{"pages":[{"path":"tags/index.html","text":""},{"path":"about/index.html","text":"唐玉龙 ##个人信息 性 别：男 年 龄：34 手 机：18996195388 邮 箱：&#49;&#x31;&#48;&#x34;&#x36;&#x35;&#51;&#x32;&#x36;&#50;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#109; 学校：重庆交通大学(非全) 本科 专 业：计算机科学与技术 工作年限：7年app&amp;1年framework 岗 位：Android研发工程师 博客：https://cq-tyl.github.io 简书：https://www.jianshu.com/u/517b3c07af90 ##专业技能 8年互联网开发经验(7年app&amp;1年framework)，精通Java语言，了解C语言，并熟悉SDK及NDK、JNI开发； 熟悉安卓系统架构，熟悉Android系统启动流程，熟悉IMS,了解WMS，AMS模块； 熟悉画中画、分屏、自由窗口,了解SystemUl,Launcher3等系统应用的定制开发； 熟悉winscop,perfetto,systrace,Profile,adb,logcat,dumpsys等常用调试工具； 熟悉Binder,Aidl,socket等跨进程通信; 熟练处理冻屏、闪黑、不开机、重启、死机、黑屏、定屏、ANR、Crash等问题; 熟悉app组件化开发、jetpack及各种安卓开发组件； 熟悉app性能优化、屏幕适配、进程保活、软件稳定性处理； 熟悉git,svn,as,asfp,vscode,vim等常用开发工具； 能够解决Framework层的定制问题并熟悉Android APK及Android系统应用的开发流程，拥有良好的表达能力与沟通能力,工作积极主动,能尽心尽责地完成本职工作. 热衷于移动互联的垂直领域,对Hal及bsp方向有着浓厚的兴趣； ##工作经历 重庆捷旭科技有限公司 2020.03-至今 Android工程师 重庆国狮科技有限公司 2018.06-2020.02 Android组负责人 重庆全心协力科技有限公司 2016.04-2018.06 Android工程师 ##重点项目经历 捷宇M32-rk3566-android13_r6 framework定制开发 项目简介：定制M32信息交互终端设备，集成身份核验、电子签名、指纹采集、社保卡读写、二维码扫描、高拍仪、服务评价、数据加密等功能的设备，能有效实现业务无纸化办理，应用于电子政务、医保社保、卫生健康、公共服务等智慧办公、身份核验及签批审核无纸化等领域。 项目地址：http://www.fjjieyu.com/product/index/133 项目职责：framework定制及bug处理 需求&amp;技术： 画中画、分屏、自由窗口; 冻屏bug处理 壁纸切换闪黑bug解决 内置系统apk应用实现不可退出不可卸载的需求； 修改开关机动画为云上共享法庭的启动动画； app无root执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）; 云上共享法庭APP开发 项目简介：重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，已在各级法院正式投入使用并繁衍出多种不同的定制版本； 项目地址：https://www.jetshine.com.cn/product.html?id=1520657316474638337 项目职责：独立负责该项目的法官&#x2F;当事人&#x2F;签字端&#x2F;手机端&#x2F;电视端的Android开发及适配任务； 需求&amp;技术： 组件化+mvp架构实现多身份多模块解耦； Jetpack+Retrofit+AutoSize+第三方硬件厂商sdk对接完成技术功能； profile+perfetto+systrace+leakcanary保障app性能； monkey+自定义异常收集类保障应用稳定性； 出行加司机&amp;乘客 android开发 项目简介：一款专用于出行加网约车平台司机接单,网约车乘客派单的应用，根据司机注册公司及车辆信息，可动态接取不同类型的网约车订单，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用，该应用已繁衍出小巷约车应用； 项目地址：https://www.dacheruanjian.cn/index.html 项目职责：独立负责该项目的乘客及司机端的开发及适配任务； 需求&amp;技术： Jetpack+Okhttp+AutoSize+高德&#x2F;微信&#x2F;支付宝等第三方api; https双向验证+ssl证书 进程保活+Sentry自动打包 完整项目经历地址： https://cq-tyl.github.io/wiki/其他笔记/我的简历/完整项目经历/"},{"path":"categories/index.html","text":""}],"posts":[{"path":"wiki/其他笔记/我的简历/完整项目经历/","text":"###项目经历 重庆捷旭科技有限公司 2021.02-至今 Android工程师 捷宇rk3566-android13_r6 framework定制开发 产品简介：http://www.fjjieyu.com/product/index/133 1.将云法庭apk内置成系统应用并实现不可退出不可卸载的需求；2.修改开关机动画为云上共享法庭的启动动画；3.app执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;4.实现带鱼屏宽屏的分屏场景-双屏动画切换移动功能；5.冻屏bug处理6.壁纸切换闪黑bug解决 云上共享法庭 android开发重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，独立负责里面的内网法官&#x2F;当事人&#x2F;签字端&#x2F;手机端&#x2F;电视端的开发及适配处理； 信息发布 android开发类似与广告机的应用，动态实现图片&#x2F;音视频&#x2F;文字&#x2F;定制布局等不同场景的展示及开机自启和自动升级等功能； 案件排期 android开发一款基层法院窗口信息显示应用，通过与条屏厂家对接实现条屏的适配显示窗口信息等； 傲视取号机 android开发一款基层法院取号应用，通过与硬件厂家对接实现刷身份证，取号，叫号，切纸等操作； 重庆国狮科技有限公司 2018.02-2019.03 Android组负责人 出行加司机 android开发一款专用于出行加网约车平台司机接单应用,根据司机注册公司及车辆信息，可动态接取不同类型的网约车订单，该应用已繁衍出小巷约车应用。 出行加乘客 android开发一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用 项目名称： 商务司机一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用 文具购（二次开发 Android是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能 vaptcha手势验证 android开发公司接的一个外包项目，android应用的第三方库开发，识别并计算出用户的手势滑动坐标并上传至后台返回完成手势验证。Vaptcha Sdk文档 https &#x2F;&#x2F;www.jianshu.com/p/1b72ea2142c2 富山 android开发类似于梦想打卡的投资类项目，主体由android原生结合webView完成，该项目完成周期仅用了3个星期的时间并通过招商等形式繁衍出了富海应用。 完美日程 android开发一款仿谷歌日历的本地日历应用，已完成大部分业务逻辑，包含了自定义日历视图，本地日历活动同步，节假日的动态显示以及用户自定义个人目标等功能。 梦想打卡 android开发一款提供给用户在固定时间进行签到的应用，用户可选择参与不同的打卡签到活动，在指定时间完成签到则获得现金奖励，该项目通过招商等形式已繁衍出喔喔打卡&#x2F;星星打卡等应用。 重庆全心协力科技有限公司 2016.04-2018.02 Android工程师 现场云 android开发是公司自己的项目（已维护更新5个版本），打造的一款提升工厂生产效率，旨 在避免问题产生到问题解决无人监管无人记录导致同一问题反复出现或无人处 理的情况，兼具点检和报表统计，即时聊天等功能。 文具购（二次开发） android开发是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能 健康西南 android开发是在医事通平台下，西南医院的一款App，也集合了预约挂号、导医、查询等 功能。 小马医疗 android开发一款为以医疗、推广为主的App。主要功能有预约挂号、健康咨询、健康商城 等。分四个主界面全部用原生的页面撰写，其余二级页面加载网页 医事通 android开发广州市卫生信息服务平台的手机版，为用户更方便快捷的提供预约挂号服务","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"我的简历","slug":"其他笔记/我的简历","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/"}]},{"path":"wiki/其他笔记/我的简历/Framework简历/","text":"####个人信息 姓名：唐玉龙 状态：在职 性 别：男 年 龄：34 手 机：18996195388 邮 箱：&#x31;&#49;&#48;&#52;&#54;&#53;&#51;&#50;&#54;&#50;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d; 学校：重庆交通大学(非全) 本科 专 业：计算机科学与技术 工作年限：7年app&amp;1年framework 岗 位：Android研发工程师 博客：https://cq-tyl.github.io 简书：https://www.jianshu.com/u/517b3c07af90 ####专业技能 8年互联网开发经验(7年app&amp;1年framework)，熟悉Android、Java，了解C++； 熟悉安卓系统架构，熟悉Android系统启动流程，熟悉IMS,了解WMS，AMS模块； 熟悉画中画、分屏、自由窗口,了解SystemUl,Launcher3等系统应用的定制开发； 熟悉winscop,perfetto,systrace,Profile,adb,logcat,dumpsys等常用调试工具； 熟悉Binder,Aidl,socket等跨进程通信; 熟练处理冻屏、闪黑、黑屏、定屏、ANR、Crash等问题; 熟悉app组件化开发、jetpack及各种安卓开发组件； 熟悉app性能优化、屏幕适配、进程保活、软件稳定性处理； 熟悉git,svn,as,asfp,vscode,vim等常用开发工具； 能够解决Framework层的定制问题并熟悉Android APK及Android系统应用的开发流程，拥有良好的表达能力与沟通能力,工作积极主动,能尽心尽责地完成本职工作. 热衷于移动互联的垂直领域,对Hal及bsp方向有着浓厚的兴趣； ####工作经历 重庆捷旭科技有限公司 2020.03-至今 Android工程师 重庆国狮科技有限公司 2018.06-2020.02 Android组负责人 重庆全心协力科技有限公司 2016.04-2018.06 Android工程师 ####重点项目经历 捷宇M32-rk3566-android13_r6 framework定制开发 项目简介：定制M32信息交互终端设备，集成身份核验、电子签名、指纹采集、社保卡读写、二维码扫描、高拍仪、服务评价、数据加密等功能的设备，能有效实现业务无纸化办理，应用于电子政务、医保社保、卫生健康、公共服务等智慧办公、身份核验及签批审核无纸化等领域。 项目地址：http://www.fjjieyu.com/product/index/133 项目职责：framework定制及bug处理 需求&amp;技术： 画中画、分屏、自由窗口; 冻屏bug处理 壁纸切换闪黑bug解决 内置系统apk应用实现不可退出不可卸载的需求； 修改开关机动画为云上共享法庭的启动动画； app无root执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）; 云上共享法庭APP开发 项目简介：重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，已在各级法院正式投入使用并繁衍出多种不同的定制版本； 项目地址：https://www.jetshine.com.cn/product.html?id=1520657316474638337 项目职责：独立负责该项目的法官&#x2F;当事人&#x2F;签字端&#x2F;手机端&#x2F;电视端的Android开发及适配任务； 需求&amp;技术： 组件化+mvp架构实现多身份多模块解耦； Jetpack+Retrofit+AutoSize+第三方硬件厂商sdk对接完成技术功能； profile+perfetto+systrace+leakcanary保障app性能； monkey+自定义异常收集类保障应用稳定性； 出行加司机&amp;乘客 android开发 项目简介：一款专用于出行加网约车平台司机接单,网约车乘客派单的应用，根据司机注册公司及车辆信息，可动态接取不同类型的网约车订单，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用，该应用已繁衍出小巷约车应用； 项目地址：https://www.dacheruanjian.cn/index.html 项目职责：独立负责该项目的乘客及司机端的开发及适配任务； 需求&amp;技术： Jetpack+Okhttp+AutoSize+高德&#x2F;微信&#x2F;支付宝等第三方api; https双向验证+ssl证书 进程保活+Sentry自动打包 完整项目经历地址： https://cq-tyl.github.io/wiki/其他笔记/我的简历/完整项目经历/","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"我的简历","slug":"其他笔记/我的简历","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/"}]},{"path":"wiki/Android进阶/MVC、MVP、MVVM架构/","text":"01 架构介绍先来看一下MVC、MVP、MVVM的架构图。 从这些架构图中，可以看到每种架构都有3个模块以及数据流动方向箭头。 模块 在系统架构中，首先要做的就是把系统整体按照一定的原则划分成模块。 数据流动 模块划分之后，模块之间的通信，就是数据的流动。在Android中，流动数据包括两部分，事件和数据。 架构 模块和模块之间的数据通信方式构成不同的架构。在这3种架构中，都是把系统整体划分成了3个模块：视图层，数据层，业务层。 他们之间的区别在于，模块之间的通信方式（数据流动方向）不一致。 MVC是视图层接收到事件后调用到业务层处理业务逻辑，业务层调用数据层处理数据，数据层再调用视图层更新页面。 MVP是视图层接收到事件后调用到业务层处理，业务层调用数据层处理数据，数据层处理数据后回调给业务层，业务层再回调给视图层更新页面。（数据层已不再持有视图层，他们之间通过业务层（Presenter）交互，具体使用接口实现，使数据层和视图层解耦。 MVVM在MVP的基础上实现了视图层和业务层的双向数据绑定（data binding），不再通过接口的方式交互，ViewModel不在和Presenter一样持有视图层，使视图层和业务层解耦。 02 具体实现MVC 视图层：在MVC架构中， Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理。需要和Activity一起才能够构成一个完整的视图层。 业务层：大多数的MVC架构开发的安卓项目， 并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，这就是MVC的缺点之一。 在本例中，我们会将业务层独立出来，实现一个标准的MVC架构。 数据层：数据层Model指的是，数据管理模块，这包括了数据的获取，处理。存储等。 MVP、MVVM的架构中的Model也是一样。后面不再赘述。 代码结构 xml代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/ll_gallery_outer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_result&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; /&gt; &lt;EditText android:id=&quot;@+id/tv_account&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_marginRight=&quot;16dp&quot; android:gravity=&quot;center&quot; android:hint=&quot;输入用户名&quot; /&gt; &lt;EditText android:id=&quot;@+id/tv_pwd&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:gravity=&quot;center&quot; android:hint=&quot;输入密码&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:gravity=&quot;center&quot; android:text=&quot;登录&quot; /&gt;&lt;/LinearLayout&gt; Activity代码 public class MVCActivity extends AppCompatActivity &#123; TextView tvResult; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); tvResult = findViewById(R.id.tv_result); TextView tvAccount = findViewById(R.id.tv_account); TextView tvPwd = findViewById(R.id.tv_pwd); Button btnLogin = findViewById(R.id.btn_login); MVCController mvcController = new MVCController(); btnLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mvcController.login(tvAccount.getText().toString(),tvPwd.getText().toString(), MVCActivity.this); &#125; &#125;); &#125; public void loginSuccess()&#123; tvResult.setText(&quot;登录结果：登录成功&quot;); &#125; public void loginFail()&#123; tvResult.setText(&quot;登录结果：登录失败&quot;); &#125; &#125; ​ Controller代码 public class MVCController &#123; MVCModel mvcModel; public MVCController() &#123; mvcModel = new MVCModel(); &#125; public void login(String account, String pwd, MVCActivity loginActivity) &#123; mvcModel.login(account, pwd, loginActivity); &#125; &#125; ​ Model代码 public class MVCModel &#123; public void login(String account, String pwd, MVCActivity loginActivity)&#123; if (account == null || account.length()==0) &#123; loginActivity.loginFail(); &#125; if (pwd == null || pwd.length()==0) &#123; loginActivity.loginFail(); &#125; if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd))&#123; loginActivity.loginSuccess(); &#125; &#125; &#125; 实现代码说明在Activity中监听登录按钮的事件，接收到事件之后，调用Controller的登录方法处理登录逻辑，在Controller的登录方法中调用Model请求网络数据（这里是模拟）判断是否登录成功，Model拿到登录结果后，调用Activity的方法刷新页面数据，展示登录结果。 优缺点优点：通过划分模块的方式，将系统分成了3个模块，视图层，业务层和数据层。 代码开发实现不再是只在一个代码文件中，一定程度便于程序开发。 缺点：但是三个模块之间还存在很强的耦合关系。 不利于业务需求的更变和代码维护工作。 MVP MVP架构是基于MVC的改进，将MVC的中Controller独立出来作为Presenter。 xml和Activity还是作为视图层， 视图层接收到页面数据，调用Presenter进行业务逻辑处理，Presenter调用Model进行数据处理，Model回传数据给Presenter，Presenter回传数据给View。数据的回传通过接口回调的方式来实现。 代码结构 IModel接口代码 public interface IModel &#123; public boolean login(String account, String pwd); &#125; ​ IView接口代码 public interface IView &#123; public void loginSuccess(); public void loginFail(); &#125; ​ Activity代码 public class MVPActivity extends AppCompatActivity implements IView &#123; TextView tvResult; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); tvResult = findViewById(R.id.tv_result); TextView tvAccount = findViewById(R.id.tv_account); TextView tvPwd = findViewById(R.id.tv_pwd); Button btnLogin = findViewById(R.id.btn_login); MVPPresenter presenter = new MVPPresenter(); presenter.setiView(this); btnLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; presenter.login(tvAccount.getText().toString(), tvPwd.getText().toString()); &#125; &#125;); &#125; public void loginSuccess() &#123; tvResult.setText(&quot;登录结果：登录成功&quot;); &#125; public void loginFail() &#123; tvResult.setText(&quot;登录结果：登录失败&quot;); &#125; &#125; Model代码 public class MVPModel implements IModel &#123; public boolean login(String account, String pwd) &#123; if (account == null || account.length() == 0) &#123; return false; &#125; if (pwd == null || pwd.length() == 0) &#123; return false; &#125; if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123; return true; &#125; return false; &#125; &#125; Presenter代码 public class MVPPresenter &#123; MVPModel model; public MVPPresenter() &#123; model = new MVPModel(); &#125; IView iView; public void setiView(IView iView) &#123; this.iView = iView; &#125; public void login(String account, String pwd) &#123; boolean loginResult = model.login(account, pwd); if (loginResult)&#123; iView.loginSuccess(); &#125;else &#123; iView.loginFail(); &#125; &#125; &#125; 实现代码说明定义了两个接口，IView和IModel, Activity和Model分别实现了这两个接口。 在Presenter中持有这两个实例。Presenter调用Model处理数据后，通过Iview的接口方法回调给Activity刷新页面。 优缺点从上面的代码可以看到，三个模块之间的通信是通过接口实现的，在实际开发，定义的接口和方法会非常多。 导致很简单的一个页面功能也需要实现多个接口和方法。 优点就是通过Presenter，把MVC中的Controller代码抽出来了，并且Presenter作为View和Model通信的桥梁，完成了Model和View的解耦。 MVVM MVVM在MVP的基础上加入了双向绑定，使View能够感知ViewModel中的数据变化，ViewModel能够感知View数据的变化。 代码结构 xml代码 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.domain.android.study.notes.architecture.mvvm.MVVMViewModel&quot; /&gt; &lt;/data&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/ll_gallery_outer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_result&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;viewModel.result&#125;&quot; android:layout_gravity=&quot;center&quot; /&gt; &lt;EditText android:id=&quot;@+id/tv_account&quot; android:layout_width=&quot;match_parent&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:layout_height=&quot;40dp&quot; android:hint=&quot;输入用户名&quot; android:gravity=&quot;center&quot; android:text=&quot;@=&#123;viewModel.account&#125;&quot; android:layout_gravity=&quot;center&quot; android:layout_marginTop=&quot;20dp&quot; /&gt; &lt;EditText android:id=&quot;@+id/tv_pwd&quot; android:layout_width=&quot;match_parent&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:layout_height=&quot;40dp&quot; android:hint=&quot;输入密码&quot; android:text=&quot;@=&#123;viewModel.pwd&#125;&quot; android:gravity=&quot;center&quot; android:layout_gravity=&quot;center&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;match_parent&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:layout_height=&quot;40dp&quot; android:text=&quot;登录&quot; android:gravity=&quot;center&quot; android:layout_gravity=&quot;center&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; Activity代码 public class MVVMActivity extends AppCompatActivity &#123; MVVMViewModel viewModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityLoginBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_login); viewModel = ViewModelProviders.of(this).get(MVVMViewModel.class); binding.setVariable(BR.viewModel, viewModel); binding.setLifecycleOwner(this); binding.btnLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; viewModel.login(); &#125; &#125;); &#125; &#125; ViewModel代码 public class MVVMViewModel extends ViewModel &#123; public ObservableField&lt;String&gt; account = new ObservableField&lt;&gt;(&quot;&quot;); public ObservableField&lt;String&gt; pwd = new ObservableField&lt;&gt;(&quot;&quot;); public ObservableField&lt;String&gt; result = new ObservableField&lt;&gt;(&quot;&quot;); MVVMModel mvvmModel; public MVVMViewModel() &#123; mvvmModel = new MVVMModel(); &#125; public void login()&#123; boolean loginResult = mvvmModel.login(account.get(), pwd.get()); result.set(loginResult ? &quot;登录结果：成功&quot; :&quot;登录结果：失败&quot;); &#125; &#125; Model代码 public class MVVMModel &#123; public boolean login(String account, String pwd) &#123; if (account == null || account.length() == 0) &#123; return false; &#125; if (pwd == null || pwd.length() == 0) &#123; return false; &#125; if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123; return true; &#125; return false; &#125; &#125; 注意 在本例MVVM架构实现中，用到了Android提供的data binding这个数据双向绑定框架。需要在APP模块的gralde文件中添加以下配置开启： android &#123; ... dataBinding &#123; enabled true &#125; ... &#125; 实现代码说明通过Android提供的数据双向绑定库data binding 将Acitvity&#x2F;xml视图层与ViewModel绑定。在xml布局文件中，通过@&#123;&#125;来表示单向绑定或者@=&#123;&#125;来表示双向绑定。Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。 注意 data binding通过观察者模式实现。 内部具体实现也是通过调用notify通知数据变化给观察者，notify调用了观察者实现的接口方法。 优缺点优点：经过数据双向绑定之后，我们不在需要想MVP中写那么多接口回调方法区实现视图层和业务层的交互。业务层也不再持有视图层的引用。 缺点：通过这种方式进行数据双向绑定后，xml中会多出一些标签、表达式、甚至和业务有点的简单计算代码。这不利于业务的逻辑的查看。并且由于双向绑定是data binding实现的。在这个过程中， 如果出现bug导致数据没有被感知改变，不方便排错，因为xml不能debug调试。 03 总结MVC、MVP、MVVM大体上都是把系统划分成3个模块：视图层、业务层、数据层。 但是他们的通信方式、数据流动方向不一致，形成了不同的架构。 其后面产生的架构都是为了更好的解耦，解决已有架构的不足。每个架构都有自己的优缺点，没有最好的架构，只有最合适的架构。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"}]},{"path":"wiki/Android进阶/Jetpack/0.jetpack合集/","text":"","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/性能优化/0.app性能优化集合/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//性能优化性能优化:包括了启动，内存，布局，卡顿，网络，电量，瘦身，稳定性；性能监测平台：外网：听云，内网：自检各种性能检测机制，统一上报；//App启动优化1.获取启动耗时： 1.手动埋点，aop统一处理，systrace/traceview获取 2.优化手段：延迟加载或者异步加载(充分利用CPU，将任务放到子线程中执行分担主线程任务，jetpack的App Startup框架，或者自定义使 用线程池异步加载) //内存优化：内存优化主要体现在两个地方，第一个是内存抖动，第二个是内存泄漏1. 内存抖动： 主要是由于快速的内存创建和释放造成的，容易产生GC(Profiler);2. 内存泄漏：主要是由于长生命周期的引用了短生命周期的对象造成的(leakcary);3. 检测方式：AS的Profiler（Memory Profiler/Memory Analyzer）主动检测，leakcary被动的自动检测；//布局优化1. 绘制时长检测： 1.AOP（面向切面编程,在指定的地方执行特定的代码）的方式获取每个界面的绘制耗时; 1.Systrace查看整体绘制情况，查看是否存在绘制耗时等情况； 2.as自带的布局检测工具Inspector，查看视图层次结构；2.如存在io加载布局文件慢 1.使用AsyncLayoutInflater/X2C异步加载布局3. 布局层级:减少布局层级，减少过度绘制 1.减少View树层级 2.宽而浅，避免窄而深 3.尽量使用 ConstraintLayout布局控件 2.gpu过度绘制//开发者选项-调试gpu过度绘制打开设置 1.一个像素最好只被绘制一次 2.调试GPU过度绘制 3.蓝色可接受 3. 卡顿的原因就是CPU数据处理不过来，比如层级过深，CPU太忙，GC，之类的，可以通过systrace 工具进行检测， 然后通过编舞者监测帧率定位时间，再然后可以通过looper的日志功能定位到卡顿点。网上也有库blockcanary 3.在Systrace 报告中，你可以查看应用程序布局绘制的相关事件，包括布局计算、绘制命令的发送、GPU 图形呈现等阶段所花费的时间 //卡顿优化1.硬件性能导致卡顿：CPU Profiler/Systrace 分析查看CPU利用率2.使用blockcanary可以实现自动化监测卡顿3.anr检测：ANR-WatchDog，logcat/trace.txt日志分析信息//网络优化1.网络缓存： 1.服务端返回加上过期时间，避免每次重新获取 2.OkHttp、Retfort、Volley都有较好实践 3.无网络时展示数据缓存；2.网络质量： 1.时长、业务成功率、失败率的统计，在OkHttp、Retfort、Volley等自行统计相关数据并在特定场景合并上报； 2.弱网络模拟3.增量更新： 1.加上版本的概念，只传输有变化的数据4.数据压缩: 1.Post请求Body使用GZip压缩(字符压缩) 2.图片上传之前必须压缩5.图片相关： 1.图片使用策略细化:优先缩略图 2.使用WebP格式图片//电量优化1.电量优化检测方案： Battery Historian - Google推出的一款Android系统电量分析工具 - 支持50(API21)及以上系统的电量分析 - 功能强大，推荐使用 - 可视化展示指标:耗电比例、执行时间、次数 - 适合线下使用2.电量优化套路总结： 1.网络相关:控制请求时机及次数,数据压缩，减少时间 2.传感器相关: 1.根据场景谨慎选择定位模式 2.考虑网络定位代替GPS 3.使用后务必及时关闭，减少更新频率 //瘦身优化1.代码混淆，统一三方库、删除无用代码2.资源在线化3.So:只保留Armeabi、或者只保留armeabi-v7a、arm64-v8a4. 图片优化： 1.根据场景使用不同的文件，比如将png换成webp，像什么需要来回改变的简单的图可以使用svg替换，去除不需要的图片资源 2.图片压缩5. 备用资源：默认情况下Android会有很多备用资源，比如string，包含了多国语言，我们可以指定需要的语言即可；//稳定性优化1.统一编码规范、增强编码功底、技术评审2.架构优化:统一容错，功能模块解耦3.回归测试，压力测试，兼容性测试，4.容灾方案：热更新(bugly),功能开关，崩溃后自启等","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/WMSAMS/4.WMS窗口相关流程/","text":"4.WMS窗口相关流程一、介绍什么是窗口窗口即是屏幕上的一块用于绘制各种UI元素并可以响应用户输入的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。Window是个抽象类其实现类为PhoneWindow。本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。其他建议：可以先学习层级结构树相关内容，有助于对窗口模块的理解Android T 窗口层级其一 —— 容器类Android T 窗口层级其二 —— 层级结构树的构建Android T 窗口层级其三 —— 层级结构树添加窗口 二、流程简述当Activity.onResume()被调用之后，客户端会与WMS进行通信将我们的布局显示在屏幕上。其中主要涉及以下几个过程：客户端通知WMS创建一个窗口，并添加到WindowToken。即addToDisplayAsUser阶段。客户端通知WMS创建Surface，并计算窗口尺寸大小。即relayoutWindow阶段。客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度。即performMeasure阶段。客户端确定该窗口下View的尺寸和位置。即performLayout阶段。确定好View的尺寸大小位置之后，便对View进行绘制。即performDraw阶段。通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来。即reportDrawFinished阶段。这里以Activity.onResume()被调用之后为起点 1.客户端WindowManager：是一个接口类，负责窗口的管理（增、删、改）。 WindowManagerImpl：WindowManager的实现类，但是他把对于窗口的具体管理操作交给WindowManagerGlobal来处理。 WindowManagerGlobal：是一个单例类，实现了窗口的添加、删除、更新的逻辑，但是 ViewRootImpl：通过IWindowSession与WMS进行通信。其内部类W实现了WMS与ViewRootImpl的通信。 ActivityThread.java handleResumeActivity通过WindowManager接口添加view，即wm.addView(decor, l);，wm为ViewManager对象，即ViewManager wm = a.getWindowManager(); WindowManagerImpl.java addViewmGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,mContext.getUserId());mGlobal为WindowManagerGlobal对象。 WindowManagerGlobal.java addViewroot.setView(view, wparams, panelParentView, userId);root为ViewRootImpl对象。parentWindow.adjustLayoutParamsForSubWindow(wparams);parentWindow为Window（Window为抽象类，PhoneWindow继承于Window），即在Window中调用adjustLayoutParamsForSubWindow，用于赋值参数布局的token以及title ViewRootImpl.java setView1.addToDisplayAsUser客户端通知WMS创建一个窗口，并添加到WindowTokenres = mWindowSession.addToDisplayAsUser(mWindow,mWindowAttributes,getHostVisibility(), mDisplay.getDisplayId(), userId,mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,mTempControls);2.requestLayout在添加到窗口管理器之前安排第一个布局，以确保我们在从系统接收任何其他事件之前进行重新布局scheduleTraversals-&gt;doTraversal-&gt;performTraversalsperformTraversals中调用了五个关键方法：relayoutWindow客户端通知WMS创建Surface，并计算窗口尺寸大小performMeasure客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度performLayout客户端确定该窗口下View的尺寸和位置performDraw确定好View的尺寸大小位置之后，便对View进行绘制createSyncIfNeeded-&gt;reportDrawFinished通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来 2. 通信方式Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。 IWindowSession.aidlViewRootImpl中通过此接口调用服务端1.addToDisplayAsUser2.relayout3.finishDrawing Session.javaIWindowSession的实现在这里，最终调用到WMS中1.addToDisplayAsUser-&gt;addWindow2.relayout-&gt;relayoutWindow3.finishDrawing-&gt;finishDrawingWindow 3. 服务端WindowManagerService：负责为Activity对应的窗口分配Surface，管理Surface的显示顺序以及位置尺寸，控制窗口动画，并且还是输入系统的一个重要中转站。 WindowState：和客户端窗口一一对应，在向WMS添加一个窗口时，WMS会为其创建一个WindowState，来表示窗口的所有属性，WindowState相当于属性窗口管理（比如对外提供操作接口，属于层级结构中最底部的容器），窗口画面相关都剥离给了WindowStateAnimator，WindowState也是WMS中事实上的窗口。 WindowStateAnimator：主要用于管理WindowState相关画面surface，通过mDrawState参数来描述Surface所处的状态。 WindowToken：保存了所有具有同一个token的WindowState，将属于同一个activity的窗口组织在一起，activity在需要更新窗口时，必须向WMS提供WindowToken以表名自己的身份，并且窗口的类型必须与所持有的的WindowToken类型一致。补充：一个WindowToken可以对应多个WindowState。 WindowToken是一个用于表示窗口层次结构中的窗口的标识符。每个Window具有一个与之关联的WindowToken，它用于帮助系统管理窗口的显示和交互。一个WindowToken可以有多个WindowState表示与之相关的窗口。这是因为在Android系统中，可能会存在一些特殊情况，例如PopupWindow、Dialog等，它们属于同一个WindowToken，但是显示在不同的窗口上。因此，一个WindowToken可以与多个WindowState关联，这样可以实现多个窗口的操作和管理。 WindowSurfaceController：用来创建SurfaceControl。 DisplayContent：即代表的是单个屏幕。隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每个DisplayContent都对应着一个唯一的id，在添加窗口时可以通过指定这个ID决定将其显示在哪个屏幕中。 WindowSurfacePlacer：整个窗口层次结构刷新的入口。 RootWindowContainer：是窗口容器的顶层容器，其直接管理DisplayContent。 WindowManagerService.java 3.1.addWindow1.根据客户端传来的token获取WindowToken或创建WindowToken，并将其挂载到对应的层级节点上WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);判断WindowToken是否有父亲,即parentWindow 是否不为空final boolean hasParent = parentWindow != null;注：前面代码有判断是否是子窗口，是则会给parentWindow 赋值；否则parentWindow仍为初始值，即为空关于窗口类型，见 窗口常见参数汇总Activity启动时会在ActivityRecord的构造方法中new Token()。应用侧直接通过addView的方式添加窗口不会有ActivityRecord,因此不会在ActivityRecord的构造方法中new Token()。系统侧直接添加的窗口（状态栏、导航栏等），是通过new WindowToken.Builder的方式添加即主动使用ViewManager.addView来添加一个窗口则不会在ActivityRecord的构造方法中new Token()，否则通过new WindowToken.Builder的方式添加。attrs.token这个参数一可以在应用端设置，应用没有设置token那么就为空，token为IBinder类型对象，默认值为空public IBinder token = null;例如：在应用侧可通过mLayoutParams.token的方式设置值private WindowManager.LayoutParams mLayoutParams;mLayoutParams.token = null; 后面会继续判断token是否为空,最终会到最后的else中创建token2.创建WindowStatefinal WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId,session.mCanAddInternalSystemWindow);3.验证当前窗口是否可以添加到WMSres = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);该方法会对窗口TYPE,FLAG等多方面判断。只有返回ADD_OKAY时表示允许当前窗口的添加，反之则不允许添加该窗口。假如想禁止某些应用做添加窗口操作时，可以在里面通过应用的包名过滤该应用，也可以直接在WindowManagerGlobal.java的addView()方法中直接对应用想要添加的窗口进行过滤。注：ADD_OKAY在WindowManagerGlobal中定义，这个类里面还有一些其他的返回值，所有返回给res的常量最终会在ViewRootImpl的setView方法中判断4.调用openInputChannel，初始化input相关通路（本文不做讨论）final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125;5.将WindowState加入到WindowTokenwin.mToken.addWindow(win);WMS窗口添加之后，还没有创建Surface，此时mDrawState状态为NO_SURFACE 3.2 relayoutWindow1.根据客户端传递过来的IWindow的mWindowMap获取窗口添加阶段创建的WindowStatefinal WindowState win = windowForClientLocked(session, client, false);2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位win.setDisplayLayoutNeeded();win为WindowState对象，该方法实际操作在DisplayContent中final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;(win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || win.mActivityRecord.isClientVisible());3.创建SurfaceControl在layoutWindow()调用了createSurfaceControl方法创建SurfaceControlresult = createSurfaceControl(outSurfaceControl, result, win, winAnimator);该方法的实现仍然在WMS中这里以createSurfaceControl方法为起点在createSurfaceControl()中调用WindowStateAnimator执行具体的SurfaceControl的创建 surfaceController = winAnimator.createSurfaceLocked();创建Surface后，Surface还未进行绘制，此时mDrawState状态为DRAW_PENDING将创建的SurfaceControl赋值给客户端的outSurfaceControlsurfaceController.getSurfaceControl(outSurfaceControl);4.窗口尺寸的计算以及Surface状态更新在layoutWindow()调用了performSurfacePlacementmWindowPlacerLocked.performSurfacePlacement(true /* force */);mWindowPlacerLocked为WindowSurfacePlacer对象，因此这里以WindowSurfacePlacer的performSurfacePlacement()为起点处理窗口布局循环WindowSurfacePlacer.performSurfacePlacementLoop()处理Surface的状态更变，以及调用LayoutWindowLw的流程RootWindowContainer.performSurfacePlacementNoTrace()计算窗口位置大小DisplayPolicy.layoutWindowLw() 3.3 finishDrawingWindow 1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PEDINGwin.finishDrawing(postDrawTransaction, seqId),并请求窗口布局mWindowPlacerLocked.requestTraversal();2.通过mApplySurfaceChangesTransaction的callback， 调用commitFinishDrawingLocked()改变mDrawState状态将mDrawState更新为READY_TO_SHOW,最终mDrawState更新为HAS_DRAW后，再次请求窗口布局3.执行show SurfaceshowSurfaceRobustlyLocked(t)注：WindowStateAnimator的commitFinishDrawingLocked()方法中，如果是应用通过WindowManager中的addView的方式创建窗口，则不会有ActivityRecord，或者该窗口类型为启动窗口，则直接调用result = mWin.performShowLocked();，即WindowState的performShowLocked()方法改变窗口状态为HAS_DRAW，否则会从RootWindowContainer的checkAppTransitionReady方法逐步调用到performShowLocked() 4.窗口状态变化总结WMS为了管理窗口的显示进度，在WindowStateAnimator中定义了mDrawState来描述Surface所处的状态。主要有如下五种状态：NO_SURFACE:WMS添加窗口,即调用addWindow之后，还没有创建Surface，mDrawState处于该状态。DRAW_PENDING:app调用relayoutWindow创建Surface后，但是Surface还没有进行绘制，mDrawState处于该状态。COMMIT_DRAW_PENDING:app完成Surface的绘制，调用finishDrawing，将mDrawState设置为该状态。READY_TO_SHOW:在performSurfacePlacement过程中会将所有处于COMMIT_DRAW_PENDING状态的mDrawState变更为READY_TO_SHOW。HAS_DRAW:若准备显示窗口，WMS执行performShowLocked，将mDrawState设置为该状态 窗口显示相关方法 工作内容解释 addWindow App向WMS请求添加窗口记录，会在WMS里新建WindowState(NO_SURFACE) relayoutWindow App向WMS申请surface用于绘制，执行后window拥有了surface(NO_SURFACE-&gt;DRAW_PENDING) finishDrawingWindow App在surface上完成绘制后，通知WMS(DRAW_PENDING-&gt;COMMIT_DRAW_PENDING) commitFinishDrawingLocked WMS遍历window，对于完成绘制的window(COMMIT_DRAW_PENDING-&gt;READY_TO_SHOW) performShowLocked 判断系统是否允许窗口显示isReadyForDisplay(READY_TO_SHOW-&gt;HAS_DRAWN) showSurfaceRobustlyLocked 对HAS_DRAWN状态的窗口，用SurfaceControl通知SurfaceFlinger显示出来 5.移除流程简述窗口移除从App端发起，当Activity执行destroy(),即以handleDestroyActivity()为起点，执行wm.removeViewImmediate()开启；通过WindowManagerGlobal–&gt;ViewRootImpl–&gt;Session–&gt;WindowManagerService的removeWindow()，调用到WindowState的removeIfPossible()–&gt;removeImmediately()，接着调用到WindowStateAnimator的destroySurfaceLocked()–&gt;destroySurface(),逐步调用改变绘制状态为NO_SURFACE–&gt;WindowSurfaceController的destroy()最终调用到SurfaceControl的remove()来通知SurfaceFlinger来移除layer； 三、代码流程详解1.客户端1.1 Activity走到onresume后从ActivityThread.handleResumeActivity方法看起1.调用performResumeActivity，执行onResume。2.获取WindowManager的实现类WindowManagerImpl的实例。3.调用WindowManagerImpl.addView传入DecorView和当前布局参数WindowManager.LayoutParams。代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java @Override public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest, boolean isForward, String reason) &#123; ...... // TODO Push resumeArgs into the activity for consideration // skip below steps for double-resume and r.mFinish = true case. /*1.执行onResume*/ if (!performResumeActivity(r, finalStateRequest, reason)) &#123; return; &#125; ...... //获取Activity实例 final Activity a = r.activity; ...... // If the window hasn&#39;t yet been added to the window manager, // and this guy didn&#39;t finish itself or start another activity, // then go ahead and add the window. //mStartedActivity在performLaunchActivity和performResumeActivity方法中被置为false boolean willBeVisible = !a.mStartedActivity; ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //获取当前Activity的PhoneWindow r.window = r.activity.getWindow(); //从PhoneWindow中获取DecorView View decor = r.window.getDecorView(); //将view的可见性状态设置为INVISIBLE,view不可见但是仍然占用布局空间 decor.setVisibility(View.INVISIBLE); /*2.获取WindowManager的实现类WindowManagerImpl的实例*/ ViewManager wm = a.getWindowManager(); //获取布局参数 WindowManager.LayoutParams l = r.window.getAttributes(); //将phoneWindow的DecorView赋值给mDecor a.mDecor = decor; //设置窗口类型为TYPE_BASE_APPLICATION l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; /*3.传入DecorView和当前布局参数WindowManager.LayoutParams*/ wm.addView(decor, l); &#125; else &#123; // The activity will get a callback for this &#123;@link LayoutParams&#125; change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); &#125; &#125; &#125; ...... &#125; wm.addView(decor, l);WindowManager接口的实现是WindowManagerImpl，即实际调用的是WindowManagerImpl中的addView方法代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerImpl.java @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyTokens(params); //转交给windowManagerGlobal，添加view mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId()); &#125; WindowManagerImpl对窗口的管理交给WindowManagerGlobal，调用WindowManagerGlobal的addView方法WindowManagerGlobal中对窗口的处理主要如下几个步骤：1.对WindowManagerImpl传进来的参数进行检查。2.设置WindowManager.LayoutParams中的token、title等相关属性。查看“【1.2 Token的创建与传递】”。3.创建ViewRootImpl对象，并获取客户端与WMS通信的Session。查看“【1.3 ViewRootImpl的创建】”。4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。5.调用ViewRootImpl，与WMS通信添加窗口。查看“【1.4 ViewRootImpl与WMS的通信】”。代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; /*1.对WindowManagerImpl传进来的参数进行检查*/ if (view == null) &#123; throw new IllegalArgumentException(&quot;view must not be null&quot;); &#125; if (display == null) &#123; throw new IllegalArgumentException(&quot;display must not be null&quot;); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; //此处的ParentWindow即当Activity的PhoneWindow if (parentWindow != null) &#123; /*2.为wparams的token进行赋值*/ parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; ...... &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... IWindowSession windowlessSession = null; ...... if (windowlessSession == null) &#123; /*3.新建ViewRootImpl，在新建时会通过WindowManagerGlobal获取session*/ root = new ViewRootImpl(view.getContext(), display); &#125; else &#123; root = new ViewRootImpl(view.getContext(), display, windowlessSession); &#125; view.setLayoutParams(wparams); /*4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。*/ //当前view加入到view列表中 mViews.add(view); //将新建的viewRootImpl加入到root列表中 mRoots.add(root); //将当前布局参数加入到布局参数列表中 mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; /*5.调用ViewRootImpl，设置view，panelParentView为null，与WMS通信添加窗口*/ root.setView(view, wparams, panelParentView, userId); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; 1.2 Token的创建与传递parentWindow.adjustLayoutParamsForSubWindow(wparams);调用Window的adjustLayoutParamsForSubWindow()方法在adjustLayoutParamsForSubWindow中会分别对WindowManager.LayoutParams中的token以及title进行赋值。1.首先针对子窗口、系统窗口以及应用窗口做了不同的处理，此处我们只关注应用窗口的处理。2.其次将当前PhoneWindow.mAppToken赋值给WindowManager.LayoutParams.token。代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java void adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123; CharSequence curTitle = wp.getTitle(); if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; //对子窗口的Token以及Title赋值 ...... &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123; //对子窗口的Token以及Title赋值 ...... &#125; else &#123; //对应用窗口的Token以及Title赋值 if (wp.token == null) &#123; //将当前PhoneWindow的mAppToken赋值给wp.Token wp.token = mContainer == null ? mAppToken : mContainer.mAppToken; &#125; //将Title设置为mAppName if ((curTitle == null || curTitle.length() == 0) &amp;&amp; mAppName != null) &#123; wp.setTitle(mAppName); &#125; &#125; //设置为packageName if (wp.packageName == null) &#123; wp.packageName = mContext.getPackageName(); &#125; ...... &#125; 此处的mAppToken便是在Activity启动时，在ATMS端创建的Token。接下来我们看看Token是如何从ATMS端传递过来，并赋值给PhoneWindow.mAppToken的 1.在ATMS端新建ActivityRecord时，便新建了Token。并赋值给ActivityRecord.tokenActivityRecord继承WindowToken代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java private ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller, int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage, @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType, ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo, String _resultWho, int _reqCode, boolean _componentSpecified, boolean _rootVoiceInteraction, ActivityTaskSupervisor supervisor, ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState, TaskDescription _taskDescription, long _createTime) &#123; //新建Token super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true, null /* displayContent */, false /* ownerCanManageAppTokens */); ...... &#125; 2.将ActivityRecord.token封装在clientTransaction中，并将这个传递到客户端代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskSupervisor.java boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... final Task task = r.getTask(); final Task rootTask = task.getRootTask(); ...... try &#123; ...... try &#123; ...... // Create activity launch transaction. /*将ActivityRecord.token封装在clientTransaction中*/ final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.token); final boolean isTransitionForward = r.isTransitionForward(); final IBinder fragmentToken = r.getTaskFragment().getFragmentToken(); clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor, proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(), results, newIntents, r.takeOptions(), isTransitionForward, proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController, r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken)); ...... // Schedule transaction. /*将clientTransaction传递给客户端*/ mService.getLifecycleManager().scheduleTransaction(clientTransaction); ...... &#125; catch (RemoteException e) &#123; ...... &#125; &#125; finally &#123; ...... &#125; ...... return true; &#125; final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.token);在ClientTransaction中调用obtain方法，把ActivityRecord.token存到mActivityToken代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;ClientTransaction.java /** Obtain an instance initialized with provided params. */ public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123; ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class); if (instance == null) &#123; //创建ClientTransaction instance = new ClientTransaction(); &#125; instance.mClient = client; /*把ActivityRecord.token存到mActivityToken*/ //private IBinder mActivityToken; instance.mActivityToken = activityToken; return instance; &#125; 3.客户端从ClientTransaction中获取ATMS端传来的Token，并传递到LaunchActivityItem中代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;TransactionExecutor.java /** Cycle through all states requested by callbacks and execute them at proper times. */ @VisibleForTesting public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); ...... /*从ClientTransaction中获取ATMS端传来的Token*/ final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); ...... final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i); ...... /*将Token传递到LaunchActivityItem中*/ item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ...... &#125; &#125; 4.在LaunchActivityItem中将客户端传过来的Token保存在ActivityClientRecord.token中代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;LaunchActivityItem.java @Override public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); //将客户端传过来的Token保存在ActivityClientRecord的token中 ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mActivityOptions, mIsForward, mProfilerInfo, client, mAssistToken, mShareableActivityToken, mLaunchedFromBubble, mTaskFragmentToken); client.handleLaunchActivity(r, pendingActions, null /* customIntent */); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); &#125; client.handleLaunchActivity(r, pendingActions, null /* customIntent */);ClientTransactionHandler调用handleLaunchActivity方法，ClientTransactionHandler为抽象类，其子类为ActivityThread，即实际调用的是该类中的handleLaunchActivity()，有从该方法中调用到了performLaunchActivity()5.客户端ActivityThread将ActivityClientRecord以及其对应的token保存在ActivityThread.mActivities数组中，并调用Activity.attach将Token传给Activity。代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java /** Core implementation of activity launch. */ private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ...... try &#123; Application app = r.packageInfo.makeApplicationInner(false, mInstrumentation); ...... synchronized (mResourcesManager) &#123; /*将ActivityClientRecord以及其对应的Token保存在mActivities中*/ //mActivities的类型为ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities.put(r.token, r); &#125; if (activity != null) &#123; ...... /*将Token赋值给Activity.mToken*/ activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.activityConfigCallback, r.assistToken, r.shareableActivityToken); ...... &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ...... &#125; return activity; &#125; 6.在Activity中将客户端传来的Token赋值给Activity.mToken。此外在该方法中还新建了PhoneWindow,并将PhoneWindow.mAppToken也设置为客户端传过来的Token。代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Activity.java @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553) final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); /*新建PhoneWindow*/ mWindow = new PhoneWindow(this, window, activityConfigCallback); ...... /*将客户端传过来的Token赋值给mToken*/ mToken = token; ...... /*PhoneWindow.mAppToken设置为当前客户端传递过来的Token*/ mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); ...... &#125; PhoneWindow继承Window，setWindowManager实际调用的是其父类方法，把mAppToken设置为当前客户端传递过来的mToken代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java /** * Set the window manager for use by this Window to, for example, * display panels. This is &lt;em&gt;not&lt;/em&gt; used for displaying the * Window itself -- that must be done by the client. * * @param wm The window manager for adding new windows. */ public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123; //传递客户端的mToken给appToken setWindowManager(wm, appToken, appName, false); &#125; /** * Set the window manager for use by this Window to, for example, * display panels. This is &lt;em&gt;not&lt;/em&gt; used for displaying the * Window itself -- that must be done by the client. * * @param wm The window manager for adding new windows. */ public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; /*把appToken赋值给mAppToken*/ mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated; if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125; 1.3 ViewRootImpl的创建root = new ViewRootImpl(view.getContext(), display);之前在【1.1 Activity走到onresume后】的流程中有调用创建ViewRootImpl，这里我们看下ViewRootImpl的构造方法代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java public ViewRootImpl(Context context, Display display) &#123; this(context, display, WindowManagerGlobal.getWindowSession(), false /* useSfChoreographer */); &#125; public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) &#123; this(context, display, session, false /* useSfChoreographer */); &#125; public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session, boolean useSfChoreographer) &#123; mContext = context; mWindowSession = session; ...... &#125; 从这个构造方法中我们可以看出，通过WindowManagerGlobal.getWindowSession获取到客户端与WMS沟通的桥梁IWindowSession，并将其赋值给ViewRootImpl.mWindowSession。 下面我们查看WindowManagerGlobal中是如何获取Session的。1.通过getWindowManagerService获取IWindowManager，而WindowManagerService则实现了这个Binder接口。2.调用IWindowManager.openSession方法即WMS.openSession，在WMS端便会新建Session。至此客户端与WMS通信的桥梁便已经搭建好了代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java @UnsupportedAppUsage public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; // Emulate the legacy behavior. The global instance of InputMethodManager // was instantiated here. // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary(); /*1.获取Binder*/ IWindowManager windowManager = getWindowManagerService(); /*2.调用WMS的openSession*/ sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125; &#125; 从代码中可以看出如果sWindowSession不为空则直接返回，sWindowSession为当前WindowManagerGlobal属性，且WindowManagerGloba又是单例的，所以客户端一个进程中只有一个IWindowSession与WMS通信。如果sWindowSession为空，则会创建IWindowSession。 调用WindowManagerService中的openSession，新建Session代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java @Override public IWindowSession openSession(IWindowSessionCallback callback) &#123; /*新建Session*/ return new Session(this, callback); &#125; 1.4 ViewRootImpl与WMS的通信root.setView(view, wparams, panelParentView, userId);之前在【1.1 Activity走到onresume后】的流程中有调用ViewRootImpl与WMS的通信，继续看看当前方法是与WMS进行通信添加窗口的入口，在此处我们只关注两点:1.requestLayout()该方法会调用到doTraversal()，之后调用performTraversals()，最终调用到relayoutWindow()和reportDrawFinished()流程，在通过Session与服务端通信2.mWindowSession.addToDisplayAsUser，与服务端进行Binder通信，调用Session的addToDisplayAsUser方法。 /** * We have one child */ public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; setView(view, attrs, panelParentView, UserHandle.myUserId()); &#125; /** * We have one child */ public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ...... //将布局参数拷贝纸mWindowAttributes mWindowAttributes.copyFrom(attrs); //设置包名 if (mWindowAttributes.packageName == null) &#123; mWindowAttributes.packageName = mBasePackageName; &#125; mWindowAttributes.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST; attrs = mWindowAttributes; ...... // Keep track of the actual window flags supplied by the client. //获取当前布局的flags mClientWindowLayoutFlags = attrs.flags; ...... int res; /* = WindowManagerImpl.ADD_OKAY; */ // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. /*请求布局，对应服务端layoutWindow流程*/ requestLayout(); InputChannel inputChannel = null; if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; inputChannel = new InputChannel(); &#125; ...... try &#123; ...... /*与服务端进行Binder通信，调用Session的addToDisplayAsUser方法*/ //执行addWindow的相关流程 res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets, mTempControls); ...... &#125; catch (RemoteException e) &#123; ...... &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; ...... if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow); if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123; mAttachInfo.mRootView = null; mAdded = false; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); switch (res) &#123; case WindowManagerGlobal.ADD_BAD_APP_TOKEN: case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN: throw new WindowManager.BadTokenException( &quot;Unable to add window -- token &quot; + attrs.token + &quot; is not valid; is your activity running?&quot;); case WindowManagerGlobal.ADD_NOT_APP_TOKEN: throw new WindowManager.BadTokenException( &quot;Unable to add window -- token &quot; + attrs.token + &quot; is not for an application&quot;); case WindowManagerGlobal.ADD_APP_EXITING: throw new WindowManager.BadTokenException( &quot;Unable to add window -- app for token &quot; + attrs.token + &quot; is exiting&quot;); case WindowManagerGlobal.ADD_DUPLICATE_ADD: throw new WindowManager.BadTokenException( &quot;Unable to add window -- window &quot; + mWindow + &quot; has already been added&quot;); case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED: // Silently ignore -- we would have just removed it // right away, anyway. return; case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON: throw new WindowManager.BadTokenException(&quot;Unable to add window &quot; + mWindow + &quot; -- another window of type &quot; + mWindowAttributes.type + &quot; already exists&quot;); case WindowManagerGlobal.ADD_PERMISSION_DENIED: throw new WindowManager.BadTokenException(&quot;Unable to add window &quot; + mWindow + &quot; -- permission denied for window type &quot; + mWindowAttributes.type); case WindowManagerGlobal.ADD_INVALID_DISPLAY: throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot; + mWindow + &quot; -- the specified display can not be found&quot;); case WindowManagerGlobal.ADD_INVALID_TYPE: throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot; + mWindow + &quot; -- the specified window type &quot; + mWindowAttributes.type + &quot; is not valid&quot;); case WindowManagerGlobal.ADD_INVALID_USER: throw new WindowManager.BadTokenException(&quot;Unable to add Window &quot; + mWindow + &quot; -- requested userId is not valid&quot;); &#125; throw new RuntimeException( &quot;Unable to add window -- unknown error code &quot; + res); &#125; ...... &#125; &#125; &#125; 其中关键的添加代码为 res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets, mTempControls); addToDisplayAsUser()方法最终会走到WindowManagerService.java的addWindow方法，addWindow方法的返回值最后会返回给res，之后回看ViewRootImpl的setView方法，返回值如果满足if (res &lt; WindowManagerGlobal.ADD_OKAY)条件，那么会根据switch (res)中对应的case抛出异常。至此，客户端流程结束，后面进入服务端流程。 2.服务端2.1 窗口添加WMS通过Session接受客户端添加窗口的请求，因此WMS会新建WindowState、将WindowState加入到WindowToken，并更新WindowToken下所有WindowState的z-order。客户端通过Binder通信调用WMS端的Session.addToDisplayAsUser进入addWindow的流程。主要做了这三件事：1.接收客户端请求2.WindowState初始化3.WindowState加入到WIndowToken 2.1.1 接收客户端请求客户端传递给Session的参数IWindow window:是WMS与客户端通信的句柄。WindowManager.LayoutParams arrts：窗口布局参数。viewVisibility：附着在窗口的rootView的可见性。displayId：顾名思义，display id表示的是DisplayContent即屏幕的id。InsetsVisibilities requestedVisibilities:当前对象的mVisibilities记录了insets的可见性。InputChannel outInputChannel：InputDispatcher接收InputReader读取到的事件，分发给对应窗口，InputDispatcher属于system_server进程和各个应用不在同一进程，它们之间的联系靠的就是InputChannel。InsetsState outInsetsState：用来保存系统中所有Insets的状态，该对象只是在客户端创建，内部属性需要在WMS端赋值。InsetsSourceControl[] outActiveControls：InSetsSourceControl数组。该对象也是只在客户端创建，内部属性需要在WMS端赋值。Session调用WindowManagerService.addWindow 将客户端传入的参数传递给WindowManagerService。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java @Override public int addToDisplayAsUser(IWindow window, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, int userId, InsetsVisibilities requestedVisibilities, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; return mService.addWindow(this, window, attrs, viewVisibility, displayId, userId, requestedVisibilities, outInputChannel, outInsetsState, outActiveControls); &#125; 2.1.2 addWindow添加窗口的主要逻辑均在WMS.addWindow执行，该方法主要实现以下功能：1.首先进行权限验证以及各种条件判断。2.根据客户端传来的token获取windowToken。3.借助客户端传来的参数，创建WindowState实例，并将其加入到WMS. mWindowMap中。4.将新建的WindowState加入到相应的WindowToken，并为每个窗口赋值一个z-order。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsVisibilities requestedVisibilities, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... /*1.进行权限验证以及各种条件判断*/ //判断调用者是否有权限add window int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName, appOp); if (res != ADD_OKAY) &#123; return res; &#125; WindowState parentWindow = null; final int callingUid = Binder.getCallingUid(); final int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); //获取将要添加的窗口类型 final int type = attrs.type; synchronized (mGlobalLock) &#123; ...... //根据displayId以及客户端传过来的token获取相应的displayContent final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token); ...... //判断mWindowMap中是否已经存在当前客户端的key,如果有则已经将当前客户端的window添加了，无需重复添加 if (mWindowMap.containsKey(client.asBinder())) &#123; ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client); return WindowManagerGlobal.ADD_DUPLICATE_ADD; &#125; //判断是否是子窗口 if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123; parentWindow = windowForClientLocked(null, attrs.token, false); if (parentWindow == null) &#123; ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is not a window: &quot; + &quot;%s. Aborting.&quot;, attrs.token); return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123; ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is a sub-window: &quot; + &quot;%s. Aborting.&quot;, attrs.token); return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; &#125; //判断当前DisplayContent是否是私有的，只拥有该display或者display已经的应用才可以在其上创建 if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) &#123; ProtoLog.w(WM_ERROR, &quot;Attempted to add private presentation window to a non-private display. &quot; + &quot;Aborting.&quot;); return WindowManagerGlobal.ADD_PERMISSION_DENIED; &#125; ...... ActivityRecord activity = null; //设置是否有父窗口的标志位 final boolean hasParent = parentWindow != null; // Use existing parent window token for child windows since they go in the same token // as there parent window so we can apply the same policy on them. /*2.根据客户端传来的token获取windowToken*/ //attrs.token去DisplayContent.mTokenMap中去取WindowToken //那么WindowToken是什么时候加入到mTokenMap中的呢 //这就要追溯到Activity的启动时，加入到DisplayContent中 //在ActivityStarter.startActivityInner中调用addOrReparentStartingActivity通过addChild一步步调用到WindowContainert中。 //在调用setParent,最终通过onDisplayChanged将ActivityRecord加入到DisplayContent.mTokenMap中 WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); // If this is a child window, we want to apply the same type checking rules as the // parent window type. final int rootType = hasParent ? parentWindow.mAttrs.type : type; boolean addToastWindowRequiresToken = false; final IBinder windowContextToken = attrs.mWindowContextToken; if (token == null) &#123; ...... &#125;else if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123; //当前窗口为应用窗口，通过token，获取ActivityRecord activity = token.asActivityRecord(); ...... &#125; else if (token.asActivityRecord() != null) &#123; ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;, rootType); // It is not valid to use an app token with other system types; we will // instead make a new token for it (as if null had been passed in for the token). attrs.token = null; token = new WindowToken.Builder(this, client.asBinder(), type) .setDisplayContent(displayContent) .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow) .build(); &#125; /*3.创建WindowState*/ final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); //将客户端传过来的Insets可见性赋值给WindowState的requestedVisibilities win.setRequestedVisibilities(requestedVisibilities); //验证当前窗口是否可以添加到WMS res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid); if (res != ADD_OKAY) &#123; return res; &#125; //调用openInputChannel，初始化input相关通路 final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125; //创建SufaceSession用于SurfaceFlinger通信 win.attach(); //将客户端与WindowState加入到mWindowMap中 mWindowMap.put(client.asBinder(), win); win.initAppOpsState(); ...... /*4.将WindowState加入到WindowToken*/ win.mToken.addWindow(win); ...... return res; &#125; mWindowMap保存了每个WindowState和客户端窗口的映射关系，客户端应用请求窗口操作时，通过mWindowMap查询到对应的WindowState 2.1.3 WindowToken的创建token = new WindowToken.Builder(this, client.asBinder(), type) .setDisplayContent(displayContent) .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow) .build(); 这里调用的是其WindowToken自身的build方法创建代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java WindowToken build() &#123; return new WindowToken(mService, mToken, mType, mPersistOnEmpty, mDisplayContent, mOwnerCanManageAppTokens, mRoundedCornerOverlay, mFromClientToken, mOptions); &#125; protected WindowToken(WindowManagerService service, IBinder _token, int type, boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123; super(service); token = _token; windowType = type; mOptions = options; mPersistOnEmpty = persistOnEmpty; mOwnerCanManageAppTokens = ownerCanManageAppTokens; mRoundedCornerOverlay = roundedCornerOverlay; mFromClientToken = fromClientToken; if (dc != null) &#123; dc.addWindowToken(token, this); &#125; &#125; dc.addWindowToken(token, this);在WindowToken构造方法中，调用DisplayContent.addWindowToken将WindowToken添加到以DisplayContent为根节点的WindowContainer层级结构中。代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java void addWindowToken(IBinder binder, WindowToken token) &#123; final DisplayContent dc = mWmService.mRoot.getWindowTokenDisplay(token); if (dc != null) &#123; // We currently don&#39;t support adding a window token to the display if the display // already has the binder mapped to another token. If there is a use case for supporting // this moving forward we will either need to merge the WindowTokens some how or have // the binder map to a list of window tokens. throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot; + getName() + &quot; already mapped to display=&quot; + dc + &quot; tokens=&quot; + dc.mTokenMap); &#125; if (binder == null) &#123; throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot; + getName() + &quot; binder is null&quot;); &#125; if (token == null) &#123; throw new IllegalArgumentException(&quot;Can&#39;t map null token to display=&quot; + getName() + &quot; binder=&quot; + binder); &#125; mTokenMap.put(binder, token); if (token.asActivityRecord() == null) &#123; // Set displayContent for non-app token to prevent same token will add twice after // onDisplayChanged. // TODO: Check if it&#39;s fine that super.onDisplayChanged of WindowToken // (WindowsContainer#onDisplayChanged) may skipped when token.mDisplayContent assigned. token.mDisplayContent = this; // Add non-app token to container hierarchy on the display. App tokens are added through // the parent container managing them (e.g. Tasks). //1.调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。 final DisplayArea.Tokens da = findAreaForToken(token).asTokens(); //2.将WindowToken添加到父容器中。 da.addChild(token); &#125; &#125; 这里我们分两步看1.final DisplayArea.Tokens da = findAreaForToken(token).asTokens();调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。 /** * Finds the &#123;@link DisplayArea&#125; for the &#123;@link WindowToken&#125; to attach to. * &lt;p&gt; * Note that the differences between this API and * &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; is that this API finds a * &#123;@link DisplayArea&#125; in &#123;@link DisplayContent&#125; level, which may find a &#123;@link DisplayArea&#125; * from multiple &#123;@link RootDisplayArea RootDisplayAreas&#125; under this &#123;@link DisplayContent&#125;&#39;s * hierarchy, while &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; finds a * &#123;@link DisplayArea.Tokens&#125; from a &#123;@link DisplayArea.Tokens&#125; list mapped to window layers. * &lt;/p&gt; * * @see DisplayContent#findAreaForTokenInLayer(WindowToken) */ DisplayArea findAreaForToken(WindowToken windowToken) &#123; return findAreaForWindowType(windowToken.getWindowType(), windowToken.mOptions, windowToken.mOwnerCanManageAppTokens, windowToken.mRoundedCornerOverlay); &#125; ​ 为传入的WindowToken找到一个DisplayArea对象来添加进去。 DisplayArea findAreaForWindowType(int windowType, Bundle options, boolean ownerCanManageAppToken, boolean roundedCornerOverlay) &#123; // TODO(b/159767464): figure out how to find an appropriate TDA. //1.如果是App窗口，那么返回默认的TaskDisplayArea对象。 if (windowType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; windowType &lt;= LAST_APPLICATION_WINDOW) &#123; return getDefaultTaskDisplayArea(); &#125; // Return IME container here because it could be in one of sub RootDisplayAreas depending on // the focused edit text. Also, the RootDisplayArea choosing strategy is implemented by // the server side, but not mSelectRootForWindowFunc customized by OEM. //2.如果是输入法窗口，那么返回ImeContainer。 if (windowType == TYPE_INPUT_METHOD || windowType == TYPE_INPUT_METHOD_DIALOG) &#123; return getImeContainer(); &#125; //3.如果是其他类型，继续寻找。 return mDisplayAreaPolicy.findAreaForWindowType(windowType, options, ownerCanManageAppToken, roundedCornerOverlay); &#125; 如果是App窗口，那么返回默认的TaskDisplayArea对象。如果是输入法窗口，那么返回ImeContainer。如果是其他类型，继续寻找。mDisplayAreaPolicy.findAreaForWindowType(windowType, options, ownerCanManageAppToken, roundedCornerOverlay);调用的是DisplayAreaPolicy中的findAreaForWindowType方法，DisplayAreaPolicy为抽象类,DisplayAreaPolicyBuilder中的Result继承了该类代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java static class Result extends DisplayAreaPolicy &#123; ...... @Override public DisplayArea.Tokens findAreaForWindowType(int type, Bundle options, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123; return mSelectRootForWindowFunc.apply(type, options).findAreaForWindowTypeInLayer(type, ownerCanManageAppTokens, roundedCornerOverlay); &#125; ...... 代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootDisplayArea.java DisplayArea.Tokens findAreaForWindowTypeInLayer(int windowType, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123; //通过getWindowLayerFromTypeLw方法获取对应的窗口类型 int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType, ownerCanManageAppTokens, roundedCornerOverlay); if (windowLayerFromType == APPLICATION_LAYER) &#123; throw new IllegalArgumentException( &quot;There shouldn&#39;t be WindowToken on APPLICATION_LAYER&quot;); &#125; return mAreaForLayer[windowLayerFromType]; &#125; 通过getWindowLayerFromTypeLw方法计算出该窗口的类型对应的层级值windowLayerFromType，然后从mAreaForLayer数组中，找到windowLayerFromType对应的那个DisplayArea.Tokens对象。2. da.addChild(token);将WindowToken添加到父容器（叶子节点）中。代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayArea.java /** * DisplayArea that contains WindowTokens, and orders them according to their type. */ public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123; ...... void addChild(WindowToken token) &#123; addChild(token, mWindowComparator); &#125; ...... addChild(token, mWindowComparator);最终调用到WindowContainer.addChild方法添加WindowToken到叶子节点 2.1.4 WindowState初始化在addWindow中初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); 下面我们看一下在WindowState的实例化过程中，都做了什么。1.根据客户端传过来的参数，对相关属性进行赋值。2.根据当前窗口的类型获取mBaseLayer,当将WindowState加入到WindowToken时，该值用来确定加入窗口在WindowToken数组中的位置。3.实例化WindowStateAnimator，该类会跟踪当前WIndowState的动画以及surface操作。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState parentWindow, int appOp, WindowManager.LayoutParams a, int viewVisibility, int ownerId, int showUserId, boolean ownerCanAddInternalSystemWindow, PowerManagerWrapper powerManagerWrapper) &#123; /*1.根据客户端传递过来的参数，对相关属性进行赋值*/ //调用WindowState的父类WindowContainer构造方法，将WMS赋值给其父类属性mWmService super(service); //获取事务 mTmpTransaction = service.mTransactionFactory.get(); //将Session赋值给mSession mSession = s; //将与客户端通信的Binder赋值给mClient mClient = c; mAppOp = appOp; //将当前activity的token赋值给mToken mToken = token; //通过token，获取当前窗口对的ActivityRecord mActivityRecord = mToken.asActivityRecord(); //赋值id mOwnerUid = ownerId; mShowUserId = showUserId; //是否可以添加系统窗口的标志位 mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow; mWindowId = new WindowId(this); //布局参数赋值给mAttrs mAttrs.copyFrom(a); //将surfaceInsets赋值给mLastSurfaceInsets mLastSurfaceInsets.set(mAttrs.surfaceInsets); //将窗口可见性赋值给mViewVisibility mViewVisibility = viewVisibility; //将窗口WindowManagerPolicy赋值给mPolicy mPolicy = mWmService.mPolicy; mContext = mWmService.mContext; ...... /*2.获取当前窗口的BaseLayer*/ if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123; ...... &#125; else &#123; // The multiplier here is to reserve space for multiple // windows in the same type layer. //当前为应用窗口所以mPolicy.getWindowLayerLw(this)获取值为2，即应用层级 //TYPE_LAYER_MULTIPLIER为同一类型的多窗口保留空间 //TYPE_LAYER_OFFSET将同一组窗口移动到同一层中其他窗口的上方或者下方 mBaseLayer = mPolicy.getWindowLayerLw(this) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; mSubLayer = 0; mIsChildWindow = false; mLayoutAttached = false; mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD || mAttrs.type == TYPE_INPUT_METHOD_DIALOG; mIsWallpaper = mAttrs.type == TYPE_WALLPAPER; &#125; ...... /*3.新建windowStateAnimator，该类会跟踪当前WindowState的动画以及surface操作*/ mWinAnimator = new WindowStateAnimator(this); //将透明度alpha赋值给mAlpha mWinAnimator.mAlpha = a.alpha; ...... &#125; 2.1.5 将WindowState加入到WindowToken在addWindow中将WindowState加入到WindowTokenwin.mToken.addWindow(win);WindowState加入到WindowToken中的具体过程：1.将要加入的WindowState.mBaseLayer与WindowToken中现有的WindowState.mBaseLayer相比，按照mBaseLayer有小到大存放到数组中，若mBaseLayer相等，则后加入的WindowState放在数组后面。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java void addWindow(final WindowState win) &#123; ProtoLog.d(WM_DEBUG_FOCUS, &quot;addWindow: win=%s Callers=%s&quot;, win, Debug.getCallers(5)); if (win.isChildWindow()) &#123; // Child windows are added to their parent windows. //如果是子窗口直接返回 return; &#125; // This token is created from WindowContext and the client requests to addView now, create a // surface for this token. if (mSurfaceControl == null) &#123; createSurfaceControl(true /* force */); // Layers could have been assigned before the surface was created, update them again reassignLayer(getSyncTransaction()); &#125; if (!mChildren.contains(win)) &#123; ProtoLog.v(WM_DEBUG_ADD_REMOVE, &quot;Adding %s to %s&quot;, win, this); //调用WindowContainer.addChild方法 addChild(win, mWindowComparator); mWmService.mWindowsChanged = true; // TODO: Should we also be setting layout needed here and other places? &#125; &#125; /** * Compares two child window of this token and returns -1 if the first is lesser than the * second in terms of z-order and 1 otherwise. */ private final Comparator&lt;WindowState&gt; mWindowComparator = (WindowState newWindow, WindowState existingWindow) -&gt; &#123; final WindowToken token = WindowToken.this; ...... //如果新窗口的mBaseLayer 不小于（大于等于）已经存在的WindowState的BaseLayer，则返回1，否则返回-1 return isFirstChildWindowGreaterThanSecond(newWindow, existingWindow) ? 1 : -1; &#125;; /** * Returns true if the new window is considered greater than the existing window in terms of * z-order. */ protected boolean isFirstChildWindowGreaterThanSecond(WindowState newWindow, WindowState existingWindow) &#123; // New window is considered greater if it has a higher or equal base layer. //此处可以发现比较的是两个窗口的mBaseLayer return newWindow.mBaseLayer &gt;= existingWindow.mBaseLayer; &#125; 我们看看WindowContainer.addChild方法代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java /** * Adds the input window container has a child of this container in order based on the input * comparator. * @param child The window container to add as a child of this window container. * @param comparator Comparator to use in determining the position the child should be added to. * If null, the child will be added to the top. */ @CallSuper protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123; ...... //记录插入数组的位置，若为-1则将windowState加入到后面 int positionToAdd = -1; if (comparator != null) &#123; //判断当前WindowToken中WindowState的数量 //依次比较将要加入的窗口与已经存在的WindowState的BaseLayer //mChildren越大放到数组最前面WindowToken final int count = mChildren.size(); for (int i = 0; i &lt; count; i++) &#123; //比较baseLayer，如果child大于列表中已经存在的，则需要返回1，否则返回-1 //新加入的的child大于mChildren.get(i)则返回1，小于则返回-1 //注：comparator比较器的逻辑见上面代码的mWindowComparator if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123; //记录当前要插入的位置 positionToAdd = i; break; &#125; &#125; &#125; //如果新加入的窗口大于现在所有窗口 if (positionToAdd == -1) &#123; //将该窗口加入到列表最后 mChildren.add(child); &#125; else &#123; mChildren.add(positionToAdd, child); &#125; // Set the parent after we&#39;ve actually added a child in case a subclass depends on this. //此处将child的mParent设置为this child.setParent(this); &#125; 2.将WindowState的mParent置为刚才的WindowToken，并更新其Parent的mTreeWeight。mTreeWeight记录了其子节点的数量。继续查看WindowState的父类WindowContainer.setParent final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123; //将当前WindowState的mParent设置为相应的WindowToken final WindowContainer oldParent = mParent; mParent = parent; if (mParent != null) &#123; //更新parent中的mTreeWeight属性 //mTreeWeight代表以parent的根节点的子树中的元素的数量 mParent.onChildAdded(this); &#125; else if (mSurfaceAnimator.hasLeash()) &#123; mSurfaceAnimator.cancelAnimation(); &#125; if (!mReparenting) &#123; onSyncReparent(oldParent, mParent); if (mParent != null &amp;&amp; mParent.mDisplayContent != null &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123; onDisplayChanged(mParent.mDisplayContent); &#125; //计算显示layer onParentChanged(mParent, oldParent); &#125; &#125; 3.将WindowState加入到WindowToken之后，调用parent的assignChildLayers方法，调整其所有child的z-order。主要经历以下步骤：初始化layer&#x3D;0，代表着z-order。遍历mChildren数组，判断Children是否需要提高到顶部（判断标志位mNeedsZBoost）。如果不需要则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果需要则执行下一遍循环。再次遍历mChildren数组，判断Children是否需要提高到顶部。如果需要则则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果不需要则执行下一次循环。注：Z-order也被称为深度顺序（depth order）或Z轴顺序，它用于确定图层（Layers）在屏幕上的堆叠顺序。简单来说，Z-order就是图层在Z轴上的位置，Z轴位置越低，图层越在底层，Z轴位置越高，图层越在顶层。继续看onParentChanged方法 /** * Callback that is triggered when @link WindowContainer#setParent(WindowContainer)&#125; was called. * Supposed to be overridden and contain actions that should be executed after parent was set. */ @Override void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123; onParentChanged(newParent, oldParent, null); &#125; void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent, PreAssignChildLayersCallback callback) &#123; ...... if (mSurfaceControl == null) &#123; // If we don&#39;t yet have a surface, but we now have a parent, we should // build a surface. //创建一个SurfaceControl来调整窗口的z-order createSurfaceControl(false /*force*/); &#125; else &#123; ...... &#125; ...... // Either way we need to ask the parent to assign us a Z-order. //进入WindowToken的父类WindowContainer中，调整窗口的z-order mParent.assignChildLayers(); scheduleAnimation(); &#125; void assignChildLayers() &#123; assignChildLayers(getSyncTransaction()); scheduleAnimation(); &#125; void assignChildLayers(Transaction t) &#123; //分配给当前窗口的z-order，初始化为0 int layer = 0; // We use two passes as a way to promote children which // need Z-boosting to the end of the list. //此处会以parent为根节点向下遍历到子节点，再从下到上依次进行处理 for (int j = 0; j &lt; mChildren.size(); ++j) &#123; final WindowContainer wc = mChildren.get(j); wc.assignChildLayers(t); //needsZBoot是用来判断当前窗口是否应该提升到容器的顶部 //若不需要提升到容器的顶部 if (!wc.needsZBoost()) &#123; //调用WindowState的父类WindowContainer中的assignLayer wc.assignLayer(t, layer++); &#125; &#125; //处理需要提升到容器顶部的窗口 for (int j = 0; j &lt; mChildren.size(); ++j) &#123; final WindowContainer wc = mChildren.get(j); if (wc.needsZBoost()) &#123; wc.assignLayer(t, layer++); &#125; &#125; if (mOverlayHost != null) &#123; mOverlayHost.setLayer(t, layer++); &#125; &#125; 4.在Children的assignLayer中会首先判断此次要调整的layer与自己上次layer是否相等，不相等则最终会调用nativeSetLayer来调整自己的z-order。 void assignLayer(Transaction t, int layer) &#123; // Don&#39;t assign layers while a transition animation is playing // TODO(b/173528115): establish robust best-practices around z-order fighting. //如果正在执行Transaction，则不需要进行assignLayer if (mTransitionController.isPlaying()) return; //layer为此次要调整的z-order final boolean changed = layer != mLastLayer || mLastRelativeToLayer != null; //如果需要调整 if (mSurfaceControl != null &amp;&amp; changed) &#123; //调用setLayer调整窗口的z-order setLayer(t, layer); //将mLastLayer调整为新的z-order mLastLayer = layer; mLastRelativeToLayer = null; &#125; &#125; protected void setLayer(Transaction t, int layer) &#123; if (mSurfaceFreezer.hasLeash()) &#123; ...... &#125; else &#123; // Route through surface animator to accommodate that our surface control might be // attached to the leash, and leash is attached to parent container. //调用SurfaceAnimator中的setLayer mSurfaceAnimator.setLayer(t, layer); &#125; &#125; 代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;SurfaceAnimator.java /** * Sets the layer of the surface. * &lt;p&gt; * When the layer of the surface needs to be adjusted, we need to set it on the leash if the * surface is reparented to the leash. This method takes care of that. */ void setLayer(Transaction t, int layer) &#123; //调用SurfaceControl中的setlayer方法 t.setLayer(mLeash != null ? mLeash : mAnimatable.getSurfaceControl(), layer); &#125; 代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java /** * Set the Z-order for a given SurfaceControl, relative to it&#39;s siblings. * If two siblings share the same Z order the ordering is undefined. Surfaces * with a negative Z will be placed below the parent surface. * * @param sc The SurfaceControl to set the Z order on * @param z The Z-order * @return This Transaction. */ @NonNull public Transaction setLayer(@NonNull SurfaceControl sc, @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z) &#123; //调用调整layer checkPreconditions(sc); nativeSetLayer(mNativeObject, sc.mNativeObject, z); return this; &#125; 2.2 窗口位置和大小计算当WindowState加入到WindowToken并调整z-order之后，客户端会再次调用WindowManagerService.relayoutWindow执行窗口布局。主要做了这三件事：1.接收客户端请求2.创建SurfaceControl3.窗口位置和大小计算 2.2.1 接收客户端请求与addWindow流程的调用过程类似，WindowManagerService.relayoutWindow也是由客户端通过Session来调用的。首先我们来看一下客户端给我们传递了哪些参数吧。window：是WMS与客户端通信的Binder。attrs：窗口的布局属性，根据attrs提供的属性来布局窗口。requestWidth、requestHeight：客户端请求的窗口尺寸。viewFlags：窗口的可见性。包括VISIBLE（0，view可见），INVISIBLE（4，view不可见，但是仍然占用布局空间）GONE（8，view不可见，不占用布局空间）flags：定义一些布局行为。outFrames：返回给客户端的，保存了重新布局之后的位置与大小。mergedConfiguration:相关配置信息。outSurfaceControl:返回给客户端的surfaceControl。outInsetsState：用来保存系统中所有Insets的状态。outActiveControls：InSetsSourceControl数组。outSyncSeqIdBundle：与布局同步有关。Session调用WMS.relayoutWindow将客户端传入的参数传递给WMS。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java @Override public int relayout(IWindow window, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration, SurfaceControl outSurfaceControl, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls, Bundle outSyncSeqIdBundle) &#123; if (false) Slog.d(TAG_WM, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot; + Binder.getCallingPid()); Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, mRelayoutTag); int res = mService.relayoutWindow(this, window, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrames, mergedConfiguration, outSurfaceControl, outInsetsState, outActiveControls, outSyncSeqIdBundle); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); if (false) Slog.d(TAG_WM, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot; + Binder.getCallingPid()); return res; &#125; 2.2.2 relayoutWindow在WMS.relayoutWindow中主要做了以下事情：1.根据客户端传过来的IWindow在mWindowMap获取窗口添加阶段创建的WindowState。2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位3.Surface的创建流程。4.窗口尺寸的计算以及Surface的状态变更。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java public int relayoutWindow(Session session, IWindow client, LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration, SurfaceControl outSurfaceControl, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle) &#123; ...... synchronized (mGlobalLock) &#123; /*1.根据客户端传过来的Iwindow从mWindowMap中获取对应的WindowState*/ final WindowState win = windowForClientLocked(session, client, false); if (win == null) &#123; return 0; &#125; //获取DisplayContent、DisplayPolicy以及WindowStateAnimator final DisplayContent displayContent = win.getDisplayContent(); final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy(); WindowStateAnimator winAnimator = win.mWinAnimator; if (viewVisibility != View.GONE) &#123; //根据客户端请求的窗口大小设置WindowState的requestedWidth, requestedHeight //并设置WindowState.mLayoutNeeded为true win.setRequestedSize(requestedWidth, requestedHeight); &#125; ...... //根据请求的宽带和高度窗口缩放比例 win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight); ...... //获取原来window的可见性，此时为INVISIBLE final int oldVisibility = win.mViewVisibility; ...... //代表现在没有surface但应该很快就有标志位 win.mRelayoutCalled = true; win.mInRelayout = true; //将当前窗口的可见性有原来的INVISIBLE调整为VISIBLE win.setViewVisibility(viewVisibility); ProtoLog.i(WM_DEBUG_SCREEN_ON, &quot;Relayout %s: oldVis=%d newVis=%d. %s&quot;, win, oldVisibility, viewVisibility, new RuntimeException().fillInStackTrace()); /*2.1.将displayContent中的布局标志为mLayoutNeeded置为true*/ win.setDisplayLayoutNeeded(); win.mGivenInsetsPending = (flags &amp; WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0; // We should only relayout if the view is visible, it is a starting window, or the // associated appToken is not hidden. /*2.2.判断是否允许relayout，此时为true*/ //判断条件：view可见且（activityRecord不为空，或者布局类型为TYPE_APPLICATION_STARTING，或者窗口已经告诉客户端可以显示） final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp; (win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || win.mActivityRecord.isClientVisible()); ...... // Create surfaceControl before surface placement otherwise layout will be skipped // (because WS.isGoneForLayout() is true when there is no surface. /*3.surface的创建流程*/ if (shouldRelayout) &#123; try &#123; //进入creatSurfaceControl开始创建SurfaceControl result = createSurfaceControl(outSurfaceControl, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... return 0; &#125; &#125; // We may be deferring layout passes at the moment, but since the client is interested // in the new out values right now we need to force a layout. /*4.窗口尺寸的计算以及Surface的状态变更*/ //WindowSurfacePlacer在WMS初始化的时候创建 mWindowPlacerLocked.performSurfacePlacement(true /* force */); ...... //填充计算好的frame返回给客户端，更新mergedConfiguration对象 win.fillClientWindowFramesAndConfiguration(outFrames, mergedConfiguration, false /* useLatestConfig */, shouldRelayout); // Set resize-handled here because the values are sent back to the client. win.onResizeHandled(); ...... &#125; Binder.restoreCallingIdentity(origId); //返回result return result; &#125; 2.2.3 创建SurfaceControl在relayoutWindow中创建SurfaceControlresult = createSurfaceControl(outSurfaceControl, result, win, winAnimator);关于SurfaceControl的创建在WMS中主要做两件事：1.调用WindwoStateAnimator执行具体的SurfaceControl的创建。2.将创建的SurfaceControl赋值给客户端的outSurfaceControl。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java private int createSurfaceControl(SurfaceControl outSurfaceControl, int result, WindowState win, WindowStateAnimator winAnimator) &#123; ...... WindowSurfaceController surfaceController; try &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;createSurfaceControl&quot;); /* * WindowStateAnimator用来帮助WindowState管理animator和surface基本操作的 * 1.WMS将创建的surfaceContorl的操作交给windowAnimator来处理 */ surfaceController = winAnimator.createSurfaceLocked(); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; if (surfaceController != null) &#123; /*2.将WMS的SurfaceControl赋值给客户端的outSurfaceControl*/ surfaceController.getSurfaceControl(outSurfaceControl); ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot;OUT SURFACE %s: copied&quot;, outSurfaceControl); &#125; else &#123; // For some reason there isn&#39;t a surface. Clear the // caller&#39;s object so they see the same state. ProtoLog.w(WM_ERROR, &quot;Failed to create surface control for %s&quot;, win); outSurfaceControl.release(); &#125; return result; &#125; 在WindowStateAnimator中创建SurfaceControl主要经过以下三个步骤：1.重置Surface标志位，变更mDrawState状态为DRAW_PENDING。2.通过实例化WindowSurfaceController来创建SurfaceControl。3.处理Surface标志位，将其置为true，标志着当前WindowState已经有surface了代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java WindowSurfaceController createSurfaceLocked() &#123; final WindowState w = mWin; //首先判断是否存在mSurfaceController if (mSurfaceController != null) &#123; return mSurfaceController; &#125; /*1.1.设置WindowState的mHasSurface设置为false*/ w.setHasSurface(false); ProtoLog.i(WM_DEBUG_ANIM, &quot;createSurface %s: mDrawState=DRAW_PENDING&quot;, this); /*1.2.将WindowStateAnimator中的DrawState设置为DRAW_PENDING*/ resetDrawState(); mService.makeWindowFreezingScreenIfNeededLocked(w); /*1.3.将surface创建flag设置为hidden*/ int flags = SurfaceControl.HIDDEN; //获取windowState的布局参数 final WindowManager.LayoutParams attrs = w.mAttrs; // Set up surface control with initial size. try &#123; ...... /*2.创建WindowSurfaceController*/ //attrs.getTitle().toString()为当前activity的全路径名 //format为位图格式 //flags为surface创建的标志位（如：HIDDED(0x04,surface创建为隐藏)，SKIP_SCREENSHOT(0x040，截屏时跳过此图层将不会包含在非主显示器上),SECURE(0X080,禁止复制表面的内容，屏幕截图和次要的非安全显示将呈现黑色内容而不是surface内容)等） //attrs.type为窗口类型 mSurfaceController = new WindowSurfaceController(attrs.getTitle().toString(), format, flags, this, attrs.type); mSurfaceController.setColorSpaceAgnostic((attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_COLOR_SPACE_AGNOSTIC) != 0); /*3.将WindowState的hasSurface标志设置为true，标志着道歉WindowState已经有surface了*/ w.setHasSurface(true); ...... &#125; catch (OutOfResourcesException e) &#123; ...... &#125; catch (Exception e) &#123; ...... &#125; ...... return mSurfaceController; &#125; SurfaceControl的创建过程为典型的建造者模式接下来看看WindowSurfaceController的构造方法代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java WindowSurfaceController(String name, int format, int flags, WindowStateAnimator animator, int windowType) &#123; //设置WindowStateAnimator mAnimator = animator; //窗口名 title = name; //WMS对象 mService = animator.mService; //WindowState对象 final WindowState win = animator.mWin; //窗口类型 mWindowType = windowType; //IWindowSession对象 mWindowSession = win.mSession; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;new SurfaceControl&quot;); //makeSurface最终会调用到DisplayContent的makeChildSurface方法，返回SurfaceControl.Builder final SurfaceControl.Builder b = win.makeSurface() .setParent(win.getSurfaceControl()) .setName(name) .setFormat(format) .setFlags(flags) .setMetadata(METADATA_WINDOW_TYPE, windowType) .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid) .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid) .setCallsite(&quot;WindowSurfaceController&quot;); ...... //获取SurfaceControl实例对象 mSurfaceControl = b.build(); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; 两个关键方法win.makeSurface()和b.build()1.final SurfaceControl.Builder b = win.makeSurface()我们先来看看win.makeSurface()，windowState中没有makeSurface()方法，因此调用其父类WindowContainer的makeSurface()方法代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java SurfaceControl.Builder makeSurface() &#123; final WindowContainer p = getParent(); return p.makeChildSurface(this); &#125; /** * @param child The WindowContainer this child surface is for, or null if the Surface * is not assosciated with a WindowContainer (e.g. a surface used for Dimming). */ SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123; final WindowContainer p = getParent(); // Give the parent a chance to set properties. In hierarchy v1 we rely // on this to set full-screen dimensions on all our Surface-less Layers. return p.makeChildSurface(child) .setParent(mSurfaceControl); &#125; 最终会调用到DisplayContent的makeChildSurface代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java @Override SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123; //此时child为WindowState //获取SurfaceSession，SurfaceSession的创建在Session.windowAddedLocked中，其最开始调用在WindowManagerService.addWindow中win.attach()中创建 SurfaceSession s = child != null ? child.getSession() : getSession(); //返回SurfaceControl.Builder final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(s).setContainerLayer(); if (child == null) &#123; return b; &#125; //设置SurfaceControl.Builder的name以及parent return b.setName(child.getName()) .setParent(mSurfaceControl); &#125; 2.mSurfaceControl = b.build();再来看看b.build()，调用SurfaceControl中的build代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java /** * Construct a new &#123;@link SurfaceControl&#125; with the set parameters. The builder * remains valid. */ @NonNull public SurfaceControl build() &#123; //检查width以及height，初始都应该为0 if (mWidth &lt; 0 || mHeight &lt; 0) &#123; throw new IllegalStateException( &quot;width and height must be positive or unset&quot;); &#125; if ((mWidth &gt; 0 || mHeight &gt; 0) &amp;&amp; (isEffectLayer() || isContainerLayer())) &#123; throw new IllegalStateException( &quot;Only buffer layers can set a valid buffer size.&quot;); &#125; if ((mFlags &amp; FX_SURFACE_MASK) == FX_SURFACE_NORMAL) &#123; setBLASTLayer(); &#125; //创建SurfaceControl的实例 return new SurfaceControl( mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata, mLocalOwnerView, mCallsite); &#125; /** * @param session The surface session, must not be null. * @param name The surface name, must not be null. * @param w The surface initial width. * @param h The surface initial height. * @param flags The surface creation flags. * @param metadata Initial metadata. * @param callsite String uniquely identifying callsite that created this object. Used for * leakage tracking. * @throws throws OutOfResourcesException If the SurfaceControl cannot be created. */ private SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags, SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView, String callsite) throws OutOfResourcesException, IllegalArgumentException &#123; if (name == null) &#123; throw new IllegalArgumentException(&quot;name must not be null&quot;); &#125; mName = name; mWidth = w; mHeight = h; mLocalOwnerView = localOwnerView; //创建Parcel用来传递数据 Parcel metaParcel = Parcel.obtain(); try &#123; ...... //调用native层 mNativeObject = nativeCreate(session, name, w, h, format, flags, parent != null ? parent.mNativeObject : 0, metaParcel); &#125; finally &#123; metaParcel.recycle(); &#125; if (mNativeObject == 0) &#123; throw new OutOfResourcesException( &quot;Couldn&#39;t allocate SurfaceControl native object&quot;); &#125; mNativeHandle = nativeGetHandle(mNativeObject); mCloseGuard.openWithCallSite(&quot;release&quot;, callsite); &#125; ​ SurfaceControl的构造方法调用完成后，返回查看前面result = createSurfaceControl(outSurfaceControl, result, win, winAnimator); 2.2.4 计算窗口大小位置在relayoutWindow中计算窗口大小位置mWindowPlacerLocked.performSurfacePlacement(true /* force */);该流程我们分为三部分介绍：1.该部分处理有关窗口布局循环的逻辑。2.该部分处理Surface的状态变更，以及调用layoutWindowLw的流程。3.计算窗口位置大小。 1.处理窗口布局循环performSurfacePlacement是一个确定所有窗口的Surface的如何摆放，如何显示、显示在什么位置、显示区域多大的一个入口方法。该方法主要设置了布局的循环条件，当mTraversalScheduled 标志位为true，且loopCount大于0。将会调用performSurfacePlacementLoop执行布局操作。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java final void performSurfacePlacement(boolean force) &#123; if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123; mDeferredRequests++; return; &#125; //将循环的最大次数设置为6次 int loopCount = 6; do &#123; //将该标志为设置为false mTraversalScheduled = false; //执行窗口布局操作 performSurfacePlacementLoop(); mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement); loopCount--; //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局 &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0); mService.mRoot.mWallpaperActionPending = false; &#125; performSurfacePlacementLoop方法主要做两件事：1.调用RootWindowContainer对所有窗口执行布局操作，2.处理是否再次进行布局的逻辑。如果DisplayContent.mLayoutNeeded标志位为true且布局循环次数小于6次，则会将mTraversalScheduled标志位置为true，在performSurfacePlacement中会再次调用performSurfacePlacementLoop。 private void performSurfacePlacementLoop() &#123; //若当前已经进行布局操作，则无需重复调用直接返回 if (mInLayout) &#123; ...... return; &#125; ...... //将该标志位置为true，表示正在处于布局过程中 mInLayout = true; ...... try &#123; /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/ mService.mRoot.performSurfacePlacement(); mInLayout = false; if (mService.mRoot.isLayoutNeeded()) &#123; /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/ if (++mLayoutRepeatCount &lt; 6) &#123; //该方法中会将mTraversalScheduled标志位设置位true requestTraversal(); &#125; else &#123; Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;); mLayoutRepeatCount = 0; &#125; &#125; else &#123; mLayoutRepeatCount = 0; &#125; if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123; mService.mH.removeMessages(REPORT_WINDOWS_CHANGE); mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE); &#125; &#125; catch (RuntimeException e) &#123; mInLayout = false; Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e); &#125; &#125; 2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程mService.mRoot.performSurfacePlacement();上面说到在RootWindowContainer.performSurfacePlacement()中调用了performSurfaceNoTrace()方法，该方法为实际的处理布局的方法，主要处理以下流程：1.如果有焦点变化，更新焦点。2.执行窗口尺寸计算，surface状态变更等操作。3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在finishdrawing()中再详细分析。4.如果壁纸有变化，更新壁纸。5.再次处理焦点变化。6.如果过程中由size或者位置变化，则通知客户端重新relayout。7.销毁不可见的窗口代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java void performSurfacePlacement() &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;); try &#123; //调用performSurfacePlacementNoTrace() performSurfacePlacementNoTrace(); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; // &quot;Something has changed! Let&#39;s make it correct now.&quot; // TODO: Super long method that should be broken down... void performSurfacePlacementNoTrace() &#123; ...... /*1.如果有焦点变化，更新焦点*/ if (mWmService.mFocusMayChange) &#123; mWmService.mFocusMayChange = false; mWmService.updateFocusedWindowLocked( UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/); &#125; ...... Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;); //开启事务，获取GlobalTransactionWrapper对象 mWmService.openSurfaceTransaction(); try &#123; /*2.执行窗口尺寸计算，surface状态变更等操作*/ applySurfaceChangesTransaction(); &#125; catch (RuntimeException e) &#123; Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e); &#125; finally &#123; //关闭事务 mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); if (SHOW_LIGHT_TRANSACTIONS) &#123; Slog.i(TAG, &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;); &#125; &#125; ...... /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/ checkAppTransitionReady(surfacePlacer); ...... /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/ for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123; final DisplayContent displayContent = mChildren.get(displayNdx); //判断DisplayContent的壁纸是否需要改变 if (displayContent.mWallpaperMayChange) &#123; ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change! Adjusting&quot;); displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; if (DEBUG_LAYOUT_REPEATS) &#123; surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;, displayContent.pendingLayoutChanges); &#125; &#125; &#125; /*5.在此处理焦点变化*/ if (mWmService.mFocusMayChange) &#123; mWmService.mFocusMayChange = false; mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, false /*updateInputWindows*/); &#125; ...... /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/ handleResizingWindows(); if (mWmService.mDisplayFrozen) &#123; ProtoLog.v(WM_DEBUG_ORIENTATION, &quot;With display frozen, orientationChangeComplete=%b&quot;, mOrientationChangeComplete); &#125; if (mOrientationChangeComplete) &#123; if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123; mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE; mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource; mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT); &#125; mWmService.stopFreezingDisplayLocked(); &#125; // Destroy the surface of any windows that are no longer visible. /*7.销毁不可见的窗口*/ i = mWmService.mDestroySurface.size(); if (i &gt; 0) &#123; do &#123; i--; WindowState win = mWmService.mDestroySurface.get(i); win.mDestroying = false; final DisplayContent displayContent = win.getDisplayContent(); if (displayContent.mInputMethodWindow == win) &#123; displayContent.setInputMethodWindowLocked(null); &#125; if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; win.destroySurfaceUnchecked(); &#125; while (i &gt; 0); mWmService.mDestroySurface.clear(); &#125; ...... &#125; ​ 在applySurfaceChangesTransaction();方法中其主要执行：1.水印、StrictMode警告框以及模拟器显示的布局。2.遍历所有DisplayContent执行其applySurfaceChangesTransaction我们一起看看这个方法 private void applySurfaceChangesTransaction() &#123; mHoldScreenWindow = null; mObscuringWindow = null; // TODO(multi-display): Support these features on secondary screens. /*1.水印、StrictMode警告框以及模拟器显示的布局*/ //获取手机默认DisplayContent的信息 final DisplayContent defaultDc = mWmService.getDefaultDisplayContentLocked(); final DisplayInfo defaultInfo = defaultDc.getDisplayInfo(); final int defaultDw = defaultInfo.logicalWidth; final int defaultDh = defaultInfo.logicalHeight; //布局水印 if (mWmService.mWatermark != null) &#123; mWmService.mWatermark.positionSurface(defaultDw, defaultDh, mDisplayTransaction); &#125; //布局StrictMode警告框 if (mWmService.mStrictModeFlash != null) &#123; mWmService.mStrictModeFlash.positionSurface(defaultDw, defaultDh, mDisplayTransaction); &#125; //布局模拟器显示覆盖 if (mWmService.mEmulatorDisplayOverlay != null) &#123; mWmService.mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh, mWmService.getDefaultDisplayRotation(), mDisplayTransaction); &#125; /*2.遍历RootWindowContainer下所有DisplayContent执行其applySurfaceChangesTransaction()*/ final int count = mChildren.size(); for (int j = 0; j &lt; count; ++j) &#123; final DisplayContent dc = mChildren.get(j); dc.applySurfaceChangesTransaction(); &#125; // Give the display manager a chance to adjust properties like display rotation if it needs // to. mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction); SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction); &#125; 接下来继续跟踪dc.applySurfaceChangesTransaction();该方法主要1.遍历所有窗口，计算窗口的布局大小，具体流程查看performLayoutNoTrace。（主要跟踪点）2.surface的状态更改。（见“2.3.3mDrawState变更为HAS_DRAW”流程”）3.处理surface的位置、大小以及显示等。（见“2.3.4 show Surface”流程”）代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java void applySurfaceChangesTransaction() &#123; //获取WindowSurfacePlacer final WindowSurfacePlacer surfacePlacer = mWmService.mWindowPlacerLocked; ...... // Perform a layout, if needed. /*1.执行布局，该方法最终会调用performLayoutNoTrace，计算窗口的布局参数*/ performLayout(true /* initial */, false /* updateInputWindows */); ...... Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applyWindowSurfaceChanges&quot;); try &#123; /*2.遍历所有窗口，主要是改变surface的状态。见“2.3.3mDrawState变更为HAS_DRAW”流程*/ forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; /*3.处理各个surface的位置、大小以及是否要在屏幕上显示等。后面finishDrawing()流程中再跟踪*/ prepareSurfaces(); ...... &#125; 继续跟踪performLayout(true /* initial */, false /* updateInputWindows */);该方法主要就是调用performLayoutNoTrace()方法，首先判断布局标志位mLayoutNeeded，该标志位在WMS.relayoutWindow中被置为true。false则直接返回不会进行布局操作。true则分别遍历父窗口和子窗口进行布局，我们暂且只分析父窗口的布局操作，查看mPerformLayout。 void performLayout(boolean initial, boolean updateInputWindows) &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performLayout&quot;); try &#123; //调用performLayoutNoTrace performLayoutNoTrace(initial, updateInputWindows); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; private void performLayoutNoTrace(boolean initial, boolean updateInputWindows) &#123; /*1.判断是否需要布局，不需要则直接返回，即判断布局标志位mLayoutNeeded是否为true*/ if (!isLayoutNeeded()) &#123; return; &#125; //将DisplayContent.mLayoutNeeded属性置为false clearLayoutNeeded(); ...... // First perform layout of any root windows (not attached to another window). /*2.对所有顶级窗口进行布局*/ //最终会回调mPerformLayout forAllWindows(mPerformLayout, true /* traverseTopToBottom */); // Now perform layout of attached windows, which usually depend on the position of the // window they are attached to. XXX does not deal with windows that are attached to windows // that are themselves attached. /*3.处理子窗口的布局*/ //最终会回调mPerformLayoutAttached forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */); ...... &#125; forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);当遍历到DisplayContent下的每个窗口时都会执行mPerformLayout，该方法会将WindowState.mLayoutNeeded标志位置false，并将具体的布局操作交给DisplayPolicy进行处理，见“3. 计算窗口位置大小“。 private final Consumer&lt;WindowState&gt; mPerformLayout = w -&gt; &#123; //如果当前窗口为子窗口则直接返回 if (w.mLayoutAttached) &#123; return; &#125; // Don&#39;t do layout of a window if it is not visible, or soon won&#39;t be visible, to avoid // wasting time and funky changes while a window is animating away. //先判断当前窗口是否会不可见 final boolean gone = w.isGoneForLayout(); ...... // If this view is GONE, then skip it -- keep the current frame, and let the caller know // so they can ignore it if they want. (We do the normal layout for INVISIBLE windows, // since that means &quot;perform layout as normal, just don&#39;t display&quot;). if (!gone || !w.mHaveFrame || w.mLayoutNeeded) &#123; if (mTmpInitial) &#123; //设置窗口布局WindowFrames.mContentChanged为false w.resetContentChanged(); &#125; //将mSurfacePlacementNeeded标志为置为true w.mSurfacePlacementNeeded = true; //将WindowState.mLayoutNeeded标志位置为false w.mLayoutNeeded = false; //判断当前窗口是否是第一次布局 final boolean firstLayout = !w.isLaidOut(); //调用DisplayPolicy.layoutWindowLw进行布局，根据DisplayFrames对象对WindowState.mWindowFrames中的各个Rect对象属性进行确定 getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames); w.mLayoutSeq = mLayoutSeq; // If this is the first layout, we need to initialize the last frames and inset values, // as otherwise we&#39;d immediately cause an unnecessary resize. if (firstLayout) &#123; // The client may compute its actual requested size according to the first layout, // so we still request the window to resize if the current frame is empty. if (!w.getFrame().isEmpty()) &#123; w.updateLastFrames(); &#125; w.onResizeHandled(); &#125; if (DEBUG_LAYOUT) Slog.v(TAG, &quot; LAYOUT: mFrame=&quot; + w.getFrame() + &quot; mParentFrame=&quot; + w.getParentFrame() + &quot; mDisplayFrame=&quot; + w.getDisplayFrame()); &#125; &#125;; 当mLayoutNeeded标志被设置时，表示布局需要更新；mSurfacePlacementNeeded标志被设置时，表示需要更新surface位置的条件之一（WindowState.updateSurfacePosition方法中有判断）。 3.计算窗口位置大小getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);layoutWindowLw主要做了以下三件事1.首先会获DisplayFrames：DisplayContent新建时创建，内部数据由屏幕提供。2.其次调用WindowLayout.computeFrames计算窗口布局大小。3.最后调用WindowState.setFrames将计算的布局参数赋值给当前窗口的windowFrames。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayPolicy.java /** * Called for each window attached to the window manager as layout is proceeding. The * implementation of this function must take care of setting the window&#39;s frame, either here or * in finishLayout(). * * @param win The window being positioned. * @param attached For sub-windows, the window it is attached to; this * window will already have had layoutWindow() called on it * so you can use its Rect. Otherwise null. * @param displayFrames The display frames. */ public void layoutWindowLw(WindowState win, WindowState attached, DisplayFrames displayFrames) &#123; //判断是否需要跳过布局 if (win.skipLayout()) &#123; return; &#125; // This window might be in the simulated environment. // We invoke this to get the proper DisplayFrames. /*1.获取DisplayFrames*/ displayFrames = win.getDisplayFrames(displayFrames); //获取某个方向的窗口布局参数 final WindowManager.LayoutParams attrs = win.getLayoutingAttrs(displayFrames.mRotation); //null final Rect attachedWindowFrame = attached != null ? attached.getFrame() : null; // If this window has different LayoutParams for rotations, we cannot trust its requested // size. Because it might have not sent its requested size for the new rotation. final boolean trustedSize = attrs == win.mAttrs; final int requestedWidth = trustedSize ? win.mRequestedWidth : UNSPECIFIED_LENGTH; final int requestedHeight = trustedSize ? win.mRequestedHeight : UNSPECIFIED_LENGTH; /*2.调用WindowLayout.computeFrames计算窗口布局大小*/ mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe, win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight, win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale, sTmpClientFrames); /*3.将计算的布局参数赋值给windowFrames*/ win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight); &#125; 先来看看computeFrames，计算窗口布局大小 mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe, win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight, win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale, sTmpClientFrames); 调用的是WindowLayout的computeFrames方法 public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state, Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode, int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities, Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames) 入参说明：attrs：这些是窗口的布局参数。它们定义了窗口的位置、大小、堆叠顺序等属性。state：这个参数代表了窗口的边距状态。边距是窗口与设备边缘之间的空间，可能会被其他元素（如状态栏或导航栏）占据。displayCutoutSafe：这是一个矩形，表示在计算窗口大小时可以安全忽略的显示切边区域。这通常是为了防止应用程序内容与设备上的物理切边重叠。windowBounds：这是窗口的边界矩形，通常表示窗口在屏幕上的位置和大小。windowingMode：这个参数定义了窗口的窗口模式。例如，它可以是全屏、浮动等模式。requestedWidth、requestedHeight：这是应用程序请求的窗口宽度和高度。requestedVisibilities：请求的可见性。这定义了应用程序请求的边距可见性，例如状态栏或导航栏是否可见。attachedWindowFrame：附加窗口的边界。如果这个窗口是附加到另一个窗口的，这个参数表示它相对于其父窗口的位置和大小。compatScale：兼容性比例，一个缩放因子，用于调整窗口内容的显示大小以适应不同的屏幕尺寸或分辨率。outFrames：用于返回计算后的窗口信息。它包含了窗口的实际边界、边距等信息。代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowLayout.java public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state, Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode, int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities, Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames) &#123; //传入的参数attrs中提取出窗口的类型（type）、标志（fl）、私有标志（pfl）和布局是否在屏幕内（layoutInScreen） final int type = attrs.type; final int fl = attrs.flags; final int pfl = attrs.privateFlags; final boolean layoutInScreen = (fl &amp; FLAG_LAYOUT_IN_SCREEN) == FLAG_LAYOUT_IN_SCREEN; //定义了用于存储结果的矩形变量，包含：显示边界（outDisplayFrame）、父边界（outParentFrame）和实际边界（outFrame） final Rect outDisplayFrame = outFrames.displayFrame; final Rect outParentFrame = outFrames.parentFrame; final Rect outFrame = outFrames.frame; // Compute bounds restricted by insets //计算窗口被Insets限制的边界。Insets是屏幕边缘的空间，用于放置状态栏、导航栏等。 //这一步通过调用state.calculateInsets()方法完成，该方法需要窗口边界和窗口布局参数作为输入。 final Insets insets = state.calculateInsets(windowBounds, attrs.getFitInsetsTypes(), attrs.isFitInsetsIgnoringVisibility()); //代码根据Insets的边类型（LEFT、TOP、RIGHT、BOTTOM），从计算出的Insets中提取出相应的边距， //并将它们添加到窗口的原始边界上，得到显示边界。 final @WindowInsets.Side.InsetsSide int sides = attrs.getFitInsetsSides(); final int left = (sides &amp; WindowInsets.Side.LEFT) != 0 ? insets.left : 0; final int top = (sides &amp; WindowInsets.Side.TOP) != 0 ? insets.top : 0; final int right = (sides &amp; WindowInsets.Side.RIGHT) != 0 ? insets.right : 0; final int bottom = (sides &amp; WindowInsets.Side.BOTTOM) != 0 ? insets.bottom : 0; //代码将计算出的显示边界赋值给outDisplayFrame outDisplayFrame.set(windowBounds.left + left, windowBounds.top + top, windowBounds.right - right, windowBounds.bottom - bottom); //根据窗口的附加信息和布局属性来确定父边界的位置和大小。 if (attachedWindowFrame == null) &#123; //将outParentFrame设置为与outDisplayFrame相同，这意味着父边界与显示边界相同 outParentFrame.set(outDisplayFrame); //检查私有标志PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME是否被设置。 //这个标志可能表示是否需要根据输入法窗口（IME）的位置来调整父边界。 if ((pfl &amp; PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME) != 0) &#123; //从状态中获取输入法窗口的源（source） final InsetsSource source = state.peekSource(ITYPE_IME); if (source != null) &#123; //如果输入法窗口的source存在，则使用该source来计算父边界的内边距（Insets）。 outParentFrame.inset(source.calculateInsets( outParentFrame, false /* ignoreVisibility */));//这里忽略source的可见性。 &#125; &#125; &#125; else &#123; //如果layoutInScreen为true，则将outParentFrame设置为与attachedWindowFrame相同。 //这表示父边界是由附加窗口的边界决定的。 //如果layoutInScreen为false，则将outParentFrame设置为与outDisplayFrame相同。 //这表示父边界与显示边界相同。 outParentFrame.set(!layoutInScreen ? attachedWindowFrame : outDisplayFrame); &#125; // Compute bounds restricted by display cutout //根据屏幕的显示切边和窗口的布局属性来计算窗口在屏幕上受到限制的位置和大小，确保窗口不会覆盖到显示切边区域 final int cutoutMode = attrs.layoutInDisplayCutoutMode;//切边模式 final DisplayCutout cutout = state.getDisplayCutout();//屏幕上的显示切边区域 //将displayCutoutSafeExceptMaybeBars设置为与displayCutoutSafe相同， //这是一个临时矩形，用于稍后计算不受某些系统界面元素（如状态栏）影响的显示切边安全区域。 final Rect displayCutoutSafeExceptMaybeBars = mTempDisplayCutoutSafeExceptMaybeBarsRect; displayCutoutSafeExceptMaybeBars.set(displayCutoutSafe); //将outFrames.isParentFrameClippedByDisplayCutout设置为false，表示父边界目前没有被显示切边裁剪 outFrames.isParentFrameClippedByDisplayCutout = false; //如果layoutInDisplayCutoutMode不是ALWAYS并且显示切边不为空 if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS &amp;&amp; !cutout.isEmpty()) &#123; // Ensure that windows with a non-ALWAYS display cutout mode are laid out in // the cutout safe zone. //获取屏幕的显示边界（displayFrame） final Rect displayFrame = state.getDisplayFrame(); //获取状态的Source final InsetsSource statusBarSource = state.peekSource(ITYPE_STATUS_BAR); //检查状态栏源（statusBarSource）是否存在，并且如果displayCutoutSafe.top大于屏幕的顶部 if (statusBarSource != null &amp;&amp; displayCutoutSafe.top &gt; displayFrame.top) &#123; // Make sure that the zone we&#39;re avoiding for the cutout is at least as tall as the // status bar; otherwise fullscreen apps will end up cutting halfway into the status // bar. //调整displayCutoutSafeExceptMaybeBars.top以确保切边避开的区域至少与状态栏一样高。 displayCutoutSafeExceptMaybeBars.top = Math.max(statusBarSource.getFrame().bottom, displayCutoutSafe.top); &#125; //如果layoutInDisplayCutoutMode是SHORT_EDGES if (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES) &#123; if (displayFrame.width() &lt; displayFrame.height()) &#123; //如果屏幕的宽度小于高度，则将displayCutoutSafeExceptMaybeBars的顶部和底部设置为最大和最小整数值， //这意味着不考虑这些方向上的显示切边。 displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE; displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE; &#125; else &#123; //否则，将左侧和右侧设置为最大和最小整数值 //这意味着不考虑这些方向上的显示切边。 displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE; displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE; &#125; &#125; //通过位运算检查attrs.flags中的FLAG_LAYOUT_INSET_DECOR标志是否被设置。如果被设置，则layoutInsetDecor为true // FLAG_LAYOUT_INSET_DECOR:使窗口的内容布局在DecorView（装饰视图）之内 final boolean layoutInsetDecor = (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) != 0; //检查布局是否应在屏幕上进行且是否需要考虑显示切边 //布局在屏幕上、DecorView之内 且 显示切边模式为默认或短边缘模式 if (layoutInScreen &amp;&amp; layoutInsetDecor &amp;&amp; (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT || cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)) &#123; //使用给定的displayFrame、系统栏类型和可见性请求来计算系统栏的插入 //系统栏包含： STATUS_BARS | NAVIGATION_BARS | CAPTION_BAR final Insets systemBarsInsets = state.calculateInsets( displayFrame, WindowInsets.Type.systemBars(), requestedVisibilities); //如果系统栏在左侧、顶部、右侧或底部的插入大于0，则调整displayCutoutSafeExceptMaybeBars的相应边界， //使其尽可能地远离屏幕边缘。这是为了确保窗口不会覆盖到这些系统栏。 if (systemBarsInsets.left &gt; 0) &#123; displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE; &#125; if (systemBarsInsets.top &gt; 0) &#123; displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE; &#125; if (systemBarsInsets.right &gt; 0) &#123; displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE; &#125; if (systemBarsInsets.bottom &gt; 0) &#123; displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE; &#125; &#125; //如果窗口类型是输入法（IME） if (type == TYPE_INPUT_METHOD) &#123; //获取导航栏的Source final InsetsSource navSource = state.peekSource(ITYPE_NAVIGATION_BAR); //如果存在导航栏且其底部插入大于0 if (navSource != null &amp;&amp; navSource.calculateInsets(displayFrame, true).bottom &gt; 0) &#123; // The IME can always extend under the bottom cutout if the navbar is there. //调整displayCutoutSafeExceptMaybeBars.bottom，允许IME窗口扩展到底部显示切边以下。 //这是为了确保IME可以正常显示在有导航栏的设备上。 displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE; &#125; &#125; //如果窗口已附加到其父窗口并且不是全屏布局，则attachedInParent为true final boolean attachedInParent = attachedWindowFrame != null &amp;&amp; !layoutInScreen; // TYPE_BASE_APPLICATION windows are never considered floating here because they don&#39;t // get cropped / shifted to the displayFrame in WindowState. //判断窗口是否为浮窗 //如果窗口不是全屏的、全屏布局的并且不是基础应用程序类型，那么它是一个浮动在屏幕上的窗口，简称浮窗。 final boolean floatingInScreenWindow = !attrs.isFullscreen() &amp;&amp; layoutInScreen &amp;&amp; type != TYPE_BASE_APPLICATION; // Windows that are attached to a parent and laid out in said parent already avoid // the cutout according to that parent and don&#39;t need to be further constrained. // Floating IN_SCREEN windows get what they ask for and lay out in the full screen. // They will later be cropped or shifted using the displayFrame in WindowState, // which prevents overlap with the DisplayCutout. //对于非附加到父窗口和非浮动在屏幕上的窗口，需要处理其与显示切边的交集。这是因为这些窗口需要避免与显示切边重叠。 if (!attachedInParent &amp;&amp; !floatingInScreenWindow) &#123; mTempRect.set(outParentFrame); //临时存储父窗口的边界 //将父窗口的边界设置为与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界 outParentFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars); //如果父窗口的边界交集后与原始边界不同，则表示父窗口的边界被切边裁剪了 outFrames.isParentFrameClippedByDisplayCutout = !mTempRect.equals(outParentFrame); &#125; //将输出显示边界设置与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界 outDisplayFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars); &#125; //检查attrs.flags中的FLAG_LAYOUT_NO_LIMITS位是否被设置。 //FLAG_LAYOUT_NO_LIMITS表示允许窗口布局到屏幕外侧。 final boolean noLimits = (attrs.flags &amp; FLAG_LAYOUT_NO_LIMITS) != 0; //检查当前窗口是否处于多窗口模式 final boolean inMultiWindowMode = WindowConfiguration.inMultiWindowMode(windowingMode); // TYPE_SYSTEM_ERROR is above the NavigationBar so it can&#39;t be allowed to extend over it. // Also, we don&#39;t allow windows in multi-window mode to extend out of the screen. //noLimits是否为true即允许窗口布局到屏幕外） //type是否不等于TYPE_SYSTEM_ERROR（表示窗口类型不是系统错误） //inMultiWindowMode是否为false（表示窗口不在多窗口模式下） if (noLimits &amp;&amp; type != TYPE_SYSTEM_ERROR &amp;&amp; !inMultiWindowMode) &#123; //设置输出显示的窗口边界 //[left,top]为左上角左边，[right,bottom]为右上角坐标，两个坐标构成一个矩形 //左上角左边设置为屏幕最小点，右下角坐标设置为屏幕最大点，即窗口将占据整个屏幕的边界 outDisplayFrame.left = MIN_X; outDisplayFrame.top = MIN_Y; outDisplayFrame.right = MAX_X; outDisplayFrame.bottom = MAX_Y; &#125; //如果compatScale不等于1，则hasCompatScale为true。这意味着存在一个兼容的缩放因子。 final boolean hasCompatScale = compatScale != 1f; //父窗口的宽度和高度 final int pw = outParentFrame.width(); final int ph = outParentFrame.height(); //判断窗口的布局尺寸是否因为显示切边而扩展 //某些设备可能具有物理上的切边（如刘海屏、水滴屏等），这些切边区域不能用于显示内容。 //PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT作用就是为了确保应用程序的布局在具有切边的设备上仍然正确显示 //设置这个标志时，窗口的实际尺寸将大于其请求的尺寸，以便在切边区域周围填充空间。 final boolean extendedByCutout = (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != 0; //请求的窗口宽度和高度 int rw = requestedWidth; int rh = requestedHeight; //窗口的位置坐标 float x, y; //最终确定的窗口宽度和高度 int w, h; // If the view hierarchy hasn&#39;t been measured, the requested width and height would be // UNSPECIFIED_LENGTH. This can happen in the first layout of a window or in the simulated // layout. If extendedByCutout is true, we cannot use the requested lengths. Otherwise, // the window frame might be extended again because the requested lengths may come from the // window frame. //如果请求的窗口宽度或高度，是UNSPECIFIED_LENGTH或者窗口因为显示切边而扩展， //那么其大于或等于0则使用attrs.width或attrs.height的值，否则使用父窗口的宽度和高度 if (rw == UNSPECIFIED_LENGTH || extendedByCutout) &#123; rw = attrs.width &gt;= 0 ? attrs.width : pw; &#125; if (rh == UNSPECIFIED_LENGTH || extendedByCutout) &#123; rh = attrs.height &gt;= 0 ? attrs.height : ph; &#125; //如果设置了FLAG_SCALED标志，代码会根据是否应用兼容性缩放来调整窗口的宽度和高度。 if ((attrs.flags &amp; FLAG_SCALED) != 0) &#123; if (attrs.width &lt; 0) &#123; w = pw; &#125; else if (hasCompatScale) &#123; w = (int) (attrs.width * compatScale + .5f); &#125; else &#123; w = attrs.width; &#125; if (attrs.height &lt; 0) &#123; h = ph; &#125; else if (hasCompatScale) &#123; h = (int) (attrs.height * compatScale + .5f); &#125; else &#123; h = attrs.height; &#125; &#125; else &#123; if (attrs.width == MATCH_PARENT) &#123; w = pw; &#125; else if (hasCompatScale) &#123; w = (int) (rw * compatScale + .5f); &#125; else &#123; w = rw; &#125; if (attrs.height == MATCH_PARENT) &#123; h = ph; &#125; else if (hasCompatScale) &#123; h = (int) (rh * compatScale + .5f); &#125; else &#123; h = rh; &#125; &#125; //如果存在兼容缩放因子，则调整窗口的x和y位置以考虑缩放。否则，直接使用原始的x和y位置。 if (hasCompatScale) &#123; x = attrs.x * compatScale; y = attrs.y * compatScale; &#125; else &#123; x = attrs.x; y = attrs.y; &#125; //当前窗口是多窗口且设置PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME //PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME的作用是窗口应该根据其父窗口的边界来调整自己的大小和位置。 //即控制子窗口在其父窗口内的布局行为，确保子窗口不会超出父窗口的边界。 if (inMultiWindowMode &amp;&amp; (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME) == 0) &#123; // Make sure window fits in parent frame since it is in a non-fullscreen task as // required by &#123;@link Gravity#apply&#125; call. //将窗口的宽度和高度分别设置为它们与父窗口宽度和高度中的较小值。 //这样做的目的是确保子窗口的大小不会超过其父窗口的大小。 w = Math.min(w, pw); h = Math.min(h, ph); &#125; // We need to fit it to the display if either // a) The window is in a fullscreen container, or we don&#39;t have a task (we assume fullscreen // for the taskless windows) // b) If it&#39;s a secondary app window, we also need to fit it to the display unless // FLAG_LAYOUT_NO_LIMITS is set. This is so we place Popups, dialogs, and similar windows on // screen, but SurfaceViews want to be always at a specific location so we don&#39;t fit it to // the display. //如果窗口不在多窗口模式下，或者窗口类型不是基础应用程序类型并且noLimits标志未设置，那么窗口需要适应显示。 final boolean fitToDisplay = !inMultiWindowMode || ((attrs.type != TYPE_BASE_APPLICATION) &amp;&amp; !noLimits); // Set mFrame //根据给定的重力属性、宽度、高度、父边界等，计算并设置outFrame。 //这里主要是确定窗口的位置。 Gravity.apply(attrs.gravity, w, h, outParentFrame, (int) (x + attrs.horizontalMargin * pw), (int) (y + attrs.verticalMargin * ph), outFrame); // Now make sure the window fits in the overall display frame. //如果窗口需要适应显示，那么使用Gravity.applyDisplay方法来调整outFrame(实际边界)的大小和位置在outDisplayFrame(显示边界)之内。 if (fitToDisplay) &#123; Gravity.applyDisplay(attrs.gravity, outDisplayFrame, outFrame); &#125; //确保应用窗口的位置不会与设备的切边冲突。 //如果窗口的布局因为切边的存在而进行了扩展，并且窗口的边界超出了安全区域，那么它会调整窗口的位置，使其位于安全区域内。 if (extendedByCutout &amp;&amp; !displayCutoutSafe.contains(outFrame)) &#123; mTempRect.set(outFrame); // Move the frame into displayCutoutSafe. final int clipFlags = DISPLAY_CLIP_VERTICAL | DISPLAY_CLIP_HORIZONTAL; Gravity.applyDisplay(attrs.gravity &amp; ~clipFlags, displayCutoutSafe, mTempRect); if (mTempRect.intersect(outDisplayFrame)) &#123; outFrame.union(mTempRect); &#125; &#125; if (DEBUG) Log.d(TAG, &quot;computeWindowFrames &quot; + attrs.getTitle() + &quot; outFrames=&quot; + outFrames + &quot; windowBounds=&quot; + windowBounds.toShortString() + &quot; attachedWindowFrame=&quot; + (attachedWindowFrame != null ? attachedWindowFrame.toShortString() : &quot;null&quot;) + &quot; requestedWidth=&quot; + requestedWidth + &quot; requestedHeight=&quot; + requestedHeight + &quot; compatScale=&quot; + compatScale + &quot; windowingMode=&quot; + WindowConfiguration.windowingModeToString(windowingMode) + &quot; displayCutoutSafe=&quot; + displayCutoutSafe + &quot; attrs=&quot; + attrs + &quot; state=&quot; + state + &quot; requestedVisibilities=&quot; + requestedVisibilities); &#125; computeFrame方法是WindowState类中的一个重要方法，用于计算窗口的位置和大小。具体来说，它负责计算窗口的绘制区域，即窗口的内容在屏幕上实际显示的位置和大小。这个计算涉及到考虑窗口的位置、大小、布局参数以及可能的边界限制，确保窗口内容不会超出屏幕边界或被其他窗口遮挡。 在窗口管理器中，computeFrame方法通常会在以下情况被调用： 当窗口第一次被创建时，需要计算其初始位置和大小。 当窗口的布局参数或内容发生变化时，需要重新计算窗口的位置和大小。 当屏幕旋转或大小变化等系统事件发生时，需要调整所有窗口的位置和大小。 总之，computeFrame方法在Android窗口管理系统中起到了非常重要的作用，确保应用程序窗口能够正确地在屏幕上显示，并且适应不同的设备和系统事件, 为了计算小窗的位置，以及处理小窗内的View 的边界异常情况， 再来看看setFrames，更新窗口大小位置变化 win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight); 调用的是WindowState的setFrames方法入参说明：sTmpClientFrames：在computeFrames方法计算后的值，用于传递的窗口位置大小相关信息requestedWidth、requestedHeight：这是应用程序请求的窗口宽度和高度。代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java void setFrames(ClientWindowFrames clientWindowFrames, int requestedWidth, int requestedHeight) &#123; final WindowFrames windowFrames = mWindowFrames; //用mTmpRect存储windowFrames.mParentFrame mTmpRect.set(windowFrames.mParentFrame); //LOCAL_LAYOUTd的值取决于配置项persist.debug.local_layout的值 if (LOCAL_LAYOUT) &#123; //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。 windowFrames.mCompatFrame.set(clientWindowFrames.frame); //将clientWindowFrames.frame的值设置为windowFrames.mFrame。 //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。 //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。 windowFrames.mFrame.set(clientWindowFrames.frame); windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame); windowFrames.mParentFrame.set(clientWindowFrames.parentFrame); if (hasCompatScale()) &#123; // The frames sent from the client need to be adjusted to the real coordinate space. //如果存在兼容比例（通过调用hasCompatScale()方法检查），则对windowFrames中的Frame进行缩放，以适应实际的坐标空间。 //这里使用mGlobalScale作为缩放因子。 windowFrames.mFrame.scale(mGlobalScale); windowFrames.mDisplayFrame.scale(mGlobalScale); windowFrames.mParentFrame.scale(mGlobalScale); &#125; &#125; else &#123; //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。 //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。 //将clientWindowFrames.frame的值设置为windowFrames.mFrame。 windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame); windowFrames.mParentFrame.set(clientWindowFrames.parentFrame); windowFrames.mFrame.set(clientWindowFrames.frame); //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。 windowFrames.mCompatFrame.set(windowFrames.mFrame); if (hasCompatScale()) &#123; // Also, the scaled frame that we report to the app needs to be adjusted to be in // its coordinate space. //仅对windowFrames.mCompatFrame缩放 windowFrames.mCompatFrame.scale(mInvGlobalScale); &#125; &#125; //isParentFrameClippedByDisplayCutout是一个Boolean //如果为true，表示父窗口的边界被显示切边裁剪了；如果为false，表示父窗口的边界没有被显示切边裁剪。 windowFrames.setParentFrameWasClippedByDisplayCutout( clientWindowFrames.isParentFrameClippedByDisplayCutout); // Calculate relative frame //将mRelFrame设置为与mFrame相同的值。这意味着mRelFrame现在存储了与mFrame相同的位置和尺寸信息。 windowFrames.mRelFrame.set(windowFrames.mFrame); //获取当前窗口的父容器 WindowContainer&lt;?&gt; parent = getParent(); //初始化parentLeft和parentTop为0，表示父容器的左上角坐标 int parentLeft = 0; int parentTop = 0; if (mIsChildWindow) &#123;//如果当前窗口是一个子窗口 //从父窗口的状态中获取其边界的位置信息。 parentLeft = ((WindowState) parent).mWindowFrames.mFrame.left; parentTop = ((WindowState) parent).mWindowFrames.mFrame.top; &#125; else if (parent != null) &#123;//如果当前窗口不是子窗口，并且父容器不为空 //获取父容器的边界位置 final Rect parentBounds = parent.getBounds(); parentLeft = parentBounds.left; parentTop = parentBounds.top; &#125; //调整mRelFrame的位置，使其相对于父容器的左上角有一个偏移 windowFrames.mRelFrame.offsetTo(windowFrames.mFrame.left - parentLeft, windowFrames.mFrame.top - parentTop); //如果请求的宽度、高度或者父框架与上次不同 if (requestedWidth != mLastRequestedWidth || requestedHeight != mLastRequestedHeight || !mTmpRect.equals(windowFrames.mParentFrame)) &#123; //更新最后请求的宽度和高度，并标记内容已更改 mLastRequestedWidth = requestedWidth; mLastRequestedHeight = requestedHeight; windowFrames.setContentChanged(true); &#125; //如果窗口的类型是TYPE_DOCK_DIVIDER，并且边界的位置发生了变化，mMovedByResize标记为true。 //在分屏的场合，YPE_DOCK_DIVIDER窗口类型用于绘制这个分隔栏，并处理用户的触摸事件以实现大小调整功能。 if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123; if (!windowFrames.mFrame.equals(windowFrames.mLastFrame)) &#123; mMovedByResize = true; &#125; &#125; //如果当前窗口是壁纸，并且框架的宽度或高度发生了变化，更新壁纸的位置。 if (mIsWallpaper) &#123; final Rect lastFrame = windowFrames.mLastFrame; final Rect frame = windowFrames.mFrame; if (lastFrame.width() != frame.width() || lastFrame.height() != frame.height()) &#123; mDisplayContent.mWallpaperController.updateWallpaperOffset(this, false /* sync */); &#125; &#125; //更新windowFrames.mFrame updateSourceFrame(windowFrames.mFrame); //如果定义了LOCAL_LAYOUT，并且还没有边界，更新最后边界的位置。 if (LOCAL_LAYOUT) &#123; if (!mHaveFrame) &#123; // The first frame should not be considered as moved. updateLastFrames(); &#125; &#125; //如果存在活动记录，并且当前窗口不是子窗口 if (mActivityRecord != null &amp;&amp; !mIsChildWindow) &#123; //调用mActivityRecord.layoutLetterbox(this);来填充空白区域。也就是Letterbox模式 mActivityRecord.layoutLetterbox(this); &#125; //设置mSurfacePlacementNeeded为true。 mSurfacePlacementNeeded = true; //设置mHaveFrame为true，表示已经设置了边界 mHaveFrame = true; &#125; 其中WindowFrames 是一个表示窗口边框大小和位置的类。WindowFrames 中有一些重要成员变量，用于描述不同的窗口区域。 mFrame表示窗口在屏幕上的位置和大小，是窗口管理和界面绘制的基础依据。mVisibleFrame表示窗口可见区域的位置和大小，即除去状态栏和导航栏等系统 UI 元素后，窗口实际可以显示的区域。mDecorFrame表示窗口装饰区域的位置和大小，即窗口除去实际内容区域外，包含的标题栏、边框、按钮等 UI 元素所占用的空间。mDisplayFrame表示整个屏幕的可见区域的位置和大小，也就是说它包含了状态栏和导航栏等系统 UI 元素。 这些成员变量共同描述了窗口在屏幕中的位置和大小，并提供给其他模块使用，比如 WindowManager 和 View 系统。在 Android Framework 中，WindowManagerService 会在每次窗口大小发生变化时，调用 WindowFrames 的 setFrames() 方法，更新这些成员变量的值。 2.3 窗口状态刷新当应用端执行measure-layout-draw之后，便会调用WindowManagerService.finishDrawingWindow，处理Surface的状态变更并将Surface show出来。首先还是看一下该阶段的流程图，对整个流程有个初步的了解。将整个流程分为三部分：1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PENDING，并请求窗口布局。2.mDrawState更新为HAS_DRAW，再次请求窗口布局。3.执行show Surface。 2.3.1 接受客户端请求代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java @Override public void finishDrawing(IWindow window, @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123; if (DEBUG) Slog.v(TAG_WM, &quot;IWindow finishDrawing called for &quot; + window); //调用WMS中的finishDrawingWindow处理 mService.finishDrawingWindow(this, window, postDrawTransaction, seqId); &#125; 2.3.2 finishDrawingWindow1.在WMS中根据客户端的Binder在mWindowMap中获取对应的WindowState。2.调用WindowState.finishDrawing执行mDrawState的状态变更。3.将WindowState.mLayoutNeeded标志位置为true。4.请求进行布局刷新。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java void finishDrawingWindow(Session session, IWindow client, @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123; if (postDrawTransaction != null) &#123; postDrawTransaction.sanitize(); &#125; final long origId = Binder.clearCallingIdentity(); try &#123; synchronized (mGlobalLock) &#123; /*1.根据客户端的Binder在mWindowMap中获取对应的WindowState*/ WindowState win = windowForClientLocked(session, client, false); ProtoLog.d(WM_DEBUG_ADD_REMOVE, &quot;finishDrawingWindow: %s mDrawState=%s&quot;, win, (win != null ? win.mWinAnimator.drawStateToString() : &quot;null&quot;)); /*2.finishDrawing执行mDrawState的状态更变*/ if (win != null &amp;&amp; win.finishDrawing(postDrawTransaction, seqId)) &#123; if (win.hasWallpaper()) &#123; win.getDisplayContent().pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER; &#125; /*3.将当前WindowState.mLayoutNeeded置为true*/ //该标志位是判断是否进行窗口大小尺寸计算的条件之一 win.setDisplayLayoutNeeded(); /*4.请求进行布局刷新*/ mWindowPlacerLocked.requestTraversal(); &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125; 1.mDrawState的状态更变在finishDrawingWindow中调用WindowState的finishDrawing方法win.finishDrawing(postDrawTransaction, seqId)这个方法主要调用了WindowStateAnimator的finishDrawingLocked进行状态更变代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java boolean finishDrawing(SurfaceControl.Transaction postDrawTransaction, int syncSeqId) &#123; ...... //调用WindowStateAnimator.finishDrawingLocked，会将mDrawState的状态更改为COMMIT_DRAW_PENDING final boolean layoutNeeded = mWinAnimator.finishDrawingLocked(postDrawTransaction, mClientWasDrawingForSync); mClientWasDrawingForSync = false; // We always want to force a traversal after a finish draw for blast sync. return !skipLayout &amp;&amp; (hasSyncHandlers || layoutNeeded); &#125; 我们继续看看WindowStateAnimator中的finishDrawingLocked()方法首先判断mDrawState的状态是否为DRAW_PENDING，在我们创建SurfaceControl时，会将mDrawState状态更新为DRAW_PENDING。因此接下来将状态调整为COMMIT_DRAW_PENDING。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java boolean finishDrawingLocked(SurfaceControl.Transaction postDrawTransaction, boolean forceApplyNow) &#123; ...... boolean layoutNeeded = false; if (mDrawState == DRAW_PENDING) &#123; ...... //如果当前状态为DRAW_PENDING，则将mDrawState更变为COMMIT_DRAW_PENDING mDrawState = COMMIT_DRAW_PENDING; layoutNeeded = true; &#125; ...... return layoutNeeded; &#125; 2.请求布局刷新在finishDrawingWindow中请求布局刷新mWindowPlacerLocked.requestTraversal();requestTraversal中主要做了两件事：1.首先将遍历标志为mTraversalSchedule置为true。2.其次发送handle消息mPerformSurfacePlacement void requestTraversal() &#123; //判断遍历标志mTraversalScheduled是否为true if (mTraversalScheduled) &#123; return; &#125; // Set as scheduled even the request will be deferred because mDeferredRequests is also // increased, then the end of deferring will perform the request. //将遍历标志位置为true mTraversalScheduled = true; if (mDeferDepth &gt; 0) &#123; mDeferredRequests++; if (DEBUG) Slog.i(TAG, &quot;Defer requestTraversal &quot; + Debug.getCallers(3)); return; &#125; //发送handle消息，处理消息会调用mPerformSurfacePlacement mService.mAnimationHandler.post(mPerformSurfacePlacement); &#125; mPerformSurfacePlacement会新建一个线程调用performSurfacePlacement。performSurfacePlacement方法我们在讲relayoutWindow相关流程的时候讲过，这是执行遍历布局的入口。可以回看下【2.2.4 计算窗口大小位置中的“1.处理窗口布局循环”】 private class Traverser implements Runnable &#123; @Override public void run() &#123; synchronized (mService.mGlobalLock) &#123; //调用执行performSurfacePlacement performSurfacePlacement(); &#125; &#125; &#125; private final Traverser mPerformSurfacePlacement = new Traverser(); final void performSurfacePlacement(boolean force) &#123; //当mDeferDepth大于0且force为false时，则将延迟布局请求数+1，并直接返回 if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123; mDeferredRequests++; return; &#125; //将循环的最大次数设置为6次 int loopCount = 6; do &#123; //将该标志为设置为false mTraversalScheduled = false; //执行窗口布局操作 performSurfacePlacementLoop(); mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement); loopCount--; //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局 &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0); mService.mRoot.mWallpaperActionPending = false; &#125; private void performSurfacePlacementLoop() &#123; //若当前已经进行布局操作，则无需重复调用直接返回 if (mInLayout) &#123; ...... return; &#125; ...... //将该标志位置为true，表示正在处于布局过程中 mInLayout = true; ...... try &#123; /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/ mService.mRoot.performSurfacePlacement(); mInLayout = false; if (mService.mRoot.isLayoutNeeded()) &#123; /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/ if (++mLayoutRepeatCount &lt; 6) &#123; //该方法中会将mTraversalScheduled标志位设置位true requestTraversal(); &#125; else &#123; Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;); mLayoutRepeatCount = 0; &#125; &#125; else &#123; mLayoutRepeatCount = 0; &#125; if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123; mService.mH.removeMessages(REPORT_WINDOWS_CHANGE); mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE); &#125; &#125; catch (RuntimeException e) &#123; mInLayout = false; Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e); &#125; &#125; 代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java void performSurfacePlacement() &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;); try &#123; //调用performSurfacePlacementNoTrace() performSurfacePlacementNoTrace(); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; // &quot;Something has changed! Let&#39;s make it correct now.&quot; // TODO: Super long method that should be broken down... void performSurfacePlacementNoTrace() &#123; ...... /*1.如果有焦点变化，更新焦点*/ if (mWmService.mFocusMayChange) &#123; mWmService.mFocusMayChange = false; mWmService.updateFocusedWindowLocked( UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/); &#125; ...... Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;); //开启事务，获取GlobalTransactionWrapper对象 mWmService.openSurfaceTransaction(); try &#123; /*2.执行窗口尺寸计算，surface状态变更等操作*/ applySurfaceChangesTransaction(); &#125; catch (RuntimeException e) &#123; Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e); &#125; finally &#123; //关闭事务，把事务提交 mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); if (SHOW_LIGHT_TRANSACTIONS) &#123; Slog.i(TAG, &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;); &#125; &#125; ...... /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/ checkAppTransitionReady(surfacePlacer); ...... /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/ for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123; final DisplayContent displayContent = mChildren.get(displayNdx); //判断DisplayContent的壁纸是否需要改变 if (displayContent.mWallpaperMayChange) &#123; ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change! Adjusting&quot;); displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; if (DEBUG_LAYOUT_REPEATS) &#123; surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;, displayContent.pendingLayoutChanges); &#125; &#125; &#125; /*5.在此处理焦点变化*/ if (mWmService.mFocusMayChange) &#123; mWmService.mFocusMayChange = false; mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, false /*updateInputWindows*/); &#125; ...... /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/ handleResizingWindows(); if (mWmService.mDisplayFrozen) &#123; ProtoLog.v(WM_DEBUG_ORIENTATION, &quot;With display frozen, orientationChangeComplete=%b&quot;, mOrientationChangeComplete); &#125; if (mOrientationChangeComplete) &#123; if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123; mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE; mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource; mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT); &#125; mWmService.stopFreezingDisplayLocked(); &#125; // Destroy the surface of any windows that are no longer visible. /*7.销毁不可见的窗口*/ i = mWmService.mDestroySurface.size(); if (i &gt; 0) &#123; do &#123; i--; WindowState win = mWmService.mDestroySurface.get(i); win.mDestroying = false; final DisplayContent displayContent = win.getDisplayContent(); if (displayContent.mInputMethodWindow == win) &#123; displayContent.setInputMethodWindowLocked(null); &#125; if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; win.destroySurfaceUnchecked(); &#125; while (i &gt; 0); mWmService.mDestroySurface.clear(); &#125; ...... &#125; ​ 这里我们主要关注applySurfaceChangesTransaction();和checkAppTransitionReady(surfacePlacer); * 窗口位置计算与窗口状态刷新流程不同点可以发现，窗口位置计算流程与窗口状态刷新流程都调用了performSurfacePlacement，两次调用的主要不同点在于：1.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用mApplySurfaceChangesTransaction，处理mDrawState状态。2.窗口状态刷新流程在RootWindowContainer.performSurfacePlacementNoTrace中调用checkAppTransitionReady，处理mDrawState状态变更为HAS_DRAWN，触发Activity过渡动画。3.窗口状态刷新流程在WindowSurfacePlacementLoop.performSurfacePlacementLoop中会调用requestTraversal，请求再次布局。4.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用prepareSurfaces()处理处理surface的位置、大小以及显示等。 2.3.3 mDrawState变更为HAS_DRAW1.mApplySurfaceChangesTransactionRootWindowContainer的applySurfaceChangesTransaction()方法最终会调用到DisplayContent中调用的applySurfaceChangesTransaction()方法（【2.2.4 计算窗口大小位置】中讲过流程，不再赘述）我们接着该方法中的mApplySurfaceChangesTransaction跟踪。forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);如果当前WindowState存在surfaceControl，则进入到WindowStateAnimator进行mDrawState的状态更变。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123; ...... //首先判断当前windowState的是否有surfaceControl if (w.mHasSurface) &#123; // Take care of the window being ready to display. //调用WindowStateAnimator的commitFinishDrawingLocked()方法 final boolean committed = winAnimator.commitFinishDrawingLocked(); ...... &#125; ...... &#125;; 继续看看WindowStateAnimator的commitFinishDrawingLocked()方法final boolean committed = winAnimator.commitFinishDrawingLocked();1.对mDrawState的状态进行过滤，非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回。2.此时我们的mDrawState已经在“【2.3.2 finishDrawingWindow】”将状态更新为COMMIT_DRAW_PENDING，因此此处将其变更为READY_TO_SHOW。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java // This must be called while inside a transaction. boolean commitFinishDrawingLocked() &#123; //非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回 if (mDrawState != COMMIT_DRAW_PENDING &amp;&amp; mDrawState != READY_TO_SHOW) &#123; return false; &#125; ProtoLog.i(WM_DEBUG_ANIM, &quot;commitFinishDrawingLocked: mDrawState=READY_TO_SHOW %s&quot;, mSurfaceController); //将状态更变为READY_TO_SHOW mDrawState = READY_TO_SHOW; boolean result = false; final ActivityRecord activity = mWin.mActivityRecord; //直接进入到WindowState.performShowLocked()流程的三种情况 //1.如果ActivityRecord为空，这种情况可以理解为不依赖Activity的窗口，比如常见的悬浮窗 //2.或者canShowWindows()为true，这个方法大概是说：只有当所有窗口都已绘制完成，并且没有正在进行父级窗口的应用过渡动画，并且没有非默认颜色的窗口存在时，返回true //3.或者窗口类型为启动窗口，启动窗口就是StartingWindow，应用启动时出现的窗口，常见的就是Splash screen ，许多应用都会定义自己的SplashActivity //进入performShowLocked()流程后mDrawState更新HAS_DRAWN //由于非这三种情况最终也会调用到performShowLocked()，因此下面这种情况我们暂不讨论 if (activity == null || activity.canShowWindows() || mWin.mAttrs.type == TYPE_APPLICATION_STARTING) &#123; result = mWin.performShowLocked(); &#125; return result; &#125; 2.checkAppTransitionReady()这里我们继续跟踪RootWindowContainer.performSurfacePlacementNoTrace()方法中的checkAppTransitionReady()方法checkAppTransitionReady(surfacePlacer);该方法会遍历所有DisplayContent，处理activity的过滤动画，此处我们只有跟踪有关mDrawState状态更变的相关代码代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java private void checkAppTransitionReady(WindowSurfacePlacer surfacePlacer) &#123; // Trace all displays app transition by Z-order for pending layout change. for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123; final DisplayContent curDisplay = mChildren.get(i); // If we are ready to perform an app transition, check through all of the app tokens // to be shown and see if they are ready to go. //检查所有要显示的app token，是否已经准备就绪 if (curDisplay.mAppTransition.isReady()) &#123; // handleAppTransitionReady may modify curDisplay.pendingLayoutChanges. curDisplay.mAppTransitionController.handleAppTransitionReady(); if (DEBUG_LAYOUT_REPEATS) &#123; surfacePlacer.debugLayoutRepeats(&quot;after handleAppTransitionReady&quot;, curDisplay.pendingLayoutChanges); &#125; &#125; ...... &#125; &#125; 调用AppTransitionController的handleAppTransitionReady()方法，该方法主要做了以下事情1.处理activity的过渡动画（远程动画）2.分别调用 handleClosingApps以及handleOpeningApps对要关闭的和要打开的Activity进行可见性更新。3.由于activity的可见性变更，将DisplayContent.mLayoutNeeded设置为true，该标志位在DisplayContent.performLayoutNoTrace中用来判断是否对当前DisplayContent下的所有窗口进行刷新。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;AppTransitionController.java /** * Handle application transition for given display. */ void handleAppTransitionReady() &#123; ...... try &#123; /*1.1应用app transition动画（远程动画）*/ applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp, voiceInteraction); /*1.2处理closing activity可见性*/ handleClosingApps(); /*1.3处理opening actvity可见性*/ handleOpeningApps(); ...... &#125; finally &#123; mService.mSurfaceAnimationRunner.continueStartingAnimations(); &#125; ...... // This has changed the visibility of windows, so perform // a new layout to get them all up-to-date. /*2.由于activity的可见性变更，将DisplayContent.mLayoutNeeded标志位置为true*/ mDisplayContent.setLayoutNeeded(); ...... &#125; applyAnimations()基于一组ActivityRecord来应用动画，这些ActivityRecord表示正在进行切换的应用程序。applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,voiceInteraction); /** * Apply an app transition animation based on a set of &#123;@link ActivityRecord&#125; * * @param openingApps The list of opening apps to which an app transition animation applies. * @param closingApps The list of closing apps to which an app transition animation applies. * @param transit The current transition type. * @param animLp Layout parameters in which an app transition animation runs. * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice * interaction session driving task. */ private void applyAnimations(ArraySet&lt;ActivityRecord&gt; openingApps, ArraySet&lt;ActivityRecord&gt; closingApps, @TransitionOldType int transit, LayoutParams animLp, boolean voiceInteraction) &#123; //方法检查过渡类型是否未设置，或者打开和关闭的应用程序是否都为空。如果是，则方法直接返回，不执行任何动画。 if (transit == WindowManager.TRANSIT_OLD_UNSET || (openingApps.isEmpty() &amp;&amp; closingApps.isEmpty())) &#123; return; &#125; //调用getAnimationTargets方法获取打开和关闭的窗口容器（WindowContainer） final ArraySet&lt;WindowContainer&gt; openingWcs = getAnimationTargets( openingApps, closingApps, true /* visible */); final ArraySet&lt;WindowContainer&gt; closingWcs = getAnimationTargets( openingApps, closingApps, false /* visible */); //打开和关闭的窗口应用动画。这是通过调重载的applyAnimations方法完成的，传递相应的参数，如动画的目标、过渡类型等。 applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp, voiceInteraction); applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp, voiceInteraction); //如果存在最近任务动画控制器（RecentsAnimationController），则发送任务出现任务 final RecentsAnimationController rac = mService.getRecentsAnimationController(); if (rac != null) &#123; rac.sendTasksAppeared(); &#125; //遍历打开和关闭的应用程序，并设置mOverrideTaskTransition为false for (int i = 0; i &lt; openingApps.size(); ++i) &#123; openingApps.valueAtUnchecked(i).mOverrideTaskTransition = false; &#125; for (int i = 0; i &lt; closingApps.size(); ++i) &#123; closingApps.valueAtUnchecked(i).mOverrideTaskTransition = false; &#125; //如果存在辅助功能控制器（AccessibilityController）且有回调，则调用其onAppWindowTransition方法。 final AccessibilityController accessibilityController = mDisplayContent.mWmService.mAccessibilityController; if (accessibilityController.hasCallbacks()) &#123; accessibilityController.onAppWindowTransition(mDisplayContent.getDisplayId(), transit); &#125; &#125; 入参含义：openingApps 和 closingApps: 这两个参数是ActivityRecord类型的数组，分别表示正在打开和关闭的应用程序，即这些ActivityRecord表示正在进行切换的应用程序。transit: 这是一个整型参数，表示过渡类型。例如，WindowManager.TRANSIT_OLD_UNSET表示没有特定的过渡类型。animLp: 这是一个LayoutParams对象，用于定义窗口的布局参数。voiceInteraction: 一个布尔值，表示是否为语音交互。 总而言之，该方法主要负责处理应用程序窗口的打开和关闭动画。它确保应用程序在切换时有一个平滑的视觉效果，为用户提供更好的体验。最后还与辅助功能服务交互，确保辅助功能用户也能正确地感知应用程序窗口的切换。 再来说说其中调用的applyAnimations方法部分 applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp, voiceInteraction); applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp, voiceInteraction); 调用的是重载的applyAnimations方法 /** * Apply animation to the set of window containers. * * @param wcs The list of &#123;@link WindowContainer&#125;s to which an app transition animation applies. * @param apps The list of &#123;@link ActivityRecord&#125;s being transitioning. * @param transit The current transition type. * @param visible &#123;@code true&#125; if the apps becomes visible, &#123;@code false&#125; if the apps becomes * invisible. * @param animLp Layout parameters in which an app transition animation runs. * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice * interaction session driving task. */ private void applyAnimations(ArraySet&lt;WindowContainer&gt; wcs, ArraySet&lt;ActivityRecord&gt; apps, @TransitionOldType int transit, boolean visible, LayoutParams animLp, boolean voiceInteraction) &#123; //获取窗口容器的数量 final int wcsCount = wcs.size(); //遍历每一个窗口容器 for (int i = 0; i &lt; wcsCount; i++) &#123; final WindowContainer wc = wcs.valueAt(i); // If app transition animation target is promoted to higher level, SurfaceAnimator // triggers WC#onAnimationFinished only on the promoted target. So we need to take care // of triggering AR#onAnimationFinished on each ActivityRecord which is a part of the // app transition. //对于每一个窗口容器，检查正在进行切换的应用程序（apps）中哪些是该窗口容器的后代。 //这些后代应用程序将被添加到一个列表中。 final ArrayList&lt;ActivityRecord&gt; transitioningDescendants = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; apps.size(); ++j) &#123; final ActivityRecord app = apps.valueAt(j); if (app.isDescendantOf(wc)) &#123; transitioningDescendants.add(app); &#125; &#125; //调用每个窗口容器的applyAnimation方法，传入相应的参数（如动画的布局参数、过渡类型、是否可见等）以及后代应用程序的列表。 wc.applyAnimation(animLp, transit, visible, voiceInteraction, transitioningDescendants); &#125; &#125; 入参含义：wcs: 一个WindowContainer对象的集合，这些对象是需要应用动画的窗口容器。apps: 一个ActivityRecord对象的集合，这些对象表示正在进行切换的应用程序。transit: 当前的过渡类型，例如淡入淡出、滑动等。visible: 一个布尔值，表示应用程序是否变为可见。animLp: 布局参数，定义了动画运行时的布局。voiceInteraction: 一个布尔值，表示是否有语音交互。 这部分远程动画流程，这里不做重点 handleClosingApps()该方法中主要的作用就是将所有即将close的activity的mVisible标志设置为false。该标志位在后续prepareSurfaces中是判断是否show surface的条件之一。 private void handleClosingApps() &#123; final ArraySet&lt;ActivityRecord&gt; closingApps = mDisplayContent.mClosingApps; final int appsCount = closingApps.size(); for (int i = 0; i &lt; appsCount; i++) &#123; final ActivityRecord app = closingApps.valueAt(i); ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now closing app %s&quot;, app); //设置activity的可见性，将mVisible设置为false app.commitVisibility(false /* visible */, false /* performLayout */); app.updateReportedVisibilityLocked(); // Force the allDrawn flag, because we want to start // this guy&#39;s animations regardless of whether it&#39;s // gotten drawn. //强制将allDrawn设置为true app.allDrawn = true; ...... &#125; &#125; handleOpeningApps()该方法与handleClosingApps方法类似,主要处理两件事情：1.将所有即将open的activity的mVisible标志位设置为true.2.调用ActivityRecord.showAllWindowsLocked()，最终会调用到WindowState.performShowLocked() ，处理mDrawState的状态变更 private void handleOpeningApps() &#123; final ArraySet&lt;ActivityRecord&gt; openingApps = mDisplayContent.mOpeningApps; final int appsCount = openingApps.size(); for (int i = 0; i &lt; appsCount; i++) &#123; final ActivityRecord app = openingApps.valueAt(i); ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now opening app %s&quot;, app); /*1.设置activity的可见性，将mVisible设置为true*/ app.commitVisibility(true /* visible */, false /* performLayout */); ...... if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG, &quot;&gt;&gt;&gt; OPEN TRANSACTION handleAppTransitionReady()&quot;); //开启事务 mService.openSurfaceTransaction(); try &#123; /*2.此方法最终会调用到WindowState.performShowLocked*/ app.showAllWindowsLocked(); &#125; finally &#123; //关闭事务 mService.closeSurfaceTransaction(&quot;handleAppTransitionReady&quot;); if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG, &quot;&lt;&lt;&lt; CLOSE TRANSACTION handleAppTransitionReady()&quot;); &#125; ...... &#125; &#125; app.showAllWindowsLocked();先调用到ActivityRecord的showAllWindowsLocked()代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java /** * This must be called while inside a transaction. */ void showAllWindowsLocked() &#123; forAllWindows(windowState -&gt; &#123; if (DEBUG_VISIBILITY) Slog.v(TAG, &quot;performing show on: &quot; + windowState); windowState.performShowLocked(); &#125;, false /* traverseTopToBottom */); &#125; windowState.performShowLocked();再调用到WindowState的performShowLocked()将mDrawState的状态由READY_TO_SHOW变更为HAS_DRAW代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java // This must be called while inside a transaction. boolean performShowLocked() &#123; ...... //获取WindowStateAnimator.mDrawState final int drawState = mWinAnimator.mDrawState; //这里判断（drawState 状态为HAS_DRAWN 或者READY_TO_SHOW）且ActivityRecord不为空 if ((drawState == HAS_DRAWN || drawState == READY_TO_SHOW) &amp;&amp; mActivityRecord != null) &#123; //窗口类型不为启动窗口 if (mAttrs.type != TYPE_APPLICATION_STARTING) &#123; mActivityRecord.onFirstWindowDrawn(this); &#125; else &#123; mActivityRecord.onStartingWindowDrawn(); &#125; &#125; //如果当前mDrawState的状态不为READY_TO_SHOW ，则直接返回 if (mWinAnimator.mDrawState != READY_TO_SHOW || !isReadyForDisplay()) &#123; return false; &#125; ...... //走入窗口动画流程 mWinAnimator.applyEnterAnimationLocked(); // Force the show in the next prepareSurfaceLocked() call. mWinAnimator.mLastAlpha = -1; ProtoLog.v(WM_DEBUG_ANIM, &quot;performShowLocked: mDrawState=HAS_DRAWN in %s&quot;, this); //设置mDrawState的状态为HAS_DRAWN mWinAnimator.mDrawState = HAS_DRAWN; mWmService.scheduleAnimationLocked(); ...... return true; &#125; 添加窗口时，会调用这个mWinAnimator.applyEnterAnimationLocked();窗口动画的方法，然后调用到applyAnimationLocked()；窗口移除时，会直接调用applyAnimationLocked()显示动画。可参考Android T窗口动画显示和退出流程 3.再次请求布局回到WindowSurfacePlacer中通过requestTraversals()，再次请求布局，该方法将mTraversalScheduled标志位设置为true的判断条件有两个：1.遍历所有DisplayContent.mLayoutNeeded标志为是否为true。（由于AppTransitionController.handleAppTransitionReady阶段已经将mLayoutNeeded置为true，因此该条件为真）2.重复布局的次数不能超过6次，该条件也为真。（因为当前还只是第一次布局)代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java private void performSurfacePlacementLoop() &#123; ...... try &#123; ...... /*1.遍历所有DisplayContent.mLayoutNeeded标志位是否为true*/ if (mService.mRoot.isLayoutNeeded()) &#123; /*2.如果需要布局，且布局次数小于6次，则需要再次请求布局*/ if (++mLayoutRepeatCount &lt; 6) &#123; //该方法中会将mTraversalScheduled标志位设置位true requestTraversal(); &#125; else &#123; Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;); mLayoutRepeatCount = 0; &#125; &#125; else &#123; mLayoutRepeatCount = 0; &#125; ...... &#125; catch (RuntimeException e) &#123; ...... &#125; &#125; 接下来进入第二次布局循环，其主要目的是为了show surface 2.3.4 show Surface在第二次循环中，我们主要关注DisplayContent中applySurfaceChangesTransaction()方法调用的prepareSurfaces() 该方法最终会调用到根容器WindowContainer，来遍历所有子容器中的prepareSurfaces。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java @Override void prepareSurfaces() &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;prepareSurfaces&quot;); try &#123; //获取事务 final Transaction transaction = getPendingTransaction(); //调用其父类方法 super.prepareSurfaces(); // TODO: Once we totally eliminate global transaction we will pass transaction in here // rather than merging to global. SurfaceControl.mergeToGlobalTransaction(transaction); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; 调用其父类方法super.prepareSurfaces();DisplayContent的父类为WindowContainer代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java void prepareSurfaces() &#123; // If a leash has been set when the transaction was committed, then the leash reparent has // been committed. mCommittedReparentToAnimationLeash = mSurfaceAnimator.hasLeash(); //调用所有子容器中的prepareSurfaces for (int i = 0; i &lt; mChildren.size(); i++) &#123; mChildren.get(i).prepareSurfaces(); &#125; &#125; mChildren.get(i).prepareSurfaces();在WindowState.prepareSurfaces中，主要做了两方面工作。1.将mWindowFrames中计算出来的left以及top设置surface位置，并调整窗口比例。2.控制surface的可见性，查看WindowStateAnimator.prepareSurfaceLocked代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java void prepareSurfaces() &#123; mIsDimming = false; applyDims(); //实际调用的是其父类WindowContainer的方法 /*1.最终调用自身的updateSurfacePosition()（自身有重写该方法）计算surface的位置*/ updateSurfacePositionNonOrganized(); // Send information to SurfaceFlinger about the priority of the current window. updateFrameRateSelectionPriorityIfNeeded(); //更新窗口比例 updateScaleIfNeeded(); /*2.控制surface的可见性，调用WindowStateAnimator的prepareSurfaceLocked()方法*/ mWinAnimator.prepareSurfaceLocked(getSyncTransaction()); super.prepareSurfaces(); &#125; @Override @VisibleForTesting void updateSurfacePosition(Transaction t) &#123; if (mSurfaceControl == null) &#123; return; &#125; //这段代码首先检查布局是否被延迟（通过 isLayoutDeferred() 方法） //或者应用是否正在进行布局（通过 isGoneForLayout() 方法）。 //如果满足这些条件并且 mSurfacePlacementNeeded 为 false，则方法返回，不执行后续操作。 //这是因为当布局被延迟或应用正在进行布局时，界面的位置可能不是最新的，因此不执行updateSurfacePosition。 if ((mWmService.mWindowPlacerLocked.isLayoutDeferred() || isGoneForLayout()) &amp;&amp; !mSurfacePlacementNeeded) &#123; // Since this relies on mWindowFrames, changes made while layout is deferred are // likely to be invalid. Similarly, if it&#39;s goneForLayout, mWindowFrames may not be // up-to-date and thus can&#39;t be relied on. return; &#125; //将mSurfacePlacementNeeded设置为false mSurfacePlacementNeeded = false; //将mSurfacePosition的left以及top设置mWindowFrames中计算出来的left以及top，并根据parent进行偏移 transformFrameToSurfacePosition(mWindowFrames.mFrame.left, mWindowFrames.mFrame.top, mSurfacePosition); //根据壁纸的比例对SurfacePosition进行调整 if (mWallpaperScale != 1f) &#123; final Rect bounds = getLastReportedBounds(); Matrix matrix = mTmpMatrix; matrix.setTranslate(mXOffset, mYOffset); matrix.postScale(mWallpaperScale, mWallpaperScale, bounds.exactCenterX(), bounds.exactCenterY()); matrix.getValues(mTmpMatrixArray); mSurfacePosition.offset(Math.round(mTmpMatrixArray[Matrix.MTRANS_X]), Math.round(mTmpMatrixArray[Matrix.MTRANS_Y])); &#125; else &#123; mSurfacePosition.offset(mXOffset, mYOffset); &#125; ...... &#125; mWinAnimator.prepareSurfaceLocked(getSyncTransaction()); 调用WindowStateAnimator的prepareSurfaceLocked()方法，该则真正的处理触发surface show的逻辑。主要分为两部分。1.将计算的alpha应用于当前surface。2.判断是否调用showSurfaceRobustlyLocked将surface show出来。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java void prepareSurfaceLocked(SurfaceControl.Transaction t) &#123; final WindowState w = mWin; //首先判断是否有SurfaceControl if (!hasSurface()) &#123; ...... return; &#125; //设置mShowAlpha computeShownFrameLocked(); //判断parentWindow是否hidden，或者当前窗口是否on-screen if (w.isParentWindowHidden() || !w.isOnScreen()) &#123; ...... &#125; else if (mLastAlpha != mShownAlpha || mLastHidden) &#123; mLastAlpha = mShownAlpha; ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot;SURFACE controller=%s alpha=%f HScale=%f, VScale=%f: %s&quot;, mSurfaceController, mShownAlpha, w.mHScale, w.mVScale, w); /*1.设置surface的alpha*/ boolean prepared = mSurfaceController.prepareToShowInTransaction(t, mShownAlpha); //如果当前状态为HAS_DRAWN if (prepared &amp;&amp; mDrawState == HAS_DRAWN) &#123; if (mLastHidden) &#123; /*2.触发show surface*/ if (showSurfaceRobustlyLocked(t)) &#123; mAnimator.requestRemovalOfReplacedWindows(w); //设置mLastHidden为false mLastHidden = false; ....... &#125; else &#123; w.setOrientationChanging(false); &#125; &#125; &#125; &#125; else &#123; if (mWin.isAnimating(TRANSITION | PARENTS)) &#123; ProtoLog.v(WM_DEBUG_ANIM, &quot;prepareSurface: No changes in animation for %s&quot;, this); &#125; &#125; ...... &#125; 从上述代码中可以看出触发showSurfaceRobustlyLocked的判断条件有以下几点：1.w.isParentWindowHidden判断其parent的mHidden是否为true，此时当前窗口没有parent直接返回false2.w.isOnScreen，判断当前窗口是否在屏幕上，如果该窗口mVisible为true或者在不可见之前正在运行动画，判断为在屏幕上。我们在上次布局的AppTransitionController.handleAppTransitionReady阶段将当前窗口的mVisible置为了true，因此w.isOnScreen返回true。3.mLastAlpha !&#x3D; mShownAlpha以及mLastHidden满足其一即可，此处我们分析mLastHidden，该标志位在创建SurfaceControl或者hide surface时会被置为true，因为当前窗口才刚刚被创建，因此mLastHidden为true。经过以上判断可以得出我们顺利触发showSurfaceRobustlyLocked后面通过WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController /** * Have the surface flinger show a surface, robustly dealing with * error conditions. In particular, if there is not enough memory * to show the surface, then we will try to get rid of other surfaces * in order to succeed. * * @return Returns true if the surface was successfully shown. */ private boolean showSurfaceRobustlyLocked(SurfaceControl.Transaction t) &#123; //WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController //调用WindowSurfaceController的showRobustly方法 boolean shown = mSurfaceController.showRobustly(t); //如果没有成功返回false if (!shown) return false; t.merge(mPostDrawTransaction); return true; &#125; 在WindowSurfaceController中，首先判断标志位mSurfaceShown，若为true则直接返回；若为false，则将mSurfaceShown置为true，并调用SurfaceControl.show。至此真正的绘图已经显示出来，但是否真正的被用户看见，还需要看其parent是否被show。代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java boolean showRobustly(SurfaceControl.Transaction t) &#123; ...... //首先判断surface是否已经shown if (mSurfaceShown) &#123; return true; &#125; //将mSurfaceShown设置为true setShown(true); //调用SurfceControl中的show方法，将surface show出来 t.show(mSurfaceControl); if (mAnimator.mIsWallpaper) &#123; EventLog.writeEvent(EventLogTags.WM_WALLPAPER_SURFACE, mAnimator.mWin.getDisplayId(), 1 /* request shown */); &#125; return true; &#125; 从SurfaceControl的创建以及show的流程上看，可以发现WMS是通过WindowSurfaceController对SurfaceControl进行管理的。最后我们看一下SurfaceControl中的show方法代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java /** * Request that a given surface and it&#39;s sub-tree be shown. * * @param sc The surface to show. * @return This transaction. * @hide */ @UnsupportedAppUsage public Transaction show(SurfaceControl sc) &#123; checkPreconditions(sc); nativeSetFlags(mNativeObject, sc.mNativeObject, 0, SURFACE_HIDDEN); return this; &#125; 2.4 performSurfacePlacement()流程总结在“【2.2 窗口位置计算】”以及“【2.3 窗口状态刷新】”部分均调用了WindowSurfacePlacer.performSurfacePlacement()，实际上任何窗口属性变化都会触发该方法，但我们在performSurfacePlacement中只关注了窗口位置大小计算以及窗口状态变更的相关流程。此处再对该流程进行简单的梳理。当调用到WindowSurfacePlacer.performSurfacePlacement()时首先会执行“1”更新所有窗口的大小以及状态信息，在执行“2”处理是否在此调用执行performSurfacePlacement。1.1.1：主要调用computeFrames，计算窗口的尺寸大小。1.1.2：主要处理mDrawState的状态变更，在commitFinishDrawingLocked中会将处于DRAW_PENDING状态的mDrawState更新为COMMIT_DRAW_PENDING。1.1.3：主要根据computerFrames中计算出来的窗口大小来设置Surface的位置，并调用SurfaceControl.show()将窗口show出来。1.2：将处于COMMIT_DRAW_PENDING状态的mDrawState更新为READY_TO_SHOW，并将DisplayContent.mLayoutNeeded设置为true。在“2”中会判断该标志位来处理是否再次调用performSurfacePlacement的操作。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"WMSAMS","slug":"Android-FrameWork/Framework源码分析/Android-13/WMSAMS","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/WMSAMS/3.窗口层级_层级结构树添加窗口/","text":"尚未添加窗口的层级结构树，如图DisplayArea层级结构中的每一个DisplayArea，都包含着一个层级值范围，这个层级值范围表明了这个DisplayArea可以容纳哪些类型的窗口。每种窗口类型，都可以通过WindowManagerPolicy.getWindowLayerFromTypeLw方法，返回一个相应的层级值。 /** * Returns the layer assignment for the window type. Allows you to control how different * kinds of windows are ordered on-screen. * * @param type The type of window being assigned. * @param canAddInternalSystemWindow If the owner window associated with the type we are * evaluating can add internal system windows. I.e they have * &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window * types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125; * can be assigned layers greater than the layer for * &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their * layers would be lesser. * @return int An arbitrary integer used to order windows, with lower numbers below higher ones. */ default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123; return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow, false /* roundedCornerOverlay */); &#125; /** * Returns the layer assignment for the window type. Allows you to control how different * kinds of windows are ordered on-screen. * * @param type The type of window being assigned. * @param canAddInternalSystemWindow If the owner window associated with the type we are * evaluating can add internal system windows. I.e they have * &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window * types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125; * can be assigned layers greater than the layer for * &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their * layers would be lesser. * @param roundedCornerOverlay","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"WMSAMS","slug":"Android-FrameWork/Framework源码分析/Android-13/WMSAMS","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/WMSAMS/2.窗口层级 _层级结构树的构建/","text":"如何通过dump中的内容找到对应的代码？我们dump窗口层级发现会有很多信息，adb shell dumpsys activity containers这里我们以其中的DefaultTaskDisplayArea为例 在源码的framework目录下查找该字符串，找到对应的代码就可以通过打印堆栈或者搜索代码跟踪的方式找到其调用逻辑 final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService, &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER); 也就是这一句 当然我们上篇文章也讲到了DisplayContent代表的屏幕的DisplayArea层级结构的根节点，我们可以直接从DisplayContent.java的构造方法出发，追踪其流程 DisplayContent初始化代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java /** * Create new &#123;@link DisplayContent&#125; instance, add itself to the root window container and * initialize direct children. * @param display May not be null. * @param root &#123;@link RootWindowContainer&#125; */ DisplayContent(Display display, RootWindowContainer root) &#123; super(root.mWindowManager, &quot;DisplayContent&quot;, FEATURE_ROOT); ...... final Transaction pendingTransaction = getPendingTransaction(); configureSurfaces(pendingTransaction); pendingTransaction.apply(); ...... &#125; 创建新的DisplayContent实例，将其自身添加到根窗口容器并初始化直接子级FEATURE_ROOT，对应DisplayContent，一个屏幕上的根DisplayArea，也就是dump中的Display节点。 这里我们主要关注一下configureSurfaces(pendingTransaction); /** * Configures the surfaces hierarchy for DisplayContent * This method always recreates the main surface control but reparents the children * if they are already created. * @param transaction as part of which to perform the configuration */ private void configureSurfaces(Transaction transaction) &#123; final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(mSession) .setOpaque(true) .setContainerLayer() .setCallsite(&quot;DisplayContent&quot;); mSurfaceControl = b.setName(getName()).setContainerLayer().build(); if (mDisplayAreaPolicy == null) &#123; // Setup the policy and build the display area hierarchy. // Build the hierarchy only after creating the surface so it is reparented correctly mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate( mWmService, this /* content */, this /* root */, mImeWindowsContainer); &#125; ...... &#125; 通过DisplayContent来配置图层结构 DisplayAreaPolicy初始化代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicy.java mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate( mWmService, this /* content */, this /* root */, mImeWindowsContainer) 调用DisplayAreaPolicy中的Provider接口instantiate方法，去初始化一个DisplayArea层级结构记住这边传递的参数，后面代码需要结合起来看 DisplayAreaPolicy.Provider /** * Provider for &#123;@link DisplayAreaPolicy&#125; instances. * * &lt;p&gt;By implementing this interface and overriding the * &#123;@code config_deviceSpecificDisplayAreaPolicyProvider&#125;, a device-specific implementations * of &#123;@link DisplayAreaPolicy&#125; can be supplied. */ public interface Provider &#123; /** * Instantiates a new &#123;@link DisplayAreaPolicy&#125;. It should set up the &#123;@link DisplayArea&#125; * hierarchy. * * @see DisplayAreaPolicy#DisplayAreaPolicy */ DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content, RootDisplayArea root, DisplayArea.Tokens imeContainer); 用来实例化一个DisplayAreaPolicy对象，这个对象应该建立起DisplayArea层级结构，实际走到的则是DisplayAreaPolicy.Provider的实现类DisplayAreaPolicy.DefaultProvider.instantiate方法 DisplayAreaPolicy.DefaultProvider /** Provider for platform-default display area policy. */ static final class DefaultProvider implements DisplayAreaPolicy.Provider &#123; @Override public DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content, RootDisplayArea root, DisplayArea.Tokens imeContainer) &#123; //1.创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中 final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService, &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER); final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;(); tdaList.add(defaultTaskDisplayArea); // Define the features that will be supported under the root of the whole logical // display. The policy will build the DisplayArea hierarchy based on this. //2.创建HierarchyBuilder final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root); // Set the essential containers (even if the display doesn&#39;t support IME). //3.1添加ImeContainer到HierarchyBuilder //3.2创建并保存默认TaskDisplayArea到HierarchyBuilder rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList); if (content.isTrusted()) &#123; // Only trusted display can have system decorations. //4.为HierarchyBuilder添加Feature configureTrustedHierarchyBuilder(rootHierarchy, wmService, content); &#125; // Instantiate the policy with the hierarchy defined above. This will create and attach // all the necessary DisplayAreas to the root. //5.生成DisplayArea层级结构 return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService); &#125; 我们先了解下DisplayArea.Tokens的构造方法 Tokens(WindowManagerService wms, Type type, String name) &#123; this(wms, type, name, FEATURE_WINDOW_TOKENS); &#125; FEATURE_WINDOW_TOKENS，容纳非activity窗口的DisplayArea，dump中对应着ImeContainer、WindowToken等这里DefaultProvider实现了这个接口。这个方法主要干了这几件事情： 1.初始化TaskDisplayAreafinal TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService, &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER); final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;(); tdaList.add(defaultTaskDisplayArea); FEATURE_DEFAULT_TASK_CONTAINER，容纳默认Task容器的DisplayArea，dump中正是以“DefaultTaskDisplayArea”命名创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中 2.创建HierarchyBuilderfinal HierarchyBuilder rootHierarchy = new HierarchyBuilder(root); HierarchyBuilder是什么？是用来定义在整个逻辑显示的根里面所需的一些FeatureHierarchyBuilder是在DisplayAreaPolicyBuilder中定义的代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java /** * Builder to define &#123;@link Feature&#125; and &#123;@link DisplayArea&#125; hierarchy under a * &#123;@link RootDisplayArea&#125; */ static class HierarchyBuilder &#123; private static final int LEAF_TYPE_TASK_CONTAINERS = 1; private static final int LEAF_TYPE_IME_CONTAINERS = 2; private static final int LEAF_TYPE_TOKENS = 0; private final RootDisplayArea mRoot; private final ArrayList&lt;DisplayAreaPolicyBuilder.Feature&gt; mFeatures = new ArrayList&lt;&gt;(); private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;(); @Nullable private DisplayArea.Tokens mImeContainer; HierarchyBuilder(RootDisplayArea root) &#123; mRoot = root; &#125; ...... &#125; 从代码中我们可以看出，HierarchyBuilder用来构建一个DisplayArea层级结构，该层级结构的根节点其构造方法HierarchyBuilder(RootDisplayArea root)传入的是RootDisplayArea的对象。结合前面的configureSurfaces方法中我们可以发现传入的是DisplayContent，即HierarchyBuilder以DisplayContent对象为根节点，生成一个DisplayArea层级结构。 3.1添加ImeContainer到HierarchyBuilderrootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList); 我们先看setImeContainer(imeContainer)部分。其中参数imeContainer是DisplayArea.Tokens的对象。 在DisplayContent中DisplayAreaPolicy初始化时，传递了一个mImeWindowsContainer对应我们这里的imeContainer形参，其是在DisplayContent中定义并初始化的代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java // Contains all IME window containers. Note that the z-ordering of the IME windows will depend // on the IME target. We mainly have this container grouping so we can keep track of all the IME // window containers together and move them in-sync if/when needed. We use a subclass of // WindowContainer which is omitted from screen magnification, as the IME is never magnified. // TODO(display-area): is &quot;no magnification&quot; in the comment still true? private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService); ImeContainer就是输入法的容器，其继承在DisplayContent中DisplayArea.Tokens /** * Container for IME windows. * * This has some special behaviors: * - layers assignment is ignored except if setNeedsLayer() has been called before (and no * layer has been assigned since), to facilitate assigning the layer from the IME target, or * fall back if there is no target. * - the container doesn&#39;t always participate in window traversal, according to * &#123;@link #skipImeWindowsDuringTraversal()&#125; */ private static class ImeContainer extends DisplayArea.Tokens &#123; HierarchyBuilder的setImeContainer方法代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java private DisplayArea.Tokens mImeContainer; /** Sets IME container as a child of this hierarchy root. */ HierarchyBuilder setImeContainer(DisplayArea.Tokens imeContainer) &#123; mImeContainer = imeContainer; return this; &#125; 从代码中可以看出，就是将DisplayContent的mImeWindowsContainer保存到了HierarchyBuilder的mImeContainer成员变量中，后续创建DisplayArea层级结构时可以直接拿来使用。 3.2添加TaskDisplayArea到HierarchyBuilderrootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList); 这里我们看setTaskDisplayAreas(tdaList)部分，第一步【1.初始化TaskDisplayArea】的时候，就已经把名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到tdaList中， private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;(); /** * Sets &#123;@link TaskDisplayArea&#125; that are children of this hierarchy root. * &#123;@link DisplayArea&#125; group must have at least one &#123;@link TaskDisplayArea&#125;. */ HierarchyBuilder setTaskDisplayAreas(List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123; mTaskDisplayAreas.clear(); mTaskDisplayAreas.addAll(taskDisplayAreas); return this; &#125; 虽然TaskDisplayArea是支持嵌套的，并且这里也采用了一个ArrayList来管理TaskDisplayArea，但是目前TaskDisplayArea只在这里被创建，即目前一个DisplayContent只有一个名为“DefaultTaskDisplayArea”的TaskDisplayArea。从dumpsys activity containers 中我们也可以看到,整个文件也只有一个“DefaultTaskDisplayArea” 4.为HierarchyBuilder添加Feature// Only trusted display can have system decorations. configureTrustedHierarchyBuilder(rootHierarchy, wmService, content); configureTrustedHierarchyBuilder这个方法就在DisplayAreaPolicy.DefaultProvider内部 private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy, WindowManagerService wmService, DisplayContent content) &#123; // WindowedMagnification should be on the top so that there is only one surface // to be magnified. rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;, FEATURE_WINDOWED_MAGNIFICATION) .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY) .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY) // Make the DA dimmable so that the magnify window also mirrors the dim layer. .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new) .build()); if (content.isDefaultDisplay) &#123; // Only default display can have cutout. // See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked. rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;, FEATURE_HIDE_DISPLAY_CUTOUT) .all() .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR, TYPE_NOTIFICATION_SHADE) .build()) .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;, FEATURE_ONE_HANDED) .all() .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_SECURE_SYSTEM_OVERLAY) .build()); &#125; rootHierarchy .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;, FEATURE_FULLSCREEN_MAGNIFICATION) .all() .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY, TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL) .build()) .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;, FEATURE_IME_PLACEHOLDER) .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG) .build()); &#125; &#125; 从代码中可以看到五大的Feature：WindowedMagnification、HideDisplayCutout、OneHanded、FullscreenMagnification、ImePlaceholder，这些Feature其实也就是我们在dumpsys中看到那些，还有一些关键方法all()、and()、except()、upto()、build()等在我们正式开始聊这个几个Feature添加之前，我们先来看看，Feature是怎么定义的 4.1 Feature的定义从HierarchyBuilder的addFeature方法跟踪发现，Feature是在DisplayAreaPolicyBuilder中定义的 HierarchyBuilder addFeature(DisplayAreaPolicyBuilder.Feature feature) &#123; mFeatures.add(feature); return this; &#125; Feature的定义代码路径&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java /** * A feature that requires &#123;@link DisplayArea DisplayArea(s)&#125;. */ static class Feature &#123; private final String mName; private final int mId; private final boolean[] mWindowLayers; private final NewDisplayAreaSupplier mNewDisplayAreaSupplier; private Feature(String name, int id, boolean[] windowLayers, NewDisplayAreaSupplier newDisplayAreaSupplier) &#123; mName = name; mId = id; mWindowLayers = windowLayers; mNewDisplayAreaSupplier = newDisplayAreaSupplier; &#125; ...... &#125; 首先Feature代表的是DisplayArea的一个特征，可以根据Feature来对不同的DisplayArea进行划分。 mName：这个Feature的名字，如上面的“WindowedMagnification”，“HideDisplayCutout”之类的，后续DisplayArea层级结构建立起来后，每个DisplayArea的名字用的就是当前DisplayArea对应的那个Feature的名字。 mId：Feature的ID，如上面的FEATURE_WINDOWED_MAGNIFICATION和FEATURE_HIDE_DISPLAY_CUTOUT，虽说是Feature的ID，因为Feature又是DisplayArea的特征 mWindowLayers：代表了这个DisplayArea可以包含哪些层级对应的窗口 mNewDisplayAreaSupplier：只是一个接口，内部定义一个create方法。 关键是其Feature内部定义Builder类以及其build()方法 Feature.Builder和Feature.Builder.build()static class Builder &#123; private final WindowManagerPolicy mPolicy; private final String mName; private final int mId; private final boolean[] mLayers; private NewDisplayAreaSupplier mNewDisplayAreaSupplier = DisplayArea::new; private boolean mExcludeRoundedCorner = true; /** * Builds a new feature that applies to a set of window types as specified by the * builder methods. * * &lt;p&gt;The set of types is updated iteratively in the order of the method invocations. * For example, &#123;@code all().except(TYPE_STATUS_BAR)&#125; expresses that a feature should * apply to all types except TYPE_STATUS_BAR. * * &lt;p&gt;The builder starts out with the feature not applying to any types. * * @param name the name of the feature. * @param id of the feature. &#123;@see Feature#getId&#125; */ Builder(WindowManagerPolicy policy, String name, int id) &#123; mPolicy = policy; mName = name; mId = id; mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1]; &#125; ...... Feature build() &#123; if (mExcludeRoundedCorner) &#123; // Always put the rounded corner layer to the top most layer. mLayers[mPolicy.getMaxWindowLayer()] = false; &#125; return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier); &#125; 通过一套适用于具体的窗口类型构建方法来构建新Feature其中mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1]; mPolicy.getMaxWindowLayer()返回的是窗口最大层数。 /** * Returns the max window layer. * &lt;p&gt;Note that the max window layer should be higher that the maximum value which reported * by &#123;@link #getWindowLayerFromTypeLw(int, boolean)&#125; to contain rounded corner overlay.&lt;/p&gt; * * @see WindowManager.LayoutParams#PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY */ default int getMaxWindowLayer() &#123; return 36; &#125; 1.代码中最大层数是36，这里+1，则也就是mLayers = new boolean[37]，即窗口层级区间为[0,36]2.在看看build()方法中的 mLayers[mPolicy.getMaxWindowLayer()] = false;，则表示mLayers[36] &#x3D; false，即第36层在build时会置为false（注：mExcludeRoundedCorner这个变量的值一直是true，没有改动）3.return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);其中mLayers对应的就是Feature中的mWindowLayers，即mLayers.clone()就是把Feature.mWindowLayer的值复制给Feature.Builder.mLayer。 下面我们来说说构建Feature的关键星魂 4.2 构建Feature的核心方法以下代码均在DisplayAreaPolicyBuilder.Feature.Builder中 Feature.Builder第一星魂：all() /** * Set that the feature applies to all window types. */ Builder all() &#123; Arrays.fill(mLayers, true); return this; &#125; 将mLayers数组中的所有元素都设置为true，表示当前DisplayArea可以包含所有类型的窗口。简述，all()就是把所有类型窗口置为true（添加） Feature.Builder第二星魂：and() /** * Set that the feature applies to the given window types. */ Builder and(int... types) &#123; for (int i = 0; i &lt; types.length; i++) &#123; int type = types[i]; set(type, true); &#125; return this; &#125; 先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为true，表示该DisplayArea可以包含传入的窗口类型对应的窗口。简述，and就是把你传入的所有参数（窗口类型）置为true（添加） Feature.Builder第三星魂：except() /** * Set that the feature does not apply to the given window types. */ Builder except(int... types) &#123; for (int i = 0; i &lt; types.length; i++) &#123; int type = types[i]; set(type, false); &#125; return this; &#125; 先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为false，表示该DisplayArea不再包含传入的窗口类型对应的窗口。简述，except就是你传入的所有参数（窗口类型）置为false（不添加） Feature.Builder第四星魂（必点）：upTo() /** * Set that the feature applies window types that are layerd at or below the layer of * the given window type. */ Builder upTo(int typeInclusive) &#123; final int max = layerFromType(typeInclusive, false); for (int i = 0; i &lt; max; i++) &#123; mLayers[i] = true; &#125; set(typeInclusive, true); return this; &#125; 先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的的元素之前的所有元素（包含该元素）设置为true，表示当前DisplayArea可以包含比传入的窗口类型层级值低的所有窗口。简述，upTo把就是[0,typeInclusive]区间内的所有类型窗口置为true（添加）。其中layerFromType方法非常重要，我们一起看看 private int layerFromType(int type, boolean internalWindows) &#123; return mPolicy.getWindowLayerFromTypeLw(type, internalWindows); &#125; 调用的了WindowManagerPolicy.getWindowLayerFromTypeLw方法 WindowManagerPolicy.getWindowLayerFromTypeLw /** * Returns the layer assignment for the window type. Allows you to control how different * kinds of windows are ordered on-screen. * * @param type The type of window being assigned. * @param canAddInternalSystemWindow If the owner window associated with the type we are * evaluating can add internal system windows. I.e they have * &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window * types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125; * can be assigned layers greater than the layer for * &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their * layers would be lesser. * @return int An arbitrary integer used to order windows, with lower numbers below higher ones. */ default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123; return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow, false /* roundedCornerOverlay */); &#125; /** * Returns the layer assignment for the window type. Allows you to control how different * kinds of windows are ordered on-screen. * * @param type The type of window being assigned. * @param canAddInternalSystemWindow If the owner window associated with the type we are * evaluating can add internal system windows. I.e they have * &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window * types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125; * can be assigned layers greater than the layer for * &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their * layers would be lesser. * @param roundedCornerOverlay","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"WMSAMS","slug":"Android-FrameWork/Framework源码分析/Android-13/WMSAMS","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/WMSAMS/1.窗口层级 _容器类/","text":"窗口在App端是以PhoneWindow的形式存在，承载了一个Activity的View层级结构。这里我们探讨一下WMS端窗口的形式。可以通过adb shell dumpsys activity containers 来看窗口显示的层级 窗口容器类 —— WindowContainer类/** * Defines common functionality for classes that can hold windows directly or through their * children in a hierarchy form. * The test class is &#123;@link WindowContainerTests&#125; which must be kept up-to-date and ran anytime * changes are made to this class. */ class WindowContainer&lt;E extends WindowContainer&gt; extends ConfigurationContainer&lt;E&gt; implements Comparable&lt;WindowContainer&gt;, Animatable, SurfaceFreezer.Freezable, InsetsControlTarget &#123; ...... /** * The parent of this window container. * For removing or setting new parent &#123;@link #setParent&#125; should be used, because it also * performs configuration updates based on new parent&#39;s settings. */ private WindowContainer&lt;WindowContainer&gt; mParent = null; ...... // List of children for this window container. List is in z-order as the children appear on // screen with the top-most window container at the tail of the list. protected final WindowList&lt;E&gt; mChildren = new WindowList&lt;E&gt;(); WindowContainer注释中开头就说明了其作用，即给可以直接持有窗口的自己或它的孩子定义了一些公共的方法和属性。WindowContainer定义了能够直接或者间接以层级结构的形式持有窗口的类的通用功能。从类的定义和名称，可以看到WindowContainer是一个容器类，可以容纳WindowContainer及其子类对象。如果另外一个容器类作为WindowState的容器，那么这个容器类需要继承WindowContainer或其子类。 其中mParent和mChildren，一个代表父节点一个代表子节点，而且子节点的list顺序代表就是z轴的层级显示顺序，list尾巴在比list的头的z轴层级要高。1）mParent是WindowContainer类型成员变量，保存的是当前WindowContainer的父容器的引用。2）mChildren是WindowList类型的成员变量，保存的则是当前WindowContainer持有的所有子容器。并且列表的顺序也就是子容器出现在屏幕上的顺序，最顶层的子容器位于队尾。 根窗口容器 —— RootWindowContainer/** Root &#123;@link WindowContainer&#125; for the device. */ public class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt; 根窗口容器，树的根是它。通过它遍历寻找，可以找到窗口树上的窗口。它的孩子是DisplayContent。 屏幕 —— DisplayContent/** * Utility class for keeping track of the WindowStates and other pertinent contents of a * particular Display. */ class DisplayContent extends RootDisplayArea implements WindowManagerPolicy.DisplayContentInfo &#123; 该类是对应着显示屏幕的，Android是支持多屏幕的，所以可能存在多个DisplayContent对象。上图只画了一个对象的结构，其他对象的结构也是和画的对象的结构是相似的。 RootWindowContainer代表dumpsys containers中ROOT ，DisplayContentdumpsys containers中Display，0表示当前显示的屏幕 窗口 —— WindowState类/** A window in the window manager. */ class WindowState extends WindowContainer&lt;WindowState&gt; implements WindowManagerPolicy.WindowState, InsetsControlTarget, InputTarget &#123; 在WMS窗口体系中，一个WindowState对象就代表了一个窗口，其继承WindowContainer，这就说明WindowState同样可以作为其他窗口的父容器，例如我们常见的PopupWindow WindowState的容器可直接持有WindowState的容器即WindowToken和ActivityRecord，WallpaperWindowToken也可以持有WindowState，而其是继承WindowToken的 WindowToken类/** * Container of a set of related windows in the window manager. Often this is an AppWindowToken, * which is the handle for an Activity that it uses to display windows. For nested windows, there is * a WindowToken created for the parent window to manage its children. */ class WindowToken extends WindowContainer&lt;WindowState&gt; &#123; 这个注释的意思大概是说：窗口管理器中一组相关窗口的容器。这通常是一个AppWindowToken，它是用于显示窗口的“活动”的句柄。对于嵌套窗口，会为父窗口创建一个WindowToken来管理其子窗口。总而言之就是用WindowToken来管理WindowState WallpaperWindowToken类/** * A token that represents a set of wallpaper windows. */ class WallpaperWindowToken extends WindowToken &#123; WallpaperWindowToken继承WindowToken，是用来存放和Wallpaper相关的窗口。 ActivityRecord类/** * An entry in the history task, representing an activity. */ public final class ActivityRecord extends WindowToken implements WindowManagerService.AppFreezeListener &#123; ActivityRecord是WindowToken的子类，在WMS中一个ActivityRecord对象就代表一个Activity对象。 一般来说，一个窗口的父容器是WindowToken还是ActivityRecord，是否主动使用ViewManager.addView来添加一个窗口父容器为WindowToken的情况：APP（含系统应用）主动调用添加窗口方法来添加窗口，如StatusBar、浮窗等。即非Activity窗口父容器为ActivityRecord的情况：系统侧调用添加窗口方法来添加窗口，如在桌面启动一个应用等。即Activity窗口 从层级角度将窗口划分为：App之上的窗口，父容器为WindowToken，如StatusBar和NavigationBar。App窗口，父容器为ActivityRecord，如Launcher。App之下的窗口，父容器为WallpaperWindowToken，如ImageWallpaper窗口 WindowToken的容器 —— DisplayArea.Tokens /** * DisplayArea that contains WindowTokens, and orders them according to their type. */ public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123; 包含WindowTokens的容器Tokens，并根据其类型对其进行排序。 ActivityRecord的容器 —— Task/** * &#123;@link Task&#125; is a TaskFragment that can contain a group of activities to perform a certain job. * Activities of the same task affinities usually group in the same &#123;@link Task&#125;. A &#123;@link Task&#125; * can also be an entity that showing in the Recents Screen for a job that user interacted with. * A &#123;@link Task&#125; can also contain other &#123;@link Task&#125;s. */ class Task extends TaskFragment &#123; Task继承TaskFragment，它的孩子可以是Task，也可以是ActivityRecord类型。是一个TaskFragment，它可以包含一组执行特定作业的Activity。具有相同任务相似性的Activity通常在同一任务中分组。任务也可以是显示在用户交互的作业的最近屏幕中的实体。任务还可以包含其他任务。 /** * A basic container that can be used to contain activities or other &#123;@link TaskFragment&#125;, which * also able to manage the activity lifecycle and updates the visibilities of the activities in it. */ class TaskFragment extends WindowContainer&lt;WindowContainer&gt; &#123; 一个基本容器，可用于包含Activity或其他TaskFragment，它还能够管理Activity生命周期并更新其中活动的可见性。 Task的容器 —— TaskDisplayArea/** * &#123;@link DisplayArea&#125; that represents a section of a screen that contains app window containers. * * The children can be either &#123;@link Task&#125; or &#123;@link TaskDisplayArea&#125;. */ final class TaskDisplayArea extends DisplayArea&lt;WindowContainer&gt; &#123; TaskDisplayArea，代表了屏幕上一块专门用来存放App窗口的区域。它的子容器可能是Task或者是TaskDisplayArea。 DefaultTaskDisplay是TaskDisplayArea的别名，在代码中有体现，后面说明从这个dump中我们可以看到TaskDisplayArea下面就是Task，Task下面就是ActivityRecord且有多个，而ActivityRecord下面的a9a1d8b和c4b2818是各自的WindowState DisplayArea类/** * Container for grouping WindowContainer below DisplayContent. * * DisplayAreas are managed by a &#123;@link DisplayAreaPolicy&#125;, and can override configurations and * can be leashed. * * DisplayAreas can contain nested DisplayAreas. * * DisplayAreas come in three flavors, to ensure that windows have the right Z-Order: * - BELOW_TASKS: Can only contain BELOW_TASK DisplayAreas and WindowTokens that go below tasks. * - ABOVE_TASKS: Can only contain ABOVE_TASK DisplayAreas and WindowTokens that go above tasks. * - ANY: Can contain any kind of DisplayArea, and any kind of WindowToken or the Task container. * * @param &lt;T&gt; type of the children of the DisplayArea. */ public class DisplayArea&lt;T extends WindowContainer&gt; extends WindowContainer&lt;T&gt; &#123; 用于将WindowContainer分组到DisplayContent下方的容器。DisplayArea由｛@link DisplayAreaPolicy｝管理，能够复写Configuration和被绑定到leash上。DisplayArea可以包含嵌套的DisplayArea。DisplayAreas有三种风格，以确保窗口具有正确的Z顺序： BELOW_TASKS:只能包含位于任务下方的BELLOW_TASK显示区域和WindowToken。 ABOVE_TASKS:只能包含位于任务上方的ABOVE_TASK显示区域和WindowToken。 ANY：可以包含任何类型的DisplayArea，以及任何类型的WindowToken或Task容器。 @param＜T＞DisplayArea的子项的类型。 DisplayArea有三个直接子类，TaskDisplayArea，DisplayArea.Tokens和DisplayArea.Tokens Task的容器 —— TaskDisplayArea/** * &#123;@link DisplayArea&#125; that represents a section of a screen that contains app window containers. * * The children can be either &#123;@link Task&#125; or &#123;@link TaskDisplayArea&#125;. */ final class TaskDisplayArea extends DisplayArea&lt;WindowContainer&gt; &#123; TaskDisplayArea为DisplayContent的孩子，对应着窗口层次的第2层。第2层作为应用层，看它的定义：int APPLICATION_LAYER &#x3D; 2，应用层的窗口是处于第2层。TaskDisplayArea代表了屏幕上的一个包含App类型的WindowContainer的区域。它的子节点可以是Task，或者是TaskDisplayArea。 public DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content, RootDisplayArea root, DisplayArea.Tokens imeContainer) &#123; Inject.ResultOne&lt;TaskDisplayArea&gt; result = new Inject.ResultOne&lt;&gt;(new TaskDisplayArea(content, wmService, &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER)); 在DisplayAreaPolicy.java中有创建，并更名为DefaultTaskDisplayArea WindowTokens的容器 —— DisplayArea.Tokens /** * DisplayArea that contains WindowTokens, and orders them according to their type. */ public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123; Tokens为DisplayArea的内部类，且继承DisplayArea。即Tokens代表专门包含WindowTokens的容器，它的孩子是WindowToken，而WindowToken的孩子则为WindowState对象。WindowState是对应着一个窗口的。 输入法的容器 —— ImeContainer /** * Container for IME windows. * * This has some special behaviors: * - layers assignment is ignored except if setNeedsLayer() has been called before (and no * layer has been assigned since), to facilitate assigning the layer from the IME target, or * fall back if there is no target. * - the container doesn&#39;t always participate in window traversal, according to * &#123;@link #skipImeWindowsDuringTraversal()&#125; */ private static class ImeContainer extends DisplayArea.Tokens &#123; ImeContainer为DisplayContent.java的内部类，且继承DisplayArea.Tokens，即同样是一个WindowToken的容器，它的孩子是WindowToken类型。WindowToken的孩子为WindowState类型，而WindowState类型则对应着输入法窗口。 模糊效果 —— DisplayArea.Dimmable /** * DisplayArea that can be dimmed. */ static class Dimmable extends DisplayArea&lt;DisplayArea&gt; &#123; private final Dimmer mDimmer = new Dimmer(this); Dimmable也是DisplayArea的内部类，从名字可以看出，这类的DisplayArea可以添加模糊效果，并且Dimmable也是一个DisplayArea类型的DisplayArea容器。可以通过Dimmer对象mDimmer施加模糊效果，模糊图层可以插入到以该Dimmable对象为根节点的层级结构之下的任意两个图层之间。且它有一个直接子类，RootDisplayArea。 DisplayArea层级结构的根节点 —— RootDisplayArea/** * Root of a &#123;@link DisplayArea&#125; hierarchy. It can be either the &#123;@link DisplayContent&#125; as the root * of the whole logical display, or a &#123;@link DisplayAreaGroup&#125; as the root of a partition of the * logical display. */ class RootDisplayArea extends DisplayArea.Dimmable &#123; ｛@link DisplayArea｝层次结构的根。它可以是作为整个逻辑显示的根的{@link DisplayContent}，也可以是作为逻辑显示的分区的根的｛@link DisplayAreaGroup}。即：DisplayContent，作为整个屏幕的DisplayArea层级结构根节点。DisplayAreaGroup，作为屏幕上部分区域对应的DisplayArea层级结构的根节点 屏幕 —— DisplayContent/** * Utility class for keeping track of the WindowStates and other pertinent contents of a * particular Display. */ class DisplayContent extends RootDisplayArea implements WindowManagerPolicy.DisplayContentInfo &#123; 用于跟踪特定显示器的WindowStates和其他相关内容的实用程序类，总而言之就是代表一个屏幕。隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每一个DisplayContent都对应着唯一ID DisplayAreaGroup/** The root of a partition of the logical display. */ class DisplayAreaGroup extends RootDisplayArea &#123; 逻辑显示分区的根","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"WMSAMS","slug":"Android-FrameWork/Framework源码分析/Android-13/WMSAMS","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"}]},{"path":"wiki/Android Application/Android工具类/判断当前应用是否退到后台/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyApp extends MultiDexApplication &#123; private int count = 0; @Override public void onCreate() &#123; initActivityLifecycle(); &#125; private void initActivityLifecycle() &#123; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; count ++; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; if(count &gt; 0) &#123; count--; &#125; boolean isBackground = isBackground(); Log.e(&quot;tyl&quot;,&quot;isBackground=&quot;+isBackground); if(isBackground)&#123; //app已经切入到后台 //System.exit(0); &#125; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; &#125; &#125;); &#125; /** * 判断app是否在后台 * @return */ public boolean isBackground()&#123; if(count &lt;= 0)&#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/8.点击桌面APP图标，到APP界面显示流程分析(二)/","text":"八、绘制ViewRootImpl.performDraw先看CPU绘制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788java复制代码ViewRootImpl.mTraversalRunnable.run()| doTraversal(); | performTraversals(); | relayoutWindow //创建surface流程 + sf 创建layer流程 | hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface); | mAttachInfo.mThreadedRenderer.allocateBuffers();//硬件绘制，预分配内存 | performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); | mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); // measure 流程 | performLayout(lp, mWidth, mHeight); | mView.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // layout 流程 | mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();//分发OnGlobalLayout事件 | View focused = mView.findFocus(); focused.restoreDefaultFocus(); //插眼WYF，这块逻辑以后再看 // 分发OnPreDraw事件 | boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible; //不拦截的话 cancelDraw = FALSE | performDraw(); | Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;draw&quot;); | boolean canUseAsync = draw(fullRedrawNeeded); | mAttachInfo.mTreeObserver.dispatchOnDraw();// 分发OnDraw，回调OnDrawListener中的onDraw()方法。 // 硬件绘制 | isHardwareEnabled() | mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); // 如果未开启硬件绘制使用软件绘制： | drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets) | Canvas canvas = mSurface.lockCanvas(dirty); // /frameworks/base/core/java/android/view/Surface.java |--&gt;Canvas lockCanvas(Rect inOutDirty) | | private final Canvas mCanvas = new CompatibleCanvas(); // 初始化 Canvas.mNativeCanvasWrapper | // 把 native lock 的Surface地址保存到mLockedObject，这个mLockedObject通常情况和mNativeObject是一个地址 | | mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); | | // /frameworks/base/core/jni/android_view_Surface.cpp | |--&gt;nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) | | // 把Java层保存的地址转换为 native Surface | | sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject)); | | ANativeWindow_Buffer buffer; | | surface-&gt;lock(&amp;buffer, dirtyRectPtr); |--&gt;Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds) | // 1、需要先连接到SurfaceFlinger端的BufferQueueProducer，会返回宽高数据，SurfaceFlinger端的BufferQueueCore也会设置一些属性 | // 注释说在调用dequeueBuffer前，必须先调用connect，是传入生产者监听，接收 onBufferReleased 回调。 | // 但是软绘，传入的监听是StubProducerListener，onBufferReleased是个空函数 | int err = Surface::connect(NATIVE_WINDOW_API_CPU); | | ANativeWindowBuffer* out; | int fenceFd = -1; | | // 2、调用dequeueBuffer获取 ANativeWindowBuffer 对象 和 fenceFd。 | | status_t err = dequeueBuffer(&amp;out, &amp;fenceFd); // 【进入 dequeueBuffer 章节】 | | // 3、使用ANativeWindowBuffer创建后台 GraphicBuffer 对象 | | sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out)); // GraphicBuffer 继承 ANativeWindowBuffer | // 4、获取前台buffer | const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); | // 宽高格式都相同时，可以把前台的buffer的 Region 复制给后台buffer | const bool canCopyBack = (frontBuffer != nullptr &amp;&amp; backBuffer-&gt;width == frontBuffer-&gt;width &amp;&amp;...); | // 干净区域 = 上一次所重绘的区域减去接下来需要重绘的脏区域newDirtyRegion， | // copyBlt 把干净的区域从frontBuffer拷贝到backBuffer | if (canCopyBack) const Region copyback(mDirtyRegion.subtract(newDirtyRegion));copyBlt(...); | // 5、锁定 GraphicBuffer，获取buffer地址 | void* vaddr; // 这变量会携带图形buffer的地址回来，图形库，其实就是在这个地址上做像素操作 | // 调用 GraphicBufferMapper::lockAsync | backBuffer-&gt;lockAsync(...,newDirtyRegion.bounds(), &amp;vaddr, fenceFd); | mLockedBuffer = backBuffer; // 后台buffer变为已经lock的buffer，入队后变为 mPostedBuffer | // 6、把获取到的这些信息，存储到 ANativeWindow_Buffer，函数返回后，会把这对象传给图形库 | outBuffer-&gt;width = backBuffer-&gt;width; | outBuffer-&gt;height = backBuffer-&gt;height; | outBuffer-&gt;stride = backBuffer-&gt;stride; | outBuffer-&gt;format = backBuffer-&gt;format; | outBuffer-&gt;bits = vaddr; // 把图形buffer的地址赋值给 ANativeWindow_Buffer.bits | // graphics::Canvas.mCanvas = native 层的 SkiaCanvas | | graphics::Canvas canvas(env, canvasObj); | // 把图形缓存的地址，宽高格式啊这些，设置进图形库的 SkiaCanvas，有了这些，图形库就专注画图就行了 | canvas.setBuffer(&amp;buffer, static_cast&lt;int32_t&gt;(surface-&gt;getBuffersDataSpace())); | sp&lt;Surface&gt; lockedSurface(surface); // 创建新的sp引用 | lockedSurface-&gt;incStrong(&amp;sRefBaseOwner); // 引用加一 | return (jlong) lockedSurface.get(); // 返回地址，传入Java 层的 mLockedObject | | return mCanvas; | mView.draw(canvas); //[View的绘制流程] | surface.unlockCanvasAndPost(canvas); // queueBuffer流程起始 | if (mHwuiContext != null) mHwuiContext.unlockAndPost(canvas); | else unlockSwCanvasAndPost(canvas); | nativeUnlockCanvasAndPost(mLockedObject, canvas); |--&gt;nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj) | sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject)); | graphics::Canvas canvas(env, canvasObj); | canvas.setBuffer(nullptr, ADATASPACE_UNKNOWN);// detach the canvas from the surface | status_t err = surface-&gt;unlockAndPost(); |--&gt;Surface::unlockAndPost() | int fd = -1; | status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd); | err = queueBuffer(mLockedBuffer.get(), fd); // 【进入 queueBuffer 章节】 | mPostedBuffer = mLockedBuffer; // 把锁定状态的buffer转换为 已经入队的 buffer | mLockedBuffer = nullptr; Surface.connect–&gt;BBQBufferQueueProducer.connect 重点是注册生产者回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354c++复制代码status_t Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds);| if (!mConnectedToCpu) // 没调用过 connect 时，false | Surface::connect(NATIVE_WINDOW_API_CPU); |--&gt;Surface::connect(int api) | // StubProducerListener 就是个虚假的实现,重载函数都为空函数 | static sp&lt;IProducerListener&gt; listener = new StubProducerListener(); | return connect(api, listener); |--&gt;Surface::connect(int api, const sp&lt;IProducerListener&gt;&amp; listener) | return connect(api, listener, false); | //参数 reportBufferRemoval = false |--&gt;Surface::connect( int api, const sp&lt;IProducerListener&gt;&amp; listener, bool reportBufferRemoval) | IGraphicBufferProducer::QueueBufferOutput output; | mReportRemovedBuffers = reportBufferRemoval; // false | // mProducerControlledByApp = true; BBQSurface 创建时，传入的是 true | int err = mGraphicBufferProducer-&gt;connect(listener, api, mProducerControlledByApp, &amp;output); |--&gt;BBQBufferQueueProducer.connect(IProducerListener&amp; listener,int api,bool producerControlledByApp QueueBufferOutput* output) | return BufferQueueProducer::connect(listener, api, producerControlledByApp, output); |--&gt;BufferQueueProducer::connect(IProducerListener&amp; listener,int api, bool producerControlledByApp, QueueBufferOutput *output) | mConsumerName = mCore-&gt;mConsumerName;//mConsumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot; | // 中间有一段代码，会依据擦混入的参数producerControlledByApp再调整一次 BufferQueueCore的 mFreeSlots mUnusedSlots | // 目前的参数为无效代码，不贴代码了 | | switch (api) &#123; case NATIVE_WINDOW_API_EGL: | case NATIVE_WINDOW_API_CPU: | case NATIVE_WINDOW_API_MEDIA: case NATIVE_WINDOW_API_CAMERA: | mCore-&gt;mConnectedApi = api; // 返回给 Surface 的属性 // 这些值，在 BLASTBufferQueue.update 把SurfaceContrl的值传到BufferQueueCore，现在又从 BufferQueueCore 传回Surface | output-&gt;width = mCore-&gt;mDefaultWidth; | output-&gt;height = mCore-&gt;mDefaultHeight; // 用于优化旋转。预旋转 | output-&gt;transformHint = mCore-&gt;mTransformHintInUse = mCore-&gt;mTransformHint;//初始化时为 0 // 返回当前 处于 QUEUEED 状态的 buffer 数量 | output-&gt;numPendingBuffers = static_cast&lt;uint32_t&gt;(mCore-&gt;mQueue.size()); output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + 1; | output-&gt;bufferReplaced = false; output-&gt;maxBufferCount = mCore-&gt;mMaxBufferCount; | // 【注册生产者回调--onBufferReleased】 | mCore-&gt;mConnectedProducerListener = listener;// CPU绘制传入的 StubProducerListener,没啥用 // 用于触发 onBufferReleased 回调, mBufferReleasedCbEnabled 为true的时候才能触发 | mCore-&gt;mBufferReleasedCbEnabled = listener-&gt;needsReleaseNotify(); // CPU 绘制返回false | // 再刷一遍 BufferQueueCore 的属性，其实这些属性 BufferQueueCore 初始化时设置的也是这些值 | mCore-&gt;mConnectedPid = BufferQueueThreadState::getCallingPid(); | mCore-&gt;mBufferHasBeenQueued = false; mCore-&gt;mDequeueBufferCannotBlock = false; | | mCore-&gt;mQueueBufferCanDrop = false; mCore-&gt;mLegacyBufferDrop = true; | mCore-&gt;mAllowAllocation = true; // 允许分配内存 | // 使用请求到的数据，设置 Surface 属性 | mDefaultWidth = output.width; mDefaultHeight = output.height; | mNextFrameNumber = output.nextFrameNumber; mMaxBufferCount = output.maxBufferCount; | mTransformHint = output.transformHint;// 这只是一个提示，实际的转换可能会有所不同。被用来提高layer的系统性能 | mConsumerRunningBehind = (output.numPendingBuffers &gt;= 2); | if (!err &amp;&amp; api == NATIVE_WINDOW_API_CPU) mConnectedToCpu = true; // CPU绘制 else mDirtyRegion = Region::INVALID_REGION; Surface继承 ANativeWindow ANativeWindow 图形库的各种函数 ANativeWindow_Buffer ANativeWindow_Buffer.bits 存储图形buffer的地址 用于 Surface::lock 的参数，用于图形库。 GraphicBuffer 继承 ANativeWindowBuffer 封装图形内存分配接口 GraphicBufferMapper GraphicBufferAllocator ，以及进程间传递的序列化接口 ANativeWindowBuffer typedef ANativeWindowBuffer ANativeWindowBuffer_t typedef ANativeWindowBuffer_t android_native_buffer_t; 内部有个成员 native_handle_t* handle; 存储buffer的fd Surface.dequeueBuffer–&gt;BufferQueueProducer.dequeueBufferBBQBufferQueueProducer 没有重载 BufferQueueProducer.dequeueBuffer 直接调用父类 BufferQueueProducer.dequeueBuffer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113c++复制代码status_t Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds);| if (!mConnectedToCpu) // 没调用过 connect 时，false | Surface::connect(NATIVE_WINDOW_API_CPU);| ANativeWindowBuffer* out; | int fenceFd = -1;| status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);|--&gt;Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd);| | getDequeueBufferInputLocked(&amp;dqInput); |--&gt;Surface::getDequeueBufferInputLocked(IGraphicBufferProducer::DequeueBufferInput* dequeueInput) | // Req 前缀表示 request，用于请求使用的参数，软绘应该全使用的默认值 | dequeueInput-&gt;width = mReqWidth ? mReqWidth : mUserWidth;// 默认 mReqWidth = mUserWidth = 0 | dequeueInput-&gt;height = mReqHeight ? mReqHeight : mUserHeight;// 默认 mReqHeight = mUserHeight = 0 | dequeueInput-&gt;format = mReqFormat;// 默认 0 | dequeueInput-&gt;usage = mReqUsage;// 默认 0 | dequeueInput-&gt;usage = mReqUsage;// mEnableFrameTimestamps 默认false | dequeueInput-&gt;getTimestamps = mEnableFrameTimestamps;// mEnableFrameTimestamps 默认false | int buf = -1; | sp&lt;Fence&gt; fence; | nsecs_t startTime = systemTime();// 当前时间 | FrameEventHistoryDelta frameTimestamps; | status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, dqInput.width,dqInput.height, dqInput.format, dqInput.usage, &amp;mBufferAge,dqInput.getTimestamps ? &amp;frameTimestamps : nullptr); |--&gt;BufferQueueProducer.dequeueBuffer(int* outSlot, sp&lt;android::Fence&gt;* outFence, uint32_t width, uint32_t height, PixelFormat format, uint64_t usage, uint64_t* outBufferAge, FrameEventHistoryDelta* outTimestamps) | mConsumerName = mCore-&gt;mConsumerName; // consumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot; | //width、height 可以都为0，但是不能一个是0，一个非零。 | if ((width &amp;&amp; !height) || (!width &amp;&amp; height)) return BAD_VALUE; | if (mCore-&gt;mFreeBuffers.empty() &amp;&amp; mCore-&gt;mIsAllocating) mCore-&gt;waitWhileAllocatingLocked(lock);//正在分配buffer，自旋等待 | if (format == 0) format = mCore-&gt;mDefaultBufferFormat; // mDefaultBufferFormat = PIXEL_FORMAT_RGBA_8888 | // mConsumerUsageBits 在BLASTBufferItemConsumer构造是赋值为 GraphicBuffer::USAGE_HW_COMPOSER |GraphicBuffer::USAGE_HW_TEXTURE | usage |= mCore-&gt;mConsumerUsageBits | const bool useDefaultSize = !width &amp;&amp; !height; // 宽高都为0，使用默认尺寸 | if (useDefaultSize) | //默认宽高在 BLASTBufferQueue.update 把SurfaceContrl的宽高值传到BufferQueueCore | width = mCore-&gt;mDefaultWidth; height = mCore-&gt;mDefaultHeight; | if (mCore-&gt;mAutoPrerotation &amp;&amp; (mCore-&gt;mTransformHintInUse &amp; NATIVE_WINDOW_TRANSFORM_ROT_90)) | std::swap(width, height); // mAutoPrerotation自动预旋转默认false，mTransformHintInUse 90度时宽高互换 | int found = BufferItem::INVALID_BUFFER_SLOT; | //【获取可用的 BufferSlot 索引】 | waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue, lock, &amp;found); |--&gt;BufferQueueProducer::waitForFreeSlotThenRelock(FreeSlotCaller caller, std::unique_lock&lt;std::mutex&gt;&amp; lock, int* found) | bool tryAgain = true; | while (tryAgain) | *found = BufferQueueCore::INVALID_BUFFER_SLOT; | // 首先从list链表 BufferQueueCore-&gt;mFreeBuffers 拿 BufferSlot，如果集合是空的，会返回BufferQueueCore::INVALID_BUFFER_SLOT | int slot = getFreeBufferLocked(); | if (slot != BufferQueueCore::INVALID_BUFFER_SLOT) | *found = slot; | else if (mCore-&gt;mAllowAllocation) | // mFreeBuffers没有，就从set集合 BufferQueueCore-&gt;mFreeSlots 拿 BufferSlot，如果集合是空的，返回BufferQueueCore::INVALID_BUFFER_SLOT | *found = getFreeSlotLocked(); | tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) || tooManyBuffers; | // 没有 buffer了，或者 queue 太多了(这个可能性不大，mFreeSlots 这个set就三个数据，dequeue不出来那么多，queue就更不可能)， | if (tryAgain) | if (mDequeueTimeout &gt;= 0)// BBQ 设置的mDequeueTimeout=int64.max | // 等待buffer(有可能是buffer被释放了，小概率因为mFreeSlots集合增加了) | mCore-&gt;mDequeueCondition.wait_for(lock, std::chrono::nanoseconds(mDequeueTimeout)); | //拿到可用的索引found对应的 BufferSlot 的 GraphicBuffer | const sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[found].mGraphicBuffer); | //【把找到的buffer，插入到set集合 mActiveBuffers 中】 | mCore-&gt;mActiveBuffers.insert(found); | //把索引值返回 | *outSlot = found; | // 【把找到的 BufferSlot buffer状态转为 dequeue】 | mSlots[found].mBufferState.dequeue(); | //找到的 BufferSlot 没有关联GraphicBuffer，或者 GraphicBuffer 宽高，格式、usage、layerCount 和需求不相等的话，需要重新分配 | if ((buffer == nullptr) || buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) | mSlots[found].mAcquireCalled = false; mSlots[found].mGraphicBuffer = nullptr; | mSlots[found].mRequestBufferCalled = false; mSlots[found].mEglDisplay = EGL_NO_DISPLAY; | mSlots[found].mEglFence = EGL_NO_SYNC_KHR; mSlots[found].mFence = Fence::NO_FENCE; | mCore-&gt;mBufferAge = 0; // 设置 mBufferAge 为0，新鲜的buffer啊，还没有被queue过 | mCore-&gt;mIsAllocating = true; // 设置为正在分配内存 | //【 添加 “需要重新分配buffer” flag】 | returnFlags |= BUFFER_NEEDS_REALLOCATION; |else // 计算buffer年龄 | // mBufferAge： [(自从当前的 BufferSlot 上次被 queueBuffer 后，又queue了多少个BufferSlot) + 1] | mCore-&gt;mBufferAge = mCore-&gt;mFrameCounter + 1 - mSlots[found].mFrameNumber; | // 非共享内存模式下， 把当前的 buffer Fence ，传到外部参数 outFence | *outFence = (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == found) ? Fence::NO_FENCE : mSlots[found].mFence; | // BufferSlot的Fence重新赋值为 NO_FENCE | mSlots[found].mEglFence = EGL_NO_SYNC_KHR; | mSlots[found].mFence = Fence::NO_FENCE; | // 【需要重新分配buffer情况，分配新的buffer】 | if (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) | //GraphicBuffer构造函数中调用 GraphicBufferAllocator.allocate 分配图形buffer，并映射内存到当前进程 | sp&lt;GraphicBuffer&gt; graphicBuffer = new GraphicBuffer(width, height, format, BQ_LAYER_COUNT, usage,mConsumerName); | mCore-&gt;mIsAllocating = false; // 分配完了，要重新设置回 false 啊 | mCore-&gt;mIsAllocatingCondition.notify_all(); // 唤醒那些因为 正在分配buffer 而等待的线程 | // 如果需要等待 eglFence 释放 Fence | if (eglFence != EGL_NO_SYNC_KHR) | EGLint result = eglClientWaitSyncKHR(eglDisplay, eglFence, 0,1000000000);// 等待B | eglDestroySyncKHR(eglDisplay, eglFence); | *outBufferAge = mCore-&gt;mBufferAge; // buffer年龄传到外部 | addAndGetFrameTimestamps(nullptr, outTimestamps);// BBQ 没有实现这方法，是个空实现。只有 BufferQueue 在消费者进程里，才会被调用。 | return returnFlags; | //继续 Surface::dequeueBuffer | mLastDequeueDuration = systemTime() - startTime;// 计算 dequeue 时间 | mLastDequeueStartTime = startTime;// 记录上次 dequeue 开始时间 | // 根据拿到的 slolt 下标,获取本地Surface自己的 GraphicBuffer | sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer); | if (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) freeAllBuffers(); | if (dqInput.getTimestamps) mFrameEventHistory-&gt;applyDelta(frameTimestamps); | // dequeueBuffer返回值 带有 BUFFER_NEEDS_REALLOCATION 标记，并且 gbuf == nullptr 的时候 进入此分支 | if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == nullptr) | //【请求 GraphicBuffer】 | // requestBuffer接口很简单，直接返回 dequeueBuffer时关联/创建的 GraphicBuffer对象。 | // S版本以前，需要跨进程传递GraphicBuffer对象，反序列化时，会调用GraphicBufferMapper.importBuffer映射内存 | result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf); | if (fence-&gt;isValid()) *fenceFd = fence-&gt;dup(); | // 赋值外部的 android_native_buffer_t** buffer | *buffer = gbuf.get(); | // std::unordered_set&lt;int&gt; mDequeuedSlots; | mDequeuedSlots.insert(buf); // Dequeued 的buffer的 下标 存入 mDequeuedSlots Surface.queueBuffer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116c++复制代码// 前置流程：surface.unlockCanvasAndPost(canvas); // queueBuffer| if (mHwuiContext != null) mHwuiContext.unlockAndPost(canvas);| else unlockSwCanvasAndPost(canvas); | nativeUnlockCanvasAndPost(mLockedObject, canvas); |--&gt;nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj) | sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject)); | graphics::Canvas canvas(env, canvasObj); | canvas.setBuffer(nullptr, ADATASPACE_UNKNOWN);// detach the canvas from the surface | status_t err = surface-&gt;unlockAndPost(); |--&gt;Surface::unlockAndPost() | | int fd = -1; | | status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd); | GraphicBuffer::getBufferMapper().unlockAsync(handle, fenceFd); | | err = queueBuffer(mLockedBuffer.get(), fd); // 进入【queueBuffer 章节】 | | mPostedBuffer = mLockedBuffer; // 把锁定的buffer转换为 已经入队的 buffer | | mLockedBuffer = nullptr; | nativeRelease(mLockedObject); | mLockedObject = 0;//【queueBuffer 章节】Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) | int i = getSlotFromBufferLocked(buffer);| // 遍历 Surface.mSlots 数组，找到 GraphicBuffer.handle 相同的 BufferSlot 索引|--&gt;Surface::getSlotFromBufferLocked(android_native_buffer_t* buffer) | for (int i = 0; i &lt; NUM_BUFFER_SLOTS; i++) | if (mSlots[i].buffer != nullptr &amp;&amp; mSlots[i].buffer-&gt;handle == buffer-&gt;handle) | return i;| IGraphicBufferProducer::QueueBufferOutput output;| IGraphicBufferProducer::QueueBufferInput input;| /* Surface.mTimestamp 使用默认的 NATIVE_WINDOW_TIMESTAMP_AUTO 时， QueueBufferInput.timestamp = systemTime(SYSTEM_TIME_MONOTONIC); QueueBufferInput.isAutoTimestamp = true; // 这个参数标明是否在入队时，自动生成时间戳 | */ | getQueueBufferInputLocked(buffer, fenceFd, mTimestamp, &amp;input);| // 一些 Gralloc 的元数据 mapper.setDataspace，HdrMetadata 设置| applyGrallocMetadataLocked(buffer, input);| sp&lt;Fence&gt; fence = input.fence;| nsecs_t now = systemTime();| status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);|--&gt;BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) | int64_t requestedPresentTimestamp; bool isAutoTimestamp; android_dataspace dataSpace; | Rect crop(Rect::EMPTY_RECT); int scalingMode; uint32_t transform; | uint32_t stickyTransform; sp&lt;Fence&gt; acquireFence; bool getFrameTimestamps = false; | // 读取输入参数的数据 | input.deflate(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace, &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform, &amp;getFrameTimestamps); | const Region&amp; surfaceDamage = input.getSurfaceDamage(); | const HdrMetadata&amp; hdrMetadata = input.getHdrMetadata(); | sp&lt;IConsumerListener&gt; frameAvailableListener;// buffer 可用通知 | sp&lt;IConsumerListener&gt; frameReplacedListener;//buffer被替换通知 | BufferItem item; // 创建 BufferItem | // 拿到 slot 对应的 GraphicBuffer | const sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[slot].mGraphicBuffer); | // 裁剪区域 | Rect bufferRect(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight()); | Rect croppedRect(Rect::EMPTY_RECT); | // crop 和 bufferRect 的交集，结果存入 croppedRect | crop.intersect(bufferRect, &amp;croppedRect); | mSlots[slot].mFence = acquireFence; | //【设置为 QUEUED 状态】 | mSlots[slot].mBufferState.queue(); | ++mCore-&gt;mFrameCounter;// 每次 queueBuffer 都+1 | currentFrameNumber = mCore-&gt;mFrameCounter; | mSlots[slot].mFrameNumber = currentFrameNumber;//存储当前BufferSlot的帧号 | // 封装 BufferItem 信息 | item.mAcquireCalled = mSlots[slot].mAcquireCalled; | item.mGraphicBuffer = mSlots[slot].mGraphicBuffer; //图形buffer | item.mCrop = crop;//裁切矩形 | item.mTransform = transform &amp; ~static_cast&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);// 旋转变换 | item.mTransformToDisplayInverse = (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != 0; | item.mScalingMode = static_cast&lt;uint32_t&gt;(scalingMode);//缩放模式 | item.mTimestamp = requestedPresentTimestamp;//时间戳 | item.mIsAutoTimestamp = isAutoTimestamp;// 是否在入队时，自动生成时间戳，默认情况下 true | item.mDataSpace = dataSpace;// 描述图像内容，依赖于图像格式 | item.mHdrMetadata = hdrMetadata;// HDR metadata 不懂 | item.mFrameNumber = currentFrameNumber;//帧号 | item.mSlot = slot;/*索引*/ item.mFence = acquireFence;/*fence*/ item.mFenceTime = acquireFenceTime;/*FenceTime*/ | // mIsDroppable 如果为true，则 queuebuffer 时，可以替换旧的buffer。 | item.mIsDroppable = mCore-&gt;mAsyncMode || ...;// 当前 mIsDroppable = false | item.mSurfaceDamage = surfaceDamage;//已经被修改的区域 | item.mQueuedBuffer = true;// 标明buffer已经被生产者 queued，acquireBuffer后设置为false | item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;// 仅仅在共享buffer下有用，标明消费者应该尽快 acquire 下一帧 | item.mApi = mCore-&gt;mConnectedApi;//表明是 CPU还是GPU queue的buffer | output-&gt;bufferReplaced = false; | //【BufferItem入队】 | mCore-&gt;mQueue.push_back(item); | // BufferQueueCore.mConsumerListener = ConsumerBase(BLASTBufferItemConsumer的父类) | frameAvailableListener = mCore-&gt;mConsumerListener; | mCore-&gt;mBufferHasBeenQueued = true;// 每次queueBuffer后都设置为true | mCore-&gt;mDequeueCondition.notify_all();// 唤醒等待的线程 | mCore-&gt;mLastQueuedSlot = slot;// 赋值最新queue的 BufferSlot 索引 | // 返回给Surface的数据 | output-&gt;width = mCore-&gt;mDefaultWidth; output-&gt;height = mCore-&gt;mDefaultHeight; | output-&gt;transformHint = mCore-&gt;mTransformHintInUse = mCore-&gt;mTransformHint; | output-&gt;numPendingBuffers = static_cast&lt;uint32_t&gt;(mCore-&gt;mQueue.size());// 返回当前已经Queue的数量，代表还未被消费的数量 | output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + 1;// 返回下一帧的帧号 | // atrace 记录 mQueue 大小 | ATRACE_INT(mCore-&gt;mConsumerName.string(), static_cast&lt;int32_t&gt;(mCore-&gt;mQueue.size())); | // BBQ生产者构造函数设置 mConsumerIsSurfaceFlinger = false | if (!mConsumerIsSurfaceFlinger) | // 清理 GraphicBuffer 指针【TODO：这里的一些比较重要联动细节待研究】 | item.mGraphicBuffer.clear(); | int connectedApi = mCore-&gt;mConnectedApi; | sp&lt;Fence&gt; lastQueuedFence = std::move(mLastQueueBufferFence); | mLastQueueBufferFence = std::move(acquireFence); | //【消费者回调】 | // 回调到 ConsumerBase.onFrameAvailable ，再回调到 BLASTBufferQueue.onFrameAvailable | frameAvailableListener-&gt;onFrameAvailable(item);//【转入“BufferQueueConsumer::acquireBuffer”章节】 | // 如果是 GPU 绘制，最多queueBuffer两个buffer，第二个buffer没有绘制完成，就需要等待 fence | if (connectedApi == NATIVE_WINDOW_API_EGL) | lastQueuedFence-&gt;waitForever(&quot;Throttling EGL Production&quot;);| mLastQueueDuration = systemTime() - now; // 记录 queueBuffer 时间| // 更新Surface的一些成员属性| onBufferQueuedLocked(i, fence, output); BufferQueueConsumer::acquireBuffer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990c++复制代码BLASTBufferQueue::onFrameAvailable(const BufferItem&amp; item)| acquireNextBufferLocked(std::nullopt);|--&gt;BLASTBufferQueue::acquireNextBufferLocked(const std::optional&lt;SurfaceComposerClient::Transaction*&gt; transaction) | // 参数 transaction = nullopt | const bool includeExtraAcquire = !transaction;// includeExtraAcquire = true | // 判断 mNumAcquired 是否大于等于 mMaxAcquiredBuffers + (includeExtraAcquire ? 2 : 1) | const bool maxAcquired = maxBuffersAcquired(includeExtraAcquire); | // Transaction 一个事务里边会填充各种需要执行的业务和业务数据，最终传递到 SurfaceFlinger，SF对事务解析的结果通常是设置Layer的各种属性 | // 每设置一种数据，都会存到ComposerState中，并添加对应的flag，SF端根据flag解析数据 | SurfaceComposerClient::Transaction localTransaction; | bool applyTransaction = true; | SurfaceComposerClient::Transaction* t = &amp;localTransaction; | BufferItem bufferItem; // 创建一个未填充数据的的栈对象 BufferItem | //【acquireBuffer流程!!!!!!!!!!!!!!!!】 | status_t status = mBufferItemConsumer-&gt;acquireBuffer(&amp;bufferItem, 0 /* expectedPresent */, false); |--&gt;BufferItemConsumer::acquireBuffer(BufferItem *item, nsecs_t presentWhen, bool waitForFence) | acquireBufferLocked(item, presentWhen); // presentWhen = 0 |--&gt;ConsumerBase::acquireBufferLocked(BufferItem *item, nsecs_t presentWhen, uint64_t maxFrameNumber) | // 调用消费者的 acquireBuffer, mConsumer 为 BufferQueueConsumer | mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber); |--&gt;BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer, nsecs_t expectedPresent, uint64_t maxFrameNumber) | // 参数： outBuffer 是个需要带回数据的指针; expectedPresent = 0; maxFrameNumber = 0 | // 拿到队列的迭代指针 | BufferQueueCore::Fifo::iterator front(mCore-&gt;mQueue.begin()); | // 忽略一大段不执行的分支：作用就是丢弃buffer的操作、共享buffer | int slot = front-&gt;mSlot; // 把 mQueue 队列里的第一个 BufferItem 的mSlot，赋值给 slot | // 【把拿到的 BufferItem 通过指针参数带回】 | *outBuffer = *front; | ATRACE_BUFFER_INDEX(slot);// trace 记录 BufferSlot 的索引值 | if (!outBuffer-&gt;mIsStale) // 如果buffer没有过时 | mSlots[slot].mAcquireCalled = true;// 设置状态为已经被acquire过了 | // 【切换状态为 acquired 状态】 | mSlots[slot].mBufferState.acquire(); | mSlots[slot].mFence = Fence::NO_FENCE; // 设置为 NO_FENCE | if (outBuffer-&gt;mAcquireCalled) // 已经被消费过了，需要设置 GraphicBuffer 为 nullptr，避免 remapping | outBuffer-&gt;mGraphicBuffer = nullptr; | //【把 BufferItem 从队queued列中移除】 | mCore-&gt;mQueue.erase(front); | mCore-&gt;mDequeueCondition.notify_all();// 唤醒等待的线程 | // atrace 记录此时的队列长度 | ATRACE_INT(mCore-&gt;mConsumerName.string(), static_cast&lt;int32_t&gt;(mCore-&gt;mQueue.size())); | //返回到 ConsumerBase::acquireBufferLocked | //BBQ生产者 BufferQueueProducer::queueBuffer 时，把 mGraphicBuffer 指针清空了，这个分支不走的 | if (item-&gt;mGraphicBuffer != nullptr) | if (mSlots[item-&gt;mSlot].mGraphicBuffer != nullptr) | freeBufferLocked(item-&gt;mSlot); | mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer; | // 这里的 BufferItemConsumer.mSlots 和 BufferQueueConsumer.mSlots 不是同一个对象 | mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;// 帧号存到 BufferItemConsumer.mSlots 里 | mSlots[item-&gt;mSlot].mFence = item-&gt;mFence; // Fence存到 BufferItemConsumer.mSlots 里 | //返回到 BufferItemConsumer::acquireBuffer | if (waitForFence) // waitForFence = false ,无需等待fence | item-&gt;mFence-&gt;waitForever(&quot;BufferItemConsumer::acquireBuffer&quot;); | // 返回的 GraphicBuffer 为 BLASTBufferItemConsumer.mSlots 的 GraphicBuffer | item-&gt;mGraphicBuffer = mSlots[item-&gt;mSlot].mGraphicBuffer; | //返回到BLASTBufferQueue::acquireNextBufferLocked | auto buffer = bufferItem.mGraphicBuffer; | mNumFrameAvailable--; | if (buffer == nullptr) //TODO：流程上，应该是进入了此分支，现实是不可能，这里看了好几遍也没找到问题出哪里了，以后再重新分析一下吧 | mBufferItemConsumer-&gt;releaseBuffer(bufferItem, Fence::NO_FENCE); | return; | // 如果buffer的尺寸不匹配，直接释放buffer，请求下一个 | if (rejectBuffer(bufferItem)) | mBufferItemConsumer-&gt;releaseBuffer(bufferItem, Fence::NO_FENCE); | acquireNextBufferLocked(transaction); | return; | mNumAcquired++; // Acquired数量加一，release 时减一 | mLastAcquiredFrameNumber = bufferItem.mFrameNumber;// 记录当前的帧号 | // 创建 ReleaseCallbackId ，加入到map mSubmitted，SurfaceFlinger 释放buffer，回调回来时会通过ReleaseCallbackId查找BufferItem | ReleaseCallbackId releaseCallbackId(buffer-&gt;getId(), mLastAcquiredFrameNumber); | mSubmitted[releaseCallbackId] = bufferItem; | mSize = mRequestedSize; | Rect crop = computeCrop(bufferItem);// 裁剪矩形 | //【 releaseBuffer 回调函数 !!!!!!!!!!!!!!!!】,SurfaceFlinger合成完后，就是回调的 releaseBufferCallbackThunk函数 | auto releaseBufferCallback = std::bind(releaseBufferCallbackThunk, wp&lt;BLASTBufferQueue&gt;(this),...); | sp&lt;Fence&gt; fence = bufferItem.mFence ? new Fence(bufferItem.mFence-&gt;dup()) : Fence::NO_FENCE;//GPU绘制的fence | //【把buffer、fence、释放buffer的回调函数 都传入事务，通过事务传递给SurfaceFlinger】 | t-&gt;setBuffer(mSurfaceControl, buffer, fence, bufferItem.mFrameNumber, releaseBufferCallback); | // 使用 bufferItem中的数据，填充事务的其他各种数据... | t-&gt;setDataspace(mSurfaceControl, static_cast&lt;ui::Dataspace&gt;(bufferItem.mDataSpace)); | t-&gt;setHdrMetadata(mSurfaceControl, bufferItem.mHdrMetadata); | t-&gt;setBufferCrop(mSurfaceControl, crop); | t-&gt;setAutoRefresh(mSurfaceControl, bufferItem.mAutoRefresh); | t-&gt;setSurfaceDamageRegion(mSurfaceControl, bufferItem.mSurfaceDamage); | //.... | // 最后调用apply，把事务传递到SurfaceFlinger | t-&gt;setApplyToken(mApplyToken).apply(false, true); | SurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay) | sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); | sf-&gt;setTransactionState(mFrameTimelineInfo, composerStates, displayStates, flags, applyToken,...) 九、SurfaceFlinger 合成— Android 13 (Android T)相对于Android 12，Android13在架构上做了微调 SurfaceFlinger::onMessageInvalidate 对应于 SurfaceFlinger::commit，但是结构上做了大量的调整 一些函数像 handleMessageTransaction、handleTransaction、handleMessageInvalidate、handlePageFlip 这些都不见了 SurfaceFlinger::onMessageRefresh 对应于 SurfaceFlinger::composite 然后Android13 还做了GPU合成的优化 对GPU合成进行预测，如果有GPU合成，那么 chooseCompositionStrategy 和 GPU合成 并行执行。用以节约时间。 SurfaceComposerClient::Transaction::apply–&gt;SurfaceFlinger::setTransactionState 事务入队。加入到队列 SurfaceFlinger.mTransactionQueue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253c++复制代码// frameworks/native/libs/gui/SurfaceComposerClient.cppSurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay)| // applyToken 来源于 BLASTBufferQueue.h | // const sp&lt;IBinder&gt; mApplyToken GUARDED_BY(mMutex) = new BBinder();| sf-&gt;setTransactionState(mFrameTimelineInfo, composerStates, displayStates, flags, applyToken, mInputWindowCommands, mDesiredPresentTime, mIsAutoTimestamp, &#123;&#125; /*uncacheBuffer - only set in doUncacheBufferTransaction*/, hasListenerCallbacks, listenerCallbacks, mId);//进入 SurfaceFlinger 进程// frameworks/native/services/surfaceflinger/SurfaceFlinger.cppSurfaceFlinger::setTransactionState(const FrameTimelineInfo&amp; frameTimelineInfo, const Vector&lt;ComposerState&gt;&amp; states, const Vector&lt;DisplayState&gt;&amp; displays, uint32_t flags, const sp&lt;IBinder&gt;&amp; applyToken, const InputWindowCommands&amp; inputWindowCommands, int64_t desiredPresentTime, bool isAutoTimestamp, const client_cache_t&amp; uncacheBuffer, bool hasListenerCallbacks, const std::vector&lt;ListenerCallbacks&gt;&amp; listenerCallbacks, uint64_t transactionId)| //...| const int64_t postTime = systemTime();| IPCThreadState* ipc = IPCThreadState::self();| const int originPid = ipc-&gt;getCallingPid();| const int originUid = ipc-&gt;getCallingUid();| // 主要逻辑就是把这个 TransactionState 对象入队。然后请求 SF-vsync | TransactionState state&#123;frameTimelineInfo, states, displays, flags, applyToken, inputWindowCommands, desiredPresentTime, isAutoTimestamp, uncacheBuffer, postTime, permissions, hasListenerCallbacks,listenerCallbacks, originPid, originUid, transactionId&#125;;| //...| queueTransaction(state);|--&gt;SurfaceFlinger::queueTransaction(TransactionState&amp; state) | state.queueTime = systemTime(); | // std::deque&lt;TransactionState&gt; mTransactionQueue; 双端队列 | //【把 TransactionState 入队】 | // 在 SurfaceFlinger::flushTransactions() 函数中会出队 | mTransactionQueue.emplace_back(state); | ATRACE_INT(&quot;TransactionQueue&quot;, mTransactionQueue.size()); | const auto schedule = ...; | const auto frameHint = state.isFrameActive() ? FrameHint::kActive : FrameHint::kNone; | // 传入的事务flag是枚举类型 eTransactionFlushNeeded = 0x10; | setTransactionFlags(eTransactionFlushNeeded, schedule, state.applyToken, frameHint); |--&gt;SurfaceFlinger::setTransactionFlags(uint32_t mask, TransactionSchedule schedule, IBinder&amp; applyToken, FrameHint frameHint) | // 调整vsync一些时间配置 | modulateVsync(&amp;VsyncModulator::setTransactionSchedule, schedule, applyToken); /* 1、mTransactionFlags 添加 eTransactionFlushNeeded 标记 2、mTransactionFlags原值 同 mask 相与， 表示原先有没有这个标记。并把结果存储 scheduled 3、!scheduled 取非，表示如果原先没有这个标记，就进入此分支，执行 scheduleCommit */ | if (const bool scheduled = mTransactionFlags.fetch_or(mask) &amp; mask; !scheduled) | scheduleCommit(frameHint); |--&gt;SurfaceFlinger::scheduleCommit(FrameHint hint) | if (hint == FrameHint::kActive) | mScheduler-&gt;resetIdleTimer(); | mPowerAdvisor-&gt;notifyDisplayUpdateImminent(); | // 这个函数的调用链很长，知道这个代码是请求 SurfaceFlinger 的 vsync 就行了 | mScheduler-&gt;scheduleFrame(); MessageQueue::scheduleFrame() — 请求vsync123456789101112131415161718192021222324c++复制代码MessageQueue::scheduleFrame()| mVsync.registration-&gt;schedule(&#123;.workDuration = mVsync.workDuration.get().count(), .readyDuration = 0, .earliestVsync = mVsync.lastCallbackTime.count()&#125;);|--&gt;VSyncCallbackRegistration::schedule(VSyncDispatch::ScheduleTiming scheduleTiming) | if (!mValidToken) return std::nullopt; | // mDispatch 是 VSyncDispatchTimerQueue | return mDispatch.get().schedule(mToken, scheduleTiming); | VSyncDispatchTimerQueue::schedule(CallbackToken token, ScheduleTiming scheduleTiming) | ScheduleResult result; | // VSyncCallbackRegistration 构造的时候，调用registerCallback生成了一个 token ，这个token存储到了 map 对象 mCallbacks | // 现在拿出来 | auto it = mCallbacks.find(token); | auto&amp; callback = it-&gt;second; // map 迭代器 second 中存储 VSyncDispatchTimerQueueEntry | // VSyncDispatchTimerQueueEntry 中存储真正的回调函数 MessageQueue::vsyncCallback | result = callback-&gt;schedule(scheduleTiming, mTracker, now); | // 这里步骤还很多。大概是更新vsync的时间配置啥的 |--&gt;VSyncDispatchTimerQueueEntry::schedule(VSyncDispatch::ScheduleTiming timing, VSyncTracker&amp; tracker, nsecs_t now) | //省略VSyncDispatchTimerQueueEntry函数内XXXX，太长了。抽空再研究 | //......... | if (callback-&gt;wakeupTime() &lt; mIntendedWakeupTime - mTimerSlack) | // 启动vsync的定时器 | rearmTimerSkippingUpdateFor(now, it); | return result; sf-vsync事件分发流程 Android 13 把用了好多年的 onMessageInvalidate()、onMessageRefresh 体系给改了 变成了 SurfaceFlinger::commit 和 SurfaceFlinger::composite ，中间不post消息了，直接无缝切换 1234567891011121314151617181920212223242526c++复制代码// frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cppMessageQueue::vsyncCallback(nsecs_t vsyncTime, nsecs_t targetWakeupTime, nsecs_t readyTime)| mHandler-&gt;dispatchFrame(vsyncId, vsyncTime);|--&gt;MessageQueue::Handler::dispatchFrame(int64_t vsyncId, nsecs_t expectedVsyncTime) | mQueue.mLooper-&gt;sendMessage(this, Message())void MessageQueue::Handler::handleMessage(const Message&amp;) &#123; mFramePending.store(false); const nsecs_t frameTime = systemTime(); // mQueue 类型android::impl::MessageQueue // android::impl::MessageQueue.mCompositor 类型 ICompositor // SurfaceFlinger 继承 ICompositor // mQueue.mCompositor 其实就是 SurfaceFlinger auto&amp; compositor = mQueue.mCompositor; // 【流程1，返回false的话，直接返回，不会执行后面的合成流程composite】 if (!compositor.commit(frameTime, mVsyncId, mExpectedVsyncTime)) &#123; return; &#125; // 【流程2，合成】 compositor.composite(frameTime, mVsyncId); // 通过RegionSamplingThread对合成帧进行采样 compositor.sample();&#125; SurfaceFlinger::commit 流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191c++复制代码// frameworks/native/services/surfaceflinger/SurfaceFlinger.cppSurfaceFlinger::commit(nsecs_t frameTime, int64_t vsyncId, nsecs_t expectedVsyncTime)| // 返回 SurfaceFlinger.mTransactionFlags 是否携带 eTransactionFlushNeeded 标记。同时清除这个标记| // eTransactionFlushNeeded 是由 queueTransaction 流程中设置的| if (clearTransactionFlags(eTransactionFlushNeeded)) | //【1】、flushTransactions()，核心是获取所有的TransactionState，之后将作为 applyTransactions流程 的参数】 | // 把 Transaction::apply 流程中，加入 mTransactionQueue 队列的 TransactionState 出队 | std::vector&lt;TransactionState&gt; transactions = flushTransactions(); | // 这个函数核心就是把 mTransactionQueue 队列的数据转移到一个 vector 中返回 // 中间处理一些还没有处理完的事务。具体代码待研究 |--&gt;SurfaceFlinger::flushTransactions() | std::vector&lt;TransactionState&gt; transactions; | while (!mTransactionQueue.empty())// 【取出setTransactionState流程中入队的所有事务】 | auto&amp; transaction = mTransactionQueue.front(); | // 省略 X 行代码 | transactions.emplace_back(std::move(transaction));// 把事务转入向量集合 vector&lt;TransactionState&gt; transactions | mTransactionQueue.pop_front(); | ATRACE_INT(&quot;TransactionQueue&quot;, mTransactionQueue.size()); | return transactions; | // 【2】、处理以前创建的layer，核心就是把新创建的layer加入到Z轴排序集合体系 mCurrentState.layersSortedByZ 】 | // Android12以前layersSortedByZ不是在这里添加的。或许谷歌以后想仅仅通过事务的接口创建layer？？ | needsTraversal |= commitCreatedLayers(); |--&gt;SurfaceFlinger::commitCreatedLayers() | std::vector&lt;LayerCreatedState&gt; createdLayers; /* mCreatedLayers： 创建layer流程中，通过 SurfaceFlinger::addClientLayer 把layer添加到了 mCreatedLayers 这个vector中 现在开始拿来使用了 */ | createdLayers = std::move(mCreatedLayers); //数据转移到新的对象createdLayers中 | mCreatedLayers.clear();//清除mCreatedLayers所有的数据 | if (createdLayers.size() == 0) | return false; // 如果没有新增的Layer，直接返回，那么 mLayersAdded 就不会被设置为 true | for (const auto&amp; createdLayer : createdLayers) | handleLayerCreatedLocked(createdLayer); |--&gt;SurfaceFlinger::handleLayerCreatedLocked(const LayerCreatedState&amp; state) | sp&lt;Layer&gt; layer = state.layer.promote(); | bool addToRoot = state.addToRoot; | sp&lt;Layer&gt; parent = state.initialParent.promote(); | // 如果没有父layer的话，执行以下代码。 | if (parent == nullptr &amp;&amp; addToRoot) | layer-&gt;setIsAtRoot(true); | //【添加到 mCurrentState.layersSortedByZ 这个以Z轴排序的集合中】 | mCurrentState.layersSortedByZ.add(layer); | else if (parent == nullptr) | layer-&gt;onRemovedFromCurrentState();// Layer删除处理 | else if (parent-&gt;isRemovedFromCurrentState()) | parent-&gt;addChild(layer); | layer-&gt;onRemovedFromCurrentState();// Layer删除处理 | else// TODO: 待验证 parent 为 ContainerLayer， addToRoot=true | parent-&gt;addChild(layer);// BufferStateLayer 应该走这里。添加到 Layer.mCurrentChildren 集合中 | layer-&gt;updateTransformHint(mActiveDisplayTransformHint); | mInterceptor-&gt;saveSurfaceCreation(layer); | // 在之后的流程 commitTransactionsLocked 函数中会设置回 false | mLayersAdded = true; | return true;//如果有新创建的layer，需要执行合成步骤 SurfaceFlinger.composite 函数 | needsTraversal |= applyTransactions(transactions, vsyncId); | // 因图形buffer更新放到事务中来了，所以事务这里重点关注 eBufferChanged | //【3】、applyTransactions流程: 把事务中的对于flag的数据存入Layer.mDrawingState对应的属性 | // 对于Layer删除、调整Z轴，则是把相关数据存入 SurfaceFlinger.mCurrentState.layersSortedByZ | // 对于图形buffer更新而言，核心就是赋值 mDrawingState.buffer |--&gt;SurfaceFlinger::applyTransactions(std::vector&lt;TransactionState&gt;&amp; transactions,int64_t vsyncId) | return applyTransactionsLocked(transactions, vsyncId); |--&gt;SurfaceFlinger::applyTransactionsLocked(std::vector&lt;TransactionState&gt;&amp; transactions, int64_t vsyncId) | bool needsTraversal = false; | // 【遍历步骤1中flushTransactions()返回的 transactions】 | for (auto&amp; transaction : transactions) | needsTraversal |= applyTransactionState(...) |--&gt;SurfaceFlinger::applyTransactionState(..) | uint32_t transactionFlags = 0; | uint32_t clientStateFlags = 0; | // 省略一大堆内容 | clientStateFlags = setClientStateLocked(frameTimelineInfo, state, desiredPresentTime,isAutoTimestamp, postTime, permissions); |--&gt;SurfaceFlinger::setClientStateLocked(const FrameTimelineInfo&amp; frameTimelineInfo,ComposerState&amp; composerState,...) | //省略一大堆内容 | layer_state_t&amp; s = composerState.state; | // BLASTBufferQueue 传递buffer到SF的时候，调用Transaction::setBuffer 添加 eBufferChanged 标记 | if (what &amp; layer_state_t::eBufferChanged) | layer-&gt;setBuffer(buffer, *s.bufferData, postTime, desiredPresentTime, isAutoTimestamp, dequeueBufferTimestamp, frameTimelineInfo) | // 只有 BufferStateLayer 覆写了setBuffer，其他layer使用父类Layer.setBuffer,父类的函数直接返回false |--&gt;BufferStateLayer::setBuffer(std::shared_ptr&lt;renderengine::ExternalTexture&gt;&amp; buffer,const BufferData&amp; bufferData,...) | // 省略一大堆 | // 这里的 mDrawingState 是 Layer 的，和SurfaceFlinger的 mDrawingState 不是一个类 | // 以前 Layer也有一个 mCurrentState 对象，现在没有了 | mDrawingState.frameNumber = frameNumber; | mDrawingState.releaseBufferListener = bufferData.releaseBufferListener; | mDrawingState.buffer = std::move(buffer);//【把buffer给到 mDrawingState.buffer】 | mDrawingState.acquireFence = ... bufferData.acquireFence; | mDrawingState.modified = true; // 表示是否有状态被修改，几乎所有Layer事务都会设置这个变量为true | mFlinger-&gt;mTimeStats-&gt;setPostTime(layerId, mDrawingState.frameNumber, getName().c_str(),mOwnerUid, postTime,...); | mDrawingState.isAutoTimestamp = isAutoTimestamp; | mDrawingState.releaseBufferEndpoint = bufferData.releaseBufferEndpoint; | // 每次vsync事件都会伴随生成一个 vsyncId。TODO:通常情况可能没有 frameTimelineInfo,，没找到赋值过程，待研究 | else if (frameTimelineInfo.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID) | layer-&gt;setFrameTimelineVsyncForBufferlessTransaction(frameTimelineInfo, postTime); | transactionFlags |= clientStateFlags;// 添加 setClientStateLocked 返回的flag | bool needsTraversal = false; | if (transactionFlags &amp; eTraversalNeeded) | transactionFlags = transactionFlags &amp; (~eTraversalNeeded); | needsTraversal = true; | if (transactionFlags) setTransactionFlags(transactionFlags); //如果还有eTraversalNeeded以外的flag，请求vsync | return needsTraversal; | if (mTransactionTracing) | mTransactionTracing-&gt;addCommittedTransactions(transactions, vsyncId); | return needsTraversal;//返回最终的 needsTraversal，这个为true的话，会执行 commitTransactions、composite| // 是否需要执行事务提交。【提交的核心就是把 mCurrentState 赋值给 mDrawingState】| // mCurrentState 保存APP传来的数据，mDrawingState 用于合成| const bool shouldCommit = (getTransactionFlags() &amp; ~eTransactionFlushNeeded) || needsTraversal;| //【4】、commitTransactions()流程：核心是把mCurrentState转移到 mDrawingState| if(shouldCommit) | commitTransactions(); |--&gt;SurfaceFlinger:::commitTransactions() | State drawingState(mDrawingState); | mDebugInTransaction = systemTime(); | modulateVsync(&amp;VsyncModulator::onTransactionCommit); | commitTransactionsLocked(clearTransactionFlags(eTransactionMask)); |--&gt;SurfaceFlinger::commitTransactionsLocked(uint32_t transactionFlags); | // 屏幕的热插拔SurfaceFlinger::onComposerHalHotplug会调用 setTransactionFlags(eDisplayTransactionNeeded)，然后到这里处理 | // TODO:主线程中接收到的热插拔，不会走到这里。这里处理的可能是非主屏的热插拔，待验证。 | const bool displayTransactionNeeded = transactionFlags &amp; eDisplayTransactionNeeded; | // 处理显示器的事务，显示屏幕增删，显示器的尺寸变化 | if (displayTransactionNeeded) | processDisplayChangesLocked(); | processDisplayHotplugEventsLocked(); | mCurrentState.traverse(...) | layer-&gt;updateTransformHint(hintDisplay-&gt;getTransformHint());//更新旋转提示 | if (mLayersAdded) // 在此之前的步骤[2] commitCreatedLayers 中设置的 true | mLayersAdded = false; | mVisibleRegionsDirty = true;//有脏区域，【用于步骤6计算脏区域】 | if (mLayersRemoved)// 处理被移除的Layer | mLayersRemoved = false; | mVisibleRegionsDirty = true; | mDrawingState.traverseInZOrder(...) | Region visibleReg; | visibleReg.set(layer-&gt;getScreenBounds()); | invalidateLayerStack(layer, visibleReg);//更新DisplayDevice中原有的可视脏区 | //把Layer的添加以及删除从Current状态转为Drawing状态 | doCommitTransactions(); |--&gt;SurfaceFlinger::doCommitTransactions() | // 处理以及被移除的layer集合 mLayersPendingRemoval。释放buffer，从layersSortedByZ移除，加入到mOffscreenLayers | for (const auto&amp; l : mLayersPendingRemoval) | l-&gt;latchAndReleaseBuffer(); | mCurrentState.layersSortedByZ.remove(l); | mOffscreenLayers.emplace(l.get()); | mLayersPendingRemoval.clear(); | //【核心步骤】 | mDrawingState = mCurrentState; | mCurrentState.colorMatrixChanged = false; | if (mVisibleRegionsDirty) | for (const auto&amp; rootLayer : mDrawingState.layersSortedByZ) | // 遍历所有的根layer，把所有子Layer的mCurrentChildren赋值给mDrawingChildren | rootLayer-&gt;commitChildList(); | mDrawingChildren = mCurrentChildren; | mDrawingParent = mCurrentParent; | mDebugInTransaction = 0;| // 如果还有待处理的事务，请求下一个SF vsync| if (transactionFlushNeeded()) | setTransactionFlags(eTransactionFlushNeeded);| mustComposite |= shouldCommit;| //【5】、latchBuffers 相当于以前的handlePageFlip 流程| //【如果有新的buffer的layer大于0，并且拿到了buffer，SurfaceFlinger::latchBuffers()函数返回true，执行 SurfaceFlinger::composite 】| mustComposite |= latchBuffers();|--&gt;SurfaceFlinger::latchBuffers() //【详细内容，见 latchBuffers() 章节】 | layer-&gt;latchBuffer(visibleRegions, latchTime, expectedPresentTime) | //父类Layer的 latchBuffer 返回 false, 子类只有 BufferLayer 重载了 latchBuffer |--&gt;BufferLayer.latchBuffer(bool&amp; /*recomputeVisibleRegions*/, nsecs_t /*latchTime*/, nsecs_t /*expectedPresentTime*/) | updateTexImage(recomputeVisibleRegions, latchTime, expectedPresentTime); |--&gt;BufferStateLayer::updateTexImage(bool&amp; /*recomputeVisibleRegions*/, nsecs_t latchTime,nsecs_t /*expectedPresentTime*/)| //【6】、计算边界、脏区域| updateLayerGeometry();|--&gt;SurfaceFlinger::updateLayerGeometry() | if (mVisibleRegionsDirty) //【mVisibleRegionsDirty在有新的Layer增加时设置为 true 】 | /* 调用每个Layer的 computeBounds 方法 计算每个Layer的以下边界： mSourceBounds 应用任何变换之前以及由其父对象裁剪之前的Layer边界。 mBounds Layer空间中的Layer边界。mSourceBounds 和 Layer的裁剪矩形的交集，再和其父空间交集 mScreenBounds Layer在屏幕上的空间。由 mBounds transform转换而来 */ | computeLayerBounds(); |--&gt;SurfaceFlinger::computeLayerBounds() | const FloatRect maxBounds = getMaxDisplayBounds(); | for (const auto&amp; layer : mDrawingState.layersSortedByZ) | layer-&gt;computeBounds(maxBounds, ui::Transform(), 0.f /* shadowRadius */); | // mLayersPendingRefresh 参见步骤[5] latchBuffers() | for (auto&amp; layer : mLayersPendingRefresh)// mLayersPendingRefresh 存储中能拿到 buffer的layer | Region visibleReg; | visibleReg.set(layer-&gt;getScreenBounds()); | // 对每个包含当前layer的显示器的脏区域初始化为 Layer.mScreenBounds | invalidateLayerStack(layer, visibleReg); | // mLayersPendingRefresh这个集合表示有新的buffer更新，并且能拿到buffer的layer。 | // 在 SurfaceFlinger::latchBuffers()流程中添加，此时清空此集合 | mLayersPendingRefresh.clear();| // 非开机阶段，mustComposite==true情况下将执行合成步骤 SurfaceFlinger::composite| return mustComposite &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER); latchBuffers() 因为使用 BufferStateLayer + BBQ ， latchBuffer 流程相比Android12以前逻辑要少很多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596c++复制代码// SurfaceFlinger.mLayersWithQueuedFrames 存储有新buffer的layer// SurfaceFlinger.mLayersPendingRefresh 存储mLayersWithQueuedFrames中能拿到 buffer的layer。用于更新显示设备的脏区域|--&gt;SurfaceFlinger::latchBuffers() | const nsecs_t latchTime = systemTime();// perfetto 会记录这个时间 | bool visibleRegions = false;// 用于 latchBuffer 的参数 | bool newDataLatched = false; | // 【1、核心逻辑是把 有buffer更新的layer存储到set集合 mLayersWithQueuedFrames】 | mDrawingState.traverse(...) | // layer 各种属性变化后都会设置 eTransactionNeeded 这个flag，比如尺寸，背景，位置，inputInfo、刷新率等等，几乎所有的变化都会设置eTransactionNeeded。 | if (layer-&gt;clearTransactionFlags(eTransactionNeeded) || mForceTransactionDisplayChange) | // 赋值 mDrawingState.transform | // mDrawingStateModified = mDrawingState.modified; mDrawingState.modified = false; | const uint32_t flags = layer-&gt;doTransaction(0); | if (flags &amp; Layer::eVisibleRegion) | mVisibleRegionsDirty = true; | // layer有新buffer时，hasReadyFrame() 返回true | if (layer-&gt;hasReadyFrame()) | // shouldPresentNow函数，对于 BufferStateLayer 而言，有buffer的来了，就返回true | if (layer-&gt;shouldPresentNow(expectedPresentTime)) | //【2、把有新buffer的layer，加入set集合 mLayersWithQueuedFrames】 | mLayersWithQueuedFrames.emplace(layer); | mForceTransactionDisplayChange = false; | // 【3、mLayersWithQueuedFrames不为空，则调用集合中每个layer的 latchBuffer 函数】 | if (!mLayersWithQueuedFrames.empty()) | for (const auto&amp; layer : mLayersWithQueuedFrames) | // latchBuffer 判断是否需要重新计算显示区域，由参数visibleRegions带回结果 | //【4、获取buffer，并把 Layer.mDrawingState 中的属性变量转移到 BufferLayer.mBufferInfo 】 | // mBufferInfo 用于 Layer中获取各种buffer信息相关的get方法 | if (layer-&gt;latchBuffer(visibleRegions, latchTime, expectedPresentTime)) |--&gt;BufferLayer::latchBuffer(bool&amp; recomputeVisibleRegions, nsecs_t latchTime, nsecs_t expectedPresentTime) | if (!fenceHasSignaled()) | // 【如果Fence还没有发送信号，请求 SF-vsync，并且函数返回，等一下次的vsync再处理这个buffer】 | mFlinger-&gt;onLayerUpdate(); | return false; | BufferInfo oldBufferInfo = mBufferInfo; | updateTexImage(recomputeVisibleRegions, latchTime, expectedPresentTime); | // BufferStateLayer 和 以前使用的 BufferQueueLayer 是完全不同的步骤。大部分内容是debug用的 |--&gt;BufferStateLayer::updateTexImage(bool&amp; /*recomputeVisibleRegions*/, nsecs_t latchTime, nsecs_t /*expectedPresentTime*/) | const int32_t layerId = getSequence();// sequence，每个layer唯一，是个递增int | //把 acquireFence 存储到 mFlinger-&gt;mTimeStats-&gt;mTimeStatsTracker[layerId].timeRecords[layerRecord.waitData].acquireFence | mFlinger-&gt;mTimeStats-&gt;setAcquireFence(layerId, frameNumber, acquireFence); | mFlinger-&gt;mTimeStats-&gt;setLatchTime(layerId, frameNumber, latchTime); | // perfetto 相应的数据源配置启用的情况下，记录 Fence 和 latchTime | mFlinger-&gt;mFrameTracer-&gt;traceFence(...); | mFlinger-&gt;mFrameTracer-&gt;traceTimestamp(...); | mDrawingStateModified = false;// 修改为false，对应于步骤1中 Layer.doTransaction | updateActiveBuffer(); |--&gt;BufferStateLayer::updateActiveBuffer() | const State&amp; s(getDrawingState()); | //mPendingBufferTransactions-- | // 调用到 latchBuffer 阶段，setBuffer 的事务就算处理完了，待处理的buffer数量计数器 mPendingBufferTransactions要减一 | //这里对应于SurfaceFlinger::setTransactionState函数中：mBufferCountTracker.increment(state.surface-&gt;localBinder()); | // mBufferCountTracker.increment 函数使 mPendingBufferTransactions 自增1 | decrementPendingBufferCount(); | // 把 mDrawingState 中的buffer、acquireFence、frameNumber 转移到 mBufferInfo | mBufferInfo.mBuffer = s.buffer; | mBufferInfo.mFence = s.acquireFence; | mBufferInfo.mFrameNumber = s.frameNumber; | // mCurrentFrameNumber = mDrawingState.frameNumber; mPreviousFrameNumber = mCurrentFrameNumber; | updateFrameNumber(); |--&gt;BufferStateLayer::updateFrameNumber() | mPreviousFrameNumber = mCurrentFrameNumber; | mCurrentFrameNumber = mDrawingState.frameNumber; return NO_ERROR; | // 这个函数就是把 mDrawingState 中buffer相关信息的各种变量转移到 mBufferInfo 中 | // mBufferInfo.mDesiredPresentTime、mFenceTime、mFence、mTransform、mDataspace、mCrop、mScaleMode、mSurfaceDamage | // mHdrMetadata、mApi、mTransformToDisplayInverse、mBufferSlot等等赋值 | gatherBufferInfo(); |--&gt;BufferStateLayer::gatherBufferInfo() | BufferLayer::gatherBufferInfo(); | const State&amp; s(getDrawingState()); | mBufferInfo.mFence = s.acquireFence; | mBufferInfo.mCrop = computeBufferCrop(s); | mBufferInfo.mScaleMode = NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW; | mBufferInfo.mBufferSlot = mHwcSlotGenerator-&gt;getHwcCacheSlot(s.clientCacheId); | //.... | // 后边的代码是判断 是否需要重新计算显示区域 | // 大致情况是：当前是第一个buffer、裁剪区域变化了，旋转变了，缩放变了，宽高变了，透明度变了，mTransformToDisplayInverse变了 | // 以上情况都需要重新计算显示区域 | if(oldBufferInfo.mBuffer == nullptr || mBufferInfo.mCrop != oldBufferInfo.mCrop ....) | | recomputeVisibleRegions = true; | return true; | //【5、如果 latchBuffer 返回true，把layer加入向量集合 mLayersPendingRefresh 】 | // 依据 latchBuffer 逻辑，latchBuffer 返回false，通常是由于 Fence 还没有发送信号。当然还有其他细节原因，这里未贴出代码。 | //【可以说，mLayersPendingRefresh 保存了GPU绘制已经完成的layer】 | mLayersPendingRefresh.push_back(layer); | newDataLatched = true; | // Layer.surfaceDamageRegion = mBufferInfo.mSurfaceDamage; | layer-&gt;useSurfaceDamage(); | //回到 SurfaceFlinger::latchBuffers() 函数 | // latchBuffer 函数，由参数 visibleRegions 返回 是否需要重新计算显示区域 | // 这里把结果添加到 mVisibleRegionsDirty 变量中 | mVisibleRegionsDirty |= visibleRegions; | // 如果有新的buffer的layer大于0，并且 拿到了buffer， | // 那么SurfaceFlinger::latchBuffers()函数返回true，表示需要执行合成步骤 SurfaceFlinger::composite | //【6、如果有新的buffer的layer数量大于0，并且 拿到了buffer，SurfaceFlinger::latchBuffers()函数返回true，执行 SurfaceFlinger::composite 】 | return !mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched; SurfaceFlinger::composite123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234c++复制代码SurfaceFlinger::composite(nsecs_t frameTime, int64_t vsyncId)| // 【1】准备合成的参数 | compositionengine::CompositionRefreshArgs refreshArgs;| /* SmallMap&lt;IBinder, DisplayDevice&gt; mDisplays; 合成是以 mDisplays 元素中的顺序去合成的 内置的显示器，是在开机的时候加入的，因此按照顺序合成的话，内置显示器要优先于 外部显示器 和 虚拟显示器 */ | const auto&amp; displays = FTL_FAKE_GUARD(mStateLock, mDisplays);| // outputs 为Output的vector| refreshArgs.outputs.reserve(displays.size());// 增加容器的大小为显示屏的大小| // 遍历显示设备| for (const auto&amp; [_, display] : displays) | // DisplayDevice.mCompositionDisplay 类型 android::compositionengine::Display，继承 Output | // outputs 代表所有需要合成的显示器 | refreshArgs.outputs.push_back(display-&gt;getCompositionDisplay());//【所有需要合成工作的显示设备】| // 遍历 mDrawingState.layersSortedByZ，这个 layersSortedByZ 存储了所有的的layer| // 以Z轴顺序遍历 mDrawingState.layersSortedByZ ，从底层开始遍历| mDrawingState.traverseInZOrder(...) | // 并非所有种类的layer都能通过 Layer.getCompositionEngineLayerFE() 拿到LayerFE对象。是有显示界面的才有返回对象 | // 父类 Layer.getCompositionEngineLayerFE() 返回 nullptr | // 只有 BufferLayer 和 EffectLayer 实现了这个方法 | // getCompositionEngineLayerFE 这个函数就是返回layer自身，并强转为Layer父类 compositionengine::LayerFE 类型 | if (auto layerFE = layer-&gt;getCompositionEngineLayerFE()) | // refreshArgs.layers 是 std::vector&lt;sp&lt;compositionengine::LayerFE&gt;&gt; 类型 | // 这个是以 Z 轴顺序添加到 layers 中的 | refreshArgs.layers.push_back(layerFE);//【添加所有参与合成的layer】| // mLayersWithQueuedFrames 是有新的帧数据的Layer| // 把有帧数据的Layer转移到 refreshArgs.layersWithQueuedFrames| refreshArgs.layersWithQueuedFrames.reserve(mLayersWithQueuedFrames.size());| mCompositionEngine-&gt;present(refreshArgs);| for (auto layer : mLayersWithQueuedFrames) | if (auto layerFE = layer-&gt;getCompositionEngineLayerFE()) | refreshArgs.layersWithQueuedFrames.push_back(layerFE);| // 把准备好的合成的参数，传入 CompositionEngine 开始合成工作| mCompositionEngine-&gt;present(refreshArgs);|--&gt;CompositionEngine::present(CompositionRefreshArgs&amp; args) | // 【2】如果存在新的buffer处理，mNeedsAnotherUpdate设置为true， | preComposition(args); | // LayerFESet 是 unordered_set 类型 | LayerFESet latchedLayers; // using LayerFESet = std::unordered_set&lt;sp&lt;LayerFE&gt;, LayerFESpHash&gt;; | // 【3】遍历所有需要合成输出的显示设备 【核心是把显示区域相关数据转存到 OutputLayer 的mState对象】 | for (const auto&amp; output : args.outputs)// 第一层循环，遍历所有的显示设备 | // 调用每个显示设备的 prepare 方法 | output-&gt;prepare(args, latchedLayers); |--&gt;Output::prepare(const compositionengine::CompositionRefreshArgs&amp; refreshArgs, LayerFESet&amp; geomSnapshots) | rebuildLayerStacks(refreshArgs, geomSnapshots); |--&gt;Output::rebuildLayerStacks(const compositionengine::CompositionRefreshArgs&amp; refreshArgs, LayerFESet&amp; layerFESet) | auto&amp; outputState = editState();// editState() 返回 OutputCompositionState 类型的 Output.mState; | compositionengine::Output::CoverageState coverage&#123;layerFESet&#125;; | // 1、从顶层到底层遍历所有参与合成的Layer，累积计算 覆盖区域、完全不透明区域、脏区域 | // 2、存储当前层的显示区域、排除透明区域的显示区域、被覆盖区域、显示器空间显示区域、阴影区域等到 当前显示设备上的OutputLayer的mState对象 | collectVisibleLayers(refreshArgs, coverage); |--&gt;Output::collectVisibleLayers(CompositionRefreshArgs&amp; refreshArgs,Output::CoverageState&amp; coverage) | // 从顶层到底层开始遍历所有Layer，以便于计算哪些可以显示。 这个过程中，每层的显示区域是不断减少的，相反，覆盖区域是不断增大的 | for (auto layer : reversed(refreshArgs.layers)) | // 1、从顶层到底层遍历所有参与合成的Layer，累积计算 覆盖区域、完全不透明区域、脏区域 | // 2、【如果显示设备没有对应的 OutputLayer，创建 OutputLayer 同时创建 HWCLayer，并作为 OutputLayer.mState 的成员】 | // 3、存储当前层的显示区域、排除透明区域的显示区域、被覆盖区域、显示器空间显示区域、阴影区域等到 当前显示设备上的 OutputLayer 的mState对象 | //OutputLayer.mState.visibleRegion、visibleNonTransparentRegion、coveredRegion、outputSpaceVisibleRegion、shadowRegion | //outputSpaceBlockingRegionHint | // 4、Output.mPendingOutputLayersOrderedByZ.emplace_back(std::move(outputLayer)); | ensureOutputLayerIfVisible(layer, coverage); | // setReleasedLayers 函数会遍历 Output.mCurrentOutputLayersOrderedByZ | // 此时 Output.mCurrentOutputLayersOrderedByZ 中会在当前vsync显示的layer都转移到了mPendingOutputLayersOrderedByZ | // 这里会把mCurrentOutputLayersOrderedByZ余下的Layer中，在当前vsync，入队新的buffer的layer放入到 Output.mReleasedLayers 中 | // 就是说，mReleasedLayers是一些即将移除的的layer，但是当前vsync还在生产帧数据的layer | setReleasedLayers(refreshArgs); | // 把 Output.mPendingOutputLayersOrderedByZ 转到 Output.mCurrentOutputLayersOrderedByZ //使用的move赋值 | // 【每个vsync内，Output中存储的OutputLayer，都是最新即将要显示的Layer】 | finalizePendingOutputLayers(); | const ui::Transform&amp; tr = outputState.transform; | Region undefinedRegion&#123;outputState.displaySpace.getBoundsAsRect()&#125;; | // 整个显示空间 减去 所有Layer的不透明覆盖区域 为未定义的区域 | undefinedRegion.subtractSelf(tr.transform(coverage.aboveOpaqueLayers)); | outputState.undefinedRegion = undefinedRegion; | // 把计算好的脏区域传入 outputState.dirtyRegion // Output::postFramebuffer() 中被清空 | outputState.dirtyRegion.orSelf(coverage.dirtyRegion); | // 【4】把状态属性转移到 BufferLayer.mCompositionState。这个对象是 compositionengine::LayerFECompositionState 类型 | // 可以通过 LayerFE.getCompositionState() 获取合成状态对象。不算EffectLayer的话，其实就是就是获取 BufferLayer.mCompositionState | updateLayerStateFromFE(args); |--&gt;CompositionEngine::updateLayerStateFromFE(CompositionRefreshArgs&amp; args) | // 从前端layer中更新合成状态 | for (const auto&amp; output : args.outputs) | output-&gt;updateLayerStateFromFE(args); |--&gt;Output::updateLayerStateFromFE(const CompositionRefreshArgs&amp; args) | // SurfaceFlinger.mVisibleRegionsDirty 为true时， args.updatingGeometryThisFrame=true | // 有新的Layer增加时 mVisibleRegionsDirty 为true | layer-&gt;getLayerFE().prepareCompositionState(args.updatingGeometryThisFrame ? LayerFE::StateSubset::GeometryAndContent : LayerFE::StateSubset::Content); |--&gt;Layer::prepareCompositionState(compositionengine::LayerFE::StateSubset subset) | // 根据 StateSubset 的类型选择以下函数的几种组合去执行 | /* prepareBasicGeometry更新BufferLayer状态对象LayerFECompositionState(mCompositionState)的以下属性: outputFilter、isVisible、isOpaque、shadowRadius、contentDirty、geomLayerBounds、geomLayerTransform、 geomInverseLayerTransform、transparentRegionHint、blendMode、alpha、backgroundBlurRadius、blurRegions、stretchEffect 同时设置 Layer.contentDirty = false;*/ | prepareBasicGeometryCompositionState(); /*更新BufferLayer状态对象mCompositionState的以下属性: geomBufferSize、geomContentCrop、geomCrop、geomBufferTransform、 geomBufferUsesDisplayInverseTransform|geomUsesSourceCrop、isSecure、metadata 就是集合图形相关的属性*/ | prepareGeometryCompositionState(); /* preparePerFrameCompositionState更新BufferLayer状态对象mCompositionState的以下属性: compositionType、hdrMetadata、compositionType、buffer、bufferSlot、acquireFence、frameNumber、sidebandStreamHasFrame forceClientComposition、isColorspaceAgnostic、dataspace、colorTransform、colorTransformIsIdentity、surfaceDamage hasProtectedContent、dimmingEnabled、isOpaque、stretchEffect、blurRegions、backgroundBlurRadius、fps 就是帧数据相关的属性*/ | preparePerFrameCompositionState(); | | // 调用每个显示设备的 present 方法 | for (const auto&amp; output : args.outputs) | output-&gt;present(args); |--&gt;Output::present(const compositionengine::CompositionRefreshArgs&amp; refreshArgs) | // 2.4.1 更新Output合成状态对象OutputCompositionState | // Output.mState的 colorMode、dataspace、renderIntent、targetDataspace 属性 | updateColorProfile(refreshArgs); | // 2.4.2 更新 OutputLayer.mState.forceClientComposition、displayFrame、sourceCrop、bufferTransform、dataspace | // 【显示区域相关属性已经在rebuildLayerStacks阶段更新完成，至此OutputLayer.mState的属性基本全更新完了】 | updateCompositionState(refreshArgs); |--&gt;Output::updateCompositionState(const compositionengine::CompositionRefreshArgs&amp; refreshArgs) | // 查找最顶层使用背景模糊的 OutputLayer | mLayerRequestingBackgroundBlur = findLayerRequestingBackgroundComposition(); | // 如果有 OutputLayer 使用了背景模糊，则必须使用 GPU 合成 | bool forceClientComposition = mLayerRequestingBackgroundBlur != nullptr; | for (auto* layer : getOutputLayersOrderedByZ()) | /* 更新每个OutputLayer OutputLayerState 的以下属性 | forceClientComposition、displayFrame、sourceCrop、bufferTransform、bufferTransform、dataspace */ | layer-&gt;updateCompositionState(refreshArgs.updatingGeometryThisFrame,refreshArgs.devOptForceClientComposition || | forceClientComposition, refreshArgs.internalDisplayRotationFlags) | // 到最顶层使用背景模糊的 OutputLayer 之前都强制使用 GPU 合成 | if (mLayerRequestingBackgroundBlur == layer) | | forceClientComposition = false; | // 2.4.3 | planComposition(); |--&gt;Output::planComposition() | // 需要 ro.surface_flinger.enable_layer_caching 这个属性为true，mLayerCachingEnabled=true，然后才会启用 Planner | // Planner 似乎还未启用，目前查几台机器都未启用 | if (!mPlanner || !getState().isEnabled) | return; | // 把Layer扁平化到数据结构 compositionengine::impl::OutputLayerCompositionState.overrideInfo | // 缓存layer，扁平化到override中，下次再用其中的数据。TODO：似乎还未启用，暂时忽略 | mPlanner-&gt;plan(getOutputLayersOrderedByZ()); | // 2.4.4 把状态属性写入HWC待执行的缓存，等待执行 | writeCompositionState(refreshArgs); |--&gt;Output::writeCompositionState(const compositionengine::CompositionRefreshArgs&amp; refreshArgs) | // 遍历当前显示器的 OutputLayer | for (auto* layer : getOutputLayersOrderedByZ()) | // 前边一大段是 透视图层 的处理 | // 如果上一个Layer的buffer和当前的Layer的buffer一样，那么忽略当前Layer | // 下面直接看主逻辑 | layer-&gt;writeStateToHWC(includeGeometry, skipLayer, z++, overrideZ, isPeekingThrough); |--&gt;OutputLayer::writeStateToHWC(bool includeGeometry, bool skipLayer, uint32_t z,bool zIsOverridden, bool isPeekingThrough) | const auto&amp; state = getState(); | if (!state.hwc) return; //如果没有HWC接口，直接返回 | auto&amp; hwcLayer = (*state.hwc).hwcLayer; | if (!hwcLayer) return; // 如果没有 hwcLayer 直接返回 | // 获取 Layer 的 LayerFECompositionState ，只有 BufferLayer和 EffectLayer 有 | const auto* outputIndependentState = getLayerFE().getCompositionState(); | if (!outputIndependentState) return; | // 合成类型 | auto requestedCompositionType = outputIndependentState-&gt;compositionType; | // 有忽略的layer，新增的layer | if (... skipLayer || includeGeometry) | // 写入HWC依赖显示设备的几何图形信息 | // HWC2::Layer.setDisplayFrame、setSourceCrop、setZOrder、setTransform | writeOutputDependentGeometryStateToHWC(hwcLayer.get(), requestedCompositionType, z); | // 写入HWC不依赖显示设备的几何图形信息 | // HWC2::Layer.setBlendMode、setPlaneAlpha、setLayerGenericMetadata | // skipLayer 为true的话，alpha=0.0f 颜色设置为完全透明 | writeOutputIndependentGeometryStateToHWC(hwcLayer.get(), *outputIndependentState, skipLayer); | // 写入HWC依赖显示设备的每个帧状态 | // HWC2::Layer.etVisibleRegion、setBlockingRegion、setDataspace、setBrightness | writeOutputDependentPerFrameStateToHWC(hwcLayer.get()); | // 写入HWC不依赖显示设备的每帧状态 | // HWC2::Layer.setColorTransform、setSurfaceDamage、setPerFrameMetadata、setBuffer | writeOutputIndependentPerFrameStateToHWC(hwcLayer.get(), *outputIndependentState, requestedCompositionType, skipLayer); | // 写入合成类型 HWC2::Layer.setCompositionType | writeCompositionTypeToHWC(hwcLayer.get(), requestedCompositionType, isPeekingThrough, skipLayer); | // 2.4.5 设置显示设备的颜色矩阵，做颜色变换，色盲、护眼模式等 | setColorTransform(refreshArgs); | // 2.4.6 给虚拟显示屏用的。正常主屏使用 FramebufferSurface ，啥事也不做 | beginFrame(); | GpuCompositionResult result; | // 是否可以预测合成策略--Android 13 新增 | // 去掉一些小概率原因，总结：如果上次不全是硬件合成，且存在GPU合成Layer时，返回true | const bool predictCompositionStrategy = canPredictCompositionStrategy(refreshArgs); | if (predictCompositionStrategy) | // 异步执行 chooseCompositionStrategy --Android 13 新增 | // 就是 chooseCompositionStrategy 和 GPU合成 并行执行。用以节约时间 | result = prepareFrameAsync(refreshArgs); | else | //核心逻辑还是确认使用 客户端合成 还是 使用硬件合成 | prepareFrame();//【转“Output::prepareFrame()”章节】 |--&gt;Output::prepareFrame()// 详情参见：prepareFrame() 章节 | auto&amp; outputState = editState(); | std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt; changes; | bool success = chooseCompositionStrategy(&amp;changes);//选择合成策略 | resetCompositionStrategy();// 重置合成策略的变量 | outputState.previousDeviceRequestedChanges = changes; | outputState.previousDeviceRequestedSuccess = success; | if (success) | applyCompositionStrategy(changes);//应用合成策略 | finishPrepareFrame();// 用于虚拟屏 | //继续 Output::present(const compositionengine::CompositionRefreshArgs&amp; refreshArgs) | devOptRepaintFlash(refreshArgs);// doDebugFlashRegions当打开开发者选项中的“显示Surface刷新”时，额外为产生变化的图层绘制闪烁动画 | // GPU 合成，新增了一些对 prepareFrameAsync 结果的处理逻辑 | finishFrame(refreshArgs, std::move(result));//【转“Output::finishFrame”章节】 | //【转“Output::postFramebuffer()”】 | postFramebuffer();// postFramebuffer 函数就是告诉HWC开始做最后的合成了,并显示。获取释放fence， | // 渲染最新的 cached sets，需要开启了Planner。TODO：渲染设置了预期显示时间的buffer？ | renderCachedSets(refreshArgs);| postFrame();// 没啥东西输出log| postComposition();// 杂七杂八的合成后处理，对于 BufferStateLayer 最终要的是 releasePendingBuffer|--&gt;SurfaceFlinger::postComposition() | // 省略一大段内容 | for (const auto&amp; layer: mLayersWithQueuedFrames) | // 都是更新 FrameTracker、TimeStats 这些 | layer-&gt;onPostComposition(display, glCompositionDoneFenceTime,mPreviousPresentFences[0].fenceTime, compositorTiming); | layer-&gt;releasePendingBuffer(/*dequeueReadyTime*/ now); |--&gt;BufferStateLayer::releasePendingBuffer(nsecs_t dequeueReadyTime) | for (auto&amp; handle : mDrawingState.callbackHandles) | if (handle-&gt;releasePreviousBuffer &amp;&amp; mDrawingState.releaseBufferEndpoint == handle-&gt;listener) | // 这个 mPreviousReleaseCallbackId 在 BufferStateLayer::updateActiveBuffer() 赋值 | // mPreviousReleaseCallbackId = &#123;getCurrentBufferId(), mBufferInfo.mFrameNumber&#125;; | handle-&gt;previousReleaseCallbackId = mPreviousReleaseCallbackId; | break; | // 把 callback 加入 TransactionCallbackInvoker::mCompletedTransactions | mFlinger-&gt;getTransactionCallbackInvoker().addCallbackHandles(mDrawingState.callbackHandles, jankData); | //【这里就是通过binder通信，回调到 APP 端BBQ执行 releaseBuffer 了】 | mTransactionCallbackInvoker.sendCallbacks(false /* onCommitOnly */); |--&gt;BpTransactionCompletedListener::onTransactionCompleted(android::ListenerStats)| // 如果还有新的buffer，需要请求新的vsync| if (mCompositionEngine-&gt;needsAnotherUpdate()) | scheduleCommit(FrameHint::kNone) Output::prepareFrame() 所谓 Client 合成，就是 HWC 的客户端 SurfaceFlinger 去合成，SurfaceFlinger 合成的话使用GPU合成，因此 Client 合成，即GPU合成 prepareFrame 核心逻辑是确认使用 客户端合成 还是 使用硬件合成 prepareFrame 函数中同 HWC服务 交互去确认是否有客户端合成，如果没有客户端合成，并可以忽略验证，那么会直接显示。流程到这里基本结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136c++复制代码CompositionEngine::present(CompositionRefreshArgs&amp; args)| //....|--&gt;Output::prepareFrame()| auto&amp; outputState = editState();| std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt; changes;| bool success = chooseCompositionStrategy(&amp;changes);|--&gt;Display::chooseCompositionStrategy(std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt;* outChanges) | // 在最近的一次合成中如果有任意一个layer是 GPU 合成，则返回true | const bool requiresClientComposition = anyLayersRequireClientComposition(); | status_t result = hwc.getDeviceCompositionChanges(*halDisplayId, requiresClientComposition,...outChanges); |--&gt;HWComposer::getDeviceCompositionChanges(HalDisplayId displayId, bool frameUsesClientComposition,...outChanges) | // 如果有需要GPU合成的layer， canSkipValidate=false; | // 没有需要GPU合成的layer，如果Composer支持获得预期的展示时间，canSkipValidate=true; | // 没有需要GPU合成的layer，Composer 也不支持获得预期的当前时间，只有当我们知道我们不会提前呈现时，我们才能跳过验证。 | const bool canSkipValidate = &#123;...&#125;; | if (canSkipValidate) | sp&lt;Fence&gt; outPresentFence; | uint32_t state = UINT32_MAX; | //如果可以跳过验证，则直接在屏幕上显示内容,否则执行 validate(HWC 检查各个图层的状态，并确定如何进行合成) | // numTypes返回合成类型需要变更的layer数量，numRequests 返回需要做getDisplayRequests请求的layer数量 | hwcDisplay-&gt;presentOrValidate(expectedPresentTime, &amp;numTypes, &amp;numRequests, &amp;outPresentFence, &amp;state); | if (state == 1) | // 跳过了验证环节，直接显示了。这时直接返回 | std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences; | hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);// 显示成功，会返回 Fence fd | displayData.releaseFences = std::move(releaseFences); | displayData.lastPresentFence = outPresentFence; | displayData.validateWasSkipped = true; | displayData.presentError = error; | return NO_ERROR; | else | // HWC 检查各个图层的状态，并确定如何进行合成 | // numTypes返回合成类型需要变更的layer数量，numRequests 返回需要做getDisplayRequests请求的layer数量 | hwcDisplay-&gt;validate(expectedPresentTime, &amp;numTypes, &amp;numRequests); | // composer3::Composition 为枚举类型： | //&#123; INVALID = 0, CLIENT = 1, DEVICE = 2, SOLID_COLOR = 3, CURSOR = 4, SIDEBAND = 5, DISPLAY_DECORATION = 6,&#125;; | std::unordered_map&lt;HWC2::Layer*, composer3::Composition&gt; changedTypes; | changedTypes.reserve(numTypes);// map扩容为numTypes | // changedTypes 返回 map&lt;Layer，Composition&gt; 包含所有 与上次调用validateDisplay之前设置的合成类型不同的合成类型的Layer | hwcDisplay-&gt;getChangedCompositionTypes(&amp;changedTypes); | // 枚举 hal::DisplayRequest&#123;FLIP_CLIENT_TARGET = 1u , WRITE_CLIENT_TARGET_TO_OUTPUT = 2u ,&#125; | // 0 表示：指示客户端提供新的客户端目标缓冲区，即使没有为客户端合成标记任何layers。 | // 1 表示：指示客户端将客户端合成的结果直接写入虚拟显示输出缓冲区。 | auto displayRequests = static_cast&lt;hal::DisplayRequest&gt;(0); | // 枚举 hal::LayerRequest&#123;CLEAR_CLIENT_TARGET = 1 &lt;&lt; 0, &#125; | // 1表示：客户端必须在该layer所在的位置使用透明像素清除其目标。如果必须混合该层，客户端可能会忽略此请求。 | std::unordered_map&lt;HWC2::Layer*, hal::LayerRequest&gt; layerRequests; | layerRequests.reserve(numRequests); // map扩容为 numRequests | // 返回 hal::DisplayRequest 和 每个Layer的 hal::LayerRequest 类型，用于指导 SurfaceFlinger 的GPU合成 | hwcDisplay-&gt;getRequests(&amp;displayRequests, &amp;layerRequests); | // 返回client target属性，这个新增的，目前可能仅仅实现了亮度、调光、数据格式、数据空间相关属性 | DeviceRequestedChanges::ClientTargetProperty clientTargetProperty; | hwcDisplay-&gt;getClientTargetProperty(&amp;clientTargetProperty); | // 组合成 DeviceRequestedChanges 结构体，返回 | outChanges-&gt;emplace(DeviceRequestedChanges&#123;std::move(changedTypes), std::move(displayRequests), std::move(layerRequests), std::move(clientTargetProperty)&#125;); | // 注释这么说的：此函数相当于从getChangedCompositionTypes请求更改后的类型，在相应的层上设置这些类型，然后再次调用validateDisplay。 | // 但是，看源码感觉注释说的不大对，这里仅仅是把这个成员设为true： DisplayCommand::acceptDisplayChanges = true | // 注释说的应该是命令缓存发送到HWC后，执行的流程 | hwcDisplay-&gt;acceptChanges(); | //只有正常执行会返回 true，其他，显示设备未连接、没有硬件合成、getDeviceCompositionChanges返回false，那么会 return false; | return true; | resetCompositionStrategy();|--&gt;Output::resetCompositionStrategy() | auto&amp; outputState = editState(); | // 先重置这些变量，在后续的流程中会使用。相当于设置默认值，因为对基本的Output实现只能进行客户端合成 | outputState.usesClientComposition = true; | outputState.usesDeviceComposition = false; | outputState.reusedClientComposition = false;| // 这个previousDeviceRequestedChanges变量在 Output::canPredictCompositionStrategy 函数中用来判断是否预测合成策略| outputState.previousDeviceRequestedChanges = changes;| outputState.previousDeviceRequestedSuccess = success;| if (success)// HWComposer::getDeviceCompositionChanges 执行错误，不会进入到这里。比如IComposer任意一接口调用失败 | applyCompositionStrategy(changes); |--&gt;Display::applyCompositionStrategy(const std::optional&lt;DeviceRequestedChanges&gt;&amp; changes) | if (changes) | // 对每个 OutputLayer 应用HWC设备要求的合成类型更改 | applyChangedTypesToLayers(changes-&gt;changedTypes); |--&gt;Display::applyChangedTypesToLayers(const ChangedTypes&amp; changedTypes) | for (auto* layer : getOutputLayersOrderedByZ()) | auto hwcLayer = layer-&gt;getHwcLayer();// 获取 OutputLayer中存储的 HWC::Layer | auto it = changedTypes.find(hwcLayer); | if (it == changedTypes.end()) continue; | layer-&gt;applyDeviceCompositionTypeChange( static_cast&lt;aidl::android::hardware::graphics::composer3::Composition&gt;(it-&gt;second)); | // 应用HWC设备要求的合成类型更改 |--&gt;OutputLayer::applyDeviceCompositionTypeChange(Composition compositionType) | auto&amp; state = editState(); | auto&amp; hwcState = *state.hwc; | // 这个 OutputLayerCompositionState::Hwc.hwcCompositionType 用于预测合成策略 Output::canPredictCompositionStrategy | hwcState.hwcCompositionType = compositionType;//这个代表最近使用的合成类型 | applyDisplayRequests(changes-&gt;displayRequests); |--&gt;Display::applyDisplayRequests(const DisplayRequests&amp; displayRequests) | auto&amp; state = editState(); | // 如果 displayRequests 包含flag FLIP_CLIENT_TARGET，则 flipClientTarget=true | // 如果为true，则在执行客户端合成时应提供新的客户端目标(client target)缓冲区 | state.flipClientTarget = (static_cast&lt;uint32_t&gt;(displayRequests) &amp; static_cast&lt;uint32_t&gt;(hal::DisplayRequest::FLIP_CLIENT_TARGET)) != 0; | applyLayerRequestsToLayers(changes-&gt;layerRequests); |--&gt;Display::applyLayerRequestsToLayers(const LayerRequests&amp; layerRequests) | for (auto* layer : getOutputLayersOrderedByZ()) | // OutputLayer.editState().clearClientTarget = false; | layer-&gt;prepareForDeviceLayerRequests(); | auto hwcLayer = layer-&gt;getHwcLayer(); | if (auto it = layerRequests.find(hwcLayer); it != layerRequests.end()) | // 应用HWC的layer请求 | layer-&gt;applyDeviceLayerRequest(static_cast&lt;Hwc2::IComposerClient::LayerRequest&gt;(it-&gt;second)); |--&gt;OutputLayer::applyDeviceLayerRequest(hal::LayerRequest request) | if(request== hal::LayerRequest::CLEAR_CLIENT_TARGET:) | // 客户端合成时，该layer所在的位置使用透明像素清除其目标 | editState().clearClientTarget = true; | applyClientTargetRequests(changes-&gt;clientTargetProperty); |--&gt;Display::applyClientTargetRequests(const ClientTargetProperty&amp; clientTargetProperty) | editState().dataspace = static_cast&lt;ui::Dataspace&gt;(clientTargetProperty.clientTargetProperty.dataspace); | editState().clientTargetBrightness = clientTargetProperty.brightness; | editState().clientTargetDimmingStage = clientTargetProperty.dimmingStage; | getRenderSurface()-&gt;setBufferDataspace(editState().dataspace); | getRenderSurface()-&gt;setBufferPixelFormat(static_cast&lt;ui::PixelFormat&gt;(clientTargetProperty.clientTargetProperty.pixelFormat)); | auto&amp; state = editState(); | // anyLayersRequireClientComposition: | // Output 中有任意一个 OutputLayer 状态对象的 hwc-&gt;hwcCompositionType 为 Composition::CLIENT，则返回true | // 就是 OutputLayer.getState().hwc-&gt;hwcCompositionType == Composition::CLIENT | // 即，当前显示设备中有任意一个Layer的合成为 客户端合成，则 Output.getState().usesClientComposition = true; | state.usesClientComposition = anyLayersRequireClientComposition();// true表示有使用客户端合成 | // 当前显示设备的当前帧中，不是全部使用了客户端合成，则 usesDeviceComposition = true; | // 表示当前显示设备的当前帧可能完使用硬件合成，也可能是两者都有 | state.usesDeviceComposition = !allLayersRequireClientComposition();// true表示有使用硬件合成 | // 以上两个变量将用于接下来的 Output::finishPrepareFrame()流程，虚拟屏的prepareFrame方法 和 finishFrame 流程| finishPrepareFrame();| // 用于虚拟屏|--&gt;Output::finishPrepareFrame() | const auto&amp; state = getState(); | if (mPlanner) | mPlanner-&gt;reportFinalPlan(getOutputLayersOrderedByZ()); | // 准备帧进行渲染----这里只有 虚拟屏幕 实现了prepareFrame，其他什么也不做 | mRenderSurface-&gt;prepareFrame(state.usesClientComposition, state.usesDeviceComposition); Output::finishFrame 处理Client合成(GPU合成) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061c++复制代码Output::present(const compositionengine::CompositionRefreshArgs&amp; refreshArgs)//...finishFrame(refreshArgs, std::move(result));// GPU 合成// result 为 prepareFrameAsync 的执行结果|--&gt;Output::finishFrame(const CompositionRefreshArgs&amp; refreshArgs, GpuCompositionResult&amp;&amp; result) | const auto&amp; outputState = getState(); /* outputState.strategyPrediction 走 prepareFrame() 为 DISABLED，表示不使用预测合成策略 走 prepareFrameAsync() 为 SUCCESS 或者 FAIL 表示合预测成功或者失败 */ | if (outputState.strategyPrediction == CompositionStrategyPredictionState::SUCCESS) | //如果预测成功，则已经执行完 GPU 合成了，不必再dequeueRenderBuffer了 | optReadyFence = std::move(result.fence); | else // prepareFrameAsync 中预测失败了 | // 虽然预测失败了，但是已经dequeued的buffer，会通过GpuCompositionResult传送过来，拿来复用 | if (result.bufferAvailable()) | buffer = std::move(result.buffer); | bufferFence = std::move(result.fence); | else // dequeueRenderBuffer失败，连dequeued的buffer都没有，那就重走一遍 prepareFrameAsync GPU 合成的那块逻辑。当然，也可能就没有执行 prepareFrameAsync | // BufferQueue熟悉的配方 dequeueBuffer | dequeueRenderBuffer(&amp;bufferFence, &amp;buffer)) |--&gt;Output::dequeueRenderBuffer(unique_fd* bufferFence, std::shared_ptr&lt;ExternalTexture&gt;* tex) | const auto&amp; outputState = getState(); | // 有使用客户端合成 或者 设置了 flipClientTarget 都需要进行 GPU 合成 | if (outputState.usesClientComposition || outputState.flipClientTarget) | //【dequeueBuffer，然后把dequeue的Buffer包装为 ExternalTexture】 | *tex = mRenderSurface-&gt;dequeueBuffer(bufferFence); |--&gt;RenderSurface::dequeueBuffer(base::unique_fd* bufferFence) | int fd = -1; | ANativeWindowBuffer* buffer = nullptr; | // 调用 Surface.dequeueBuffer | mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buffer, &amp;fd); | // GraphicBuffer 继承 ANativeWindowBuffer | // GraphicBuffer::from 把父类ANativeWindowBuffer强制转换为子类 GraphicBuffer | sp&lt;GraphicBuffer&gt; newBuffer = GraphicBuffer::from(buffer); | // ExternalTexture 使用 RenderEngine 代表客户端管理GPU图像资源。 | // 渲染引擎不是GLES的话，在 ExternalTexture 构造函数中把GraphicBuffer映射到RenderEngine所需的GPU资源中。 | mTexture = new ExternalTexture(newBuffer,mCompositionEngine.getRenderEngine(),WRITEABLE) | *bufferFence = base::unique_fd(fd);//返回fence fd | return mTexture;// 返回纹理类 | // 执行GPU合成 | optReadyFence = composeSurfaces(Region::INVALID_REGION, refreshArgs, buffer, bufferFence); | // BufferQueue熟悉的配方 queueBuffer | mRenderSurface-&gt;queueBuffer(std::move(*optReadyFence)); |--&gt;RenderSurface::queueBuffer(base::unique_fd readyFence) | // 调用 Surface.queueBuffer | mNativeWindow-&gt;queueBuffer(mNativeWindow.get(),mTexture-&gt;getBuffer()-&gt;getNativeBuffer(),dup(readyFence)); | // mDisplaySurface: | // 对于非虚拟屏是 FramebufferSurface，其包装消费者、继承 DisplaySurface；对于虚拟屏是 VirtualDisplaySurface | mDisplaySurface-&gt;advanceFrame(); |--&gt;FramebufferSurface::advanceFrame()//就是调用 FramebufferSurface::nextBuffer | uint32_t slot = 0; | sp&lt;GraphicBuffer&gt; buf; | sp&lt;Fence&gt; acquireFence(Fence::NO_FENCE); | Dataspace dataspace = Dataspace::UNKNOWN; | nextBuffer(slot, buf, acquireFence, dataspace); | // 这里核心是调用 setClientTarget ，把 客户端合成输出的缓冲区句柄 传递给 HWC。 | // 当然，目前还未真正传递到HWC，只是写到命令缓冲区。需要等待执行 present 才执行传递 |--&gt;FramebufferSurface::nextBuffer(uint32_t&amp; outSlot,sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence,Dataspace&amp; outDataspace) | mHwc.setClientTarget(mDisplayId, outSlot, outFence, outBuffer, outDataspace); Output::postFramebuffer() 送显 + 获取 Layer releaseFence 这个 releaseFence 并不是当前送显的fence，是上一帧的 Layer releaseFence 会合并 GPU合成的fence 就是说APP dequeuebuffer拿到新buffer后，需要等待GPU合成完成 + HWC使用当前Layer buffer替换上一个buffer(app dequque的buffer)后，才能在这个新buffer上填充数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152c++复制代码//先看下结构体 FrameFences/* struct FrameFences &#123; // 这个fence，在当前帧在屏幕上显现，或者发送到面板内存时，会发送信号 sp&lt;Fence&gt; presentFence&#123;Fence::NO_FENCE&#125;; // GPU 合成的buffer的消费者 acquire fence；代表GPU合成是否完成；(注：GPU绘制的acquire fence，在latchBuffer阶段已经判断了。) sp&lt;Fence&gt; clientTargetAcquireFence&#123;Fence::NO_FENCE&#125;; // 所有Layer的fence；在先前呈现的buffer被读取完成后发送信息；HWC生成 std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; layerFences; &#125;;*/Output::postFramebuffer()| auto frame = presentAndGetFrameFences();|--&gt;Display::presentAndGetFrameFences() | // 【1】这里就是赋值 FrameFences.clientTargetAcquireFence | auto fences = impl::Output::presentAndGetFrameFences(); |--&gt;Output::presentAndGetFrameFences() | if (getState().usesClientComposition) | result.clientTargetAcquireFence = mRenderSurface-&gt;getClientTargetAcquireFence(); | // 1、【在屏幕上呈现当前显示内容（如果是虚拟显示，则显示到输出缓冲区中）】 | // 2、获取device上所有layer的 ReleaseFence | hwc.presentAndGetReleaseFences(*halDisplayIdOpt, getState().earliestPresentTime, getState().previousPresentFence); | // getPresentFence返回 HWComposer.mDisplayData.at(displayId).lastPresentFence; | // 这个fence，在当前帧在屏幕上显现，或者发送到面板内存时，会发送信号 | // 【2】赋值 FrameFences.presentFence | fences.presentFence = hwc.getPresentFence(*halDisplayIdOpt); | for (const auto* layer : getOutputLayersOrderedByZ()) | auto hwcLayer = layer-&gt;getHwcLayer(); | // 从HWC显示设备上所有Layer的fence | // 【3】赋值 FrameFences.layerFences | fences.layerFences.emplace(hwcLayer, hwc.getLayerReleaseFence(*halDisplayIdOpt, hwcLayer));| // 释放GPU合成使用的buffer| mRenderSurface-&gt;onPresentDisplayCompleted();| for (auto* layer : getOutputLayersOrderedByZ()) | sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE; | // 获取HWC每个layer的releaseFence | if (auto hwcLayer = layer-&gt;getHwcLayer()) | if (auto f = frame.layerFences.find(hwcLayer); f != frame.layerFences.end()) | releaseFence = f-&gt;second; | // 如果有客户端合成，merge GPUbuffer的fence | if (outputState.usesClientComposition) | releaseFence = Fence::merge(&quot;LayerRelease&quot;, releaseFence, frame.clientTargetAcquireFence); | //同步Fence到Layer中 | // 如果是 BufferQueueLayer 设置 mSlots[slot].mFence; | // 如果是 BufferStateLayer 把fence关联到回调类中 | layer-&gt;getLayerFE().onLayerDisplayed(ftl::yield&lt;FenceResult&gt;(std::move(releaseFence)).share());| // mReleasedLayers是一些即将移除的的layer，但是当前vsync还在生产帧数据的layer| // 把presentFence传给这些layer使用，毕竟他们不参与合成了| for (auto&amp; weakLayer : mReleasedLayers) | if (const auto layer = weakLayer.promote()) | layer-&gt;onLayerDisplayed(ftl::yield&lt;FenceResult&gt;(frame.presentFence).share());| mReleasedLayers.clear();//清空 mReleasedLayers 再回到APP进程端 releaseBuffer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576c++复制代码|--&gt;SurfaceFlinger::postComposition() | // 省略一大段内容 | for (const auto&amp; layer: mLayersWithQueuedFrames) | // 更新FrameTracker、TimeStats这些 | layer-&gt;onPostComposition(display, glCompositionDoneFenceTime,mPreviousPresentFences[0].fenceTime, compositorTiming); | layer-&gt;releasePendingBuffer(/*dequeueReadyTime*/ now); |--&gt;BufferStateLayer::releasePendingBuffer(nsecs_t dequeueReadyTime) | for (auto&amp; handle : mDrawingState.callbackHandles) | if (handle-&gt;releasePreviousBuffer &amp;&amp; mDrawingState.releaseBufferEndpoint == handle-&gt;listener) | // 这个 mPreviousReleaseCallbackId 在 BufferStateLayer::updateActiveBuffer() 赋值 | // mPreviousReleaseCallbackId = &#123;getCurrentBufferId(), mBufferInfo.mFrameNumber&#125;; | handle-&gt;previousReleaseCallbackId = mPreviousReleaseCallbackId; | break; | // 把 callback 加入 TransactionCallbackInvoker::mCompletedTransactions | mFlinger-&gt;getTransactionCallbackInvoker().addCallbackHandles(mDrawingState.callbackHandles, jankData); | //【这里就是通过binder通信，回调到 APP 端BBQ执行 releaseBuffer 了】 | mTransactionCallbackInvoker.sendCallbacks(false /* onCommitOnly */); |--&gt;BpTransactionCompletedListener::onTransactionCompleted(android::ListenerStats) // 跨进程进入到APP端// frameworks/native/libs/gui/BLASTBufferQueue.cppreleaseBufferCallbackThunk(wp&lt;BLASTBufferQueue&gt; context, ReleaseCallbackId&amp; id,Fence&amp; releaseFence, uint32_t currentMaxAcquiredBufferCount)| sp&lt;BLASTBufferQueue&gt; blastBufferQueue = context.promote();| blastBufferQueue-&gt;releaseBufferCallback(id, releaseFence, currentMaxAcquiredBufferCount);|--&gt;BLASTBufferQueue::releaseBufferCallback(const ReleaseCallbackId&amp; id,Fence&amp; releaseFence,uint32_t currentMaxAcquiredBufferCount) | releaseBufferCallbackLocked(id, releaseFence, currentMaxAcquiredBufferCount,false /* fakeRelease */); |--&gt;BLASTBufferQueue::releaseBufferCallbackLocked(ReleaseCallbackId&amp; id,Fence&amp; releaseFence,uint32_t currentMaxAcquiredBufferCount, bool fakeRelease) | // ReleaseCallbackId 是个包含 bufferId 和 帧号 的Parcelable, ReleasedBuffer结构体又把 releaseFence 包含进来 | auto rb = ReleasedBuffer&#123;id, releaseFence&#125;; | if (std::find(mPendingRelease.begin(), mPendingRelease.end(), rb) == mPendingRelease.end()) | // 队列里边没有的话，就加入队列 | mPendingRelease.emplace_back(rb);// mPendingRelease 是个 std::deque | while (mPendingRelease.size() &gt; numPendingBuffersToHold) // numPendingBuffersToHold 是需要保留的buffer数量 | const auto releasedBuffer = mPendingRelease.front(); | mPendingRelease.pop_front(); | releaseBuffer(releasedBuffer.callbackId, releasedBuffer.releaseFence); |--&gt;BLASTBufferQueue::releaseBuffer(const ReleaseCallbackId&amp; callbackId,const sp&lt;Fence&gt;&amp; releaseFence) | // mSubmitted 是个map&lt;ReleaseCallbackId, BufferItem&gt;，从这个map中查找对应的 BufferItem | auto it = mSubmitted.find(callbackId); | mNumAcquired--; | mBufferItemConsumer-&gt;releaseBuffer(it-&gt;second, releaseFence); |--&gt;BufferItemConsumer::releaseBuffer(const BufferItem &amp;item, const sp&lt;Fence&gt;&amp; releaseFence) | // mSlots[slot].mFence = fence; 赋值releaseFence，并处理 Fence 合并情况 | addReleaseFenceLocked(item.mSlot, item.mGraphicBuffer, releaseFence); | releaseBufferLocked(item.mSlot, item.mGraphicBuffer, EGL_NO_DISPLAY, EGL_NO_SYNC_KHR); |--&gt;ConsumerBase::releaseBufferLocked(int slot, const sp&lt;GraphicBuffer&gt; graphicBuffer, EGLDisplay display, EGLSyncKHR eglFence) | // 调用消费者的 releaseBuffer 方法 | status_t err = mConsumer-&gt;releaseBuffer(slot, mSlots[slot].mFrameNumber, display, eglFence, mSlots[slot].mFence); |--&gt;BufferQueueConsumer::releaseBuffer(int slot, uint64_t frameNumber, const sp&lt;Fence&gt;&amp; releaseFence,...) | // 忽略一些容错处理 | sp&lt;IProducerListener&gt; listener; | mSlots[slot].mEglDisplay = eglDisplay; // display = EGL_NO_DISPLAY; | mSlots[slot].mEglFence = eglFence; // EGLSyncKHR eglFence = EGL_NO_SYNC_KHR | mSlots[slot].mFence = releaseFence; // SurfaceFlinger 传递过来的 releaseFence | mSlots[slot].mBufferState.release(); // 状态转为 released | mCore-&gt;mActiveBuffers.erase(slot);// 从激活状态set中删除 | mCore-&gt;mFreeBuffers.push_back(slot); // 放回 Free list 中 | if (mCore-&gt;mBufferReleasedCbEnabled) | // mConnectedProducerListener 是 BufferQueueProducer::connect 时传入的 | // CPU绘制传入的 StubProducerListener,没啥用 | listener = mCore-&gt;mConnectedProducerListener; | // 如果有阻塞在dequeuebuffer的线程，此时会被唤醒，有新的buffer可以 Dequeue 了 | mCore-&gt;mDequeueCondition.notify_all(); | if (listener != nullptr) | listener-&gt;onBufferReleased();// 对于CPU绘制，这个是空函数没啥 | // 如果返回 buffer过时了，需要清空这个slot的 GraphicBuffer | if (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) | mSlots[slotIndex].mGraphicBuffer = nullptr; | mSlots[slotIndex].mFence = Fence::NO_FENCE; | mSlots[slotIndex].mFrameNumber = 0; | mPrevFinalReleaseFence = mSlots[slot].mFence; | // 这里的mSlots是BufferItem的，和 BufferQueue 的不是一个变量 | // BufferItem 的Fence设置为 NO_FENCE | mSlots[slot].mFence = Fence::NO_FENCE; | mSubmitted.erase(it); 后记： 对于 Android 13 的 SurfaceFlinger 而言，参考资料真的是非常有限。 从 Android PAndroid Q小更新，Android QAndroid R 大的架构更新， Android R~Android S 机制上的更新(BBQ+BufferStateLayer)，Android S ~ Android T 又是大的架构更新， Google还不断使用最新的c++标准去重构代码，从c11又更新到c20。更新的XX都不认识了。 最后导致能参考的资料基本失效了，只能一个个变量去查，并且都没类注释，要命的工作量啊。 最后不感谢CCTV，感谢 cs.android.com 吧，多亏了这个源码网站强大的检索能力。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/7.点击桌面APP图标，到APP界面显示流程分析(一)/","text":"一、点击桌面App图标事件分发 systemserver进程启动时，会启动 inputflinger 服务： native层的 InputManager InputManager 启动时，启动 InputDispatcher 线程和 InputReader 线程 InputReader 线程循环调用 EventHub 的 getEvents 方法，linux设备节点&#x2F;dev&#x2F;input文件夹下的event读取事件 InputReader 读取到事件后，放到 InputDispatcher.mInboundQueue 队列中，并通知 InputDispatcher 线程读取数据 InputDispatcher 线程唤醒后，从 mInboundQueue 队列中取出事件，按事件类型进行分发。 对于触屏事件，会寻找屏幕触控事件的焦点窗口，找到后把事件放入 Connection.outboundQueue 队列中 Connection是在窗口添加时在 WindowState.openInputChannel 调用过程中创建的， 一个 Connection有一个服务端的InputChannel，一个InputChannel有一个socketpair服务端socket的fd， 同时 socketpair客户端的fd会被发送到App进程，并加入epoll监听 因此Connection就代表同App端的socket连接(或者说是管道) 最后通过 Connection 中的 socket 把事件发送到 App InputDispatcher分发流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253c复制代码InputDispatcher::start();// 这个start是SystemServer进程启动过程调用的// 启动线程。循环执行 dispatchOnce()| mThread = std::make_unique&lt;InputThread&gt;( &quot;InputDispatcher&quot;, [this]() &#123; dispatchOnce(); &#125;, [this]() &#123; mLooper-&gt;wake(); &#125;);|--&gt;InputDispatcher::dispatchOnce(); | dispatchOnceInnerLocked(&amp;nextWakeupTime); // 取出队列第一个数据， mPendingEvent 作为成员变量，表示待处理事件，一次循环处理一个待处理事件 | mPendingEvent = mInboundQueue.front(); // 取出后，移除第一个数据 | mInboundQueue.pop_front(); // 根据事件类别，分别调用不同的事件分发函数，比如，按键事件调用 dispatchKeyLocked | switch (mPendingEvent-&gt;type) // 以屏幕触控事件为例 | case EventEntry::Type::MOTION: | // 分发屏幕触控事件 | done = dispatchMotionLocked(currentTime, motionEntry, &amp;dropReason, nextWakeupTime); // 寻找屏幕触控事件的焦点窗口，把所有接收当前输入事件的窗口的InputChannel封装到InputTarget，并添加到集合inputTargets | findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions); | dispatchEventLocked(currentTime, entry, inputTargets); // 遍历集合 inputTargets | for (const InputTarget&amp; inputTarget : inputTargets) // 根据 token 拿到 Connection 【见：addToDisplayAsUser 章节】 // 从map类型数据 mConnectionsByToken 依据key InputChannel.mToken 查找 Connection // std::unordered_map&lt;sp&lt;IBinder&gt;, sp&lt;Connection&gt;&gt; mConnectionsByToken // mConnectionsByToken 中的数据是 createInputChannel 是添加的 // createInputChannel 是添加窗口时在 WindowState.openInputChannel 调用过程中调用。 // 一个 Connection有一个服务端的InputChannel，一个InputChannel有一个socketpair服务端socket的fd // 因此Connection就代表同App端的socket连接(或者说是管道) | sp&lt;Connection&gt; connection = getConnectionLocked(inputTarget.inputChannel-&gt;getConnectionToken()); | prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget); | enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget); | enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, FLAG_DISPATCH_AS_IS); // 把需要分发的事件加入到对于窗口的Connection.outboundQueue队列中 | connection-&gt;outboundQueue.push_back(dispatchEntry.release()); // 开始循环分发事件 | startDispatchCycleLocked(currentTime, connection); // outboundQueue 队列不为空就一直循环处理 | while (!connection-&gt;outboundQueue.empty()) | connection-&gt;inputPublisher.publishMotionEvent(...) | mChannel-&gt;sendMessage(&amp;msg); // 通过socket把事件发生给客户端 | ::send(getFd(), &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); // 删除outboundQueue队列中已发送的事件 | connection-&gt;outboundQueue.erase(std::remove(connection-&gt;outboundQueue.begin(), connection-&gt;outboundQueue.end(), dispatchEntry)); // 已发送的事件加入Connection的 waitQueue // App端处理完事件后，会回调回来删除waitQueue中的事件 // AMR 检查时，waitQueue 中的事件超时未回调，会触发ANR | connection-&gt;waitQueue.push_back(dispatchEntry); // 处理ANR | const nsecs_t nextAnrCheck = processAnrsLocked(); | mLooper-&gt;pollOnce(timeoutMillis); App进程事件分发 looper epoll监听 SocketPair 的fd 【这个fd的来源见：addToDisplayAsUser 章节】 socket来数据后，回调 NativeInputEventReceiver::handleEvent android::NativeInputEventReceiver.consumeEvent native 反射调用Java层 InputEventReceiver.deliverInputEvent WindowInputEventReceiver.onInputEvent ViewRootImpl.enqueueInputEvent&#x2F;&#x2F;执行入队操作—PendingInputEventQueue doProcessInputEvents() deliverInputEvent(q);&#x2F;&#x2F;这里会在systrace显示 deliverInputEvent块 经过若干步骤后 mView.dispatchPointerEvent(event);&#x2F;&#x2F;进入view的事件分发流程 然后 view 再处理各自的touch事件。 比如ScrollView，在touch事件中，会调整view的坐标，然后调用 invalidate 函数，函数最终会调用 requestNextVsync 触发 vsync ，vsync 回调doframe中绘制流程中，ScrollView根据新的坐标绘制界面，然后就看到了界面滚动。 事件分发到桌面图标的view后，view自身的点击事件中调用 startActivity 启动App。 二、APP创建进程App到systemserver进程Activity 的 startActivity 函数会调用到 ActivityTaskManagerService 的 startActivityAsUser 或者其他几个 start 方法 ActivityTaskManagerService.startActivityAsUser —&gt;ActivityStarter.execute —&gt;ActivityStarter.executeRequest 内部创建ActivityRecord ： ActivityRecord r &#x3D; new ActivityRecord.Builder(mService) ActivityRecord 继承 WindowToken Android 12 构造函数中 appToken &#x3D; new Token Token extends IApplicationToken.Stub token，这个东西Android 11，Android12，Android13 这里的代码都不一样。 Android 13 Token extends Binder ActivityRecord 没有 appToken 变量了，也是new Token，然后传递到 父类 WindowToken 中 由于构造函数中传递的DisplayContent为null，新创建的 ActivityRecord 还不会加入 DisplayContent 的HashMap对象 mTokenMap —&gt;ActivityStarter.startActivityUnchecked —&gt;ActivityStarter.startActivityInner setNewTask –&gt;addOrReparentStartingActivity(task, “setTaskFromReuseOrCreateNewTask”); 把 ActivityRecord 添加到任务栈 给 ActivityRecord 添加 parent : parent.addChild(mStartActivity); ActivityRecord.getTask 返回的就是这个 targetTask addOrReparentStartingActivity 最终会把 ActivityRecord 加入到 DisplayContent .mTokenMap mTargetRootTask.startActivityLocked 判断当前 activity 是否需要为其新建 Task，将 ActivityRecord 加入到对应的 Task 栈顶中 ActivityRecord.showStartingWindow 启动过度界面 mTargetRootTask.moveToFront RootWindowContainer.resumeFocusedTasksTopActivities&#x3D;&#x3D;&#x3D;&gt;转Task.resumeFocusedTasksTopActivities mSupervisor.mRecentTasks.add(mStartActivity.getTask()) 其他任务栈相关的处理 —&gt; Task.resumeFocusedTasksTopActivities —&gt; Task.resumeTopActivityUncheckedLocked —&gt; Task.resumeTopActivityInnerLocked &#x2F;&#x2F; 这里写是的Android12的流程，Android 13 这里不一样了 ActivityRecord next &#x3D; topRunningActivity(true &#x2F;* focusableOnly *&#x2F;); —&gt;如果有关联的进程，则直接调度生命周期：mAtmService.getLifecycleManager().scheduleTransaction(transaction); —&gt;如果是新的activity【mTaskSupervisor.startSpecificActivity(next, true, true)】，事务添加 LaunchActivityItem Callback，用于app进程创建activity。如果没有进程还会创建进程 —&gt;ActivityTaskSupervisor.startSpecificActivity —&gt; 如果已有进程调用 realStartActivityLocked —&gt;没有进程，创建进程流程：mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? “top-activity” : “activity”); –&gt;ATMS.startProcessAsync startProcessAsync 只是把任务post给AMS，调用 AMS.startProcess –&gt;ActivityManagerInternal.startProcess ActivityManagerInternal.startProcess 是个抽象方法，实现是 ActivityManagerService.LocalService.startProcess –&gt;ActivityManagerService.LocalService.startProcessLocked 创建 HostingRecord ，并作为参数传给下一步 HostingRecord .mHostingZygote 属性用于选择 zygote 类型 HostingRecord 构造函数未传入 hostingZygote 参数，使用默认的 REGULAR_ZYGOTE ，即常规孵化器 ActivityManagerService.startProcessLocked 没啥内容，直接调用 ProcessList.startProcessLocked –&gt;16参数的ProcessList.startProcessLocked 处理 badProcess，连续崩溃超过2次会变成badProcess，后台禁止启动badProcess 处理隔离进程 处理不同App在同一个进程情况，App正在启动情况 正在启动的话，直接返回 处理App已经死亡，但是死亡通知还未到来的情况 处理系统还未启动完成情况，先把App存起来，之后处理 –&gt;4参数的ProcessList.startProcessLocked 直接转发到6参数的 startProcessLocked –&gt;6参数的ProcessList.startProcessLocked 代码很多主要是设置启动参数 进程正在启动中，返回 记录启动开始的时间 清理参与的 死亡通知信息 清理mProcessesOnHold用于保存那些在系统还没有准备好就提前请求启动的ProcessRecord 更新 Profiler 信息 设置外存储挂载模式、设置App权限：gids 处理 manifest中设置了android:debuggable 信息，添加debug启动参数 设置 ABI、设置指令集、设置 selinux 设置App进程的启动入口为 “android.app.ActivityThread“ –&gt;ProcessList.startProcess 启动准备 设置一些正在启动的标志 异步启动和同步启动，默认使用异步启动 –&gt;ProcessList.handleProcessStart 异步启动 如果上一个App还没有死亡通知，则延迟启动，延迟时间最长默认 10 秒 正常情况直接调用 ProcessList.startProcess –&gt;ProcessList.startProcess 处理存储目录 选择创建App进程的孵化器，由于HostingRecord .mHostingZygote 为 REGULAR_ZYGOTE ，因此调用 Process.start –&gt;Process.start 没啥内容，直接调用 ZygoteProcess.start –&gt;ZygoteProcess.start 处理usap，usap启用的话，预创建APP进程，最大创建10个线程 Android 13 由属性 dalvik.vm.usap_pool_enabled 决定是否启用usap，这个属性默认为false 之后调用 ZygoteProcess.startViaZygote –&gt;ZygoteProcess.startViaZygote 把参数封装成字符串 –&gt;ZygoteProcess.zygoteSendArgsAndGetResult 处理一些字符串异常，并加入数据大小 调用 openZygoteSocketIfNeeded(abi) 连接 ZygoteServer ，根据ABI确定连接 zygote(zygote64) 还是 zygote_secondary(zygote32) –&gt;ZygoteProcess.attemptZygoteSendArgsAndGetResult 写完socket，接着后读socket –&gt;zygoteWriter.write(msgStr); –&gt;使用socket 数据传输到 ZygoteServer ZygoteServer进程从Zygote启动讲起 ZygoteInit.main &#x2F;&#x2F; Zygote 有两种启动方式，一种是启动system_server 一种启动App main函数 1、非懒加载情况下，预加载资源：jar，图形库，drawable、字体 2、创建zygote进程的socket server服务端对象 ZygoteServer 3、调用 ZygoteServer.runSelectLoop 进入死循环，等待 AMS 创建进程的socket消息(也会处理其他消息) 4、调用 runSelectLoop 返回的 Runnable.run 方法 ZygoteServer.runSelectLoop ZygoteServer.acceptCommandPeer &#x2F;&#x2F; 得到一个请求连接封装对象ZygoteConnection ZygoteConnection.processCommand &#x2F;&#x2F;处理AMS客户端请求 Zygote.forkSimpleApps &#x2F;&#x2F; fork创建应用子进程， ZygoteCommandBuffer.forkRepeatedly &#x2F;&#x2F; 进入native层后，调用 fork() Zygote.childMain ZygoteInit.zygoteInit &#x2F;&#x2F; 开启 binder 消息监听 ,设置异常处理函数 RuntimeInit.applicationInit RuntimeInit.findStaticMain return new MethodAndArgsCaller(m, argv); MethodAndArgsCaller 对象不再继承Exception，仅仅继承Runnable， MethodAndArgsCaller经过层层 return 后，返回 ZygoteInit.main ， 最后调用 MethodAndArgsCaller.run 方法 通过反射创建ActivityThread对象并调用其“main”入口方法。 ZygoteInit.main123456789101112131415161718192021222324252627282930313233343536373839404142434445java复制代码ZygoteInit.main(String[] argv);| ZygoteServer zygoteServer = null;| Runnable caller; // 非懒加载情况下，预加载资源|--&gt;static void preload(TimingsTraceLog bootTimingsTraceLog); | preloadClasses(); // 加载 /system/etc/preloaded-classes // 加载非启动使用的类： // /system/framework/android.hidl.base-V1.0-java.jar // /system/framework/android.hidl.manager-V1.0-java.jar // /system/framework/android.test.base.jar | cacheNonBootClasspathClassLoaders(); /* com.android.internal.R.array.preloaded_drawables com.android.internal.R.array.preloaded_color_state_lists com.android.internal.R.array.preloaded_freeform_multi_window_drawables */ | preloadResources(); // 预加载图形缓存map库 // Gralloc4Mapper::preload();Gralloc3Mapper::preload();Gralloc2Mapper::preload(); | nativePreloadAppProcessHALs(); /* GL driver 或者 Vulkan driver 预加载 */ | maybePreloadGraphicsDriver(); // 加载共享库：libandroid.so libcompiler_rt.so libjnigraphics.so | preloadSharedLibraries(); // TextView.preloadFontCache(); 加载字体 | preloadTextResources(); | WebViewFactory.prepareWebViewInZygote();// native层获取socket fd; 命名空间mount rootfs; selinux_android_seapp_context_init();| Zygote.initNativeState(isPrimaryZygote);//如果是主Zygote，Zygote 64位，创建地址名为 zygote 的socket服务端，以及usap socket服务 usap_pool_primary//如果是次Zygote，Zygote 32位，创建地址名为 zygote_secondary 的socket服务端，以及usap socket服务 usap_pool_secondary| zygoteServer = new ZygoteServer(isPrimaryZygote);// 如果argv参数中有 &quot;start-system-server&quot; 则fork SystemServer 进程| if (startSystemServer) | Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); | r.run(); | return; // for SystemServer 进程 后直接返回,退出进程// 默认情况，运行 runSelectLoop ，开启 zygoteServer 循环，等待 AMS 创建进程的socket消息| caller = zygoteServer.runSelectLoop(abiList);| if (caller != null) // fork 完成的子进程，会从runSelectLoop无线循环中跳出，会进入到这里 /* 如果是子进程的话，这里返回的是 MethodAndArgsCaller，MethodAndArgsCaller 继承Runnable 这里不像以前那样抛出异常清理栈帧，就是回退到 ZygoteInit.main，通过 MethodAndArgsCaller.run调用 android.app.ActivityThread.main */ | caller.run(); ZygoteServer.runSelectLoop1234567891011121314151617181920212223242526272829java复制代码Runnable runSelectLoop(String abiList);// socketFDs[0] 为 ZygoteServer 的fd，之后的数据为 连接客户端的 socket fd| ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;&gt;();| ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;&gt;();| socketFDs.add(mZygoteSocket.getFileDescriptor());// ZygoteServer 的fd| peers.add(null);// 先add了一个null，用于和 socketFDs 共用一个下标变量 pollIndex | while (true) | StructPollfd[] pollFDs; // 循环起始先把 socketFDs 的fd加入到数组 pollFDs // 之后再把 usapPool 的 fd 加入到 pollFDs // usapPoolEventFDIndex 记录 usapPool 起始索引 // poll监听 socketFDs 中的文件描述符 | Os.poll(pollFDs, pollTimeoutMs); | while (--pollIndex &gt;= 0) | if (pollIndex == 0) // pollIndex == 0 表示 ZygoteServer socket 事件 | ZygoteConnection newPeer = acceptCommandPeer(abiList); // 拿到连接客户端的socket | peers.add(newPeer); // 把客户端的fd放到数组，下一次循环，一起加入到poll监听 | socketFDs.add(newPeer.getFileDescriptor()); | else if (pollIndex &lt; usapPoolEventFDIndex) // AMS 创建进程的客户端 socket 事件 | ZygoteConnection connection = peers.get(pollIndex); // 读取socket连接的数据，并处理 | final Runnable command = connection.processCommand(this, multipleForksOK); // //默认值为false，在子进程时，会调用 setForkChild 设置为 true | if (mIsForkChild) // 子进程返回的是 继承Runnable的 MethodAndArgsCaller 对象 | return command; // 子进程直接返回 command ，并结束 runSelectLoop 循环 ZygoteConnection.processCommand123456789101112131415161718192021222324252627282930313233343536373839java复制代码Runnable processCommand(ZygoteServer zygoteServer, boolean multipleOK);// 创建 native 层对象 NativeCommandBuffer，用于读socket数据 | ZygoteCommandBuffer argBuffer = new ZygoteCommandBuffer(mSocket);// 把 ZygoteCommandBuffer 传入ZygoteArguments// 并调用 ZygoteArguments.parseArgs(ZygoteCommandBuffer args, int argCount)// parseArgs 读取socket，并解析数据| parsedArgs = ZygoteArguments.getInstance(argBuffer);| if (parsedArgs.mPreloadPackage != null) // 如果是 WebViewZygote，预加载 WebView 的库 | handlePreloadPackage(...);| if (canPreloadApp() &amp;&amp; parsedArgs.mPreloadApp != null) // 如果是AppZygoteServer，会预加载apk | handlePreloadApp(...);/*mInvokeWith InvokeWith DEBUG 使用， wrap.sh 脚本相关mStartChildZygote 创建子zygote进程multipleOK = true非系统进程（systemserver、系统App），ATMS就是 SYSTEM_UID 符合以上条件调用 Zygote.forkAndSpecialize，这个和以前也不一样了*/| if (parsedArgs.mInvokeWith != null || parsedArgs.mStartChildZygote || !multipleOK || peer.getUid() != Process.SYSTEM_UID) | pid = Zygote.forkAndSpecialize(...); // 以前用这个，现在不用了 |else // 通常情况是走 else 分支，调用 Zygote.forkSimpleApps Runnable result = Zygote.forkSimpleApps(...); |--&gt;static @Nullable Runnable forkSimpleApps(...); | boolean in_child = argBuffer.forkRepeatedly(...); | return nativeForkRepeatedly(...); | com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(...); | NativeCommandBuffer.readAllLines; | int pid = zygote::forkApp(...); // fd 的处理 | zygote::ForkCommon(...); | pid_t pid = fork(); // 真正fork进程的地方 //处于子进程时，pid=0，处理分配内存的设置等等 | return pid; |//如果pid为0，处于子进程，return true; | if (in_child) // 如果是子进程，调用 childMain | return childMain(argBuffer, /*usapPoolSocket=*/null, /*writePipe=*/null); |else// 如果是 Zygote 进程，return null; |// 子进程返回时，result不为null，return result; 子进程调用 Zygote.childMain123456789101112131415161718192021222324252627282930313233343536java复制代码// frameworks/base/core/java/com/android/internal/os/Zygote.javaZygote.forkSimpleApps(...);| childMain(argBuffer, /*usapPoolSocket=*/null, /*writePipe=*/null);|--&gt;private static Runnable childMain(ZygoteCommandBuffer argBuffer,LocalServerSocket usapPoolSocket,FileDescriptor writePipe);| specializeAppProcess(...); | nativeSpecializeAppProcess(...); | com_android_internal_os_Zygote_nativeSpecializeAppProcess(); // 设置命名空间的存储目录挂载 // 设置调度策略，selinux，调试模式，SetGids，内存分配模式 等等 | SpecializeCommon(...); | Thread.currentThread().setPriority(Thread.NORM_PRIORITY); //设置进程优先级| return ZygoteInit.zygoteInit(args.mTargetSdkVersion,args.mDisabledCompatChanges,args.mRemainingArgs,null); | RuntimeInit.commonInit(); // 设置异常处理 | RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler); | Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)); | ZygoteInit.nativeZygoteInit(); // 开启 binder 消息监听 |--&gt; com_android_internal_os_ZygoteInit_nativeZygoteInit |--&gt; gCurRuntime-&gt;onZygoteInit(); |--&gt; frameworks/base/cmds/app_process/app_main.cpp |--&gt; onZygoteInit(); | sp&lt;ProcessState&gt; proc = ProcessState::self(); | proc-&gt;startThreadPool(); | return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader); | return findStaticMain(args.startClass, args.startArgs, classLoader); | return new MethodAndArgsCaller(m, argv); // MethodAndArgsCaller 是个 Runnable, [见：附]// 层层 return 回退到 ZygoteInit.main，通过 MethodAndArgsCaller.run 调用 android.app.ActivityThread.main // 附：MethodAndArgsCallerstatic class MethodAndArgsCaller implements Runnable &#123; //... public void run() &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;) &#125;&#125; 三、android.app.ActivityThread.main1、ActivityThread.main 到 AMS 流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950java复制代码ActivityThread.main // 1.创建主线程的 Looper 对象。 main函数最后调用 Looper.loop();启动无线循环。 | Looper.prepareMainLooper(); // 2.创建 ActivityThread 对象 | ActivityThread thread = new ActivityThread(); // 在类成员中直接创建 ApplicationThread，ApplicationThread 继承 IApplicationThread.Stub // IApplicationThread 是 APP 同 AMS 交互的接口 | final ApplicationThread mAppThread = new ApplicationThread(); // 3. 调用 ActivityThread .attach 方法 | thread.attach(false, startSeq); | final IActivityManager mgr = ActivityManager.getService(); // mAppThread 是 ApplicationThread // 通过binder调用AMS的attachApplication接口将 ApplicationThread 注册到AMS中 | mgr.attachApplication(mAppThread, startSeq); // 进入systemserver进程 的 AMS | AMS.attachApplicationLocked //直接转到 attachApplicationLocked | ProcessRecord app; | 【1】thread.bindApplication(...); //binder跨进程 回调 ApplicationThread bindApplication // bindApplication流程： /*app进程 ApplicationThread .handleBindApplication Dex文件的加载和Resource资源的加载 创建应用的LoadedApk对象、创建Application的Context 加载应用APK的Dex文件到内存中，加载APK的Resource资源 调用LoadedApk.makeApplication函数，创建应用的Application对象 执行应用 Application.onCreate 生命周期函数*/ // 设置 ProcessRecord.mThread = IApplicationThread(thread) // 设置 ProcessRecord.mWindowProcessController.mThread = IApplicationThread(thread) | app.makeActive(thread, mProcessStats); //启动应用 Activity的 流程 | 【2】mAtmInternal.attachApplication(app.getWindowProcessController()); | mRootWindowContainer.attachApplication(wpc); | RootWindowContainer::startActivityForAttachedApplicationIfNeeded//这里Android 13 版本有些变化 | mStackSupervisor.realStartActivityLocked(ActivityRecord r,WindowProcessController proc,boolean andResume,...) | r.startFreezingScreenLocked(proc, 0); // 冻结屏幕 | r.setProcess(proc); // ActivityRecord 关联 WindowProcessController // 创建 ClientTransaction // ClientTransaction.mClient = WindowProcessController.getThread() 是 App 端的 ApplicationThread // 使用 ActivityRecord.token 赋值 ClientTransaction.mActivityToken // ClientTransaction.mActivityToken 会传入 客户端app进程 // 注：Android12 用的 ActivityRecord.appToken, Android 12 ActivityRecord.appToken=ActivityRecord.token | final ClientTransaction clientTransaction = ClientTransaction.obtain(proc.getThread(), r.token); // 添加 LaunchActivityItem 回调，App进程会执行其execute方法，内部执行 handleLaunchActivity | clientTransaction.addCallback(LaunchActivityItem.obtain(...)) | lifecycleItem = ResumeActivityItem.obtain(isTransitionForward, r.shouldSendCompatFakeFocus()); // App进程会执行 ResumeActivityItem.execute方法 ,内部调用 handleResumeActivity | clientTransaction.setLifecycleStateRequest(lifecycleItem); // 传递Launch和Resume生命周期事务 | mService.getLifecycleManager().scheduleTransaction(clientTransaction); // 4. 启动loop无线循环 | Looper.loop(); 2、scheduleTransaction 跨进程调用，把事务传递到 APP进程12345678910111213141516171819202122232425262728java复制代码ClientLifecycleManager.scheduleTransaction(ClientTransaction transaction);| transaction.schedule();|--&gt;ClientTransaction.schedule(); // IApplicationThread mClient; | mClient.scheduleTransaction(this) //ApplicationThread 继承 IApplicationThread |--&gt;ApplicationThread.scheduleTransaction(ClientTransaction transaction); | ActivityThread.this.scheduleTransaction(transaction); // ActivityThread.scheduleTransaction 继承 ClientTransactionHandler.scheduleTransaction |--&gt;ClientTransactionHandler.scheduleTransaction(ClientTransaction transaction); // 调用 LaunchActivityItem.preExecute 预处理工作 | transaction.preExecute(this); | sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); //post到主线程去处理 |--&gt;ActivityThread.H.handleMessage(Message msg); | mTransactionExecutor.execute(transaction); | executeCallbacks(transaction); // 取出 ClientTransaction.mActivityToken 作为参数传入 LaunchActivityItem.execute | final IBinder token = transaction.getActivityToken(); // 这个 token = ActivityRecord.appToken | LaunchActivityItem.execute(ClientTransactionHandler client, IBinder token,...); // 创建 ActivityClientRecord ActivityClientRecord.token = token; // Android 12 是在 preExecute 中创建，Android 13 变更到了execute 中 | ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,...); // 执行 ActivityThread.handleLaunchActivity | client.handleLaunchActivity(r, pendingActions, null /* customIntent */); | executeLifecycleState(transaction); | ResumeActivityItem.execute(ClientTransactionHandler client, ActivityClientRecord r,...); // 执行 ActivityThread.handleResumeActivity | client.handleResumeActivity(r, true /* finalStateRequest */, mIsForward,...); ActivityClientRecord.token &#x3D; ClientTransaction.mActivityToken &#x3D; ActivityRecord.token 经过一系列的 事务，生命周期管理相关的代码后 调用 handleLaunchActivity 和 handleResumeActivity 3、handleLaunchActivity 执行 Launch 生命周期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364java复制代码// frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.javaclient.handleLaunchActivity(r, pendingActions, null /* customIntent */);// frameworks/base/core/java/android/app/ActivityThread.javaActivityThread.handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent);| performLaunchActivity(ActivityClientRecord r, Intent customIntent) // 1.创建Activity的Context，Activity虽然也是Context，但是其真正的Context是Activity.mBase 成员 | ContextImpl appContext = createBaseContextForActivity(r); // 2.调用 mInstrumentation.newActivity,通过反射创建Activity | java.lang.ClassLoader cl = appContext.getClassLoader(); | activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); // 把 ActivityClientRecord 存入 mActivities // ActivityClientRecord.activity 存储 Activity 对象 | mActivities.put(r.token, r); // 3.调用 activity.attach 方法 | activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo,...); // 把 performLaunchActivity 创建的 context 设置到 Activity.mBase | attachBaseContext(context); // 创建 PhoneWindow 对象 | mWindow = new PhoneWindow(this, window, activityConfigCallback); | mWindowAttributes = new WindowManager.LayoutParams(); // 这个 type 在后边 Window.adjustLayoutParamsForSubWindow 会用到 | type = TYPE_APPLICATION; // 设置Activity key dispatching， panels and menus 等回调。用于拦截点击触摸事件等等 | mWindow.setCallback(this);//至此：// activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token | mToken = token; | mApplication = application; // 给 PhoneWindow 对象，设置 WindowManager 对象 | mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, ...); // SystemServiceRegistry 静态代码中创建 getSystemService 接口的 WindowManager 实例： | new WindowManagerImpl(ctx); // SystemServiceRegistry 创建的WindowManagerImpl的成员 mParentWindow=null; mWindowContextToken=null; | this(context, null /* parentWindow */, null /* clientToken */); |--&gt;Window.setWindowManager(WindowManager wm, IBinder appToken, String appName,boolean hardwareAccelerated);//至此：//PhoneWindow.mAppToken=activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token | mAppToken = appToken; | mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);// 参数传入 PhoneWindow |--&gt;WindowManagerImpl createLocalWindowManager(Window parentWindow) | return new WindowManagerImpl(mContext, parentWindow, mWindowContextToken); | mContext = context; | mParentWindow = parentWindow; // 这个传入的是 PhoneWindow | mWindowContextToken = windowContextToken; // 这个是 null | 这个 mWindowManager 对象时new的 WindowManagerImpl // 也就是说Activity中的 mWindowManager 对象，获取的window管理器是 WindowManagerImpl | mWindowManager = mWindow.getWindowManager(); | r.activity = activity; // ActivityClientRecord 关联 activity // 4.Instrumentation.callActivityOnCreate---&gt;Activity.onCreate | mInstrumentation.callActivityOnCreate // 执行Activity的onCreate生命周期函数 // 在 setContentView 调用installDecor创建 DecorView 对象 // 并设置 DecorView 的window对象为 PhoneWindow | Activity.performCreate | Activity.onCreate | Activity.setContentView(R.layout.activity_main); | getWindow().setContentView | PhoneWindow.installDecor() | mDecor = generateDecor(-1); | return new DecorView(context, featureId, this, getAttributes()); |--&gt;DecorView(Context context,..., PhoneWindow window,WindowManager.LayoutParams params) | setWindow(window); | mWindow = window; //PhoneWindow; 4、handleResumeActivity 执行Resume生命周期 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556java复制代码// frameworks/base/core/java/android/app/servertransaction/ResumeActivityItem.javaclient.handleResumeActivity(r, true /* finalStateRequest */, mIsForward, mShouldSendCompatFakeFocus, &quot;RESUME_ACTIVITY&quot;);// frameworks/base/core/java/android/app/ActivityThread.java// 执行应用Activity的onResume生命周期函数ActivityThread.handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,boolean isForward, ...) | performResumeActivity(r, finalStateRequest, reason); | 执行应用Activity的onResume生命周期函数 | r.activity.performResume(r.startsNotResumed, reason); | mInstrumentation.callActivityOnResume(this); | activity.onResume(); // handleResumeActivity中执行完毕performResumeActivity后，继续执行以下代码： | final Activity a = r.activity; | r.window = r.activity.getWindow(); // 赋值 ActivityClientRecord.window | View decor = r.window.getDecorView(); | decor.setVisibility(View.INVISIBLE); | ViewManager wm = a.getWindowManager(); //activity.attach 中创建的 WindowManagerImpl 对象 // 返回的是 Window.mWindowAttributes，即 l = PhoneWindow.mWindowAttributes | WindowManager.LayoutParams l = r.window.getAttributes(); | wm.addView(decor, l); |--&gt;WindowManagerImpl.addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) | applyTokens(params); // 这里虽然看上去是设置 WindowManager.LayoutParams.token 但分析下来不是，还要在后边 | final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; | if(mDefaultToken != null ) wparams.token = mDefaultToken; // 不进这个流程 | wparams.mWindowContextToken = mWindowContextToken; // 目前为止还是 null | mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId()); |--&gt;WindowManagerGlobal.addView(View view, ViewGroup.LayoutParams params, Window parentWindow, ...) | final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; // 设置 WindowManager.LayoutParams 的 token、title、packageName、flags 属性 | parentWindow.adjustLayoutParamsForSubWindow(wparams); |--&gt;Window.adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) // wp.type = TYPE_APPLICATION =2; 如果是startingwindow，这里 wp.type = 3 (startingwindow的flag) | wp.token = mContainer == null ? mAppToken : mContainer.mAppToken; // 因为 mContainer 是 null, 所以 wp.token = mAppToken /*至此：PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.tokenPhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken */ | ViewRootImpl root = new ViewRootImpl(view.getContext(), display); //创建ViewRootImpl对象 // ViewRootImpl构造函数 |--&gt;ViewRootImpl(Context context, Display display); | 构造函数中创建IWindowSession 对象，用于同 wms 通信 | this(context, display, WindowManagerGlobal.getWindowSession(), false /* useSfChoreographer */); | private static IWindowSession sWindowSession = windowManager.openSession(...) | mWindowSession = sWindowSession // W extends IWindow.Stub ，作为参数传递给WMS，用于同 WMS 通信 | mWindow = new W(this); | 创建 Choreographer 对象 | mChoreographer = useSfChoreographer ? Choreographer.getSfInstance() : Choreographer.getInstance(); | mChoreographer = Choreographer.getInstance();//以上代码简写 | | view.setLayoutParams(wparams); | mViews.add(view); | mRoots.add(root); | mParams.add(wparams); // 来到关键点 ViewRootImpl.setview | root.setView(view, wparams, panelParentView, userId); setview之后看surface创建流程 四、ViewRootImpl 注册vsync回调注册vsync回调流程：Choreographer12345678910111213141516171819202122232425262728java复制代码WindowManagerGlobal:: mGlobal.addView | ViewRootImpl root = new ViewRootImpl(view.getContext(), display); //创建ViewRootImpl对象 | 构造函数中创建 IWindowSession 对象，用于同 wms 通信 | this(context, display, WindowManagerGlobal.getWindowSession(), false /* useSfChoreographer */); | private static IWindowSession sWindowSession = windowManager.openSession(...) | mWindowSession = sWindowSession; | 创建 Choreographer 对象 | mChoreographer = useSfChoreographer ? Choreographer.getSfInstance() : Choreographer.getInstance(); // 以上代码简写: | mChoreographer = Choreographer.getInstance(); |--&gt;Choreographer::Choreographer getInstance(); // 获取当前线程的 Choreographer,如果当前线程没有，就调用ThreadLocal.initialValue()创建一个新的 Choreographer | return sThreadInstance.get(); | ThreadLocal.initialValue(); | Looper looper = Looper.myLooper(); | return new Choreographer(looper, VSYNC_SOURCE_APP); // VSYNC_SOURCE_APP = 0; // Choreographer 构造函数: | Choreographer(Looper looper, int vsyncSource) | mLooper = looper; | mHandler = new FrameHandler(looper); // 创建 FrameDisplayEventReceiver,内部创建 IDisplayEventConnection，并创建vsync的通信socket | mDisplayEventReceiver = new FrameDisplayEventReceiver(looper, vsyncSource); | mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); // CALLBACK_LAST = 4 | mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; // 创建 5 个CallbackQueue | for (int i = 0; i &lt;= CALLBACK_LAST; i++) | mCallbackQueues[i] = new CallbackQueue(); 注册vsync回调流程：EventThreadChoreographer 构造函数创建 FrameDisplayEventReceiver 时，会创建同SurfaceFlinger的EventThread线程通信的 IDisplayEventConnection IDisplayEventConnection定义了以下接口： void stealReceiveChannel(out BitTube outChannel);获取socket通信管道 void setVsyncRate(in int count); 设置vsync分发速率。0，不调用requestNextVsync不分发；1，每次vsync事件都分发；其他，每N个vsync事件分发一次 系统默认为 0 ，不调用requestNextVsync不分发 oneway void requestNextVsync(); 请求vsync ParcelableVsyncEventData getLatestVsyncEventData(); 获取最新的 获取到 IDisplayEventConnection 后，会立刻调用 stealReceiveChannel 获取socket通信管道 从 FrameDisplayEventReceiver 构造函数开始： 注册vsync回调流程：APP进程端123456789101112131415161718192021222324252627282930313233343536373839404142c++复制代码Choreographer choreographer = new Choreographer(Looper.myLooper(), VSYNC_SOURCE_APP); | // Choreographer 构造函数中 new FrameDisplayEventReceiver | mDisplayEventReceiver = new FrameDisplayEventReceiver(looper, vsyncSource);// FrameDisplayEventReceiver 构造函数：//参数 looper：当前线程的looper; vsyncSource = VSYNC_SOURCE_APP =0;FrameDisplayEventReceiver(Looper looper, int vsyncSource);| super(looper, vsyncSource, 0); // FrameDisplayEventReceiver 继承 DisplayEventReceiver | DisplayEventReceiver(Looper looper, int vsyncSource, int eventRegistration)； | mMessageQueue = looper.getQueue(); // 创建 NativeDisplayEventReceiver，把对象地址存储到java层的 DisplayEventReceiver.mReceiverPtr 中 | mReceiverPtr = nativeInit(this, mMessageQueue,vsyncSource, eventRegistration); // frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp | nativeInit(..., jobject receiverWeak, jobject messageQueueObj,jint vsyncSource, jint eventRegistration) | sp&lt;NativeDisplayEventReceiver&gt; receiver = | new NativeDisplayEventReceiver(env, receiverWeak, messageQueue, vsyncSource, eventRegistration); // NativeDisplayEventReceiver 构造函数继续调用父类 DisplayEventDispatcher 的构造函数 // DisplayEventDispatcher 构造函数中创建成员变量 DisplayEventReceiver mReceiver(vsyncSource, eventRegistration) // DisplayEventReceiver 构造函数： // frameworks/native/libs/gui/DisplayEventReceiver.cpp | DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource,EventRegistrationFlags eventRegistration) // 获取 SurfaceFlinger 服务 | sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); // 获取 IDisplayEventConnection 存储到成员变量 mEventConnection | mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource, eventRegistration); //进入 BpSurfaceComposer.createDisplayEventConnection 开始binder通信 |--&gt;createDisplayEventConnection(VsyncSource vsyncSource, EventRegistrationFlags eventRegistration) // 【见 “SurfaceFlinger进程端注册vsync流程” 章节】 | remote()-&gt;transact(BnSurfaceComposer::CREATE_DISPLAY_EVENT_CONNECTION,data, &amp;reply); | result = interface_cast&lt;IDisplayEventConnection&gt;(reply.readStrongBinder()); | return result; | mDataChannel = std::make_unique&lt;gui::BitTube&gt;(); // 获取进程间通讯 socket 管道，封装到 BitTube 中，存储到成员变量 mDataChannel // 【详情，见 “SurfaceFlinger进程端注册vsync流程” 章节】 | mEventConnection-&gt;stealReceiveChannel(mDataChannel.get()); | receiver-&gt;initialize(); | DisplayEventDispatcher.initialize() // 把 socket 加入 | mLooper-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL); | receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); | return reinterpret_cast&lt;jlong&gt;(receiver.get()); 注册vsync回调流程：SurfaceFlinger 进程端BpSurfaceComposer.createDisplayEventConnection 跨进程进入 SurfaceFlinger 端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556c++复制代码// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp// 参数vsyncSource = VSYNC_SOURCE_APP = 0; eventRegistration = 0SurfaceFlinger.createDisplayEventConnection(ISurfaceComposer::VsyncSource vsyncSource,EventRegistrationFlags eventRegistration);| // eVsyncSourceSurfaceFlinger = 1| // handle = mAppConnectionHandle | const auto&amp; handle = vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;| return mScheduler-&gt;createDisplayEventConnection(handle, eventRegistration);|--&gt;Scheduler.createDisplayEventConnection(ConnectionHandle handle, ISurfaceComposer::EventRegistrationFlags eventRegistration) // std::unordered_map&lt;ConnectionHandle, Connection&gt; mConnections; // mConnections 存储的 Connection 是个结构体。仅含有两个成员变量 EventThreadConnection 和 EventThread [参见：附] // mConnections[handle].thread.get() 获取 SurfaceFlinger.mAppConnectionHandle 对应的 EventThread, App的EventThread线程 | return createConnectionInternal(mConnections[handle].thread.get(), eventRegistration); |--&gt;Scheduler.createConnectionInternal( EventThread* eventThread, EventRegistrationFlags eventRegistration) | return eventThread-&gt;createEventConnection([&amp;] &#123; resync(); &#125;, eventRegistration); |--&gt;EventThread.createEventConnection(ResyncCallback resyncCallback, EventRegistrationFlags eventRegistration) // EventThreadConnection 继承 IDisplayEventConnection ，返回APP的IDisplayEventConnection 就是 EventThreadConnection | return new EventThreadConnection(this,IPCThreadState::self()-&gt;getCallingUid(),resyncCallback，eventRegistration） // EventThreadConnection 构造函数： |--&gt;EventThreadConnection(EventThread* eventThread, uid_t callingUid, ResyncCallback resyncCallback,...) | : resyncCallback(std::move(resyncCallback)), | mOwnerUid(callingUid), | mEventRegistration(eventRegistration), | mEventThread(eventThread), // 创建 BitTube，BitTube 构造函数中创建 socketpair | mChannel(gui::BitTube::DefaultSize)&#123;&#125; // BitTube 构造函数 | BitTube::BitTube(size_t bufsize) | init(bufsize, bufsize); | int sockets[2]; | socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets); // 创建 socketpair | mReceiveFd.reset(sockets[0]); // sockets[0] 赋值给 mReceiveFd ，未来会发送到 APP 进程端 | mSendFd.reset(sockets[1]); // EventThreadConnection 创建完成后，首次 sp 指针引用时调用 onFirstRef() | EventThreadConnection.onFirstRef(); // 注册 vsync 回调 | mEventThread-&gt;registerDisplayEventConnection(this); |--&gt;EventThread::registerDisplayEventConnection(const sp&lt;EventThreadConnection&gt;&amp; connection); | // 加入vector集合 mDisplayEventConnections | // 这个集合 mDisplayEventConnection 会在 EventThread::threadMain 循环遍历 | mDisplayEventConnections.push_back(connection); | mCondition.notify_all(); // App进程端获取到 IDisplayEventConnection 后，立即就调用了stealReceiveChannel 接口获取 socket fd： |--&gt;EventThreadConnection::stealReceiveChannel(gui::BitTube* outChannel) // 把构造EventThreadConnection时，创建的 socketpair的fd 写到APP进程的 BitTube 中 | outChannel-&gt;setReceiveFd(mChannel.moveReceiveFd()); | outChannel-&gt;setSendFd(base::unique_fd(dup(mChannel.getSendFd()))); // 附： Scheduler.Connection 结构体 struct Connection &#123; sp&lt;EventThreadConnection&gt; connection; std::unique_ptr&lt;EventThread&gt; thread; &#125;; 五、ViewRootImpl.setView 注册 vsync 回调 IDisplayEventConnection ViewRootImpl.setView 函数中调用 requestLayout 请求vsync流程 ViewRootImpl.setView 函数中调用 WindowSession. addToDisplayAsUser ​ **创建 ISurfaceComposerClient ** addToDisplayAsUser 还有个功能是 创建 InputChannel ​ 传入一个null的 inputChannel 对象到 addToDisplayAsUser，这个 inputChannel ，在wms端创建，并赋值到inputChannel ，实际就是 socketpair vsync回调回来后 调用ViewRootImpl.**relayoutWindow 创建 Surface ** ViewRootImpl.requestLayout 请求vsync流程衔接第三章的 setView 12345678910111213141516171819202122232425262728293031323334353637383940414243java复制代码// frameworks/base/core/java/android/view/WindowManagerGlobal.javaroot.setView(view, wparams, panelParentView, userId); // 调用ViewRootImpl 的setview方法 关键方法// frameworks/base/core/java/android/view/ViewRootImpl.javaViewRootImpl.setView(View view, WindowManager.LayoutParams attrs, View panelParentView)//【一】、请求vsync：| requestLayout(); //请求vsync ，vsync回调后，开启界面绘制流程======！！！！！！！！！！！！！** | scheduleTraversals(); | mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); |--&gt;Choreographer.postCallback(int callbackType, Runnable action, Object token) | postCallbackDelayed(callbackType, action, token, 0); | postCallbackDelayedInternal(callbackType, action, token, delayMillis); // 这里把 mTraversalRunnable 加入到 mCallbackQueues 数组 | mCallbackQueues[callbackType].**addCallbackLocked**(dueTime, action, token); | scheduleFrameLocked | scheduleVsyncLocked(); | mDisplayEventReceiver.scheduleVsync(); |--&gt;DisplayEventReceiver.scheduleVsync(); | nativeScheduleVsync(mReceiverPtr); // android_view_DisplayEventReceiver.cpp | nativeScheduleVsync() // DisplayEventDispatcher.cpp | scheduleVsync() //IDisplayEventConnection mEventConnection=sf-&gt;createDisplayEventConnection | mReceiver.requestNextVsync(); // 之后跨进程调用到 SurfaceFlinger 的 requestNextVsync 方法 | DisplayEventReceiver.cpp--requestNextVsync(); | mEventConnection-&gt;requestNextVsync(); | EventThreadConnection::requestNextVsync() | EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection) | mCondition.notify_all();//唤醒 app EventThread 线程 //sf 启动后 EventThread 线程会在 threadMain 循环 | EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock) | mCondition.wait(lock);// 从阻塞中唤醒 | mVSyncSource-&gt;setVSyncEnabled(true); | DispSyncSource::setVSyncEnabled(bool enable) | 又经过很多代码，最终： | VSyncDispatchTimerQueue::setTimer(nsecs_t targetTime, nsecs_t /*now*/) | Timer::alarmAt(std::function&lt;void()&gt; const&amp; cb, nsecs_t time) | 最终的最终调用“系统调用”，timerfd_settime 设置定时发送vsync | timerfd_settime(mTimerFd, TFD_TIMER_ABSTIME, &amp;new_timer, &amp;old_timer) | 之后就是异步代码了，之后很快就启动了vsync，之后vsync事件回调app进程的doFrame方法 IWindowSession.addToDisplayAsUser–&gt;WMS.addWindow 1、创建 WindowState 2、创建 InputChannel 3、创建同 SurfaceFlinger 的连接 ISurfaceComposerClient 4、更新焦点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152java复制代码root.setView(view, wparams, panelParentView, userId);// frameworks/base/core/java/android/view/ViewRootImpl.javaViewRootImpl.setView(View view, WindowManager.LayoutParams attrs, View panelParentView);| mView = view; // 把 DecorView 存储到 mView // 把 WindowManagerGlobal.addView 设置过 token 的wparams数据复制到 mWindowAttributes| mWindowAttributes.copyFrom(attrs);/*至此：WindowToken.token 是 IBinder 类ActivityRecord 继承 WindowTokenActivityRecord 有个内部类 ActivityRecord.Token 继承 BinderActivityRecord.token 这个成员继承自 WindowToken，是内部类 ActivityRecord.Token 的实例PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.tokenViewRootImpl.mWindowAttributes.mToken = PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken */// 加入 PRIVATE_FLAG_USE_BLAST flag，这个flag在创建 SurfaceControl 时会用到 | mWindowAttributes.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;// 【一】、请求vsync| requestLayout();| InputChannel inputChannel = null; // 一个null的inputChannel，传递到WMS端赋值// 【二】、创建 ISurfaceComposerClient// mWindow 参数为 [W extends IWindow.Stub]，作为参数传递给WMS，用于同 WMS 通信| mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes..., userId,..., inputChannel, mTempInsets,...) // 参数 attrs.token = ActivityRecord.token |--&gt;WindowManagerService.mService.addWindow(this, window, attrs, viewVisibility, displayId, userId, equestedVisibility, outInputChannel, outInsetsState, outActiveControls); // 【1】、从 DisplayContent.mTokenMap 中检索token // 在 setNewTask 时，以ActivityRecord.token为键，已经把ActivityRecord加入了DisplayContent.mTokenMap // 所以能取到 token， 这个token不为 null | WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token); // 如果 token为null，这里会走创建token流程： // binder 为 ViewRootImpl.mWindowAttributes.mToken = ActivityRecord.token | final IBinder binder = attrs.token != null ? attrs.token : client.asBinder(); // WindowToken 构造函数中，传入的 DisplayContent 参数不为null时，加入 DisplayContent.mTokenMap | token = new WindowToken.Builder(this, binder, type).setDisplayContent(displayContent)....build(); | // WindowToken 构造函数： | WindowToken(WindowManagerService service, IBinder _token, int type...DisplayContent dc,...) | token = _token; | if (dc != null) dc.addWindowToken(token, this); // 加入 DisplayContent.mTokenMap // 【2】、创建 WindowState | WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); // WindowState构造函数 |--&gt;WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,WindowState parentWindow...) | mSession = s; | mClient = c; | mToken = token;/*至此：PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token参数attrs.token = ViewRootImpl.mWindowAttributes.mToken = PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken WindowState.mToken = ActivityRecord */ | mActivityRecord = mToken.asActivityRecord(); // 把token转为 ActivityRecord | InputApplicationHandle tempIAHandle = mActivityRecord.getInputApplicationHandle(false); |--&gt;ActivityRecord.getInputApplicationHandle(boolean update); | | mInputApplicationHandle = new InputApplicationHandle(token, toString(),mInputDispatchingTimeoutMillis); | // InputApplicationHandle 构造函数： | |--&gt;InputApplicationHandle(@NonNull IBinder token, @NonNull String name,long dispatchingTimeoutMillis); | | this.token = token; | | return mInputApplicationHandle; | //创建 InputWindowHandleWrapper，包装为InputWindowHandle，用于输入输出，焦点更新等等，是wms，SurfaceFlinger，input 传递数据的对象 | mInputWindowHandle = new InputWindowHandleWrapper(new InputWindowHandle(tempIAHandle, getDisplayId())) | // InputWindowHandle 构造函数： | |--&gt;InputWindowHandle(InputApplicationHandle inputApplicationHandle, int displayId); | | this.inputApplicationHandle = inputApplicationHandle; | // InputWindowHandleWrapper 构造函数： | |--&gt;InputWindowHandleWrapper(@NonNull InputWindowHandle handle); | // WindowState.mInputWindowHandle.mHandle 为InputWindowHandle对象，这个对象会传到 SurfaceFlinger | // WindowState.mInputWindowHandle.mHandle.inputApplicationHandle.token = ActivityRecord.token | | mHandle = handle; | mWinAnimator = new WindowStateAnimator(this);// 创建 WindowStateAnimator // 【3】、InputChannel 创建流程： | win.openInputChannel(outInputChannel); |--&gt;WindowState.openInputChannel(InputChannel outInputChannel); | mInputChannel = mWmService.mInputManager.createInputChannel(name); |--&gt;InputManagerService.createInputChannel(String name); |--&gt;NativeInputManagerService.createInputChannel(String name); |--&gt;nativeCreateInputChannel(JNIEnv* env, jobject nativeImplObj, jstring nameObj); |--&gt;NativeInputManager.createInputChannel(const std::string&amp; name); |--&gt;InputDispatcher::createInputChannel(const std::string&amp; name); | std::unique_ptr&lt;InputChannel&gt; serverChannel; | std::unique_ptr&lt;InputChannel&gt; clientChannel; // 1、创建 socketpair | InputChannel::openInputChannelPair(name, serverChannel, clientChannel); |--&gt;InputChannel::openInputChannelPair(...InputChannel outServerChannel,outClientChannel) | int sockets[2]; | socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets);// 创建 socketpair | sp&lt;IBinder&gt; token = new BBinder(); // 创建token | std::string serverChannelName = name + &quot; (server)&quot;; | outServerChannel = InputChannel::create(serverChannelName, sockets[0], token); | std::string clientChannelName = name + &quot; (client)&quot;; | outClientChannel = InputChannel::create(clientChannelName, sockets[1], token); // 获取InputChannel.mToken， 这个 token = new BBinder(); | const sp&lt;IBinder&gt;&amp; token = serverChannel-&gt;getConnectionToken(); // 2、使用 serverChannel 创建 connection | sp&lt;Connection&gt; connection = new Connection(std::move(serverChannel), false , ...); // 以token为键，把 connection 加入 mConnectionsByToken // serverChannel 和 clientChannel 共用一个token，用来寻找彼此 // 服务端加入mConnectionsByToken，一个返回到WMS，WMS再返回给App | mConnectionsByToken.emplace(token, connection); // 3、服务端的 socket fd 加入 epoll 监听 | int fd = serverChannel-&gt;getFd(); | mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, new LooperEventCallback(callback), nullptr); | mLooper-&gt;wake(); | return clientChannel; // 返回客户端的 InputChannel | mInputChannelToken = mInputChannel.getToken(); // 获取 native 创建的 token // mInputWindowHandle. | mInputWindowHandle.setToken(mInputChannelToken); // WindowState.InputWindowHandleWrapper.InputWindowHandle.token = native层创建的 token // InputWindowHandle.token 这个token 很重要，是 SurfaceFlinger，input 沟通用的令牌，比如焦点更新 // InputWindowHandle.InputApplicationHandle.token = ActivityRecord.token // wms会透过 SurfaceTransition 把InputWindowHandle传递给 SurfaceFlinger 的 Layer.mDrawingState.inputInfo // 到这里 Inputms，wms，ams, SurfaceFlinger 就这么连接起来了。 | mHandle.token = token; // 以 mInputChannelToken 为键，把 WindowState 存入WMS的 HashMap | mWmService.mInputToWindowMap.put(mInputChannelToken, this); // 把 native 层创建的客户端InputChannel返回给 APP | mInputChannel.copyTo(outInputChannel); | res = ADD_OKAY; | // mUseBLAST = (settings get global use_blast_adapter_vr == 1) | // global settings 中没有设置这个 use_blast_adapter_vr 值的话，默认值为 true | if (mUseBLAST) res |= WindowManagerGlobal.ADD_FLAG_USE_BLAST; // 【4】、 创建 SurfaceSession---&gt; 创建SurfaceFlinger的客户端 ISurfaceComposerClient | win.attach(); | mSession.windowAddedLocked(); //WindowState.mSession.mSurfaceSession.mNativeClient.mClient保存了用于SurfaceFlinger通信的 ISurfaceComposerClient | Session.mSurfaceSession = new SurfaceSession(); // SurfaceSession 内容很少，大概60行的代码。就是个 Native 的Java包装类 // SurfaceSession.mNativeClient 是个 SurfaceComposerClient 类 // SurfaceComposerClient.mClient 成员是个 ISurfaceComposerClient， 用于SurfaceFlinger通信 | SurfaceSession.mNativeClient = nativeCreate(); // android_view_SurfaceSession.cpp | android_view_SurfaceSession.nativeCreate | SurfaceComposerClient* client = new SurfaceComposerClient(); // sp指针引用会调用 SurfaceComposerClient::onFirstRef() | client-&gt;incStrong((void*)nativeCreate); | SurfaceComposerClient::onFirstRef() | sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); // SurfaceComposerClient.mClient 是 ISurfaceComposerClient | mClient = sf-&gt;createConnection(); | return client; // 以 IWindow 为键，把 WindowState 加入到 mWindowMap | mWindowMap.put(client.asBinder(), win); // 把 WindowState 加入到 ActivityRecord.token ，成为其子节点 // ActivityRecord.mSurfaceControl 和 WindowState.mSurfaceControl 应该都会创建。 // 这个流程会创建 WindowState.mSurfaceControl，继承的父类 WindowToken.mSurfaceControl // TODO: 这里的代码应该没这么简单，具体流程待研究。创建SurfaceControl，意味着创建Layer。这里应该是创建 ContainerLayer 和 EffectLayer 相关 | win.mToken.addWindow(win); |--&gt;WindowToken.addWindow(final WindowState win) | if (mSurfaceControl == null) | createSurfaceControl(true /* force */); // 更新焦点 | updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,false /*updateInputWindows*/); 六、vsync 回调1、SurfaceFlinger进程端： vsync 事件分发这里简单写写吧 1234567891011121314151617181920212223242526272829303132333435363738394041c++复制代码EventThread::onVSyncEvent(nsecs_t timestamp, VSyncSource::VSyncData vsyncData)| mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count,...);| mCondition.notify_all(); // 唤醒 EventThread::threadMain 处wait代码EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock)| std::vector&lt;sp&lt;EventThreadConnection&gt;&gt; consumers;| while (mState != State::Quit) | std::optional&lt;DisplayEventReceiver::Event&gt; event; | //... | if (mState == State::Idle) &#123;// 界面不动，进这里wait | mCondition.wait(lock); | //... | if (!mPendingEvents.empty()) // 被唤醒后开始处理 mPendingEvents | event = mPendingEvents.front(); | mPendingEvents.pop_front(); | //... | auto it = mDisplayEventConnections.begin(); | // mDisplayEventConnections是存储所有 EventThreadConnection 的 vector | while (it != mDisplayEventConnections.end()) | // EventThreadConnection 为虚引用，这里 promote 提升为强引用 | if (const auto connection = it-&gt;promote()) | if (event &amp;&amp; shouldConsumeEvent(*event, connection)) | // 对于需要消费这个事件的EventThreadConnection存入入 vector 中 | consumers.push_back(connection); | ++it; | else | it = mDisplayEventConnections.erase(it);// 如果虚引用的对象销毁了，则从集合删除 | if (!consumers.empty()) &#123;//集合不为空，开始分发事件 | dispatchEvent(*event, consumers); |--&gt;EventThread::dispatchEvent(const DisplayEventReceiver::Event&amp; event, const DisplayEventConsumers&amp; consumers) | for (const auto&amp; consumer : consumers) | DisplayEventReceiver::Event copy = event; | generateFrameTimeline(copy.vsync.vsyncData,...); | consumer-&gt;postEvent(copy) |--&gt;EventThreadConnection::postEvent(const DisplayEventReceiver::Event&amp; event) | DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); | gui::BitTube::sendObjects(dataChannel, events, count); | ssize_t size = tube-&gt;write(vaddr, count * objSize); |--&gt;BitTube::write(void const* vaddr, size_t size) | // mSendFd 是 socketpair 的fd | len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL); 2、APP进程端：接收vsync回调123456789101112131415161718192021222324java复制代码epoll回调| DisplayEventDispatcher::handleEvent | processPendingEvents 使用 socketpair 的BitTube 在d中取出 VSync 事件 | DisplayEventReceiver::getEvents() | BitTube::recvObjects | linux 系统调用 ::recv | dispatchVsync // env-&gt;CallVoidMethod 回到 JAVA 层的 DisplayEventReceiver.dispatchVsync() | DisplayEventReceiver.dispatchVsync() // /frameworks/base/core/java/android/view/Choreographer.java | FrameDisplayEventReceiver.onVsync | Message msg = Message.obtain(mHandler, this);//传入的回调是this，即FrameDisplayEventReceiver.run() ; | mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); | 之后进入FrameDisplayEventReceiver.run()方法调用 doFrame | void doFrame(long frameTimeNanos, int frame, DisplayEventReceiver.VsyncEventData vsyncEventData) | doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos, frameIntervalNanos) | doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos, frameIntervalNanos); | doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos, frameIntervalNanos); | doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos, frameIntervalNanos); | ViewRootImpl.mTraversalRunnable.run() | doTraversal(); | performTraversals(); | relayoutWindow //创建 Surface 流程 | doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos, frameIntervalNanos); 3、ViewRootImpl.relayoutWindow 创建 Surface123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157java复制代码ViewRootImpl.mTraversalRunnable.run()| doTraversal(); | performTraversals(); // 如果是ViewRootImpl刚创建，还没执行过performTraversals，或者窗口需要resize，或者显示属性变化,需要执行 relayoutWindow | relayoutWindow //创建surface流程 + sf 创建layer流程ViewRootImpl.relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,boolean insetsPending);| mWindowSession.relayout(mWindow, params,requestedWidth, requestedHeight,...mSurfaceControl, mTempInsets, mTempControls, mRelayoutBundle); | // 【接口层：ViewRootImpl.mSurfaceControl 构造流程】 | android.view.IWindowSession.Stub.Proxy.relayout(...android.view.SurfaceControl outSurfaceControl,...) | // 调用 system_server 进程 Session.relayout 【转到： &quot;system_server 进程 Session.relayout&quot;】 | boolean _status = mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0); | //若干步骤太多了不写了QTNND... | IPCThreadState::transact(...); | IPCThreadState::waitForResponse(...);//binder通信 | // 从 system_server 进程返回后，从 _reply 读取返回的 SurfaceControl 到 outSurfaceControl，即 ViewRootImpl.mSurfaceControl | outSurfaceControl.readFromParcel(_reply); // system_server 进程 Session.relayout|--&gt;Session.relayout(IWindow window, WindowManager.LayoutParams attrs,...SurfaceControl outSurfaceControl,...) //进入system_server进程的 WMS | mService.relayoutWindow(this, window, attrs,requestedWidth, requestedHeight,... outSurfaceControl,...) |--&gt;WindowManagerService.relayoutWindow(Session session, IWindow client, LayoutParams attrs,...SurfaceControl outSurfaceControl,...) | int result = 0; | //从 WindowManagerService.mWindowMap 获取之前addToDisplayAsUser流程存储的 WindowState | final WindowState win = windowForClientLocked(session, client, false); | // WindowState.mWinAnimator: WindowState构造函数中创建的 | WindowStateAnimator winAnimator = win.mWinAnimator; | result = createSurfaceControl(outSurfaceControl, result, win, winAnimator); |--&gt;WindowManagerService.createSurfaceControl(SurfaceControl outSurfaceControl, int result,WindowState win, WindowStateAnimator winAnimator) | WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(); |--&gt;WindowStateAnimator.createSurfaceLocked() | final WindowState w = mWin; // WindowState构造函数中会把WindowState自身传入WindowStateAnimator.mWin | final WindowManager.LayoutParams attrs = w.mAttrs; | final int format = isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format; | // 1、创建 WindowSurfaceController，赋值到 WindowStateAnimator.mSurfaceController | | mSurfaceController = new WindowSurfaceController(attrs.getTitle().toString(), format, flags, this, attrs.type); // WindowSurfaceController 构造函数 |--&gt;WindowSurfaceController(String name, int format, int flags, WindowStateAnimator animator,int windowType) | mAnimator = animator; title = name; mService = animator.mService; | final WindowState win = animator.mWin; | mWindowType = windowType; | mWindowSession = win.mSession; | // 注意这里的 parent = WindowState.mSurfaceControl | SurfaceControl.Builder b = win.makeSurface().setParent(win.getSurfaceControl()).setName(name).setFormat(format) .setFlags(flags).setMetadata(METADATA_WINDOW_TYPE, windowType).setMetadata(...mUid).setMetadata(...mPid)...; | //mService.mUseBLAST = (settings get global use_blast_adapter_vr == 1) //global settings 中没有设置这个 use_blast_adapter_vr 值的话，默认值为 true //PRIVATE_FLAG_USE_BLAST 这个 flag 是在 ViewRootImpl.setview 设置的 //综上，useBLAST = true | boolean useBLAST = mService.mUseBLAST &amp;&amp; ((win.getAttrs().privateFlags&amp; LayoutParams.PRIVATE_FLAG_USE_BLAST) != 0); | if (useBLAST) b.setBLASTLayer(); | // FX_SURFACE_BLAST = 0x00040000; 对应于 ISurfaceComposerClient.eFXSurfaceBufferState = 0x00040000 |--&gt;SurfaceControl.Builder.setFlags(FX_SURFACE_BLAST, FX_SURFACE_MASK); | // 2、创建Java层的 SurfaceControl ，赋值到 WindowStateAnimator.mSurfaceController.mSurfaceControl | | mSurfaceControl = b.build(); | | | new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,mLocalOwnerView, mCallsite); |--&gt;SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags, SurfaceControl parent...) | | mName = name;mWidth = w;mHeight = h;mLocalOwnerView = localOwnerView; | // 3、创建native层的 SurfaceControl，赋值到 WindowStateAnimator.mSurfaceController.mSurfaceControl.mNativeObject | | mNativeObject = nativeCreate(session, name, w, h, format, flags,... metaParcel); | | | | // /frameworks/base/core/jni/android_view_SurfaceControl.cpp | |--&gt;nativeCreate(..., jobject sessionObj,jstring nameStr, jint w, jint h, jint format, jint flags, ...) | | sp&lt;SurfaceComposerClient&gt; client; | client = android_view_SurfaceSession_getClient(env, sessionObj); | sp&lt;SurfaceControl&gt; surface;// surface 作为引用参数传入 | client-&gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;surface,flags, parentHandle...); | // /frameworks/native/libs/gui/SurfaceComposerClient.cpp | SurfaceComposerClient.createSurfaceChecked(const String8&amp; name,...,sp&lt;SurfaceControl&gt;* outSurface,...) | | sp&lt;IBinder&gt; handle; | | | sp&lt;IGraphicBufferProducer&gt; gbp; | | | int32_t id = -1; | | mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,... &amp;handle, &amp;gbp, &amp;id, &amp;transformHint); | //surfaceflinger/Client.cpp | | | mFlinger-&gt;createLayer | | | // 进入SurfaceFlinger进程，创建layer流程 【转“SurfaceFlinger创建layer”章节】 | SurfaceFlinger::createLayer(name, this, w, h, format,... handle, gbp, parentHandle, outLayerId,...) | | | *outSurface = new SurfaceControl(this, handle, gbp, id, w, h, format,...flags); | | | // 4、使用SurfaceFlinger创建的 handle，GraphicBufferProducer,layerId 构造native层的 SurfaceControl | | | // GraphicBufferProducer 图形buffer的生产者，handle用于layer销毁时SurfaceFlinger端回调，和layer检索 | SurfaceControl(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, | const sp&lt;IGraphicBufferProducer&gt;&amp; gbp, int32_t layerId, | | uint32_t w, uint32_t h, PixelFormat format, uint32_t transform,uint32_t flags) | | | : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp), mTransformHint(transform) | | | | mWidth(w),mHeight(h),mFormat(format),mCreateFlags(flags) &#123;&#125; | | return reinterpret_cast&lt;jlong&gt;(surface.get());// 返回native创建的 SurfaceControl | // 如果native有 mBbqChild ，返回 mBbqChild.mHandle，否则直接返回native SurfaceControl.mHandle | | | | | mNativeHandle = nativeGetHandle(mNativeObject);/ | w.mInputWindowHandle.forceChange(); | return mSurfaceController; | | surfaceController.getSurfaceControl(outSurfaceControl);//====================!!! |--&gt;WindowSurfaceController.getSurfaceControl(SurfaceControl outSurfaceControl) | // 传入的是 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl | // 5、把AMS创建的 SurfaceControl 数据，复制给需要返回 App进程的对象 outSurfaceControl | outSurfaceControl.copyFrom(mSurfaceControl, &quot;WindowSurfaceController.getSurfaceControl&quot;); |--&gt;SurfaceControl.copyFrom(@NonNull SurfaceControl other, String callsite) | // 几个重要成员复制 | mName = other.mName; mLocalOwnerView = other.mLocalOwnerView; | mWidth = other.mWidth; mHeight = other.mHeight; | // native层SurfaceControl复制， 以及 mNativeObject、mNativeHandle 复制 | assignNativeObject(nativeCopyFromSurfaceControl(other.mNativeObject), callsite); |--&gt;nativeCopyFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) | sp&lt;SurfaceControl&gt; surface(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)); | // native 层创建新的 SurfaceControl // 把 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl.mNativeObject 数据复制到新的 SurfaceControl 对象 | sp&lt;SurfaceControl&gt; newSurface = new SurfaceControl(surface); |--&gt;SurfaceControl::SurfaceControl(const sp&lt;SurfaceControl&gt;&amp; other) | mClient = other-&gt;mClient; mHandle = other-&gt;mHandle; | mGraphicBufferProducer = other-&gt;mGraphicBufferProducer; | mTransformHint = other-&gt;mTransformHint; mLayerId = other-&gt;mLayerId; | mWidth = other-&gt;mWidth; mHeight = other-&gt;mHeight; | mFormat = other-&gt;mFormat; mCreateFlags = other-&gt;mCreateFlags; | return reinterpret_cast&lt;jlong&gt;(newSurface.get()); // 返回新的SurfaceControl地址到Java层的 outSurfaceControl |--&gt;SurfaceControl.assignNativeObject(long nativeObject, String callsite) | mNativeObject = nativeObject; // 把native地址赋值到 SurfaceControl.mNativeObject | //这里不展开了，没有mBbqChild，还是使用 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl.mNativeObject.mHandle | mNativeHandle = nativeGetHandle(nativeObject); | return result; // END WindowManagerService.createSurfaceControl | | mWindowPlacerLocked.performSurfacePlacement(true /* force */); // 执行 Surface 的摆放工作 | // 如果焦点变化了更新焦点 | updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/) // 回到 APP进程端：ViewRootImpl.relayoutWindow //(1) 非 useBLAST 的情况：(Android12以后代码不会走这里)| //6、创建 Surface | mSurface.copyFrom(mSurfaceControl); |--&gt;Surface.copyFrom(SurfaceControl other) | long surfaceControlPtr = other.mNativeObject; | // 获取 native 层的 Surface 地址 | long newNativeObject = nativeGetFromSurfaceControl(mNativeObject, surfaceControlPtr); |--&gt;nativeGetFromSurfaceControl(JNIEnv* env, jclass clazz,jlong nativeObject, jlong surfaceControlNativeObj) | sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)); | sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());// 创建native Surface |--&gt;SurfaceControl.getSurface() | return generateSurfaceLocked(); |--&gt;SurfaceControl.generateSurfaceLocked() | // Android 11版本以前，这个函数内部直接创建 Surface 返回：new Surface(mGraphicBufferProducer, false); | // Android 12 这里使用 BBQ ，还从这里连接 SurfaceFlinger 创建layer。ViewRootImpl不走这里，目前这里的流程不知道给谁用的 | mBbqChild = mClient-&gt;createSurface(String8(&quot;bbq-wrapper&quot;), 0, 0, mFormat,flags, mHandle, &#123;&#125;, &amp;ignore); | // 以下流程展开参考【创建Surface：useBLAST】章节 | mBbq = sp&lt;BLASTBufferQueue&gt;::make(&quot;bbq-adapter&quot;, mBbqChild, mWidth, mHeight, mFormat); | mSurfaceData = mBbq-&gt;getSurface(true); // 返回 new BBQSurface | return mSurfaceData; | surface-&gt;incStrong(&amp;sRefBaseOwner); | return reinterpret_cast&lt;jlong&gt;(surface.get());//返回 native 的 Surface 地址 | updateNativeObject(newNativeObject) |--&gt;updateNativeObject(long newNativeObject) | setNativeObjectLocked(newNativeObject); |--&gt;setNativeObjectLocked(long ptr) | mNativeObject = ptr;// 把新的native的Surface地址存储到 Surface.mNativeObject//(2) useBLAST 的情况：(Android13 代码走这里，在Android12的基础上稍微变化了一下)| updateBlastSurfaceIfNeeded(); | mBlastBufferQueue = new BLASTBufferQueue(mTag, mSurfaceControl, mSurfaceSize.x, mSurfaceSize.y, mWindowAttributes.format); | mBlastBufferQueue.setTransactionHangCallback(sTransactionHangCallback); | Surface blastSurface = mBlastBufferQueue.createSurface(); | mSurface.transferFrom(blastSurface); 创建Surface：useBLAST (BBQ)接续上一章节“useBLAST 的情况” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134java复制代码// frameworks/base/core/java/android/view/ViewRootImpl.java// useBLAST 函数： /* mForceDisableBLAST 使用默认值false mUseBLASTAdapter：如果 WMS.addWindow 返回值带有flag WindowManagerGlobal.ADD_FLAG_USE_BLAST ，则为 true。[见：IWindowSession.addToDisplayAsUser] Android 12 后有这个flag */ boolean useBLAST() &#123; return mUseBLASTAdapter &amp;&amp; !mForceDisableBLAST; &#125;// 如果 useBLAST() 返回 true，则调用 updateBlastSurfaceIfNeeded(); // 接续上一章节“useBLAST 的情况”// frameworks/base/core/java/android/view/ViewRootImpl.javaupdateBlastSurfaceIfNeeded(); | // 【1】创建 BLASTBufferQueue| // 参数：mSurfaceControl 是在 ViewRootImpl.mWindowSession.relayout 的接口层调用 mSurfaceControl.readFromParcel 填充的数据| mBlastBufferQueue = new BLASTBufferQueue(mTag, mSurfaceControl, mSurfaceSize.x, mSurfaceSize.y, mWindowAttributes.format);| // Java层 BLASTBufferQueue 构造|--&gt;BLASTBufferQueue (String name, SurfaceControl sc, int width, int height, @PixelFormat.Format int format) | mNativeObject = nativeCreate(name, true);// 创建 native 层 BLASTBufferQueue，返回的地址存储到 mNativeObject | //【2】创建 native BLASTBufferQueue | //frameworks/base/core/jni/android_graphics_BLASTBufferQueue.cpp |--&gt;nativeCreate(JNIEnv* env, jclass clazz, jstring jName, jboolean updateDestinationFrame) | sp&lt;BLASTBufferQueue&gt; queue = new BLASTBufferQueue(name.c_str(), updateDestinationFrame); | // native 层 BLASTBufferQueue 构造，Android 13的构造函数相比 Android 12 少了一部分内容，那部分内容放到了 BLASTBufferQueue::update |--&gt;BLASTBufferQueue::BLASTBufferQueue(const std::string&amp; name, bool updateDestinationFrame) | : mSurfaceControl(nullptr),mSize(1, 1),mRequestedSize(mSize),mFormat(PIXEL_FORMAT_RGBA_8888), | mTransactionReadyCallback(nullptr),mSyncTransaction(nullptr),mUpdateDestinationFrame(updateDestinationFrame)&#123; | // 【3】创建 BufferQueueCore、BBQBufferQueueProducer、BufferQueueConsumer | createBufferQueue(&amp;mProducer, &amp;mConsumer); //[转 BLASTBufferQueue::createBufferQueue 章节] // BufferQueueProducer.mDequeueTimeout = int64.max | mProducer-&gt;setDequeueTimeout(std::numeric_limits&lt;int64_t&gt;::max()); /* BufferQueueCore: std::set&lt;int&gt; mFreeSlots; // 初始添加 2个int std::list&lt;int&gt; mUnusedSlots; // 初始添加 64 int值 setMaxDequeuedBufferCount(2)的结果： 1)从 BufferQueueCore.mUnusedSlots 中取出 1 个并删除，然后插入 BufferQueueCore.mFreeSlots; mUnusedSlots 长度变为 63，mFreeSlots长度变为 3 (mFreeSlots，是dequeuebuffer数据来源，其长度代表最大可dequeue的数量，当前为3，表示三级缓存) 2)BufferQueueCore.mMaxDequeuedBufferCount = 2; BufferQueueCore.mMaxAcquiredBufferCount = 1; 3)调整完毕mMaxDequeuedBufferCount后,如果 dequeueBuffer 处于等待buffer状态，会被唤醒拿取buffer 函数调用完成后，如果调用 getMaxBufferCountLocked，在同步模式下： BufferQueueCore.getMaxBufferCountLocked() = mMaxDequeuedBufferCount + mMaxAcquiredBufferCount = 3 (三级缓存) */ | mProducer-&gt;setMaxDequeuedBufferCount(2); | // 【4】创建 BLASTBufferItemConsumer 并设置生产者消费者监听 | mBufferItemConsumer = new BLASTBufferItemConsumer(mConsumer,USAGE_HW_COMPOSER|USAGE_HW_TEXTURE, 1, false, this); |--&gt;BLASTBufferItemConsumer(IGBConsumer&amp; consumer,uint64_t consumerUsage,int bufferCount, bool controlledByApp, wp&lt;BLASTBufferQueue&gt; bbq) : BufferItemConsumer(consumer, consumerUsage, bufferCount, controlledByApp),//构造父类BufferItemConsumer mBLASTBufferQueue(std::move(bbq)),/* 存储 BBQ*/mCurrentlyConnected(false),mPreviouslyConnected(false) &#123;&#125; |--&gt;:BufferItemConsumer(sp&lt;IGraphicBufferConsumer&gt;&amp; consumer,uint64_t consumerUsage,int bufferCount, bool controlledByApp) : ConsumerBase(consumer, controlledByApp)&#123; // BufferQueueCore.mConsumerUsageBits = GraphicBuffer::USAGE_HW_COMPOSER |GraphicBuffer::USAGE_HW_TEXTURE; mConsumer-&gt;setConsumerUsageBits(consumerUsage); // 默认 BufferQueueCore-&gt;mMaxAcquiredBufferCount = 1，bufferCount=1, 所以这里无用功 mConsumer-&gt;setMaxAcquiredBufferCount(bufferCount); &#125; |--&gt;ConsumerBase.ConsumerBase(const sp&lt;IGraphicBufferConsumer&gt;&amp; bufferQueue, bool controlledByApp) : mAbandoned(false),mConsumer(bufferQueue),mPrevFinalReleaseFence(Fence::NO_FENCE)&#123; // 创建未命令的名字，这里的名字会被之后 BLASTBufferQueue 构造函数的代码覆盖 mName = String8::format(&quot;unnamed-%d-%d&quot;, getpid(), createProcessUniqueId()); wp&lt;ConsumerListener&gt; listener = static_cast&lt;ConsumerListener*&gt;(this); sp&lt;IConsumerListener&gt; proxy = new BufferQueue::ProxyConsumerListener(listener); //【5】调用消费者的 connect 函数，这里的代码执行结果： // 1、赋值 BufferQueueCore 的消费者监听: BufferQueueCore.mConsumerListener = ConsumerBase // 2、BufferQueueCore.mConsumerControlledByApp = false status_t err = mConsumer-&gt;consumerConnect(proxy, controlledByApp); mConsumer-&gt;setConsumerName(mName);// 名字传给 BufferQueueConsumer、BufferQueueCore &#125; // consumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot; //BufferQueueCore.mConsumerName = BufferQueueConsumer.mConsumerName = BufferItemConsumer父类ConsumerBase.mName = consumerName; | mBufferItemConsumer-&gt;setName(String8(consumerName.c_str())); // ConsumerBase.mFrameAvailableListener = BLASTBufferQueue | mBufferItemConsumer-&gt;setFrameAvailableListener(this); // queuebuffer后，通知消费者的监听 // BufferItemConsumer.mBufferFreedListener = BLASTBufferQueue | mBufferItemConsumer-&gt;setBufferFreedListener(this); // 通知生产者的的监听 | ComposerService::getComposerService()-&gt;getMaxAcquiredBufferCount(&amp;mMaxAcquiredBuffers);// 从是sf获取MaxAcquiredBufferCount // 赋值 sf 的MaxAcquiredBufferCount | mBufferItemConsumer-&gt;setMaxAcquiredBufferCount(mMaxAcquiredBuffers); | mCurrentMaxAcquiredBufferCount = mMaxAcquiredBuffers; |&#125; | return reinterpret_cast&lt;jlong&gt;(queue.get());// 返回 native BLASTBufferQueue 地址 | nativeUpdate(mNativeObject, sc.mNativeObject, width, height, format); |--&gt;nativeUpdate(JNIEnv* env, jclass clazz, jlong ptr, jlong surfaceControl, jlong width,jlong height, jint format) | sp&lt;BLASTBufferQueue&gt; queue = reinterpret_cast&lt;BLASTBufferQueue*&gt;(ptr); | queue-&gt;update(reinterpret_cast&lt;SurfaceControl*&gt;(surfaceControl), width, height, format); |--&gt;BLASTBufferQueue.update(const sp&lt;SurfaceControl&gt;&amp; surface, uint32_t width, uint32_t height,int32_t format) | // 这些值，在 BufferQueueProducer::connect 函数中，会再返回 Surface | mFormat = format; BufferQueueCore-&gt;mDefaultBufferFormat = mFormat; | mSurfaceControl = surface; | mTransformHint = mSurfaceControl-&gt;getTransformHint(); BufferQueueCore-&gt;mTransformHint = mTransformHint; | // 这里的宽高，来源是 ViewRootImpl.relayout 后通过 WindowLayout::computeSurfaceSize 计算的宽高 | mRequestedSize = newSize(width, height); | mSize = mRequestedSize; | BufferQueueCore-&gt;mDefaultWidth = mRequestedSize.width; BufferQueueCore-&gt;mDefaultHeight = mRequestedSize.height; | //之后再把 宽高 通过事务传递到sf | SurfaceComposerClient::Transaction.setApplyToken(mApplyToken).apply(false, true); | mBlastBufferQueue.setTransactionHangCallback(sTransactionHangCallback);// GPU hang 回调 | Surface blastSurface = mBlastBufferQueue.createSurface();| | BlastBufferQueue.nativeGetSurface(mNativeObject, false /* includeSurfaceControlHandle */); | //frameworks/base/core/jni/android_graphics_BLASTBufferQueue.cpp |--&gt;nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr, jboolean includeSurfaceControlHandle) | sp&lt;BLASTBufferQueue&gt; queue = reinterpret_cast&lt;BLASTBufferQueue*&gt;(ptr); // 地址转为 native BLASTBufferQueue 对象 | return android_view_Surface_createFromSurface(env,queue-&gt;getSurface(includeSurfaceControlHandle)); | // 【6】创建 BBQSurface | //frameworks/native/libs/gui/BLASTBufferQueue.cpp |--&gt;BLASTBufferQueue.getSurface(bool includeSurfaceControlHandle) | sp&lt;IBinder&gt; scHandle = nullptr; | if (includeSurfaceControlHandle &amp;&amp; mSurfaceControl)// includeSurfaceControlHandle = false | scHandle = mSurfaceControl-&gt;getHandle(); | return new BBQSurface(mProducer, true, scHandle, this); | //创建 BBQSurface，比较重要的是重载了 allocateBuffers |--&gt;BBQSurface(const sp&lt;IGraphicBufferProducer&gt;&amp; igbp, bool controlledByApp, const sp&lt;IBinder&gt;&amp; scHandle, const sp&lt;BLASTBufferQueue&gt;&amp; bbq) : Surface(igbp, controlledByApp, scHandle), mBbq(bbq) &#123;&#125; | //Surface 的构造函数内容太多了不写了 |--&gt;Surface::Surface(const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp,...) : mGraphicBufferProducer(bufferProducer) // 最关键的就是传入了 生产者 | mProducerControlledByApp = controlledByApp; // true | // 【7】创建Java层的 Surface，并把 BBQSurface 的地址存入Surface.mNativeObject,(这一步就是创建个java的Surface，临时存储native的BBQSurface) | //frameworks/base/core/jni/android_view_Surface.cpp |--&gt;android_view_Surface_createFromSurface(JNIEnv* env, const sp&lt;Surface&gt;&amp; surface) | // 在 JNI new Java 层的 Surface | jobject surfaceObj = env-&gt;NewObject(gSurfaceClassInfo.clazz, gSurfaceClassInfo.ctor, (jlong)surface.get()); | // 调用Java层，参数为 long 的构造函数： |--&gt;Surface(long nativeObject) | setNativeObjectLocked(nativeObject); | mNativeObject = nativeObject; | return surfaceObj; // 返回java层的对象| //【8】把返回的BBQSurface地址 Surface.mNativeObject 转存入 ViewRootImpl.mSurface.mNativeObject| mSurface.transferFrom(blastSurface); // mSurface.mNativeObject = blastSurface.mNativeObject 4、BLASTBufferQueue::createBufferQueue 生产者-消费者-BufferQueueCore1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859c++复制代码// frameworks/native/libs/gui/BLASTBufferQueue.cppBLASTBufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer)| // 1、创建 BufferQueueCore| sp&lt;BufferQueueCore&gt; core(new BufferQueueCore()); | // BufferQueueCore 构造函数： |--&gt;BufferQueueCore::BufferQueueCore() : mMutex(), mConsumerControlledByApp(false), mSlots(), // BufferSlot[64] mSlots; 创建 Slots mQueue(), // Vector&lt;BufferItem&gt; mQueue; queuebuffer 后存储到这个变量里 // FREE 状态，没有GraphicBuffer的放到mFreeSlots里 mFreeSlots(), // std::set&lt;int&gt; mFreeSlots; 初始化为 2个int, mUnusedSlots 每减一个，对应的 mFreeSlots 加入一个 // FREE 状态，但是有buffer attached mFreeBuffers(), // std::list&lt;int&gt; mFreeBuffers; // 未被使用的 Slot ，起始长度为64，64 + 2个mFreeSlots的元素 其实代表了 Slot 的总数 // 依据 adjustAvailableSlotsLocked函数，可以得出 mUnusedSlots 每减一个，对应的 mFreeSlots 加入一个(加入的就是mUnusedSlots减去的那个) mUnusedSlots(), // std::list&lt;int&gt; mUnusedSlots; // 当应用申请走一个Slot时，该Slot状态会切换到DEQUEUED状态，该Slot会被放入mActiveBuffers队列 mActiveBuffers(),//std::set&lt;int&gt; mActiveBuffers; // mutable std::condition_variable mDequeueCondition; mDequeueCondition(), // dequeueBuffer 没slot时，调用 mDequeueCondition.wait 等待 mDequeueBufferCannotBlock(false), // bool mDequeueBufferCannotBlock = false; dequeueBuffer 时 阻塞 mQueueBufferCanDrop(false), mLegacyBufferDrop(true), mDefaultBufferFormat(PIXEL_FORMAT_RGBA_8888),/*默认使用的格式*/ mDefaultWidth(1), mDefaultHeight(1), mDefaultBufferDataSpace(HAL_DATASPACE_UNKNOWN), mMaxBufferCount(BufferQueueDefs::NUM_BUFFER_SLOTS), // NUM_BUFFER_SLOTS = 64; 这个值64，设置这么大其实用多少 mMaxAcquiredBufferCount(1), mMaxDequeuedBufferCount(1),... mTransformHint(0)/*优化屏幕旋转*/,mIsAllocating(false)/*是否正在分配内存*/,mIsAllocatingCondition(), mAllowAllocation(true), /*允许分配新buffer， BufferQueueProducer::connect时，设置为true*/ mBufferAge(0),/*当前的 BufferSlot 自从上次 queueBuffer 后，又queue了多少个BufferSlot*/ mAsyncMode(false),/*同步模式*/ mSharedBufferMode(false),... mUniqueId(getUniqueId()),mAutoPrerotation(false)/*自动预旋转*/,mTransformHintInUse(0)/*自动预旋转的方向，90度时宽高互换*/&#123; int numStartingBuffers = getMaxBufferCountLocked(); //numStartingBuffers = 2 // 构造函数中 set&lt;int&gt; mFreeSlots 插入两个int for (int s = 0; s &lt; numStartingBuffers; s++) &#123; mFreeSlots.insert(s); &#125; // 构造函数中 std::list&lt;int&gt; mUnusedSlots 插入 64 个int for (int s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; // NUM_BUFFER_SLOTS = 64 mUnusedSlots.push_front(s); &#125; &#125; | // 2、创建生产者| sp&lt;IGraphicBufferProducer&gt; producer(new BBQBufferQueueProducer(core, this)); | // BBQBufferQueueProducer 没多少内容，就是重载了 connect、setMaxDequeuedBufferCount、query |--&gt;BBQBufferQueueProducer(const sp&lt;BufferQueueCore&gt;&amp; core, wp&lt;BLASTBufferQueue&gt; bbq) // mConsumerIsSurfaceFlinger 入队后，GraphicBuffer 在BufferItem 中的指针是否应该被清除 : BufferQueueProducer(core, false /* consumerIsSurfaceFlinger*/),mBLASTBufferQueue(std::move(bbq)) &#123;&#125; |--&gt;BufferQueueProducer::BufferQueueProducer(const sp&lt;BufferQueueCore&gt;&amp; core, bool consumerIsSurfaceFlinger) : mCore(core), mSlots(core-&gt;mSlots), mConsumerName(),mStickyTransform(0), mConsumerIsSurfaceFlinger(consumerIsSurfaceFlinger/*false*/),mLastQueueBufferFence(Fence::NO_FENCE),mLastQueuedTransform(0), mCallbackMutex(),mNextCallbackTicket(0),mCurrentCallbackTicket(0),mCallbackCondition(), mDequeueTimeout(-1),mDequeueWaitingForAllocation(false) &#123;&#125;| // 3、创建消费者| sp&lt;BufferQueueConsumer&gt; consumer(new BufferQueueConsumer(core)); |--&gt;BufferQueueConsumer::BufferQueueConsumer(const sp&lt;BufferQueueCore&gt;&amp; core) : mCore(core), mSlots(core-&gt;mSlots), mConsumerName() &#123;&#125;| // 4、生产消费者赋值到 BLASTBufferQueue成员变量 mProducer 和 mConsumer| *outProducer = producer;| *outConsumer = consumer; 七、SurfaceFlinger创建layerAndroid 11 以及以前的版本简述：1234567891011121314151617c++复制代码SurfaceFlinger::createLayer| SurfaceFlinger::createBufferQueueLayer(client, uniqueName, w, h, flags, metadata, format, handle, gbp, &amp;layer); | sp&lt;BufferQueueLayer&gt; layer; | layer = getFactory().createBufferQueueLayer(args); | BufferQueueLayer 对象创建完成后，在首次sp指针引用时调用 BufferQueueLayer::onFirstRef() | onFirstRef函数中会创建 生产者，消费者，生产者会传入到客户端 | sp&lt;IGraphicBufferProducer&gt; producer; | sp&lt;IGraphicBufferConsumer&gt; consumer; | 设置生产者的三级缓冲 | mProducer-&gt;setMaxDequeuedBufferCount(2); | 赋值client端的参数 | sp&lt;IBinder&gt; *handle = layer-&gt;getHandle(); | sp&lt;IGraphicBufferProducer&gt; *gbp = layer-&gt;getProducer(); //获取生产者 | sp&lt;Layer&gt; *outLayer = layer; //这个layer保存在 SurfaceComposerClient对象中，wms并未赋值，wms对应的是SurfaceControl| addClientLayer | 调用 addClientLayer，把layer按照Z轴顺序存入 layersSortedByZ SurfaceFlinger::createLayer Android 13 Android 12 以后因为BBQ都在APP进程，所以 createLayer 大大简化了，内容不多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051c++复制代码【接续“ViewRootImpl.relayoutWindow 创建 Surface” 章节中的 “SurfaceComposerClient.createSurfaceChecked”】SurfaceFlinger::createLayer(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* outHandle,sp&lt;IBinder&gt;&amp; parentHandle, int32_t* outLayerId, sp&lt;Layer&gt;&amp; parentLayer, uint32_t* outTransformHint)| sp&lt;Layer&gt; layer; | switch (args.flags &amp; ISurfaceComposerClient::eFXSurfaceMask)&#123; case ISurfaceComposerClient::eFXSurfaceBufferQueue: /* eFXSurfaceBufferState = 0x00040000 WindowManagerService.createSurfaceControl 流程中 if (useBLAST) b.setBLASTLayer(); 这个函数设置的flag FX_SURFACE_BLAST = 0x00040000; */ case ISurfaceComposerClient::eFXSurfaceBufferState: result = createBufferStateLayer(args, outHandle, &amp;layer); | createBufferStateLayer(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* handle, sp&lt;Layer&gt;* outLayer) | *outLayer = getFactory().createBufferStateLayer(args); // 创建的 layer |--&gt;BufferStateLayer::BufferStateLayer(const LayerCreationArgs&amp; args) | : BufferLayer(args), mHwcSlotGenerator(new HwcSlotGenerator()) | mDrawingState.dataspace = ui::Dataspace::V0_SRGB; |--&gt;BufferLayer::BufferLayer(const LayerCreationArgs&amp; args) : Layer(args), mTextureName(args.textureName), | mCompositionState&#123;mFlinger-&gt;getCompositionEngine().createLayerFECompositionState()&#125; |--&gt;Layer::Layer(const LayerCreationArgs&amp; args) : sequence(args.sequence.value_or(sSequence++)), mFlinger(args.flinger), mName(base::StringPrintf(&quot;%s#%d&quot;, args.name.c_str(), sequence)), mClientRef(args.client), mWindowType(static_cast&lt;WindowInfo::Type&gt;(args.metadata.getInt32(METADATA_WINDOW_TYPE, 0))), mLayerCreationFlags(args.flags) // 然后是一堆 mDrawingState 成员属性的初始化 | *handle = (*outLayer)-&gt;getHandle(); // 把创建的 handle 传入外部，最终会返回到APP进程端，用于创建 SurfaceControl break; case ISurfaceComposerClient::eFXSurfaceEffect: // 这里是 Task、DefaultTaskDisplayArea result = createEffectLayer(args, outHandle, &amp;layer); break; case ISurfaceComposerClient::eFXSurfaceContainer://这里是 ActivityRecord、WindowState 等等 result = createContainerLayer(args, outHandle, &amp;layer); break; default: result = BAD_VALUE; break; &#125;| | result = addClientLayer(args.client, *outHandle, layer, parent, addToRoot, outTransformHint);|--&gt;SurfaceFlinger.addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle,const sp&lt;Layer&gt;&amp; layer, const wp&lt;Layer&gt;&amp; parent,...) | // std::vector&lt;LayerCreatedState&gt; mCreatedLayers 加入到数组 | mCreatedLayers.emplace_back(layer, parent, addToRoot); | // 缓存到 Client.mLayers 集合中 //frameworks/native/services/surfaceflinger/Client.h | client-&gt;attachLayer(handle, layer); | // 请求 sf-vsync,这里的代码和 SurfaceFlinger::commitCreatedLayers() 以及 mCreatedLayers 是相关联的，具体见 SurfaceFlinger 章节 | setTransactionFlags(eTransactionNeeded);| *outLayerId = layer-&gt;sequence;| return result;","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/6.PowerManagerService启动流程和核心方法/","text":"PowerManagerService(简称PMS)主要是负责协调、管理设备CPU资源，并提供功能接口给应用框架层或应用层申请获取CPU资源的一个服务，例如：亮灭屏、关机、WakeLock管理、Dreamland(屏保模式)、休眠时间等行为。 1. PMS的启动流程PMS是在SystemServer的startBootstrapServices()中通过SystemServiceManager.startService()启动，很多服务依赖PMS服务，所以它需要尽早的启动并注册到ServiceManage中，所以它在startBootstrapServices()中来启动 frameworks/base/services/java/com/android/server/SystemServer.java private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123; t.traceBegin(&quot;StartPowerManager&quot;); mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); t.traceEnd(); &#125; SystemServiceManager.startService()通过反射拿到PowerManagerService对象 frameworks/base/services/core/java/com/android/server/SystemServiceManager.java public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); final T service; try &#123; //获取类构造方法，构造对应对象 Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); &#125; catch (IllegalAccessException ex) &#123; ... &#125; //调用startService启动服务 startService(service); //返回服务对象 return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; &#125; public void startService(@NonNull final SystemService service) &#123; // Check if already started String className = service.getClass().getName(); mServiceClassnames.add(className); // Register it. //注册服务 mServices.add(service); // Start it. long time = SystemClock.elapsedRealtime(); try &#123; //调用服务的onStart()方法启动服务 service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(&quot;Failed to start service &quot; + service.getClass().getName() + &quot;: onStart threw an exception&quot;, ex); &#125; warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;); &#125; 将服务加入mServices列表中，然后调用服务的onStart()方法，mServices列表是管理着所有需要接收系统启动过程中生命周期的服务 1.1 PowerManagerService构造方法frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java public PowerManagerService(Context context) &#123; this(context, new Injector()); //内部类Injector对象，管理创建其他对象 &#125; PowerManagerService(Context context, Injector injector) &#123; super(context); mContext = context; mBinderService = new BinderService(); //用于IPC交互, BinderService 继承于 IPowerManager.Stub mLocalService = new LocalService(); //用户跨线程交互(SystemServer进程内部) //创建一个NativeWrapper对象，管理所有的native交互 mNativeWrapper = injector.createNativeWrapper(); //创建SystemPropertiesWrapper对象，用于获取系统属性等信息 mSystemProperties = injector.createSystemPropertiesWrapper(); mClock = injector.createClock(); //内部类Injector对象，管理创建其他对象 mInjector = injector; //创建PMS主线程，优先级为DISPLAY级别 mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_DISPLAY, /* allowIo= */ false); mHandlerThread.start(); //启动主线程 //创建PMS主线程Handler mHandler = injector.createHandler(mHandlerThread.getLooper(), new PowerManagerHandlerCallback()); //用于管理Settings.Global下的常量 mConstants = new Constants(mHandler); //创建AmbientDisplayConfiguration对象，管理一些显示配置，如AOD mAmbientDisplayConfiguration = mInjector.createAmbientDisplayConfiguration(context); //创建AmbientDisplaySuppressionController对象，用于管理AmbientDisplay显示相关，和AOD显示有关 mAmbientDisplaySuppressionController = mInjector.createAmbientDisplaySuppressionController(context); //创建AttentionDetector对象，用来检查用户活动是否需要再更新 mAttentionDetector = new AttentionDetector(this::onUserAttention, mLock); mFaceDownDetector = new FaceDownDetector(this::onFlip); mScreenUndimDetector = new ScreenUndimDetector(); //创建BatterySavingStats对象，用来记录电池耗电率 mBatterySavingStats = new BatterySavingStats(mLock); //创建BatterySaverPolicy对象，管理一些省电策略 mBatterySaverPolicy = mInjector.createBatterySaverPolicy(mLock, mContext, mBatterySavingStats); //创建BatterySaverController对象，管理省电策略的切换 mBatterySaverController = mInjector.createBatterySaverController(mLock, mContext, mBatterySaverPolicy, mBatterySavingStats); //创建BatterySaverStateMachine对象，负责省电策略的开启/关闭 mBatterySaverStateMachine = mInjector.createBatterySaverStateMachine(mLock, mContext, mBatterySaverController); mLowPowerStandbyController = mInjector.createLowPowerStandbyController(mContext, Looper.getMainLooper()); mInattentiveSleepWarningOverlayController = mInjector.createInattentiveSleepWarningController(); mAppOpsManager = injector.createAppOpsManager(mContext); mPowerGroupWakefulnessChangeListener = new PowerGroupWakefulnessChangeListener(); ... //获取一些配置初始值 synchronized (mLock) &#123; //创建SuspendBlockerImpl对象，&quot;PowerManagerService.Booting&quot;类型对象负责在开机时负责保活CPU mBootingSuspendBlocker = mInjector.createSuspendBlocker(this, &quot;PowerManagerService.Booting&quot;); //创建SuspendBlockerImpl对象，WakeLock的最终反映，&quot;PowerManagerService.WakeLocks&quot;类型对象负责保活CPU mWakeLockSuspendBlocker = mInjector.createSuspendBlocker(this, &quot;PowerManagerService.WakeLocks&quot;); //创建SuspendBlockerImpl对象，&quot;PowerManagerService.Display&quot;类型对象负责保持屏幕常亮 mDisplaySuspendBlocker = mInjector.createSuspendBlocker(this, &quot;PowerManagerService.Display&quot;); //申请mBootingSuspendBlocker，保持开机启动过程CPU资源 if (mBootingSuspendBlocker != null) &#123; mBootingSuspendBlocker.acquire(); mHoldingBootingSuspendBlocker = true; &#125; //申请mDisplaySuspendBlocker，保持屏幕常亮 if (mDisplaySuspendBlocker != null) &#123; mDisplaySuspendBlocker.acquire(HOLDING_DISPLAY_SUSPEND_BLOCKER); mHoldingDisplaySuspendBlocker = true; &#125; //auto-suspend 模式是否可用 mHalAutoSuspendModeEnabled = false; //是否是可交互状态 mHalInteractiveModeEnabled = true; //设置设备状态为唤醒状态 mWakefulnessRaw = WAKEFULNESS_AWAKE; //静默模式，会控制背光的点亮，使用场景不多 sQuiescent = mSystemProperties.get(SYSTEM_PROPERTY_QUIESCENT, &quot;0&quot;).equals(&quot;1&quot;) || InitProperties.userspace_reboot_in_progress().orElse(false); //mNativeWrapper对象进行native层初始化工作 mNativeWrapper.nativeInit(this); mNativeWrapper.nativeSetAutoSuspend(false); //设置auto suspend状态 mNativeWrapper.nativeSetPowerMode(Mode.INTERACTIVE, true); //设置interactive状态 mNativeWrapper.nativeSetPowerMode(Mode.DOUBLE_TAP_TO_WAKE, false); //设置双击唤醒模式状态 mInjector.invalidateIsInteractiveCaches(); &#125; &#125; 构造方法主要做了几件事： 创建用于IPC的BinderService对象和system_server进程内跨线程交互的LocalService对象； 创建PMS的主线程，并使用该HandlerThread的Looper实例化PowerManagerHandler，将作为PMS主线程Handler进行Message的处理 相关配置参数的读取，如系统配置各种亮度参数 获取了三个Suspend锁对象，SuspendBlocker是一种锁机制，上层申请的wakelock锁在PMS中都会反映为SuspendBlocker锁 通过mNativeWrapper对象和底层进行状态交互 1.2 onStart()中注册发布服务执行完构造方法后接着执行了onStart() frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java @Override public void onStart() &#123; //向ServiceManager进程注册当前服务mBinderService(BinderServic才是PMS的Binder服务端) publishBinderService(Context.POWER_SERVICE, mBinderService, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_DEFAULT | DUMP_FLAG_PRIORITY_CRITICAL); //发布本地服务提供给SystemServer进程中其他组件访问 publishLocalService(PowerManagerInternal.class, mLocalService); //添加watchdog监听 Watchdog.getInstance().addMonitor(this); Watchdog.getInstance().addThread(mHandler); &#125; 这个方法中会进行对PMS的Binder服务和Local服务的注册，BinderService注册后，其他模块中就可以通过ServiceManager获取到对应的Binder对象，进行IPC通信；LocalService注册后，在system_server进程内就可以通过获取LocalService对象跨线程交互。PMS中的BinderService，是继承自IPowerManager.Stub的一个内部类BinderService，IPowerManager.Stub继承自Binder并且实现了IPowerManager，因此，PMS和其他模块的跨进程交互，实际上就是通过PMS.BinderService实现。 Binder服务注册的过程在SystemService中的publishBinderService方法，通过ServiceManager.addService注册： frameworks/base/services/core/java/com/android/server/SystemService.java protected final void publishBinderService(String name, IBinder service, boolean allowIsolated, int dumpPriority) &#123; ServiceManager.addService(name, service, allowIsolated, dumpPriority); &#125; frameworks/base/core/java/android/os/ServiceManager.java public static void addService(String name, IBinder service) &#123; addService(name, service, false, IServiceManager.DUMP_FLAG_PRIORITY_DEFAULT); &#125; 当通过ServiceManager注册后，就可以根据Context.POWER_SERVICE在其他服务中获得服务代理对象，进行跨进程交互了。 LocalService则用于system_server进程内部交互，注册的对象是另一个内部类——继承自PowerManagerInternal的LocalService(带有Internal的类一般都在System进程内使用)。Local Service的注册是在LocalServices中进行，其注册方法如下： frameworks/base/services/core/java/com/android/server/SystemService.java protected final &lt;T&gt; void publishLocalService(Class&lt;T&gt; type, T service) &#123; LocalServices.addService(type, service); &#125; frameworks/base/core/java/com/android/server/LocalServices.java public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123; synchronized (sLocalServiceObjects) &#123; if (sLocalServiceObjects.containsKey(type)) &#123; throw new IllegalStateException(&quot;Overriding service registration&quot;); &#125; sLocalServiceObjects.put(type, service); //添加到sLocalServiceObjects容器中 &#125; &#125; 1.3 onBootPhase()进行各个启动阶段的处理回到SytemServer中，startBootstrapServices()方法中PMS的实例化和注册流程执行完成了，接下来会开始执行SystemService的生命周期，会开始执行SystemServiceManager.onBootPhase()，这个方法为所有的已进行实例化和注册的服务(通过前面的startService启动的服务)设置启动阶段，以便在不同的启动阶段进行不同的工作，方法如下： frameworks/base/services/core/java/com/android/server/SystemServiceManager.java public void startBootPhase(@NonNull TimingsTraceAndSlog t, int phase) &#123; mCurrentPhase = phase; try &#123; final int serviceLen = mServices.size(); for (int i = 0; i &lt; serviceLen; i++) &#123; final SystemService service = mServices.get(i); try &#123; service.onBootPhase(mCurrentPhase); &#125; catch (Exception ex) &#123; ... &#125; &#125; &#125; finally &#123; t.traceEnd(); &#125; if (phase == SystemService.PHASE_BOOT_COMPLETED) &#123; final long totalBootTime = SystemClock.uptimeMillis() - mRuntimeStartUptime; t.logDuration(&quot;TotalBootTime&quot;, totalBootTime); SystemServerInitThreadPool.shutdown(); &#125; &#125; 在SystemServiceManager#startBootPhase()中，通过在SystemServiceManager中传入不同的形参，遍历SystemServiceManager#mServices列表，调用各个SystemService#onBootPhase(int)方法，根据参数在方法实现中完成不同的工作。在SystemService中定义了七个代表启动阶段的参数： PHASE_WAIT_FOR_DEFAULT_DISPLAY：第一个启动阶段，用于在启动PKMS之前，需要确保已经存在默认逻辑屏，只有DisplayManagerService使用该阶段；PHASE_LOCK_SETTINGS_READY：第二个启动阶段，该阶段的执行，意味这Lock Pattern&#x2F;Password相关服务已经准备完毕，只有DisplayManagerService使用该阶段；PHASE_SYSTEM_SERVICES_READY：第三个启动阶段，该阶段的执行，意味这其他服务可以安全地使用核心系统服务;PHASE_DEVICE_SPECIFIC_SERVICES_READY：第四个启动阶段，该阶段的执行，意味这其他服务可以安全地使用设备指定的一些系统服务，这些服务在config_deviceSpecificSystemServices中进行配置;PHASE_ACTIVITY_MANAGER_READY：第五个启动阶段，该阶段的执行，意味这其他AMS组件已经启动完成，可以进行广播操作;PHASE_THIRD_PARTY_APPS_CAN_START：第六个启动阶段，该阶段的执行，意味这系统可以启动APP，并可以进行service的bind&#x2F;start操作了；PHASE_BOOT_COMPLETED：第六个启动阶段，该阶段的执行，意味这启动完成，Home应用也已经启动完成，并且可以和设备进行交互了。 PMS#onBootPhase()方法只对以上的3个阶段做了处理： frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java @Override public void onBootPhase(int phase) &#123; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; systemReady(); //如果是PHASE_SYSTEM_SERVICES_READY阶段则调用PMS的systemReady() &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123; //统计系统启动次数，adb shell settings get global boot_count可查看 incrementBootCount(); &#125; else if (phase == PHASE_BOOT_COMPLETED) &#123; synchronized (mLock) &#123; final long now = mClock.uptimeMillis(); mBootCompleted = true; //表示启动完成 mDirty |= DIRTY_BOOT_COMPLETED; //最重要的标志位 //执行BatterySaverStateMachine.onBootCompleted() mBatterySaverStateMachine.onBootCompleted(); //更新用户活动时间 userActivityNoUpdateLocked( now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID); //更新全局状态信息 updatePowerStateLocked(); if (sQuiescent) &#123; sleepPowerGroupLocked(mPowerGroups.get(Display.DEFAULT_DISPLAY_GROUP), mClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_QUIESCENT, Process.SYSTEM_UID); &#125; //注册DeviceStateManager服务的回调接口 mContext.getSystemService(DeviceStateManager.class).registerCallback( new HandlerExecutor(mHandler), new DeviceStateListener()); &#125; &#125; &#125; mDirty是一个二进制的标记位，用来表示电源状态哪一部分发生了改变，通过对其进行置位（|操作）、清零（～操作），得到二进制数各个位的值(0或1)，进行不同的处理，这个变量非常重要。最后，调用updatePowerStateLocked()方法，这是整个PMS中最重要的方法，会在下面进行详细分析。此时，启动过程中SystemService的生命周期方法全部执行完毕。 1.4 sytemReady()当onBootPhase处于PHASE_SYSTEM_SERVICES_READY阶段时，执行sytemReady() private void systemReady() &#123; //方法太长了 &#125; 这个方法中主要做了以下几个操作，方法太长了相关方法代码就不再粘贴: 获取各类本地服务和远程服务，如Dreamland服务(DreamMangerService)、窗口服务(PhoneWindowManager)、电池状态监听(BatteryService)等服务；注册用于和其他SytemService交互的广播；调用updateSettingsLocked()方法更新Settings中值的变化；调用readConfigurationLocked()方法读取配置文件中的默认值；注册SettingsObserver监听； 到此为止，PMS的启动过程完成。 2. 核心方法updatePowerStateLocked()updatePowerStateLocked()方法是整个PMS模块的核心方法，也是整个PSM中最重要的一个方法，它用来更新整个Power状态。当Power状态发生改变时，如亮灭屏、电池状态改变、暗屏、WakeLock锁申请&#x2F;释放…都会调用该方法，并调用其他同级方法进行各个状态的更新： frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java private void updatePowerStateLocked() &#123; if (!mSystemReady || mDirty == 0 || mUpdatePowerStateInProgress) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_POWER, &quot;updatePowerState&quot;); mUpdatePowerStateInProgress = true; try &#123; // Phase 0: Basic state updates. 基本状态的更新 updateIsPoweredLocked(mDirty); //更新充电状态 updateStayOnLocked(mDirty); //更新当前是否为屏幕常亮状态，由mStayOn控制 updateScreenBrightnessBoostLocked(mDirty); //更新是否需要增强亮度变量 // Phase 1: Update wakefulness. 更新唤醒状态 // Loop because the wake lock and user activity computations are influenced // by changes in wakefulness. // 循环是因为唤醒锁和用户活动计算受到唤醒状态变化的影响。 final long now = mClock.uptimeMillis(); int dirtyPhase2 = 0; for (;;) &#123; // 循环进行更新流程，直到updateWakefulnessLocked()返回false int dirtyPhase1 = mDirty; dirtyPhase2 |= dirtyPhase1; mDirty = 0; //清空标记 // 更新用于统计wakelock的标记值mWakeLockSummary属性 updateWakeLockSummaryLocked(dirtyPhase1); // 更新用于统计用户活动状态的标记值mUserActivitySummary属性 updateUserActivitySummaryLocked(now, dirtyPhase1); // 更新细微模式状态 updateAttentiveStateLocked(now, dirtyPhase1); // 更新唤醒状态，如果状态改变返回true if (!updateWakefulnessLocked(dirtyPhase1)) &#123; break; &#125; &#125; // Phase 2: Lock profiles that became inactive/not kept awake. updateProfilesLocked(now); // Phase 3: Update power state of all PowerGroups. 更新PowerGroups状态 final boolean powerGroupsBecameReady = updatePowerGroupsLocked(dirtyPhase2); // Phase 4: Update dream state (depends on power group ready signal). 更新Dreamland状态 updateDreamLocked(dirtyPhase2, powerGroupsBecameReady); // Phase 5: Send notifications, if needed. 如果wakefulness改变，做最后的收尾工作 finishWakefulnessChangeIfNeededLocked(); // Phase 6: Update suspend blocker. // Because we might release the last suspend blocker here, we need to make sure // we finished everything else first! 更新SuspendBlocker锁状态 updateSuspendBlockerLocked(); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_POWER); mUpdatePowerStateInProgress = false; &#125; &#125; 下面对以上内容中所有方法逐个进行分析 2.1 updateIsPoweredLocked()更新充电状态这个方法用于更新mIsPowered属性，它代表当前的充电状态。插拔USB点亮屏幕功能的逻辑，就是在这个方法中。该方法如下： private void updateIsPoweredLocked(int dirty) &#123; if ((dirty &amp; DIRTY_BATTERY_STATE) != 0) &#123; // 记录旧值 final boolean wasPowered = mIsPowered; final int oldPlugType = mPlugType; // 获取新值 mIsPowered = mBatteryManagerInternal.isPowered(BatteryManager.BATTERY_PLUGGED_ANY); mPlugType = mBatteryManagerInternal.getPlugType(); mBatteryLevel = mBatteryManagerInternal.getBatteryLevel(); mBatteryLevelLow = mBatteryManagerInternal.getBatteryLevelLow(); // 当充电状态发生变化 if (wasPowered != mIsPowered || oldPlugType != mPlugType) &#123; mDirty |= DIRTY_IS_POWERED; // 设置标记位DIRTY_IS_POWERED // 更新无线充电状态 final boolean dockedOnWirelessCharger = mWirelessChargerDetector.update( mIsPowered, mPlugType); final long now = mClock.uptimeMillis(); // 插拔USB是否需要亮屏 if (shouldWakeUpWhenPluggedOrUnpluggedLocked(wasPowered, oldPlugType, dockedOnWirelessCharger)) &#123; // 亮屏流程 wakePowerGroupLocked(mPowerGroups.get(Display.DEFAULT_DISPLAY_GROUP), now, PowerManager.WAKE_REASON_PLUGGED_IN, &quot;android.server.power:PLUGGED:&quot; + mIsPowered, Process.SYSTEM_UID, mContext.getOpPackageName(), Process.SYSTEM_UID); &#125; // 更新用户活动时间 userActivityNoUpdateLocked(mPowerGroups.get(Display.DEFAULT_DISPLAY_GROUP), now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID); // 播放充电提示音和动画 if (mBootCompleted) &#123; //只有在开机完成后才允许播放充电提示声 if (mIsPowered &amp;&amp; !BatteryManager.isPlugWired(oldPlugType) &amp;&amp; BatteryManager.isPlugWired(mPlugType)) &#123; mNotifier.onWiredChargingStarted(mUserId); &#125; else if (dockedOnWirelessCharger) &#123; mNotifier.onWirelessChargingStarted(mBatteryLevel, mUserId); &#125; &#125; &#125; //将充电状态更新到BatterySaverStateMachine mBatterySaverStateMachine.setBatteryStatus(mIsPowered, mBatteryLevel, mBatteryLevelLow); &#125; &#125; 只有对mDirty设置了DIRTY_BATTERY_STATE标记时才会进入这个方法中，那么DIRTY_BATTERY_STATE在什么时候会设置呢？一是当PMS执行systemReady()时，二是当电池信息变化后，由healthd模块上报给BatteryService，BatteryService中则会发出广播Intent.ACTION_BATTERY_CHANGED来通知其他组件，PMS中会接收这个广播并作出处理： frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java final class BatteryReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; synchronized (mLock) &#123; handleBatteryStateChangedLocked(); &#125; &#125; &#125; private void handleBatteryStateChangedLocked() &#123; mDirty |= DIRTY_BATTERY_STATE; updatePowerStateLocked(); &#125; 因此，只要电池状态发生变化，就会执行这个方法。在这个方法中： 首先，更新一些如mIsPowered等全局变量。 然后，通过shouldWakeUpWhenPluggedOrUnpluggedLocked()方法判断是否需要亮屏，这就是插拔USB点亮屏幕功能的逻辑。 接下来，执行userActivityNoUpdateLocked()方法更新用户活动时间，这个时间决定了何时会自动灭屏，用户每次操作手机(触摸、按键、Other)都会更新到当前时间，用户最后活动时间 + 设置自动休眠时间 &#x3D; 最终自动灭屏的时间点，这个方法会在后面部分分析。 再接下来，则调用Notifier对象播放插拔USB音效或动画，Notifier类是PMS模块中用于发送广播、异步通知其他组件的一个类。 最后，将充电状态传递给mBatterySaverStateMachine中，进行省电策略的调整。 2.2 updateStayOnLocked()更新屏幕常亮状态这个方法用来更新全局变量mStayOn的值，如果把”开发者选项—不锁定屏幕”这个选项开启后，则在充电时将保持常亮不会自动休眠： frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java private void updateStayOnLocked(int dirty) &#123; if ((dirty &amp; (DIRTY_BATTERY_STATE | DIRTY_SETTINGS)) != 0) &#123; final boolean wasStayOn = mStayOn; if (mStayOnWhilePluggedInSetting != 0 &amp;&amp; !isMaximumScreenOffTimeoutFromDeviceAdminEnforcedLocked()) &#123; // 如果任意方式充电(AC/USB/wireless)，返回true mStayOn = mBatteryManagerInternal.isPowered(mStayOnWhilePluggedInSetting); &#125; else &#123; mStayOn = false; &#125; // 状态发生变化时，向mDirty设置DIRTY_STAY_ON标记 if (mStayOn != wasStayOn) &#123; mDirty |= DIRTY_STAY_ON; &#125; &#125; &#125; 只有mDirty设置了DIRTY_BATTERY_STATE或DIRTY_SETTINGS标记位后，才会执行该方法。DIRTY_BATTERY_STATE在电池状态发生变化后设置，DIRTY_SETTINGS是在Settings中的值发生变化后设置，mStayOnWhilePluggedInSetting就是从来自于Settings中”不锁定屏幕”的值，如果发生变化，且处于充电状态，则会更新mStayOn变量的值。在自动灭屏流程中，一旦mStayOn值为true，则永远不会灭屏，从而实现了“不锁定屏幕”这个功能。 2.3 updateScreenBrightnessBoostLocked()更新是否增强亮度这个方法会更新表示增强亮度的全局变量mScreenBrightnessBoostInProgress，PMS.BinderService提供了boostScreenBrightness()方法，允许其他组件通过该接口将亮度调节到最大(短时间保持)，并保持5s后恢复： private void updateScreenBrightnessBoostLocked(int dirty) &#123; if ((dirty &amp; DIRTY_SCREEN_BRIGHTNESS_BOOST) != 0) &#123; if (mScreenBrightnessBoostInProgress) &#123; final long now = mClock.uptimeMillis(); mHandler.removeMessages(MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT); if (mLastScreenBrightnessBoostTime &gt; mLastGlobalSleepTime) &#123; final long boostTimeout = mLastScreenBrightnessBoostTime + SCREEN_BRIGHTNESS_BOOST_TIMEOUT; // 向主线程mHandler发出一个异步消息，5s后会再次更新 if (boostTimeout &gt; now) &#123; Message msg = mHandler.obtainMessage(MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, boostTimeout); return; &#125; &#125; // 表示增强亮度结束 mScreenBrightnessBoostInProgress = false; // 更新用户活动时间 userActivityNoUpdateLocked(now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID); &#125; &#125; &#125; 只有当mDirty设置了DIRTY_SCREEN_BRIGHTNESS_BOOST标记时，才会执行这个方法。这个标记位就是通过boostScreenBrightness()设置，这个功能在Google原生逻辑中有一个使用场景： // frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java //是否开启双击Power键定制行为(例如双击打开NFC,相机等) mDoublePressOnPowerBehavior = mContext.getResources().getInteger( com.android.internal.R.integer.config_doublePressOnPowerBehavior); // must match: config_doublePressOnPowerBehavior in config.xml static final int MULTI_PRESS_POWER_NOTHING = 0; //默认无 static final int MULTI_PRESS_POWER_THEATER_MODE = 1; //剧场模式 static final int MULTI_PRESS_POWER_BRIGHTNESS_BOOST = 2; //双击电源键会将亮度调到最大 static final int MULTI_PRESS_POWER_LAUNCH_TARGET_ACTIVITY = 3; //双击打开特定应用 2.4 updateWakeLockSummaryLocked()更新WakeLock统计值从这个方法开始到，直到updateWakefulnessLocked()结束，将会在一个for循环中执行。该方法用来更新mWakeLockSummary属性，它是用来记录所有WakeLock锁状态的状态值，代表了所有的WakeLock，在请求Display状时作为判断条件确定具体的请求状态。系统规定了系统休眠状态对WakeLock锁的使用影响，如当系统休眠后，常亮锁(PowerManager.SCREEN_BRIGHT等)将会被忽略；系统唤醒后，Doze锁(PowerManager.DOZE_WAKE_LOCK等）将会被忽略： private void updateWakeLockSummaryLocked(int dirty) &#123; if ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_WAKEFULNESS | DIRTY_DISPLAY_GROUP_WAKEFULNESS)) != 0) &#123; mWakeLockSummary = 0; //初始值为0 // 将每个ProfilePowerState的mWakeLockSummary也进行重置 final int numProfiles = mProfilePowerState.size(); for (int i = 0; i &lt; numProfiles; i++) &#123; mProfilePowerState.valueAt(i).mWakeLockSummary = 0; &#125; // 将每个mPowerGroups的setWakeLockSummaryLocked也进行重置 for (int idx = 0; idx &lt; mPowerGroups.size(); idx++) &#123; mPowerGroups.valueAt(idx).setWakeLockSummaryLocked(0); &#125; int invalidGroupWakeLockSummary = 0; final int numWakeLocks = mWakeLocks.size(); // 遍历mWakeLocks列表 for (int i = 0; i &lt; numWakeLocks; i++) &#123; final WakeLock wakeLock = mWakeLocks.get(i); final Integer groupId = wakeLock.getPowerGroupId(); // a wakelock with an invalid group ID should affect all groups if (groupId == null || (groupId != Display.INVALID_DISPLAY_GROUP &amp;&amp; !mPowerGroups.contains(groupId))) &#123; continue; &#125; final PowerGroup powerGroup = mPowerGroups.get(groupId); // 获取每个WakeLock对应的Flag标记 final int wakeLockFlags = getWakeLockSummaryFlags(wakeLock); // 标记在mWakeLockSummary上 mWakeLockSummary |= wakeLockFlags; if (groupId != Display.INVALID_DISPLAY_GROUP) &#123; int wakeLockSummary = powerGroup.getWakeLockSummaryLocked(); wakeLockSummary |= wakeLockFlags; powerGroup.setWakeLockSummaryLocked(wakeLockSummary); &#125; else &#123; invalidGroupWakeLockSummary |= wakeLockFlags; &#125; // 对每个ProfilePowerState#mWakeLockSummary也进行标记 for (int j = 0; j &lt; numProfiles; j++) &#123; final ProfilePowerState profile = mProfilePowerState.valueAt(j); if (wakeLockAffectsUser(wakeLock, profile.mUserId)) &#123; profile.mWakeLockSummary |= wakeLockFlags; &#125; &#125; &#125; for (int idx = 0; idx &lt; mPowerGroups.size(); idx++) &#123; final PowerGroup powerGroup = mPowerGroups.valueAt(idx); final int wakeLockSummary = adjustWakeLockSummary(powerGroup.getWakefulnessLocked(), invalidGroupWakeLockSummary | powerGroup.getWakeLockSummaryLocked()); powerGroup.setWakeLockSummaryLocked(wakeLockSummary); &#125; // 根据系统状态对mWakeLockSummary进行调整 mWakeLockSummary = adjustWakeLockSummary(getGlobalWakefulnessLocked(), mWakeLockSummary); // 对每个ProfilePowerState#mWakeLockSummary也进行调整 for (int i = 0; i &lt; numProfiles; i++) &#123; final ProfilePowerState profile = mProfilePowerState.valueAt(i); profile.mWakeLockSummary = adjustWakeLockSummary(getGlobalWakefulnessLocked(), profile.mWakeLockSummary); &#125; &#125; &#125; 只有当mDirty设置了DIRTY_WAKE_LOCKS和DIRTY_WAKEFULNESS标记位时，才会执行该方法。DIRTY_WAKE_LOCKS在申请WakeLock锁时设置，DIRTY_WAKEFULNESS在系统唤醒状态发生变化时设置。进入该方法后，首先从保存了WakeLock的List中进行遍历，并根据WakeLock类型给mWakeLockSummary设置标记，这些标记位如下: // frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java // Summarizes the state of all active wakelocks. static final int WAKE_LOCK_CPU = 1 &lt;&lt; 0; // 表示需要CPU保持唤醒状态 static final int WAKE_LOCK_SCREEN_BRIGHT = 1 &lt;&lt; 1; // 表示持有FULL_WAKE_LOCK锁，需要屏幕常亮 static final int WAKE_LOCK_SCREEN_DIM = 1 &lt;&lt; 2; // 表示持有SCREEN_DIM_WAKE_LOCK锁，需要保持dim不灭屏 static final int WAKE_LOCK_BUTTON_BRIGHT = 1 &lt;&lt; 3; //表示持有FULL_WAKE_LOCK锁，需要按键灯常亮 static final int WAKE_LOCK_PROXIMITY_SCREEN_OFF = 1 &lt;&lt; 4; // 表示持有Psensor WakeLock锁 static final int WAKE_LOCK_STAY_AWAKE = 1 &lt;&lt; 5; // only set if already awake // 表示保持屏幕常亮(只能用在awake状态时) static final int WAKE_LOCK_DOZE = 1 &lt;&lt; 6; // 表示持有DOZE_WAKE_LOCK锁 static final int WAKE_LOCK_DRAW = 1 &lt;&lt; 7; //表示持有DRAW_WAKE_LOCK锁 然后将根据系统状态进行调整: // frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java private static int adjustWakeLockSummary(int wakefulness, int wakeLockSummary) &#123; // Cancel wake locks that make no sense based on the current state. // 唤醒状态不处于Doze状态时，忽略掉PowerManager.DOZE_WAKE_LOCK和PowerManager.DRAW_WAKE_LOCK两类型锁 if (wakefulness != WAKEFULNESS_DOZING) &#123; wakeLockSummary &amp;= ~(WAKE_LOCK_DOZE | WAKE_LOCK_DRAW); &#125; // 唤醒状态处于Asleep状态或者Doze状态时，忽略掉屏幕常亮锁、PSensor锁 if (wakefulness == WAKEFULNESS_ASLEEP || (wakeLockSummary &amp; WAKE_LOCK_DOZE) != 0) &#123; wakeLockSummary &amp;= ~(WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM | WAKE_LOCK_BUTTON_BRIGHT); if (wakefulness == WAKEFULNESS_ASLEEP) &#123; wakeLockSummary &amp;= ~WAKE_LOCK_PROXIMITY_SCREEN_OFF; &#125; &#125; // Infer implied wake locks where necessary based on the current state. if ((wakeLockSummary &amp; (WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM)) != 0) &#123; // 唤醒状态处于Awake状态，WAKE_LOCK_STAY_AWAKE只用于awake状态时 if (wakefulness == WAKEFULNESS_AWAKE) &#123; wakeLockSummary |= WAKE_LOCK_CPU | WAKE_LOCK_STAY_AWAKE; &#125; else if (wakefulness == WAKEFULNESS_DREAMING) &#123; // 唤醒状态处于Awake状态，WAKE_LOCK_STAY_AWAKE只用于awake状态时 wakeLockSummary |= WAKE_LOCK_CPU; &#125; &#125; // 有DRAW_WAKE_LOCK锁时，需要CPU保持唤醒 if ((wakeLockSummary &amp; WAKE_LOCK_DRAW) != 0) &#123; wakeLockSummary |= WAKE_LOCK_CPU; &#125; return wakeLockSummary; &#125; 在平时分析处理不灭屏相关Bug时，通过该值可确定当前系统持有哪些类型的锁。 最终得到mWakeLockSummary，在自动灭屏流程中将使用起到重要作用，当自动灭屏时，如果mWakeLockSummary设置有WAKE_LOCK_STAY_AWAKE标记位，那么将不会灭屏。此外，上面方法中出现了对ProfilePowerState对象的处理，它用来对不同user进行不同参数的设置，在多用户模式下，可以支持不同的状态，这部分略去。 2.5 updateUserActivitySummaryLocked()更新用户活动状态这个方法用来更新全局变量mUserActivitySummary，它表示用户活动状态，有三个值: // Summarizes the user activity state. static final int USER_ACTIVITY_SCREEN_BRIGHT = 1 &lt;&lt; 0; // 表示亮屏状态下的交互 static final int USER_ACTIVITY_SCREEN_DIM = 1 &lt;&lt; 1; // 表示Dim状态下的交互 static final int USER_ACTIVITY_SCREEN_DREAM = 1 &lt;&lt; 2; // 表示Dreamland状态下的交互 何时开始自动灭屏，就是这个方法中实现的。当设备和用户有交互时，都会根据当前时间和自动灭屏时间、Dim时长、当前唤醒状态计算下次休眠的时间，完成自动灭屏的操作。由亮屏进入Dim的时长、Dim到灭屏的时长、亮屏到屏保的时长，都是在这里计算的，这个方法的详细分析见后面的灭屏流程篇。 2.6 updateAttentiveStateLocked()更新细微模式状态这个方法用来更新细微模式状态，这是Android R上新添加的一个功能，其目的就是解决用户长时间没有操作但一直持有亮屏锁导致系统不灭屏这个场景的，算是一个省电优化项，看下是如何实现的： //frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java private void updateAttentiveStateLocked(long now, int dirty) &#123; // 触发细微模式的时间阈值 long attentiveTimeout = getAttentiveTimeoutLocked(); // Attentive state only applies to the default display group. // 自动休眠时间 long goToSleepTime = mPowerGroups.get( Display.DEFAULT_DISPLAY_GROUP).getLastUserActivityTimeLocked() + attentiveTimeout; // 细微模式提示Dialog弹出时间 long showWarningTime = goToSleepTime - mAttentiveWarningDurationConfig; // 是否已经弹出提升对话框 boolean warningDismissed = maybeHideInattentiveSleepWarningLocked(now, showWarningTime); if (attentiveTimeout &gt;= 0 &amp;&amp; (warningDismissed || (dirty &amp; (DIRTY_ATTENTIVE | DIRTY_STAY_ON | DIRTY_SCREEN_BRIGHTNESS_BOOST | DIRTY_PROXIMITY_POSITIVE | DIRTY_WAKEFULNESS | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS)) != 0)) &#123; mHandler.removeMessages(MSG_ATTENTIVE_TIMEOUT); // 是否需要弹出警告 if (isBeingKeptFromInattentiveSleepLocked()) &#123; return; &#125; long nextTimeout = -1; if (now &lt; showWarningTime) &#123; nextTimeout = showWarningTime; &#125; else if (now &lt; goToSleepTime) &#123; // 弹出警告给用户 mInattentiveSleepWarningOverlayController.show(); nextTimeout = goToSleepTime; &#125; // 下一次进入时将会灭屏 if (nextTimeout &gt;= 0) &#123; scheduleAttentiveTimeout(nextTimeout); &#125; &#125; &#125; 这里提供了两个配置值： mAttentiveWarningDurationConfig表示触发细微模式前，弹出警告的时长，到达该时间时，会弹出对话框提示用户是否还要亮屏； mAttentiveTimeoutConfig表示触发细微模式的时间阈值，到达该时长后，会进行自动灭屏；这种情况下，即使没有达到用户设置的自动休眠时间，也会进行自动灭屏。 2.7 updateWakefulnessLocked()是否需要更新唤醒状态这个方法也和自动灭屏流程有关。如果满足自动灭屏条件，会更新系统唤醒状态。这三个方法放在for(;;)循环中执行，是因为它们共同决定了设备的唤醒状态，前两个方法是汇总状态，后一个方法是根据前两个方法汇总的值而进行判断是否要改变当前的设备唤醒状态，汇总状态会受mWakefulness的影响，因此会进行循环处理。同时，也仅仅会在超时灭屏进入睡眠或屏保时，for循环会执行两次，其他情况下，只会执行一次。这个方法的详细分析见PMS灭屏流程。 2.8 updateProfilesLocked()以上几个方法针对全局状态进行更新，这个方法则根据ProfilePowerState中保存的状态，更新不同用户是否进入锁定状态，由于使用场景不是很高，这里暂且略过。 2.9 updatePowerGroupsLocked该方法用于请求并更新Display状态，在这个方法中，会确定多个影响Display状态的属性，并将这些值封装到DisplayPowerRequest对象中，向DisplayMangerService发起请求，最终由DMS完成Display亮度、状态的更新： private boolean updatePowerGroupsLocked(int dirty) &#123; final boolean oldPowerGroupsReady = areAllPowerGroupsReadyLocked(); if ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS | DIRTY_SCREEN_BRIGHTNESS_BOOST | DIRTY_VR_MODE_CHANGED | DIRTY_QUIESCENT | DIRTY_DISPLAY_GROUP_WAKEFULNESS)) != 0) &#123; if ((dirty &amp; DIRTY_QUIESCENT) != 0) &#123; if (areAllPowerGroupsReadyLocked()) &#123; sQuiescent = false; &#125; else &#123; mDirty |= DIRTY_QUIESCENT; &#125; &#125; for (int idx = 0; idx &lt; mPowerGroups.size(); idx++) &#123; final PowerGroup powerGroup = mPowerGroups.valueAt(idx); final int groupId = powerGroup.getGroupId(); // Determine appropriate screen brightness and auto-brightness adjustments. final boolean autoBrightness; // 自动亮度是否开启 final float screenBrightnessOverride; // 是否有覆盖亮度 if (!mBootCompleted) &#123; //启动过程中要求亮度稳定，要求默认亮度和Bootloader中设定的亮度值保持一致 autoBrightness = false; //不开启自动亮度 screenBrightnessOverride = mScreenBrightnessDefault; //使用默认值 &#125; else if (isValidBrightness(mScreenBrightnessOverrideFromWindowManager)) &#123; //使用WindowManager覆盖的亮度值 autoBrightness = false; screenBrightnessOverride = mScreenBrightnessOverrideFromWindowManager; &#125; else &#123; autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC); screenBrightnessOverride = PowerManager.BRIGHTNESS_INVALID_FLOAT; &#125; //向DisplayMangerService发起请 boolean ready = powerGroup.updateLocked(screenBrightnessOverride, autoBrightness, shouldUseProximitySensorLocked(), shouldBoostScreenBrightness(), mDozeScreenStateOverrideFromDreamManager, mDozeScreenBrightnessOverrideFromDreamManagerFloat, mDrawWakeLockOverrideFromSidekick, mBatterySaverPolicy.getBatterySaverPolicy(ServiceType.SCREEN_BRIGHTNESS), sQuiescent, mDozeAfterScreenOff, mIsVrModeEnabled, mBootCompleted, mScreenBrightnessBoostInProgress, mRequestWaitForNegativeProximity); int wakefulness = powerGroup.getWakefulnessLocked(); final boolean displayReadyStateChanged = powerGroup.setReadyLocked(ready); final boolean poweringOn = powerGroup.isPoweringOnLocked(); if (ready &amp;&amp; displayReadyStateChanged &amp;&amp; poweringOn &amp;&amp; wakefulness == WAKEFULNESS_AWAKE) &#123; powerGroup.setIsPoweringOnLocked(false); LatencyTracker.getInstance(mContext).onActionEnd(ACTION_TURN_ON_SCREEN); Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, TRACE_SCREEN_ON, groupId); final int latencyMs = (int) (mClock.uptimeMillis() - powerGroup.getLastPowerOnTimeLocked()); // 如果亮屏流程超过200ms，输出亮屏所用时间 if (latencyMs &gt;= SCREEN_ON_LATENCY_WARNING_MS) &#123; Slog.w(TAG, &quot;Screen on took &quot; + latencyMs + &quot; ms&quot;); &#125; &#125; &#125; // 释放PSensor WakeLock锁时的一个标记 mRequestWaitForNegativeProximity = false; &#125; return areAllPowerGroupsReadyLocked() &amp;&amp; !oldPowerGroupsReady; &#125; boolean updateLocked(float screenBrightnessOverride, boolean autoBrightness, boolean useProximitySensor, boolean boostScreenBrightness, int dozeScreenState, float dozeScreenBrightness, boolean overrideDrawWakeLock, PowerSaveState powerSaverState, boolean quiescent, boolean dozeAfterScreenOff, boolean vrModeEnabled, boolean bootCompleted, boolean screenBrightnessBoostInProgress, boolean waitForNegativeProximity) &#123; // 根据系统唤醒状态获取请求的&#39;策略&#39;： off, doze, dim or bright. mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked(quiescent, dozeAfterScreenOff, vrModeEnabled, bootCompleted, screenBrightnessBoostInProgress); // WindowManager覆盖的亮度值，如播放视频时调节亮度 mDisplayPowerRequest.screenBrightnessOverride = screenBrightnessOverride; // 是否使用自动亮度 mDisplayPowerRequest.useAutoBrightness = autoBrightness; // 是否存在PSensor Wakelock锁 mDisplayPowerRequest.useProximitySensor = useProximitySensor; // 是否有增强亮度 mDisplayPowerRequest.boostScreenBrightness = boostScreenBrightness; // 唤醒状态为Doze时，确定display的状态 if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DOZE) &#123; mDisplayPowerRequest.dozeScreenState = dozeScreenState; if ((getWakeLockSummaryLocked() &amp; WAKE_LOCK_DRAW) != 0 &amp;&amp; !overrideDrawWakeLock) &#123; if (mDisplayPowerRequest.dozeScreenState == Display.STATE_DOZE_SUSPEND) &#123; mDisplayPowerRequest.dozeScreenState = Display.STATE_DOZE; &#125; if (mDisplayPowerRequest.dozeScreenState == Display.STATE_ON_SUSPEND) &#123; mDisplayPowerRequest.dozeScreenState = Display.STATE_ON; &#125; &#125; // Doze时的屏幕亮度 mDisplayPowerRequest.dozeScreenBrightness = dozeScreenBrightness; &#125; else &#123; mDisplayPowerRequest.dozeScreenState = Display.STATE_UNKNOWN; mDisplayPowerRequest.dozeScreenBrightness = PowerManager.BRIGHTNESS_INVALID_FLOAT; &#125; mDisplayPowerRequest.lowPowerMode = powerSaverState.batterySaverEnabled; mDisplayPowerRequest.screenLowPowerBrightnessFactor = powerSaverState.brightnessFactor; // 发起请求，返回值表示DisplayPowerController中是否完成这次请求 boolean ready = mDisplayManagerInternal.requestPowerState(mGroupId, mDisplayPowerRequest, waitForNegativeProximity); mNotifier.onScreenPolicyUpdate(mGroupId, mDisplayPowerRequest.policy); return ready; &#125; 在向DisplayManagerService发起请求时，会将所有的信息封装到DisplayPowerRequest对象中，其中，policy属性值有五类： POLICY_OFF：请求屏幕进入灭屏状态； POLICY_DOZE：请求屏幕进入Doze状态； POLICY_DIM：请求屏幕进入Dim状态， POLICY_BRIGHT：请求屏幕处于正常亮屏状态； POLICY_VR：VR模式相关； 在请求前，通过getDesiredScreenPolicyLocked()方法，根据当前唤醒状态和WakeLock统计状态来决定要请求的Display状态： int getDesiredScreenPolicyLocked(boolean quiescent, boolean dozeAfterScreenOff, boolean vrModeEnabled, boolean bootCompleted, boolean screenBrightnessBoostInProgress) &#123; final int wakefulness = getWakefulnessLocked(); final int wakeLockSummary = getWakeLockSummaryLocked(); // 当前唤醒状态为Asleep，则Display状态会设置为OFF if (wakefulness == WAKEFULNESS_ASLEEP || quiescent) &#123; return DisplayPowerRequest.POLICY_OFF; &#125; else if (wakefulness == WAKEFULNESS_DOZING) &#123; // 当前唤醒状态为Doze，则Display状态会设置为Doze指定的状态 if ((wakeLockSummary &amp; WAKE_LOCK_DOZE) != 0) &#123; return DisplayPowerRequest.POLICY_DOZE; &#125; // 表示跳过Doze的状态，直接设置成OFF if (dozeAfterScreenOff) &#123; return DisplayPowerRequest.POLICY_OFF; &#125; // Fall through and preserve the current screen policy if not configured to // doze after screen off. This causes the screen off transition to be skipped. &#125; //如果开启了VR模式则设置为VR模式 if (vrModeEnabled) &#123; return DisplayPowerRequest.POLICY_VR; &#125; // 如果存在亮屏锁、用户活动状态为亮屏、进行增强亮度，则Display状态将设置为ON if ((wakeLockSummary &amp; WAKE_LOCK_SCREEN_BRIGHT) != 0 || !bootCompleted || (getUserActivitySummaryLocked() &amp; USER_ACTIVITY_SCREEN_BRIGHT) != 0 || screenBrightnessBoostInProgress) &#123; return DisplayPowerRequest.POLICY_BRIGHT; &#125; // 不满足以上条件，默认设置DIM return DisplayPowerRequest.POLICY_DIM; &#125; 2.10 updateDreamLocked()该方法用来更新设备Dreamland状态，比如是否进入Dream、Doze或者开始休眠: // frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java private void updateDreamLocked(int dirty, boolean powerGroupBecameReady) &#123; if ((dirty &amp; (DIRTY_WAKEFULNESS | DIRTY_USER_ACTIVITY | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_ATTENTIVE | DIRTY_WAKE_LOCKS | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS | DIRTY_IS_POWERED | DIRTY_STAY_ON | DIRTY_PROXIMITY_POSITIVE | DIRTY_BATTERY_STATE)) != 0 || powerGroupBecameReady) &#123; if (areAllPowerGroupsReadyLocked()) &#123; //areAllPowerGroupsReadyLocked为ture后，才会进一步执行 //通过Handler异步发送一个消息 scheduleSandmanLocked(); &#125; &#125; &#125; private boolean areAllPowerGroupsReadyLocked() &#123; final int size = mPowerGroups.size(); for (int i = 0; i &lt; size; i++) &#123; if (!mPowerGroups.valueAt(i).isReadyLocked()) &#123; return false; &#125; &#125; return true; &#125; 可以看到，对于Dreamland相关状态的更新，依赖areAllPowerGroupsReadyLocked的返回值，它表示每一个display是否已经准备就绪，因此只有在准备就绪的情况下才会进一步调用该方法的方法体。最后会PMS主线程中，调用handleSandman()方法执行Dreamland的操作: // frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java private void handleSandman(int groupId) &#123; // runs on handler thread // Handle preconditions. final boolean startDreaming; final int wakefulness; synchronized (mLock) &#123; mSandmanScheduled = false; final PowerGroup powerGroup = mPowerGroups.get(groupId); wakefulness = powerGroup.getWakefulnessLocked(); // 如果召唤了&quot;睡魔&quot;，且每个Display状态已经准备完毕 if ((wakefulness == WAKEFULNESS_DREAMING || wakefulness == WAKEFULNESS_DOZING) &amp;&amp; powerGroup.isSandmanSummonedLocked() &amp;&amp; powerGroup.isReadyLocked()) &#123; // 判断是否可以进入Dreamland startDreaming = canDreamLocked(powerGroup) || canDozeLocked(powerGroup); powerGroup.setSandmanSummonedLocked(/* isSandmanSummoned= */ false); &#125; else &#123; startDreaming = false; &#125; &#125; // Start dreaming if needed. // We only control the dream on the handler thread, so we don&#39;t need to worry about // concurrent attempts to start or stop the dream. final boolean isDreaming; if (mDreamManager != null) &#123; // Restart the dream whenever the sandman is summoned. if (startDreaming) &#123; mDreamManager.stopDream(/* immediate= */ false); // 开始进入Dreamland mDreamManager.startDream(wakefulness == WAKEFULNESS_DOZING); &#125; isDreaming = mDreamManager.isDreaming(); &#125; else &#123; isDreaming = false; &#125; // At this point, we either attempted to start the dream or no attempt will be made, // so stop holding the display suspend blocker for Doze. mDozeStartInProgress = false; // Update dream state. synchronized (mLock) &#123; ... // Remember the initial battery level when the dream started. // 记录下进入Dream模式前的初始电量值 if (startDreaming &amp;&amp; isDreaming) &#123; mBatteryLevelWhenDreamStarted = mBatteryLevel; if (wakefulness == WAKEFULNESS_DOZING) &#123; Slog.i(TAG, &quot;Dozing...&quot;); &#125; else &#123; Slog.i(TAG, &quot;Dreaming...&quot;); &#125; &#125; // If preconditions changed, wait for the next iteration to determine // whether the dream should continue (or be restarted). final PowerGroup powerGroup = mPowerGroups.get(groupId); if (powerGroup.isSandmanSummonedLocked() || powerGroup.getWakefulnessLocked() != wakefulness) &#123; return; // wait for next cycle &#125; // Determine whether the dream should continue. long now = mClock.uptimeMillis(); if (wakefulness == WAKEFULNESS_DREAMING) &#123; if (isDreaming &amp;&amp; canDreamLocked(powerGroup)) &#123; if (mDreamsBatteryLevelDrainCutoffConfig &gt;= 0 &amp;&amp; mBatteryLevel &lt; mBatteryLevelWhenDreamStarted - mDreamsBatteryLevelDrainCutoffConfig &amp;&amp; !isBeingKeptAwakeLocked(powerGroup)) &#123; //充电速度慢于消耗速度或者用户活动timeout已过则退出Dream进入睡眠 &#125; else &#123; return; // continue dreaming 继续维持Dream状态 &#125; &#125; // Dream has ended or will be stopped. Update the power state. // 退出Dreamland,进入休眠状态 if (isItBedTimeYetLocked(powerGroup)) &#123; if (isAttentiveTimeoutExpired(powerGroup, now)) &#123; //更新睡眠状态 sleepPowerGroupLocked(powerGroup, now, PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, Process.SYSTEM_UID); &#125; else &#123; //更新doze状态 dozePowerGroupLocked(powerGroup, now, PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, Process.SYSTEM_UID); &#125; &#125; else &#123; // 唤醒设备 wakePowerGroupLocked(powerGroup, now, PowerManager.WAKE_REASON_DREAM_FINISHED, &quot;android.server.power:DREAM_FINISHED&quot;, Process.SYSTEM_UID, mContext.getOpPackageName(), Process.SYSTEM_UID); &#125; &#125; else if (wakefulness == WAKEFULNESS_DOZING) &#123; if (isDreaming) &#123; return; // continue dozing 继续保持doze状态 &#125; // Doze has ended or will be stopped. Update the power state. // 更新睡眠状态 sleepPowerGroupLocked(powerGroup, now, PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, Process.SYSTEM_UID); &#125; &#125; // Stop dream. if (isDreaming) &#123; mDreamManager.stopDream(/* immediate= */ false); &#125; &#125; 在以上方法中，将会调用DreamManager处理具体的Dreamland逻辑，这部分流程的分析，在DreamManagerService模块分析时会进行详细分析。 2.11 finishWakefulnessChangeIfNeededLocked()该方法主要做唤醒状态发生变化后，后半部分更新工作： //frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java @GuardedBy(&quot;mLock&quot;) private void finishWakefulnessChangeIfNeededLocked() &#123; if (mWakefulnessChanging &amp;&amp; areAllPowerGroupsReadyLocked()) &#123; if (getGlobalWakefulnessLocked() == WAKEFULNESS_DOZING &amp;&amp; (mWakeLockSummary &amp; WAKE_LOCK_DOZE) == 0) &#123; return; // wait until dream has enabled dozing &#125; else &#123; // Doze wakelock acquired (doze started) or device is no longer dozing. mDozeStartInProgress = false; &#125;Android采码蜂: if (getGlobalWakefulnessLocked() == WAKEFULNESS_DOZING || getGlobalWakefulnessLocked() == WAKEFULNESS_ASLEEP) &#123; logSleepTimeoutRecapturedLocked(); &#125; mWakefulnessChanging = false; mNotifier.onWakefulnessChangeFinished(); &#125; &#125; 只有当屏幕状态改变后，才会执行该方法。进入该方法后，将通过Notifier#onWakefulnessChangeFinished()方法发送亮屏、灭屏广播等。 该方法中的logScreenOn()方法将打印出整个亮屏流程的耗时，在平时处理问题时很有帮助。 2.12 updateSuspendBlockerLocked()这个方法用来更新SuspendBlocker锁状态。Suspend锁机制是Android框架中锁机的一种锁，它代表了框架层以上所有的WakeLock。Wakelock锁是APP或其他组建向PMS模块申请，而Suspend锁是PMS模块中对WakeLock锁的最终表现，或者说上层应用或system_server其他组件申请了wakelock锁后，在PMS中最终都会表现为Suspend锁，通过Suspend锁向Hal层写入节点，Kernal层会读取节点，从而唤醒或者休眠CPU。该方法的详细分析在PMS WakeLock机制中进行汇总。到此为止，对PMS中所有核心方法进行了简单的分析，有些方法仅仅说明了下作用，会在后面具体业务中进行详细分析。 跟着学习自： Android R PowerManagerService模块(1) 启动流程和核心方法","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/InPutManagerService/5.触摸事件在应用进程的分发和处理/","text":"前面我们已经梳理了input事件在native层的传递，这一篇我们接着探索input事件在应用中的传递与处理，我们将按键事件和触摸事件分开梳理，这一篇就只涉及触摸事件。 一、事件的接收从前面的篇幅我们知道，framework native层InputDispatcher向应用通过socket方式发送事件,应用的Looper 通过epoll方式监听sockcet的fd, 当应用的socket变为可读时（例如，inputDispatcher向socket中写入数据），Looper将回调handleEvent。 此时，应用应读取已进入套接字的事件。 只要socket中有未读事件，函数 handleEvent 就会继续触发。 NativeInputEventReceiver::handleEvent12345678910111213141516171819202122232425262728293031//frameworks/base/core/jni/android_view_InputEventReceiver.cppint NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; // Allowed return values of this function as documented in LooperCallback::handleEvent constexpr int REMOVE_CALLBACK = 0; constexpr int KEEP_CALLBACK = 1; //注意：下面这个event不是真正的输入事件，只是Looper的event if (events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) &#123; //当inputdispatcher异常导致socket被关闭或者目标窗口正在被移除或者传递窗口时输入法，但是输入法正在关闭时会直接抛弃这个事件 return REMOVE_CALLBACK; &#125; //如果是传入的事件，即是inputDispatcher传递过来的事件时需要处理时 //回调java层的consumeEvents方法 if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, nullptr); mMessageQueue-&gt;raiseAndClearException(env, &quot;handleReceiveCallback&quot;); return status == OK || status == NO_MEMORY ? KEEP_CALLBACK : REMOVE_CALLBACK; &#125; //如果是要传出的事件，即已处理的事件需要告知inputdispatcher这个事件已处理时 if (events &amp; ALOOPER_EVENT_OUTPUT) &#123; const status_t status = processOutboundEvents(); if (status == OK || status == WOULD_BLOCK) &#123; return KEEP_CALLBACK; &#125; else &#123; return REMOVE_CALLBACK; &#125; &#125; return KEEP_CALLBACK;&#125; 这里既会监视inputDispatcher发送过来的事件（准确的说应该是InputPublisher发过来的）也监视当前进程发送已经消费的事件发给Looper的行为，无论是接收来自InputPublisher的事件，还是来自当前进程的事件，都会被looper监听到并回调handleEvent。这里就用events中的标志位来区分（ALOOPER_EVENT_INPUT和ALOOPER_EVENT_OUTPUT）对于接收来自InputPublisher的事件则调consumeEvents方法处理. NativeInputEventReceiver::consumeEvents//frameworks/base/core/jni/android_view_InputEventReceiver.cpp status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ... ScopedLocalRef&lt;jobject&gt; receiverObj(env, nullptr); bool skipCallbacks = false; for (;;) &#123; uint32_t seq; InputEvent* inputEvent; //获取mInputConsumer发过来的事件，并构建成具体的某种InputEvent，例如MotionEvent status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); if (status != OK &amp;&amp; status != WOULD_BLOCK) &#123; ALOGE(&quot;channel &#39;%s&#39; ~ Failed to consume input event. status=%s(%d)&quot;, getInputChannelName().c_str(), statusToString(status).c_str(), status); return status; &#125; ... InputConsumer::consume//frameworks/native/libs/input/InputTransport.cpp status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; ... *outSeq = 0; *outEvent = nullptr; // Fetch the next input message. // Loop until an event can be returned or no additional events are received. while (!*outEvent) &#123; //获取到一次真正的事件就退出 if (mMsgDeferred) &#123; ... &#125; else &#123; // Receive a fresh message. status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); //通过InputChannel来接收socket中真正的InputMessage(描述事件的结构体) ... &#125; ... &#125; &#125; return OK; &#125; InputConsumer::consume中获取事件实际上是通过InputChannel去读取 InputChannel::receiveMessageframeworks/native/libs/input/InputTransport.cpp status_t InputChannel::receiveMessage(InputMessage* msg) &#123; ssize_t nRead; do &#123; nRead = ::recv(getFd(), msg, sizeof(InputMessage), MSG_DONTWAIT); //在这里真正的读取socket fd,并将输入事件信息装入msg（InputMessage) &#125; while (nRead == -1 &amp;&amp; errno == EINTR); ... return OK; //最后返回OK &#125; 通过InputChannel去读取真正的事件信息，并装入InputMessage对象，最后返回OK InputChannel::receiveMessageframeworks/native/libs/input/InputTransport.cpp status_t InputChannel::receiveMessage(InputMessage* msg) &#123; ssize_t nRead; do &#123; nRead = ::recv(getFd(), msg, sizeof(InputMessage), MSG_DONTWAIT); //在这里真正的读取socket fd,并将输入事件信息装入msg（InputMessage) &#125; while (nRead == -1 &amp;&amp; errno == EINTR); ... return OK; //最后返回OK &#125; 通过InputChannel去读取真正的事件信息，并装入InputMessage对象，最后返回OK； 创建并使用InputMessager中的事件信息填充MotionEvent，然后继续往下执行 NativeInputEventReceiver::consumeEvents NativeInputEventReceiver::consumeEvents//frameworks/base/core/jni/android_view_InputEventReceiver.cpp status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ... for (;;) &#123; uint32_t seq; InputEvent* inputEvent; //真正的去获取socket发过来的事件，并构建成具体的某种InputEvent，例MotionEvent //上面的分析从这里进入的，返回到这里继续往下分析 status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); ... if (!skipCallbacks) &#123; jobject inputEventObj; switch (inputEvent-&gt;getType()) &#123; case AINPUT_EVENT_TYPE_MOTION: &#123; MotionEvent* motionEvent = static_cast&lt;MotionEvent*&gt;(inputEvent); if ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123; *outConsumedBatch = true; &#125; //创建一个java层MotionEvent对象 inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent); break; &#125; &#125; ... if (inputEventObj) &#123; ...//jni调用InputEventReceiver.java中的InputEventReceiver，将事件传递到java的世界 // env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); ... env-&gt;DeleteLocalRef(inputEventObj); &#125; ... &#125; &#125; &#125; dispatchInputEvent12345678910111213//frameworks/base/core/java/android/view/InputEventReceiver.javapublic abstract class InputEventReceiver &#123; ... // //从native执行的调用 @SuppressWarnings(&quot;unused&quot;) @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553) private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event); &#125; ...&#125; InputEventReceiver是一个抽象类，但是对应的dispatchInputEvent方法，它的子类WindowInputEventReceiver并没有实现，所以native层调用父类的InputEventReceiver的方法，这个方法中接着调用了onInputEvent接着处理。onInputEvent子类是有实现的，所以会走子类的方法。 onInputEvent//frameworks/base/core/java/android/view/ViewRootImpl.java ... final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;processInputEventForCompatibility&quot;); List&lt;InputEvent&gt; processedEvents; try &#123; //对M版本之前的触摸事件的兼容处理 processedEvents = mInputCompatProcessor.processInputEventForCompatibility(event); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; if (processedEvents != null) &#123; ... &#125; else &#123; //因为上面返回null 所以走到这里 //在这里将自己this传入 //processImmediately 为true意味着需要马上处理，而不是延迟处理 enqueueInputEvent(event, this, 0, true); &#125; &#125; ... onInputEvent中会通过QueuedInputEvent的enqueueInputEvent将事件加入队列中再处理 enqueueInputEvent//frameworks/base/core/java/android/view/ViewRootImpl.java @UnsupportedAppUsage void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); //将事件加入队列，确保事件的有序处理 if (event instanceof MotionEvent) &#123; MotionEvent me = (MotionEvent) event; if (me.getAction() == MotionEvent.ACTION_CANCEL) &#123; //inputDispatcher中会根据实际焦点和触摸坐标的关系或者事件是有down无up情形设置ACTION_CANCEL &#125; &#125; else if (event instanceof KeyEvent) &#123; ... &#125; // Always enqueue the input event in order, regardless of its time stamp. // We do this because the application or the IME may inject key events // in response to touch events and we want to ensure that the injected keys // are processed in the order they were received and we cannot trust that // the time stamp of injected events are monotonic. // 无论时间戳如何，始终按顺序排列输入事件。 // 我们这样做是因为应用程序或 IME 可能会注入按键事件以响应触摸事件， // 我们希望确保注入的按键按照接收到的顺序进行处理，不能仅仅通过时间戳的前后来确定顺序。 QueuedInputEvent last = mPendingInputEventTail; if (last == null) &#123; mPendingInputEventHead = q; mPendingInputEventTail = q; &#125; else &#123; last.mNext = q; mPendingInputEventTail = q; &#125; mPendingInputEventCount += 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); if (processImmediately) &#123; doProcessInputEvents(); //前面传进来的processImmediately = true所以走这里处理 &#125; else &#123; scheduleProcessInputEvents(); &#125; &#125; doProcessInputEvents//frameworks/base/core/java/android/view/ViewRootImpl.java void doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; //从队头开始处理 mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); mViewFrameInfo.setInputEvent(mInputEventAssigner.processEvent(q.mEvent)); deliverInputEvent(q); //开始分发事件 &#125; // We are done processing all input events that we can process right now // so we can clear the pending flag immediately. //已经处理完所有待办的输入事件，是时候移除主线程mHandler中的MSG_PROCESS_INPUT_EVENTS消息了 if (mProcessInputEventsScheduled) &#123; mProcessInputEventsScheduled = false; mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS); &#125; &#125; 二、事件的传递前面将事件入队，然后在doProcessInputEvents就开始从队头拿出并通过deliverInputEvent开始分发 deliverInputEvent//frameworks/base/core/java/android/view/ViewRootImpl.java private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, &quot;deliverInputEvent&quot;, q.mEvent.getId()); ... try &#123; ... InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; //如果忽略输入法窗口则从mFirstPostImeInputStage阶段开始分发，否则从mFirstInputStage开始 stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; ... if (stage != null) &#123; handleWindowFocusChanged(); //在分发前确认是否焦点窗口变化了，如果变化就需要更新焦点的信息 stage.deliver(q); //调用对应的stage阶段的deliver方法分发事件 &#125; else &#123; finishInputEvent(q); &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 把事件从拿出，下一步就是往view或者IME分发，分发的过程这里会分为多个阶段(InputStage)来顺序执行, 这些阶段在ViewRootImpl中setView时会指定 setView12345678910111213141516171819202122232425262728293031//frameworks/base/core/java/android/view/ViewRootImpl.java /** * We have one child */ public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; synchronized (this) &#123; if (mView == null) &#123; ... // Set up the input pipeline. CharSequence counterSuffix = attrs.getTitle(); //这里进行的赋值； mSyntheticInputStage = new SyntheticInputStage(); InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage); InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, &quot;aq:native-post-ime:&quot; + counterSuffix); InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage); InputStage imeStage = new ImeInputStage(earlyPostImeStage, &quot;aq:ime:&quot; + counterSuffix); InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, &quot;aq:native-pre-ime:&quot; + counterSuffix); mFirstInputStage = nativePreImeStage; mFirstPostImeInputStage = earlyPostImeStage; mPendingInputEventQueueLengthCounterName = &quot;aq:pending:&quot; + counterSuffix; &#125; &#125; &#125; InputStage这里采用责任链的设计模式，从抽象类InputStage内容可以知道，每一个子类都会将next指向下一个stage子类对象 InputStage//frameworks/base/core/java/android/view/ViewRootImpl.java abstract class InputStage &#123; private final InputStage mNext; protected static final int FORWARD = 0; protected static final int FINISH_HANDLED = 1; protected static final int FINISH_NOT_HANDLED = 2; private String mTracePrefix; /** * Creates an input stage. * 将所有的阶段都组成一个链表，next指向下一个阶段 * @param next The next stage to which events should be forwarded. */ public InputStage(InputStage next) &#123; mNext = next; &#125; ... 从setView方法中的内容，我们得出整个链条的结构 分发阶段就会从第一个创建的stage子类开始执行到最后一个stage子类,无论要不要处理，都要从链表的头传递到尾。回到deliverInputEvent方法中stage.deliver(q)正式进入stage的分发中,观察下完整的一个stage的处理流程 //frameworks/base/core/java/android/view/ViewRootImpl.java /** * Delivers an event to be processed. */ public final void deliver(QueuedInputEvent q) &#123; if ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != 0) &#123; //如果上一stage中事件被处理（FLAG_FINISHED）那么本stage就不会再处理（onProcess），直接传递到下一个stage(无论是要处理，链表都要走完) forward(q); &#125; else if (shouldDropInputEvent(q)) &#123; finish(q, false); &#125; else &#123; traceEvent(q, Trace.TRACE_TAG_VIEW); final int result; try &#123; result = onProcess(q); //如果前面的阶段没有被处理，本stage就需要走处理流程 &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; apply(q, result); //判断是否需要下一个阶段走处理流程 &#125; &#125; /** * Marks the input event as finished then forwards it to the next stage. * 如果事件在当前阶段被结束，q.mFlags被标记为FLAG_FINISHED，并通过forward(q)传递给下一个阶段 */ protected void finish(QueuedInputEvent q, boolean handled) &#123; q.mFlags |= QueuedInputEvent.FLAG_FINISHED; if (handled) &#123; q.mFlags |= QueuedInputEvent.FLAG_FINISHED_HANDLED; &#125; forward(q); &#125; /** * Forwards the event to the next stage. * 往下一个阶段分发 */ protected void forward(QueuedInputEvent q) &#123; onDeliverToNext(q);// 继续往下一个阶段传递 &#125; /** * Applies a result code from &#123;@link #onProcess&#125; to the specified event. * 判断是否需要继续接着往下一个阶段分发 */ protected void apply(QueuedInputEvent q, int result) &#123; if (result == FORWARD) &#123; //如果上一个阶段还没处理这个事件，则继续往下一个阶段分发处理 forward(q); &#125; else if (result == FINISH_HANDLED) &#123; //如果事件被处理了，就标记为FLAG_FINISHED|FLAG_FINISHED_HANDLED，然后继续传递给下一个阶段（但不走onProcess()了） finish(q, true); &#125; else if (result == FINISH_NOT_HANDLED) &#123; //如果事件没有被处理则标记为FLAG_FINISHED，然后继续传递给下一个阶段（但不走onProcess()了） finish(q, false); &#125; else &#123; throw new IllegalArgumentException(&quot;Invalid result: &quot; + result); &#125; &#125; /** * Called when an event is ready to be processed. * @return A result code indicating how the event was handled. */ protected int onProcess(QueuedInputEvent q) &#123; return FORWARD; &#125; /** * Called when an event is being delivered to the next stage. * 继续执行下一阶段的deliver */ protected void onDeliverToNext(QueuedInputEvent q) &#123; if (DEBUG_INPUT_STAGES) &#123; Log.v(mTag, &quot;Done with &quot; + getClass().getSimpleName() + &quot;. &quot; + q); &#125; if (mNext != null) &#123; mNext.deliver(q); //如果下一阶段不为空就继续执行下一阶段的deliver，继续往下一阶段传递 &#125; else &#123; finishInputEvent(q); &#125; &#125; 具体如流程图： 从NativePreImeInputStage开始deliver，事件经过每一个stage, 如果该事件没有被处理（标记为）FLAG_FINISHED或者该事件应该被抛弃（shouldDropInputEvent)，那么就应该传给本阶段（stage）处理（onProcess），按照这个逻辑一直跑完整个链表。 三、View树的分发在这里阶段里我们本篇比较关心往View树分发的阶段，即ViewPostImeInputStage ViewPostImeInputStage /** * Delivers post-ime input events to the view hierarchy. */ final class ViewPostImeInputStage extends InputStage &#123; public ViewPostImeInputStage(InputStage next) &#123; super(next); &#125; @Override protected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); //按键事件 &#125; else &#123; final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); //pointer类型（包含触摸事件） &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; return processTrackballEvent(q); //轨迹球 &#125; else &#123; return processGenericMotionEvent(q); //其他 &#125; &#125; &#125; @Override protected void onDeliverToNext(QueuedInputEvent q) &#123; ... super.onDeliverToNext(q); &#125; private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; mHandwritingInitiator.onTouchEvent(event); mAttachInfo.mUnbufferedDispatchRequested = false; mAttachInfo.mHandlingPointerEvent = true; boolean handled = mView.dispatchPointerEvent(event); //mView实际上是DecorView, 在addView时添加 maybeUpdatePointerIcon(event); maybeUpdateTooltip(event); mAttachInfo.mHandlingPointerEvent = false; if (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123; mUnbufferedInputDispatch = true; if (mConsumeBatchedInputScheduled) &#123; scheduleConsumeBatchedInputImmediately(); &#125; &#125; return handled ? FINISH_HANDLED : FORWARD; &#125; ... &#125; 回顾下继承关系：DecorView-&gt;FrameLayout-&gt;ViewGroup-&gt;ViewdispatchPointerEvent方法并没有被DecorView-&gt;FrameLayout-&gt;ViewGroup实现，是祖父类View实现了这个方法 View::dispatchPointerEvent public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; //根据MotionEvent事件的类型，如果是触摸事件 return dispatchTouchEvent(event); //此时是this对象是DecorView子类对象，所以调的是它的dispatchTouchEvent &#125; else &#123; //其他（如鼠标） return dispatchGenericMotionEvent(event); &#125; &#125; DecorView::dispatchTouchEvent @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; final Window.Callback cb = mWindow.getCallback(); //这个cb实际上是Activity对象，(当调Activity的attach方法时， 通过mWindow.setCallback(this)传入) //这里判断条件为真，走cb.dispatchTouchEvent(ev)，也就是Activity的方法 return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); &#125; Activity::dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); //按下时通知通知栏进行相应的变化 &#125; //getWindow获取到的是PhoneWindow对象(在Activity的attach方法中创建的) //所以这里会传递给PhoneWindow::superDispatchTouchEvent if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; //如果上面的链路都没人处理，一路都是返回的false，那么最终还是由Activity来消费 return onTouchEvent(ev); &#125; PhoneWindow::superDispatchTouchEvent @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; // 兜兜转转又到DecorView手里，原因就是它是View树的最顶部ViewGroup呀，还是得从它开始的 return mDecor.superDispatchTouchEvent(event); &#125; DecorView::superDispatchTouchEvent public boolean superDispatchTouchEvent(MotionEvent event) &#123; //调用父类ViewGroup的dispatchTouchEvent开始遍历子成员分发 //step ViewGroup.java dispatchTouchEvent(); return super.dispatchTouchEvent(event); &#125; ViewGroup::dispatchTouchEvent @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. //如果这是个ACTION_DOWN事件说明是一个新触摸行为的开始，那么重置相关的状态 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. //ViewGroup是否拦截当前事件，通过onInterceptTouchEvent方法。这个方法只有ViewGroup有 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); // ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; ... if (!canceled &amp;&amp; !intercepted) &#123; //当这时一个ACTION_DOWN事件进这里 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex); final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. //在当前ViewGroup中找到能处理这个事件的子View或者Viewgroup final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); .... newTouchTarget = getTouchTarget(child); resetCancelNextUpFlag(child); //传递到child，调用dispatchTouchEvent，或者如果当前ViewGroup没有child，则调用View的dispatchTouchEvent交由当前ViewGroup处理 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. ... mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //记录下这个能消费触摸事件的View target newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; //这个标识通过这个Down事件找到了能处理这个触摸行为的View target break; &#125; // The accessibility focus didn&#39;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; ... &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. //如果找不到mFirstTouchTarget，则交给当前ViewGroup处理，即通过super.dispatchTouchEvent(event) handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; //前面的dispatchTransformedTouchEvent已经处理了这个Down事件,直接标识为已消费 handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //如果被拦截，则给子child发ACTION_CANCEL事件 //如果没有拦截则正常分发到子类，包括MOVE和UP事件 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; ... return handled; &#125; ViewGroup::dispatchTransformedTouchEvent private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; ... final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; //如果当前ViewGroup没有子View或者子ViewGroup，则调用View的dispatchTouchEvent，即由当前ViewGroup来处理 handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); //由子View或者子ViewGroup的dispatchTouchEvent处理 event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; ... return handled; &#125; View::dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent event) &#123; ... if (onFilterTouchEventForSecurity(event)) &#123; ... //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; //如果实现了onTouch方法，则不往下执行 result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; //调用当前View的onTouchEvent(这个View可能是View也可能是ViewGroup) result = true; &#125; &#125; ... return result; &#125; View::onTouchEvent public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; ... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; //根据action进行处理 switch (action) &#123; case MotionEvent.ACTION_UP: ... break; case MotionEvent.ACTION_DOWN: ... break; case MotionEvent.ACTION_CANCEL: ... break; case MotionEvent.ACTION_MOVE: ... break; &#125; return true; &#125; return false; &#125; 这个方法也是又臭又长，核心方法了, 还是用图来说明更直接，也结束触摸事件的分析。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"InPutManagerService","slug":"Android-FrameWork/Framework源码分析/Android-13/InPutManagerService","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/InPutManagerService/4.InputDispatcher事件分发/","text":"InputDispatcher::dispatchOnce()frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;dispatcher&#x2F;InputDispatcher.cpp void InputDispatcher::dispatchOnce() &#123; nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock std::scoped_lock _l(mLock); mDispatcherIsAlive.notify_all(); //唤醒在这个condition上wait的所有地方 // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. // 如果当前没有待办的command需要处理（command一般是需要处理一些异常情况，比如ANR） // 就进行事件的分发 if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); //事件分发 &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. // 如果mCommandQueue不为空，就执行完所有command，并将下次唤醒时间设置为最小值，强制下一次poll唤醒线程 if (runCommandsLockedInterruptable()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125; // If we are still waiting for ack on some events, // we might have to wake up earlier to check if an app is anr&#39;ing. // 如果此时正在等待分发出去的事件的ack(目标应用的响应)，我们需要早点唤醒去检查这个应用是否正在ANR const nsecs_t nextAnrCheck = processAnrsLocked(); nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck); // We are about to enter an infinitely long sleep, because we have no commands or // pending or queued events // 如果唤醒时间还是LONG_LONG_MAX没有被修改 // 说明上面没有待处理的事件也没有待处理的command，那么将进入无限期的休眠中 if (nextWakeupTime == LONG_LONG_MAX) &#123; mDispatcherEnteredIdle.notify_all(); //唤醒等待进入idle状态的condition &#125; &#125; // release lock // Wait for callback or timeout or wake. (make sure we round up, not down) nsecs_t currentTime = now(); int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); mLooper-&gt;pollOnce(timeoutMillis); //进入阻塞等待唤醒或者timeout或者callback回调 &#125; InputDispatcher::dispatchOnceInnerLockedvoid InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); // Reset the key repeat timer whenever normal dispatch is suspended while the // device is in a non-interactive state. This is to ensure that we abort a key // repeat if the device is just coming out of sleep. // 如果设备处于不可交互时，则不进行事件的分发 // 如果处于不可分发状态则重置按键重复计时器 if (!mDispatchEnabled) &#123; resetKeyRepeatLocked(); &#125; // If dispatching is frozen, do not process timeouts or try to deliver any new events. // 如果处于frozen状态，则不处理任何有关目标进程是否有简单窗口的timeout行为，也不会进行事件的分发 if (mDispatchFrozen) &#123; if (DEBUG_FOCUS) &#123; ALOGD(&quot;Dispatch frozen. Waiting some more.&quot;); &#125; return; &#125; // Optimize latency of app switches. // Essentially we start a short timeout when an app switch key (HOME / ENDCALL) has // been pressed. When it expires, we preempt dispatch and drop all other pending events. // 对APP切换时的优化措施，当按下类似HOME键时，启动一个超时机制(0.5s)，当timeout时，会立即分发事件并抛弃其他的未处理事件 bool isAppSwitchDue = mAppSwitchDueTime &lt;= currentTime; if (mAppSwitchDueTime &lt; *nextWakeupTime) &#123; *nextWakeupTime = mAppSwitchDueTime; &#125; // Ready to start a new event. // If we don&#39;t already have a pending event, go grab one. if (!mPendingEvent) &#123; //正常一次分发前mPendingEvent = nullptr if (mInboundQueue.empty()) &#123; ... &#125; else &#123; //因为inputReader已经往Inbound queue中添加了事件，所以不为空 // Inbound queue has at least one entry. mPendingEvent = mInboundQueue.front(); //拿出一个待分发的事件 mInboundQueue.pop_front(); //从mInboundQueue中移除这个事件 traceInboundQueueLengthLocked(); //systrace、perfetto中可以看到这个队列size发生变化 &#125; // Poke user activity for this event. // 每次分发事件时都调PMS的updatePowerStateLocked更新电源的状态 if (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123; pokeUserActivityLocked(*mPendingEvent); &#125; &#125; // Now we have an event to dispatch. // All events are eventually dequeued and processed this way, even if we intend to drop them. ALOG_ASSERT(mPendingEvent != nullptr); bool done = false; DropReason dropReason = DropReason::NOT_DROPPED; if (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123; //如果事件不是分发给用户的则抛弃drop dropReason = DropReason::POLICY; &#125; else if (!mDispatchEnabled) &#123; //如果当前属于不可交互的状态则drop dropReason = DropReason::DISABLED; &#125; if (mNextUnblockedEvent == mPendingEvent) &#123; mNextUnblockedEvent = nullptr; &#125; switch (mPendingEvent-&gt;type) &#123; ... case EventEntry::Type::KEY: &#123; ... &#125; case EventEntry::Type::MOTION: &#123; std::shared_ptr&lt;MotionEntry&gt; motionEntry = std::static_pointer_cast&lt;MotionEntry&gt;(mPendingEvent); if (dropReason == DropReason::NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123; dropReason = DropReason::APP_SWITCH; //处于APP切换情形drop的事件 &#125; if (dropReason == DropReason::NOT_DROPPED &amp;&amp; isStaleEvent(currentTime, *motionEntry)) &#123; //事件超过了一个事件允许分发的最大时间(10s)(事件太老)则drop这个事件 //时间计算：currentTime - entry.eventTime dropReason = DropReason::STALE; &#125; if (dropReason == DropReason::NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; //当焦点将要移到到新的应用上，则抛弃期间的事件 dropReason = DropReason::BLOCKED; &#125; //事件的分发（无论这个事件要分发还是要drop都要走这里） done = dispatchMotionLocked(currentTime, motionEntry, &amp;dropReason, nextWakeupTime); break; &#125; ... &#125; if (done) &#123; if (dropReason != DropReason::NOT_DROPPED) &#123; dropInboundEventLocked(*mPendingEvent, dropReason); &#125; mLastDropReason = dropReason; releasePendingEventLocked(); //将mPendingEvent设置为nullptr，重置为下一个事件分发准备 // 强制下一个poll中立即唤醒inputDispatcher线程来干活 *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately &#125; &#125; InputDispatcher::dispatchMotionLockedbool InputDispatcher::dispatchMotionLocked(nsecs_t currentTime, std::shared_ptr&lt;MotionEntry&gt; entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ATRACE_CALL(); // Preprocessing. //将当前事件的dispatchInProgress设置为true表示处理中 if (!entry-&gt;dispatchInProgress) &#123; entry-&gt;dispatchInProgress = true; logOutboundMotionDetails(&quot;dispatchMotion - &quot;, *entry); &#125; // Clean up if dropping the event. //如果事件需要抛弃 if (*dropReason != DropReason::NOT_DROPPED) &#123; setInjectionResult(*entry, *dropReason == DropReason::POLICY ? InputEventInjectionResult::SUCCEEDED : InputEventInjectionResult::FAILED); return true; &#125; //从entry-&gt;source判断事件的源类型 const bool isPointerEvent = isFromSource(entry-&gt;source, AINPUT_SOURCE_CLASS_POINTER); // Identify targets. std::vector&lt;InputTarget&gt; inputTargets; bool conflictingPointerActions = false; InputEventInjectionResult injectionResult; if (isPointerEvent) &#123; //触屏这这里 // Pointer event. (eg. touchscreen) //重要的方法，获取当前焦点窗口，后续单独展开分析这个，这里就展开 //获取到的焦点窗口为inputTargets injectionResult = findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions); &#125; else &#123; ... &#125; ... setInjectionResult(*entry, injectionResult); ... // Add monitor channels from event&#39;s or focused display. //将全局的监视器窗口加入分发的目标窗口列表中（举个例子：开发者选项中的显示触摸轨迹图层就一个全局监视器） //只要事件在前面没有被抛弃，那么无论后面的流程是否拦截事件，这些全局监视器都能收到事件 addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry)); // Dispatch the motion. ... dispatchEventLocked(currentTime, entry, inputTargets); //往目标窗口分发事件 return true; //return true就可以进行下一次从iq中读取新事件并分发 &#125; InputDispatcher::dispatchEventLockedvoid InputDispatcher::dispatchEventLocked(nsecs_t currentTime, std::shared_ptr&lt;EventEntry&gt; eventEntry, const std::vector&lt;InputTarget&gt;&amp; inputTargets) &#123; ATRACE_CALL(); updateInteractionTokensLocked(*eventEntry, inputTargets); ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); // should already have been set to true pokeUserActivityLocked(*eventEntry); //再次更新电源状态，避免进入息屏等行为 //遍历所有找到的目标窗口inputTargets，通过他们的向他们inputChannel分发当前的事件 for (const InputTarget&amp; inputTarget : inputTargets) &#123; sp&lt;Connection&gt; connection = getConnectionLocked(inputTarget.inputChannel-&gt;getConnectionToken()); if (connection != nullptr) &#123; prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget); &#125; else &#123; if (DEBUG_FOCUS) &#123; ALOGD(&quot;Dropping event delivery to target with channel &#39;%s&#39; because it &quot; &quot;is no longer registered with the input dispatcher.&quot;, inputTarget.inputChannel-&gt;getName().c_str()); &#125; &#125; &#125; &#125; InputDispatcher::prepareDispatchCycleLockedvoid InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, std::shared_ptr&lt;EventEntry&gt; eventEntry, const InputTarget&amp; inputTarget) &#123; ... // Skip this event if the connection status is not normal. // We don&#39;t want to enqueue additional outbound events if the connection is broken. // 如果目标窗口的连接状态不正常，比如进程已经死了，那么就不向它分发了 if (connection-&gt;status != Connection::Status::NORMAL) &#123; return; &#125; // Split a motion event if needed. // 如果当前系统处于分屏的状态，就需要考虑分离触摸的情形，检查目标窗口是否设置分离触摸标志 if (inputTarget.flags &amp; InputTarget::FLAG_SPLIT) &#123; const MotionEntry&amp; originalMotionEntry = static_cast&lt;const MotionEntry&amp;&gt;(*eventEntry); if (inputTarget.pointerIds.count() != originalMotionEntry.pointerCount) &#123; std::unique_ptr&lt;MotionEntry&gt; splitMotionEntry = splitMotionEvent(originalMotionEntry, inputTarget.pointerIds); if (!splitMotionEntry) &#123; return; // split event was dropped &#125; if (splitMotionEntry-&gt;action == AMOTION_EVENT_ACTION_CANCEL) &#123; std::string reason = std::string(&quot;reason=pointer cancel on split window&quot;); android_log_event_list(LOGTAG_INPUT_CANCEL) &lt;&lt; connection-&gt;getInputChannelName().c_str() &lt;&lt; reason &lt;&lt; LOG_ID_EVENTS; &#125; enqueueDispatchEntriesLocked(currentTime, connection, std::move(splitMotionEntry), inputTarget); return; &#125; &#125; // Not splitting. Enqueue dispatch entries for the event as is. //一般走这里，继续事件的分发，将事件加入目标窗口的即将分发的队列中 enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget); &#125; InputDispatcher::enqueueDispatchEntriesLockedvoid InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, std::shared_ptr&lt;EventEntry&gt; eventEntry, const InputTarget&amp; inputTarget) &#123; bool wasEmpty = connection-&gt;outboundQueue.empty(); // Enqueue dispatch entries for the requested modes. // 将事件加入分发队列outboundQueue，这里有些复杂 enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT); //2048 enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_OUTSIDE); //512 enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER); //1024 //FLAG_DISPATCH_AS_IS表示事件按原样分发，不改变事件的分发模式，一般都是走这里，其他的是特殊情形 enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_IS); //256 enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT); //4096 enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER); //8192 // If the outbound queue was previously empty, start the dispatch cycle going. if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.empty()) &#123; startDispatchCycleLocked(currentTime, connection); //outboundQueue中已经有事件，可以分发 &#125; &#125; InputDispatcher::enqueueDispatchEntryLockedvoid InputDispatcher::enqueueDispatchEntryLocked(const sp&lt;Connection&gt;&amp; connection, std::shared_ptr&lt;EventEntry&gt; eventEntry, const InputTarget&amp; inputTarget, int32_t dispatchMode) &#123; int32_t inputTargetFlags = inputTarget.flags; //这里很关键，enqueueDispatchEntryLocked从上面来看，貌似会调五次，但是 // 这里有限制条件，根据inputTargetFlags是否等于本次传入的dispatchMode，不同则return // 所以是否入队还是由inputTargetFlags决定，正常事件都是inputTargetFlags = FLAG_DISPATCH_AS_IS // 所以一般只有dispatchMode = FLAG_DISPATCH_AS_IS时才会往下执行 if (!(inputTargetFlags &amp; dispatchMode)) &#123; return; &#125; inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode; // This is a new event. // Enqueue a new dispatch entry onto the outbound queue for this connection. // 创建DispatchEntry，DispatchEntry是对EventEntry的包装，加入分发的一些跟踪状态属性值 // 关联eventEntry，inputTarget，inputTarget， std::unique_ptr&lt;DispatchEntry&gt; dispatchEntry = createDispatchEntry(inputTarget, eventEntry, inputTarget); // Use the eventEntry from dispatchEntry since the entry may have changed and can now be a // different EventEntry than what was passed in. EventEntry&amp; newEntry = *(dispatchEntry-&gt;eventEntry); // Apply target flags and update the connection&#39;s input state. switch (newEntry.type) &#123; case EventEntry::Type::KEY: &#123; ... break; &#125; case EventEntry::Type::MOTION: &#123; const MotionEntry&amp; motionEntry = static_cast&lt;const MotionEntry&amp;&gt;(newEntry); // Assign a default value to dispatchEntry that will never be generated by InputReader, // and assign a InputDispatcher value if it doesn&#39;t change in the if-else chain below. constexpr int32_t DEFAULT_RESOLVED_EVENT_ID = static_cast&lt;int32_t&gt;(IdGenerator::Source::OTHER); dispatchEntry-&gt;resolvedEventId = DEFAULT_RESOLVED_EVENT_ID; if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_OUTSIDE) &#123; dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE; &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) &#123; dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT; &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) &#123; dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER; &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) &#123; dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_CANCEL; &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) &#123; dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_DOWN; &#125; else &#123; //由上面可知dispatchMode = FLAG_DISPATCH_AS_IS所以走else，保留事件原本的action和id dispatchEntry-&gt;resolvedAction = motionEntry.action; dispatchEntry-&gt;resolvedEventId = motionEntry.id; &#125; if (dispatchEntry-&gt;resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE &amp;&amp; ... &#125; dispatchEntry-&gt;resolvedFlags = motionEntry.flags; //判断当前目标窗口是否被其他可见窗口遮挡的情况并设置到dispatchEntry-&gt;resolvedFlags, 全遮挡还是部分遮挡 if (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_OBSCURED) &#123; dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED; &#125; if (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) &#123; dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED; &#125; ... // 从上面可知，当dispatchMode = FLAG_DISPATCH_AS_IS时 // 事件的resolvedEventId仍然保留原有motionEntry.id dispatchEntry-&gt;resolvedEventId = dispatchEntry-&gt;resolvedEventId == DEFAULT_RESOLVED_EVENT_ID ? mIdGenerator.nextId() : motionEntry.id; if ((motionEntry.flags &amp; AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE) &amp;&amp; (motionEntry.policyFlags &amp; POLICY_FLAG_TRUSTED)) &#123; // Skip reporting pointer down outside focus to the policy. break; &#125; //处理分发事件目标窗口不是当前焦点窗口的情况 dispatchPointerDownOutsideFocus(motionEntry.source, dispatchEntry-&gt;resolvedAction, inputTarget.inputChannel-&gt;getConnectionToken()); break; &#125; ... &#125; // Remember that we are waiting for this dispatch to complete. if (dispatchEntry-&gt;hasForegroundTarget()) &#123; incrementPendingForegroundDispatches(newEntry); &#125; // Enqueue the dispatch entry. // 将dispatchEntry加入当前目标窗口的outboundQueue connection-&gt;outboundQueue.push_back(dispatchEntry.release()); traceOutboundQueueLength(*connection); //systrace可以看到outboundQueue的size发生改变 &#125; InputDispatcher::startDispatchCycleLockedvoid InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; //循环从outboundQueue中取出事件通过目标窗口的inputchannel向目标窗口分发 while (connection-&gt;status == Connection::Status::NORMAL &amp;&amp; !connection-&gt;outboundQueue.empty()) &#123; DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.front(); //取出DispatchEntry dispatchEntry-&gt;deliveryTime = currentTime; //记录分发事件 const std::chrono::nanoseconds timeout = getDispatchingTimeoutLocked(connection); //事件处理的超时时间点 = currentTime + 5s 超时会引发ANR dispatchEntry-&gt;timeoutTime = currentTime + timeout.count(); // Publish the event. status_t status; const EventEntry&amp; eventEntry = *(dispatchEntry-&gt;eventEntry); //获取EventEntry switch (eventEntry.type) &#123; case EventEntry::Type::KEY: &#123; ... &#125; case EventEntry::Type::MOTION: &#123; const MotionEntry&amp; motionEntry = static_cast&lt;const MotionEntry&amp;&gt;(eventEntry); //转化为触摸对应MotionEntry PointerCoords scaledCoords[MAX_POINTERS]; const PointerCoords* usingCoords = motionEntry.pointerCoords; // Set the X and Y offset and X and Y scale depending on the input source. //根据输入源设置 X 和 Y 偏移以及 X 和 Y 比例。 if ((motionEntry.source &amp; AINPUT_SOURCE_CLASS_POINTER) &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123; //模拟器走这里 float globalScaleFactor = dispatchEntry-&gt;globalScaleFactor; if (globalScaleFactor != 1.0f) &#123; for (uint32_t i = 0; i &lt; motionEntry.pointerCount; i++) &#123; scaledCoords[i] = motionEntry.pointerCoords[i]; // Don&#39;t apply window scale here since we don&#39;t want scale to affect raw // coordinates. The scale will be sent back to the client and applied // later when requesting relative coordinates. //如果当前窗口的全局坐标比例不是1.0f,那么这里先把每个pointer的比例设置为1.0f scaledCoords[i].scale(globalScaleFactor, 1 /* windowXScale */, 1 /* windowYScale */); &#125; usingCoords = scaledCoords; &#125; &#125; else &#123; ... &#125; std::array&lt;uint8_t, 32&gt; hmac = getSignature(motionEntry, *dispatchEntry); // Publish the motion event. // 向目标窗口分发触摸事件 status = connection-&gt;inputPublisher .publishMotionEvent(dispatchEntry-&gt;seq, dispatchEntry-&gt;resolvedEventId, motionEntry.deviceId, motionEntry.source, motionEntry.displayId, std::move(hmac), dispatchEntry-&gt;resolvedAction, motionEntry.actionButton, dispatchEntry-&gt;resolvedFlags, motionEntry.edgeFlags, motionEntry.metaState, motionEntry.buttonState, motionEntry.classification, dispatchEntry-&gt;transform, motionEntry.xPrecision, motionEntry.yPrecision, motionEntry.xCursorPosition, motionEntry.yCursorPosition, dispatchEntry-&gt;rawTransform, motionEntry.downTime, motionEntry.eventTime, motionEntry.pointerCount, motionEntry.pointerProperties, usingCoords); break; &#125; ... &#125; // Check the result. // 检测分发的结果，正常时status = 0 if (status) &#123; if (status == WOULD_BLOCK) &#123; if (connection-&gt;waitQueue.empty()) &#123; // 当前waitQueue是空的，说明socket中也应该是空的，但是却是WOULD_BLOCK，说明这时一个异常的情况，中断分发 abortBrokenDispatchCycleLocked(currentTime, connection, true /*notify*/); &#125; else &#123; // Pipe is full and we are waiting for the app to finish process some events // before sending more events to it. // socket满了，等待应用进程处理掉一些事件 &#125; &#125; else &#123; //其他异常的情况 abortBrokenDispatchCycleLocked(currentTime, connection, true /*notify*/); &#125; return; &#125; // Re-enqueue the event on the wait queue. // 将已经分发的事件dispatchEntry从outboundQueue中移除 connection-&gt;outboundQueue.erase(std::remove(connection-&gt;outboundQueue.begin(), connection-&gt;outboundQueue.end(), dispatchEntry)); traceOutboundQueueLength(*connection); //systrace中跟踪outboundQueue的长度 // 将已经分发的事件dispatchEntry加入目标窗口waitQueue中，记录下已经分发到目标窗口侧的事件，便于监控ANR等行为 connection-&gt;waitQueue.push_back(dispatchEntry); //如果目标窗口进程（例如应用进程）可响应，则将这个事件超时事件点和目标窗口连接对象token加入mAnrTracker中监控 //如果不可响应，则不再向它分发更多的事件，直到它消耗了已经分发给它的事件 if (connection-&gt;responsive) &#123; mAnrTracker.insert(dispatchEntry-&gt;timeoutTime, connection-&gt;inputChannel-&gt;getConnectionToken()); &#125; traceWaitQueueLength(*connection); //systrace中跟踪waitQueue的长度 &#125; &#125; InputPublisher::publishMotionEventframeworks&#x2F;native&#x2F;libs&#x2F;input&#x2F;InputTransport.cpp status_t InputPublisher::publishMotionEvent( uint32_t seq, int32_t eventId, int32_t deviceId, int32_t source, int32_t displayId, std::array&lt;uint8_t, 32&gt; hmac, int32_t action, int32_t actionButton, int32_t flags, int32_t edgeFlags, int32_t metaState, int32_t buttonState, MotionClassification classification, const ui::Transform&amp; transform, float xPrecision, float yPrecision, float xCursorPosition, float yCursorPosition, const ui::Transform&amp; rawTransform, nsecs_t downTime, nsecs_t eventTime, uint32_t pointerCount, const PointerProperties* pointerProperties, const PointerCoords* pointerCoords) &#123; //创建InputMessage，将dispatchEntry转化为InputMessage InputMessage msg; msg.header.type = InputMessage::Type::MOTION; msg.header.seq = seq; msg.body.motion.eventId = eventId; msg.body.motion.deviceId = deviceId; msg.body.motion.source = source; msg.body.motion.displayId = displayId; msg.body.motion.hmac = std::move(hmac); msg.body.motion.action = action; msg.body.motion.actionButton = actionButton; msg.body.motion.flags = flags; msg.body.motion.edgeFlags = edgeFlags; msg.body.motion.metaState = metaState; msg.body.motion.buttonState = buttonState; msg.body.motion.classification = classification; msg.body.motion.dsdx = transform.dsdx(); msg.body.motion.dtdx = transform.dtdx(); msg.body.motion.dtdy = transform.dtdy(); msg.body.motion.dsdy = transform.dsdy(); msg.body.motion.tx = transform.tx(); msg.body.motion.ty = transform.ty(); msg.body.motion.xPrecision = xPrecision; msg.body.motion.yPrecision = yPrecision; msg.body.motion.xCursorPosition = xCursorPosition; msg.body.motion.yCursorPosition = yCursorPosition; msg.body.motion.dsdxRaw = rawTransform.dsdx(); msg.body.motion.dtdxRaw = rawTransform.dtdx(); msg.body.motion.dtdyRaw = rawTransform.dtdy(); msg.body.motion.dsdyRaw = rawTransform.dsdy(); msg.body.motion.txRaw = rawTransform.tx(); msg.body.motion.tyRaw = rawTransform.ty(); msg.body.motion.downTime = downTime; msg.body.motion.eventTime = eventTime; msg.body.motion.pointerCount = pointerCount; for (uint32_t i = 0; i &lt; pointerCount; i++) &#123; //多指的情况 msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]); msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]); &#125; return mChannel-&gt;sendMessage(&amp;msg); //通过socketpair传递到目标窗口所在的进程中 &#125; 到这里InputDispatcher的Native层分发就分析完了。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"InPutManagerService","slug":"Android-FrameWork/Framework源码分析/Android-13/InPutManagerService","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/InPutManagerService/2.EventHub获取事件/","text":"从前面inputflinger的启动分析中，我们知道事件来源是在EventHub::getEvents, 所以我们重点看下这个方法的流程来了解事件是如何从驱动上报中获取的。 EventHub::getEventsframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;EventHub.cpp size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123; ALOG_ASSERT(bufferSize &gt;= 1); std::scoped_lock _l(mLock); //创建一个input_event数组，用于存放从epoll中读取到的input_events struct input_event readBuffer[bufferSize]; //buffer是inputReader传入的RawEvent数组首地址，数组大小为256，将事件构造成RawEvent并装入后返回给inputReader //用这里把数组地址赋给event指针，后续使用这个指针操作这个数组 RawEvent* event = buffer; //传入的RawEvent数组首地址 //一次处理事件的最大容量为256个 size_t capacity = bufferSize; bool awoken = false; for (;;) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); //获取当前时间戳 //处理有关设备状态变化的逻辑 // Reopen input devices if needed. if (mNeedToReopenDevices) &#123; mNeedToReopenDevices = false; ALOGI(&quot;Reopening all input devices due to a configuration change.&quot;); closeAllDevicesLocked(); mNeedToScanDevices = true; break; // return to the caller before we actually rescan &#125; // Report any devices that had last been added/removed. //当调用closeDeviceLocked时，就会把需要关闭的设备加入mClosingDevices，下一次循环到这里时就遍历这个列表处理 for (auto it = mClosingDevices.begin(); it != mClosingDevices.end();) &#123; //移除一个设备就构建一个DEVICE_REMOVED类型的event并加入RawEvent数组中 std::unique_ptr&lt;Device&gt; device = std::move(*it); ALOGV(&quot;Reporting device closed: id=%d, name=%s\\n&quot;, device-&gt;id, device-&gt;path.c_str()); event-&gt;when = now; event-&gt;deviceId = (device-&gt;id == mBuiltInKeyboardId) ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID : device-&gt;id; event-&gt;type = DEVICE_REMOVED; event += 1; it = mClosingDevices.erase(it); //从mClosingDevices中移除device mNeedToSendFinishedDeviceScan = true; if (--capacity == 0) &#123; break; &#125; &#125; //当EventHub初始化时，mNeedToScanDevices = true， 所以首次进入需要scan输入设备 if (mNeedToScanDevices) &#123; mNeedToScanDevices = false; scanDevicesLocked(); //扫描设备&quot;/dev/input&quot;下的设备，例如event1、event2，这个方法很复杂， mNeedToSendFinishedDeviceScan = true; &#125; //上一步进行了scan device的操作，现在mOpeningDevices是记录着获取到的Device while (!mOpeningDevices.empty()) &#123; //遍历取出mOpeningDevices中Device，构建RawEvent-&gt;DEVICE_ADDED事件，写入event缓冲区中 std::unique_ptr&lt;Device&gt; device = std::move(*mOpeningDevices.rbegin()); mOpeningDevices.pop_back();//把这个device对象从移除mOpeningDevices中 ALOGV(&quot;Reporting device opened: id=%d, name=%s\\n&quot;, device-&gt;id, device-&gt;path.c_str()); //构建一个RawEvent时间，type = DEVICE_ADDED event-&gt;when = now; event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id; event-&gt;type = DEVICE_ADDED; event += 1; //RawEvent对象偏移 + 1（RawEvent数组中RawEvent数量） ... //从已经处理的设备中mOpeningDevices中的device加入mDevices Map中，以device-&gt;id标记 auto [dev_it, inserted] = mDevices.insert_or_assign(device-&gt;id, std::move(device)); mNeedToSendFinishedDeviceScan = true; //标记扫描完成，可以退出扫描状态（退出也要发退出事件） //如果RawEvent数组装满了，就跳出循环往下执行（需要等数组中数据分发释放后进入这里再处理） if (--capacity == 0) &#123; break; &#125; &#125; //如果扫描结束需要发一个mNeedToSendFinishedDeviceScan事件，将这个事件构造并写入event（RawEvent）数组中 if (mNeedToSendFinishedDeviceScan) &#123; mNeedToSendFinishedDeviceScan = false; event-&gt;when = now; event-&gt;type = FINISHED_DEVICE_SCAN; event += 1; //RawEvent对象偏移 + 1（RawEvent数组中RawEvent数量） if (--capacity == 0) &#123; break; &#125; &#125; // Grab the next input event. //从epoll中下一个输入事件 bool deviceChanged = false; //这个变量标记当前设备是否有变化（拔插、配置改变等） //mPendingEventCount指epoll中返回的事件（在epoll event数组中）的数量 //mPendingEventIndex指要处理的epoll事件在epoll返回列表中的下标 //循环处理epoll返回列表中的epoll事件 while (mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; if (eventItem.data.fd == mINotifyFd) &#123; if (eventItem.events &amp; EPOLLIN) &#123; mPendingINotify = true; &#125; else &#123; ALOGW(&quot;Received unexpected epoll event 0x%08x for INotify.&quot;, eventItem.events); &#125; continue; &#125; if (eventItem.data.fd == mWakeReadPipeFd) &#123; if (eventItem.events &amp; EPOLLIN) &#123; ALOGV(&quot;awoken after wake()&quot;); awoken = true; char wakeReadBuffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, wakeReadBuffer, sizeof(wakeReadBuffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(wakeReadBuffer)); &#125; else &#123; ALOGW(&quot;Received unexpected epoll event 0x%08x for wake read pipe.&quot;, eventItem.events); &#125; continue; &#125; //如果非mINotifyFd和非mWakeReadPipeFd，则是底层输入驱动上报的输入事件，那么通过fd获取这个事件对应的Device Device* device = getDeviceByFdLocked(eventItem.data.fd); ... // This must be an input event //如果是个epoll读事件 if (eventItem.events &amp; EPOLLIN) &#123; //通过read方法获取读缓冲区大小和数据。写入readBuffer，读取size为256个input_event int32_t readSize = read(device-&gt;fd, readBuffer, sizeof(struct input_event) * capacity); if (readSize == 0 || (readSize &lt; 0 &amp;&amp; errno == ENODEV)) &#123; // Device was removed before INotify noticed. //如果读取的size &lt;= 0 且返回异常可能是设备已经被移除了，只是INotify还没通知， //那么就标记这个设备状态改变，并移除这个设备 deviceChanged = true; //标记这个设备状态改变 closeDeviceLocked(*device); //移除这个设备 &#125; else if (readSize &lt; 0) &#123; ... &#125; else if ((readSize % sizeof(struct input_event)) != 0) &#123; ... &#125; else &#123; //正常读到数据了 //(特殊)如果读到的device是内置键盘，name就设置它的device-&gt;id = 0 int32_t deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id; //计算这次读到的epoll读事件中的readBuffer中包含的input_event数量 size_t count = size_t(readSize) / sizeof(struct input_event); //从readBuffer循环取出读到的的input_event对象 //构造RawEvent对象写入RawEvent数组中，指针依次往后偏移 for (size_t i = 0; i &lt; count; i++) &#123; struct input_event&amp; iev = readBuffer[i]; event-&gt;when = processEventTimestamp(iev); event-&gt;readTime = systemTime(SYSTEM_TIME_MONOTONIC); event-&gt;deviceId = deviceId; event-&gt;type = iev.type; event-&gt;code = iev.code; event-&gt;value = iev.value; event += 1; capacity -= 1; &#125; //如果写满了RawEvent数组 if (capacity == 0) &#123; // The result buffer is full. Reset the pending event index // so we will try to read the device again on the next iteration. // 如果RawEvent数组写满了，就把mPendingEventIndex - 1，(因为下次循环开始会加一，提前减一这样处理的就还是当前这个epoll事件) // 说明我们本次epoll读事件我们没有处理完，下一个循环还要继续处理这个epoll事件 mPendingEventIndex -= 1; break; &#125; &#125; &#125; else if (eventItem.events &amp; EPOLLHUP) &#123; //如果是hang-up事件说明设备拔出，就移除这个设备，通知设备状态变化 ALOGI(&quot;Removing device %s due to epoll hang-up event.&quot;, device-&gt;identifier.name.c_str()); deviceChanged = true; closeDeviceLocked(*device); &#125; else &#123; //收到异常的epoll事件，不处理 ALOGW(&quot;Received unexpected epoll event 0x%08x for device %s.&quot;, eventItem.events, device-&gt;identifier.name.c_str()); &#125; &#125; // readNotify() will modify the list of devices so this must be done after // processing all other events to ensure that we read all remaining events // before closing the devices. //当处理完一次一次epoll_wait返回列表中所有epoll事件后，检测下是否有底层设备变化（mPendingINotify = true） //如果有就通知设备状态改变 if (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123; mPendingINotify = false; readNotifyLocked(); //通过read去读取INotify fd返回的事件，判断设备状态，是需要重新获取设备还是移除设备 deviceChanged = true; //标记设备状态改变， &#125; // Report added or removed devices immediately. // 如果有设备状态改变（新增或者移除）需要马上到下一个循环处理 if (deviceChanged) &#123; continue; &#125; // Return now if we have collected any events or if we were explicitly awoken. //1.如果其他地方调用了`mEventHub-&gt;wake()`则会唤醒阻塞在epoll_wait()中的inputReader线程，下一次循环时然后从这里跳出getEvents方法，往下执行loopOnce，处理输入事件 //2. 或者RawEvent数组中有数据则跳出getEvents方法，往下执行loopOnce，处理输入事件 if (event != buffer || awoken) &#123; break; &#125; //如果RawEvent数组为空且没有inputReader线程没有被外部唤醒，则下面就准备开始获取下一次epoll事件(进入阻塞等待) mPendingEventIndex = 0; //准备进入下一次事件接收前，重置mPendingEventIndex下标 mLock.unlock(); // release lock before poll //进入epoll_wait阻塞等待驱动上报事件 int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis); //从epoll_wait中唤醒 //也许是外部调用mEventHub-&gt;wake()唤醒 //或者内核通知事件上报唤醒 //或者是超时退出休眠 mLock.lock(); // reacquire lock after poll if (pollResult == 0) &#123; // Timed out. // 超时退出的情况 mPendingEventCount = 0; break; &#125; if (pollResult &lt; 0) &#123; // An error occurred. mPendingEventCount = 0; // Sleep after errors to avoid locking up the system. // Hopefully the error is transient. if (errno != EINTR) &#123; ALOGW(&quot;poll failed (errno=%d)\\n&quot;, errno); usleep(100000); &#125; &#125; else &#123; // Some events occurred. // 获取到epoll事件，将事件数量赋给mPendingEventCount mPendingEventCount = size_t(pollResult); &#125; &#125; // All done, return the number of events we read. // 处理结束，退出循环将事件返回到inputReader的loopOnce中处理 return event - buffer; &#125; EventHub::scanDevicesLocked()void EventHub::scanDevicesLocked() &#123; status_t result; std::error_code errorCode; if (std::filesystem::exists(DEVICE_INPUT_PATH, errorCode)) &#123; result = scanDirLocked(DEVICE_INPUT_PATH); &#125; else &#123; ... &#125; ... &#125; status_t EventHub::scanDirLocked(const std::string&amp; dirname) &#123; //遍历 /dev/input/event* 路径，打开这些设备并获取相关设备信息 for (const auto&amp; entry : std::filesystem::directory_iterator(dirname)) &#123; openDeviceLocked(entry.path()); &#125; return 0; &#125; EventHub::openDeviceLocked这个方法很长，主要作用就是打开/dev/input/eventX设备节点，用返回的fd通过ioctl向驱动获取输入设备device相关信息。 void EventHub::openDeviceLocked(const std::string&amp; devicePath) &#123; //如果目标路径是当前已存在的设备（之前扫描过的设备）的，就不再扫描这个路径了，避免出现重复设备 for (const auto&amp; [deviceId, device] : mDevices) &#123; if (device-&gt;path == devicePath) &#123; return; // device was already registered &#125; &#125; char buffer[80]; ALOGV(&quot;Opening device: %s&quot;, devicePath.c_str()); //通过open打开设备节点，返回该设备节点的fd int fd = open(devicePath.c_str(), O_RDWR | O_CLOEXEC | O_NONBLOCK); InputDeviceIdentifier identifier; //一个硬件设备的结构体在用户空间中描述, 包括name、vendor、product、descriptor等 // Get device name. //获取设备 device name if (ioctl(fd, EVIOCGNAME(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123; ALOGE(&quot;Could not get device name for %s: %s&quot;, devicePath.c_str(), strerror(errno)); &#125; else &#123; buffer[sizeof(buffer) - 1] = &#39;\\0&#39;; identifier.name = buffer; &#125; // Check to see if the device is on our excluded list //通过device name检测下这个设备是不是在排除名单，如果是就忽略这个设备 for (size_t i = 0; i &lt; mExcludedDevices.size(); i++) &#123; const std::string&amp; item = mExcludedDevices[i]; if (identifier.name == item) &#123; ALOGI(&quot;ignoring event id %s driver %s\\n&quot;, devicePath.c_str(), item.c_str()); close(fd); return; &#125; &#125; // Get device driver version. //获取设备驱动版本 int driverVersion; if (ioctl(fd, EVIOCGVERSION, &amp;driverVersion)) &#123; &#125; // Get device identifier. //获取设备的identifier，是设备在内核空间的描述 //内核描述为input_id结构体，内容为：bustype、product、product、version struct input_id inputId; if (ioctl(fd, EVIOCGID, &amp;inputId)) &#123; &#125; identifier.bus = inputId.bustype; identifier.product = inputId.product; identifier.vendor = inputId.product; identifier.version = inputId.version; // Get device physical location. //获取设备的物理位置（物理拓扑中的位置） if (ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123; // fprintf(stderr, &quot;could not get location for %s, %s\\n&quot;, devicePath, strerror(errno)); &#125; else &#123; buffer[sizeof(buffer) - 1] = &#39;\\0&#39;; identifier.location = buffer; &#125; // Get device unique id. //获取设备的unique id（一般的设备这个字段都是没有的，为空） if (ioctl(fd, EVIOCGUNIQ(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123; // fprintf(stderr, &quot;could not get idstring for %s, %s\\n&quot;, devicePath, strerror(errno)); &#125; else &#123; buffer[sizeof(buffer) - 1] = &#39;\\0&#39;; identifier.uniqueId = buffer; &#125; // Fill in the descriptor. // 获取设备的descriptor，这个字段很重要，它是用于标识这个设备的标识符，无论重启、拔插、升级都不会变 //根据unique_id、vendor_id、product_id、随机数组合后sha1转化生成，赋值给identifier.descriptor assignDescriptorLocked(identifier); // Allocate device. (The device object takes ownership of the fd at this point.) //创建Device结构体，用于描述当前从驱动获取到的这个输入设备，将前面获取的设备fd、设备节点路径devicePath、设备硬件描述identifier赋给这个Device, //同时还有deviceId，这个id并不是驱动传上来的，而是我们每次通过ioctl获取到新设备时计数 + 1 int32_t deviceId = mNextDeviceId++; std::unique_ptr&lt;Device&gt; device = std::make_unique&lt;Device&gt;(fd, deviceId, devicePath, identifier); //我们可以通过这个打印或者dumpsys input获取设备的信息 ALOGV(&quot;add device %d: %s\\n&quot;, deviceId, devicePath.c_str()); ALOGV(&quot; bus: %04x\\n&quot; &quot; vendor %04x\\n&quot; &quot; product %04x\\n&quot; &quot; version %04x\\n&quot;, identifier.bus, identifier.vendor, identifier.product, identifier.version); ALOGV(&quot; name: \\&quot;%s\\&quot;\\n&quot;, identifier.name.c_str()); ALOGV(&quot; location: \\&quot;%s\\&quot;\\n&quot;, identifier.location.c_str()); ALOGV(&quot; unique id: \\&quot;%s\\&quot;\\n&quot;, identifier.uniqueId.c_str()); ALOGV(&quot; descriptor: \\&quot;%s\\&quot;\\n&quot;, identifier.descriptor.c_str()); ALOGV(&quot; driver: v%d.%d.%d\\n&quot;, driverVersion &gt;&gt; 16, (driverVersion &gt;&gt; 8) &amp; 0xff, driverVersion &amp; 0xff); // Load the configuration file for the device. //为当前获取到的设备加载`.idc`配置文件，格式一般是：/vendor/usr/idc/Vendor_XXXX_Product_XXXX_Version_XXXX.idc //通过product/vendor/version来检索主要路径下符合条件的`idc`文件 //解析该文件后保存在device对象的configuration变量中 device-&gt;loadConfigurationLocked(); // 针对带电池，有LED灯的输入设备，需要设备associatedDevice来关联它的额外能力 bool hasBattery = false; bool hasLights = false; // Check the sysfs root path std::optional&lt;std::filesystem::path&gt; sysfsRootPath = getSysfsRootPath(devicePath.c_str()); if (sysfsRootPath.has_value()) &#123; std::shared_ptr&lt;AssociatedDevice&gt; associatedDevice; for (const auto&amp; [id, dev] : mDevices) &#123; if (device-&gt;identifier.descriptor == dev-&gt;identifier.descriptor &amp;&amp; !dev-&gt;associatedDevice) &#123; associatedDevice = dev-&gt;associatedDevice; &#125; &#125; if (!associatedDevice) &#123; associatedDevice = std::make_shared&lt;AssociatedDevice&gt;(sysfsRootPath.value()); &#125; hasBattery = associatedDevice-&gt;configureBatteryLocked(); hasLights = associatedDevice-&gt;configureLightsLocked(); device-&gt;associatedDevice = associatedDevice; &#125; //向ioctl驱动查询这个设备会上报那种类型的事件，每个类型都问一下支不支持，有点... //设备会上报哪一种事件，对应的XXBitmask就会有对应的值，用于判断它是什么类型的设备 // Figure out the kinds of events the device reports. device-&gt;readDeviceBitMask(EVIOCGBIT(EV_KEY, 0), device-&gt;keyBitmask); device-&gt;readDeviceBitMask(EVIOCGBIT(EV_ABS, 0), device-&gt;absBitmask); device-&gt;readDeviceBitMask(EVIOCGBIT(EV_REL, 0), device-&gt;relBitmask); device-&gt;readDeviceBitMask(EVIOCGBIT(EV_SW, 0), device-&gt;swBitmask); device-&gt;readDeviceBitMask(EVIOCGBIT(EV_LED, 0), device-&gt;ledBitmask); device-&gt;readDeviceBitMask(EVIOCGBIT(EV_FF, 0), device-&gt;ffBitmask); device-&gt;readDeviceBitMask(EVIOCGBIT(EV_MSC, 0), device-&gt;mscBitmask); device-&gt;readDeviceBitMask(EVIOCGPROP(0), device-&gt;propBitmask); // See if this is a keyboard. Ignore everything in the button range except for // joystick and gamepad buttons which are handled like keyboards for the most part. // 判断是否是键盘、游戏手柄等 bool haveKeyboardKeys = device-&gt;keyBitmask.any(0, BTN_MISC) || device-&gt;keyBitmask.any(BTN_WHEEL, KEY_MAX + 1); bool haveGamepadButtons = device-&gt;keyBitmask.any(BTN_MISC, BTN_MOUSE) || device-&gt;keyBitmask.any(BTN_JOYSTICK, BTN_DIGI); if (haveKeyboardKeys || haveGamepadButtons) &#123; device-&gt;classes |= InputDeviceClass::KEYBOARD; &#125; // See if this is a cursor device such as a trackball or mouse. //判断设备是不是鼠标或者轨迹球类型 if (device-&gt;keyBitmask.test(BTN_MOUSE) &amp;&amp; device-&gt;relBitmask.test(REL_X) &amp;&amp; device-&gt;relBitmask.test(REL_Y)) &#123; device-&gt;classes |= InputDeviceClass::CURSOR; &#125; // See if this is a rotary encoder type device. //判断设备是不是旋转编码器类型（旋钮） String8 deviceType = String8(); if (device-&gt;configuration &amp;&amp; device-&gt;configuration-&gt;tryGetProperty(String8(&quot;device.type&quot;), deviceType)) &#123; if (!deviceType.compare(String8(&quot;rotaryEncoder&quot;))) &#123; device-&gt;classes |= InputDeviceClass::ROTARY_ENCODER; &#125; &#125; // See if this is a touch pad. // Is this a new modern multi-touch driver? //是不是触摸板，支不支持多点触摸 if (device-&gt;absBitmask.test(ABS_MT_POSITION_X) &amp;&amp; device-&gt;absBitmask.test(ABS_MT_POSITION_Y)) &#123; // Some joysticks such as the PS3 controller report axes that conflict // with the ABS_MT range. Try to confirm that the device really is // a touch screen. if (device-&gt;keyBitmask.test(BTN_TOUCH) || !haveGamepadButtons) &#123; device-&gt;classes |= (InputDeviceClass::TOUCH | InputDeviceClass::TOUCH_MT); &#125; // Is this an old style single-touch driver? //是不是老版的单点触摸驱动 &#125; else if (device-&gt;keyBitmask.test(BTN_TOUCH) &amp;&amp; device-&gt;absBitmask.test(ABS_X) &amp;&amp; device-&gt;absBitmask.test(ABS_Y)) &#123; device-&gt;classes |= InputDeviceClass::TOUCH; // Is this a BT stylus? //是不是蓝牙手写笔 &#125; else if ((device-&gt;absBitmask.test(ABS_PRESSURE) || device-&gt;keyBitmask.test(BTN_TOUCH)) &amp;&amp; !device-&gt;absBitmask.test(ABS_X) &amp;&amp; !device-&gt;absBitmask.test(ABS_Y)) &#123; device-&gt;classes |= InputDeviceClass::EXTERNAL_STYLUS; // Keyboard will try to claim some of the buttons but we really want to reserve those so we // can fuse it with the touch screen data, so just take them back. Note this means an // external stylus cannot also be a keyboard device. //外部手写笔不能同时是键盘设备 device-&gt;classes &amp;= ~InputDeviceClass::KEYBOARD; &#125; // See if this device is a joystick. // Assumes that joysticks always have gamepad buttons in order to distinguish them // from other devices such as accelerometers that also have absolute axes. //是不是操作杆 if (haveGamepadButtons) &#123; auto assumedClasses = device-&gt;classes | InputDeviceClass::JOYSTICK; for (int i = 0; i &lt;= ABS_MAX; i++) &#123; if (device-&gt;absBitmask.test(i) &amp;&amp; (getAbsAxisUsage(i, assumedClasses).test(InputDeviceClass::JOYSTICK))) &#123; device-&gt;classes = assumedClasses; break; &#125; &#125; &#125; // Check whether this device is an accelerometer. //是不是加速计 if (device-&gt;propBitmask.test(INPUT_PROP_ACCELEROMETER)) &#123; device-&gt;classes |= InputDeviceClass::SENSOR; &#125; // Check whether this device has switches. //是不是有开关 for (int i = 0; i &lt;= SW_MAX; i++) &#123; if (device-&gt;swBitmask.test(i)) &#123; device-&gt;classes |= InputDeviceClass::SWITCH; break; &#125; &#125; // Check whether this device supports the vibrator. //支不支持震动 if (device-&gt;ffBitmask.test(FF_RUMBLE)) &#123; device-&gt;classes |= InputDeviceClass::VIBRATOR; &#125; // Configure virtual keys. //虚拟按键（类似于老手机上面三个虚拟按键back、home、recent） if ((device-&gt;classes.test(InputDeviceClass::TOUCH))) &#123; // Load the virtual keys for the touch screen, if any. // We do this now so that we can make sure to load the keymap if necessary. bool success = device-&gt;loadVirtualKeyMapLocked(); if (success) &#123; device-&gt;classes |= InputDeviceClass::KEYBOARD; &#125; &#125; // Load the key map. // We need to do this for joysticks too because the key layout may specify axes, and for // sensor as well because the key layout may specify the axes to sensor data mapping. //如果设备是键盘等设备就加载按键映射配置文件， //包括kl(keyLayout)文件、kcm(KeyCharacterMap)文件 status_t keyMapStatus = NAME_NOT_FOUND; if (device-&gt;classes.any(InputDeviceClass::KEYBOARD | InputDeviceClass::JOYSTICK | InputDeviceClass::SENSOR)) &#123; // Load the keymap for the device. keyMapStatus = device-&gt;loadKeyMapLocked(); //加载过程和idc文件类似 &#125; // Configure the keyboard, gamepad or virtual keyboard. //配置键盘、手柄、虚拟键盘相关 if (device-&gt;classes.test(InputDeviceClass::KEYBOARD)) &#123; // Register the keyboard as a built-in keyboard if it is eligible. //如果符合内置键盘的条件就把这个device指定为内置键盘 if (!keyMapStatus &amp;&amp; mBuiltInKeyboardId == NO_BUILT_IN_KEYBOARD &amp;&amp; isEligibleBuiltInKeyboard(device-&gt;identifier, device-&gt;configuration.get(), &amp;device-&gt;keyMap)) &#123; mBuiltInKeyboardId = device-&gt;id; &#125; // &#39;Q&#39; key support = cheap test of whether this is an alpha-capable kbd //如果有Q键就说明是一个标准全功能键盘，设置为ALPHAKEY类型 if (device-&gt;hasKeycodeLocked(AKEYCODE_Q)) &#123; device-&gt;classes |= InputDeviceClass::ALPHAKEY; &#125; // See if this device has a DPAD. //如果有方向键 if (device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_UP) &amp;&amp; device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_DOWN) &amp;&amp; device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_LEFT) &amp;&amp; device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_RIGHT) &amp;&amp; device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_CENTER)) &#123; device-&gt;classes |= InputDeviceClass::DPAD; &#125; // See if this device has a gamepad. //如果是游戏手柄 for (size_t i = 0; i &lt; sizeof(GAMEPAD_KEYCODES) / sizeof(GAMEPAD_KEYCODES[0]); i++) &#123; if (device-&gt;hasKeycodeLocked(GAMEPAD_KEYCODES[i])) &#123; device-&gt;classes |= InputDeviceClass::GAMEPAD; break; &#125; &#125; &#125; // If the device isn&#39;t recognized as something we handle, don&#39;t monitor it. //如果这个设备上面的类型都不符合，那么这个设备就是个屑，不用往下处理了，忽略，直接返回 if (device-&gt;classes == ftl::Flags&lt;InputDeviceClass&gt;(0)) &#123; ALOGV(&quot;Dropping device: id=%d, path=&#39;%s&#39;, name=&#39;%s&#39;&quot;, deviceId, devicePath.c_str(), device-&gt;identifier.name.c_str()); return; &#125; // Classify InputDeviceClass::BATTERY. //如果这个设备还有关联的电池 if (hasBattery) &#123; device-&gt;classes |= InputDeviceClass::BATTERY; &#125; // Classify InputDeviceClass::LIGHT. //如果这个设备还有先进的LED灯 if (hasLights) &#123; device-&gt;classes |= InputDeviceClass::LIGHT; &#125; // Determine whether the device has a mic. //如果这个设备还有麦克风 if (device-&gt;deviceHasMicLocked()) &#123; device-&gt;classes |= InputDeviceClass::MIC; &#125; // Determine whether the device is external or internal. //从设备的idc文件中获取这个设备是内部设备还是外接设备，这个会影响一些优先级等，比如多屏 if (device-&gt;isExternalDeviceLocked()) &#123; device-&gt;classes |= InputDeviceClass::EXTERNAL; &#125; //游戏手柄和操作杆有时会有多个controller if (device-&gt;classes.any(InputDeviceClass::JOYSTICK | InputDeviceClass::DPAD) &amp;&amp; device-&gt;classes.test(InputDeviceClass::GAMEPAD)) &#123; device-&gt;controllerNumber = getNextControllerNumberLocked(device-&gt;identifier.name); device-&gt;setLedForControllerLocked(); &#125; //将这个设备的fd加入epoll的监听 if (registerDeviceForEpollLocked(*device) != OK) &#123; return; &#125; //使用ioctl设置fd参数，例如按键重复、挂起块和时钟类型 device-&gt;configureFd(); ALOGI(&quot;New device: id=%d, fd=%d, path=&#39;%s&#39;, name=&#39;%s&#39;, classes=%s, &quot; &quot;configuration=&#39;%s&#39;, keyLayout=&#39;%s&#39;, keyCharacterMap=&#39;%s&#39;, builtinKeyboard=%s, &quot;, deviceId, fd, devicePath.c_str(), device-&gt;identifier.name.c_str(), device-&gt;classes.string().c_str(), device-&gt;configurationFile.c_str(), device-&gt;keyMap.keyLayoutFile.c_str(), device-&gt;keyMap.keyCharacterMapFile.c_str(), toString(mBuiltInKeyboardId == deviceId)); //到这里从驱动获取到的这个设备已经完成各种初始化和配置，是时候加到mOpeningDevices中了，继续下一个循环，最后读取所有的设备 addDeviceLocked(std::move(device)); &#125; 这个方法很长，总的概括来看就做了几件事情： 打开设备节点，从设备驱动中获取设备的各种描述信息并构造出Device对象 根据设备的信息加载这个设备的idc文件 向驱动查询这个设备支持的事件类型 判断设备的类型，设置相关的属性到device-&gt;classes中 如果是键盘灯设备还需要加载设备对应的kl文件和kcm文件， 将这个设备的fd加入epoll的监听中 通过ioctl设置fd参数，例如按键重复、挂起块和时钟类型 最后再把这个设备加到mOpeningDevices中管理","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"InPutManagerService","slug":"Android-FrameWork/Framework源码分析/Android-13/InPutManagerService","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/InPutManagerService/1.InputFlinger的启动/","text":"服务的启动frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123; t.traceBegin(&quot;startOtherServices&quot;); ... WindowManagerService wm = null; InputManagerService inputManager = null; try &#123; //1. 获取InputManagerService，并走初始化inputManager流程 ... t.traceBegin(&quot;StartInputManagerService&quot;); inputManager = new InputManagerService(context); t.traceEnd(); ... //2. WindowManagerService服务持有inputManager对象 t.traceBegin(&quot;StartWindowManagerService&quot;); wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore, new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); ... //3. 向ServiceManager注册java层ims服务，name = &quot;input&quot;，(native层的服务name = &quot;inputflinger&quot;) ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); t.traceEnd(); ... //4. 启动inputflinger，处理输入事件 t.traceBegin(&quot;StartInputManager&quot;); inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback()); inputManager.start(); t.traceEnd(); ... &#125; catch (Throwable e) &#123; ... &#125; 获取InputManagerService，并走初始化inputManager（java层和native层）流程 WindowManagerService服务构造时传入inputManager对象，用户wms和ims交互 向ServiceManager注册java层ims服务 启动inputflinger，处理输入事件 我们重点看下1和4 1. 初始化InputFlingerframeworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java public InputManagerService(Context context) &#123; this(new Injector(context, DisplayThread.get().getLooper())); &#125; @VisibleForTesting InputManagerService(Injector injector) &#123; ... mContext = injector.getContext(); mHandler = new InputManagerHandler(injector.getLooper()); //创建一个handle（使用DisplayThread，这个线程用户 //wms，display，input三个服务使用，对延迟敏感） mNative = injector.getNativeService(this); //创建native input服务（NativeInputManagerService） ... injector.registerLocalService(new LocalService()); //将InputManagerService中的InputManagerInternal实现类加入LocalServices，供同进程其他服务调用相关功能 &#125; @VisibleForTesting static class Injector &#123; private final Context mContext; private final Looper mLooper; Injector(Context context, Looper looper) &#123; mContext = context; mLooper = looper; &#125; Context getContext() &#123; return mContext; &#125; Looper getLooper() &#123; return mLooper; &#125; //创建native层对应的service NativeInputManagerService getNativeService(InputManagerService service) &#123; return new NativeInputManagerService.NativeImpl(service, mContext, mLooper.getQueue()); &#125; //将InputManagerService中的InputManagerInternal实现类加入LocalServices，供同进程其他服务调用相关功能 void registerLocalService(InputManagerInternal localService) &#123; LocalServices.addService(InputManagerInternal.class, localService); &#125; &#125; NativeInputManagerService.NativeImpl1234567891011121314151617public interface NativeInputManagerService &#123; ... class NativeImpl implements NativeInputManagerService &#123; /** Pointer to native input manager service object, used by native code. */ @SuppressWarnings(&#123;&quot;unused&quot;, &quot;FieldCanBeLocal&quot;&#125;) private final long mPtr; NativeImpl(InputManagerService service, Context context, MessageQueue messageQueue) &#123; mPtr = init(service, context, messageQueue); //初始化native层服务并返回该服务的对象指针到java层 &#125; private native long init(InputManagerService service, Context context, MessageQueue messageQueue); ... &#125; ...&#125; nativeInitframeworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;com_android_server_input_InputManagerService.cpp static const JNINativeMethod gInputManagerMethods[] = &#123; &#123;&quot;init&quot;, &quot;(Lcom/android/server/input/InputManagerService;Landroid/content/Context;Landroid/os/&quot; &quot;MessageQueue;)J&quot;, (void*)nativeInit&#125;, //init(java)-&gt;nativeInit(native) ... &#125;; static jlong nativeInit(JNIEnv* env, jclass /* clazz */, jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123; sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); ... // 创建native层NativeInputManager，保存java层的context对象、ims对象、msgqueue NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper()); im-&gt;incStrong(0); //NativeInputManager对象强引用 + 1 return reinterpret_cast&lt;jlong&gt;(im); //将native层NativeInputManager对象地址返回给java层，这个地址可以在native层获取出同一个对象 &#125; //NativeInputManager类声明，实现了三个重要接口抽象类 /*class NativeInputManager : public virtual RefBase, public virtual InputReaderPolicyInterface, public virtual InputDispatcherPolicyInterface, public virtual PointerControllerPolicyInterface &#123; */ NativeInputManager::NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : mLooper(looper), mInteractive(true) &#123; JNIEnv* env = jniEnv(); //获取虚拟机环境指针 mServiceObj = env-&gt;NewGlobalRef(serviceObj); //将java层的ims对象保存为全局引用 &#123; AutoMutex _l(mLock); mLocked.systemUiLightsOut = false; mLocked.pointerSpeed = 0; mLocked.pointerAcceleration = android::os::IInputConstants::DEFAULT_POINTER_ACCELERATION; mLocked.pointerGesturesEnabled = true; mLocked.showTouches = false; mLocked.pointerDisplayId = ADISPLAY_ID_DEFAULT; &#125; mInteractive = true; InputManager* im = new InputManager(this, this); //创建native层InputManager mInputManager = im; defaultServiceManager()-&gt;addService(String16(&quot;inputflinger&quot;), im); //向ServiceManager注册native层inputflinger服务 &#125; new InputManagerframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputManager.cpp /** * The event flow is via the &quot;InputListener&quot; interface, as follows: * InputReader -&gt; UnwantedInteractionBlocker -&gt; InputClassifier -&gt; InputDispatcher */ InputManager::InputManager( const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123; mDispatcher = createInputDispatcher(dispatcherPolicy); mClassifier = std::make_unique&lt;InputClassifier&gt;(*mDispatcher); mBlocker = std::make_unique&lt;UnwantedInteractionBlocker&gt;(*mClassifier); mReader = createInputReader(readerPolicy, *mBlocker); &#125; 创建并初始化四个event flow中的重要对象, 事件从前到后传递，前面的对象依次持有下一个阶段的对象引用event flow: InputReader -&gt; UnwantedInteractionBlocker -&gt; InputClassifier -&gt; InputDispatcher createInputDispatcherframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;dispatcher&#x2F;InputDispatcher.cpp //InputDispatcherFactory.cpp std::unique_ptr&lt;InputDispatcherInterface&gt; createInputDispatcher( const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) &#123; return std::make_unique&lt;android::inputdispatcher::InputDispatcher&gt;(policy); &#125; // InputDispatcher.cpp InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) : InputDispatcher(policy, STALE_EVENT_TIMEOUT) &#123;&#125; InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy, std::chrono::nanoseconds staleEventTimeout) : mPolicy(policy), //将接口实现对象传进来，用户和wms服务交互 ...//一些成员变量初始化，太多了不列出 &#123; mLooper = new Looper(false); //用于InputDispatcher线程 mReporter = createInputReporter(); //注册SurfaceComposer监听，当window状态改变时回调此接口onWindowInfosChanged通知inputflinger mWindowInfoListener = new DispatcherWindowListener(*this); SurfaceComposerClient::getDefault()-&gt;addWindowInfosListener(mWindowInfoListener); mKeyRepeatState.lastKeyEntry = nullptr; policy-&gt;getDispatcherConfiguration(&amp;mConfig); &#125; InputClassifierframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputClassifier.cpp //构建InputClassifier，传入mQueuedListener = listener 这个就是mDispatcher对象，这样就可以回调mDispatcher的方法 InputClassifier::InputClassifier(InputListenerInterface&amp; listener) : mQueuedListener(listener) &#123;&#125; UnwantedInteractionBlocker//UnwantedInteractionBlocker是所有输入事件都会经历的一个阶段 //inputReader通过它notifyXXX方法向InputDispatcher传递对应事件 //其中对于触摸事件，如果支持手掌误触等功能，则会在这里有特殊处理 UnwantedInteractionBlocker::UnwantedInteractionBlocker(InputListenerInterface&amp; listener) : UnwantedInteractionBlocker(listener, isPalmRejectionEnabled())&#123;&#125;; //isPalmRejectionEnabled 检测是否开始手掌误触功能 UnwantedInteractionBlocker::UnwantedInteractionBlocker(InputListenerInterface&amp; listener, bool enablePalmRejection) : mQueuedListener(listener), mEnablePalmRejection(enablePalmRejection) &#123;&#125; InputReaderframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputReader.cpp std::unique_ptr&lt;InputReaderInterface&gt; createInputReader( const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, InputListenerInterface&amp; listener) &#123; return std::make_unique&lt;InputReader&gt;(std::make_unique&lt;EventHub&gt;(), policy, listener); &#125; InputReader::InputReader(std::shared_ptr&lt;EventHubInterface&gt; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, InputListenerInterface&amp; listener) : mContext(this), mEventHub(eventHub), //1.初始化EventHub mPolicy(policy), mQueuedListener(listener), //2. 传入UnwantedInteractionBlocker对象 mGlobalMetaState(AMETA_NONE), mLedMetaState(AMETA_NONE), mGeneration(1), mNextInputDeviceId(END_RESERVED_ID), mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX), mConfigurationChangesToRefresh(0) &#123; refreshConfigurationLocked(0); updateGlobalMetaStateLocked(); &#125; InputReader最重要就是： 创建并初始化EventHub, 通过它向驱动获取上报的事件 注册UnwantedInteractionBlocker listener, 通过它向inputDispater传递事件 EventHubframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;EventHub.cpp EventHub::EventHub(void) : mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(), mNeedToSendFinishedDeviceScan(false), mNeedToReopenDevices(false), mNeedToScanDevices(true), mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(false) &#123; ensureProcessCanBlockSuspend(); //初始化epoll (用于监听文件描述符上的事件，用于监听具体/dev/input/eventX的fd的事件) mEpollFd = epoll_create1(EPOLL_CLOEXEC); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno)); //初始化inotify (用于监听文件和目录的变化，这里主要时用于监听/dev/input/下面的目录变化) mINotifyFd = inotify_init1(IN_CLOEXEC); std::error_code errorCode; bool isDeviceInotifyAdded = false; //检测 &quot;/dev/input&quot; 文件节点是否存在 if (std::filesystem::exists(DEVICE_INPUT_PATH, errorCode)) &#123; //如果当前&quot;/dev/input&quot; 文件节点存在则将这个路径加入Inotify监听 addDeviceInputInotify(); &#125; else &#123; //如果当前&quot;/dev/input&quot; 文件节点不存在，则先将这个路径&quot;/dev&quot;加入Inotify监听(监听dev所有节点) //因为有些嵌入式设备不一定一直存在输入设备，那么仅当/dev/input出现时（插入输入设备）才添加对/dev/input内容的监听, addDeviceInotify(); isDeviceInotifyAdded = true; &#125; //V4L视频设备相关 if (isV4lScanningEnabled() &amp;&amp; !isDeviceInotifyAdded) &#123; addDeviceInotify(); &#125; else &#123; ALOGI(&quot;Video device scanning disabled&quot;); &#125; struct epoll_event eventItem = &#123;&#125;; eventItem.events = EPOLLIN | EPOLLWAKEUP; //设置监听epoll事件类型 eventItem.data.fd = mINotifyFd;//要处理的事件相关的文件描述符 //将mINotifyFd加入epoll监听的fd池子 int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem); //创建一个管道 int wakeFds[2]; result = pipe2(wakeFds, O_CLOEXEC); mWakeReadPipeFd = wakeFds[0]; //0为读端 mWakeWritePipeFd = wakeFds[1]; //1为写端 result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK); result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK); eventItem.data.fd = mWakeReadPipeFd; //将mWakeReadPipeFd设置到eventItem.data.fd，当epoll有event到来会 //将管道读端fd加入epoll监听的fd池子，当管道写端写入数据时，读端就换监听到epoll事件 result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem); &#125; 到这里初始化InputFlinger就完成了 2. 启动inputflinger，处理输入事件前面SystemServer的1、2、3步都完成后，会往下执行 //4. 启动inputflinger，处理输入事件 t.traceBegin(&quot;StartInputManager&quot;); //ims也注册wms的回调，用于通知wms一些事件发生 inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback()); inputManager.start(); //启动ims，开始处理输入事件 t.traceEnd(); start()frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java public void start() &#123; Slog.i(TAG, &quot;Starting input manager&quot;); mNative.start(); //到native中的方法 // Add ourselves to the Watchdog monitors. Watchdog.getInstance().addMonitor(this); //加入Watchdog的检测列表中 //一系列对settings中开关的状态值监听 ... &#125; nativeStartframeworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;com_android_server_input_InputManagerService.cpp static void nativeStart(JNIEnv* env, jobject nativeImplObj) &#123; NativeInputManager* im = getNativeInputManager(env, nativeImplObj); status_t result = im-&gt;getInputManager()-&gt;start(); &#125; InputManager::start()status_t InputManager::start() &#123; status_t result = mDispatcher-&gt;start(); result = mReader-&gt;start(); return OK; &#125; 分别调用inputDispatcher和inputReader的start方法 InputDispatcher::start()//InputManager.cpp status_t InputDispatcher::start() &#123; //创建线程InputDispatcher，线程体函数dispatchOnce(), 线程唤醒函数mLooper-&gt;wake() mThread = std::make_unique&lt;InputThread&gt;( &quot;InputDispatcher&quot;, [this]() &#123; dispatchOnce(); &#125;, [this]() &#123; mLooper-&gt;wake(); &#125;); return OK; &#125; InputThread继承与Thead类frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputThread.cpp InputThread::InputThread(std::string name, std::function&lt;void()&gt; loop, std::function&lt;void()&gt; wake) : mName(name), mThreadWake(wake) &#123; mThread = new InputThreadImpl(loop); mThread-&gt;run(mName.c_str(), ANDROID_PRIORITY_URGENT_DISPLAY); //启动线程，线程优先级很高 &#125; class InputThreadImpl : public Thread &#123; public: explicit InputThreadImpl(std::function&lt;void()&gt; loop) : Thread(/* canCallJava */ true), mThreadLoop(loop) &#123;&#125; ~InputThreadImpl() &#123;&#125; private: std::function&lt;void()&gt; mThreadLoop; bool threadLoop() override &#123; mThreadLoop(); return true; &#125; &#125;; 创建一个线程，用于分发事件，线程执行体dispatchOnce() void InputDispatcher::dispatchOnce() &#123; nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock std::scoped_lock _l(mLock); mDispatcherIsAlive.notify_all(); // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); //处理事件的分发 &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptable()) &#123; //处理命令队列中的命令 nextWakeupTime = LONG_LONG_MIN; &#125; // If we are still waiting for ack on some events, // we might have to wake up earlier to check if an app is anr&#39;ing. const nsecs_t nextAnrCheck = processAnrsLocked(); //处理input ANR相关 nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck); // We are about to enter an infinitely long sleep, because we have no commands or // pending or queued events if (nextWakeupTime == LONG_LONG_MAX) &#123; mDispatcherEnteredIdle.notify_all(); //线程进入idle状态 &#125; &#125; // release lock // Wait for callback or timeout or wake. (make sure we round up, not down) nsecs_t currentTime = now(); int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); mLooper-&gt;pollOnce(timeoutMillis); //再次进入阻塞等待中 &#125; InputReader::start()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849status_t InputReader::start() &#123; //创建线程InputReader，线程体函数loopOnce(), 线程唤醒函数mEventHub-&gt;wake()（调用EventHub的wake方法来唤醒） mThread = std::make_unique&lt;InputThread&gt;( &quot;InputReader&quot;, [this]() &#123; loopOnce(); &#125;, [this]() &#123; mEventHub-&gt;wake(); &#125;); return OK;&#125;void InputReader::loopOnce() &#123; int32_t oldGeneration; int32_t timeoutMillis; bool inputDevicesChanged = false; std::vector&lt;InputDeviceInfo&gt; inputDevices; ... //调用EventHub的getEvents获取输入事件 size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); &#123; // acquire lock std::scoped_lock _l(mLock); mReaderIsAliveCondition.notify_all(); if (count) &#123; processEventsLocked(mEventBuffer, count); &#125; if (mNextTimeout != LLONG_MAX) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); if (now &gt;= mNextTimeout) &#123; if (DEBUG_RAW_EVENTS) &#123; ALOGD(&quot;Timeout expired, latency=%0.3fms&quot;, (now - mNextTimeout) * 0.000001f); &#125; mNextTimeout = LLONG_MAX; timeoutExpiredLocked(now); &#125; &#125; if (oldGeneration != mGeneration) &#123; inputDevicesChanged = true; inputDevices = getInputDevicesLocked(); &#125; &#125; // release lock // Send out a message that the describes the changed input devices. //如果输入设备有变化，通知其他服务 if (inputDevicesChanged) &#123; mPolicy-&gt;notifyInputDevicesChanged(inputDevices); &#125; mQueuedListener.flush();&#125; 线程在循环从mEventHub-&gt;getEvents获取输入事件（这个方法会引起阻塞），如果获取到事件，EventHub会唤醒此线程，返回后会刷新mQueuedListener的事件队列, 唤醒InputDispatcher线程来消费。到这里inputflinger的启动就完成，开始正常等待输入事件的上报并处理。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"InPutManagerService","slug":"Android-FrameWork/Framework源码分析/Android-13/InPutManagerService","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/InPutManagerService/3.InputReader事件处理/","text":"####回顾 从前面的InputFlinger的启动可知，InputReader线程启动后会循环执行loopOnce()方法，然后阻塞在getEvents等待事件的上报，这里就从loopOnce获取到事件被唤醒后来分析InputReader对事件的处理。 InputReader::loopOnce()frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputReader.cpp void InputReader::loopOnce() &#123; int32_t oldGeneration; int32_t timeoutMillis; bool inputDevicesChanged = false; std::vector&lt;InputDeviceInfo&gt; inputDevices; ... //从EventHub中读取事件 size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); &#123; // acquire lock ... if (count) &#123; //处理事件 processEventsLocked(mEventBuffer, count); &#125; ... &#125; // release lock // Send out a message that the describes the changed input devices. //如果输入设备状态改变则通过回调通知java层 if (inputDevicesChanged) &#123; mPolicy-&gt;notifyInputDevicesChanged(inputDevices); &#125; // Flush queued events out to the listener. mQueuedListener.flush(); &#125; 一、处理事件InputReader::processEventsLockedvoid InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123; for (const RawEvent* rawEvent = rawEvents; count;) &#123; int32_t type = rawEvent-&gt;type; size_t batchSize = 1; //除了设备添加、移除、结束扫描事件之外的普通事件采用批处理方式方式处理 if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123; int32_t deviceId = rawEvent-&gt;deviceId; while (batchSize &lt; count) &#123; //如果出现不符合批处理的事件（一般上面的判断已经足够）则退出本次事件流程 if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT || rawEvent[batchSize].deviceId != deviceId) &#123; break; &#125; batchSize += 1; &#125; //处理普通事件（批量处理） processEventsForDeviceLocked(deviceId, rawEvent, batchSize); &#125; else &#123; switch (rawEvent-&gt;type) &#123; //如果是设备添加事件 case EventHubInterface::DEVICE_ADDED: //添加设备主要就是创建设备对应的inputDevice //通过设备的class类型创建对应的mapper //将对应的mapper和EventHub、inputReader关联（InputDeviceContext） //然后将对应的deviceId、mapper、InputDeviceContext加入inputDevice容器中 addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; //如果是设备移除事件 case EventHubInterface::DEVICE_REMOVED: removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId); break; //如果是设备结束扫描事件 case EventHubInterface::FINISHED_DEVICE_SCAN: handleConfigurationChangedLocked(rawEvent-&gt;when); break; default: ALOG_ASSERT(false); // can&#39;t happen break; &#125; &#125; count -= batchSize; rawEvent += batchSize; &#125; &#125; InputReader::processEventsForDeviceLockedvoid InputReader::processEventsForDeviceLocked(int32_t eventHubId, const RawEvent* rawEvents, size_t count) &#123; auto deviceIt = mDevices.find(eventHubId); //通过device id找到事件对应的inputDevice对象 ... device-&gt;process(rawEvents, count); //调用事件对应的inputDevice对象process处理当前事件 &#125; InputDevice::processframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputDevice.cpp void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123; //按顺序分发给对应的mapper处理，要求事件按照时间顺序处理 for (const RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) &#123; if (mDropUntilNextSync) &#123; //抛弃下一个SYN事件前的所有事件 ... &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123; ... &#125; else &#123; //正常走这里 //通过deviceId查询mDevices中对应的mapper（这个是在设备add事件时添加的） for_each_mapper_in_subdevice(rawEvent-&gt;deviceId, [rawEvent](InputMapper&amp; mapper) &#123; mapper.process(rawEvent); &#125;); &#125; --count; &#125; &#125; for_each_mapper_in_subdeviceframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;include&#x2F;InputDevice.h // run a function against every mapper on a specific subdevice inline void for_each_mapper_in_subdevice(int32_t eventHubDevice, std::function&lt;void(InputMapper&amp;)&gt; f) &#123; auto deviceIt = mDevices.find(eventHubDevice); if (deviceIt != mDevices.end()) &#123; auto&amp; devicePair = deviceIt-&gt;second; auto&amp; mappers = devicePair.second; for (auto&amp; mapperPtr : mappers) &#123; f(*mapperPtr); &#125; &#125; &#125; 通过rawEvent-&gt;deviceId来查询这个事件对应的设备在设备add事件时添加的mapper，这个mapper是根据device的class类型来决定的 MultiTouchInputMapper::process在InputReader::addDeviceLocked中可以知道触摸现在走的是MultiTouchInputMapperframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;mapper&#x2F;MultiTouchInputMapper.cpp void MultiTouchInputMapper::process(const RawEvent* rawEvent) &#123; TouchInputMapper::process(rawEvent); //处理常规触摸EV_ABS事件，包括多指情况（多个slot） mMultiTouchMotionAccumulator.process(rawEvent); &#125; void TouchInputMapper::process(const RawEvent* rawEvent) &#123; mCursorButtonAccumulator.process(rawEvent); //如果是光标按键事件，一般不是 mCursorScrollAccumulator.process(rawEvent); //如果是光标滚动事件，一般不是 mTouchButtonAccumulator.process(rawEvent); //如果是触摸按键事件，（手写笔有时有） //只有当收到一次EV_SYN事件上上报本次触摸的事件集 if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123; sync(rawEvent-&gt;when, rawEvent-&gt;readTime); &#125; &#125; void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) &#123; if (rawEvent-&gt;type == EV_ABS) &#123; bool newSlot = false; if (mUsingSlotsProtocol) &#123; //如果支持多指触摸协议 if (rawEvent-&gt;code == ABS_MT_SLOT) &#123; mCurrentSlot = rawEvent-&gt;value; newSlot = true; &#125; &#125; else if (mCurrentSlot &lt; 0) &#123; mCurrentSlot = 0; &#125; if (mCurrentSlot &lt; 0 || size_t(mCurrentSlot) &gt;= mSlotCount) &#123; ... &#125; else &#123; Slot* slot = &amp;mSlots[mCurrentSlot]; // If mUsingSlotsProtocol is true, it means the raw pointer has axis info of // ABS_MT_TRACKING_ID and ABS_MT_SLOT, so driver should send a valid trackingId while // updating the slot. //如果支持多指触摸协议，那么驱动就需要上报有效的trackingId来给上层区分 if (!mUsingSlotsProtocol) &#123; slot-&gt;mInUse = true; &#125; //根据事件的code来更新slot的信息 switch (rawEvent-&gt;code) &#123; case ABS_MT_POSITION_X: slot-&gt;mAbsMTPositionX = rawEvent-&gt;value; warnIfNotInUse(*rawEvent, *slot); break; case ABS_MT_POSITION_Y: slot-&gt;mAbsMTPositionY = rawEvent-&gt;value; warnIfNotInUse(*rawEvent, *slot); break; case ABS_MT_TOUCH_MAJOR: slot-&gt;mAbsMTTouchMajor = rawEvent-&gt;value; break; case ABS_MT_TOUCH_MINOR: slot-&gt;mAbsMTTouchMinor = rawEvent-&gt;value; slot-&gt;mHaveAbsMTTouchMinor = true; break; case ABS_MT_WIDTH_MAJOR: slot-&gt;mAbsMTWidthMajor = rawEvent-&gt;value; break; case ABS_MT_WIDTH_MINOR: slot-&gt;mAbsMTWidthMinor = rawEvent-&gt;value; slot-&gt;mHaveAbsMTWidthMinor = true; break; case ABS_MT_ORIENTATION: slot-&gt;mAbsMTOrientation = rawEvent-&gt;value; break; case ABS_MT_TRACKING_ID: if (mUsingSlotsProtocol &amp;&amp; rawEvent-&gt;value &lt; 0) &#123; // The slot is no longer in use but it retains its previous contents, // which may be reused for subsequent touches. slot-&gt;mInUse = false; &#125; else &#123; slot-&gt;mInUse = true; slot-&gt;mAbsMTTrackingId = rawEvent-&gt;value; &#125; break; case ABS_MT_PRESSURE: slot-&gt;mAbsMTPressure = rawEvent-&gt;value; break; case ABS_MT_DISTANCE: slot-&gt;mAbsMTDistance = rawEvent-&gt;value; break; case ABS_MT_TOOL_TYPE: slot-&gt;mAbsMTToolType = rawEvent-&gt;value; slot-&gt;mHaveAbsMTToolType = true; break; &#125; &#125; &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_MT_REPORT) &#123; // MultiTouch Sync: The driver has returned all data for *one* of the pointers. mCurrentSlot += 1; &#125; &#125; TouchInputMapper::syncvoid TouchInputMapper::sync(nsecs_t when, nsecs_t readTime) &#123; //创建一个RawState并加入mRawStatesPending列表 // Push a new state. mRawStatesPending.emplace_back(); //初始化上面的RawState, 将相关的各个mapper.process()中记录的事件的属性写入（sync） RawState&amp; next = mRawStatesPending.back(); next.clear(); next.when = when; next.readTime = readTime; ... // Sync touch //同步触摸的状态，这里是调用子类MultiTouchInputMapper的实现，将子类的process中赋值的多指触摸相关属性赋值给next syncTouch(when, &amp;next); // The last RawState is the actually second to last, since we just added a new state const RawState&amp; last = mRawStatesPending.size() == 1 ? mCurrentRawState : mRawStatesPending.rbegin()[1]; ... processRawTouches(false /*timeout*/); &#125; TouchInputMapper::processRawTouchesframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;mapper&#x2F;TouchInputMapper.cpp void TouchInputMapper::processRawTouches(bool timeout) &#123; //如果当前事件的设备被禁用，则中断这个触摸事件集的传递 if (mDeviceMode == DeviceMode::DISABLED) &#123; // Drop all input if the device is disabled. cancelTouch(mCurrentRawState.when, mCurrentRawState.readTime); mCurrentCookedState.clear(); updateTouchSpots(); return; &#125; // Drain any pending touch states. The invariant here is that the mCurrentRawState is always // valid and must go through the full cook and dispatch cycle. This ensures that anything // touching the current state will only observe the events that have been dispatched to the // rest of the pipeline. const size_t N = mRawStatesPending.size(); size_t count; for (count = 0; count &lt; N; count++) &#123; const RawState&amp; next = mRawStatesPending[count]; // A failure to assign the stylus id means that we&#39;re waiting on stylus data // and so should defer the rest of the pipeline. //检测手写笔id是否可以获取到，如果无法获取就中断本次触摸批事件处理 if (assignExternalStylusId(next, timeout)) &#123; break; &#125; // All ready to go. clearStylusDataPendingFlags(); //移除手写笔状态相关变量 mCurrentRawState.copyFrom(next); //将next赋给mCurrentRawState ... cookAndDispatch(mCurrentRawState.when, mCurrentRawState.readTime); &#125; if (count != 0) &#123; //从mRawStatesPending移除本次已处理的RawState，一个RawState对应一次SYNC包含的触摸事件集 mRawStatesPending.erase(mRawStatesPending.begin(), mRawStatesPending.begin() + count); &#125; ... &#125; TouchInputMapper::cookAndDispatchvoid TouchInputMapper::cookAndDispatch(nsecs_t when, nsecs_t readTime) &#123; // Always start with a clean state. mCurrentCookedState.clear(); // Apply stylus buttons to current raw state. applyExternalStylusButtonState(when); //处理手写笔按键状态 // Handle policy on initial down or hover events. bool initialDown = mLastRawState.rawPointerData.pointerCount == 0 &amp;&amp; mCurrentRawState.rawPointerData.pointerCount != 0; uint32_t policyFlags = 0; bool buttonsPressed = mCurrentRawState.buttonState &amp; ~mLastRawState.buttonState; if (initialDown || buttonsPressed) &#123; // If this is a touch screen, hide the pointer on an initial down. if (mDeviceMode == DeviceMode::DIRECT) &#123; getContext()-&gt;fadePointer(); &#125; if (mParameters.wake) &#123; policyFlags |= POLICY_FLAG_WAKE; &#125; &#125; // Consume raw off-screen touches before cooking pointer data. // If touches are consumed, subsequent code will not receive any pointer data. //处理一些非屏幕区域的触摸行为，比如屏幕外的虚拟按键等， //如果本次触摸是虚拟按键，那么本次触摸事件将会被虚拟按键逻辑消费，不在往下处理 if (consumeRawTouches(when, readTime, policyFlags)) &#123; mCurrentRawState.rawPointerData.clear(); &#125; // Cook pointer data. This call populates the mCurrentCookedState.cookedPointerData structure // with cooked pointer data that has the same ids and indices as the raw data. // The following code can use either the raw or cooked data, as needed. //这里就是将触摸设备(TP)的坐标范围映射到实际屏幕的坐标范围等（常识：TP的坐标不一定和屏幕的坐标对应，所以需要转化） cookPointerData(); // Apply stylus pressure to current cooked state. applyExternalStylusTouchState(when); 处理手写笔触摸状态 // Synthesize key down from raw buttons if needed. // 如果上面有处理触摸按键相关的事件，在这里会进行按键事件的分发，走按键分发逻辑（notifyKey） synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_DOWN, when, readTime, getDeviceId(), mSource, mViewport.displayId, policyFlags, mLastCookedState.buttonState, mCurrentCookedState.buttonState); // Dispatch the touches either directly or by translation through a pointer on screen. if (mDeviceMode == DeviceMode::POINTER) &#123; //pointer光标 ... &#125; else &#123; //触摸 DeviceMode::DIRECT touchscreen if (!mCurrentMotionAborted) &#123; updateTouchSpots(); //更新触摸点相关 dispatchButtonRelease(when, readTime, policyFlags); //一般触摸不涉及，不进行任何处理 dispatchHoverExit(when, readTime, policyFlags); //一般触摸不涉及，不进行任何处理 dispatchTouches(when, readTime, policyFlags); // 分发触摸事件，主要是这里 dispatchHoverEnterAndMove(when, readTime, policyFlags); //一般触摸不涉及，不进行任何处理 dispatchButtonPress(when, readTime, policyFlags); //一般触摸不涉及，不进行任何处理 &#125; if (mCurrentCookedState.cookedPointerData.pointerCount == 0) &#123; mCurrentMotionAborted = false; &#125; &#125; // Synthesize key up from raw buttons if needed. synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_UP, when, readTime, getDeviceId(), mSource, mViewport.displayId, policyFlags, mLastCookedState.buttonState, mCurrentCookedState.buttonState); // Clear some transient state. mCurrentRawState.rawVScroll = 0; mCurrentRawState.rawHScroll = 0; // Copy current touch to last touch in preparation for the next cycle. mLastRawState.copyFrom(mCurrentRawState); mLastCookedState.copyFrom(mCurrentCookedState); &#125; TouchInputMapper::cookPointerDatavoid TouchInputMapper::cookPointerData() &#123; uint32_t currentPointerCount = mCurrentRawState.rawPointerData.pointerCount; mCurrentCookedState.cookedPointerData.clear(); mCurrentCookedState.cookedPointerData.pointerCount = currentPointerCount; mCurrentCookedState.cookedPointerData.hoveringIdBits = mCurrentRawState.rawPointerData.hoveringIdBits; mCurrentCookedState.cookedPointerData.touchingIdBits = mCurrentRawState.rawPointerData.touchingIdBits; mCurrentCookedState.cookedPointerData.canceledIdBits = mCurrentRawState.rawPointerData.canceledIdBits; if (mCurrentCookedState.cookedPointerData.pointerCount == 0) &#123; mCurrentCookedState.buttonState = 0; &#125; else &#123; mCurrentCookedState.buttonState = mCurrentRawState.buttonState; &#125; // Walk through the the active pointers and map device coordinates onto // display coordinates and adjust for display orientation. // 遍历活动指针并将设备坐标映射到显示坐标并调整显示方向。 // 并将相关的转化值写入mCurrentCookedState.cookedPointerData for (uint32_t i = 0; i &lt; currentPointerCount; i++) &#123; const RawPointerData::Pointer&amp; in = mCurrentRawState.rawPointerData.pointers[i]; // Size // 长短轴大小校准 float touchMajor, touchMinor, toolMajor, toolMinor, size; switch (mCalibration.sizeCalibration) &#123; case Calibration::SizeCalibration::GEOMETRIC: //几何类型 case Calibration::SizeCalibration::DIAMETER: //直径类型 case Calibration::SizeCalibration::BOX: // 方型？ case Calibration::SizeCalibration::AREA: //面积类型？ if (mRawPointerAxes.touchMajor.valid &amp;&amp; mRawPointerAxes.toolMajor.valid) &#123; touchMajor = in.touchMajor; touchMinor = mRawPointerAxes.touchMinor.valid ? in.touchMinor : in.touchMajor; toolMajor = in.toolMajor; toolMinor = mRawPointerAxes.toolMinor.valid ? in.toolMinor : in.toolMajor; size = mRawPointerAxes.touchMinor.valid ? avg(in.touchMajor, in.touchMinor) : in.touchMajor; &#125; else if (mRawPointerAxes.touchMajor.valid) &#123; toolMajor = touchMajor = in.touchMajor; toolMinor = touchMinor = mRawPointerAxes.touchMinor.valid ? in.touchMinor : in.touchMajor; size = mRawPointerAxes.touchMinor.valid ? avg(in.touchMajor, in.touchMinor) : in.touchMajor; &#125; else if (mRawPointerAxes.toolMajor.valid) &#123; touchMajor = toolMajor = in.toolMajor; touchMinor = toolMinor = mRawPointerAxes.toolMinor.valid ? in.toolMinor : in.toolMajor; size = mRawPointerAxes.toolMinor.valid ? avg(in.toolMajor, in.toolMinor) : in.toolMajor; &#125; else &#123; ... &#125; if (mCalibration.haveSizeIsSummed &amp;&amp; mCalibration.sizeIsSummed) &#123; uint32_t touchingCount = mCurrentRawState.rawPointerData.touchingIdBits.count(); if (touchingCount &gt; 1) &#123; touchMajor /= touchingCount; touchMinor /= touchingCount; toolMajor /= touchingCount; toolMinor /= touchingCount; size /= touchingCount; &#125; &#125; if (mCalibration.sizeCalibration == Calibration::SizeCalibration::GEOMETRIC) &#123; touchMajor *= mGeometricScale; touchMinor *= mGeometricScale; toolMajor *= mGeometricScale; toolMinor *= mGeometricScale; &#125; else if (mCalibration.sizeCalibration == Calibration::SizeCalibration::AREA) &#123; touchMajor = touchMajor &gt; 0 ? sqrtf(touchMajor) : 0; touchMinor = touchMajor; toolMajor = toolMajor &gt; 0 ? sqrtf(toolMajor) : 0; toolMinor = toolMajor; &#125; else if (mCalibration.sizeCalibration == Calibration::SizeCalibration::DIAMETER) &#123; touchMinor = touchMajor; toolMinor = toolMajor; &#125; mCalibration.applySizeScaleAndBias(&amp;touchMajor); mCalibration.applySizeScaleAndBias(&amp;touchMinor); mCalibration.applySizeScaleAndBias(&amp;toolMajor); mCalibration.applySizeScaleAndBias(&amp;toolMinor); size *= mSizeScale; break; default: touchMajor = 0; touchMinor = 0; toolMajor = 0; toolMinor = 0; size = 0; break; &#125; // Pressure //压感校准 float pressure; switch (mCalibration.pressureCalibration) &#123; case Calibration::PressureCalibration::PHYSICAL: case Calibration::PressureCalibration::AMPLITUDE: pressure = in.pressure * mPressureScale; break; default: pressure = in.isHovering ? 0 : 1; break; &#125; // Tilt and Orientation //倾斜角度和方向 float tilt; float orientation; if (mHaveTilt) &#123; float tiltXAngle = (in.tiltX - mTiltXCenter) * mTiltXScale; float tiltYAngle = (in.tiltY - mTiltYCenter) * mTiltYScale; orientation = atan2f(-sinf(tiltXAngle), sinf(tiltYAngle)); tilt = acosf(cosf(tiltXAngle) * cosf(tiltYAngle)); &#125; else &#123; tilt = 0; switch (mCalibration.orientationCalibration) &#123; case Calibration::OrientationCalibration::INTERPOLATED: orientation = in.orientation * mOrientationScale; break; case Calibration::OrientationCalibration::VECTOR: &#123; int32_t c1 = signExtendNybble((in.orientation &amp; 0xf0) &gt;&gt; 4); int32_t c2 = signExtendNybble(in.orientation &amp; 0x0f); if (c1 != 0 || c2 != 0) &#123; orientation = atan2f(c1, c2) * 0.5f; float confidence = hypotf(c1, c2); float scale = 1.0f + confidence / 16.0f; touchMajor *= scale; touchMinor /= scale; toolMajor *= scale; toolMinor /= scale; &#125; else &#123; orientation = 0; &#125; break; &#125; default: orientation = 0; &#125; &#125; // Distance //距离校准 float distance; switch (mCalibration.distanceCalibration) &#123; case Calibration::DistanceCalibration::SCALED: distance = in.distance * mDistanceScale; break; default: distance = 0; &#125; // Coverage // 覆盖校准？ int32_t rawLeft, rawTop, rawRight, rawBottom; switch (mCalibration.coverageCalibration) &#123; case Calibration::CoverageCalibration::BOX: rawLeft = (in.toolMinor &amp; 0xffff0000) &gt;&gt; 16; rawRight = in.toolMinor &amp; 0x0000ffff; rawBottom = in.toolMajor &amp; 0x0000ffff; rawTop = (in.toolMajor &amp; 0xffff0000) &gt;&gt; 16; break; default: rawLeft = rawTop = rawRight = rawBottom = 0; break; &#125; // Adjust X,Y coords for device calibration // TODO: Adjust coverage coords? float xTransformed = in.x, yTransformed = in.y; mAffineTransform.applyTo(xTransformed, yTransformed); rotateAndScale(xTransformed, yTransformed); // Adjust X, Y, and coverage coords for input device orientation. float left, top, right, bottom; // 转换触摸设备坐标到实际的屏幕方向上的坐标 switch (mInputDeviceOrientation) &#123; case DISPLAY_ORIENTATION_90: left = float(rawTop - mRawPointerAxes.y.minValue) * mYScale; right = float(rawBottom - mRawPointerAxes.y.minValue) * mYScale; bottom = float(mRawPointerAxes.x.maxValue - rawLeft) * mXScale; top = float(mRawPointerAxes.x.maxValue - rawRight) * mXScale; orientation -= M_PI_2; if (mOrientedRanges.haveOrientation &amp;&amp; orientation &lt; mOrientedRanges.orientation.min) &#123; orientation += (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min); &#125; break; case DISPLAY_ORIENTATION_180: left = float(mRawPointerAxes.x.maxValue - rawRight) * mXScale; right = float(mRawPointerAxes.x.maxValue - rawLeft) * mXScale; bottom = float(mRawPointerAxes.y.maxValue - rawTop) * mYScale; top = float(mRawPointerAxes.y.maxValue - rawBottom) * mYScale; orientation -= M_PI; if (mOrientedRanges.haveOrientation &amp;&amp; orientation &lt; mOrientedRanges.orientation.min) &#123; orientation += (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min); &#125; break; case DISPLAY_ORIENTATION_270: left = float(mRawPointerAxes.y.maxValue - rawBottom) * mYScale; right = float(mRawPointerAxes.y.maxValue - rawTop) * mYScale; bottom = float(rawRight - mRawPointerAxes.x.minValue) * mXScale; top = float(rawLeft - mRawPointerAxes.x.minValue) * mXScale; orientation += M_PI_2; if (mOrientedRanges.haveOrientation &amp;&amp; orientation &gt; mOrientedRanges.orientation.max) &#123; orientation -= (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min); &#125; break; default: left = float(rawLeft - mRawPointerAxes.x.minValue) * mXScale; right = float(rawRight - mRawPointerAxes.x.minValue) * mXScale; bottom = float(rawBottom - mRawPointerAxes.y.minValue) * mYScale; top = float(rawTop - mRawPointerAxes.y.minValue) * mYScale; break; &#125; // Write output coords. PointerCoords&amp; out = mCurrentCookedState.cookedPointerData.pointerCoords[i]; out.clear(); out.setAxisValue(AMOTION_EVENT_AXIS_X, xTransformed); out.setAxisValue(AMOTION_EVENT_AXIS_Y, yTransformed); out.setAxisValue(AMOTION_EVENT_AXIS_PRESSURE, pressure); out.setAxisValue(AMOTION_EVENT_AXIS_SIZE, size); out.setAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR, touchMajor); out.setAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR, touchMinor); out.setAxisValue(AMOTION_EVENT_AXIS_ORIENTATION, orientation); out.setAxisValue(AMOTION_EVENT_AXIS_TILT, tilt); out.setAxisValue(AMOTION_EVENT_AXIS_DISTANCE, distance); if (mCalibration.coverageCalibration == Calibration::CoverageCalibration::BOX) &#123; out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_1, left); out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_2, top); out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_3, right); out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_4, bottom); &#125; else &#123; out.setAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR, toolMajor); out.setAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR, toolMinor); &#125; // Write output relative fields if applicable. uint32_t id = in.id; if (mSource == AINPUT_SOURCE_TOUCHPAD &amp;&amp; mLastCookedState.cookedPointerData.hasPointerCoordsForId(id)) &#123; const PointerCoords&amp; p = mLastCookedState.cookedPointerData.pointerCoordsForId(id); float dx = xTransformed - p.getAxisValue(AMOTION_EVENT_AXIS_X); float dy = yTransformed - p.getAxisValue(AMOTION_EVENT_AXIS_Y); out.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, dx); out.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, dy); &#125; // Write output properties. PointerProperties&amp; properties = mCurrentCookedState.cookedPointerData.pointerProperties[i]; properties.clear(); properties.id = id; properties.toolType = in.toolType; // Write id index and mark id as valid. mCurrentCookedState.cookedPointerData.idToIndex[id] = i; mCurrentCookedState.cookedPointerData.validIdBits.markBit(id); &#125; &#125; TouchInputMapper::dispatchTouchesvoid TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t readTime, uint32_t policyFlags) &#123; BitSet32 currentIdBits = mCurrentCookedState.cookedPointerData.touchingIdBits; BitSet32 lastIdBits = mLastCookedState.cookedPointerData.touchingIdBits; int32_t metaState = getContext()-&gt;getGlobalMetaState(); int32_t buttonState = mCurrentCookedState.buttonState; if (currentIdBits == lastIdBits) &#123; //pointer id 没有改变 if (!currentIdBits.isEmpty()) &#123; // No pointer id changes so this is a move event. // The listener takes care of batching moves so we don&#39;t have to deal with that here. // 如果pointer id 没有改变，说明是个move事件，这里不进行处理，直接分发到listener dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, buttonState, AMOTION_EVENT_EDGE_FLAG_NONE, mCurrentCookedState.cookedPointerData.pointerProperties, mCurrentCookedState.cookedPointerData.pointerCoords, mCurrentCookedState.cookedPointerData.idToIndex, currentIdBits, -1, mOrientedXPrecision, mOrientedYPrecision, mDownTime); &#125; &#125; else &#123; // There may be pointers going up and pointers going down and pointers moving // all at the same time. // 获取并更新四个方向pointers的值，判断本次是down、up、move的哪一种 BitSet32 upIdBits(lastIdBits.value &amp; ~currentIdBits.value); BitSet32 downIdBits(currentIdBits.value &amp; ~lastIdBits.value); BitSet32 moveIdBits(lastIdBits.value &amp; currentIdBits.value); BitSet32 dispatchedIdBits(lastIdBits.value); //用于记录上一次分发的事件 // Update last coordinates of pointers that have moved so that we observe the new // pointer positions at the same time as other pointers that have just gone up. //更新最后一个pointers的坐标 bool moveNeeded = updateMovedPointers(mCurrentCookedState.cookedPointerData.pointerProperties, mCurrentCookedState.cookedPointerData.pointerCoords, mCurrentCookedState.cookedPointerData.idToIndex, mLastCookedState.cookedPointerData.pointerProperties, mLastCookedState.cookedPointerData.pointerCoords, mLastCookedState.cookedPointerData.idToIndex, moveIdBits); if (buttonState != mLastCookedState.buttonState) &#123; moveNeeded = true; &#125; // Dispatch pointer up events. //分发up事件 while (!upIdBits.isEmpty()) &#123; uint32_t upId = upIdBits.clearFirstMarkedBit(); //这个id应该和downId相同（看上面的更新四个方向BitSet32可知） bool isCanceled = mCurrentCookedState.cookedPointerData.canceledIdBits.hasBit(uplastIdBitsId); if (isCanceled) &#123; ALOGI(&quot;Canceling pointer %d for the palm event was detected.&quot;, upId); &#125; dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_POINTER_UP, 0, isCanceled ? AMOTION_EVENT_FLAG_CANCELED : 0, metaState, buttonState, 0, mLastCookedState.cookedPointerData.pointerProperties, mLastCookedState.cookedPointerData.pointerCoords, mLastCookedState.cookedPointerData.idToIndex, dispatchedIdBits, upId, mOrientedXPrecision, mOrientedYPrecision, mDownTime); dispatchedIdBits.clearBit(upId); //up事件分发后，重置dispatchedIdBits mCurrentCookedState.cookedPointerData.canceledIdBits.clearBit(upId); &#125; // Dispatch move events if any of the remaining pointers moved from their old locations. // Although applications receive new locations as part of individual pointer up // events, they do not generally handle them except when presented in a move event. //分发move事件 if (moveNeeded &amp;&amp; !moveIdBits.isEmpty()) &#123; ALOG_ASSERT(moveIdBits.value == dispatchedIdBits.value); dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, buttonState, 0, mCurrentCookedState.cookedPointerData.pointerProperties, mCurrentCookedState.cookedPointerData.pointerCoords, mCurrentCookedState.cookedPointerData.idToIndex, dispatchedIdBits, -1, mOrientedXPrecision, mOrientedYPrecision, mDownTime); &#125; // Dispatch pointer down events using the new pointer locations. //分发down事件 while (!downIdBits.isEmpty()) &#123; uint32_t downId = downIdBits.clearFirstMarkedBit(); dispatchedIdBits.markBit(downId); //记录分发的down事件 if (dispatchedIdBits.count() == 1) &#123; // First pointer is going down. Set down time. mDownTime = when; &#125; dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_POINTER_DOWN, 0, 0, metaState, buttonState, 0, mCurrentCookedState.cookedPointerData.pointerProperties, mCurrentCookedState.cookedPointerData.pointerCoords, mCurrentCookedState.cookedPointerData.idToIndex, dispatchedIdBits, downId, mOrientedXPrecision, mOrientedYPrecision, mDownTime); &#125; &#125; &#125; TouchInputMapper::dispatchMotionvoid TouchInputMapper::dispatchMotion(nsecs_t when, nsecs_t readTime, uint32_t policyFlags, uint32_t source, int32_t action, int32_t actionButton, int32_t flags, int32_t metaState, int32_t buttonState, int32_t edgeFlags, const PointerProperties* properties, const PointerCoords* coords, const uint32_t* idToIndex, BitSet32 idBits, int32_t changedId, float xPrecision, float yPrecision, nsecs_t downTime) &#123; PointerCoords pointerCoords[MAX_POINTERS]; PointerProperties pointerProperties[MAX_POINTERS]; uint32_t pointerCount = 0; while (!idBits.isEmpty()) &#123; uint32_t id = idBits.clearFirstMarkedBit(); uint32_t index = idToIndex[id]; pointerProperties[pointerCount].copyFrom(properties[index]); pointerCoords[pointerCount].copyFrom(coords[index]); if (changedId &gt;= 0 &amp;&amp; id == uint32_t(changedId)) &#123; action |= pointerCount &lt;&lt; AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT; &#125; pointerCount += 1; &#125; ALOG_ASSERT(pointerCount != 0); if (changedId &gt;= 0 &amp;&amp; pointerCount == 1) &#123; // Replace initial down and final up action. // We can compare the action without masking off the changed pointer index // because we know the index is 0. if (action == AMOTION_EVENT_ACTION_POINTER_DOWN) &#123; action = AMOTION_EVENT_ACTION_DOWN; &#125; else if (action == AMOTION_EVENT_ACTION_POINTER_UP) &#123; if ((flags &amp; AMOTION_EVENT_FLAG_CANCELED) != 0) &#123; action = AMOTION_EVENT_ACTION_CANCEL; &#125; else &#123; action = AMOTION_EVENT_ACTION_UP; &#125; &#125; else &#123; // Can&#39;t happen. ALOG_ASSERT(false); &#125; &#125; float xCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION; float yCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION; if (mDeviceMode == DeviceMode::POINTER) &#123; //是否是pointer模式，触摸是DIRECT模式，所以一般不设置这个 mPointerController-&gt;getPosition(&amp;xCursorPosition, &amp;yCursorPosition); &#125; //获取当前物理屏幕的id（有些设备有多个屏幕） //获取displayId主要从DisplayViewport中，而DisplayViewport主要来自： // 1. inputDevice中通过configure中指定。 // 2. WindowManagerService指定。 // 3.通过idc文件中的唯一id或显示类型获取匹配的Viewport const int32_t displayId = getAssociatedDisplayId().value_or(ADISPLAY_ID_NONE); const int32_t deviceId = getDeviceId(); std::vector&lt;TouchVideoFrame&gt; frames = getDeviceContext().getVideoFrames(); //有关视频触摸事件的，一般不是 std::for_each(frames.begin(), frames.end(), [this](TouchVideoFrame&amp; frame) &#123; frame.rotate(this-&gt;mInputDeviceOrientation); &#125;); //创建NotifyMotionArgs对象 NotifyMotionArgs args(getContext()-&gt;getNextId(), when, readTime, deviceId, source, displayId, policyFlags, action, actionButton, flags, metaState, buttonState, MotionClassification::NONE, edgeFlags, pointerCount, pointerProperties, pointerCoords, xPrecision, yPrecision, xCursorPosition, yCursorPosition, downTime, std::move(frames)); // 调用mapper创建时关联的context持有的QueuedInputListener对象的notifyMotion // 这里是getListener是UnwantedInteractionBlocker getListener().notifyMotion(&amp;args); &#125; QueuedInputListener::notifyMotionvoid QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123; ALOGD(&quot;hongxi.zhu: QueuedInputListener::notifyMotion() -&gt; mArgsQueue.emplace_back(NotifyMotionArgs)&quot;); traceEvent(__func__, args-&gt;id); mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args)); &#125; QueuedInputListener::notifyMotion只是将NotifyMotionArgs加入当前listener对象的mArgsQueue列表, 到这里我们InputReader::processEventsLocked方法就执行结束，回到loopOnce()中继续往下执行到mQueuedListener.flush()，开始事件的传递。 二、mQueuedListener.flush()事件传递接着上面，在InputReader::loopOnce()中往下执行到mQueuedListener.flush() QueuedInputListener::flush()frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputListener.cpp void QueuedInputListener::flush() &#123; for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123; args-&gt;notify(mInnerListener); //args这里是前面传进来的NotifyMotionArgs &#125; mArgsQueue.clear(); &#125; NotifyMotionArgs::notifyframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputListener.cpp void NotifyMotionArgs::notify(InputListenerInterface&amp; listener) const &#123; listener.notifyMotion(this); &#125; 这个listener是一个InputListenerInterface子类对象，到底是哪个呢？回顾下InputManager的构造方法，frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputManager.cpp InputManager::InputManager( const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123; mDispatcher = createInputDispatcher(dispatcherPolicy); mClassifier = std::make_unique&lt;InputClassifier&gt;(*mDispatcher); mBlocker = std::make_unique&lt;UnwantedInteractionBlocker&gt;(*mClassifier); mReader = createInputReader(readerPolicy, *mBlocker); &#125; mDispatcher、mClassifier、mBlocker都是InputListenerInterface的子类，从构造方法的传参得出事件传递的过程：InputReader-&gt;UnwantedInteractionBlocker-&gt;InputClassifier-&gt;InputDispatcher结合类继承关系，可知上面InputReader::loopOnce()中的mQueuedListener是UnwantedInteractionBlocker，调用它的flush方法(这几个子类都没有实现flush方法，所以执行的是QueuedInputListener的flush方法)，QueuedInputListener中的mInnerListener是UnwantedInteractionBlocker，那么listener.notifyMotion(this)实际就是：UnwantedInteractionBlocker::notifyMotion(NotifyMotionArgs) UnwantedInteractionBlocker::notifyMotionframeworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;UnwantedInteractionBlocker.cpp void UnwantedInteractionBlocker::notifyMotion(const NotifyMotionArgs* args) &#123; &#123; // acquire lock std::scoped_lock lock(mLock); const std::vector&lt;NotifyMotionArgs&gt; processedArgs = mPreferStylusOverTouchBlocker.processMotion(*args); for (const NotifyMotionArgs&amp; loopArgs : processedArgs) &#123; notifyMotionLocked(&amp;loopArgs); &#125; &#125; // release lock // Call out to the next stage without holding the lock mQueuedListener.flush(); &#125; UnwantedInteractionBlocker::notifyMotionLockedvoid UnwantedInteractionBlocker::notifyMotionLocked(const NotifyMotionArgs* args) &#123; auto it = mPalmRejectors.find(args-&gt;deviceId); const bool sendToPalmRejector = it != mPalmRejectors.end() &amp;&amp; isFromTouchscreen(args-&gt;source); if (!sendToPalmRejector) &#123; //如果不支持手掌误触处理，走这里，一般走这里 //调用UnwantedInteractionBlocker中持有的QueuedListener对象的notifyMotion //mQueuedListener这里是 mQueuedListener.notifyMotion(args); //一般走这里, 按照前面 return; &#125; //如果支持手掌误触 std::vector&lt;NotifyMotionArgs&gt; processedArgs = it-&gt;second.processMotion(*args); processedArgs.size()); for (const NotifyMotionArgs&amp; loopArgs : processedArgs) &#123; mQueuedListener.notifyMotion(&amp;loopArgs); //同理这里的mQueuedListener是InputClassifier &#125; &#125; 然后又是同样的走法notifyMotion-&gt;flush-&gt;notifyMotion, mInnerListener是InputClassifier QueuedInputListener::notifyMotionvoid QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123; traceEvent(__func__, args-&gt;id); mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args)); &#125; void QueuedInputListener::flush() &#123; for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123; //args这里是前面传进来的NotifyMotionArgs，mInnerListener是InputClassifier args-&gt;notify(mInnerListener); &#125; mArgsQueue.clear(); &#125; void NotifyMotionArgs::notify(InputListenerInterface&amp; listener) const &#123; listener.notifyMotion(this); &#125; InputClassifier::notifyMotionvoid InputClassifier::notifyMotion(const NotifyMotionArgs* args) &#123; &#123; // acquire lock std::scoped_lock lock(mLock); // MotionClassifier is only used for touch events, for now const bool sendToMotionClassifier = mMotionClassifier &amp;&amp; isTouchEvent(*args); if (!sendToMotionClassifier) &#123; //目前模拟器走这里，真机不清楚 mQueuedListener.notifyMotion(args); &#125; else &#123; NotifyMotionArgs newArgs(*args); newArgs.classification = mMotionClassifier-&gt;classify(newArgs); mQueuedListener.notifyMotion(&amp;newArgs); &#125; &#125; // release lock mQueuedListener.flush(); &#125; 然后又是同样的走法notifyMotion-&gt;flush-&gt;notifyMotion, mInnerListener是InputDispatcher QueuedInputListener::notifyMotionvoid QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123; traceEvent(__func__, args-&gt;id); mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args)); &#125; void QueuedInputListener::flush() &#123; for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123; //args这里是前面传进来的NotifyMotionArgs，mInnerListener是InputClassifier args-&gt;notify(mInnerListener); &#125; mArgsQueue.clear(); &#125; InputDispatcher::notifyMotionvoid InputDispatcher::notifyMotion(const NotifyMotionArgs* args) &#123; ... uint32_t policyFlags = args-&gt;policyFlags; policyFlags |= POLICY_FLAG_TRUSTED; android::base::Timer t; //回调wms中的interceptMotionBeforeQueueingNonInteractive方法 mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;displayId, args-&gt;eventTime, /*byref*/ policyFlags); bool needWake = false; &#123; // acquire lock mLock.lock(); ... // Just enqueue a new motion event. //创建一个MotionEntry对象，将NotifyMotionArgs转化为MotionEntry std::unique_ptr&lt;MotionEntry&gt; newEntry = std::make_unique&lt;MotionEntry&gt;(args-&gt;id, args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;displayId, policyFlags, args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState, args-&gt;classification, args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;xCursorPosition, args-&gt;yCursorPosition, args-&gt;downTime, args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords); ... //将MotionEntry加入InboundQueue needWake = enqueueInboundEventLocked(std::move(newEntry)); mLock.unlock(); &#125; // release lock if (needWake) &#123; mLooper-&gt;wake(); //唤醒InputDispatcher线程，处理InboundQueue中的MotionEntry &#125; &#125; InputDispatcher::enqueueInboundEventLockedbool InputDispatcher::enqueueInboundEventLocked(std::unique_ptr&lt;EventEntry&gt; newEntry) &#123; bool needWake = mInboundQueue.empty(); mInboundQueue.push_back(std::move(newEntry)); EventEntry&amp; entry = *(mInboundQueue.back()); traceInboundQueueLengthLocked(); switch (entry.type) &#123; case EventEntry::Type::KEY: &#123; ... break; &#125; case EventEntry::Type::MOTION: &#123; LOG_ALWAYS_FATAL_IF((entry.policyFlags &amp; POLICY_FLAG_TRUSTED) == 0, &quot;Unexpected untrusted event.&quot;); if (shouldPruneInboundQueueLocked(static_cast&lt;MotionEntry&amp;&gt;(entry))) &#123; mNextUnblockedEvent = mInboundQueue.back(); needWake = true; &#125; break; ... &#125; return needWake; &#125; 到此，InputReader线程就将事件传递到InputDispatcher线程，InputDispatcher线程被唤醒开始处理触摸事件，而InputReader线程继续循环执行loopOnce()方法，再次阻塞在getEvents方法中等待事件的上报。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"InPutManagerService","slug":"Android-FrameWork/Framework源码分析/Android-13/InPutManagerService","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"}]},{"path":"wiki/Android FrameWork/ASFP (android studio for platform)使用/","text":"Android Studio for Platform 这个是最新的google开发的阅读aosp源码的工具，特别适合做原生系统开发。具体官方介绍如下地址：参考链接：https://developer.android.google.cn/studio/platform 1、android studio for platform工具介绍可以直接点击下载（提示目前只有ubuntu可以哈，语言切换到英文，中文发现无法下载) 看看相关的官方介绍： Android Studio for Platform (ASfP) is the version of the Android Studio IDE for Android Open Source Project (AOSP) platform developers who build with the Soong build system. ASfP includes the following features: language Multi-language Support Edit C++, Kotlin, and Java programming languages in the same IDE. settings Project Setup Wizard Configure your lunch target and platform modules. 官方的介绍就以上一小段文字，总结如下：ASfP是专门用于开发aosp的ide工具，有着 Soong build system.，主要有以下几个特点语言支持部分：同时支持：C++, Kotlin, and Java 同时使用在ide中编程设置部分：可以配置你的编译target和具体的模块 2、android studio for platform痛点解决这里最吸引我们的还是他居然支持多语言，c++，java，kotlin同时都支持。以前我们开发aosp时候，其实java部分使用android studio的体验还是相当好，但是android studio没办法支持c++等native代码的跳转和代码提示，所以不得不使用vscode工具，这个vscode工具相关看c++等代码也是比较方便，基本上的代码也是可以跳转的，但是毕竟有时候需要两个工具相互切快捷键等还是有一点点不方便，虽然不太影响。 所以开发aosp之前的选择就是：java相关代码使用android studioc++相关代码使用vscode 目前ASfP工具出现真的是我们framework开发者的一个巨大福音，解决了android studio无法跳转c++代码的这个巨大痛点。 3、android studio for platform使用体验官方使用介绍： ​ Get started with ASfP If you haven&#39;t already installed repo, follow the instructions at Installing Repo. If you haven&#39;t already initialized and synced your Repo checkout, follow the instructions at Initializing a Repo client. Download ASfP. Install ASfP: sudo dpkg -i /path/to/asfp-2023.1.1.19-linux.deb. Open ASfP from the command line: /opt/android-studio-for-platform/bin/studio.sh. Import your project by pointing to your repo checkout directory, specifying a lunch target, and selecting which modules you want to build. Click Finish and your project will begin syncing. Request to join our external group for user support. ​​ 这里我们就直接自己转化把1、下载好工具，安装好即可以（限制在ubuntu）可以直接点击安装的 2、启动工具在terminator下面输入如下命令：&#x2F;opt&#x2F;android-studio-for-platform&#x2F;bin&#x2F;studio.sh就会启动工具 3、导入需要模块这里导入了Launcher和framework 同步完成就一切都好了即可以查看相关代码和跳转。 ps使用的注意点：1、跳转framework的类时候会跳到对应jar包的class文件，不是java文件，解决如下 2、KeyMap如果习惯eclipse的可以切换 3、如果导入c++相关开发建议以下3个文件夹：frameworkssystempackages 导入越多整体就慢 总结体验：整体体验和以前android studio没有大的差别1、不过说实话单独java部分的代码开发的话，体验还不如以前的android studio轻量，反而依赖的东西太多，对于跳转等，查找代码还没有以前方便，针对java部分的话，这个建议可以先观望等更多版本更新稳定 2、c++部分的native代码，来说简直就利器，非常好用，跳转准确，非常值的推荐 google官方教学视频教程地址：https://www.bilibili.com/video/BV1UV411P7nf/?vd_source&#x3D;a8c604ee3ce4999324264828f8fd99d8 生成桌面图标 修改配置文件","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/5.Android13启动流程之SystemServer内部逻辑分析/","text":"主要分析一下SystemServer启动过后的内部逻辑，特别说明一下AMS,WMS都属于SystemServer进程，属于同一个进程 一. SystemServer进程启动流程基于Android13的系统启动流程分析（五）之Zygote和SystemServer启动流程这篇文章有详细讲解，这里再简单的过一下如何启动的SystemServer 在zygote进程创建过后，会调用forkSystemServer()来孵化出SystemServer进程，当前该进程创建成功后会反射调用到SystemServer.java的main函数，从而启动完成SystemServer 二. SystemServer主函数分析main函数会被ZygoteInit的子方法handleSystemServerProcess反射调用到frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java public static void main(String[] args) &#123; new SystemServer().run(); &#125; 继续看看run方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100private void run() &#123; ... try &#123; ... // 设置系统语言，国家，时区相关 if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); &#125; ... // Prepare the main looper thread (this thread). // 设置main线程的优先级，有此可得主线程就是：SystemServer进程下的其中线程 android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); // 开始主线程的运行，和Looper.loop配对使用 // 运行在 Looper.prepareMainLooper()～Looper.loop() // 之间的就是运行在主线程中 Looper.prepareMainLooper(); Looper.getMainLooper().setSlowLogThresholdMs( SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS); ... // 初始化native services,加载android_servers库（libandroid_servers.so） System.loadLibrary(&quot;android_servers&quot;); ... // 通过ActivityThread来创建system上下文 createSystemContext(); // Call per-process mainline module initialization. // 初始化ActivityThread // 创建TelephonyServiceManager，StatsServiceManager，MediaServiceManager ActivityThread.initializeMainlineModules(); // 将SystemServer加入ServiceManager（binder线程池） // 每个继承自SystemServer 或属于SystemServer进程的服务都将加入到 // ServiceManager中的线程池中 ServiceManager.addService(&quot;system_server_dumper&quot;, mDumper); mDumper.addDumpable(this); // 每个server基本上对应了一个manager,对外提供的API也是只能获取到manager // 创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理，启动系统的各种服务 mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); mDumper.addDumpable(mSystemServiceManager); // LocalServices是system_server进程中各个服务提供的本地服务 // system_server进程中每个服务都可以往LocalServices放对象 // 有些核心服务是继承自SystemServer,LocalServices是公开缓存池目的是：解耦 LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); ... // Start services. try &#123; t.traceBegin(&quot;StartServices&quot;); // 启动系统启动所需的一系列关键服务：AMS,P(power/package)MS,SensorService,DisplayManagerService,LightService等 startBootstrapServices(t); // 启动核心服务：BatteryService，GpuService等 startCoreServices(t); // 启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等 startOtherServices(t); // 以上的所有服务都由mSystemServiceManager来启动，所以都是继承自SystemServer // 分别是引导服务、核心服务和其他服务 // [引导服务] // Installer 系统安装apk时的一个服务类，启动完成Installer服务之后才能启动其他的系统服务 //ActivityManagerService 负责四大组件的启动、切换、调度。 //PowerManagerService 计算系统中和Power相关的计算，然后决策系统应该如何反应 //LightsService 管理和显示背光LED //DisplayManagerService 用来管理所有显示设备 //UserManagerService 多用户模式管理 //SensorService 为系统提供各种感应器服务 //PackageManagerService 用来对apk进行安装、解析、删除、卸载等等操作 // [核心服务] //BatteryService 管理电池相关的服务 //UsageStatsService 收集用户使用每一个APP的频率、使用时常 //WebViewUpdateService WebView更新服务 // [其他服务] //CameraService 摄像头相关服务 //AlarmManagerService 全局定时器管理服务 //InputManagerService 管理输入事件 //WindowManagerService 窗口管理服务 //VrManagerService VR模式管理服务 //BluetoothService 蓝牙管理服务 //NotificationManagerService 通知管理服务 //DeviceStorageMonitorService 存储相关管理服务 //LocationManagerService 定位管理服务 //AudioService 音频相关管理服务 &#125; catch (Throwable ex) &#123; ... &#125; finally &#123; ... &#125; ... Looper.loop();// 主线程 // 若执行到这里说明主线程意外退出了 // 主线程：Looper.prepareMainlooper~ Looper.loop之间 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 以上方法可以看出来关于其他服务的启动都是运行在主线程中的Looper.prepareMainlooper~ Looper.loop之间，每个SystemServer中的服务都有一个binder,会加入到ServiceManager的binder线程池中统一管理，这样拿到全局的ServiceManager,根据AIDL 获取到每Service了 startBootstrapServices(t)启动系统启动所需的一系列关键服务：AMS,P(power&#x2F;package)MS,SensorService,DisplayManagerService,LightService等 startCoreServices(t)启动核心服务：BatteryService，GpuService等 startOtherServices(t)启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等 在这些启动的服务里（调用了onStart启动服务），都会将服务存入ServiceManager 用来管理系统中的各种Service，用于系统C&#x2F;S架构中的Binder机制通信：Client端要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通讯通路，这样Client端就可以使用Service了 1. startBootstrapServices1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123; // 尽早启动看门狗，以便在早期启动过程中出现死锁时使系统服务器崩溃 t.traceBegin(&quot;StartWatchdog&quot;); // 启动看门狗，看门狗需要定时喂狗，若喂狗超时则会触发重启，以便知道进程和服务是否正常运行 final Watchdog watchdog = Watchdog.getInstance(); watchdog.start(); t.traceEnd();... t.traceBegin(&quot;StartInstaller&quot;); // 通过mSystemServiceManager来启动Installer服务,管理应用的安装与卸载 Installer installer = mSystemServiceManager.startService(Installer.class); t.traceEnd();...// 通过mSystemServiceManager来启动UriGrantsManagerService，管理Uri t.traceBegin(&quot;UriGrantsManagerService&quot;);mSystemServiceManager.startService(UriGrantsManagerService.Lifecycle.class); t.traceEnd();// 通过mSystemServiceManager来启动PowerStatsService，管理电源状态 t.traceBegin(&quot;StartPowerStatsService&quot;); mSystemServiceManager.startService(PowerStatsService.class); t.traceEnd();... t.traceBegin(&quot;StartActivityManager&quot;); // 通过mSystemServiceManager来启动ActivityTaskManagerService，管理Activity任务栈 ActivityTaskManagerService atm = mSystemServiceManager.startService( ActivityTaskManagerService.Lifecycle.class).getService(); // 启动ActivityManagerService,管理Activity等 mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); // 让ActivityManagerService拿到systemServer,例如可以通过mSystemServiceManager来判断系统是否启动完成 mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); mWindowManagerGlobalLock = atm.getGlobalLock(); t.traceEnd(); ... // 启用PowerManagerService服务，电源管理服务 t.traceBegin(&quot;StartPowerManager&quot;); mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); t.traceEnd(); ... // 启动屏幕亮度服务，比如亮度调整 t.traceBegin(&quot;StartLightsService&quot;); mSystemServiceManager.startService(LightsService.class); t.traceEnd(); // 启动屏幕显示服务 t.traceBegin(&quot;StartDisplayManager&quot;); mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); t.traceEnd(); ... // 启动PMS,包管理服务 mPackageManagerService = PackageManagerService.main(mSystemContext, installer, domainVerificationService, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); &#125; finally &#123; Watchdog.getInstance().resumeWatchingCurrentThread(&quot;packagemanagermain&quot;); &#125; ... // 启动传感器服务 t.traceBegin(&quot;StartSensorService&quot;); mSystemServiceManager.startService(SensorService.class); t.traceEnd(); t.traceEnd(); // startBootstrapServices &#125; 可以看到大多数服务都是通过mSystemServiceManager.startService来启动，核心服务和其他服务都是一样的，就不过多分析了可以先看看startService方法内容 12345678910111213141516171819202122232425262728293031 public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); ... final T service; try &#123; // 反射拿到该java类 Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; ... // 将当前服务（java类）加入SystemService服务队列中，统一管理 startService(service); return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; &#125; public void startService(@NonNull final SystemService service) &#123; // 将当前服务加入mServices队列中 mServices.add(service); // Start it. long time = SystemClock.elapsedRealtime(); try &#123; // 调用当前服务的onStart来启动服务 service.onStart(); &#125; catch (RuntimeException ex) &#123; ... &#125; warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;); &#125; 可以看到startService方法就是反射拿到服务类，然后加入队列中，调用其onStart方法进行启动 2. ServiceManager服务管理每个属于SystemServer的服务都将加入到ServiceManager的binder线程池中，以供后续直接获取和管理就拿BatteryService服务来讲解 1mSystemServiceManager.startService(BatteryService.class); 已知startService后会调用BatteryService服务的onStart方法，继续看看onStart内部 123456789101112@Override public void onStart() &#123; ... mBinderService = new BinderService(); // 将BinderService服务加入ServiceManager中 publishBinderService(&quot;battery&quot;, mBinderService); mBatteryPropertiesRegistrar = new BatteryPropertiesRegistrar(); // 将batteryproperties服务加入ServiceManager中 publishBinderService(&quot;batteryproperties&quot;, mBatteryPropertiesRegistrar); // 将BinderService服务加入到LocalServices中 publishLocalService(BatteryManagerInternal.class, new LocalService()); &#125; 继续看看mBinderService具体是什么，又是如何加入到ServiceManager中的 123private final class BinderService extends Binder &#123; ... &#125; 可以看到mBinderService就是一个Binder,然后调用publishBinderService加入到ServiceManager中的binder线程池中 123protected final void publishBinderService(...) &#123; ServiceManager.addService(name, service, allowIsolated, dumpPriority); &#125; 调用ServiceManager.addService加入到binder线程池中（ServiceManager暂不深究，只知其内部维护了binder线程池），而ServiceManager服务早就在rc文件中作为核心服务启动了，所以具体实现都是c++代码 12345678910111213service servicemanager /system/bin/servicemanager class core animation user system group system readproc critical onrestart restart apexd onrestart restart audioserver onrestart restart gatekeeperd onrestart class_restart main onrestart class_restart hal onrestart class_restart early_hal writepid /dev/cpuset/system-background/tasks shutdown critical 三. 总结其实SystemServer是通过init fork出来的，父进程就是zygote,而zygote父进程就是init进程。SystemServer内部逻辑主要就是创建了核心服务，引导服务，其他服务，例如WMS,PMS,电池服务，蓝牙服务等。这些服务都不是单独的进程，而是都属于SystemServer进程，启动这些服务过后会将这些服务加入ServiceManager的binder线程池中，因为这些服务内部都创建了Binder实例，再加入到了ServiceManager的binder线程池中，以便与随时获取服务与只通信 参考文章：Android系统启动流程（三）解析SyetemServer进程启动过程","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/4.Android13启动流程之Zygote和SystemServer启动流程/","text":"##一. Android系统启动流程 基于Android13的系统启动流程分析（一）之SeLinux权限介绍 基于Android13的系统启动流程分析（三）之FirstStageMain阶段 基于Android13的系统启动流程分析（四）之SecondStageMain阶段 基于SecondStageMain阶段解析rc文件后会启动zygote进程 zygote进程启动过后会通过JNI方式回调到上层再调回到底层的fork函数创建出SystemServer 二. Zygote服务创建源码分析在init.rc文件中会执行class_start main来启动zygote,代码如下 # 启动zygote on nonencrypted class_start main class_start late_start 这个main就是zygote,可以通过init.{zygote64}.rc来查看，代码如下 123456789101112131415161718192021222324service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server # class : 给服务指定一个类属 class main priority -20 # user 在执行此服务之前先切换用户名。当前默认为root. user root # 切换组名 group root readproc reserved_disk # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程 # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为0 socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks # oneshot : 当此服务退出时不会自动重启. # disabled:服务不会自动运行，必须显式地通过服务器来启动 # 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。 critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal 第二个参数就是服务进程的名称，通过class指定函数入口，并且位于：/system/bin/app_process64,可以看到audioserver，cameraserver，media，netd，wificond这些进程都隶属于zygote进程中，那就代表着 121.如果zygote挂了，这些进程将一起died2.如果这些进程挂了，并不会影响zygote died 如果zygote挂了将会捕获到进程异常信号，将zygote进程进行重启，zygote main入口位置： frameworks/base/cmds/app_process/app_main.cpp 1. app_main.cpp源码分析int main(int argc, char* const argv[]) &#123; ... AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); ... // 如果zygote为true则代表即将创建该进程 // 如果startSystemServer为true则代表创建zygote时也会创建SystemServer // 系统正常启动都会将这两个bool默认给到true // 因为rc启动main后携带了--zygote和--start-system-server两个参数 bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; // Skip unused &quot;parent dir&quot; argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;// zygote将为true,名称就叫：zygote zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;// startSystemServer将为true startSystemServer = true; &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123; application = true; &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; ... &#125; else &#123; // 进入创建zygote模式 // 创建/data/dalvik-cache，为后续会创建Dalvik虚拟机做准备 maybeCreateDalvikCache(); // 如果startSystemServer为true的话(默认为true) // 将”start-system-server”放入启动的参数args if (startSystemServer) &#123; args.add(String8(&quot;start-system-server&quot;)); &#125; char prop[PROP_VALUE_MAX]; ... // 将所有剩余参数传递给args，例如application或tool或start-system-server或abi // 这些启动参数将会传递到其他进程中，后续取出参数决定是否启动systemServer等操作 for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; ... // zygote为真，将创建zygote，该args启动参数会包含start-system-server // 调用runtime(AppRuntime)的start来启动zygote，将args传入，因为args包含了启动SystemServer的标志 if (zygote) &#123; runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); &#125; else if (className) &#123; runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); &#125; else &#123; fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;); app_usage(); LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;); &#125; &#125; 以上代码就是启动zygote和将start-system-server放入启动参数，后续会读取参数启动SystemServer,继续分析一下runtime.start的com.android.internal.os.ZygoteInit&quot;进程，位于：frameworks/base/core/jni/AndroidRuntime.cpp 2. AndroidRuntime.cpp源码分析Vector&lt;**String8**&gt;&amp; options就是包含了start-system-server的启动参数，通过app_main传递过来的 //frameworks/base/core/jni/AndroidRuntime.cpp void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote) &#123; ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;, className != NULL ? className : &quot;(unknown)&quot;, getuid()); // 默认会启动SystemServer static const String8 startSystemServer(&quot;start-system-server&quot;); // 是否私有，如果SystemServer会被创建时，将会设置为私有 bool primary_zygote = false; for (size_t i = 0; i &lt; options.size(); ++i) &#123; // options就是传递过来的args,默认是包含了start-system-server if (options[i] == startSystemServer) &#123; primary_zygote = true; ... &#125; &#125; // 获取环境变量，这里第一次执行时默认为空，所以rootDir不存在 // = 将直接拿到/system作为rootDir并设置环境变量 const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;); if (rootDir == NULL) &#123; rootDir = &quot;/system&quot;; if (!hasDir(&quot;/system&quot;)) &#123; LOG_FATAL(&quot;No root directory specified, and /system does not exist.&quot;); return; &#125; setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1); &#125; ... /* start the virtual machine */ // 这里就开始启动虚拟机了 // JNI功能初始化 JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; // 创建Dalvik虚拟机(这里--&gt;DVM==JavaVM) if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; return; &#125; onVmCreated(env); // 调用startReg函数用来为DVM注册JNI if (startReg(env) &lt; 0) &#123; ALOGE(&quot;Unable to register all android natives\\n&quot;); return; &#125; jclass stringClass; jobjectArray strArray; jstring classNameStr; // 通过反射拿到String类型 stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;); assert(stringClass != NULL); //options就是app_main.cpp传递过来的args,包含了start-system-server // 将options转换为array list对象 strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //从app_main的main函数得知className为com.android.internal.os.ZygoteInit classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); // 将数据转换给java类型的array 数组 env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ // 启动com.android.internal.os.ZygoteInit，该线程成为JVM的主进程，在VM退出之前不会返回 char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ... &#125; else &#123; // 通过反射的方式，找到ZygoteInit的main函数 // 若获取到内容则执行else jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) &#123; ALOGE(&quot;JavaVM unable to find main() in &#39;%s&#39;\\n&quot;, className); /* keep going */ &#125; else &#123; // 通过JNI调用ZygoteInit的main函数,将args(strArray)传递到java层 // 因为ZygoteInit的main函数是Java编写的，因此需要通过JNI调用 // 所以这里继续跟到java层面:ZygoteInit.java env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ... &#125; &#125; // 若执行到这里，则会结束zygote创建，关闭jvm free(slashClassName); ALOGD(&quot;Shutting down VM\\n&quot;); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(&quot;Warning: unable to detach main thread\\n&quot;); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(&quot;Warning: VM did not shut down cleanly\\n&quot;); &#125; 可以看到以上的代码主要就是初始化了JNI（c++与Java交互）功能并创建并启动了JVM虚拟机，通过反射的方式去启动ZygoteInit.java的main方法，并将args参数（包含了是否启动SystemServer的参数）传递过去。而JVM虚拟机进程就是：com.android.internal.os.ZygoteInit,而ZygoteInit进程位于：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit.java 3. ZygoteInit.java源码分析 public static void main(String[] argv) &#123; ZygoteServer zygoteServer = null; // 标记zygote开始了 ZygoteHooks.startZygoteNoThreadCreation(); // 设置zygote自己的用户组pid try &#123; Os.setpgid(0, 0); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(&quot;Failed to setpgid(0,0)&quot;, ex); &#125; Runnable caller; try &#123; // 读取系统是否已经启动完成 final long startTime = SystemClock.elapsedRealtime(); final boolean isRuntimeRestarted = &quot;1&quot;.equals( SystemProperties.get(&quot;sys.boot_completed&quot;)); // 将行为写入trace log 标记目前正处于ZygoteInit阶段 String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;; TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag, Trace.TRACE_TAG_DALVIK); bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;); RuntimeInit.preForkInit(); boolean startSystemServer = false; // zygote进程就是一个socket,名称就叫zygote String zygoteSocketName = &quot;zygote&quot;; String abiList = null; boolean enableLazyPreload = false; for (int i = 1; i &lt; argv.length; i++) &#123; // 从AndroidRuntime.cpp中传递上来，已经包含了start-system-server // 所以startSystemServer = true if (&quot;start-system-server&quot;.equals(argv[i])) &#123; startSystemServer = true; &#125; ... &#125; // 为true，是私有zygote final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME); ... // 记录的trace log，只记录到这个地方 bootTimingsTraceLog.traceEnd(); // ZygoteInit // 初始化socket,从环境中获取套接字FD(ANDROID_SOCKET_zygote) // 若获取不到则创建一个用于和systemServer通信的socket，当systemServer fork出来后socket进程将关闭 Zygote.initNativeState(isPrimaryZygote); ... // 根据环境变量（LocalServerSocket）获取zygote文件描述符并重新创建一个socket,可以从这里看到zygote其实就是一个socket // 这个name为”zygote”的Socket用来等待ActivityManagerService来请求Zygote来fork出新的应用程序进程 // 所以ActivityManagerService里启动应用程序（APP），都是由该zygote socket进行处理并fork出的子进程 zygoteServer = new ZygoteServer(isPrimaryZygote); // 默认为true,将启动systemServer if (startSystemServer) &#123; // zygote就是一个孵化器，所以这里直接fork（分叉，派生）出来SystemServer Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); ... // 让SystemServer子进程运行起来 if (r != null) &#123; r.run(); return; &#125; &#125; Log.i(TAG, &quot;Accepting command socket connections&quot;); // 让zygote socket（注意不是systemServer zygote）循环运行 // 等待client进程来请求调用，请求创建子进程（fork出子进程（例如等待AMS的请求）） caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; ... &#125; finally &#123; if (zygoteServer != null) &#123; // 停止关于systemServer的socket,保留和AMS通信的socket // 在initNativeState阶段创建了一个和systemServer通信的socket // 接着拿到systemServer socket文件描述符重新创建了一个可以和AMS通信的socket（/dev/socket/zygote） zygoteServer.closeServerSocket(); &#125; &#125; ... &#125; 以上代码讲述了SystemServer socket的创建，将行为写入到trace log日志系统中，并通过JNI调用到底层的fork函数，孵化出SystemServer进程，如果SystemServer创建成功并已经运行了就会将当前socket进行close 期间会创建一个zygote socket,用于等待其他子进程来连接，例如等待AMS(activity manager service)来连接该socket,然后继续fork出子进程（也就是应用程序，所以应用程序就是通过zygote来fork出来的） 创建了2个socket,一个是systemServer socket（Zygote.initNativeState(isPrimaryZygote)来创建）,一个是zygote socket（new ZygoteServer来创建），注意区分 继续来看一下zygoteServer = new ZygoteServer(isPrimaryZygote); 3.1 ZygoteInit.java#ZygoteServer（zygote socket）分析 //frameworks/base/core/java/com/android/internal/os/ZygoteServer.java ZygoteServer(boolean isPrimaryZygote) &#123; mUsapPoolEventFD = Zygote.getUsapPoolEventFD(); // 创建socket，名称为zygote,路径：/dev/sockets/zygote if (isPrimaryZygote) &#123; mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME); ... &#125; ... &#125; static LocalServerSocket createManagedSocketFromInitSocket(String socketName) &#123; //文件描述符通过ANDROID_socket_&lt;socketName&gt;环境变量共享 int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; String env = System.getenv(fullSocketName); // 拿到文件描述符内容 fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(&quot;Socket unset or invalid: &quot; + fullSocketName, ex); &#125; try &#123; // 生成文件描述符 FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); return new LocalServerSocket(fd); //frameworks/base/core/java/android/net/LocalServerSocket.java &#125; catch (IOException ex) &#123; throw new RuntimeException( &quot;Error building socket from file descriptor: &quot; + fileDesc, ex); &#125; &#125; public LocalServerSocket(FileDescriptor fd) throws IOException &#123; // 创建socket并持续监听（等待client来调用） impl = new LocalSocketImpl(fd); impl.listen(LISTEN_BACKLOG); localAddress = impl.getSockAddress(); &#125; 简单点来说就是创建了一个zygoye socket ，位于&#x2F;dev&#x2F;sockets&#x2F;zygote,并调用了runSelectLoop让其循环运行，等待新进程发来的请求并进行连接zygoteServer.runSelectLoop(abiList)然后fork出子应用程序进程 Runnable runSelectLoop(String abiList) &#123; ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;&gt;(); // 拿到socket的文件描述符 socketFDs.add(mZygoteSocket.getFileDescriptor()); ... while (true) &#123; ... if (pollReturnValue == 0) &#123; ... &#125; else &#123; boolean usapPoolFDRead = false; while (--pollIndex &gt;= 0) &#123; if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (pollIndex == 0) &#123; // Zygote server socket // acceptCommandPeer函数得到ZygoteConnection类并添加到Socket连接列表peers中， // 接着将该ZygoteConnection的文件描述符添加到fd列表fds中，以便可以接收到ActivityManagerService发送过来的请求 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); socketFDs.add(newPeer.getFileDescriptor()); &#125; ... &#125; &#125; &#125; zygoteServer.runSelectLoop(abiList)持续等待进程来请求连接并fork出应用。 至此zygote socket已经启动完毕了，该socket会等待AMS进程发来的应用程序进程fork 继续看看systemServer是怎么被fork出来的forkSystemServer(abiList, zygoteSocketName, zygoteServer); 3.2 ZygoteInit.java#forkSystemServer分析 private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; ... // 创建args数组，这个数组用来保存启动SystemServer的启动参数，其中可以看出SystemServer进程的用户id和用户组id被设 //置为1000； // 并且拥有用户组10011010，1018、1021、1032、30013010的权限；进程名为system_server； // 启动的类名为com.android.server.SystemServer String[] args = &#123; &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot; + &quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011,3012&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;--target-sdk-version=&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, &quot;com.android.server.SystemServer&quot;, &#125;; ZygoteArguments parsedArgs; int pid; try &#123; ... // 通过JNI形式去调用init进程下的fork函数，派生出systemServer进程 pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; // pid == 0代表已经运行在子进程(SystemServer)上了 // 代表SystemServer创建成功，创建成功后会关闭该socket if (pid == 0) &#123; ... // 销毁zygoteServer,保留和AMS通信的socket（runSelectLoop） // 当SystemServer创建过后，zygoteServerSocket就没有用处了，进行关闭 zygoteServer.closeServerSocket(); // 处理 system server 进程初始化工作并启动SystemServer进程 // 并启动了一个 binder 线程池供system server 进程和其他进程通信使用 // 最后调用 RuntimeInit.applicationInit() 执行进程启动自身初始化工作 // applicationInit()最后是通过反射调用了 SystemServer.java 中的 main() 方法 return handleSystemServerProcess(parsedArgs); &#125; return null; &#125; Zygote.forkSystemServer就是调用了底层的fork函数，不再进一步分析了。以上代码已知SystemServer子进程已经创建成功，将调用handleSystemServerProcess来启动SystemServer.java的入口handleSystemServerProcess会一直调用到RuntimeInit.java#findStaticMain方法中 protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; // className:com.android.server.SystemServer // 反射拿到SystemServer类 cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; ... &#125; Method m; try &#123; // 反射拿到SystemServer.java的main函数，并启动 m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; ... &#125; catch (SecurityException ex) &#123; ... &#125; ... return new MethodAndArgsCaller(m, argv); &#125; 可以看到handleSystemServerProcess下面的子方法去调用了com.android.server.SystemServer的main方法，至此SystemServer就创建和启动完毕了 至此SystemServer 已经创建并启动完毕了，那么SystemServer socket就会销毁并关闭 三. 总结可以知道zygote是从rc中启动的，zygote本质上就是一个socket,不会关闭和销毁，而创建zygote时携带的StartSystemServer参数（必须携带此参数），会启动SystemServer子进程，SystemServer也是通过fork出来的，而底层和上层的交互是通过JNI实现的，SystemServer的启动是由zygoteInit通过反射的方式启动SystemServer的main方法 zygote启动时创建了服务端socket,用于SystemServer的创建，当SystemServer创建完成后则会关闭连接，期间已经调用了runSelectLoop来循环等待AMS及其他进程来请求连接，从而fork出应用程序的socket服务端 socket会在SystemServer进程创建完毕后就会关闭，已经没有用处了，等待AMS发来连接将采用runSelectLoop方法进行循环等待","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/3.Android13启动流程之SecondStageMain阶段/","text":"一. Android系统启动基本介绍在基于Android13的系统启动流程分析（三）之FirstStageMain阶段已经讲解过android系统启动的基本介绍了，这里不再单独介绍了 二. SecondStageMain源码分析我们先看是怎么进入该阶段的，仍然是由用户空间层main.cpp调用，先简单的说一下第二阶段主要是干什么的： 设置init进程优先级并创建/dev/.booting设备块代表init正在初始化执行中 初始化属性服务，也就是会读取property_contexts文件内容以及读取build.prop内容通过MMAP映射到全局内存中，也就是对所有进程共享该资源 启动属性服务并创建socket_service,等待新链接去更新或新增属性值 挂载&#x2F;apex,vendor_overlay等其他分区 检查设备是否被unlock解锁 持续监控&#x2F;proc&#x2F;mounts设备文件，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等。将解析内容生成实体类追加到要挂载的mounts_中并进行挂载 将根目录下所有的目录设置为全局共享，例如对&#x2F;data设置为根目录下的全局共享 解析init.rc以及其他import了的rc文件，主要解析rc中的：service，on（action）,Import,而zygote进程正是从解析rc文件中创建的，然后根据zygote（本质上就是一个socket），通过JNI调用到上层代码，再fork出systemServer.java 让init进程无限循环，因为主进程不能退出，退出即代表发生异常 处理sm（ServiceList）中服务超时重启相关（init.rc中的service），若rc中启动的服务启动超时则会让其服务重新启动 123456789... if (argc &gt; 1) &#123; ... if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123; return SecondStageMain(argc, argv);//第二阶段执行 &#125; &#125; return FirstStageMain(argc, argv); //第一阶段执行&#125; 1. int SecondStageMain(int argc, char** argv)分析位于/system/core/init/init.cpp，直接上代码，代码注释中分步骤来分析 int SecondStageMain(int argc, char** argv) &#123; if (REBOOT_BOOTLOADER_ON_PANIC) &#123; // 针对产生异常的进程进行信号处理,确保子进程能重启，如果主进程pid=1发生异常则触发crash // 已经在上个文章分析过该函数 InstallRebootSignalHandlers(); &#125; ... // 初始化kernel log,所有的kernel log均输出在/dev/kmsg设备节点上 SetStdioToDevNull(argv); InitKernelLogging(argv); LOG(INFO) &lt;&lt; &quot;init second stage started!&quot;; ... // Init不应该因为依赖于任何其他进程而崩溃，因此我们忽略主进程的信号管道信息 // 但我们不想忽略子进程的SIGPIPE（信号管道），因此我们为信号处理程序设置了一个no op函数 // SIGPIPE信号产生的场景举例 // ① 初始时，C、S连接建立，若某一时刻，C端进程宕机或者被KILL而终止（终止的C端进程将会关闭打开的文件描述符，即向S端发送FIN段），S端收到FIN后，响应ACK // ② 假设此时，S端仍然向C端发送数据：当第一次写数据后，S端将会收到RST分节； 当收到RST分节后，第二次写数据后，S端将收到SIGPIPE信号（S端进程被终止） &#123; struct sigaction action = &#123;.sa_flags = SA_RESTART&#125;; action.sa_handler = [](int) &#123;&#125;; // sigaction是一个函数，可以用来查询或设置信号处理方式 sigaction(SIGPIPE, &amp;action, nullptr); &#125; // MIN_OOM_SCORE_ADJUST = -1000; // MAX_OOM_SCORE_ADJUST = 1000; // 设置进程的优先级，例如APK优先级是AMS计算出来并下发到/proc/1/oom_score_adj // 统一由init进程设置/proc/**/oom_score_adj为-1000优先级 if (auto result = WriteFile(&quot;/proc/1/oom_score_adj&quot;, StringPrintf(&quot;%d&quot;, DEFAULT_OOM_SCORE_ADJUST)); !result.ok()) &#123; LOG(ERROR) &lt;&lt; &quot;Unable to write &quot; &lt;&lt; DEFAULT_OOM_SCORE_ADJUST &lt;&lt; &quot; to /proc/1/oom_score_adj: &quot; &lt;&lt; result.error(); &#125; ... // 创建 /dev/.booting 文件，就是个标记，表示booting进行中 // is_booting()函数会依靠空文件&quot;.booting&quot;来判断是否进程处于初始化中，初始化结束后，这个文件会被删除 close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); // 当设备解锁时，允许adb root // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限,这一点在第一阶段已经完成了 // 并设置了INIT_FORCE_DEBUGGABLE环境变量，这里只是根据环境变量获取第一阶段的内容 const char* force_debuggable_env = getenv(&quot;INIT_FORCE_DEBUGGABLE&quot;); bool load_debug_prop = false; if (force_debuggable_env &amp;&amp; AvbHandle::IsDeviceUnlocked()) &#123; load_debug_prop = &quot;true&quot;s == force_debuggable_env; &#125; unsetenv(&quot;INIT_FORCE_DEBUGGABLE&quot;); // 如果设备未unlock，则卸载关于debug版本的/debug_ramdisk // 让属性值读取/ramdisk而不是/debug_ramdisk，因为非unlock,不需要debug ramdisk if (!load_debug_prop) &#123; // setup 1 UmountDebugRamdisk(); &#125; // 初始化属性服务 // 获取system/build.prop,vendor/build.prop,/odm/build.prop,/product/build.prop,等其他build.prop并加载到properties map结构中 // 然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值 // 注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖 // setup 2 PropertyInit(); // Umount second stage resources after property service has read the .prop files. // 在属性服务读取.prop文件后，将卸载/second_stage_resources，因为已经用不到了，已经将属性值加载到内存当中了 UmountSecondStageRes(); // Umount the debug ramdisk after property service has read the .prop files when it means to. // 若是debug版本，已经获取了属性值过后，也将卸载/debug_ramdisk if (load_debug_prop) &#123; UmountDebugRamdisk(); &#125; // 挂载第二阶段（该阶段）的文件系统,第一阶段已经挂载了很多基本的文件系统了以及重要的分区 // 挂载/apex：简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题 // setup 3 MountExtraFilesystems(); ... // 之前初始化了属性服务，这里将开始属性服务，其实它就是一个socket // 创建socket,处理客户端发来的请求，决定是更新属性值还是新增属性值 // setup 4 StartPropertyService(&amp;property_fd); ... // 根据ro.vndk.version 版本号，将/system/vendor_overlay和/product/vendor_overlay挂载在vendor上 // 也就是会覆盖vendor分区内容 // setup 5 fs_mgr_vendor_overlay_mount_all(); // 根据ro.oem_unlock_supported属性值来决定是否可以对设备进行unlock（解锁） // 若ro.oem_unlock_supported：「1」则代表 设备支持刷写unlock,若不支持该值为0 // 如果设备支持刷写解锁，ro.boot.verifiedbootstate则会为orange，根据orange状态，把androidboot.flash.locked设置为1 // 如果设备不支持刷新解锁，ro.boot.verifiedbootstate则会为green，根据orange状态，把androidboot.flash.locked设置为0 // androidboot.flash.locked在系统启动完成后会形成属性值 // （或 /firmware/android/flash.locked DT 属性）设置为“1”（如果已锁定）或“0”（如果已解锁）来指示锁定状态。 export_oem_lock_status(); // 持续监控/proc/mounts 节点(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;)),主要是解析该文件 // 解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等(空格分割/dev/block/dm-33 /mnt/pass_through/0/emulated ext4 rw) // 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息 // setup 6 MountHandler mount_handler(&amp;epoll); ... // 将根目录下所有的目录设置为全局共享 // 将根目录/&#123;分区&#125;类型设置为共享，以便默认情况下所有进程都可以看到任何装载事件（例如/data） if (!SetupMountNamespaces()) &#123; PLOG(FATAL) &lt;&lt; &quot;SetupMountNamespaces failed&quot;; &#125; ... // setup 7 // 创建ActionManager对象和ServiceList对象 ActionManager&amp; am = ActionManager::GetInstance(); ServiceList&amp; sm = ServiceList::GetInstance(); // 加载rc文件，保存到action manager和service list中 // rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析 // 主要解析rc中的：service，on,Import,包含了zygote.rc,路径：/system/bin/app_process64 // 在文件系统挂载的第一阶段，system/vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载 // 后面主要分析一下on early-init和on init和zygote LoadBootScripts(am, sm); ... // setup 8 // 构建action和触发器(on early-init)，放到event_queue，等待执行函数 am.QueueBuiltinAction(SetupCgroupsAction, &quot;SetupCgroups&quot;); am.QueueBuiltinAction(SetKptrRestrictAction, &quot;SetKptrRestrict&quot;); am.QueueBuiltinAction(TestPerfEventSelinuxAction, &quot;TestPerfEventSelinux&quot;); am.QueueEventTrigger(&quot;early-init&quot;); // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev... am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;); // ... so that we can start queuing up actions that require stuff from /dev. am.QueueBuiltinAction(SetMmapRndBitsAction, &quot;SetMmapRndBits&quot;); Keychords keychords; am.QueueBuiltinAction( [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123; for (const auto&amp; svc : ServiceList::GetInstance()) &#123; keychords.Register(svc-&gt;keycodes()); &#125; keychords.Start(&amp;epoll, HandleKeychord); return &#123;&#125;; &#125;, &quot;KeychordInit&quot;); // Trigger all the boot actions to get us started. // 构建action和触发器(on init)，放到event_queue，等待执行函数 am.QueueEventTrigger(&quot;init&quot;); // Don&#39;t mount filesystems or start core system services in charger mode. // 如果是充电模式则不需要挂载文件系统和不要启动核心服务 std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;); if (bootmode == &quot;charger&quot;) &#123; am.QueueEventTrigger(&quot;charger&quot;); &#125; else &#123; am.QueueEventTrigger(&quot;late-init&quot;); &#125; // Run all property triggers based on current state of the properties. // 运行所有属性触发器(action)，例如 on property am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;); // Restore prio before main loop // 设置进程优先级，主进程不能被销毁和退出，循环处理rc中的服务相关 setpriority(PRIO_PROCESS, 0, 0); while (true) &#123; // By default, sleep until something happens. auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;; auto shutdown_command = shutdown_state.CheckShutdown(); if (shutdown_command) &#123; LOG(INFO) &lt;&lt; &quot;Got shutdown_command &#39;&quot; &lt;&lt; *shutdown_command &lt;&lt; &quot;&#39; Calling HandlePowerctlMessage()&quot;; HandlePowerctlMessage(*shutdown_command); shutdown_state.set_do_shutdown(false); &#125; if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; // 执行队列中的action // 队列中依次执行每个action中携带command对应的执行函数 am.ExecuteOneCommand(); &#125; if (!IsShuttingDown()) &#123; // 处理sm（ServiceList）中服务超时重启相关（init.rc中的service） auto next_process_action_time = HandleProcessActions(); if (next_process_action_time) &#123; epoll_timeout = std::chrono::ceil&lt;std::chrono::milliseconds&gt;( *next_process_action_time - boot_clock::now()); if (*epoll_timeout &lt; 0ms) epoll_timeout = 0ms; &#125; &#125; ... return 0; &#125; 2. SecondStageMain(int argc, char** argv)—–&gt;setup 1步骤先贴一下setup 1的代码块，主要分析UmountDebugRamdisk函数 if (!load_debug_prop) &#123; // setup 1 UmountDebugRamdisk(); &#125; static void UmountDebugRamdisk() &#123; if (umount(&quot;/debug_ramdisk&quot;) != 0) &#123; PLOG(ERROR) &lt;&lt; &quot;Failed to umount /debug_ramdisk&quot;; &#125; &#125; 如果设备未unlock，则卸载关于debug版本的&#x2F;debug_ramdisk,让属性值读取&#x2F;ramdisk而不是&#x2F;debug_ramdisk 3. SecondStageMain(int argc, char** argv)—–&gt;setup 2步骤该步骤主要作用是初始化属性值服务，这里只是一个初始化的动作 // setup 2 PropertyInit(); 初始化属性服务，获取system/build.prop,vendor/build.prop,/odm/build.prop,/product/build.prop,等其他build.prop并加载到properties map结构中，然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值，注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖 PropertyInit位于/system/core/init/property_service.cpp 12345678910111213141516171819202122232425262728293031323334void PropertyInit() &#123; ... // 建立属性服务设备文件（linux思想，万物皆文件系统） mkdir(&quot;/dev/__properties__&quot;, S_IRWXU | S_IXGRP | S_IXOTH); // 创建序列化过后的propertyInfo实体，主要就是读取property_contexts文件 CreateSerializedPropertyInfo(); // 这里主要步骤是：通过mmap映射，将文件（/dev/__properties__/&#123;..&#125;）映射进内存（初始化属性内存映射文件） // 这里将文件映射进内存，用于后续对__prooerties__目录（也可以说是文件，将代码块映射为file类型）进行内存共享 if (__system_property_area_init()) &#123; LOG(FATAL) &lt;&lt; &quot;Failed to initialize property area&quot;; &#125; // 加载/dev/__properties__/property_info，此文件是序列化过的，无法直接查看内容 if (!property_info_area.LoadDefaultPath()) &#123; LOG(FATAL) &lt;&lt; &quot;Failed to load serialized property info file&quot;; &#125; // 读取/proc/device-tree/firmware/android/目录下的文件，生成ro.boot.xxx属性值 // 这三个函数主要就是生成ro.boot.xx属性值，这里不详细研究 ProcessKernelDt(); ProcessKernelCmdline(); ProcessBootconfig(); // 初始化ro.xx,将ro.boot.xx的属性值复制给ro.xxx // &#123; &quot;ro.boot.serialno&quot;, &quot;ro.serialno&quot;, UNSET, &#125;, // &#123; &quot;ro.boot.mode&quot;, &quot;ro.bootmode&quot;, &quot;unknown&quot;, &#125;, // &#123; &quot;ro.boot.baseband&quot;, &quot;ro.baseband&quot;, &quot;unknown&quot;, &#125;, // &#123; &quot;ro.boot.bootloader&quot;, &quot;ro.bootloader&quot;, &quot;unknown&quot;, &#125;, // &#123; &quot;ro.boot.hardware&quot;, &quot;ro.hardware&quot;, &quot;unknown&quot;, &#125;, // &#123; &quot;ro.boot.revision&quot;, &quot;ro.revision&quot;, &quot;0&quot;, &#125;, ExportKernelBootProps(); // 读取&#123;system/vendor/odm/product&#125;/build.prop等... // 将build.prop通过MMAP映射到全局内存中，供所有进程访问 PropertyLoadBootDefaults(); 调用__system_property_area_init通过mmap映射，将文件（&#x2F;dev&#x2F;properties&#x2F;{包含了上下文和propertys_info实体：保存了property_contexts文件内容}）映射进内存（初始化属性内存映射文件）， 这里将文件映射进内存，用于后续对__prooerties__目录（也可以说是文件，将代码块映射为file类型）进行内存共享 CreateSerializedPropertyInfo： 创建序列化过后的属性值信息（既然序列化了，那肯定是要跨进程通信）(1).读取{system_ext，vendor,product,odm,system}_property_contexts属性值安全上下文并赋值给：property_infos(2).property_infos属于容器类型，读取不同的property_contexts将会追加到末尾，而不是覆盖原本内容(3).将property_infos实体序列化，使其可以跨进程传递消息(4).将property_infos实体写入&#x2F;dev&#x2F;properties&#x2F;property_info驱动节点中 PropertyLoadBootDefaults这里会将属性值全部写入build.prop里，分为：system&#x2F;build.prop,vendor&#x2F;build.prop,&#x2F;odm&#x2F;build.prop,&#x2F;product&#x2F;build.prop，注意是有优先级顺序的，按先后顺序覆盖,获取build.prop分别是直接从指定文件里获取和从指定分区中获取，这两个方式作用都一样，只不过第二种需要区分出分区里是否存在&#123;partition&#125;/&#123;etc&#125;/build.prop,有的分区是不存在&#123;partition&#125;/etc/build.prop这个文件，而是直接存在于&#123;partition&#125;/build.prop 一切都写到了注释里，继续分析比较重要的2个函数CreateSerializedPropertyInfo和PropertyLoadBootDefaults 3.1 CreateSerializedPropertyInfovoid CreateSerializedPropertyInfo() &#123; auto property_infos = std::vector&lt;PropertyInfoEntry&gt;(); //判断文件是否存在，并判断文件是否可写(属性服务的安全上下文，之前有提过设备节点，服务，属性值都要遵守selinux规则) if (access(&quot;/system/etc/selinux/plat_property_contexts&quot;, R_OK) != -1) &#123; // 加载property_contexts文件，该文件内容都是配置的属性值上下文，属于selinux相关知识 // 通过ParsePropertyInfoFile解析该文件，得到property_infos if (!LoadPropertyInfoFromFile(&quot;/system/etc/selinux/plat_property_contexts&quot;, &amp;property_infos)) &#123; return; &#125; // 如果这里system_ext/vendor/product没有挂载上（例如在恢复的情况下，vendor分区将不会安装），则无法继续加载该上下文，该分区会在第一阶段挂载 // 从下面的代码可以看出来，property_infos的是容器类型vector&lt;PropertyInfoEntry&gt;() // 所以这里并没有优先级也没有以哪个property_contexts为准，而是根据是否存在对应的分区而append加载 // 也就是在对应后面追加内容，而不是覆盖：property_infos-&gt;emplace_back(property_info_entry); if (access(&quot;/system_ext/etc/selinux/system_ext_property_contexts&quot;, R_OK) != -1) &#123; LoadPropertyInfoFromFile(&quot;/system_ext/etc/selinux/system_ext_property_contexts&quot;, &amp;property_infos); &#125; if (!LoadPropertyInfoFromFile(&quot;/vendor/etc/selinux/vendor_property_contexts&quot;, &amp;property_infos)) &#123; // Fallback to nonplat_* if vendor_* doesn&#39;t exist. LoadPropertyInfoFromFile(&quot;/vendor/etc/selinux/nonplat_property_contexts&quot;, &amp;property_infos); &#125; if (access(&quot;/product/etc/selinux/product_property_contexts&quot;, R_OK) != -1) &#123; LoadPropertyInfoFromFile(&quot;/product/etc/selinux/product_property_contexts&quot;, &amp;property_infos); &#125; if (access(&quot;/odm/etc/selinux/odm_property_contexts&quot;, R_OK) != -1) &#123; LoadPropertyInfoFromFile(&quot;/odm/etc/selinux/odm_property_contexts&quot;, &amp;property_infos); &#125; // 若/system/etc/selinux/plat_property_contexts无法读取，则else &#125; else &#123; // 由于system下的安全上下文未创建，则可能是system出现异常未挂载上，或者供应商修改过plat_property_contexts // 一般供应商都是复写，而不会直接更改文件名称 // 若找不到该文件，则加载根目录下的这些属性值安全上下文 if (!LoadPropertyInfoFromFile(&quot;/plat_property_contexts&quot;, &amp;property_infos)) &#123; return; &#125; LoadPropertyInfoFromFile(&quot;/system_ext_property_contexts&quot;, &amp;property_infos); if (!LoadPropertyInfoFromFile(&quot;/vendor_property_contexts&quot;, &amp;property_infos)) &#123; // Fallback to nonplat_* if vendor_* doesn&#39;t exist. LoadPropertyInfoFromFile(&quot;/nonplat_property_contexts&quot;, &amp;property_infos); &#125; LoadPropertyInfoFromFile(&quot;/product_property_contexts&quot;, &amp;property_infos); LoadPropertyInfoFromFile(&quot;/odm_property_contexts&quot;, &amp;property_infos); &#125; // 序列化property_infos实体，使其可以跨进程传递 auto serialized_contexts = std::string(); auto error = std::string(); if (!BuildTrie(property_infos, &quot;u:object_r:default_prop:s0&quot;, &quot;string&quot;, &amp;serialized_contexts, &amp;error)) &#123; LOG(ERROR) &lt;&lt; &quot;Unable to serialize property contexts: &quot; &lt;&lt; error; return; &#125; ​​ &#x2F;&#x2F; 将property_infos写入&#x2F;dev&#x2F;properties&#x2F;property_info设备文件中​ constexpr static const char kPropertyInfosPath[] &#x3D; “&#x2F;dev&#x2F;properties&#x2F;property_info”;​ if (!WriteStringToFile(serialized_contexts, kPropertyInfosPath, 0444, 0, 0, false)) {​ PLOG(ERROR) &lt;&lt; “Unable to write serialized property infos to file”;​ }​ selinux_android_restorecon(kPropertyInfosPath, 0);​ } 以上的步骤都是对property_infos变量进行赋值，数据就是property_contexts文件内容，而property_infos是属于vector&lt;**PropertyInfoEntry**&gt;()容器类型,而每次加载property_infos时都是调用的property_infos-&gt;emplace_back(property_info_entry);在容器后面追加数据，不会覆盖原有的数据 读取property_contexts文件内容，将内容传递给property_infos实体 3.2 PropertyLoadBootDefaultsvoid PropertyLoadBootDefaults() &#123; std::map&lt;std::string, std::string&gt; properties; // 如果是恢复模式则加载/prop.default if (IsRecoveryMode()) &#123; load_properties_from_file(&quot;/prop.default&quot;, nullptr, &amp;properties); &#125; // 这里还没执行，只是一个未执行的代码块，从分区里读取build.prop文件 const auto load_properties_from_partition = [&amp;properties](const std::string&amp; partition, int support_legacy_path_until) &#123; // 加载&#123;system_ext,product等分区&#125;/etc/build.prop文件 // 以后代码上获取的属性值就是从该文件中获取的 auto path = &quot;/&quot; + partition + &quot;/etc/build.prop&quot;; if (load_properties_from_file(path.c_str(), nullptr, &amp;properties)) &#123; return; &#125; ... &#125; // 获取第一阶段生成的second_stage_resources/system/etc/ramdisk/build.prop // 并追加到properties中（这里是map结构，注意会覆盖内容） LoadPropertiesFromSecondStageRes(&amp;properties); // 先读取的/system/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容） load_properties_from_file(&quot;/system/build.prop&quot;, nullptr, &amp;properties); // 获取/system_ext分区下的build.prop/default.prop，赋值给然后赋值给propertiess（这里是map结构，注意会覆盖内容） load_properties_from_partition(&quot;system_ext&quot;, /* support_legacy_path_until */ 30); // 继续读取的/vendor/default.prop，然后赋值给properties（这里是map结构，注意会覆盖内容） load_properties_from_file(&quot;/vendor/default.prop&quot;, nullptr, &amp;properties); // &#125; // 继续读取的/vendor/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容） load_properties_from_file(&quot;/vendor/build.prop&quot;, nullptr, &amp;properties); // 继续读取的/vendor_dlkm/etc/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容） load_properties_from_file(&quot;/vendor_dlkm/etc/build.prop&quot;, nullptr, &amp;properties); // 继续读取的/odm_dlkm/etc/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容） load_properties_from_file(&quot;/odm_dlkm/etc/build.prop&quot;, nullptr, &amp;properties); // 获取/&#123;odm,product&#125;.prop/default.prop，赋值给然后赋值给propertiess（这里是map结构，注意会覆盖内容） load_properties_from_partition(&quot;odm&quot;, /* support_legacy_path_until */ 28); load_properties_from_partition(&quot;product&quot;, /* support_legacy_path_until */ 30); // 因为propertiess是map结构，如果key一样则会覆盖内容,所以以上代码的顺序不能调换，优先级最高的是/product下的build.prop // /system-&gt;/system_ext-&gt;/vendor-&gt;/omd-&gt;/product // 如果&quot;/debug_ramdisk/adb_debug.prop&quot;存在，说明设备已经unlock过了，则加载unlock过后的属性值，例如ro.debugger=1,则是开启了调试模式 if (access(kDebugRamdiskProp, R_OK) == 0) &#123; LOG(INFO) &lt;&lt; &quot;Loading &quot; &lt;&lt; kDebugRamdiskProp; load_properties_from_file(kDebugRamdiskProp, nullptr, &amp;properties); &#125; // 将从build.prop,default.prop获取的properties，循环设置属性值 // 这里是把.prop文件里的属性值通过mmap映射到内存中，使得所有进程可以访问（全局） for (const auto&amp; [name, value] : properties) &#123; std::string error; // 如果是ro则是只读，只能设置一次，再次设置会无效，如果存在相同的key,则会调用update更新 if (PropertySet(name, value, &amp;error) != PROP_SUCCESS) &#123; LOG(ERROR) &lt;&lt; &quot;Could not set &#39;&quot; &lt;&lt; name &lt;&lt; &quot;&#39; to &#39;&quot; &lt;&lt; value &lt;&lt; &quot;&#39; while loading .prop files&quot; &lt;&lt; error; &#125; &#125; ... // 设置persist.sys.usb.config属性值来决定是否开启调试模式（adb或none） update_sys_usb_config(); &#125; 以上代码主要做的一个动作：读取各个分区里的build.prop或直接从指定目录下读取build.prop并调用PropertySet设置到全局内存中，让所有进程访问 主要的两个函数：load_properties_from_partition和load_properties_from_file，分别从分区里读取和从指定文件读取，为什么这么做呢？因为有的分区下是没有&#x2F;etc目录的，无法直接指定文件位置，所以通过调用 &quot;/&quot; + partition + &quot;/etc/build.prop&quot;来读取，若不存在该文件则直接return。注意这里读取了{system,system_ext,vendor,vendor_dlkm,odm_dlkm,odm,product}&#x2F;build.prop,由于properties属于map结构，如果key相同是会覆盖原有的值，所以这里是有优先级排序的： &#x2F;system&#x2F;build.prop &#x2F;system_ext&#x2F;{etc}&#x2F;build.prop &#x2F;vendor&#x2F;default.prop &#x2F;vendor&#x2F;build.prop &#x2F;vendor_dlkm&#x2F;etc&#x2F;build.prop &#x2F;odm_dlkm&#x2F;etc&#x2F;build.prop &#x2F;odm&#x2F;{etc}&#x2F;build.prop &#x2F;product&#x2F;{etc}&#x2F;build.prop 如果在system中自定义了属性值，又在product自定义了一样的属性值，那么是以product为准 这里只是init初始化过程，读取build.prop并解析出来每一行属性值并调用PropertySet设置到全局内存中 继续分析一下PropertySet函数，该函数比较简单 static uint32_t PropertySet(const std::string&amp; name, const std::string&amp; value, std::string* error) &#123; ... // 找到该属性值 prop_info* pi = (prop_info*) __system_property_find(name.c_str()); if (pi != nullptr) &#123; // 如果是以ro开头则代表只读，禁止写入，返回error if (StartsWith(name, &quot;ro.&quot;)) &#123; *error = &quot;Read-only property was already set&quot;; return PROP_ERROR_READ_ONLY_PROPERTY; &#125; // 若存在该属性值且非ro 则更新属性值 __system_property_update(pi, value.c_str(), valuelen); &#125; else &#123; // 若找不到该属性值则新增 int rc = __system_property_add(name.c_str(), name.size(), value.c_str(), valuelen); if (rc &lt; 0) &#123; *error = &quot;__system_property_add failed&quot;; return PROP_ERROR_SET_FAILED; &#125; &#125; // 如果是以persist.开头，则会全部写进/data/property/persistent_properties // 属于一个缓存机制 // std::string persistent_property_filename = &quot;/data/property/persistent_properties&quot;; if (persistent_properties_loaded &amp;&amp; StartsWith(name, &quot;persist.&quot;)) &#123; WritePersistentProperty(name, value); &#125; ... return PROP_SUCCESS; &#125; 以上代码就是若存在属性值则更新，若不存在则新增。如果是ro开头的属性值则代表只读，只能初始化的时候给默认值，后续不允许修改值，如果是persist开头的则会全部缓存进/data/property/persistent_properties，persist开头的属性值是可改的，如果用户修改过了persist开头的属性值相当于修改了/data/property/persistent_properties里的属性值，那么重启后仍然生效，并不会还原默认值。这样即不影响属性值的原子性（原有的属性值），又给了开发者&#x2F;用户操作的空间，如果是刷机或恢复出厂则会还原 如果是系统开发者自定义了属性值，但是发现默认定义的时候属性值无法写入，则可能是property_contexts安全上下文影响，可以直接修改这里的代码，__system_property_add强行调用该方法即可 4. SecondStageMain(int argc, char** argv)—–&gt;setup 3步骤setup 4 MountExtraFilesystems(); static void MountExtraFilesystems() &#123; #define CHECKCALL(x) \\ if ((x) != 0) PLOG(FATAL) &lt;&lt; #x &quot; failed.&quot;; // /apex is used to mount APEXes CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/apex&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, &quot;mode=0755,uid=0,gid=0&quot;)); // /linkerconfig is used to keep generated linker configuration CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/linkerconfig&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, &quot;mode=0755,uid=0,gid=0&quot;)); #undef CHECKCALL &#125; 可以看到MountExtraFilesystems主要就挂载了&#x2F;apex和&#x2F;linkerconfig并归属于tmpfs文件系统（运行在内存的文件系统，运行速度较快）,这里主要探讨一下APEX.应用程序可以通过更新APK来升级，供应商客制化系统后可以通过OTA进行系统升级，而针对google 开发者来修复原生的系统bug该如何更新呢？那就是通过google发布的安全patch和更新manline以及apex来解决 简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题 apex可以将系统内部的各个功能打包成模块，然后针对这些模块单独升级 apk是应用程序的载体，对应用开发者而言，可以apk方式对应用功能进行升级 apex是系统功能的载体，对系统开发者（目前看主要是谷歌）而言，可以apex方式对系统功能进行升级 一般是google开发者通过playstore发布，然后供我们下载更新，而对应ODM第三方供应商，则需要通过OTA升级 apex相当于对系统功能进行了更细粒度的划分，可以独立升级这些功能，可以把apex看成是一个一个的系统升级包 5. SecondStageMain(int argc, char** argv)—–&gt;setup 4步骤 // setup 4 StartPropertyService(&amp;property_fd); 在setup2中初始化了property,获取了build.prop和property_contexts并设置为内存中全局共享 void StartPropertyService(int* epoll_socket) &#123; // 在init阶段version=1,这里已经升级到2了 InitPropertySet(&quot;ro.property_service.version&quot;, &quot;2&quot;); // 创建sockets,套接字,可以用于网络通信，也可以用于本机内的进程通信 // socketpair()函数用于创建一对无名的,相互连接的套接字 // 如果函数创建成功,则返回0,创建好的套接字分别是sv[0]和sv[1];否则返回-1 int sockets[2]; // 参数1：表示协议族AF_UNIX // 参数2：表示协议，SOCK_SEQPACKET提供连续可靠的数据包连接 // SOCK_CLOEXEC：当文件描述符设置了O_CLOEXEC属性后，在调用exec函数族时，文件描述符就会自动关闭，无需手动关闭 // 而SOCK_DGRAM是基于UDP的 // 参数3：表示类型，只能为0 // 参数4：套节字柄，该两个句柄作用相同，均能进行读写双向操作 if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sockets) != 0) &#123; PLOG(FATAL) &lt;&lt; &quot;Failed to socketpair() between property_service and init&quot;; &#125; ... // PROP_SERVICE_NAME：/dev/socket/property_service，创建socket if (auto result = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, false, 0666, 0, 0, &#123;&#125;); result.ok()) &#123; property_set_fd = *result; &#125; else &#123; LOG(FATAL) &lt;&lt; &quot;start_property_service socket creation failed: &quot; &lt;&lt; result.error(); &#125; // 监听socket:/dev/socket/property_service,最大连接：8 listen(property_set_fd, 8); // 开启线程处理socket auto new_thread = std::thread&#123;PropertyServiceThread&#125;; property_service_thread.swap(new_thread); &#125; 这里就是创建了socket,而属性值服务的本质就是一个socket（&#x2F;dev&#x2F;socket&#x2F;property_service）,最大连接为：8，持续等待连接,连接成功后决定是更新还是新增属性值，仍然是调用的PropertySet，继续分析一下PropertyServiceThread，该函数里调用了handle_property_set_fd函数，来看看具体实现 static void handle_property_set_fd() &#123; // 设置超时:2s static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */ // 可以设置四个参数，所以用的是accept4,而当启用了SOCK_CLOEXEC参数后，进程在调用exec函数族时，文件描述符就会自动关闭，无需手动关闭 int s = accept4(property_set_fd, nullptr, nullptr, SOCK_CLOEXEC); if (s == -1) &#123; return; &#125; ... switch (cmd) &#123; case PROP_MSG_SETPROP: &#123; char prop_name[PROP_NAME_MAX]; char prop_value[PROP_VALUE_MAX]; ... prop_name[PROP_NAME_MAX-1] = 0; prop_value[PROP_VALUE_MAX-1] = 0; ... // 当收到客户端发来的请求，去更新或新增属性值时会调用HandlePropertySet去处理 const auto&amp; cr = socket.cred(); std::string error; uint32_t result = HandlePropertySet(prop_name, prop_value, source_context, cr, nullptr, &amp;error); if (result != PROP_SUCCESS) &#123; LOG(ERROR) &lt;&lt; &quot;Unable to set property &#39;&quot; &lt;&lt; prop_name &lt;&lt; &quot;&#39; from uid:&quot; &lt;&lt; cr.uid &lt;&lt; &quot; gid:&quot; &lt;&lt; cr.gid &lt;&lt; &quot; pid:&quot; &lt;&lt; cr.pid &lt;&lt; &quot;: &quot; &lt;&lt; error; &#125; break; &#125; ... &#125; &#125; 可以看到设置了连接超时时间为2000ms,执行 case PROP_MSG_SETPROP，获取属性值的名称和值，调用HandlePropertySet里的PropertySet进行更新属性值或新增。PropertySet已经分析过了 至此属性值相关就分析完毕了，简单的来说就是读取build.prop属性值共享到全局内存中让所有进程获取，然后创建属性值服务（socket），持续监听客户端（哪个进程去调用更新属性值就是当前客户端）发来的请求，最大只能同时受理8个来自客户端的请求，若有客户端请求则去更新属性值或新增属性值 6. SecondStageMain(int argc, char** argv)—–&gt;setup 5步骤 // setup 5 fs_mgr_vendor_overlay_mount_all(); 这里的代码只要是针对如果有vendor_overlay分区，则覆盖&#x2F;vendor分区，主要看供应商的客制化 const std::vector&lt;const std::string&gt; kVendorOverlaySourceDirs = &#123; &quot;/system/vendor_overlay/&quot;, &quot;/product/vendor_overlay/&quot;, &#125;; bool fs_mgr_vendor_overlay_mount_all() &#123; ... // 获取 &quot;/system/vendor_overlay/&quot;,&quot;/product/vendor_overlay/&quot;下的所有子目录 // 将vendor_overlay挂载到vendor上，若存在该覆盖分区则会覆盖之前的vendor分区 const auto vendor_overlay_dirs = fs_mgr_get_vendor_overlay_dirs(vndk_version); if (vendor_overlay_dirs.empty()) return true; if (fs_mgr_overlayfs_valid() == OverlayfsValidResult::kNotSupported) &#123; LINFO &lt;&lt; &quot;vendor overlay: kernel does not support overlayfs&quot;; return false; &#125; // Mount each directory in /(system|product)/vendor_overlay/&lt;ver&gt; on /vendor // 挂载vendor_overlay到/vendor分区上 auto ret = true; for (const auto&amp; vendor_overlay_dir : vendor_overlay_dirs) &#123; if (!fs_mgr_vendor_overlay_mount(vendor_overlay_dir)) &#123; ret = false; &#125; &#125; return ret; &#125; 7. SecondStageMain(int argc, char** argv)—–&gt;setup 6步骤 // setup 6 MountHandler mount_handler(&amp;epoll); 该函数主要功能：持续监控/proc/mounts 节点(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;)),主要是解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等， 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息，挂载mounts信息里的分区位置：&#x2F;system&#x2F;core&#x2F;init&#x2F;mount_handler.cpp MountHandler::MountHandler(Epoll* epoll) : epoll_(epoll), fp_(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;), fclose) &#123; if (!fp_) PLOG(FATAL) &lt;&lt; &quot;Could not open /proc/mounts&quot;; auto result = epoll-&gt;RegisterHandler( fileno(fp_.get()), [this]() &#123; this-&gt;MountHandlerFunction(); &#125;, EPOLLERR | EPOLLPRI); if (!result.ok()) LOG(FATAL) &lt;&lt; result.error(); &#125; 继续看一下MountHandlerFunction函数 void MountHandler::MountHandlerFunction() &#123; rewind(fp_.get()); std::vector&lt;MountHandlerEntry&gt; touched; auto untouched = mounts_; //容器类型 char* buf = nullptr; size_t len = 0; // 循环读取文件内容中的每一行 while (getline(&amp;buf, &amp;len, fp_.get()) != -1) &#123; auto buf_string = std::string(buf); // /proc/mounts文件下存在一系列代码 // 若读取到/0/emulated则跳过 if (buf_string.find(&quot;/emulated&quot;) != std::string::npos) &#123; continue; &#125; // 根据读取的文件内容，来解析分区以及device path,type等 auto entry = ParseMount(buf_string); auto match = untouched.find(entry); // 若这一行解析到底了仍然没有匹配的信息，则这一条记录追加到touched中 // entry：举例---&gt;对文件内容/dev/block/dm-33 /data_mirror/data_ce/null ext4 解析过后的实体 if (match == untouched.end()) &#123; touched.emplace_back(std::move(entry)); &#125; else &#123; // 若找到了匹配的信息则移除 untouched.erase(match); &#125; &#125; free(buf); // 将匹配到的entry进行移除，并记录Mount属性值 for (auto&amp; entry : untouched) &#123; SetMountProperty(entry, false); mounts_.erase(entry); &#125; // 将未匹配到的entry追加到mounts_，并记录Mount属性值 for (auto&amp; entry : touched) &#123; SetMountProperty(entry, true); // emplace是更具有性能的 更新或追加 mounts_.emplace(std::move(entry)); &#125; &#125; 读取&#x2F;proc&#x2F;mounts，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等 若解析到&#x2F;0&#x2F;emulated则跳过,不处理 根据mounts_，当entry（解析后的内容）可以在其中找到则移除 若entry未在mounts_找到，则追加到mounts_中 相当于移除旧的entry，将新的entry追加到mounts_ 再看看是如何解析文件内容的auto entry = ParseMount(buf_string)，解析文件内容 MountHandlerEntry ParseMount(const std::string&amp; line) &#123; auto fields = android::base::Split(line, &quot; &quot;); while (fields.size() &lt; 3) fields.emplace_back(&quot;&quot;); if (fields[0] == &quot;/dev/root&quot;) &#123; auto&amp; dm = dm::DeviceMapper::Instance(); std::string path; // 根据名称获取system分区目录路径，若根据名称找不到则直接获取根目录/ // 若找到根目录则继续找/system,若找到则拿到device path // 例如/system就是挂载在/dev/block/dm-1上，那么获取的就是这个玩意 // /dev/block/dm-3 /vendor ext4 ro,seclabel,relatime 0 0 if (dm.GetDmDevicePathByName(&quot;system&quot;, &amp;path) || dm.GetDmDevicePathByName(&quot;vroot&quot;, &amp;path)) &#123; fields[0] = path; &#125; else if (android::fs_mgr::Fstab fstab; android::fs_mgr::ReadDefaultFstab(&amp;fstab)) &#123; auto entry = GetEntryForMountPoint(&amp;fstab, &quot;/&quot;); if (entry || (entry = GetEntryForMountPoint(&amp;fstab, &quot;/system&quot;))) &#123; fields[0] = entry-&gt;blk_device; &#125; &#125; &#125; // 获取所有/dev目录下的device // readlink 是Linux系统中的一个常用命令，主要用来找出符号链接所指向的位置 // 也就是找到devcie path：/dev/block/dm-33 if (android::base::StartsWith(fields[0], &quot;/dev/&quot;)) &#123; if (std::string link; android::base::Readlink(fields[0], &amp;link)) &#123; fields[0] = link; &#125; &#125; // fields0：/dev/block/dm-33（blk_device） // fields1:挂载在device上的分区/文件路径：/data_mirror/cur_profiles（mount_point） // fields2:该分区的type类型，例如可能是ext4（fs_type） return MountHandlerEntry(fields[0], fields[1], fields[2]); &#125; 让我们再来看看这个文件内容可以看出来第一列是分区挂载的位置，第二列是哪个分区，第三列属于分区格式 8. SecondStageMain(int argc, char** argv)—–&gt;setup 7步骤 // setup 7 // 创建ActionManager对象和ServiceList对象 ActionManager&amp; am = ActionManager::GetInstance(); ServiceList&amp; sm = ServiceList::GetInstance(); // 解析rc文件 LoadBootScripts(am, sm); 加载rc文件，保存到action manager和service list中 rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析 主要解析rc中的：service，on,Import,包含了zygote.rc,路径：&#x2F;system&#x2F;bin&#x2F;app_process64 在文件系统挂载的第一阶段，system&#x2F;vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载 rc中action的执行顺序：on early-init，on init，on late-init，on property static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) {&#x2F;&#x2F; 创建解析器,只解析init.rc文件中的service，on,Import类型&#x2F;&#x2F; action 使用 ActionParser，而 service 使用 ServiceParser 解析Parser parser &#x3D; CreateParser(action_manager, service_list);&#x2F;&#x2F; 获取ro.boot.init_rc属性值,此时该属性值应该是空的std::string bootscript &#x3D; GetProperty(“ro.boot.init_rc”, “”);if (bootscript.empty()) { &#x2F;&#x2F; 解析&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc &#x2F;&#x2F; 这里的路径就是将&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc 拷贝到out目录下 parser.ParseConfig(“&#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.rc”); …} else { parser.ParseConfig(bootscript);}} Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) {Parser parser;parser.AddSectionParser(“service”, std::make_unique( &amp;service_list, GetSubcontext(), std::nullopt));parser.AddSectionParser(“on”, std::make_unique(&amp;action_manager, GetSubcontext()));parser.AddSectionParser(“import”, std::make_unique(&amp;parser));return parser;} 可以看到只需要解析init.rc文件中的service,on,import类型 9. SecondStageMain(int argc, char** argv)—–&gt;setup 8步骤 // setup 8 // 构建action和触发器(on early-init)，放到event_queue，等待执行函数 ... am.QueueEventTrigger(&quot;early-init&quot;); // 构建action和触发器(on init)，放到event_queue，等待执行函数 am.QueueEventTrigger(&quot;init&quot;); // 如果是充电模式则不需要挂载文件系统和不要启动核心服务 std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;); if (bootmode == &quot;charger&quot;) &#123; am.QueueEventTrigger(&quot;charger&quot;); &#125; else &#123; am.QueueEventTrigger(&quot;late-init&quot;); &#125; // 运行所有属性触发器(action)，例如 on property am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;); 把action加入队列中按顺序依次执行，继续一下rc文件中做了什么动作， rc中action的执行顺序：on early-init，on init，on late-init，on nonencrypted（启动zygote），on property 9.1. on early-initon early-init ... mkdir /acct/uid # 挂载linkerconfig（动态链接器） mount none /linkerconfig/bootstrap /linkerconfig bind rec # 启动ueventd(位于/system/bin/ueventd),ueventd是init启动的第一个进程 start ueventd # memory.pressure_level used by lmkd chown root system /dev/memcg/memory.pressure_level chmod 0040 /dev/memcg/memory.pressure_level # app mem cgroups, used by activity manager, lmkd and zygote mkdir /dev/memcg/apps/ 0755 system system mkdir /dev/memcg/system 0550 system system mkdir /dev/net 0755 root root symlink ../tun /dev/net/tun ... # 挂载tracefs，可以通过指定方式到处trace日志，分析CPU和内存相关等问题 mount tracefs tracefs /sys/kernel/tracing gid=3012 # create sys dirctory # 创建/sys目录并指定权限 mkdir /dev/sys 0755 system system mkdir /dev/sys/fs 0755 system system mkdir /dev/sys/block 0755 system system 可以看到针对lmkd（Low Memory Killer Daemon）以及app 创建用户组，创建目录，挂载tracefs：可以通过指定方式到处trace日志，分析CPU和内存相关等问题。第一个启动的核心服务是：start ueventd，位于&#x2F;system&#x2F;bin&#x2F;ueventd,ueventd是init启动的第一个服务进程 9.2. on initon init ... chmod 0775 /dev/cpuset/system-background chmod 0664 /dev/cpuset/foreground/tasks chmod 0664 /dev/cpuset/background/tasks chmod 0664 /dev/cpuset/system-background/tasks chmod 0664 /dev/cpuset/top-app/tasks chmod 0664 /dev/cpuset/restricted/tasks chmod 0664 /dev/cpuset/tasks chmod 0664 /dev/cpuset/camera-daemon/tasks # 挂载bpf mount bpf bpf /sys/fs/bpf nodev noexec nosuid mkdir /dev/fscklogs 0770 root system ... # 允许system组读写电源状态 chown system system /sys/power/state chown system system /sys/power/wakeup_count chmod 0660 /sys/power/state ... # 在运行其他进程之前需要先启动log服务，说明init中启动的服务，第一个启动的进程是ueventd start logd # 启用 Low Memory Killer Daemon（lmkd） # 1.基于Memory的CGroup进行进程的回收；2.作为frameworks与kernel的沟通桥梁传递参数与信息 # Start lmkd before any other services run so that it can register them chown root system /sys/module/lowmemorykiller/parameters/adj chmod 0664 /sys/module/lowmemorykiller/parameters/adj chown root system /sys/module/lowmemorykiller/parameters/minfree chmod 0664 /sys/module/lowmemorykiller/parameters/minfree start lmkd # Start essential services. # 启用ServiceManager,管理各个服务，非常重要 start servicemanager start hwservicemanager start vndservicemanager 可以看到第二个启动的核心服务是：start logd，日志系统。第三个核心服务是：start lmkd，Low Memory Killer Daemon作用：基于Memory的CGroup进行进程的回收，作为frameworks与kernel的沟通桥梁传递参数与信息。接着启动了：servicemanager，hwservicemanager，vndservicemanager，这些都属于核心服务若核心服务未启动成功，那么其他服务将无法启动，系统将无法启动，其他服务必须依赖核心服务 9.3. on late-init# 装载文件系统并启动核心系统服务 on late-init trigger early-fs # 触发on fs和on post-fs trigger fs trigger post-fs trigger late-fs trigger post-fs-data trigger load_persist_props_action trigger load_bpf_programs trigger zygote-start trigger firmware_mounts_complete trigger early-boot trigger boot 可以看到调用顺序为：启动系统on late-init会先执行，然后继续触发on fs，on post-fs ，on late-fs，on zygote-start ，on boot等，在调用on zygote-start后会解析zygote服务并指定class 名称，然后加入服务管理队列，后续等待调用on nonencrypted来启动zygote服务 9.4. on nonencryptedon nonencrypted class_start main class_start late_start 目录：/system/core/rootdir/init.zygote64.rc service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server # class : 给服务指定一个类属 class main priority -20 # user 在执行此服务之前先切换用户名。当前默认为root. user root # 切换组名 group root readproc reserved_disk # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程 # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为0 socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks # oneshot : 当此服务退出时不会自动重启. # disabled:服务不会自动运行，必须显式地通过服务器来启动 # 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。 critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal 可以看到通过class_start main来启动主函数main,位于：frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp int main(int argc, char* const argv[]) &#123; ... if (zygote) &#123; runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); &#125; else if (className) &#123; runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); &#125; else &#123; fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;); app_usage(); LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;); &#125; &#125; 这里启动了zygote,并且携带参数启动了systemServer，关于zygote这里就不再详细分析了 二. 附录rc文件中的command以及触发器，action等，对应的关系如下： static const BuiltinFunctionMap builtin_functions = &#123; &#123;&quot;bootchart&quot;, &#123;1, 1, &#123;false, do_bootchart&#125;&#125;&#125;, &#123;&quot;chmod&quot;, &#123;2, 2, &#123;true, do_chmod&#125;&#125;&#125;, &#123;&quot;chown&quot;, &#123;2, 3, &#123;true, do_chown&#125;&#125;&#125;, &#123;&quot;class_reset&quot;, &#123;1, 1, &#123;false, do_class_reset&#125;&#125;&#125;, &#123;&quot;class_reset_post_data&quot;, &#123;1, 1, &#123;false, do_class_reset_post_data&#125;&#125;&#125;, &#123;&quot;class_restart&quot;, &#123;1, 1, &#123;false, do_class_restart&#125;&#125;&#125;, &#123;&quot;class_start&quot;, &#123;1, 1, &#123;false, do_class_start&#125;&#125;&#125;, &#123;&quot;class_start_post_data&quot;, &#123;1, 1, &#123;false, do_class_start_post_data&#125;&#125;&#125;, &#123;&quot;class_stop&quot;, &#123;1, 1, &#123;false, do_class_stop&#125;&#125;&#125;, &#123;&quot;copy&quot;, &#123;2, 2, &#123;true, do_copy&#125;&#125;&#125;, &#123;&quot;copy_per_line&quot;, &#123;2, 2, &#123;true, do_copy_per_line&#125;&#125;&#125;, &#123;&quot;domainname&quot;, &#123;1, 1, &#123;true, do_domainname&#125;&#125;&#125;, &#123;&quot;enable&quot;, &#123;1, 1, &#123;false, do_enable&#125;&#125;&#125;, &#123;&quot;exec&quot;, &#123;1, kMax, &#123;false, do_exec&#125;&#125;&#125;, &#123;&quot;exec_background&quot;, &#123;1, kMax, &#123;false, do_exec_background&#125;&#125;&#125;, &#123;&quot;exec_start&quot;, &#123;1, 1, &#123;false, do_exec_start&#125;&#125;&#125;, &#123;&quot;export&quot;, &#123;2, 2, &#123;false, do_export&#125;&#125;&#125;, &#123;&quot;hostname&quot;, &#123;1, 1, &#123;true, do_hostname&#125;&#125;&#125;, &#123;&quot;ifup&quot;, &#123;1, 1, &#123;true, do_ifup&#125;&#125;&#125;, &#123;&quot;init_user0&quot;, &#123;0, 0, &#123;false, do_init_user0&#125;&#125;&#125;, &#123;&quot;insmod&quot;, &#123;1, kMax, &#123;true, do_insmod&#125;&#125;&#125;, &#123;&quot;installkey&quot;, &#123;1, 1, &#123;false, do_installkey&#125;&#125;&#125;, &#123;&quot;interface_restart&quot;, &#123;1, 1, &#123;false, do_interface_restart&#125;&#125;&#125;, &#123;&quot;interface_start&quot;, &#123;1, 1, &#123;false, do_interface_start&#125;&#125;&#125;, &#123;&quot;interface_stop&quot;, &#123;1, 1, &#123;false, do_interface_stop&#125;&#125;&#125;, &#123;&quot;load_exports&quot;, &#123;1, 1, &#123;false, do_load_exports&#125;&#125;&#125;, &#123;&quot;load_persist_props&quot;, &#123;0, 0, &#123;false, do_load_persist_props&#125;&#125;&#125;, &#123;&quot;load_system_props&quot;, &#123;0, 0, &#123;false, do_load_system_props&#125;&#125;&#125;, &#123;&quot;loglevel&quot;, &#123;1, 1, &#123;false, do_loglevel&#125;&#125;&#125;, &#123;&quot;mark_post_data&quot;, &#123;0, 0, &#123;false, do_mark_post_data&#125;&#125;&#125;, &#123;&quot;mkdir&quot;, &#123;1, 6, &#123;true, do_mkdir&#125;&#125;&#125;, // TODO: Do mount operations in vendor_init. // mount_all is currently too complex to run in vendor_init as it queues action triggers, // imports rc scripts, etc. It should be simplified and run in vendor_init context. // mount and umount are run in the same context as mount_all for symmetry. &#123;&quot;mount_all&quot;, &#123;0, kMax, &#123;false, do_mount_all&#125;&#125;&#125;, &#123;&quot;mount&quot;, &#123;3, kMax, &#123;false, do_mount&#125;&#125;&#125;, &#123;&quot;perform_apex_config&quot;, &#123;0, 0, &#123;false, do_perform_apex_config&#125;&#125;&#125;, &#123;&quot;umount&quot;, &#123;1, 1, &#123;false, do_umount&#125;&#125;&#125;, &#123;&quot;umount_all&quot;, &#123;0, 1, &#123;false, do_umount_all&#125;&#125;&#125;, &#123;&quot;update_linker_config&quot;, &#123;0, 0, &#123;false, do_update_linker_config&#125;&#125;&#125;, &#123;&quot;readahead&quot;, &#123;1, 2, &#123;true, do_readahead&#125;&#125;&#125;, &#123;&quot;remount_userdata&quot;, &#123;0, 0, &#123;false, do_remount_userdata&#125;&#125;&#125;, &#123;&quot;restart&quot;, &#123;1, 1, &#123;false, do_restart&#125;&#125;&#125;, &#123;&quot;restorecon&quot;, &#123;1, kMax, &#123;true, do_restorecon&#125;&#125;&#125;, &#123;&quot;restorecon_recursive&quot;, &#123;1, kMax, &#123;true, do_restorecon_recursive&#125;&#125;&#125;, &#123;&quot;rm&quot;, &#123;1, 1, &#123;true, do_rm&#125;&#125;&#125;, &#123;&quot;rmdir&quot;, &#123;1, 1, &#123;true, do_rmdir&#125;&#125;&#125;, &#123;&quot;setprop&quot;, &#123;2, 2, &#123;true, do_setprop&#125;&#125;&#125;, &#123;&quot;setrlimit&quot;, &#123;3, 3, &#123;false, do_setrlimit&#125;&#125;&#125;, &#123;&quot;start&quot;, &#123;1, 1, &#123;false, do_start&#125;&#125;&#125;, &#123;&quot;stop&quot;, &#123;1, 1, &#123;false, do_stop&#125;&#125;&#125;, &#123;&quot;swapon_all&quot;, &#123;0, 1, &#123;false, do_swapon_all&#125;&#125;&#125;, &#123;&quot;enter_default_mount_ns&quot;, &#123;0, 0, &#123;false, do_enter_default_mount_ns&#125;&#125;&#125;, &#123;&quot;symlink&quot;, &#123;2, 2, &#123;true, do_symlink&#125;&#125;&#125;, &#123;&quot;sysclktz&quot;, &#123;1, 1, &#123;false, do_sysclktz&#125;&#125;&#125;, &#123;&quot;trigger&quot;, &#123;1, 1, &#123;false, do_trigger&#125;&#125;&#125;, &#123;&quot;verity_update_state&quot;, &#123;0, 0, &#123;false, do_verity_update_state&#125;&#125;&#125;, &#123;&quot;wait&quot;, &#123;1, 2, &#123;true, do_wait&#125;&#125;&#125;, &#123;&quot;wait_for_prop&quot;, &#123;2, 2, &#123;false, do_wait_for_prop&#125;&#125;&#125;, &#123;&quot;write&quot;, &#123;2, 2, &#123;true, do_write&#125;&#125;&#125;, &#125;; 三. 总结至此第二阶段就分析完毕了，一句话来总结：优先保证init进程的存活率（拉高优先级），处理设备是否unlock,决定是否卸载一些分区以及调整selinux规则和权限，创建并启动属性服务（实质上就是把属性值映射到全局内存中供所有进程访问，然后在创建socket等待进程来连接 实现更新和新增属性值），继续决定是否把vendor_overlay覆盖到/vendor分区中，然后持续监控/proc/mounts,如果有分区信息加入到该文件中则挂载此分区，接着解析rc文件（创建目录，修改权限，挂载分区，启动服务进程等），根据调用顺序启动核心服务（adbd,ueventd等）以及主服务(zygote)和其他服务","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/2.Android13启动流程之FirstStageMain阶段/","text":"一. Android系统启动基本介绍12init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init 1. Bootloader 引导 当按下设备电源键时，最先运行的就是 bootloader（固化在ROM的程序），bootloader 的主要作用就是硬件设备（如 CPU、flash、内存）的初始化并加载到RAM，通过建立内存空间映射，为装载 Linux 内核做好准备,。如果 bootloader 在运行期间，按下预定义的组合按键，可以进入系统fastboot模式 或者 Receiver 模式。 2. 装载和启动 Linux 内核 在编译完AOSP时会生成boot.img或者boot_debug.img，该镜像就是 Linux 内核和根文件系统，bootloader 会把该镜像装载到内存中，然后 linux 内核会执行整个系统的初始化，完成后装载根文件系统，最后启动 init 进程。 3. 启动 Init 进程 Linux 内核加载完毕后，会从kernel内核层调用到用户空间层，则会首先启动 init 进程，init 进程是系统的第一个进程，在 init 进程的启动过程中会解析最主要的 init.rc 脚本，根据 init.rc 文件的描述，系统会创建文件及目录以及权限的赋予，初始化属性和启动 Android 系统重要的守护进程。 4. 启动 ServiceManager ServiceManager 由 init 进程启动。它的主要作用是管理 Binder 服务，service 服务的注册和查找，如 AMS、PMS， 都是通过 ServiceManger 来管理。 5. 启动 MediaServer MediaServer 是由 init 进程启动，它包含了一些多媒体 binder 服务，包括 CameraService、MediaPlayerService、AudioPolicyService 等等 onrestart restart audioserveronrestart restart cameraserveronrestart restart mediaonrestart restart media.tuneronrestart restart netdonrestart restart wificond 6. 启动 Zygote 进程 init 进程初始化结束后，会启动 Zygote 进程。在 Android 系统中所有的应用程序进程和系统服务进程都是通过Zygote 进程 fork 出来的。预装载系统的资源文件，所有从 Zygote 进程 fork 出的子进程都会共享这些资源，节省了资源加载的时间，提高的应用的启动速度。Zygote 启动结束后也会变为守护进程，负责响应启动 APK 的请求。 7. 启动 SystemServer SystemServer 是跟随Zygote创建出来的第一个子进程，同时也是整个 Android 系统的核心。在系统中运行的大部分系统服务都是有 SystemServer 创建，接着会启动 AMS、WMS、PMS 等。阅读过源码可以发现大部分服务会继承自systemServer PD2183:/ $ ps --pid 1 USER PID PPID VSZ RSS WCHAN ADDR S NAME root 1 0 13133644 8264 0 0 S init init进程由init_task进程fork而来，在kernel初始化完成后init_task便化身为idle进程，可以看到init的进程pid为：1而init_task进程是Linux中第一个进程，也即0号进程(PID为0)，这里不进一步分析linux内核层。 二. FirstStageMain阶段分析 针对super分区，在开机init的first stage第一阶段运行期间，会解析并验证metadata元数据并创建虚拟block设备来表示每个子分区，super分区头部信息就是metadata元数据，用于映射（mapping）出虚拟block设备，这里盗用一张大佬的图来看一下super结构 super分区除了包含system\\product\\vendor，在头部信息包含了描述分区布局的metadata，系统加载动态分区时读取metadata，对其进行解析。 Metadata中的信息会被转换成device mapper中的映射表Mapping Table，基于这个映射表，super分区对应设备/dev/block/by-name/super的不同部分被映射成多个虚拟设备，如/dev/block/mapper/system_a ，/dev/block/mapper/vendor_a等 1. 用户空间层main.cppusing namespace android::init; int main(int argc/*1*/, char** argv/*init*/) &#123; // 内核层传过来的，argc：1,argv：init #if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback); #elif __has_feature(hwaddress_sanitizer) __hwasan_set_error_report_callback(AsanReportCallback); #endif // Boost prio which will be restored later setpriority(PRIO_PROCESS, 0, -20); // 设置进程最高优先级 -20最高，20最低 if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123; return ueventd_main(argc, argv); &#125; if (argc &gt; 1) &#123; if (!strcmp(argv[1], &quot;subcontext&quot;)) &#123; android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); return SubcontextMain(argc, argv, &amp;function_map); &#125; if (!strcmp(argv[1], &quot;selinux_setup&quot;)) &#123; return SetupSelinux(argv); &#125; if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123; return SecondStageMain(argc, argv); &#125; &#125; return FirstStageMain(argc, argv); //第一阶段执行 &#125; 内核层传过来的参数：argc：1,argv：init，所以第一阶段仍然是调用return FirstStageMain(argc, argv); 这里不详细介绍subcontext,ueventd，只关注FirstStageMain阶段即可，调用顺序如下 FirstStageMain：主要创建和挂载基本的文件系统，挂载特定分区，启用log等 SetupSelinux：挂载并启用selinux权限系统，之前文章有讲过关于权限问题; SecondStageMain：主要解析ini.rc文件，创建zygote孵化器，fork 进程等 2. FirstStageMain(int argc, char** argv)解析该阶段所挂载的文件系统都属于ramdisk，运行在虚拟内存上 //system/core/init/first_stage_init.cpp int FirstStageMain(int argc, char** argv) &#123; // init阶段的启动引导加载程序（bootLoader），若发生异常重启也会再次执行，主要处理init || fork的子进程进程异常行为 // init信号处理器，调试版本当init crash，默认重启到 bootLoader if (REBOOT_BOOTLOADER_ON_PANIC) &#123; InstallRebootSignalHandlers();// setup1 &#125; // 用来设置创建目录或文件时所应该赋予权限的掩码 // Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755 // 在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高 umask(0); // 第一次执行时清除环境变量，reset path CHECKCALL(clearenv()); CHECKCALL(setenv(&quot;PATH&quot;, _PATH_DEFPATH, 1)); // setup 2 // 设置linux最基本的文件系统并且挂载到 / 目录(init ram disk)上, // 并给0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限），后续会通过rc文件处理一些分区权限和进程 CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); //将/dev设置为tmpfs并挂载，设置0755权限，tmpfs是在内存上建立的文件系统（Filesystem） CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//tmpfs文件系统类型 CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755)); CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//tmpfs文件系统类型 CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL)); // setup 3 CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC))); #undef MAKE_STR // 修改 「保存操作系统的启动参数」 的权限：0440， // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作 // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数 CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440)); std::string cmdline; // 读取操作系统的启动参数 android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline); // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程 // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作 chmod(&quot;/proc/bootconfig&quot;, 0440); std::string bootconfig; // 读取系统启动参数配置 android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig); gid_t groups[] = &#123;AID_READPROC&#125;; CHECKCALL(setgroups(arraysize(groups), groups)); // setup 4 // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。 // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中 // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息 CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL)); CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL)); CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11))); if constexpr (WORLD_WRITABLE_KMSG) &#123; CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11))); &#125; // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数 CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8))); CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9))); // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。 CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2))); CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3))); // setup 5 // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载 // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理 // tmpfs之前说过了，是运作在RAM的文件系统 CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, &quot;mode=0755,uid=0,gid=1000&quot;)); CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755)); CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755)); CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, &quot;mode=0755,uid=0,gid=0&quot;)); // 创建selinux驱动节点，类型属于：tmpfs CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744)); // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的 SetStdioToDevNull(argv); InitKernelLogging(argv); // log可以使用了，第一阶段正式开始 创建设备 LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;; // setup 6 // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统 auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;; // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量 // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成 if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123; PLOG(ERROR) &lt;&lt; &quot;Could not stat(\\&quot;/\\&quot;), not freeing ramdisk&quot;; old_root_dir.reset(); &#125; // 加载kernel模块且是非正常的启动模式 // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)，并加载kernel模块且处于非正常的启动模式 // 再根据want_console来决定是否打开串口日志 if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console, want_parallel, module_count)) &#123; if (want_console != FirstStageConsoleParam::DISABLED) &#123; LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;; &#125; else &#123; LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;; &#125; &#125; // 继续根据是否打开串口日志来创建devices // want_console == 1 if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123; // 非恢复模式下进行，在 recovery 模式下不允许创建设备 if (!IsRecoveryMode()) &#123; // 在创建逻辑分区之前挂载 /metadata // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问 // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区 created_devices = DoCreateDevices(); if (!created_devices) &#123; LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;; &#125; &#125; StartConsole(cmdline); &#125; // setup 7 // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下 if (access(kBootImageRamdiskProp, F_OK) == 0) &#123; // 获取/second_stage_resources/system/etc/ramdisk/build.prop // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建 std::string dest = GetRamdiskPropForSecondStage(); // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk std::string dir = android::base::Dirname(dest); std::error_code ec; if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123; LOG(FATAL) &lt;&lt; &quot;Can&#39;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message(); &#125; // 生成 /second_stage_resources/system/etc/ramdisk/build.prop if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123; LOG(FATAL) &lt;&lt; &quot;Can&#39;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot; &lt;&lt; ec.message(); &#125; LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest; &#125; // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root // /userdebug_plat_sepolicy.cil属于selinux策略里的规则 // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限 if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123; constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;; constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;; ... setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1); &#125; // setup 8 // 如果内核命令行中存在 androidboot.force_normal_boot=1，则设备会正常启动，即正常启动时 if (ForceNormalBoot(cmdline, bootconfig)) &#123; // 创建第一阶段ramdisk目录 /first_stage_ramdisk mkdir(&quot;/first_stage_ramdisk&quot;, 0755); // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;; PrepareSwitchRoot(); if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123; PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;; &#125; // 将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk SwitchRoot(&quot;/first_stage_ramdisk&quot;); &#125; // 挂载 system、vendor 、product等系统分区 if (!DoFirstStageMount(!created_devices)) &#123; LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;; &#125; // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等 struct stat new_root_info; if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123; PLOG(ERROR) &lt;&lt; &quot;Could not stat(\\&quot;/\\&quot;), not freeing ramdisk&quot;; old_root_dir.reset(); &#125; // 根目录发生变化，则释放old ramdisk，用new ramdisk if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123; FreeRamdisk(old_root_dir.get(), old_root_info.st_dev); &#125; // setup 8 主要内容:将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk // setup 9 //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。 // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root）, // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：bootloader，boot.img，system.img。 // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过 SetInitAvbVersionInRecovery(); // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了 // init程序的二进制文件目录 const char* path = &quot;/system/bin/init&quot;; const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区 // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp execv(path, const_cast&lt;char**&gt;(args)); &#125; ​ 具体信息可以看注释，这里我分为了11个步骤来分析，也就是对应的setup 1~10 2. FirstStageMain(int argc, char** argv)—–&gt;setup 1步骤主要分析InstallRebootSignalHandlers();// setup1其关键作用：主要加载引导程序以及init阶段crash的进程处理，也就是异常处理 // 主要加载引导程序以及init阶段crash的进程处理 //system/core/init/reboot_utils.cpp void InstallRebootSignalHandlers() &#123; struct sigaction action; // memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作 memset(&amp;action, 0, sizeof(action)); // sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里即将所有的信号标志位置为1。 // 成功返回0,反之返回1 sigfillset(&amp;action.sa_mask); // 对于从init派生的进程（init进程对操作系统的意义在于，其他所有的用户进程都直接或者间接派生自init进程,例如解析init.rc出来的进程zygote） // 这些信号处理程序也会被捕获，但是我们不希望它们触发重新启动，所以我们在这里直接为子进程调用_exit（） // 针对加载引导程序或init crash后加载引导程序，不应该restart,而是直接退出 再次启动系统时重新start action.sa_handler = [](int signal) &#123; if (getpid() != 1) &#123; _exit(signal); &#125; // 由于init fatal || crash执行重启（所以有些机器故障会无限卡logo重启），这里执行了重启或是强制关机 InitFatalReboot(signal); //1 &#125;; action.sa_flags = SA_RESTART; // 设置信号处理器 sigaction(SIGABRT, &amp;action, nullptr); sigaction(SIGBUS, &amp;action, nullptr); sigaction(SIGFPE, &amp;action, nullptr); sigaction(SIGILL, &amp;action, nullptr); sigaction(SIGSEGV, &amp;action, nullptr); #if defined(SIGSTKFLT) sigaction(SIGSTKFLT, &amp;action, nullptr); #endif sigaction(SIGSYS, &amp;action, nullptr); sigaction(SIGTRAP, &amp;action, nullptr); &#125; 以上代码块的逻辑大概就是收集进程信号集，将这些异常的信号集进行特殊处理（关机或重启 触发循环卡logo等），并把这些信号标志为1，针对init进程（Pid&#x3D;1）派生出来的子进程（例如zygote）而是选择直接退出 不进一步处理，因为如果init进程重新启动后将会重新派生出原来的子进程。这里继续分析一下InitFatalReboot(signal); //1 2.1 InitFatalReboot(signal)void __attribute__((noreturn)) InitFatalReboot(int signal_number) &#123; // 派生出子进程，pid == -1则代表fork进程失败 auto pid = fork(); // Init 是Android OS中第一个user space process（用户态或用户空间pid = 1），守护进程（在后台运行的守护进程，其一作用于执行启动的系统任务） // Init 进程是所有用户进程的鼻祖，Init 进程会孵化（fork，派生）出 ueventd、logd、healthd、installd、adbd、lmkd 等用户守护进程 if (pid == -1) &#123; // 当pid==1时说明fork失败，立即执行bootloader重启，可能会重新执行到pid == 0 // Couldn&#39;t fork, don&#39;t even try to backtrace, just reboot. RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target); &#125; else if (pid == 0) &#123; //fork成功，说明现在运行在子进程上，并且子进程需确保能重启 sleep(5); RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target); &#125; // 当关机时，尝试在父进程（pid = 1，即init）中获取back trace日志 LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: signal &quot; &lt;&lt; signal_number; std::unique_ptr&lt;Backtrace&gt; backtrace( Backtrace::Create(BACKTRACE_CURRENT_PROCESS, BACKTRACE_CURRENT_THREAD)); if (!backtrace-&gt;Unwind(0)) &#123; LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Failed to unwind callstack.&quot;; &#125; for (size_t i = 0; i &lt; backtrace-&gt;NumFrames(); i++) &#123; LOG(ERROR) &lt;&lt; backtrace-&gt;FormatFrameData(i); &#125; // 判断init（主）进程是否被标记为异常（例如init主进程都退出了），决定是否需要重启bootLoader（正常步骤会执行到重启，异常则直接sysdump） // 启动内核时出现panic的几种情况：出现init进程被异常杀死，则直接触发崩溃，即进入sysdump if (init_fatal_panic) &#123; LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Trigger crash&quot;; // 通过#define PROC_SYSRQ &quot;/proc/sysrq-trigger&quot; 写值触发系统崩溃 // echo b &gt; /proc/sysrq-trigger --&gt;立即重启 // echo o &gt; /proc/sysrq-trigger --&gt;立即关机 // echo c &gt; /proc/sysrq-trigger --&gt;立即让系统崩溃 // echo t &gt; /proc/sysrq-trigger --&gt;导出线程状态信息 // echo u &gt; /proc/sysrq-trigger --&gt;立即重新挂载所有的文件系统为只读 android::base::WriteStringToFile(&quot;c&quot;, PROC_SYSRQ); LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Sys-Rq failed to crash the system; fallback to exit().&quot;; _exit(signal_number); &#125; // 在init进程上重启 RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target); &#125; 以上代码块主要作用于确保子进程，如果fork成功则代表目前运行在子进程上，目的就是一个：确保子进程能重启，如果init进程（主进程）被标记为致命异常，则会立即执行android::base::WriteStringToFile(&quot;c&quot;, PROC_SYSRQ);，触发死机 至此setup 1就分析完了，总结一句话：针对异常的进程进行特殊的处理，例如让子进程确保能重启，检查init进程是否退出或产生异常，若主进程异常则直接对设备进行强制死机，进入sysdump 3. FirstStageMain(int argc, char** argv)—–&gt;setup 2步骤setup 2主要就是初始化文件系统，我这里单独在贴一下代码： // setup 2 //将/dev设置为tmpfs文件系统并挂载，设置0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限） // 后续会通过rc文件处理一些分区权限和进程，tmpfs是在内存上建立的文件系统（Filesystem） // tmpfs文件系统是一种基于内存的文件系统，可以运行在RAM上，所以/dev都属于tmpfs文件系统 CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//1 // 关于/dev/socket目录 // 0. tmpfs文件系统类型，例如zygote就保存到该位置（/dev/socket） // 1. zygote 开始循环监听 /dev/socket/zygote，system_server 与zygote 达成首次通信 // 2. 之后AMS会且连接 /dev/socket/zygote 的socket，进行通信 CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));//2 CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//3 CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL)); 这里主要初始化了基本的文件系统tmpfs，既然基于RAM，那肯定有易失性，特点如下： 基于内存的文件系统 能够动态地使用虚拟内存 不需要格式化文件系统 tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的,其优点是读写速度很快，但存在掉电丢失的风险(ramfs与tmpfs有着对比性)，这也许就是它叫tmpfs的原故 由于tmpfs基于RAM，运行在内存上，因此它比硬盘的速度肯定要快，因此我们可以利用这个优点使用它来提升机器的性能（小伙伴们可以试着把tmpfs改为基于disk的文件系统试试），tmpfs 的另一个主要的好处是它闪电般的速度，因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的 tmpfs使用了虚拟内存的机制，它会进行swap，用例：达到空间上限时继续写入 结果：提示错误信息并终止，且tmpfs是有上限的，超过时会提示错误信息并终止 所以相比ramfs是比较安全的 tmpfs和ramfs有着对比性，tmpfs是相对安全的，因为 达到空间上限时仍继续写入数据，那么提示错误信息并终止而ramfs没有空间上限，会持续写入尚未分配的空间（占用其他未分配的内存）。因此tmpfs是固定大小，ramfs不固定其大小。可以通过命令来查看手机系统使用的是tmpfs还是ramfs，以及他们的信息adb shell mount | grep -E &quot;(tmpfs|ramfs)&quot;可以看到该设备使用的是tmpfs文件系统，以及可以看到属于tmpfs文件系统的分区，大小信息等,还有一个命令也可以查看，比较简约adb shell df -h | grep -E &quot;(tmpfs|ramfs)&quot;可以看到使用的大小，&#x2F;dev &#x2F;mnt &#x2F;apex都属于tmpfs文件系统，代码里提到过关于&#x2F;dev&#x2F;socket目录，是一个比较重要的知识点，具体看注释即可 4. FirstStageMain(int argc, char** argv)—–&gt;setup 3步骤继续贴上FirstStageMain函数里面的setup 3的代码， // 挂载proc文件系统（驻留在RAM中），Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种虚拟文件系统 CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));// 1 #undef MAKE_STR // 修改 「保存操作系统的启动参数」 的权限：0440， // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作 // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数 CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440)); std::string cmdline; // 读取操作系统的启动参数 android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline); // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程 // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作 chmod(&quot;/proc/bootconfig&quot;, 0440); std::string bootconfig; // 读取系统启动参数配置 android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig); gid_t groups[] = &#123;AID_READPROC&#125;; CHECKCALL(setgroups(arraysize(groups), groups)); 这里主要解释一下注释的第一点 该目录下保存的并不是真正的文件和目录（虚拟文件系统），而是一些【运行时】的信息，如 CPU 信息、负载信息、系统内存信息、磁盘 IO 信息等。存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系的硬件及当前【正在运行进程的信息】，甚至可以通过更改其中某些文件来改变内核的运行状态 /proc/cmdline # 保存操作系统的启动参数,/proc/cmdline中保存bootloader 启动linux kernel 时 的参数 /proc/cpuinfo # 保存CPU的相关信息。对应lscpu命令。 /proc/devices # 系统已经加载的所有块设备和字符设备的信息。 /proc/diskstats # 统计磁盘设备的I/O信息。 /proc/filesystems # 保存当前系统支持的文件系统。 /proc/kcore # 物理内存的镜像。该文件大小是已使用的物理内存加上4K。 /proc/loadavg # 保存最近1分钟、5分钟、15分钟的系统平均负载。 /proc/meminfo # 保存当前内存使用情况。对应free命令 /proc/mounts -&gt; self/mounts # 系统中当前挂载的所有文件系统。mount命令。 # mounts文件是链接到self/mounts。 /proc/partitions # 每个分区的主设备号（major）、次设备号（minor）、包含的块（block）数目。 /proc/uptime # 系统自上次启动后的运行时间。 /proc/version # 当前系统的内核版本号 /proc/vmstat # 当前系统虚拟内存的统计数据 所以该步骤的代码块主要代码：CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));和android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);，指定权限，若权限改变则无法正常读取，可以防止强行改变权限为a+x或777而带来的非法操作，然后读取cmdline，读取操作系统的启动参数 4. FirstStageMain(int argc, char** argv)—–&gt;setup 4步骤 // setup 4 // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。 // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中 // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息 CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL)); // 挂载/sys/fs/selinux文件系统，也属于/sys // /sys/fs/selinux ： selinux机制，也就是处理selinux权限机制文件存放的位置，判断是否开启严格模式等 CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL)); // 创建处理日志的设备文件 // Linux内核通过printk打印的log信息,这些log写入到了/dev/kmsg文件中, // 也就是kernel log,在展锐平台上可以通过python解析ylog来看到kernel log // 也可以在 Shell终端可以通过dmesg /dev/kmsg 命令查看这些log信息 CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11))); // 如果是ud版本则继续创建kmsg_debug设备文件 // WORLD_WRITABLE_KMSG = 1 则是ud,为0即user if constexpr (WORLD_WRITABLE_KMSG) &#123; CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11))); &#125; // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数 // 随机数在计算中很重要。 TCP/IP 序列号、密码盐和 DNS 源端口号都依赖于随机数。 // 在密码学中，随机性无处不在，从密钥的生成到加密系统，甚至密码系统受到攻击的方式。没有随机性，所有加密操作都是可预测的，因此不安全 CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8))); CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9))); // This is needed for log wrapper, which gets called before ueventd runs. // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。 CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2))); CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3))); 上面的代码比较简单，主要就是创建随机数设备文件，所以上层可以调用random获取随机数，随机数在计算中很重要，TCP&#x2F;IP 序列号、密码盐和 DNS 源端口号都依赖于随机数，也例如加密机制，都需要用到随机数。 同时也创建了&#x2F;dev&#x2F;null设备文件，dev&#x2F;null 在Linux中是一个空设备文件，它于其他普通的设备文件不同，当往null写入数据时会被丢弃掉，它不能够被执行，所以不能使用管道符去操作它，只能通过文件重定向（&gt;,&gt;&gt;），我们可以通过把命令的输出重定向到 &#x2F;dev&#x2F;null 来丢弃脚本的全部输出 也创建了&#x2F;dev&#x2F;kmsg设备文件，主要存储日志，Shell终端可以通过dmesg &#x2F;dev&#x2F;kmsg 命令查看这些log信息 在介绍一下&#x2F;sys文件系统，sysfs（常驻于RAM中）是一个伪文件系统，不占有任何磁盘空间的虚拟文件系统 &#x2F;sys下存放的都是设备驱动，网络环境，偏硬件的文件1.&#x2F;sys&#x2F;firmware ： 固件 文件目录2.&#x2F;sys&#x2F;kernel : 内核文件目录3.&#x2F;sys&#x2F;module ： 内核驱动模块4.&#x2F;sys&#x2F;power ： 电源相关模块5.&#x2F;sys&#x2F;bus ： 驱动总线文件目录6.&#x2F;sys&#x2F;block ： 块设备目录（映射的&#x2F;sys&#x2F;devices目录）7.&#x2F;sys&#x2F;devices ： 设备目录（也有虚拟设备目录），例如：sys&#x2F;devices&#x2F;virtual&#x2F;block&#x2F;dm-288.&#x2F;sys&#x2F;fs&#x2F;selinux ： selinux机制，也就是处理selinux权限机制文件存放的位置，判断是否开启严格模式等 5. FirstStageMain(int argc, char** argv)—–&gt;setup 5步骤 // setup 5 // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载 // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理 // tmpfs之前说过了，是运作在RAM的文件系统 CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, &quot;mode=0755,uid=0,gid=1000&quot;)); CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755)); CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755)); CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV, &quot;mode=0755,uid=0,gid=0&quot;)); // 创建selinux驱动节点，类型属于：tmpfs CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744)); // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的 SetStdioToDevNull(argv); InitKernelLogging(argv); // log可以使用了，第一阶段正式开始 创建设备 LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;; 这里的代码也比较简单，主要创建比较重要的分区，注意这里只是创建并没有挂载，&#x2F;mnt&#x2F;{vendor,product}，然后初始化kernel log,LOG日志可以正常使用和输出。 vendor： 用于存放odm供应商开发的文件，例如MTK自带节点 &#x2F;mnt&#x2F;vendor&#x2F;protect_f&#x2F; 可存储恢复出厂+刷机不丢失数据 product：根据不同的项目，存放项目中不同的内容，例如APK位置等 mnt ： 此目录主要是作为挂载点使用，例如挂载&#x2F;mnt&#x2F;sdcard 6. FirstStageMain(int argc, char** argv)—–&gt;setup 6步骤 // setup 6 // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统 auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;; // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量 // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成 if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123; PLOG(ERROR) &lt;&lt; &quot;Could not stat(\\&quot;/\\&quot;), not freeing ramdisk&quot;; old_root_dir.reset(); &#125; // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)， // 并加载kernel模块且处于非正常的启动模式，根据want_console来决定是否打开串口日志 if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console, want_parallel, module_count)) &#123; if (want_console != FirstStageConsoleParam::DISABLED) &#123; LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;; &#125; else &#123; LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;; &#125; &#125; // 继续根据是否打开串口日志来创建devices // want_console == 1 if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123; // 非恢复模式下进行，在 recovery 模式下不允许创建设备 if (!IsRecoveryMode()) &#123; // 在创建逻辑分区之前挂载 /metadata // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问 // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区 created_devices = DoCreateDevices();// 1 if (!created_devices) &#123; LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;; &#125; &#125; StartConsole(cmdline); &#125; 这里的代码主要是打开串口log（可选），在手机无法开机的情况下会抓串口log来分析问题。这里挂载了&#x2F;metadata,metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问，在文章开头也提到过metadata分区，这里会挂载和创建metadata里的设备文件，感兴趣的可以进一步去了解，挂载&#x2F;metadata的前提条件是必须有根目录“&#x2F;” 或 &#x2F;system，否则，切换根目录后无法访问ramdisk（后续会把old ramdisk切换到new ramdisk,切换后的新根目录会还原默认权限） 7. FirstStageMain(int argc, char** argv)—–&gt;setup 7步骤 // setup 7 // 判断文件是否存在，并判断文件是否可写:/system/etc/ramdisk/build.prop // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下 if (access(kBootImageRamdiskProp, F_OK) == 0) &#123; // 获取/second_stage_resources/system/etc/ramdisk/build.prop // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建 std::string dest = GetRamdiskPropForSecondStage(); // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk std::string dir = android::base::Dirname(dest); std::error_code ec; // 创建/second_stage_resources/system/etc/ramdisk目录 if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123; LOG(FATAL) &lt;&lt; &quot;Can&#39;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message(); &#125; // 拷贝 /system/etc/ramdisk/build.prop文件到 /second_stage_resources/system/etc/ramdisk // 生成 /second_stage_resources/system/etc/ramdisk/build.prop if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123; LOG(FATAL) &lt;&lt; &quot;Can&#39;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot; &lt;&lt; ec.message(); &#125; LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest; &#125; // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root // /userdebug_plat_sepolicy.cil属于selinux策略里的规则 // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限 if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123; constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;; constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;; ... setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1); &#125; setup7的代码片段主要讲解了获取ramdis下的prop属性值，为了第二阶段做准备，一句话来说就是创建了second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk目录文件，然后把&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop复制到上面的目录下，得到：&#x2F;second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop。针对已经unlock了的设备加载特定的selinux规则，以放大权限，使得只读分区可以写入数据 8. FirstStageMain(int argc, char** argv)—–&gt;setup 8步骤 // setup 8 // 如果是正常启动模式则创建 /first_stage_ramdisk目录作为根目录，把之前的根目录切换掉 // 因为之前都是基于根目录创建文件系统，放大了权限，将old根目录切换到first_stage_ramdisk后 // 将会在first_stage_ramdisk根目录把权限恢复到默认，例如old根目录部分文件系统是777权限，切换到first_stage_ramdisk根目录后 // 权限会放低，会给一个安全的权限，判断是否是正常启动可以通过该属性值判断：androidboot.force_normal_boot if (ForceNormalBoot(cmdline, bootconfig)) &#123; // 创建第一阶段ramdisk目录 /first_stage_ramdisk mkdir(&quot;/first_stage_ramdisk&quot;, 0755); // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;; PrepareSwitchRoot(); // 挂载/first_stage_ramdisk目录 if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123; PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;; &#125; // 将根目录（/）切换为 (/first_stage_ramdisk) // 将根切换到 first_stage_ramdisk SwitchRoot(&quot;/first_stage_ramdisk&quot;); &#125; // 挂载 system、vendor 、product等系统分区，1 if (!DoFirstStageMount(!created_devices)) &#123; LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;; &#125; // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等 struct stat new_root_info; if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123; PLOG(ERROR) &lt;&lt; &quot;Could not stat(\\&quot;/\\&quot;), not freeing ramdisk&quot;; old_root_dir.reset(); &#125; // 如果新的根目录已经创建，则释放old ramdisk，用new ramdisk if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123; FreeRamdisk(old_root_dir.get(), old_root_info.st_dev); &#125; 如果是正常启动模式则创建 &#x2F;first_stage_ramdisk目录作为根目录，把之前的根目录切换掉，因为之前都是基于根目录创建文件系统，放大了权限，将old根目录切换到first_stage_ramdisk后，将会把first_stage_ramdisk根目录把权限恢复到默认（相对较低的权限），假设old根目录部分文件系统是777权限，切换到/first_stage_ramdisk根目录后，权限会放低（0755），会给一个安全的权限，如果文件权限给太高，是非常危险的，此后会将system、vendor 、product等系统分区挂载到新根目录上。 必须执行的一步：如果新的根目录已经创建，则释放old ramdisk，用new ramdisk，再将system、vendor 、product等系统分区挂载到&#x2F;first_stage_ramdisk上 这里再跟一下DoFirstStageMount函数 8.1 DoFirstStageMount该方法位于&#x2F;system&#x2F;core&#x2F;init&#x2F;first_stage_mount.cpp#DoFirstStageMount // 装载设备树中fstab指定的分区 bool DoFirstStageMount(bool create_devices) &#123; // 如果处于恢复模式，则跳过第一阶段装载 if (IsRecoveryMode()) &#123; LOG(INFO) &lt;&lt; &quot;First stage mount skipped (recovery mode)&quot;; return true; &#125; auto fsm = FirstStageMount::Create();// 1 if (!fsm.ok()) &#123; LOG(ERROR) &lt;&lt; &quot;Failed to create FirstStageMount &quot; &lt;&lt; fsm.error(); return false; &#125; if (create_devices) &#123; if (!(*fsm)-&gt;DoCreateDevices()) return false;// 2 &#125; return (*fsm)-&gt;DoFirstStageMount(); &#125; 先看第一点 auto fsm = FirstStageMount::Create();，该方法主要用于AVB校验，AVB校验可以去看看google文档 Result&lt;std::unique_ptr&lt;FirstStageMount&gt;&gt; FirstStageMount::Create() &#123; // 读取fstab,file system table,里面包含了要挂载的逻辑分区 auto fstab = ReadFirstStageFstab(); if (!fstab.ok()) &#123; return fstab.error(); &#125; // 判断device tree（fstabl）中是否有vbmeta/compatible结构，值是android,vbmeta // 创建FirstStageMountVBootV1或者FirstStageMountVBootV2实例，取决于 // IsDtVbmetaCompatible(fstab)的返回值，如果支持vbmeta，则使用FirstStageMountVBootV2,反之FirstStageMountVBootV1 if (IsDtVbmetaCompatible(*fstab)) &#123; return std::make_unique&lt;FirstStageMountVBootV2&gt;(std::move(*fstab)); &#125; else &#123; return std::make_unique&lt;FirstStageMountVBootV1&gt;(std::move(*fstab)); &#125; &#125; 以上主要是创建V1或者V2版本的AVB校验，AVB校验主要是针对分区进行校验，对于要启动的 Android 版本中包含的所有可执行代码和数据，启动时验证均要求在使用前以加密形式对其进行验证。包括内核（从 boot 分区加载）、设备树（从 dtbo 分区加载）、system 分区和 vendor 分区等 对于 boot 和 dtbo 这类仅读取一次的小分区，通常是通过将整个内容加载到内存中，然后计算其哈希值来进行验证 内存装不下的较大分区（如文件系统）可能会使用哈希树； 如果在某个时刻计算出的根哈希值与预期根哈希值不一致，系统便不会使用相应数据，无法启动Android 在工作上遇到过开发者模式下OEM无法打开的情况，跟代码才发现开启OEM时会把persist分区文件里的指定位置上写入值（忘记值是多少了），通过解析该分区文件，写入的数据会以十六进制保持到指定位置上。但是瞬间就会把OEM的开关站位信息给擦除了，通过log看该分区文件是启用了RPMB分区安全保护机制 我们继续看第二点if (!(*fsm)-&gt;DoCreateDevices()) return false; bool FirstStageMount::DoFirstStageMount() &#123; // 如果fstab(设备树)为空则不执行挂载动作 // Fstab是内核在启动时用来挂载文件系统的文件系统表 if (!IsDmLinearEnabled() &amp;&amp; fstab_.empty()) &#123; // Nothing to mount. LOG(INFO) &lt;&lt; &quot;First stage mount skipped (missing/incompatible/empty fstab in device tree)&quot;; return true; &#125; // 挂载分区详细步骤 if (!MountPartitions()) return false; return true; &#125; 详细逻辑都在MountPartitions里面，继续跟着看看，该内容比较长 bool FirstStageMount::MountPartitions() &#123; // 将system分区挂载到设备的“/”根目录 if (!TrySwitchSystemAsRoot()) return false; if (!SkipMountingPartitions(&amp;fstab_, true /* verbose */)) return false; // 读取fstab（设备树，product,vendor等逻辑分区），并把其中的逻辑分区进行挂载 for (auto current = fstab_.begin(); current != fstab_.end();) &#123; // 跳过/system,因为已经挂载上了 if (current-&gt;mount_point == &quot;/system&quot;) &#123; ++current; continue; &#125; // 跳过overlay，稍后后挂载它，OverlayFS是新引入的机制，感兴趣的自行了解 // 当我们adb remount分区时，本来是可以直接把vendor改rw权限，但是引入overlayfs后仍然时只读权限 // 因为分为了2层，能读写的始终在第一层，第二层仍然保留了原始的权限，保留其原子性 if (current-&gt;fs_type == &quot;overlay&quot;) &#123; ++current; continue; &#125; // flash相关，不太清楚 if (current-&gt;fs_type == &quot;emmc&quot;) &#123; ++current; continue; &#125; // 挂载fstab里的所有逻辑分区（例如：system，system_ext,vendor,product） Fstab::iterator end; if (!MountPartition(current, false /* erase_same_mounts */, &amp;end)) &#123; if (current-&gt;fs_mgr_flags.no_fail) &#123; LOG(INFO) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point &lt;&lt; &quot;, ignoring mount for no_fail partition&quot;; &#125; else if (current-&gt;fs_mgr_flags.formattable) &#123; LOG(INFO) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point &lt;&lt; &quot;, ignoring mount for formattable partition&quot;; &#125; else &#123; PLOG(ERROR) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point; return false; &#125; &#125; current = end; &#125; ... // 如果在fstab中没有看到/system或/，那么我们需要为overlayfs创建一个根目录/system或“/” if (!GetEntryForMountPoint(&amp;fstab_, &quot;/system&quot;) &amp;&amp; !GetEntryForMountPoint(&amp;fstab_, &quot;/&quot;)) &#123; FstabEntry root_entry; if (GetRootEntry(&amp;root_entry)) &#123; fstab_.emplace_back(std::move(root_entry)); &#125; &#125; // 为overlayfs实例化设备文件,将vendor,product,data分区等实例化到该设备文件中 // 例如/dev/block/dm-33设备文件上挂载的是/data，此时会有dm-verity来验证数据，比如root后更改了设备文件，那校验则会不通过，造成无法开机 // dm-verity 是一个虚拟块设备，专门用于文件系统的校验，fs直接交互的设备是dm-verity，dm-verity调用真正的块驱动去读取对应的块（dm-verity读取dm-xxx） // /dev/block/dm-3 94M 94M 300K 100% /vendor // /dev/block/dm-2 1.5G 1.5G 4.8M 100% /product // /dev/block/dm-1 166M 165M 508K 100% /system_ext // /dev/block/dm-33 5.8G 609M 5.2G 11% /data auto init_devices = [this](std::set&lt;std::string&gt; devices) -&gt; bool &#123; for (auto iter = devices.begin(); iter != devices.end();) &#123; if (android::base::StartsWith(*iter, &quot;/dev/block/dm-&quot;)) &#123; if (!block_dev_init_.InitDmDevice(*iter)) &#123; return false; &#125; iter = devices.erase(iter); &#125; else &#123; iter++; &#125; &#125; return InitRequiredDevices(std::move(devices)); &#125;; MapScratchPartitionIfNeeded(&amp;fstab_, init_devices); // 再次挂载fstab_里面的全部逻辑分区，也就是overlayfs机制（adb remount也是靠这个机制实现的） // 再次声明将只读分区修改为可读写后，写入修改后的分区内容会保存到upperdir上，而不是直接修改其底层分区数据 // 以保证overlayfs文件操作原子性，这里再次挂载了fstab里的所有逻辑分区，那岂不是重复了？其实这里再次挂载只是一个merged（合并）操作 fs_mgr_overlayfs_mount_all(&amp;fstab_); return true; &#125; 以上主要挂载了fstab(设备树)下的所有逻辑分区并实例化到对应的&#x2F;dev&#x2F;block&#x2F;dm-xx设备文件上，例如挂载了：system,system_ext,vendor,product，还有挂载了overlay，overlay机制是用于保护分区原子性和分区安全而存在，具体可以自行了解一下，注释里也解释了一些，代码里两次挂载了fstab下的逻辑分区，第二次挂载是因为overlay机制的影响，是为了合并两个名称相同的分区，这里上一张图片来观察分区挂载的设备文件和位置可以观察到vendor.img镜像被挂载到了&#x2F;vendor分区上，使用的设备文件是/dev/block/dm-3 9. FirstStageMain(int argc, char** argv)—–&gt;setup 9&#x2F;10步骤 // setup 9 //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。 // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root，则会被dm-verity检测到）, // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：boot![]()loader，boot.img，system.img。 // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过 SetInitAvbVersionInRecovery(); // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了 // init程序的二进制文件目录 const char* path = &quot;/system/bin/init&quot;; const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区 // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp execv(path, const_cast&lt;char**&gt;(args)); SetInitAvbVersionInRecovery里的步骤也是读取fstab，然后根据IsDtVbmetaCompatible是否支持AVB2.0,来进行处理，setup 10就是进入下一个阶段了（SetupSelinux） 三. FirstStageMain阶段总结以上所有的代码和步骤：根据main.cpp来启用第一阶段FirstStageMain，挂载最基本的文件系统，该文件系统是运行于RAM上的，优点是相比disk磁盘来说运行速度快，不占存储空间，特点是易失性，断电即丢失，挂载上最基本的文件系统后会根据根目录”&#x2F;“来挂载&#x2F;mnt&#x2F;{vendor,product}等重要的分区，其他不重要的文件挂载在第二阶段rc中处理，生成 &#x2F;second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop,该文件会在第二阶段使用，在第一阶段并开启kernel log，挂载&#x2F;first_stage_ramdisk新的根目录，根据设备树（fstab）来创建逻辑分区system，system_ext,vendor,product并挂载到&#x2F;first_stage_ramdisk根目录上，然后将old 根目录切换到&#x2F;first_stage_ramdisk 根目录，释放old根目录，&#x2F;first_stage_ramdisk根目录将赋予较为安全的权限，创建AVB数据校验，启用overlayfs机制来保护分区原子性，初始化恢复模式下的AVB校验方案，然后调用&quot;/system/bin/init&quot;进入下一个阶段：selinux_setup","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/Framework源码分析/Android 13/1.android13启动流程之SeLinux权限介绍/","text":"本章讲解的方向和你将收获的知识： 什么是SeLinux系统，SeLinux的简介和介绍 SeLinux系统的主要作用和存在的意义，是基于哪个版本开始推行该方案的 如果遇到了SeLinux权限问题该如何解决，有几种解决方案 SeLinux详细内容知识分解，你将了解宽松模式和严格模式 一. SeLinux介绍 SeLinux 全称 Security-Enhanced Linux 即安全增强型 Linux，基于MAC机制的一种实现，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统，这不是android特有的特性，而是由Linux衍生过来的SEAndroid。 在Android Q版本上就开始推行SeLinux机制且强行执行此机制（沙盒机制，只能获取到AOSP指定的对外的接口去获取），所以在之前很多应用在Android Q上会产生很多权限相关的问题。 如果在Android Q或以上的版本遇到权限问题，尝试命令：adb shell logcat | grep avc，如果有对应的avc log输出则大概率是受SeLinux权限影响 avc: denied { read } for pid&#x3D;1834 comm&#x3D;“gps_location” name&#x3D;“mmcblk0p17” dev&#x3D;“tmpfs”scontext&#x3D;u:r:gps_location:s0 tcontext&#x3D;u:object_r:block_device:s0 tclass&#x3D;blk_file permissive&#x3D;0 SeLinux关键字介绍MAC和DAC都隶属于访问控制类，分为自主和强制两种方式 4.1 访问控制Linux 内核资源访问控制分为 DAC（Discretionary Access Control，自主访问控制）和 MAC（MandatoryAccess Control，强制访问控制)两类4.2 DAC这是基于用户-用户组的读、写、执行的权限检查，该管理过于宽松，如果获得 root 权限，可以在 Linux 系统内做任何事情4.3 MACSELinux是 MAC 机制的一种实现，基于安全上下文和安全策略的安全机制，用于补充 DAC 检查。访问系统资源时，会先进行 DAC 检查，DAC 检查通过，才能进行 MAC 检查，如果 MAC 检查通过，才能获得访问权限 二. SeLinux基础知识 SELinux 分为 Permissive 和 Enforcing 两种模式 Permissive 宽容模式宽容模式，代表 SELinux 运作中，违反 SELinux 规则时只会有警告讯息（avc denied），而不会实际限制的访问.在 Permissive 模式中，SELinux 被启用，但安全策略规则并没有被强制执行。当安全策略规则应该拒绝访问时，访问仍然被允许。然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝（avc）. Enforcing 严格模式在 Enforcing 模式中， SELinux 被启动，并强制执行所有的安全策略规则，代表 SELinux 运作中，违反 SELinux 规则的行为将被阻止并记录到日志中(avc) 查看当前SELinux模式（1）通过adb命令行来查看：adb shell getenforce，输出结果—&gt;Enforcing 或者 Permissive（2）通过adb logcat命令行来观察：adb logcat | grep avc avc:denied {write setter} for path&#x3D;”&#x2F;dev&#x2F;…” dev&#x3D;”tmpfs”scontext&#x3D;u:r:system_server:s0 tcontext&#x3D;u:object_r:file:s0 permissive&#x3D;1(permissive&#x3D;1，说明是 Permissive 模式。permissive&#x3D;0，说明是 Enforcing 模式) avc权限语法介绍 avc: denied { read } for pid&#x3D;1834 comm&#x3D;“system_server” name&#x3D;“mmcblk0p17” dev&#x3D;“tmpfs” ino&#x3D;10268 [scontext&#x3D;u:r:system_server:s0] [tcontext&#x3D;u:object_r:block_device:s0] tclass&#x3D;blk_file permissive&#x3D;0 （此 AVC log 说明 system_server（进程）缺少对标签为 block_device、类型为 blk_file 和名称为 mmcblk0p17 文件的 read 权限）(1). avc: denied：表示当前操作被拒绝。(2). { read }：表示被拒绝的操作，{ }中含有实际尝试的操作。(3). for pid&#x3D;1834：当前发生 avc: denied 进程的 ID。(4). comm&#x3D;“system_server”：当前发生 avc: denied 进程的名称，即主体进程名称。(5). name&#x3D;“mmcblk0p17”：操作尝试的目标文件或目录的路径，即客体资源名称。(6). dev&#x3D;“tmpfs”：含有这个文件系统的设备节点，客体资源在该文件系统中。(7). ino&#x3D;10268：目标文件或目录的节点号。(8). scontext&#x3D;u:r:system_server:s0：主体进程的安全上下文。(9). tcontext&#x3D;u:object_r:block_device:s0：客体资源的安全上下文。(10). tclass&#x3D;blk_file：访问资源所属类别。(11). permissive&#x3D;0：当前是 Enforcing 模式，permissive&#x3D;1 时为 Permissive 模式 三. 解决SeLinux权限问题1.命令行修改权限模式 12adb root; adb shell setenforce 0 ---&gt;设置为Permissive宽松模式，临时关闭SELinux，机器重启以后还是会恢复的 2.AndroidManifest.xml配置开关需要注意targetSdkVersion 需要小于 30 12//用于控制应用在Android 10及更高版本上的外部存储行为android:requestLegacyExternalStorage=&quot;true&quot; 3.修改init启动过程中的代码这种方式比较简单—&gt;修改 system&#x2F;core&#x2F;init&#x2F;selinux.cpp 文件里的 IsEnforcing()函数,直接让它返回false即可 1234567891011121314151617181920212223242526bool IsEnforcing() &#123; // 直接返回false return false; if (ALLOW_PERMISSIVE_SELINUX) &#123; return StatusFromProperty() == SELINUX_ENFORCING; &#125; return true;&#125;void SelinuxSetEnforcement() &#123; // getenforce获取Enforcing模式 bool kernel_enforcing = (security_getenforce() == 1); // 直接让is_enforcing返回false即关闭严格模式 bool is_enforcing = IsEnforcing(); if (kernel_enforcing != is_enforcing) &#123; // 调用security_setenforce(false)设置为Permissive宽容模式 if (security_setenforce(is_enforcing)) &#123; PLOG(FATAL) &lt;&lt; &quot;security_setenforce(&quot; &lt;&lt; (is_enforcing ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; &quot;) failed&quot;; &#125; &#125; if (auto result = WriteFile(&quot;/sys/fs/selinux/checkreqprot&quot;, &quot;0&quot;); !result.ok()) &#123; LOG(FATAL) &lt;&lt; &quot;Unable to write to /sys/fs/selinux/checkreqprot: &quot; &lt;&lt; result.error(); &#125;&#125; 4.根据报错的权限添加SELinux权限由于缺少 SELinux 权限导致如下“avc: denied”，需要根据 AVC log 信息添加相应权限。 123avc: denied &#123; read write &#125; for pid=3483 comm=“batteryTest” name=“rtc0” dev=“tmpfs” scontext=u:r:system_server:s0 tcontext=u:object_r:custom_battery_device:s0 tclass=chr_file permissive=0 system_server（进程）缺少对标签为 custom_battery_device、类型为 chr_file 和名称为 rtc0 文件节点的读写权限。根据上面缺少的avc添加所需的读写权限：(1). 打开&#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;{scontext.te}(system_server.te)文件(2). 添加如下代码：和上面的标签对应上：&#123;allow scontext tcontext:tclass permission &#125;(3). 例如allow system_server custom_battery_device:chr_file &#123;read write&#125; ,编译源码并进行烧录即可 四. Neverallow问题1234567891011添加了selinux权限后，代码进行编译时，编译失败并报 neverallow 错误，例如添加`allow system_app sysfs:file &#123;write&#125;;`权限后 编译报错原因是 Google 不允许应用进程写 sysfs 类型的文件，这是Google规范，安全考虑，部分权限不允许给，当然也可以修改domain.te来修改Google的规范，虽然可以解决问题，但是这是不被允许的，在送测的时候会导致GMS测试失败。例如domain.te拥有以下代码：neverallow &#123; appdomain -bluetooth -nfc &#125;sysfs:dir_file_class_set write那么则不允许给dir_file_class_set标签赋予write权限。那又必须要这个权限怎么办？那就可以客制化SELiunx权限。 五. SELinux权限客制化（自定义权限）根据上面所说，Google规则需遵守，部分权限不允许通过，所以需要自定义权限规则. type定义type分为了property.te、file.te、system.te，有很多类型，不止这三种，使用哪个文件取决于avc权限中的tclass属性，目前只用file.te举例，打开file.te添加如下type 12345/system/sepolicy/private/file.te# &#123;parameter1，parameter2，parameter3&#125;# type固定格式，custom_battery_file自定义的名称，file_type定义为文件类型# 逗号分割，后面可以继续跟类型 例如：data_file_typetype custom_battery_file, file_type; 配置安全上下文安全上下文分为了 genfs_contexts、file_contexts、property_contexts ，当然不止这几种，例举了一些常用的打开 &#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;file_contexts 文件，打开哪个文件取决于avc权限中的tclass属性（三个xxx_contexts，需要自行判断缺少的权限的客体资源是目录还是文件 或是 属性值）： 12345/system/sepolicy/private/file_contexts# 添加如下代码# 第一个参数写文件节点（读取这个文件节点没权限，就添加这个节点）# 第二个参数固定写法u:object_r:custom_battery_file（这里写file.te里定义的类型）:s0（这些参数不做详细解释）/vendor/custom/product/battery u:object_r:custom_battery_file:s0 &#x2F;xxx&#x2F;xxx (目标文件路径或文件) u:object_r:file.te里面自定义的名称:s0 配置原进程访问权限根据avc log中的scontext（主体进程）的值来决定在哪个文件下添加访问权限例如 scontext=u:r:system_server:s0，那则打开system_server.te即可 /system/sepolicy/private/system_server.te # 1.allow固定格式 # 2.system_server固定格式取决于scontext的值 # 3.custom_battery_file（file.te里自定义的类型） # 4.冒号后面的file，取决于avc log中的tclass类型是什么（例如tclass=file） # 5.&#123;要给的权限类型&#125; allow system_server custom_battery_file:file &#123;read open&#125;; 这样就客制化好了一个节点的写权限 六. 补充知识（mls规则）终端中查看安全上下文的方法在终端中，可通过如下指令查看文件安全上下文：ls -lZ在终端中，可通过如下指令查看属性安全上下文：getprop -Z在终端中，可通过如下指令查看进程安全上下文：ps -Z 如果 te 文件已经添加 SELinux 权限，但没有生效，查看 AVC log 信息出现“s0:c512,c768”字眼，则可判断是由于 mls 规则导致。说明主体和客体安全级别不同，举例：已经在 platform_app.te 中添加了 SELinux 权限，但 log 中依然有如下报错：avc: denied { write } for pid&#x3D;2002 comm&#x3D;“lightness”scontext&#x3D;u:r:platform_app:s0(主体):c512,c768 tcontext&#x3D;u:r:custom_device_lightness:s0(客体资源) tclass&#x3D;char_file(file类型，读取的文件节点属于file类型) permissive&#x3D;0 主体： scontext&#x3D;u:r:【platform_app】客体： tcontext&#x3D;u:r:【custom_device_lightness】这是因为 Google 在文件 system&#x2F;sepolicy&#x2F;private&#x2F;mls 中进行了安全级的限制，代码如下：【mlsconstrain cahr_file &#123; write &#125; (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);】l1需要l2相等，或者l1等于mlstrustedsubject l2等于mlstrustedsubject ，才能允许SELiunx权限。 这种情况需要主体进程或者客体进程中的一个是 mlstrustedsubject，这里 platform_app（主体） 最好不要修改，所以要修改客体 slogmodem（客体）。 具体修改方法如下： /system/sepolicy/private/platform_app.te(取决于主体进程)文件 添加如下代码： type custom_device_lightness, domain, mlstrustedsubject; 七. 代码修改后烧录1.如果只是修改 selinux 相关文件–通过编译命令：（1）lunch 项目（2）cd system&#x2F;sepolicy（3）mma将编译产物 out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;system&#x2F;etc&#x2F;selinux 和 out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;vendor&#x2F;etc&#x2F;selinux 拷贝出来，推入手机查看是否生效，执行指令如下：（1）cd out&#x2F;target&#x2F;product&#x2F;xxx（2）adb root（3）adb remount（4）adb push system&#x2F;etc&#x2F;selinux &#x2F;system&#x2F;etc&#x2F;（5）adb push vendor&#x2F;etc&#x2F;selinux &#x2F;vendor&#x2F;etc&#x2F;如果手机不能root &amp;&amp; remount，可以考虑通过编译烧录的方式去验证 总结 至此SELinux权限系统基本上介绍完毕，如何解决权限问题，如何关闭权限和切换权限，自定义权限，配置权限，皆已教学完毕。不为别的，为了留下工作上的脚印","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"}]},{"path":"wiki/Android FrameWork/rc文件语法规则/","text":"解析init.rc脚本Android Init Languagerc文件，是用Android Init Language编写的特殊文件。用这种语法编写的文件，统一用”.rc”后缀 它的语法说明可以在aosp源码system/core/init/README.md中找到: system&#x2F;core&#x2F;init&#x2F;README.md原文： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050Android Init Language---------------------The Android Init Language consists of five broad classes of statements:Actions, Commands, Services, Options, and Imports.All of these are line-oriented, consisting of tokens separated bywhitespace. The c-style backslash escapes may be used to insertwhitespace into a token. Double quotes may also be used to preventwhitespace from breaking text into multiple tokens. The backslash,when it is the last character on a line, may be used for line-folding.Lines which start with a `#` (leading whitespace allowed) are comments.System properties can be expanded using the syntax`$&#123;property.name&#125;`. This also works in contexts where concatenation isrequired, such as `import /init.recovery.$&#123;ro.hardware&#125;.rc`.Actions and Services implicitly declare a new section. All commandsor options belong to the section most recently declared. Commandsor options before the first section are ignored.Services have unique names. If a second Service is definedwith the same name as an existing one, it is ignored and an errormessage is logged.Init .rc Files--------------The init language is used in plain text files that take the .rc fileextension. There are typically multiple of these in multiplelocations on the system, described below.`/system/etc/init/hw/init.rc` is the primary .rc file and is loaded by the init executable at thebeginning of its execution. It is responsible for the initial set up of the system.Init loads all of the files contained within the`/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/` directories immediately after loadingthe primary `/system/etc/init/hw/init.rc`. This is explained in more details in the[Imports](#imports) section of this file.Legacy devices without the first stage mount mechanism previously wereable to import init scripts during mount_all, however that is deprecatedand not allowed for devices launching after Q.The intention of these directories is: 1. /system/etc/init/ is for core system items such as SurfaceFlinger, MediaService, and logd. 2. /vendor/etc/init/ is for SoC vendor items such as actions or daemons needed for core SoC functionality. 3. /odm/etc/init/ is for device manufacturer items such as actions or daemons needed for motion sensor or other peripheral functionality.All services whose binaries reside on the system, vendor, or odmpartitions should have their service entries placed into acorresponding init .rc file, located in the /etc/init/directory of the partition where they reside. There is a buildsystem macro, LOCAL\\_INIT\\_RC, that handles this for developers. Eachinit .rc file should additionally contain any actions associated withits service.An example is the userdebug logcatd.rc and Android.mk files located in thesystem/core/logcat directory. The LOCAL\\_INIT\\_RC macro in theAndroid.mk file places logcatd.rc in /system/etc/init/ during thebuild process. Init loads logcatd.rc during the mount\\_all command andallows the service to be run and the action to be queued whenappropriate.This break up of init .rc files according to their daemon is preferredto the previously used monolithic init .rc files. This approachensures that the only service entries that init reads and the onlyactions that init performs correspond to services whose binaries are infact present on the file system, which was not the case with themonolithic init .rc files. This additionally will aid in mergeconflict resolution when multiple services are added to the system, aseach one will go into a separate file.Versioned RC files within APEXs-------------------------------With the arrival of mainline on Android Q, the individual mainlinemodules carry their own init.rc files within their boundaries. Initprocesses these files according to the naming pattern `/apex/*/etc/*rc`.Because APEX modules must run on more than one release of Android,they may require different parameters as part of the services theydefine. This is achieved, starting in Android T, by incorporatingthe SDK version information in the name of the init file. The suffixis changed from `.rc` to `.#rc` where # is the first SDK where thatRC file is accepted. An init file specific to SDK=31 might be named`init.31rc`. With this scheme, an APEX may include multiple init files. Anexample is appropriate.For an APEX module with the following files in /apex/sample-module/apex/etc/: 1. init.rc 2. init.32rc 4. init.35rcThe selection rule chooses the highest `.#rc` value that does notexceed the SDK of the currently running system. The unadorned `.rc`is interpreted as sdk=0.When this APEX is installed on a device with SDK &lt;=31, the system willprocess init.rc. When installed on a device running SDK 32, 33, or 34,it will use init.32rc. When installed on a device running SDKs &gt;= 35,it will choose init.35rcThis versioning scheme is used only for the init files within APEXmodules; it does not apply to the init files stored in /system/etc/init,/vendor/etc/init, or other directories.This naming scheme is available after Android S.Actions-------Actions are named sequences of commands. Actions have a trigger whichis used to determine when the action is executed. When an eventoccurs which matches an action&#x27;s trigger, that action is added tothe tail of a to-be-executed queue (unless it is already on thequeue).Each action in the queue is dequeued in sequence and each command inthat action is executed in sequence. Init handles other activities(device creation/destruction, property setting, process restarting)&quot;between&quot; the execution of the commands in activities.Actions take the form of: on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* &lt;command&gt; &lt;command&gt; &lt;command&gt;Actions are added to the queue and executed based on the order thatthe file that contains them was parsed (see the Imports section), thensequentially within an individual file.For example if a file contains: on boot setprop a 1 setprop b 2 on boot &amp;&amp; property:true=true setprop c 1 setprop d 2 on boot setprop e 1 setprop f 2Then when the `boot` trigger occurs and assuming the property `true`equals `true`, then the order of the commands executed will be: setprop a 1 setprop b 2 setprop c 1 setprop d 2 setprop e 1 setprop f 2Services--------Services are programs which init launches and (optionally) restartswhen they exit. Services take the form of: service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ...Options-------Options are modifiers to services. They affect how and when initruns the service.`capabilities [ &lt;capability&gt;\\* ]`&gt; Set capabilities when exec&#x27;ing this service. &#x27;capability&#x27; should be a Linux capability without the &quot;CAP\\_&quot; prefix, like &quot;NET\\_ADMIN&quot; or &quot;SETPCAP&quot;. See http://man7.org/linux/man-pages/man7/capabilities.7.html for a list of Linux capabilities. If no capabilities are provided, then all capabilities are removed from this service, even if it runs as root.`class &lt;name&gt; [ &lt;name&gt;\\* ]`&gt; Specify class names for the service. All services in a named class may be started or stopped together. A service is in the class &quot;default&quot; if one is not specified via the class option. Additional classnames beyond the (required) first one are used to group services. The `animation` class should include all services necessary for both boot animation and shutdown animation. As these services can be launched very early during bootup and can run until the last stage of shutdown, access to /data partition is not guaranteed. These services can check files under /data but it should not keep files opened and should work when /data is not available.`console [&lt;console&gt;]`&gt; This service needs a console. The optional second parameter chooses a specific console instead of the default. The default &quot;/dev/console&quot; can be changed by setting the &quot;androidboot.console&quot; kernel parameter. In all cases the leading &quot;/dev/&quot; should be omitted, so &quot;/dev/tty0&quot; would be specified as just &quot;console tty0&quot;. This option connects stdin, stdout, and stderr to the console. It is mutually exclusive with the stdio_to_kmsg option, which only connects stdout and stderr to kmsg.`critical [window=&lt;fatal crash window mins&gt;] [target=&lt;fatal reboot target&gt;]`&gt; This is a device-critical service. If it exits more than four times in _fatal crash window mins_ minutes or before boot completes, the device will reboot into _fatal reboot target_. The default value of _fatal crash window mins_ is 4, and default value of _fatal reboot target_ is &#x27;bootloader&#x27;. For tests, the fatal reboot can be skipped by setting property `init.svc_debug.no_fatal.&lt;service-name&gt;` to `true` for specified critical service.`disabled`&gt; This service will not automatically start with its class. It must be explicitly started by name or by interface name.`enter_namespace &lt;type&gt; &lt;path&gt;`&gt; Enters the namespace of type _type_ located at _path_. Only network namespaces are supported with _type_ set to &quot;net&quot;. Note that only one namespace of a given _type_ may be entered.`file &lt;path&gt; &lt;type&gt;`&gt; Open a file path and pass its fd to the launched process. _type_ must be &quot;r&quot;, &quot;w&quot; or &quot;rw&quot;. For native executables see libcutils android\\_get\\_control\\_file().`group &lt;groupname&gt; [ &lt;groupname&gt;\\* ]`&gt; Change to &#x27;groupname&#x27; before exec&#x27;ing this service. Additional groupnames beyond the (required) first one are used to set the supplemental groups of the process (via setgroups()). Currently defaults to root. (??? probably should default to nobody)`interface &lt;interface name&gt; &lt;instance name&gt;`&gt; Associates this service with a list of the AIDL or HIDL services that it provides. The interface name must be a fully-qualified name and not a value name. For instance, this is used to allow servicemanager or hwservicemanager to lazily start services. When multiple interfaces are served, this tag should be used multiple times. An example of an entry for a HIDL interface is `interface vendor.foo.bar@1.0::IBaz default`. For an AIDL interface, use `interface aidl &lt;instance name&gt;`. The instance name for an AIDL interface is whatever is registered with servicemanager, and these can be listed with `adb shell dumpsys -l`.`ioprio &lt;class&gt; &lt;priority&gt;`&gt; Sets the IO priority and IO priority class for this service via the SYS_ioprio_set syscall. _class_ must be one of &quot;rt&quot;, &quot;be&quot;, or &quot;idle&quot;. _priority_ must be an integer in the range 0 - 7.`keycodes &lt;keycode&gt; [ &lt;keycode&gt;\\* ]`&gt; Sets the keycodes that will trigger this service. If all of the keys corresponding to the passed keycodes are pressed at once, the service will start. This is typically used to start the bugreport service.&gt; This option may take a property instead of a list of keycodes. In this case, only one option is provided: the property name in the typical property expansion format. The property must contain a comma separated list of keycode values or the text &#x27;none&#x27; to indicate that this service does not respond to keycodes.&gt; For example, `keycodes $&#123;some.property.name:-none&#125;` where some.property.name expands to &quot;123,124,125&quot;. Since keycodes are handled very early in init, only PRODUCT_DEFAULT_PROPERTY_OVERRIDES properties can be used.`memcg.limit_in_bytes &lt;value&gt;` and `memcg.limit_percent &lt;value&gt;`&gt; Sets the child&#x27;s memory.limit_in_bytes to the minimum of `limit_in_bytes` bytes and `limit_percent` which is interpreted as a percentage of the size of the device&#x27;s physical memory (only if memcg is mounted). Values must be equal or greater than 0.`memcg.limit_property &lt;value&gt;`&gt; Sets the child&#x27;s memory.limit_in_bytes to the value of the specified property (only if memcg is mounted). This property will override the values specified via `memcg.limit_in_bytes` and `memcg.limit_percent`.`memcg.soft_limit_in_bytes &lt;value&gt;`&gt; Sets the child&#x27;s memory.soft_limit_in_bytes to the specified value (only if memcg is mounted), which must be equal or greater than 0.`memcg.swappiness &lt;value&gt;`&gt; Sets the child&#x27;s memory.swappiness to the specified value (only if memcg is mounted), which must be equal or greater than 0.`namespace &lt;pid|mnt&gt;`&gt; Enter a new PID or mount namespace when forking the service.`oneshot`&gt; Do not restart the service when it exits.`onrestart`&gt; Execute a Command (see below) when service restarts.`oom_score_adjust &lt;value&gt;`&gt; Sets the child&#x27;s /proc/self/oom\\_score\\_adj to the specified value, which must range from -1000 to 1000.`override`&gt; Indicates that this service definition is meant to override a previous definition for a service with the same name. This is typically meant for services on /odm to override those defined on /vendor. The last service definition that init parses with this keyword is the service definition will use for this service. Pay close attention to the order in which init.rc files are parsed, since it has some peculiarities for backwards compatibility reasons. The &#x27;imports&#x27; section of this file has more details on the order.`priority &lt;priority&gt;`&gt; Scheduling priority of the service process. This value has to be in range -20 to 19. Default priority is 0. Priority is set via setpriority().`reboot_on_failure &lt;target&gt;`&gt; If this process cannot be started or if the process terminates with an exit code other than CLD_EXITED or an status other than &#x27;0&#x27;, reboot the system with the target specified in _target_. _target_ takes the same format as the parameter to sys.powerctl. This is particularly intended to be used with the `exec_start` builtin for any must-have checks during boot.`restart_period &lt;seconds&gt;`&gt; If a non-oneshot service exits, it will be restarted at its start time plus this period. It defaults to 5s to rate limit crashing services. This can be increased for services that are meant to run periodically. For example, it may be set to 3600 to indicate that the service should run every hour or 86400 to indicate that the service should run every day.`rlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;`&gt; This applies the given rlimit to the service. rlimits are inherited by child processes, so this effectively applies the given rlimit to the process tree started by this service. It is parsed similarly to the setrlimit command specified below.`seclabel &lt;seclabel&gt;`&gt; Change to &#x27;seclabel&#x27; before exec&#x27;ing this service. Primarily for use by services run from the rootfs, e.g. ueventd, adbd. Services on the system partition can instead use policy-defined transitions based on their file security context. If not specified and no transition is defined in policy, defaults to the init context.`setenv &lt;name&gt; &lt;value&gt;`&gt; Set the environment variable _name_ to _value_ in the launched process.`shutdown &lt;shutdown_behavior&gt;`&gt; Set shutdown behavior of the service process. When this is not specified, the service is killed during shutdown process by using SIGTERM and SIGKILL. The service with shutdown_behavior of &quot;critical&quot; is not killed during shutdown until shutdown times out. When shutdown times out, even services tagged with &quot;shutdown critical&quot; will be killed. When the service tagged with &quot;shutdown critical&quot; is not running when shut down starts, it will be started.`sigstop`&gt; Send SIGSTOP to the service immediately before exec is called. This is intended for debugging. See the below section on debugging for how this can be used.`socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]`&gt; Create a UNIX domain socket named /dev/socket/_name_ and pass its fd to the launched process. _type_ must be &quot;dgram&quot;, &quot;stream&quot; or &quot;seqpacket&quot;. _type_ may end with &quot;+passcred&quot; to enable SO_PASSCRED on the socket. User and group default to 0. &#x27;seclabel&#x27; is the SELinux security context for the socket. It defaults to the service security context, as specified by seclabel or computed based on the service executable file security context. For native executables see libcutils android\\_get\\_control\\_socket().`stdio_to_kmsg`&gt; Redirect stdout and stderr to /dev/kmsg_debug. This is useful for services that do not use native Android logging during early boot and whose logs messages we want to capture. This is only enabled when /dev/kmsg_debug is enabled, which is only enabled on userdebug and eng builds. This is mutually exclusive with the console option, which additionally connects stdin to the given console.`task_profiles &lt;profile&gt; [ &lt;profile&gt;\\* ]`&gt; Set task profiles for the process when it forks. This is designed to replace the use of writepid option for moving a process into a cgroup.`timeout_period &lt;seconds&gt;`&gt; Provide a timeout after which point the service will be killed. The oneshot keyword is respected here, so oneshot services do not automatically restart, however all other services will. This is particularly useful for creating a periodic service combined with the restart_period option described above.`updatable`&gt; Mark that the service can be overridden (via the &#x27;override&#x27; option) later in the boot sequence by APEXes. When a service with updatable option is started before APEXes are all activated, the execution is delayed until the activation is finished. A service that is not marked as updatable cannot be overridden by APEXes.`user &lt;username&gt;`&gt; Change to &#x27;username&#x27; before exec&#x27;ing this service. Currently defaults to root. (??? probably should default to nobody) As of Android M, processes should use this option even if they require Linux capabilities. Previously, to acquire Linux capabilities, a process would need to run as root, request the capabilities, then drop to its desired uid. There is a new mechanism through fs\\_config that allows device manufacturers to add Linux capabilities to specific binaries on a file system that should be used instead. This mechanism is described on &lt;http://source.android.com/devices/tech/config/filesystem.html&gt;. When using this new mechanism, processes can use the user option to select their desired uid without ever running as root. As of Android O, processes can also request capabilities directly in their .rc files. See the &quot;capabilities&quot; option below.`writepid &lt;file&gt; [ &lt;file&gt;\\* ]`&gt; Write the child&#x27;s pid to the given files when it forks. Meant for cgroup/cpuset usage. If no files under /dev/cpuset/ are specified, but the system property &#x27;ro.cpuset.default&#x27; is set to a non-empty cpuset name (e.g. &#x27;/foreground&#x27;), then the pid is written to file /dev/cpuset/_cpuset\\_name_/tasks. The use of this option for moving a process into a cgroup is obsolete. Please use task_profiles option instead.Triggers--------Triggers are strings which can be used to match certain kinds ofevents and used to cause an action to occur.Triggers are subdivided into event triggers and property triggers.Event triggers are strings triggered by the &#x27;trigger&#x27; command or bythe QueueEventTrigger() function within the init executable. Thesetake the form of a simple string such as &#x27;boot&#x27; or &#x27;late-init&#x27;.Property triggers are strings triggered when a named property changesvalue to a given new value or when a named property changes value toany new value. These take the form of &#x27;property:&lt;name&gt;=&lt;value&gt;&#x27; and&#x27;property:&lt;name&gt;=\\*&#x27; respectively. Property triggers are additionallyevaluated and triggered accordingly during the initial boot phase ofinit.An Action can have multiple property triggers but may only have oneevent trigger.For example:`on boot &amp;&amp; property:a=b` defines an action that is only executed whenthe &#x27;boot&#x27; event trigger happens and the property a equals b.`on property:a=b &amp;&amp; property:c=d` defines an action that is executedat three times: 1. During initial boot if property a=b and property c=d. 2. Any time that property a transitions to value b, while property c already equals d. 3. Any time that property c transitions to value d, while property a already equals b.Trigger Sequence----------------Init uses the following sequence of triggers during early boot. These are thebuilt-in triggers defined in init.cpp. 1. `early-init` - The first in the sequence, triggered after cgroups has been configured but before ueventd&#x27;s coldboot is complete. 2. `init` - Triggered after coldboot is complete. 3. `charger` - Triggered if `ro.bootmode == &quot;charger&quot;`. 4. `late-init` - Triggered if `ro.bootmode != &quot;charger&quot;`, or via healthd triggering a boot from charging mode.Remaining triggers are configured in `init.rc` and are not built-in. The default sequence forthese is specified under the &quot;on late-init&quot; event in `init.rc`. Actions internal to `init.rc`have been omitted. 1. `early-fs` - Start vold. 2. `fs` - Vold is up. Mount partitions not marked as first-stage or latemounted. 3. `post-fs` - Configure anything dependent on early mounts. 4. `late-fs` - Mount partitions marked as latemounted. 5. `post-fs-data` - Mount and configure `/data`; set up encryption. `/metadata` is reformatted here if it couldn&#x27;t mount in first-stage init. 6. `zygote-start` - Start the zygote. 7. `early-boot` - After zygote has started. 8. `boot` - After `early-boot` actions have completed.Commands--------`bootchart [start|stop]`&gt; Start/stop bootcharting. These are present in the default init.rc files, but bootcharting is only active if the file /data/bootchart/enabled exists; otherwise bootchart start/stop are no-ops.`chmod &lt;octal-mode&gt; &lt;path&gt;`&gt; Change file access permissions.`chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;`&gt; Change file owner and group.`class_start &lt;serviceclass&gt;`&gt; Start all services of the specified class if they are not already running. See the start entry for more information on starting services.`class_stop &lt;serviceclass&gt;`&gt; Stop and disable all services of the specified class if they are currently running.`class_reset &lt;serviceclass&gt;`&gt; Stop all services of the specified class if they are currently running, without disabling them. They can be restarted later using `class_start`.`class_restart [--only-enabled] &lt;serviceclass&gt;`&gt; Restarts all services of the specified class. If `--only-enabled` is specified, then disabled services are skipped.`copy &lt;src&gt; &lt;dst&gt;`&gt; Copies a file. Similar to write, but useful for binary/large amounts of data. Regarding to the src file, copying from symbolic link file and world-writable or group-writable files are not allowed. Regarding to the dst file, the default mode created is 0600 if it does not exist. And it will be truncated if dst file is a normal regular file and already exists.`copy_per_line &lt;src&gt; &lt;dst&gt;`&gt; Copies a file line by line. Similar to copy, but useful for dst is a sysfs node that doesn&#x27;t handle multiple lines of data.`domainname &lt;name&gt;`&gt; Set the domain name.`enable &lt;servicename&gt;`&gt; Turns a disabled service into an enabled one as if the service did not specify disabled. If the service is supposed to be running, it will be started now. Typically used when the bootloader sets a variable that indicates a specific service should be started when needed. E.g. on property:ro.boot.myfancyhardware=1 enable my_fancy_service_for_my_fancy_hardware`exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\\* ]`&gt; Fork and execute command with the given arguments. The command starts after &quot;--&quot; so that an optional security context, user, and supplementary groups can be provided. No other commands will be run until this one finishes. _seclabel_ can be a - to denote default. Properties are expanded within _argument_. Init halts executing commands until the forked process exits.`exec_background [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\\* ]`&gt; Fork and execute command with the given arguments. This is handled similarly to the `exec` command. The difference is that init does not halt executing commands until the process exits for `exec_background`.`exec_start &lt;service&gt;`&gt; Start a given service and halt the processing of additional init commands until it returns. The command functions similarly to the `exec` command, but uses an existing service definition in place of the exec argument vector.`export &lt;name&gt; &lt;value&gt;`&gt; Set the environment variable _name_ equal to _value_ in the global environment (which will be inherited by all processes started after this command is executed)`hostname &lt;name&gt;`&gt; Set the host name.`ifup &lt;interface&gt;`&gt; Bring the network interface _interface_ online.`insmod [-f] &lt;path&gt; [&lt;options&gt;]`&gt; Install the module at _path_ with the specified options. -f: force installation of the module even if the version of the running kernel and the version of the kernel for which the module was compiled do not match.`interface_start &lt;name&gt;` \\`interface_restart &lt;name&gt;` \\`interface_stop &lt;name&gt;`&gt; Find the service that provides the interface _name_ if it exists and run the `start`, `restart`,or `stop` commands on it respectively. _name_ may be either a fully qualified HIDL name, in whichcase it is specified as `&lt;interface&gt;/&lt;instance&gt;`, or an AIDL name, in which case it is specified as`aidl/&lt;interface&gt;` for example `android.hardware.secure_element@1.1::ISecureElement/eSE1` or`aidl/aidl_lazy_test_1`.&gt; Note that these commands only act on interfaces specified by the `interface` service option, noton interfaces registered at runtime.&gt; Example usage of these commands: \\`interface_start android.hardware.secure_element@1.1::ISecureElement/eSE1`will start the HIDL Service that provides the `android.hardware.secure_element@1.1` and `eSI1`instance. \\`interface_start aidl/aidl_lazy_test_1` will start the AIDL service thatprovides the `aidl_lazy_test_1` interface.`load_exports &lt;path&gt;`&gt; Open the file at _path_ and export global environment variables declared there. Each line must be in the format `export &lt;name&gt; &lt;value&gt;`, as described above.`load_system_props`&gt; (This action is deprecated and no-op.)`load_persist_props`&gt; Loads persistent properties when /data has been decrypted. This is included in the default init.rc.`loglevel &lt;level&gt;`&gt; Sets init&#x27;s log level to the integer level, from 7 (all logging) to 0 (fatal logging only). The numeric values correspond to the kernel log levels, but this command does not affect the kernel log level. Use the `write` command to write to `/proc/sys/kernel/printk` to change that. Properties are expanded within _level_.`mark_post_data`&gt; Used to mark the point right after /data is mounted.`mkdir &lt;path&gt; [&lt;mode&gt;] [&lt;owner&gt;] [&lt;group&gt;] [encryption=&lt;action&gt;] [key=&lt;key&gt;]`&gt; Create a directory at _path_, optionally with the given mode, owner, and group. If not provided, the directory is created with permissions 755 and owned by the root user and root group. If provided, the mode, owner and group will be updated if the directory exists already. &gt; _action_ can be one of: * `None`: take no encryption action; directory will be encrypted if parent is. * `Require`: encrypt directory, abort boot process if encryption fails * `Attempt`: try to set an encryption policy, but continue if it fails * `DeleteIfNecessary`: recursively delete directory if necessary to set encryption policy. &gt; _key_ can be one of: * `ref`: use the systemwide DE key * `per_boot_ref`: use the key freshly generated on each boot.`mount_all [ &lt;fstab&gt; ] [--&lt;option&gt;]`&gt; Calls fs\\_mgr\\_mount\\_all on the given fs\\_mgr-format fstab with optional options &quot;early&quot; and &quot;late&quot;. With &quot;--early&quot; set, the init executable will skip mounting entries with &quot;latemount&quot; flag and triggering fs encryption state event. With &quot;--late&quot; set, init executable will only mount entries with &quot;latemount&quot; flag. By default, no option is set, and mount\\_all will process all entries in the given fstab. If the fstab parameter is not specified, fstab.$&#123;ro.boot.fstab_suffix&#125;, fstab.$&#123;ro.hardware&#125; or fstab.$&#123;ro.hardware.platform&#125; will be scanned for under /odm/etc, /vendor/etc, or / at runtime, in that order.`mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt;\\* ] [&lt;options&gt;]`&gt; Attempt to mount the named device at the directory _dir_ _flag_s include &quot;ro&quot;, &quot;rw&quot;, &quot;remount&quot;, &quot;noatime&quot;, ... _options_ include &quot;barrier=1&quot;, &quot;noauto\\_da\\_alloc&quot;, &quot;discard&quot;, ... as a comma separated string, e.g. barrier=1,noauto\\_da\\_alloc`perform_apex_config`&gt; Performs tasks after APEXes are mounted. For example, creates data directories for the mounted APEXes, parses config file(s) from them, and updates linker configurations. Intended to be used only once when apexd notifies the mount event by setting `apexd.status` to ready.`restart [--only-if-running] &lt;service&gt;`&gt; Stops and restarts a running service, does nothing if the service is currently restarting, otherwise, it just starts the service. If &quot;--only-if-running&quot; is specified, the service is only restarted if it is already running.`restorecon &lt;path&gt; [ &lt;path&gt;\\* ]`&gt; Restore the file named by _path_ to the security context specified in the file\\_contexts configuration. Not required for directories created by the init.rc as these are automatically labeled correctly by init.`restorecon_recursive &lt;path&gt; [ &lt;path&gt;\\* ]`&gt; Recursively restore the directory tree named by _path_ to the security contexts specified in the file\\_contexts configuration.`rm &lt;path&gt;`&gt; Calls unlink(2) on the given path. You might want to use &quot;exec -- rm ...&quot; instead (provided the system partition is already mounted).`rmdir &lt;path&gt;`&gt; Calls rmdir(2) on the given path.`readahead &lt;file|dir&gt; [--fully]`&gt; Calls readahead(2) on the file or files within given directory. Use option --fully to read the full file content.`setprop &lt;name&gt; &lt;value&gt;`&gt; Set system property _name_ to _value_. Properties are expanded within _value_.`setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;`&gt; Set the rlimit for a resource. This applies to all processes launched after the limit is set. It is intended to be set early in init and applied globally. _resource_ is best specified using its text representation (&#x27;cpu&#x27;, &#x27;rtio&#x27;, etc or &#x27;RLIM_CPU&#x27;, &#x27;RLIM_RTIO&#x27;, etc). It also may be specified as the int value that the resource enum corresponds to. _cur_ and _max_ can be &#x27;unlimited&#x27; or &#x27;-1&#x27; to indicate an infinite rlimit.`start &lt;service&gt;`&gt; Start a service running if it is not already running. Note that this is _not_ synchronous, and even if it were, there is no guarantee that the operating system&#x27;s scheduler will execute the service sufficiently to guarantee anything about the service&#x27;s status. See the `exec_start` command for a synchronous version of `start`.&gt; This creates an important consequence that if the service offers functionality to other services, such as providing a communication channel, simply starting this service before those services is _not_ sufficient to guarantee that the channel has been set up before those services ask for it. There must be a separate mechanism to make any such guarantees.`stop &lt;service&gt;`&gt; Stop a service from running if it is currently running.`swapon_all [ &lt;fstab&gt; ]`&gt; Calls fs\\_mgr\\_swapon\\_all on the given fstab file. If the fstab parameter is not specified, fstab.$&#123;ro.boot.fstab_suffix&#125;, fstab.$&#123;ro.hardware&#125; or fstab.$&#123;ro.hardware.platform&#125; will be scanned for under /odm/etc, /vendor/etc, or / at runtime, in that order.`symlink &lt;target&gt; &lt;path&gt;`&gt; Create a symbolic link at _path_ with the value _target_`sysclktz &lt;minutes_west_of_gmt&gt;`&gt; Set the system clock base (0 if system clock ticks in GMT)`trigger &lt;event&gt;`&gt; Trigger an event. Used to queue an action from another action.`umount &lt;path&gt;`&gt; Unmount the filesystem mounted at that path.`umount_all [ &lt;fstab&gt; ]`&gt; Calls fs\\_mgr\\_umount\\_all on the given fstab file. If the fstab parameter is not specified, fstab.$&#123;ro.boot.fstab_suffix&#125;, fstab.$&#123;ro.hardware&#125; or fstab.$&#123;ro.hardware.platform&#125; will be scanned for under /odm/etc, /vendor/etc, or / at runtime, in that order.`verity_update_state`&gt; Internal implementation detail used to update dm-verity state and set the partition._mount-point_.verified properties used by adb remount because fs\\_mgr can&#x27;t set them directly itself. This is required since Android 12, because CtsNativeVerifiedBootTestCases will read property &quot;partition.$&#123;partition&#125;.verified.hash_alg&quot; to check that sha1 is not used. See https://r.android.com/1546980 for more details.`wait &lt;path&gt; [ &lt;timeout&gt; ]`&gt; Poll for the existence of the given file and return when found, or the timeout has been reached. If timeout is not specified it currently defaults to five seconds. The timeout value can be fractional seconds, specified in floating point notation.`wait_for_prop &lt;name&gt; &lt;value&gt;`&gt; Wait for system property _name_ to be _value_. Properties are expanded within _value_. If property _name_ is already set to _value_, continue immediately.`write &lt;path&gt; &lt;content&gt;`&gt; Open the file at _path_ and write a string to it with write(2). If the file does not exist, it will be created. If it does exist, it will be truncated. Properties are expanded within _content_.Imports-------`import &lt;path&gt;`&gt; Parse an init config file, extending the current configuration. If _path_ is a directory, each file in the directory is parsed as a config file. It is not recursive, nested directories will not be parsed.The import keyword is not a command, but rather its own section,meaning that it does not happen as part of an Action, but rather,imports are handled as a file is being parsed and follow the below logic.There are only three times where the init executable imports .rc files: 1. When it imports `/system/etc/init/hw/init.rc` or the script indicated by the property `ro.boot.init_rc` during initial boot. 2. When it imports `/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/` immediately after importing `/system/etc/init/hw/init.rc`. 3. (Deprecated) When it imports /&#123;system,vendor,odm&#125;/etc/init/ or .rc files at specified paths during mount_all, not allowed for devices launching after Q.The order that files are imported is a bit complex for legacy reasons. The below is guaranteed:1. `/system/etc/init/hw/init.rc` is parsed then recursively each of its imports are parsed.2. The contents of `/system/etc/init/` are alphabetized and parsed sequentially, with imports happening recursively after each file is parsed.3. Step 2 is repeated for `/system_ext/etc/init`, `/vendor/etc/init`, `/odm/etc/init`, `/product/etc/init`The below pseudocode may explain this more clearly: fn Import(file) Parse(file) for (import : file.imports) Import(import) Import(/system/etc/init/hw/init.rc) Directories = [/system/etc/init, /system_ext/etc/init, /vendor/etc/init, /odm/etc/init, /product/etc/init] for (directory : Directories) files = &lt;Alphabetical order of directory&#x27;s contents&gt; for (file : files) Import(file)Actions are executed in the order that they are parsed. For example the `post-fs-data` action(s)in `/system/etc/init/hw/init.rc` are always the first `post-fs-data` action(s) to be executed inorder of how they appear in that file. Then the `post-fs-data` actions of the imports of`/system/etc/init/hw/init.rc` in the order that they&#x27;re imported, etc.Properties----------Init provides state information with the following properties.`init.svc.&lt;name&gt;`&gt; State of a named service (&quot;stopped&quot;, &quot;stopping&quot;, &quot;running&quot;, &quot;restarting&quot;)`dev.mnt.dev.&lt;mount_point&gt;`, `dev.mnt.blk.&lt;mount_point&gt;`, `dev.mnt.rootdisk.&lt;mount_point&gt;`&gt; Block device base name associated with a *mount_point*. The *mount_point* has / replaced by . and if referencing the root mount point &quot;/&quot;, it will use &quot;/root&quot;. `dev.mnt.dev.&lt;mount_point&gt;` indicates a block device attached to filesystems. (e.g., dm-N or sdaN/mmcblk0pN to access `/sys/fs/ext4/$&#123;dev.mnt.dev.&lt;mount_point&gt;&#125;/`) `dev.mnt.blk.&lt;mount_point&gt;` indicates the disk partition to the above block device. (e.g., sdaN / mmcblk0pN to access `/sys/class/block/$&#123;dev.mnt.blk.&lt;mount_point&gt;&#125;/`) `dev.mnt.rootdisk.&lt;mount_point&gt;` indicates the root disk to contain the above disk partition. (e.g., sda / mmcblk0 to access `/sys/class/block/$&#123;dev.mnt.rootdisk.&lt;mount_point&gt;&#125;/queue`)Init responds to properties that begin with `ctl.`. These properties take the format of`ctl.[&lt;target&gt;_]&lt;command&gt;` and the _value_ of the system property is used as a parameter. The_target_ is optional and specifies the service option that _value_ is meant to match with. There isonly one option for _target_, `interface` which indicates that _value_ will refer to an interfacethat a service provides and not the service name itself.For example:`SetProperty(&quot;ctl.start&quot;, &quot;logd&quot;)` will run the `start` command on `logd`.`SetProperty(&quot;ctl.interface_start&quot;, &quot;aidl/aidl_lazy_test_1&quot;)` will run the `start` command on theservice that exposes the `aidl aidl_lazy_test_1` interface.Note that theseproperties are only settable; they will have no value when read.The _commands_ are listed below.`start` \\`restart` \\`stop` \\These are equivalent to using the `start`, `restart`, and `stop` commands on the service specifiedby the _value_ of the property.`oneshot_on` and `oneshot_off` will turn on or off the _oneshot_flag for the service specified by the _value_ of the property. This isparticularly intended for services that are conditionally lazy HALs. Whenthey are lazy HALs, oneshot must be on, otherwise oneshot should be off.`sigstop_on` and `sigstop_off` will turn on or off the _sigstop_ feature for the servicespecified by the _value_ of the property. See the _Debugging init_ section below for more detailsabout this feature.Boot timing-----------Init records some boot timing information in system properties.`ro.boottime.init`&gt; Time after boot in ns (via the CLOCK\\_BOOTTIME clock) at which the first stage of init started.`ro.boottime.init.first_stage`&gt; How long in ns it took to run first stage.`ro.boottime.init.selinux`&gt; How long in ns it took to run SELinux stage.`ro.boottime.init.modules`&gt; How long in ms it took to load kernel modules.`ro.boottime.init.cold_boot_wait`&gt; How long init waited for ueventd&#x27;s coldboot phase to end.`ro.boottime.&lt;service-name&gt;`&gt; Time after boot in ns (via the CLOCK\\_BOOTTIME clock) that the service was first started.Bootcharting------------This version of init contains code to perform &quot;bootcharting&quot;: generating logfiles that can be later processed by the tools provided by &lt;http://www.bootchart.org/&gt;.On the emulator, use the -bootchart _timeout_ option to boot with bootchartingactivated for _timeout_ seconds.On a device: adb shell &#x27;touch /data/bootchart/enabled&#x27;Don&#x27;t forget to delete this file when you&#x27;re done collecting data!The log files are written to /data/bootchart/. A script is provided toretrieve them and create a bootchart.tgz file that can be used with thebootchart command-line utility: sudo apt-get install pybootchartgui # grab-bootchart.sh uses $ANDROID_SERIAL. $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.shOne thing to watch for is that the bootchart will show init as if it startedrunning at 0s. You&#x27;ll have to look at dmesg to work out when the kernelactually started init.Comparing two bootcharts------------------------A handy script named compare-bootcharts.py can be used to compare thestart/end time of selected processes. The aforementioned grab-bootchart.shwill leave a bootchart tarball named bootchart.tgz at /tmp/android-bootchart.If two such tarballs are preserved on the host machine under differentdirectories, the script can list the timestamps differences. For example:Usage: system/core/init/compare-bootcharts.py _base-bootchart-dir_ _exp-bootchart-dir_ process: baseline experiment (delta) - Unit is ms (a jiffy is 10 ms on the system) ------------------------------------ /init: 50 40 (-10) /system/bin/surfaceflinger: 4320 4470 (+150) /system/bin/bootanimation: 6980 6990 (+10) zygote64: 10410 10640 (+230) zygote: 10410 10640 (+230) system_server: 15350 15150 (-200) bootanimation ends at: 33790 31230 (-2560)Systrace--------Systrace (&lt;http://developer.android.com/tools/help/systrace.html&gt;) can beused for obtaining performance analysis reports during boottime on userdebug or eng builds.Here is an example of trace events of &quot;wm&quot; and &quot;am&quot; categories: $ANDROID_BUILD_TOP/external/chromium-trace/systrace.py \\ wm am --bootThis command will cause the device to reboot. After the device is rebooted andthe boot sequence has finished, the trace report is obtained from the deviceand written as trace.html on the host by hitting Ctrl+C.Limitation: recording trace events is started after persistent properties are loaded, sothe trace events that are emitted before that are not recorded. Severalservices such as vold, surfaceflinger, and servicemanager are affected by thislimitation since they are started before persistent properties are loaded.Zygote initialization and the processes that are forked from the zygote are notaffected.Debugging init--------------When a service starts from init, it may fail to `execv()` the service. This is not typical, and maypoint to an error happening in the linker as the new service is started. The linker in Androidprints its logs to `logd` and `stderr`, so they are visible in `logcat`. If the error is encounteredbefore it is possible to access `logcat`, the `stdio_to_kmsg` service option may be used to directthe logs that the linker prints to `stderr` to `kmsg`, where they can be read via a serial port.Launching init services without init is not recommended as init sets up a significant amount ofenvironment (user, groups, security label, capabilities, etc) that is hard to replicate manually.If it is required to debug a service from its very start, the `sigstop` service option is added.This option will send SIGSTOP to a service immediately before calling exec. This gives a windowwhere developers can attach a debugger, strace, etc before continuing the service with SIGCONT.This flag can also be dynamically controlled via the ctl.sigstop_on and ctl.sigstop_off properties.Below is an example of dynamically debugging logd via the above: stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd &gt; logd 4343 1 18156 1684 do_signal_stop 538280 T init gdbclient.py -p 4343 b main c c c &gt; Breakpoint 1, main (argc=1, argv=0x7ff8c9a488) at system/core/logd/main.cpp:427Below is an example of doing the same but with strace stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd &gt; logd 4343 1 18156 1684 do_signal_stop 538280 T init strace -p 4343 (From a different shell) kill -SIGCONT 4343 &gt; strace runsHost Init Script Verification-----------------------------Init scripts are checked for correctness during build time. Specifically the below is checked.1) Well formatted action, service and import sections, e.g. no actions without a preceding &#x27;on&#x27;line, and no extraneous lines after an &#x27;import&#x27; statement.2) All commands map to a valid keyword and the argument count is within the correct range.3) All service options are valid. This is stricter than how commands are checked as the serviceoptions&#x27; arguments are fully parsed, e.g. UIDs and GIDs must resolve.There are other parts of init scripts that are only parsed at runtime and therefore not checkedduring build time, among them are the below.1) The validity of the arguments of commands, e.g. no checking if file paths actually exist, ifSELinux would permit the operation, or if the UIDs and GIDs resolve.2) No checking if a service exists or has a valid SELinux domain defined3) No checking if a service has not been previously defined in a different init script.Early Init Boot Sequence------------------------The early init boot sequence is broken up into three stages: first stage init, SELinux setup, andsecond stage init.First stage init is responsible for setting up the bare minimum requirements to load the rest of thesystem. Specifically this includes mounting /dev, /proc, mounting &#x27;early mount&#x27; partitions (whichneeds to include all partitions that contain system code, for example system and vendor), and movingthe system.img mount to / for devices with a ramdisk.Note that in Android Q, system.img always contains TARGET_ROOT_OUT and always is mounted at / by thetime first stage init finishes. Android Q will also require dynamic partitions and therefore willrequire using a ramdisk to boot Android. The recovery ramdisk can be used to boot to Android insteadof a dedicated ramdisk as well.First stage init has three variations depending on the device configuration:1) For system-as-root devices, first stage init is part of /system/bin/init and a symlink at /initpoints to /system/bin/init for backwards compatibility. These devices do not need to do anything tomount system.img, since it is by definition already mounted as the rootfs by the kernel.2) For devices with a ramdisk, first stage init is a static executable located at /init. Thesedevices mount system.img as /system then perform a switch root operation to move the mount at/system to /. The contents of the ramdisk are freed after mounting has completed.3) For devices that use recovery as a ramdisk, first stage init it contained within the shared initlocated at /init within the recovery ramdisk. These devices first switch root to/first_stage_ramdisk to remove the recovery components from the environment, then proceed the sameas 2). Note that the decision to boot normally into Android instead of bootinginto recovery mode is made if androidboot.force_normal_boot=1 is present in thekernel commandline, or in bootconfig with Android S and later.Once first stage init finishes it execs /system/bin/init with the &quot;selinux_setup&quot; argument. Thisphase is where SELinux is optionally compiled and loaded onto the system. selinux.cpp contains moreinformation on the specifics of this process.Lastly once that phase finishes, it execs /system/bin/init again with the &quot;second_stage&quot;argument. At this point the main phase of init runs and continues the boot process via the init.rcscripts. chatgpt译文： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774Android Init Language---------------------Android Init语言由五个宽泛的语句类别组成：Actions（动作）、Commands（命令）、Services（服务）、Options（选项）和Imports（导入）。所有这些语句以行为单位，由空格分隔的标记组成。可以使用C风格的反斜杠转义将空格插入标记中。双引号也可以用于防止空格破坏文本形成多个标记。当反斜杠是行末字符时，可以用于行折叠。以`#`开头的行（允许前置空格）是注释。可以使用`$&#123;property.name&#125;`的语法扩展系统属性。这在需要连接的上下文中也适用，例如`import /init.recovery.$&#123;ro.hardware&#125;.rc`。Actions和Services隐式声明了一个新的区块。所有的命令或选项都属于最近声明的区块。在第一个区块之前的命令或选项将被忽略。Services具有唯一的名称。如果定义了第二个名称与现有Service相同的Service，则会被忽略并记录错误消息。Init .rc文件--------------Init语言用于采用.rc文件扩展的纯文本文件中。通常在系统中有多个这样的文件，如下所述。`/system/etc/init/hw/init.rc`是主要的.rc文件，由init可执行文件在其启动时加载。它负责系统的初始设置。在加载主要的`/system/etc/init/hw/init.rc`之后，Init会立即加载`/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/`目录中包含的所有文件。这在本文件的[Imports](#imports)部分中有更详细的解释。在Q之后启动的设备不再支持在mount_all期间导入init脚本。这些目录的目的是： 1. /system/etc/init/ 用于核心系统项，如SurfaceFlinger、MediaService和logd。 2. /vendor/etc/init/ 用于SoC供应商项，如用于核心SoC功能的动作或守护进程。 3. /odm/etc/init/ 用于设备制造商项，如用于运动传感器或其他外围设备功能的动作或守护进程。所有二进制文件位于系统、供应商或odm分区的服务应将其服务条目放置在相应的init .rc文件中，位于它们所在分区的/etc/init/目录中。开发人员可以使用构建系统宏LOCAL_INIT_RC来处理此问题。每个init .rc文件还应包含与其服务关联的任何操作。一个例子是位于system/core/logcat目录中的userdebug logcatd.rc和Android.mk文件。Android.mk文件中的LOCAL_INIT_RC宏在构建过程中将logcatd.rc放置在/system/etc/init/中。Init在执行mount_all命令时加载logcatd.rc，并在适当时运行服务和排队操作。将init .rc文件按照它们的守护进程进行拆分比以前使用的大型init .rc文件更可取。这种方法确保init读取的只有存在于文件系统上的二进制文件对应的服务条目，而在大型init .rc文件中并非如此。此外，当向系统添加多个服务时，这样分拆将有助于解决合并冲突，因为每个服务都将进入单独的文件。APEXs中的带版本的RC文件---------------------------随着在Android Q上的主线开始，各个主线模块在其范围内携带自己的init.rc文件。Init根据命名模式`/apex/*/etc/*rc`来处理这些文件。由于APEX模块必须在多个Android版本上运行，它们可能需要不同的参数作为其定义的服务的一部分。从Android T开始，通过在init文件名中加入SDK版本信息来实现。后缀从`.rc`变为`.#rc`，其中#是该RC文件被接受的第一个SDK版本。一个特定于SDK=31的init文件可以被命名为`init.31rc`。使用这种方案，一个APEX可以包含多个init文件。下面是一个示例。对于/apex/sample-module/apex/etc/目录下拥有以下文件的APEX模块： 1. init.rc 2. init.32rc 4. init.35rc选择规则选择不超过当前运行系统的SDK的最高`.#rc`值。不带后缀的`.rc`表示sdk=0。当此APEX安装在SDK &lt;=31的设备上时，系统会处理init.rc。当安装在运行SDK 32、33或34的设备上时，它将使用init.32rc。当安装在运行SDK &gt;= 35的设备上时，它将选择init.35rc。此版本方案仅适用于APEX模块中的init文件，不适用于存储在/system/etc/init、/vendor/etc/init或其他目录中的init文件。此命名方案在Android S之后提供。动作-------动作是命令的命名序列。动作有一个触发器，用于确定何时执行该动作。当发生与动作的触发器匹配的事件时，该动作将被添加到待执行队列的末尾（除非它已经在队列中）。队列中的每个动作都按顺序出队，并执行该动作中的每个命令。在执行活动命令期间，Init处理其他活动（设备创建/销毁、属性设置、进程重启）。动作的形式如下： on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* &lt;command&gt; &lt;command&gt; &lt;command&gt;根据包含它们的文件的解析顺序（请参阅导入部分），动作按顺序添加到队列并执行，然后在单个文件内顺序执行。例如，如果一个文件包含： on boot setprop a 1 setprop b 2 on boot &amp;&amp; property:true=true setprop c 1 setprop d 2 on boot setprop e 1 setprop f 2那么当`boot`触发器发生并且假设属性`true`等于`true`时，执行命令的顺序将是： setprop a 1 setprop b 2 setprop c 1 setprop d 2 setprop e 1 setprop f 2 服务--------服务是在init启动和（可选地）重新启动时运行的程序。服务的形式如下： service &lt;名称&gt; &lt;路径&gt; [ &lt;参数&gt; ]* &lt;选项&gt; &lt;选项&gt; ... 选项--------选项是对服务的修改器。它们会影响到init运行服务的方式和时间。`capabilities [ &lt;capability&gt;\\* ]`&gt; 在执行该服务时设置能力（capabilities）。&#x27;capability&#x27;应为一个Linux能力（capability），没有&quot;CAP_&quot;前缀，比如&quot;NET_ADMIN&quot;或&quot;SETPCAP&quot;。请参考http://man7.org/linux/man-pages/man7/capabilities.7.html 获取Linux能力的列表。 如果未提供任何能力，则该服务将被移除所有能力，即使它以root用户运行。`class &lt;name&gt; [ &lt;name&gt;\\* ]`&gt; 为该服务指定类名（class names）。一个指定类的所有服务可以一起启动或停止。如果没有通过class选项指定类名，则该服务默认为&quot;default&quot;类。除了（必需的）第一个类名外，额外的类名用于分组服务。 &quot;animation&quot;类应包括所有启动动画和关机动画所需的服务。由于这些服务可以在启动过程的非常早期被启动，并且可能一直运行到关机 的最后阶段，因此不能保证可以访问/data分区。这些服务可以检查/data下的文件，但不能保持文件处于打开状态，且在/data不可用时应该正常工作。`console [&lt;console&gt;]`&gt; 该服务需要一个控制台。可选的第二个参数选择一个特定的控制台，而不使用默认规定的控制台。默认的&quot;/dev/console&quot;可以通过设置&quot;androidboot.console&quot;内核参数来更改。在所有情况下，应省略&quot;/dev/&quot;前缀，所以&quot;/dev/tty0&quot;可以指定为&quot;console tty0&quot;。 此选项将标准输入、标准输出和标准错误连接到控制台。它与stdio_to_kmsg选项互斥，后者只将标准输出和标准错误连接到kmsg。`critical [window=&lt;fatal crash window分钟&gt;] [target=&lt;fatal reboot目标&gt;]`&gt; 这是一个设备关键的服务。如果在_fatal crash window分钟_内它退出了超过四次，或者在启动完成之前退出，设备将重新启动到_fatal reboot目标_。 _fatal crash window分钟_的默认值为4，_fatal reboot目标_的默认值为&#x27;bootloader&#x27;。 可以通过将属性`init.svc_debug.no_fatal.&lt;service-name&gt;`设置为`true`来跳过对指定关键服务的致命重启，以进行测试。 `disabled`&gt; 这个服务不会随其类一起自动启动。 必须通过名称或接口名称显式启动。`enter_namespace &lt;type&gt; &lt;path&gt;`&gt; 进入位于 _path_ 的 _type_ 类型的命名空间。仅支持网络命名空间，_type_ 设置为 &quot;net&quot;。请注意，每种 _type_ 类型只能进入一个命名空间。`file &lt;path&gt; &lt;type&gt;`&gt; 打开文件路径并将其文件描述符传递给启动的进程。_type_ 必须为 &quot;r&quot;、&quot;w&quot; 或 &quot;rw&quot;。对于原生可执行文件，请参阅 libcutils android\\_get\\_control\\_file()。`group &lt;groupname&gt; [ &lt;groupname&gt;\\* ]`&gt; 在执行此服务之前切换到“groupname”。除了（必需的）第一个 groupname 之外的其他 groupname 用于设置进程的附加组（通过 setgroups()）。 当前默认为 root。 （？？？应该默认为 nobody）`interface &lt;interface name&gt; &lt;instance name&gt;`&gt; 将此服务与其提供的一组 AIDL 或 HIDL 服务关联起来。接口名称必须是完全限定的名称而不是值名称。例如，这用于允许 servicemanager 或 hwservicemanager 惰性启动服务。 当提供多个接口时，此标记应多次使用。HIDL 接口的示例条目是 `interface vendor.foo.bar@1.0::IBaz default`。对于 AIDL 接口， 请使用`interface aidl &lt;instance name&gt;`。AIDL 接口的实例名称是 与 servicemanager 注册的实例名称一致，可以使用 `adb shell dumpsys -l` 列出它们。`ioprio &lt;class&gt; &lt;priority&gt;`&gt; 通过 SYS_ioprio_set 系统调用设置此服务的 IO 优先级和 IO 优先级类。 _class_ 必须是 &quot;rt&quot;、&quot;be&quot; 或 &quot;idle&quot; 中的一个。_priority_ 必须是 0 - 7 范围内的整数。`keycodes &lt;keycode&gt; [ &lt;keycode&gt;\\* ]`&gt; 设置触发该服务的按键代码。如果同时按下与传递的按键代码对应的所有按键，则服务将启动。这通常用于启动 bugreport 服务。&gt; 此选项可以接受属性而不是按键代码列表。在这种情况下，提供一个选项：按典型属性扩展格式的属性名。属性必须包含逗号分隔的按键代码值列表或文本 &#x27;none&#x27;，表示该服务不响应按键代码。&gt; 例如，`keycodes $&#123;some.property.name:-none&#125;`，其中 some.property.name 扩展 为 &quot;123,124,125&quot;。由于按键代码在 init 非常早期处理， 只能使用 PRODUCT_DEFAULT_PROPERTY_OVERRIDES 属性。`memcg.limit_in_bytes &lt;value&gt;` 和 `memcg.limit_percent &lt;value&gt;`&gt; 将子进程的 memory.limit_in_bytes 设置为 `limit_in_bytes` 字节和 `limit_percent` 中较小的一个，`limit_percent` 表示设备物理内存大小的百分比（仅在 memcg 挂载时）。 值必须大于等于 0。`memcg.limit_property &lt;value&gt;`&gt; 将子进程的 memory.limit_in_bytes 设置为指定属性的值（仅在 memcg 挂载时）。此属性将覆盖通过 `memcg.limit_in_bytes` 和 `memcg.limit_percent` 指定的值。`memcg.soft_limit_in_bytes &lt;value&gt;`&gt; 将子进程的 memory.soft_limit_in_bytes 设置为指定值（仅在 memcg 挂载时），该值必须大于等于 0。`memcg.swappiness &lt;value&gt;`&gt; 将子进程的 memory.swappiness 设置为指定值（仅在 memcg 挂载时），该值必须大于等于 0。`namespace &lt;pid|mnt&gt;`&gt; 在 fork 服务时进入新的 PID 或挂载命名空间。`oneshot`&gt; 当服务退出时不重新启动。`onrestart`&gt; 在服务重新启动时执行命令（参见下文）。`oom_score_adjust &lt;value&gt;`&gt; 将子进程的 /proc/self/oom\\_score\\_adj 设置为指定值， 该值必须在 -1000 到 1000 范围内。`override`&gt; 表示此服务定义旨在覆盖先前定义的具有相同名称的服务。这通常用于在 /odm 上覆盖在 /vendor 上定义的服务。init 解析的具有此关 键字的最后一个服务定义将用于此服务。 请注意 init.rc 文件解析的顺序，因为出于向后兼容性原因，它具有一些特殊性。此文件的 &#x27;imports&#x27; 部分详细介绍了顺序。`priority &lt;priority&gt;`&gt; 服务进程的调度优先级。该值必须在 -20 到 19 的范围内。默认优先级为 0。优先级通过 setpriority() 设置。 `reboot_on_failure &lt;目标&gt;`&gt; 如果该进程无法启动，或者进程以CLD_EXITED以外的退出代码或非0的状态码终止，则重新启动带有指定目标的系统。_target_ 的格式与sys.powerctl的参数相同。这主要用于在启动期间进行一些必要的检查。`restart_period &lt;秒数&gt;`&gt; 如果非一次性服务退出，则在其启动时间加上此持续时间后重新启动。默认为5秒，用于限制崩溃服务的速率。可以增加此值以适应定期运行的服务。例如，可以将其设置为3600表示服务应每小时运行一次，或者设置为86400表示服务应每天运行一次。`rlimit &lt;资源&gt; &lt;当前值&gt; &lt;最大值&gt;`&gt; 将给定的rlimit应用于服务。rlimit会被子进程继承，因此这实际上将给定的rlimit应用于由此服务启动的进程树。解析方式与下面的setrlimit命令类似。`seclabel &lt;安全标签&gt;`&gt; 在执行此服务之前切换到“seclabel”。主要用于从根文件系统运行的服务，例如ueventd、adbd。位于系统分区上的服务可以根据其文件安全上下文使用策略定义的转换代替。如果未指定，并且策略中未定义转换，则默认为init上下文。`setenv &lt;变量名&gt; &lt;值&gt;`&gt; 在启动的进程中将环境变量_name_设置为_value_。`shutdown &lt;关机行为&gt;`&gt; 设置服务进程的关机行为。如果未指定，则在关机过程中使用SIGTERM和SIGKILL终止服务。使用&quot;critical&quot;关机行为的服务在关机期间不会被终止，直到关机超时。当关机超时时，即使标记为&quot;shutdown critical&quot;的服务也会被终止。如果在关机开始时标记为&quot;shutdown critical&quot;的服务未运行，则会启动该服务。`sigstop`&gt; 在调用exec之前立即向服务发送SIGSTOP信号。这用于调试。关于如何使用该选项的更多信息，请参见下面有关调试的部分。`socket &lt;名称&gt; &lt;类型&gt; &lt;权限&gt; [ &lt;用户&gt; [ &lt;组&gt; [ &lt;安全标签&gt; ] ] ]`&gt; 创建名为/dev/socket/_name_的UNIX域套接字，并将其文件描述符传递给启动的进程。_type_必须是&quot;dgram&quot;、&quot;stream&quot;或&quot;seqpacket&quot;。_type_可以以&quot;+passcred&quot;结尾，以启用套接字上的SO_PASSCRED选项。用户和组默认为0。&#x27;seclabel&#x27;是套接字的SELinux安全上下文。它默认为服务的安全上下文，如seclabel中指定的，或根据服务可执行文件的安全上下文计算得出。对于原生可执行文件，请参见libcutils android\\_get\\_control\\_socket()。`stdio_to_kmsg`&gt; 将stdout和stderr重定向到/dev/kmsg_debug。这对于在早期启动期间不使用本机Android日志记录且我们希望捕获其日志消息的服务非常有用。仅当启用/dev/kmsg_debug时，即仅在userdebug和eng构建上启用时，才会启用此功能。这与console选项互斥，console选项还会将stdin连接到给定的控制台。`task_profiles &lt;配置文件&gt; [ &lt;配置文件&gt;* ]`&gt; 在进程分叉时为进程设置任务配置文件。这旨在取代使用writepid选项将进程移动到cgroup的方法。`timeout_period &lt;秒数&gt;`&gt; 提供超时时间，在该时间之后，服务将被终止。在这里，将尊重oneshot关键字，因此一次性服务不会自动重新启动，但其他所有服务都会重新启动。这对于创建与上面描述的restart_period选项结合使用的周期性服务特别有用。`updatable`&gt; 标记服务可以后续被APEX覆盖（通过&#x27;override&#x27;选项）。具有可更新选项的服务在APEX全部激活之前启动时，执行将会延迟，直到激活完成。不标记为可更新的服务无法被APEX覆盖。`user &lt;用户名&gt;`&gt; 在执行此服务之前切换到&#x27;username&#x27;。当前默认为root。（？？？可能应默认为nobody）从Android M版本开始，即使进程需要Linux特权，也应使用此选项。以前，为了获取Linux特权，进程需要以root身份运行，请求特权，然后切换到所需的uid。这里有一种新的机制，通过fs\\_config允许设备厂商向特定文件系统上的特定二进制文件添加Linux特权。该机制在&lt;http://source.android.com/devices/tech/config/filesystem.html&gt;上进行了描述。使用此新机制时，进程可以使用user选项选择其所需的uid，而无需以root身份运行。从Android O开始，进程还可以在其.rc文件中直接请求特权。参见下面的&quot;capabilities&quot;选项。`writepid &lt;文件&gt; [ &lt;文件&gt;* ]`&gt; 当进程分叉时，将子进程的pid写入给定的文件。用于cgroup/cpuset。如果未指定/dev/cpuset/下的文件，但系统属性&#x27;ro.cpuset.default&#x27;设置为非空的cpuset名称（例如&#x27;/foreground&#x27;），则pid将写入文件/dev/cpuset/_cpuset\\_name_/tasks。对于将进程移动到cgroup，此选项的使用已过时。请改用task_profiles选项。触发器--------触发器是用来匹配特定类型事件并引发某个动作的字符串。触发器被分为事件触发器和属性触发器。事件触发器是由&#x27;trigger&#x27;命令或在init可执行文件中使用QueueEventTrigger()函数引发的字符串。它们采用简单的字符串形式，比如&#x27;boot&#x27;或&#x27;late-init&#x27;。属性触发器是在命名属性的值变为给定新值或命名属性的值变为任意新值时引发的字符串。它们采用&#x27;property:&lt;name&gt;=&lt;value&gt;&#x27;和&#x27;property:&lt;name&gt;=\\*&#x27;的形式。在init的初始引导阶段，属性触发器还会进行评估并相应地引发。一个动作可以有多个属性触发器，但只能有一个事件触发器。例如：`on boot &amp;&amp; property:a=b`定义了一个只有在&#x27;boot&#x27;事件触发发生且属性a等于b时才执行的动作。`on property:a=b &amp;&amp; property:c=d`定义了一个在以下三种情况下执行的动作： 1. 在初始引导期间，如果属性a=b且属性c=d。 2. 每当属性a从其他值过渡到值b时，而属性c已经等于d。 3. 每当属性c从其他值过渡到值d时，而属性a已经等于b。触发器顺序----------------在早期引导过程中，init使用以下一系列触发器。这些是在init.cpp中定义的内置触发器。 1. `early-init` - 首个触发器，在cgroups被配置之后、ueventd的冷启动完成之前触发。 2. `init` - 冷启动完成后触发。 3. `charger` - 如果`ro.bootmode == &quot;charger&quot;`，则触发。 4. `late-init` - 如果`ro.bootmode != &quot;charger&quot;`，或者通过healthd从充电模式启动，则触发。剩余的触发器由`init.rc`中配置，并非内置的。这些触发器的默认顺序在`init.rc`的&quot;on late-init&quot;事件下指定。在`init.rc`内部的动作被省略。 1. `early-fs` - 启动vold。 2. `fs` - Vold已启动。将未标记为first-stage或latemounted的分区挂载。 3. `post-fs` - 配置任何依赖早期挂载的内容。 4. `late-fs` - 挂载被标记为latemounted的分区。 5. `post-fs-data` - 挂载和配置`/data`；设置加密。如果在第一阶段init中无法挂载`/metadata`，则在这里重新格式化。 6. `zygote-start` - 启动Zygote。 7. `early-boot` - 在Zygote启动后。 8. `boot` - 在`early-boot`动作完成后。 命令----`bootchart [start|stop]`&gt; 启动/停止启动图表记录。这些命令在默认的init.rc文件中存在，但仅当文件/data/bootchart/enabled存在时，启动图表记录才会生效；否则，启动图表记录的start/stop命令不起作用。`chmod &lt;octal-mode&gt; &lt;path&gt;`&gt; 更改文件访问权限。`chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;`&gt; 更改文件所有者和组。`class_start &lt;serviceclass&gt;`&gt; 如果指定类别的所有服务尚未运行，则启动它们。有关启动服务的更多信息，请参阅启动条目。`class_stop &lt;serviceclass&gt;`&gt; 如果指定类别的所有服务当前正在运行，则停止并禁用它们。`class_reset &lt;serviceclass&gt;`&gt; 如果指定类别的所有服务当前正在运行，则停止它们，但不禁用。稍后可以使用`class_start`命令重新启动它们。`class_restart [--only-enabled] &lt;serviceclass&gt;`&gt; 重新启动指定类别的所有服务。如果指定了`--only-enabled`选项，则跳过已禁用的服务。`copy &lt;src&gt; &lt;dst&gt;`&gt; 复制文件。与write类似，但适用于二进制/大量数据。关于src文件，不允许从符号链接文件和world-writable或group-writable文件复制。关于dst文件，如果文件不存在，则创建的默认模式是0600。如果dst文件是一个普通常规文件并且已经存在，则会被截断。`copy_per_line &lt;src&gt; &lt;dst&gt;`&gt; 逐行复制文件。与copy类似，但适用于dst是不能处理多行数据的sysfs节点。`domainname &lt;name&gt;`&gt; 设置域名。`enable &lt;servicename&gt;`&gt; 将禁用的服务变为启用状态，就好像该服务未指定禁用一样。 如果该服务应该在运行，则现在它将被启动。 通常在引导加载程序设置指定特定服务在需要时启动的变量时使用。例如： on property:ro.boot.myfancyhardware=1 enable my_fancy_service_for_my_fancy_hardware`exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\\* ]`&gt; 分支并以给定的参数执行命令。命令在“--”之后开始，以便可以提供可选的安全上下文、用户和辅助组。在此命令完成之前，不会执行其他命令。_seclabel_可以是“-”表示默认值。属性会在_argument_中展开。 Init会等待分支的进程退出后再继续执行命令。`exec_background [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\\* ]`&gt; 分支并以给定的参数执行命令。这与“exec”命令类似处理。 不同之处在于，对于`exec_background`，init不会在该进程退出之前停止执行命令。`exec_start &lt;service&gt;`&gt; 启动给定的服务，并暂停处理其他init命令，直到该服务返回。该命令的功能类似于“exec”命令，但使用现有的服务定义替代exec参数向量。`export &lt;name&gt; &lt;value&gt;`&gt; 在全局环境中将环境变量_name_设置为_value_（该变量将被所有在执行此命令后启动的进程继承）`hostname &lt;name&gt;`&gt; 设置主机名。`ifup &lt;interface&gt;`&gt; 将网络接口_interface_上线。`insmod [-f] &lt;path&gt; [&lt;options&gt;]`&gt; 使用指定选项安装_path_处的模块。 -f: 强制安装模块，即使运行的内核版本和编译该模块的内核版本不匹配。`interface_start &lt;name&gt;``interface_restart &lt;name&gt;``interface_stop &lt;name&gt;`&gt; 查找提供接口_name_的服务（如果存在），并在其上分别运行`start`、`restart`或`stop`命令。_name_可以是完全限定的HIDL名称，格式为`&lt;interface&gt;/&lt;instance&gt;`，也可以是AIDL名称，格式为`aidl/&lt;interface&gt;`，例如`android.hardware.secure_element@1.1::ISecureElement/eSE1`或`aidl/aidl_lazy_test_1`。&gt; 注意，这些命令只作用于由`interface`服务选项指定的接口，而不作用于动态注册的接口。&gt; 这些命令的示例用法：\\`interface_start android.hardware.secure_element@1.1::ISecureElement/eSE1`将启动提供`android.hardware.secure_element@1.1`和`eSI1`实例的HIDL服务。\\`interface_start aidl/aidl_lazy_test_1`将启动提供`aidl_lazy_test_1`接口的AIDL服务。`load_exports &lt;path&gt;`&gt; 打开_path_处的文件，并导出其中声明的全局环境变量。每一行必须按照上述格式`export &lt;name&gt; &lt;value&gt;`。`load_system_props`&gt; （此操作已弃用，并且不会执行任何操作。）`load_persist_props`&gt; 在/data被解密后加载持久属性。 这在默认的init.rc中包含。`loglevel &lt;level&gt;`&gt; 将init的日志级别设置为整数级别，从7（所有日志）到0（仅致命日志）。数字值对应于内核日志级别，但此命令不会影响内核日志级别。使用`write`命令写入`/proc/sys/kernel/printk`以更改内核日志级别。属性在_level_中展开。`mark_post_data`&gt; 用于标记/data挂载后的点。`mkdir &lt;path&gt; [&lt;mode&gt;] [&lt;owner&gt;] [&lt;group&gt;] [encryption=&lt;action&gt;] [key=&lt;key&gt;]`&gt; 在_path_处创建目录，可选择使用给定的模式、所有者和组。如果未提供，目录将以权限755创建，并由root用户和root组拥有。如果提供了该参数，将在目录已存在时更新模式、所有者和组。&gt; _action_可以是以下之一： * `None`：不采取加密操作；如果父目录已加密，则目录将被加密。 * `Require`：加密目录，如果加密失败，则中止引导过程。 * `Attempt`：尝试设置加密策略，如果失败继续执行。 * `DeleteIfNecessary`：递归删除必要的目录以设置加密策略。&gt; _key_可以是以下之一： * `ref`：使用系统范围的DE密钥 * `per_boot_ref`：使用每次启动时新生成的密钥。`mount_all [ &lt;fstab&gt; ] [--&lt;option&gt;]`&gt; 在给定的fs\\_mgr格式fstab上调用fs\\_mgr\\_mount\\_all，可选使用选项&quot;early&quot;和&quot;late&quot;。 如果设置了“--early”，init可执行文件将跳过具有“latemount”标志的挂载条目，并触发fs加密状态事件。如果设置了“--late”，init 可执行文件将仅挂载具有“latemount”标志的条目。默认情况下，未设置选项，并且mount\\_all将处理给定fstab中的所有条目。 如果未指定fstab参数，则在运行时将扫描fstab.$&#123;ro.boot.fstab_suffix&#125;、fstab.$&#123;ro.hardware&#125; 或fstab.$&#123;ro.hardware.platform&#125;，按照/odm/etc、/vendor/etc或/的顺序。 `mount &lt;类型&gt; &lt;设备&gt; &lt;目录&gt; [ &lt;标志&gt;\\*] [&lt;选项&gt;]`&gt; 尝试将指定的设备挂载到目录_dir_上。 _标志_包括&quot;ro&quot;、&quot;rw&quot;、&quot;remount&quot;、&quot;noatime&quot;，... _选项_是一个逗号分隔的字符串，例如，barrier=1,noauto\\_da\\_alloc`perform_apex_config`&gt; 在APEX挂载后执行任务。例如，为已挂载的APEX创建数据目录、解析其配置文件，并更新链接器配置。仅在apexd将`apexd.status`设置为ready时通知挂载事件时使用。`restart [--only-if-running] &lt;服务&gt;`&gt; 停止并重启正在运行的服务，如果服务当前正在重新启动，则不执行任何操作，否则，仅启动服务。如果指定了&quot;--only-if-running&quot;，则只有在服务已经运行时才会重启服务。`restorecon &lt;路径&gt; [ &lt;路径&gt;\\* ]`&gt; 将名为_path_的文件恢复为文件上指定的安全上下文中的状态。 对于由init.rc创建的目录不需要此操作，因为它们会自动进行正确的标记。`restorecon_recursive &lt;路径&gt; [ &lt;路径&gt;\\* ]`&gt; 递归地将名为_path_的目录树恢复为文件上指定的安全上下文中的状态。`rm &lt;路径&gt;`&gt; 对给定路径调用unlink(2)。如果系统分区已经挂载，可能应该使用&quot;exec -- rm ...&quot; (provided the system partition is already mounted)。`rmdir &lt;路径&gt;`&gt; 对给定路径调用rmdir(2)。`readahead &lt;文件|目录&gt; [--fully]`&gt; 对给定的文件或指定目录中的文件调用readahead(2)。使用选项--fully以读取完整的文件内容。`setprop &lt;名称&gt; &lt;值&gt;`&gt; 将系统属性_name_的值设置为_value_。属性将在_value_中进行扩展。`setrlimit &lt;资源&gt; &lt;当前值&gt; &lt;最大值&gt;`&gt; 设置资源的rlimit。此设置将应用于在限制设置后启动的所有进程。它旨在在init早期进行设置，并应用于全局。 _资源_最好使用其文本表示（&#x27;cpu&#x27;、&#x27;rtio&#x27;等）或&#x27;RLIM_CPU&#x27;、&#x27;RLIM_RTIO&#x27;等表示。也可以将其指定为资源枚举对应的整数值。 _当前值_和_最大值_可以设置为&#x27;unlimited&#x27;或&#x27;-1&#x27;，表示无限制的rlimit。 开始&lt;service&gt;通过启动服务来运行，如果服务尚未运行。请注意，这不是同步的，即使是同步的，也不能保证操作系统的调度程序会执行足够的次数来保证服务的状态。有关同步版本的&quot;start&quot;命令，请参阅&quot;exec_start&quot;命令。这带来了一个重要的结果，如果服务向其他服务提供功能，例如提供通信通道，那么仅仅在那些服务之前启动此服务是不足以保证在那些服务请求它之前已经建立了通道的。必须有一种单独的机制来做出任何这样的保证。停止&lt;service&gt;如果服务当前正在运行，则停止运行。swapon_all [&lt;fstab&gt;]在给定的fstab文件上调用fs_mgr_swapon_all命令。如果没有指定fstab参数，则会在/odm/etc、/vendor/etc或/根目录下以fstab.$&#123;ro.boot.fstab_suffix&#125;、fstab.$&#123;ro.hardware&#125;或fstab.$&#123;ro.hardware.platform&#125;的顺序进行扫描。symlink &lt;target&gt; &lt;path&gt;在路径_path_上创建一个带有值_target_的符号链接。sysclktz &lt;minutes_west_of_gmt&gt;设置系统时钟基准（如果系统时钟在GMT中嘀嗒，则为0）trigger &lt;event&gt;触发一个事件。用于将一个动作排队从另一个动作中执行。umount &lt;path&gt;卸载位于该路径的文件系统。umount_all [&lt;fstab&gt;]在给定的fstab文件上调用fs_mgr_umount_all命令。如果没有指定fstab参数，则会在/odm/etc、/vendor/etc或/根目录下以fstab.$&#123;ro.boot.fstab_suffix&#125;、fstab.$&#123;ro.hardware&#125;或fstab.$&#123;ro.hardware.platform&#125;的顺序进行扫描。verity_update_state用于更新dm-verity状态并设置由adb remount使用的partition._mount-point_.verified属性的内部实现细节，因为fs_mgr不能直接设置这些属性。这是自Android 12以来所需的，因为CtsNativeVerifiedBootTestCases将读取属性&quot;partition.$&#123;partition&#125;.verified.hash_alg&quot;以检查是否使用了sha1。有关更多详情，请参见https://r.android.com/1546980。wait &lt;path&gt; [&lt;timeout&gt;]轮询给定文件的存在，直到找到为止，或者超时已达到。如果未指定超时时间，默认为五秒。超时值可以是小数秒，以浮点数表示法指定。wait_for_prop &lt;name&gt; &lt;value&gt;等待系统属性_name_的值为_value_。_value_中的属性将被展开。如果属性_name_已经设置为_value_，则立即继续。write &lt;path&gt; &lt;content&gt;打开位于路径_path_的文件，并使用write(2)将字符串写入其中。如果文件不存在，则会创建文件。如果文件已存在，则会将其截断。_content_中的属性将被展开。导入-------`import &lt;路径&gt;`&gt; 解析一个init配置文件，扩展当前的配置。 如果`路径`是一个目录，则会解析目录中的每个文件作为配置文件。这是非递归的，嵌套目录不会被解析。import关键字不是一个命令，而是它自己的部分，即它不会作为一个动作的一部分发生，而是在解析文件时处理导入，并遵循以下逻辑。只有三种情况下，init可执行程序会导入.rc文件： 1. 当它在初始启动时导入`/system/etc/init/hw/init.rc`或由属性`ro.boot.init_rc`指示的脚本时。 2. 当它在导入`/system/etc/init/hw/init.rc`之后立即导入`/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/`。 3. （不推荐使用）当它在mount_all期间导入/&#123;system,vendor,odm&#125;/etc/init/或.rc文件时， 不允许在Q之后启动的设备使用。文件的导入顺序因遗留原因而稍微复杂。以下是保证的：1. 首先，解析`/system/etc/init/hw/init.rc`，然后递归解析它的每个导入文件。2. `/system/etc/init/`的内容按字母顺序排序并顺序解析，每个文件解析后递归进行导入。3. 对`/system_ext/etc/init`，`/vendor/etc/init`，`/odm/etc/init`，`/product/etc/init`执行步骤2。下面的伪代码可以更清楚地解释这个问题： fn Import(文件) 解析(文件) for (导入 : 文件.导入) 导入(导入) 导入(/system/etc/init/hw/init.rc) 目录 = [/system/etc/init, /system_ext/etc/init, /vendor/etc/init, /odm/etc/init, /product/etc/init] for (目录 : 目录) 文件 = &lt;按目录内容的字母顺序排序&gt; for (文件 : 文件) 导入(文件)动作按照解析顺序执行。例如，在`/system/etc/init/hw/init.rc`中的`post-fs-data`动作总是按照它们在文件中出现的顺序执行。然后，按导入的顺序执行`/system/etc/init/hw/init.rc`的导入中的`post-fs-data`动作，依此类推。属性------Init提供以下属性的状态信息。`init.svc.&lt;名称&gt;`&gt; 一个命名服务的状态（&quot;stopped&quot;，&quot;stopping&quot;，&quot;running&quot;，&quot;restarting&quot;）`dev.mnt.dev.&lt;挂载点&gt;`，`dev.mnt.blk.&lt;挂载点&gt;`，`dev.mnt.rootdisk.&lt;挂载点&gt;`&gt; 与*挂载点*关联的块设备基本名称。 *挂载点*将/替换为.，如果引用根挂载点&quot;/&quot;，则使用&quot;/root&quot;。 `dev.mnt.dev.&lt;挂载点&gt;`表示附加到文件系统的块设备。 （例如，使用`$&#123;dev.mnt.dev.&lt;挂载点&gt;&#125;`/sys/fs/ext4/来访问） `dev.mnt.blk.&lt;挂载点&gt;`表示上述块设备的磁盘分区。 （例如，使用`/sys/class/block/$&#123;dev.mnt.blk.&lt;挂载点&gt;&#125;`来访问） `dev.mnt.rootdisk.&lt;挂载点&gt;`表示包含上述磁盘分区的根磁盘。 （例如，使用`/sys/class/block/$&#123;dev.mnt.rootdisk.&lt;挂载点&gt;&#125;/queue`来访问）Init会响应以`ctl.`开头的属性。这些属性的格式为`ctl.[&lt;target&gt;_]&lt;command&gt;`，系统属性的_value_将用作参数。_target_是可选的，指定_value_应与哪个服务选项匹配。_target_只有一个选项，即`interface`，表示_value_将引用服务提供的接口，而不是服务名称本身。例如：`SetProperty(&quot;ctl.start&quot;, &quot;logd&quot;)` 将在 `logd` 上运行 `start` 命令。`SetProperty(&quot;ctl.interface_start&quot;, &quot;aidl/aidl_lazy_test_1&quot;)` 将在公开 `aidl aidl_lazy_test_1` 接口的服务上运行`start` 命令。请注意，这些属性只是可设置的，当读取时它们没有值。以下是 _commands_。`start` \\`restart` \\`stop` \\这等效于在由属性的 _value_ 指定的服务上使用 `start`、`restart` 和 `stop` 命令。`oneshot_on` 和 `oneshot_off` 将打开或关闭由属性的 _value_ 指定的服务的 _oneshot_ 标志。这特别适用于条件上懒加载硬件抽象层 (HAL) 的服务。当它们是懒加载 HAL 时，oneshot 必须开启，否则 oneshot 应该关闭。`sigstop_on` 和 `sigstop_off` 将打开或关闭由属性的 _value_ 指定的服务的 _sigstop_ 功能。有关此功能的更多详细信息，请参阅下面的 _Debugging init_ 部分。引导时间-----------Init 在系统属性中记录了一些引导时间信息。`ro.boottime.init`&gt; 使用 CLOCK_BOOTTIME 时钟以纳秒为单位记录的启动后阶段 init 开始的时间。`ro.boottime.init.first_stage`&gt; 运行第一阶段所需的时间，以纳秒为单位。`ro.boottime.init.selinux`&gt; 运行 SELinux 阶段所需的时间，以纳秒为单位。`ro.boottime.init.modules`&gt; 加载内核模块所需的时间，以毫秒为单位。`ro.boottime.init.cold_boot_wait`&gt; init 等待 ueventd 的冷启动阶段结束的时间，以毫秒为单位。`ro.boottime.&lt;service-name&gt;`&gt; 服务首次启动后的时间，以 CLOCK_BOOTTIME 时钟为单位，以纳秒表示。Bootcharting------------这个版本的init包含有执行“bootcharting”的代码：生成日志文件，可以在之后使用&lt;http://www.bootchart.org/&gt;提供的工具进行处理。在模拟器上，使用-bootchart _timeout_选项激活bootcharting功能，持续_timeout_秒。在设备上： adb shell &#x27;touch /data/bootchart/enabled&#x27;完成数据收集后，请不要忘记删除此文件！日志文件将被写入到/data/bootchart/。提供了一个脚本来检索这些文件并创建一个可以与bootchart命令行工具一起使用的bootchart.tgz文件： sudo apt-get install pybootchartgui # grab-bootchart.sh使用$ANDROID_SERIAL。 $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh需要注意的一点是，bootchart将显示init从0秒开始运行。您需要查看dmesg来确定内核实际上何时启动init。比较两个bootchart------------------------一个方便的脚本名为compare-bootcharts.py用于比较所选进程的开始/结束时间。上述的grab-bootchart.sh将在/tmp/android-bootchart下留下一个名为bootchart.tgz的bootchart tarball。如果在主机上的不同目录下保存了两个这样的tarballs，脚本可以列出时间戳的差异。例如：用法：system/core/init/compare-bootcharts.py _base-bootchart-dir_ _exp-bootchart-dir_ 进程：基准 实验 (增量) - 单位为ms（系统上的jiffy是10ms） ------------------------------------ /init: 50 40 (-10) /system/bin/surfaceflinger: 4320 4470 (+150) /system/bin/bootanimation: 6980 6990 (+10) zygote64: 10410 10640 (+230) zygote: 10410 10640 (+230) system_server: 15350 15150 (-200) bootanimation ends at: 33790 31230 (-2560)Systrace--------在userdebug或eng构建上，可以使用Systrace (&lt;http://developer.android.com/tools/help/systrace.html&gt;) 获取在启动过程中的性能分析报告。以下是“wm”和“am”类别的示例跟踪事件： $ANDROID_BUILD_TOP/external/chromium-trace/systrace.py \\ wm am --boot该命令将导致设备重新启动。设备重新启动并完成启动顺序后，通过按Ctrl+C从设备获取跟踪报告，并将其作为trace.html写入主机。限制：记录跟踪事件是在加载持久属性之后开始的，因此不记录在那之前发出的跟踪事件。一些服务，如vold、surfaceflinger和servicemanager受到此限制的影响，因为它们在加载持久属性之前启动。Zygote初始化和从Zygote派生的进程不受影响。调试初始化--------------当一个服务从init启动时，可能会无法`execv()`该服务。这种情况并不常见，可能是由于新服务启动时链接器发生错误引起的。Android中的链接器将其日志打印到`logd`和`stderr`中，因此它们可以在`logcat`中看到。如果在访问`logcat`之前遇到错误，可以使用`stdio_to_kmsg`服务选项将链接器打印到`stderr`中的日志导向到`kmsg`，然后可以通过串口读取这些日志。不建议在没有init的情况下启动init服务，因为init设置了大量环境（用户、组、安全标签、能力等），很难手动复制。如果需要从服务的起始位置开始调试，可以添加`sigstop`服务选项。该选项将在调用exec之前立即发送SIGSTOP给服务。在继续使用SIGCONT继续服务之前，开发者可以通过附加调试器、strace等进行调试。该标志也可以通过ctl.sigstop_on和ctl.sigstop_off属性动态控制。以下是通过上述方法动态调试logd的示例： stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd &gt; logd 4343 1 18156 1684 do_signal_stop 538280 T init gdbclient.py -p 4343 b main c c c &gt; Breakpoint 1, main (argc=1, argv=0x7ff8c9a488) at system/core/logd/main.cpp:427以下是使用strace进行相同操作的示例： stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd &gt; logd 4343 1 18156 1684 do_signal_stop 538280 T init strace -p 4343 （从另一个Shell执行） kill -SIGCONT 4343 &gt; strace运行主机Init脚本验证-----------------------------在构建时会检查Init脚本的正确性。具体检查如下所示。1) 格式良好的action、service和import部分，例如没有在&#x27;import&#x27;语句之后多余的行，没有在&#x27;on&#x27;行之前的动作。2) 所有命令都映射到有效的关键词，并且参数计数在正确范围内。3) 所有服务选项都是有效的。这比命令检查更严格，因为服务选项的参数会完全解析，例如需要解析UID和GID。还有一些Init脚本的其他部分是仅在运行时解析的，因此在构建时不会进行检查，其中包括以下内容。1) 命令的参数的有效性，例如不会检查文件路径是否存在，SELinux是否允许操作，以及UID和GID是否可解析。2) 不会检查服务是否存在或是否定义了有效的SELinux域。3) 不会检查服务是否在其他Init脚本中已经定义。早期Init引导顺序------------------------早期Init引导顺序分为三个阶段：第一阶段init、SELinux设置、第二阶段init。第一阶段init负责设置加载系统的最低要求。具体包括挂载/dev、/proc，挂载&#x27;early mount&#x27;分区（需要包括包含系统代码的所有分区，例如system和vendor），并将system.img挂载到/（对于使用ramdisk的设备）。需要注意的是，在Android Q中，system.img始终包含TARGET_ROOT_OUT，并且总是在第一阶段init完成时挂载到/。Android Q还需要动态分区，因此需要使用ramdisk引导Android。还可以使用恢复ramdisk来引导到Android，而不是使用专用的ramdisk。根据设备配置的不同，第一阶段init有三个变种：1) 对于system-as-root设备，第一阶段init是/system/bin/init的一部分，而/init是一个指向/system/bin/init的符号链接，以向后兼容。这些设备不需要执行任何操作来挂载system.img，因为根据定义，它已经被内核作为根文件系统挂载。2) 对于具有ramdisk的设备，第一阶段init是位于/init的静态可执行文件。这些设备将system.img挂载为/system，然后通过切换根操作将挂载点从/system移动到/。挂载完成后，ramdisk的内容被释放。3) 对于使用恢复模式作为ramdisk的设备，在恢复ramdisk中的/shared init中包含了第一阶段init。这些设备首先切换根目录到/first_stage_ramdisk，以从环境中删除恢复组件，然后像第二种情况一样继续处理。注意，决定正常启动到Android而不是启动到恢复模式时，是通过内核命令行中是否存在androidboot.force_normal_boot=1或在Android S及更高版本中的bootconfig中指定。第一阶段init完成后，它会使用&quot;selinux_setup&quot;参数执行/system/bin/init。此阶段是可选地编译和加载SELinux到系统上。有关此过程的详细信息，请参阅selinux.cpp。最后，一旦该阶段完成，它会再次使用&quot;second_stage&quot;参数执行/system/bin/init。此时，主要的init阶段运行，并通过init.rc脚本继续引导过程。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/10.线程/","text":"一. 什么是线程？ 这个基本不用多说了吧，学过编程的都知道，但还是简单介绍以下。线程是CPU调度的最小单位，被包含在进程之中，拥有自己的栈空间，和进程共享堆等其他资源，所以在多线程环境中存在线程同步，互斥等问题。 小知识点 其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone( )。该系统调用copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。 copy后的进程和原先的进程共享了所有的变量，运行环境。这样，原先进程中的变量变动在copy后的进程中便能体现出来。 提示 本次课程使用ubuntu 环境 、vim编辑器 编译命令： 12345678#man xx linux方法使用说明man pthread_create#编译c文件 编译线程加-lpthreadgcc xxx.c -lpthread# 执行./a.out#strerror(xx)将错误码翻译成字符串strerror(ret)or(xx) 二. 线程的创建函数pthread_create 用于创建一个线程，对应进程中就是fork函数。 1234567891011121314151617#man xx linux查询xx方法使用说明man pthread_create #include &lt;pthread.h&gt;int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, void *(*start_rtn)(void*),void *arg);// 若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。// 返回成功时，由tidp指向的内存单元被设置为新创建线程的线程ID.attr参数用于指定各种不同的线程属性。新创建的线程从start_rtn函//数的地址开始运行，该函数只有一个万能指针参数arg，如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构//中，然后把这个结构的地址作为arg的参数传入。// 失败返回errno// 参数// 第一个参数为指向线程标识符的指针。// 第二个参数用来设置线程属性。// 第三个参数是线程运行函数的起始地址。// 最后一个参数是运行函数的参数。 例子： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void *func(void *arg)&#123; printf(&quot;func------------------\\n&quot;);&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int ret = pthread_create(&amp;tid, NULL, func, NULL); if (ret != 0)&#123; //fprintf打印 fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; //不加休眠就直接运行结束了，不会显示打印的日志 sleep(3); return 0;&#125; 三. 线程ID获取函数pthread_self 进程有进程ID，用getpid()。线程同样也有线程ID，对应的函数就是pthread_self函数,用来获取当前线程ID 1234#include &lt;pthread.h&gt;// 返回值：成功线程ID；失败:其他pthread_t pthread_self(); 例子： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void *func(void *arg)&#123; printf(&quot;child pthread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); printf(&quot;func------------------\\n&quot;);&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int ret = pthread_create(&amp;tid, NULL, func, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; printf(&quot;main thread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); sleep(3); return 0; &#125; 四. 线程退出函数pthread_exit函数 线程通过调用pthread_exit函数终止执行，就如同进程在结束时调用exit函数一样。这个函数的作用是，终止调用它的线程并返回一个指向某个对象的指针。 1void pthread_exit(void* retval); 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void testxxx()&#123; // ... printf(&quot;need exit............. [%s][%d] \\n&quot;, __func__, __LINE__); pthread_exit((void *)100);&#125;int test_return()&#123; // .... printf(&quot;need exit ...........................[%s][%d]\\n&quot;, __func__, __LINE__); return 100;&#125;void *func(void *arg)&#123; printf(&quot;child pthread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); printf(&quot;func------------------\\n&quot;); test_return(); testxxx(); printf(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\n&quot;);&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int ret = pthread_create(&amp;tid, NULL, func, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; printf(&quot;main thread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); // sleep(3); pthread_exit((void *)0); return 0;&#125; 五. pthread_join函数 等待线程的结束，线程间同步的操作。以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。 12345 int pthread_join(pthread_t thread, void **retval);// 参数 ：thread: 线程标识符，即线程ID，标识唯一线程。// retval: 用户定义的指针，用来存储被等待线程的返回值。// 返回值 ： 0代表成功。 失败，返回的则是errno。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void testxxx()&#123; // ... printf(&quot;need exit............. [%s][%d] \\n&quot;, __func__, __LINE__); pthread_exit((void *)100);&#125;int test_return()&#123; // .... printf(&quot;need exit ...........................[%s][%d]\\n&quot;, __func__, __LINE__); return 100;&#125;void *func(void *arg)&#123; printf(&quot;child pthread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); printf(&quot;func------------------\\n&quot;); test_return(); testxxx(); printf(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\n&quot;);&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int ret = pthread_create(&amp;tid, NULL, func, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; printf(&quot;main thread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); // sleep(3); int r; ret = pthread_join(tid, &amp;r); if (0 != ret)&#123; fprintf(stderr, &quot;pthread_join error: %s\\n&quot;, strerror(ret)); &#125;else&#123; printf(&quot;r = %d\\n&quot;, (int)r); &#125; printf(&quot;main end\\n&quot;); return 0;&#125; 六. pthread_cancel函数 终止一个线程 123int pthread_cancel(pthread_t thread);// 参数：线程标识符，即线程ID，标识唯一线程。// 返回值：0代表成功。 失败，返回的则是errno。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void *func(void *arg)&#123; while(1)&#123; printf(&quot;child pthread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); sleep(1); &#125; return NULL;&#125;void *fun_1(void *arg)&#123; while(1)&#123; pthread_testcancel(); &#125; return (void *)111;&#125;int main(int argc, const char *argv[]) &#123; pthread_t tid;// int ret = pthread_create(&amp;tid, NULL, func, NULL); int ret = pthread_create(&amp;tid, NULL, fun_1, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; printf(&quot;main thread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); sleep(3); ret = pthread_cancel(tid); if (0 != ret)&#123; fprintf(stderr, &quot;pthread_cancel error: %s\\n&quot;, strerror(ret)); &#125; sleep(1); int r; ret = pthread_join(tid, &amp;r); if (0 != ret)&#123; fprintf(stderr, &quot;pthread_join error: %s\\n&quot;, strerror(ret)); &#125;else&#123; printf(&quot;r = %d\\n&quot;, r); &#125; printf(&quot;main end\\n&quot;); return 0;&#125; 小提示 必须要有系统调用，线程必须到达一个取消点才可以杀死线程。可以主动添加一个取消点：pthread_testcancel(); 七. pthread_detach函数 线程分离函数，线程结束后，直接自动释放，不用主动回收。 123int pthread_detach(pthread_t thread);// 参数：线程标识符，即线程ID，标识唯一线程。// 返回值：0代表成功。 失败，返回的则是errno。 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void *func(void *arg)&#123; int count = 0; while(1)&#123; if (count == 10)&#123; printf(&quot;-----------------------------------\\n&quot;); return NULL; &#125; printf(&quot;child pthread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); sleep(1); count ++; &#125; return NULL;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int ret = pthread_create(&amp;tid, NULL, func, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; ret = pthread_detach(tid); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_detach error: %s\\n&quot;, strerror(ret)); &#125; ret = pthread_join(tid, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_join error: %s\\n&quot;, strerror(ret)); &#125; printf(&quot;main thread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); pthread_exit((void *)0); return 0;&#125; 八. 线程属性pthread_attr_t 做简单了解：通过线程属性设置线程分离 1234567891011121314151617181920212223242526272829303132typedef struct&#123; int etachstate; // 线程的分离状态 int schedpolicy; // 线程的调度策略 struct sched_param schedparam; // 线程的调度参数 int inheritsched; // 线程的继承性 int scope; // 线程的作用域 size_t guardsize; // 线程栈末尾的警戒缓冲区大小 int stackaddr_set; // 线程的栈设置 void * stackaddr; // 线程栈的位置 size_t stacksize; // 线程栈大小&#125;pthread_attr_t;// 线程属性初始化: 成功：0 失败：errnoint pthread_attr_init(pthread_attr_t *attr);// 销毁线程属性所占用的资源: 成功0 失败：errnoint pthread_attr_destroy(pthread_attr_t *attr);// 设置线程属性：是否分离int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);// 获取线程属性：是否分离int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);// detachstate:// PTHREAD_CREATE_DETACHED: 分离线程// PTHREAD_CREATE_JOINABLE： 非分离线程 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void *func(void *arg)&#123; int count = 0; while(1)&#123; if (count == 10)&#123; printf(&quot;-----------------------------------\\n&quot;); return NULL; &#125; printf(&quot;child pthread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); sleep(1); count ++; &#125; return NULL;&#125;int main(int argc, const char *argv[])&#123; pthread_t tid; int ret; pthread_attr_t attr; ret = pthread_attr_init(&amp;attr); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_attr_init error: %s\\n&quot;, strerror(ret)); &#125; ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_attr_setdetachstate error: %s\\n&quot;, strerror(ret)); &#125; ret = pthread_create(&amp;tid, &amp;attr, func, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_create error: %s\\n&quot;, strerror(ret)); return 1; &#125; ret = pthread_detach(tid); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_detach error: %s\\n&quot;, strerror(ret)); &#125; ret = pthread_join(tid, NULL); if (ret != 0)&#123; fprintf(stderr, &quot;pthread_join error: %s\\n&quot;, strerror(ret)); &#125; printf(&quot;main thread: pid = %d tid = %ld\\n&quot;, getpid(), pthread_self()); pthread_exit((void *)0); return 0;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/20.jni方法大全及使用示例/","text":"一、说明这里介绍的函数大多是 NDK 开发中常用的函数，但并不是全部，内容稍多，基本可以满足我们的开发需求了，建议通过目录索引来找需要了解的。这里的函数都是 JNIEnv 操作的相关函数，JNI_OnLoad 等 JavaVM 的方法不在这里介绍。JNI 有 C、C++ 两种代码风格，即： 12C风格：(*env)-&gt;NewStringUTF(env, &quot;Hellow World!&quot;);C++风格：env-&gt;NewStringUTF(&quot;Hellow World!&quot;); 这里我们使用 C++ 风格作为示例。 二、获取版本 jint GetVersion()说明：获取当前 JNI 的版本号返回值： 1234#define JNI_VERSION_1_1 0x00010001#define JNI_VERSION_1_2 0x00010002#define JNI_VERSION_1_4 0x00010004#define JNI_VERSION_1_6 0x00010006 三、类操作 jclass FindClass(const char* name)说明：根据类的全路径找到相应的 jclass 对象参数： name：类的全路径，例如 “Ljava&#x2F;lang&#x2F;String;”示例： 1jclass mStringClass = env-&gt;FindClass(&quot;Ljava/lang/String;&quot;); jclass GetSuperclass(jclass clazz)说明：返回一个类的父类，如果 clazz 是 Object 类，没有父类，那么将返回 NULL参数： jclazz：当前类对象示例： 1jclass clazz = env-&gt;GetSuperclass(mStringClass); // clazz is Ljava/lang/Object; jboolean IsAssignableFrom(jclass clazz1, jclass clazz2)说明：判断类1是否可以安全的强制转换类2参数： clazz1：类1 clazz2：类2 四、对象操作 jobject AllocObject(jclass clazz)说明：不调用构造方法创建实例参数： clazz：指定对象的类 jobject NewObject(jclass clazz, jmethodID methodID, …) jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args) jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)说明：使用指定的构造方法创建类的实例，唯一不同的是输入参数的传入形式不同参数： clazz：指定对象的类 methodID：指定的构造方法 args：输入参数列表 示例： 123jclass rect_clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);jmethodID rect_constructor = env-&gt;GetMethodID(rect_clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);jobject rect = env-&gt;NewObject(rect_clazz, rect_constructor); jclass GetObjectClass(jobject obj)说明：根据对象获取所属类参数： obj：某个 Java 对象实例，不能为 NULL jobjectRefType GetObjectRefType(jobject obj)说明：获取到对象的引用类型，JNI 1.6 新增的方法 参数： obj：某个 Java 对象实例返回： JNIInvalidRefType &#x3D; 0 &#x2F;&#x2F; 该 obj 是个无效的引用 JNILocalRefType &#x3D; 1 &#x2F;&#x2F; 该 obj 是个局部引用 JNIGlobalRefType &#x3D; 2 &#x2F;&#x2F; 该 obj 是个全局引用 JNIWeakGlobalRefType &#x3D; 3 &#x2F;&#x2F; 该 obj 是个全局的弱引用 jboolean IsInstanceOf(jobject obj, jclass clazz)说明：判断某个对象是否是指定类的实例参数： obj：某个 Java 对象实例 clazz：指定的类对象 jboolean IsSameObject(jobject ref1, jobject ref2)说明：判断两个对象的引用是否指向的是相同的 Java 对象参数： ref1：某个 Java 对象的引用1 ref2：某个 Java 对象的引用2 五、域操作 jfieldID GetFieldID(jclass clazz, const char name, const char sig)说明：获取类中某个非静态成员变量的ID（域ID）参数： clazz：指定对象的类 name：这个域（Field）在 Java 类中定义的名字 sig：这个域（Field）的类型描述符示例： 12345jclass clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);jfieldID left_field = env-&gt;GetFieldID(clazz, &quot;left&quot;, &quot;I&quot;);jfieldID top_field = env-&gt;GetFieldID(clazz, &quot;top&quot;, &quot;I&quot;);jfieldID right_field = env-&gt;GetFieldID(clazz, &quot;right&quot;, &quot;I&quot;);jfieldID bottom_field = env-&gt;GetFieldID(clazz, &quot;bottom&quot;, &quot;I&quot;); NativeType Get&lt;type&gt;Field(jobject obj, jfieldID fieldID) 说明：获取实例域的变量值，这里 type 表示的是一系列方法，如下： GetField Routine Name Native Type GetObjectField() jobject GetBooleanField() jboolean GetByteField() jbyte GetCharField() jchar GetShortField() jshort GetIntField() jint GetLongField() jlong GetFloatField() jfloat GetDoubleField() jdouble 参数： obj：某个 Java 对象实例 fieldID：这个变量的域ID示例： 1234jobject rect; // 初始化过程省略jclass clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);jfieldID left_field = env-&gt;GetFieldID(clazz, &quot;left&quot;, &quot;I&quot;);jint left = env-&gt;GetIntField(rect, left_field); void Set&lt;type&gt;Field(jobject obj, jfieldID fieldID, NativeType value)说明：修改实例域的变量值，这里 type 对应上面的 Get 方法，不再累述参数： obj：需要修改的 Java 对象实例 fieldID：这个变量的域ID value：需要设置的值示例： 1234jobject rect; // 初始化过程省略jclass clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);jfieldID left_field = env-&gt;GetFieldID(clazz, &quot;left&quot;, &quot;I&quot;);env-&gt;SetIntField(rect, left_field, 1); jfieldID GetStaticFieldID(jclass clazz, const char name, const char sig)说明：同 GetFieldID，只不过这里操作的是静态的域（Filed） NativeType GetStaticField(jobject obj, jfieldID fieldID)说明：同 GetField，只不过这里操作的是静态的域（Filed） void SetStaticField(jobject obj, jfieldID fieldID, NativeType value)说明：同 SetField，只不过这里操作的是静态的域（Filed） 六、方法操作 jmethodID GetMethodID(jclass clazz, const char name, const char sig)说明：获取类中某个非静态方法的ID 参数： clazz：指定对象的类 name：这个方法在 Java 类中定义的名称，构造方法为 ““ sig：这个方法的类型描述符，例如 “()V”，其中括号内是方法的参数，括号后是返回值类型示例： Java 的类定义如下： 12345678910package com.afei.jnidemo;class Test &#123; public Test()&#123;&#125; public int show(String msg, int number) &#123; System.out.println(&quot;msg: &quot; + msg); System.out.println(&quot;number: &quot; + number); return 0; &#125;&#125; JNI 调用如下： 123jclass clazz = env-&gt;FindClass(&quot;com/afei/jnidemo/Test&quot;);jmethodID constructor_method = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);jmethodID show_method = env-&gt;GetMethodID(clazz, &quot;show&quot;, &quot;(Ljava/lang/String;I)I&quot;); ​ 签名时其中括号内是方法的参数，括号后是返回值类型。例如 show 方法，第一个参数是 String 类，对应 Ljava&#x2F;lang&#x2F;String;（注意后面有一个分号），第二个参数是 int 基本类型，对应的类型描述符是 I，返回值也是 int，同样是 I，所以最终该方法的签名为 “(Ljava&#x2F;lang&#x2F;String;I)I”。 NativeType CallMethod(jobject obj, jmethodID methodID, …) NativeType CallMethodA(jobject obj, jmethodID methodID, jvalue* args) NativeType CallMethodV(jobject obj, jmethodID methodID, va_list args)说明：调用对象的某个方法，唯一不同的是输入参数的传入形式不同，这里 type 表示的是一系列方法，如下： 参数： obj：某个 Java 对象实例 methodID：指定方法的ID args：输入参数列表示例： 123jclass clazz = env-&gt;FindClass(&quot;com/afei/jnidemo/Test&quot;);jmethodID show_method = env-&gt;GetMethodID(clazz, &quot;show&quot;, &quot;(Ljava/lang/String;I)I&quot;);jint result = env-&gt;CallIntMethod(clazz, show_method, &quot;Hello JNI!&quot;, 0); jmethodID GetStaticMethodID(jclass clazz, const char name, const char sig)说明：同 GetMethodID，只不过操作的是静态方法 NativeType CallStaticMethod(jclass clazz, jmethodID methodID, …) NativeType CallStaticMethodA(jclass clazz, jmethodID methodID, jvalue* args) NativeType CallStaticMethodV(jclass clazz, jmethodID methodID, va_list args)说明：同 NativeType CallMethod，只不过操作的是静态方法，参数也由 jobject 变成了 jclass。 七、全局引用和局部引用 jobject NewGlobalRef(jobject obj)说明：创建一个全局引用，不用时必须调用 DeleteGlobalRef() 方法释放。参数： obj：某个 Java 对象实例，可以是局部引用或全局引用示例： 12345jclass mPointFClass; // global reference to PointF class ...jclass clazz = env-&gt;FindClass(&quot;android/graphics/PointF&quot;);mPointFClass = (jclass) env-&gt;NewGlobalRef(clazz); void DeleteGlobalRef(jobject globalRef)说明：释放某个全局引用参数： globalRef：某全局引用 jobject NewLocalRef(jobject ref)说明：创建一个局部引用。这个方法一般很少用。参数： ref：某个引用，可以是全局引用或者局部引用 void DeleteLocalRef(jobject localRef)说明：释放某个局部引用参数： localRef：某局部引用 注意：局部引用在方法执行完后也会自动释放，不过当你在执行一个很大的循环时，里面会产生大量临时的局部引用，那么建议的做法是手动的调用该方法去释放这个局部引用。 jweak NewWeakGlobalRef(jobject obj)说明：创建一个全局的弱引用参数： obj：某个 Java 对象实例 注意：弱引用不会阻止 GC 回收它引用的对象，在内存不足时，弱引用的对象往往会被回收掉，使用时一定要多加小心。 void DeleteWeakGlobalRef(jweak obj)说明：释放某个全局的弱引用参数： obj：某个全局弱引用 八、字符串操作 jstring NewString(const jchar* unicodeChars, jsize len)说明：以 UTF-16 的编码方式创建一个 Java 的字符串（jchar 的定义为 uint16_t）参数： unicodeChars：指向字符数组的指针 len：字符数组的长度 jstring NewStringUTF(const char* bytes)说明：以 UTF-8 的编码方式创建一个 Java 的字符串参数： bytes：指向字符数组的指针 jsize GetStringLength(jstring string) jsize GetStringUTFLength(jstring string)说明：获取字符串的长度，GetStringLength 是 UTF-16 编码，GetStringUTFLength 是 UTF-8 编码参数： string：字符串 const jchar GetStringChars(jstring string, jboolean isCopy) const char GetStringUTFChars(jstring string, jboolean isCopy)说明：将 Java 风格的 jstring 对象转换成 C 风格的字符串，同上一个是 UTF-16 编码，一个是 UTF-8 编码参数： string：Java 风格的字符串 isCopy：是否进行拷贝操作，0 为不拷贝 void ReleaseStringChars(jstring string, const jchar* chars) void ReleaseStringUTFChars(jstring string, const char* utf)说明：释放指定的字符串指针，通常来说，Get 和 Release 是成对出现的参数： string：Java 风格的字符串 chars&#x2F;utf：对应的 C 风格的字符串示例： 123456JNIEXPORT void JNICALLJava_com_afei_jnidemo_MainActivity_test(JNIEnv *env, jobject instance, jstring msg_) &#123; const char *msg = env-&gt;GetStringUTFChars(msg_, 0); // Do Something env-&gt;ReleaseStringUTFChars(msg_, msg);&#125; 九、数组操作 jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement)说明：创建引用数据类型的数组参数： length：数组的长度 elementClass：数组的元素所属的类 initialElement：使用什么样的对象来初始化，可以选择 NULL示例： 123int points_count = 21;jclass pointFClass = env-&gt;FindClass(&quot;android/graphics/PointF&quot;);jobjectArray point_array = env-&gt;NewObjectArray(points_count, pointFClass, NULL); 2.ArrayType NewArray(jsize length)说明：创建基本数据类型的数组。这里的基本数据类型有： 参数： length：数组的长度 jsize GetArrayLength(jarray array)说明：获取数组的长度参数： array：指定的数组对象。jarray 是 jbooleanArray、jbyteArray、jcharArray 等的父类。 jobject GetObjectArrayElement(jobjectArray array, jsize index)说明：获取引用数据类型数组指定索引位置处的对象参数： array：引用数据类型数组 index：目标索引值 void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)说明：设置引用数据类型数组指定索引位置处的值参数： array：需要设置的引用数据类型数组 index：目标索引值 value：需要设置的值 NativeType GetArrayElements(ArrayType array, jboolean isCopy)说明：获取基本数据类型数组的头指针参数： array：基本数据类型数组 isCopy：是否进行拷贝操作，0 为不拷贝 void ReleaseArrayElements(ArrayType array, NativeType* elems, jint mode)说明：释放基本数据类型数组指针。通常来说，Get 和 Release 是成对出现的参数： array：基本数据类型数组 elems：对应的 C 风格的基本数据类型指针 mode：释放模式，通常我们都是使用 0，有三种，如下 示例： 12345Java_com_afei_jnidemo_MainActivity_test(JNIEnv *env, jobject instance, jintArray array_) &#123; jint *array = env-&gt;GetIntArrayElements(array_, 0); // Do Something env-&gt;ReleaseIntArrayElements(array_, array, 0);&#125; void GetArrayRegion(ArrayType array, jsize start, jsize len, NativeType* buf)说明：返回基本数据类型数组的部分副本。这里的基本数据类型有： 参数： array：基本数据类型数组 start：起始的索引值 len：拷贝的长度 buf：拷贝到的目标数组 void SetArrayRegion(ArrayType array, jsize start, jsize len, const NativeType* buf)说明：设置基本数据类型数组元素。类型和上面的表类似。参数： array：需要设置的基本数据类型数组 start：起始的索引值 len：需要设置的 buf 的长度 buf：需要设置的值数组 十、异常操作 jint Throw(jthrowable obj)说明：抛出一个异常，需要手动创建异常的实例，调用较复杂，一般不使用这个方法参数： obj：异常对象示例： 123456789jclass ioExceptionClazz = env-&gt;FindClass(&quot;java/io/IOException&quot;);jmethodID ioExceptionConstructor = env-&gt;GetMethodID(ioExceptionClazz, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);jthrowable exceptionObj = static_cast&lt;jthrowable&gt;(env-&gt;NewObject(ioExceptionClazz, ioExceptionConstructor, &quot;IO异常&quot;));if (env-&gt;Throw(exceptionObj) == JNI_OK) &#123; // 创建成功&#125; else &#123; // 创建失败&#125; jint ThrowNew(jclass clazz, const char* message)说明：抛出一个异常。使用起来比三个方法方便参数： clazz：指定的异常类 message：异常信息示例： if (env-&gt;ThrowNew(env-&gt;FindClass(“java&#x2F;io&#x2F;IOException”), “IO异常”) &#x3D;&#x3D; JNI_OK) { &#x2F;&#x2F; 创建成功 } else { &#x2F;&#x2F; 创建失败 } jthrowable ExceptionOccurred() jboolean ExceptionCheck()说明：检查是否有异常，如果本地函数有异常抛出，ExceptionOccurred 会返回这个异常的示例，ExceptionCheck 只返回是否有异常 void ExceptionDescribe()说明：将异常和堆栈信息推送到错误流 void ExceptionClear()说明：清除掉发生的异常 以上几个方法的示例： Java 部分代码为： public class MainActivity extends AppCompatActivity &#123; static &#123; System.loadLibrary(&quot;native-lib&quot;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); try &#123; test(); &#125; catch (Exception e) &#123; Log.e(&quot;MainActivity&quot;, &quot;onCreate: &quot; + e); &#125; &#125; private native void test() throws IllegalArgumentException; private void callNullPointerException() throws NullPointerException &#123; throw new NullPointerException(&quot;MainActivity NullPointerException&quot;); &#125; &#125; JNI 部分代码为： 123456789101112131415JNIEXPORT void JNICALLJava_com_afei_jnidemo_MainActivity_test(JNIEnv *env, jobject instance) &#123; jclass clazz = env-&gt;GetObjectClass(instance); jmethodID mid =env-&gt;GetMethodID(clazz, &quot;callNullPointerException&quot;, &quot;()V&quot;); env-&gt;CallVoidMethod(instance, mid); // will throw a NullPointerException jthrowable exc = env-&gt;ExceptionOccurred(); // 检测是否发生异常 if (exc) &#123; LOGD(&quot;============&quot;); env-&gt;ExceptionDescribe(); // 打印异常信息 LOGD(&quot;============&quot;); env-&gt;ExceptionClear(); // 清除掉发生的异常 jclass newExcCls = env-&gt;FindClass(&quot;java/lang/IllegalArgumentException&quot;); env-&gt;ThrowNew(newExcCls, &quot;throw from JNI&quot;); // 返回一个新的异常到 Java &#125;&#125; 运行结果为： 1234567891011121314151617181907-12 14:57:07.443 26623-26623/com.afei.jnidemo D/FaceAPI: ============07-12 14:57:07.443 26623-26623/com.afei.jnidemo W/System.err: java.lang.NullPointerException: MainActivity NullPointerException at com.afei.jnidemo.MainActivity.callNullPointerException(MainActivity.java:34) at com.afei.jnidemo.MainActivity.test(Native Method) at com.afei.jnidemo.MainActivity.onCreate(MainActivity.java:25) at android.app.Activity.performCreate(Activity.java:6857) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1125) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2702) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2810) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1532) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:181) at android.app.ActivityThread.main(ActivityThread.java:6288) at java.lang.reflect.Method.invoke(Native Method)07-12 14:57:07.443 26623-26623/com.afei.jnidemo W/System.err: at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:900) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:790)07-12 14:57:07.443 26623-26623/com.afei.jnidemo D/FaceAPI: ============07-12 14:57:07.444 26623-26623/com.afei.jnidemo E/MainActivity: onCreate: java.lang.IllegalArgumentException: throw from JNI void FatalError(const char* msg)说明：抛出一个致命异常，并且不希望JVM处理参数： msg：致命异常的信息 十一、其它 其他还有有关 Monitor Operations、NIO Support、Reflection Support 等一些方法，由于我也没使用过，就不再这里解释了。 可以参考 JNI 的官网的介绍：https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502 原文链接：JNI 方法大全及使用示例-CSDN博客","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/9.函数签名及ndk调用java方法/","text":"基础知识 1.1 访问域 Java有两类域：实例域和静态域。类的每个实例都有自己的实例域副本，而每个类的所有实例共享同一个静态域。 了解Java的都知道，在一个类加载器中，类的class只有一个，但可以有很多类的实例对象。所以在我们使用JNI访问Java的方法时，会有两种不同的方法。 1.2 域ID 在前面章节中我们讲解了Java调用jni的方法，Java调用jni方法只需要注意函数的命名规则即可，但在jni访问Java的方法时需要获得访问域的ID，访问域有两种，同样，域ID也有两种。一种是静态域ID，一种是实例域ID,如下所示： 1.2.1 获取类 1.2.1.1 用对象引用获得jclass 通过传入Java对象（jobject类型变量），获取Java类对象。 12jclass clazz;clazz = env-&gt;GetObjectClass(env, instance); 1.2.1.2 通过包名类名获取jclass 通过传入完整的包名&#x2F;类名获取java类对应的C&#x2F;C++环境下的jclass类型的变量，返回值：Java字节码class对象，对应C++中的jclass对象。注意：包名中的 . 使用 &#x2F; 来替代 12jclass clazz;clazz = env-&gt;FindClass(&quot;com/jiangc/jni/TestJni&quot;); 1.3 签名规则 以下是签名规则，在jni的环境中调用Java的方法或者获取Field时，需要用到签名，签名规则如下： java 类型 签名 Boolean Z Byte B Char C Short S Int I Long J Float F Double D fully-qualified-class Lfully-qualified-class type[] [type method type (arg-type)ret-type 例子： 12345678910111213141516171819package com.example.javap;public class TestJni &#123; static &#123; System.loadLibrary(&quot;javap&quot;); &#125; // ()Ljava/lang/String public native String HelloWorld(); // (II)I public int add(int a, int b)&#123; return a + b; &#125; // ()Z public boolean isTrue()&#123; return true; &#125;&#125; 1.3.1 使用javap生成函数签名 123456789101112131415161718192021221.javac TestJni.java2.javap -s -p -classpatch . TestJnijavap -s -p -classpath . TestJni警告: 文件 .\\TestJni.class 不包含类 TestJniCompiled from &quot;TestJni.java&quot;public class com.example.javap.TestJni &#123; public com.example.javap.TestJni(); descriptor: ()V public native java.lang.String HelloWorld(); descriptor: ()Ljava/lang/String; public int add(int, int); descriptor: (II)I public boolean isTrue(); descriptor: ()Z static &#123;&#125;; descriptor: ()V&#125; 1.4 设置Android Studio javap 打开Android Studio ，File-&gt;Settings-&gt;Tools-&gt;External Tools扩展工具栏，如下图： 点击+号按钮 填写信息如下： 123Program: javap的绝对路径Arguments：-s -p $FileClass$Working directory: $OutputPath$ 首先编译一下项目，然后通过右键javap获取函数签名 获取到的签名如下： 这样我们就可以相对比较快捷的得到函数签名了。 二. 通过jni访问java方法 2.1 调用实例对象的方法 12345678910111213141516171819202122232425262728293031extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_example_javap_TestJni_HelloWorld(JNIEnv *env, jobject thiz) &#123; jmethodID jmethodId; jclass clazz = env-&gt;GetObjectClass(thiz); if (nullptr == clazz) &#123; LOGE(&quot;jclass is null\\n&quot;); &#125; //GetMethodID()获取java方法，GetMethodID(类,方法名,方法签名) jmethodId = env-&gt;GetMethodID(clazz, &quot;add&quot;, &quot;(II)I&quot;); jint result; result = env-&gt;CallIntMethod(thiz, jmethodId, 1, 2); LOGE(&quot;result = %d\\n&quot;, result); std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_example_javap_TestJni_callStaticFunc(JNIEnv *env, jobject thiz) &#123; jclass clazz; // com.example.javap clazz = env-&gt;FindClass(&quot;com/example/javap/TestJni&quot;); jmethodID jmethodId = env-&gt;GetStaticMethodID(clazz, &quot;sAdd&quot;, &quot;(II)I&quot;); jint result = env-&gt;CallStaticIntMethod(clazz, jmethodId, 1, 2); LOGE(&quot;call static result : %d\\n&quot;, result);&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/8.mqtt/","text":"MQTT 源码移植 目标 在应用层使用mqtt库和平台通信。 移植原因 mqtt java端接口匮乏，不能定制 一. 源码下载 1git clone https://github.com/eclipse/paho.mqtt.c.git 主要用的就是paho.mqtt.c 是C语言实现的一个库，也有Java的，本次移植主要是基于C端，原因就是更为灵活。 二. 新建一个Android Studio工程 模块化考虑，在新建的工程里新建一个Android Native module，用于封装mqtt的库，提供java接口,目录结构如下图 三. 参考源码提供的Android.mk Android.mk的主要内容，对于应用层的移植，我们需要根据这个文件转换成CMakeList.txt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 通用源文件列表，每个库都会依赖libpaho-mqtt3_local_src_c_files_common := \\ $(libpaho-mqtt3_lib_path)/MQTTProtocolClient.c \\ $(libpaho-mqtt3_lib_path)/Tree.c \\ $(libpaho-mqtt3_lib_path)/Heap.c \\ $(libpaho-mqtt3_lib_path)/MQTTPacket.c \\ $(libpaho-mqtt3_lib_path)/Clients.c \\ $(libpaho-mqtt3_lib_path)/Thread.c \\ $(libpaho-mqtt3_lib_path)/utf-8.c \\ $(libpaho-mqtt3_lib_path)/StackTrace.c \\ $(libpaho-mqtt3_lib_path)/MQTTProtocolOut.c \\ $(libpaho-mqtt3_lib_path)/Socket.c \\ $(libpaho-mqtt3_lib_path)/Log.c \\ $(libpaho-mqtt3_lib_path)/Messages.c \\ $(libpaho-mqtt3_lib_path)/LinkedList.c \\ $(libpaho-mqtt3_lib_path)/MQTTPersistence.c \\ $(libpaho-mqtt3_lib_path)/MQTTPacketOut.c \\ $(libpaho-mqtt3_lib_path)/SocketBuffer.c \\ $(libpaho-mqtt3_lib_path)/MQTTPersistenceDefault.c \\ # 下面是声明的文件列表，分别用于生成不同的库# libpaho-mqtt3_local_src_c_files_c 文件列表libpaho-mqtt3_local_src_c_files_c := \\ $(libpaho-mqtt3_lib_path)/MQTTClient.c \\# libpaho-mqtt3_local_src_c_files_cs 文件列表libpaho-mqtt3_local_src_c_files_cs := \\ $(libpaho-mqtt3_lib_path)/MQTTClient.c \\ $(libpaho-mqtt3_lib_path)/SSLSocket.c \\# libpaho-mqtt3_local_src_c_files_a 文件列表libpaho-mqtt3_local_src_c_files_a := \\ $(libpaho-mqtt3_lib_path)/MQTTAsync.c \\# libpaho-mqtt3_local_src_c_files_as 文件列表libpaho-mqtt3_local_src_c_files_as := \\ $(libpaho-mqtt3_lib_path)/MQTTAsync.c \\ $(libpaho-mqtt3_lib_path)/SSLSocket.c \\######################################### 静态库 #####################################################.......................................................................................................######################################### 动态库 ###################################################### libpaho-mqtt3cinclude $(CLEAR_VARS)LOCAL_MODULE := libpaho-mqtt3cLOCAL_SHARED_LIBRARIES := libdlLOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/$(libpaho-mqtt3_lib_path)LOCAL_C_INCLUDES:= $(libpaho-mqtt3_c_includes)LOCAL_SRC_FILES := $(libpaho-mqtt3_local_src_c_files_common) $(libpaho-mqtt3_local_src_c_files_c)include $(BUILD_SHARED_LIBRARY)# libpaho-mqtt3csinclude $(CLEAR_VARS)LOCAL_MODULE := libpaho-mqtt3csLOCAL_SHARED_LIBRARIES := libcrypto libssl libdlLOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/$(libpaho-mqtt3_lib_path)LOCAL_C_INCLUDES:= $(libpaho-mqtt3_c_includes)LOCAL_CFLAGS += -DOPENSSLLOCAL_SRC_FILES := $(libpaho-mqtt3_local_src_c_files_common) $(libpaho-mqtt3_local_src_c_files_cs)include $(BUILD_SHARED_LIBRARY)# libpaho-mqtt3ainclude $(CLEAR_VARS)LOCAL_MODULE := libpaho-mqtt3aLOCAL_SHARED_LIBRARIES := libdlLOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/$&#123;libpaho-mqtt3_lib_path&#125;LOCAL_C_INCLUDES:= $(libpaho-mqtt3_c_includes)LOCAL_SRC_FILES := $(libpaho-mqtt3_local_src_c_files_common) $(libpaho-mqtt3_local_src_c_files_a)include $(BUILD_SHARED_LIBRARY)# libpaho-mqtt3asinclude $(CLEAR_VARS)LOCAL_MODULE := libpaho-mqtt3asLOCAL_SHARED_LIBRARIES := libcrypto libssl libdlLOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/$&#123;libpaho-mqtt3_lib_path&#125;LOCAL_CFLAGS += -DOPENSSLLOCAL_C_INCLUDES:= $(libpaho-mqtt3_c_includes)LOCAL_SRC_FILES := $(libpaho-mqtt3_local_src_c_files_common) $(libpaho-mqtt3_local_src_c_files_as)include $(BUILD_SHARED_LIBRARY) 基本上，Android.mk中的重点就是上面的描述了，包含了几个模块： 1231. 通用源码列表2. 不同库的源码列表3. 生成不同库的依赖 库的作用如下： 1234paho-mqtt3a ： 一般实际开发中就是使用这个，a表示的是异步消息推送（asynchronous）。paho-mqtt3as ： as表示的是 异步+加密（asynchronous+OpenSSL）。paho-mqtt3c ： c 表示的应该是同步（Synchronize），一般性能较差，是发送+等待模式。paho-mqtt3cs ： cs表示的是同步+加密（asynchronous+OpenSSL）。 转换成CMakeLists如下：这是最终的CMakeList.txt，具体的过程，请继续往下看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html.# For more examples on how to use CMake, see https://github.com/android/ndk-samples.# Sets the minimum CMake version required for this project.cmake_minimum_required(VERSION 3.22.1)# Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,# Since this is the top level CMakeLists.txt, the project name is also accessible# with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level# build script scope).project(&quot;mqtt&quot;)message(&quot;openssl/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;/include&quot;)# 包含子目录相关头文件include_directories(mqttsrc)# 通用源文件set(libpaho-mqtt3_local_src_c_files_common mqttsrc/MQTTProtocolClient.c mqttsrc/Tree.c mqttsrc/Heap.c mqttsrc/MQTTPacket.c mqttsrc/Clients.c mqttsrc/Thread.c mqttsrc/utf-8.c mqttsrc/StackTrace.c mqttsrc/MQTTProtocolOut.c mqttsrc/Socket.c mqttsrc/Log.c mqttsrc/Messages.c mqttsrc/LinkedList.c mqttsrc/MQTTPersistence.c mqttsrc/SocketBuffer.c mqttsrc/MQTTPersistenceDefault.c mqttsrc/MQTTProperties.c mqttsrc/MQTTTime.c mqttsrc/MQTTPacketOut.c mqttsrc/WebSocket.c mqttsrc/Base64.c mqttsrc/Proxy.c mqttsrc/SHA1.c )# libpaho-mqtt3_local_src_c_files_cset(libpaho-mqtt3_local_src_c_files_c mqttsrc/MQTTClient.c )# libpaho-mqtt3_local_src_c_files_csset(libpaho-mqtt3_local_src_c_files_cs mqttsrc/MQTTClient.c mqttsrc/SSLSocket.c )# libpaho-mqtt3_local_src_c_files_aset(libpaho-mqtt3_local_src_c_files_a mqttsrc/MQTTAsyncUtils.c mqttsrc/MQTTAsync.c )# libpaho-mqtt3_local_src_c_files_asset(libpaho-mqtt3_local_src_c_files_as mqttsrc/MQTTAsyncUtils.c mqttsrc/MQTTAsync.c mqttsrc/SSLSocket.c )# 导入预编译库# cryptoadd_library(crypto SHARED IMPORTED)set_target_properties(crypto PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;/libcrypto.so)## openssladd_library(openssl SHARED IMPORTED)set_target_properties(openssl PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;/libssl.so)add_library(libpaho-mqtt3c SHARED $&#123;libpaho-mqtt3_local_src_c_files_common&#125; $&#123;libpaho-mqtt3_local_src_c_files_c&#125; )target_link_libraries(libpaho-mqtt3c dl)add_library(libpaho-mqtt3cs SHARED $&#123;libpaho-mqtt3_local_src_c_files_common&#125; $&#123;libpaho-mqtt3_local_src_c_files_cs&#125; )target_link_libraries(libpaho-mqtt3cs openssl dl)add_library(libpaho-mqtt3a SHARED $&#123;libpaho-mqtt3_local_src_c_files_common&#125; $&#123;libpaho-mqtt3_local_src_c_files_a&#125; )target_link_libraries(libpaho-mqtt3a dl)#add_library(libpaho-mqtt3as SHARED $&#123;libpaho-mqtt3_local_src_c_files_common&#125; $&#123;libpaho-mqtt3_local_src_c_files_as&#125; )target_link_libraries(libpaho-mqtt3as openssl dl)#add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. $&#123;SOURCE_FILES&#125; mqtt.cpp)target_include_directories(mqtt PUBLIC openssl/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;/include)#target_link_libraries(mqtt libpaho-mqtt3c libpaho-mqtt3cs libpaho-mqtt3a libpaho-mqtt3as dl crypto openssl android log) 四. openssl编译 保存下面内容为mkssl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/bin/shwhile getopts n:o:a:t:d:h: optiondo case &quot;$&#123;option&#125;&quot; in n) ANDROID_NDK=$&#123;OPTARG&#125;;; o) OPENSSL_VERSION=$&#123;OPTARG&#125;;; a) API_LEVEL=$&#123;OPTARG&#125;;; t) BUILD_TARGETS=$&#123;OPTARG&#125;;; d) OUT_DIR=$&#123;OPTARG&#125;;; h) HOST_TAG=$&#123;OPTARG&#125;;; *) twentytwo=$&#123;OPTARG&#125;;; esacdoneecho &quot;ANDROID_NDK = $ANDROID_NDK&quot;echo &quot;OPENSSL_VERSION= $OPENSSL_VERSION&quot;echo &quot;API_LEVEL = $API_LEVEL&quot;echo &quot;BUILD_TARGETS = $BUILD_TARGETS&quot;echo &quot;OUT_DIR= $OUT_DIR&quot;echo &quot;HOST_TAG = $HOST_TAG&quot;echo &quot;twentytwo=$twentytwo&quot;BUILD_DIR=/tmp/openssl_android_buildif [ ! -d openssl-$&#123;OPENSSL_VERSION&#125; ]then if [ ! -f openssl-$&#123;OPENSSL_VERSION&#125;.tar.gz ] then wget https://www.openssl.org/source/openssl-$&#123;OPENSSL_VERSION&#125;.tar.gz || exit 128 fi tar xzf openssl-$&#123;OPENSSL_VERSION&#125;.tar.gz || exit 128ficd openssl-$&#123;OPENSSL_VERSION&#125; || exit 128##### export ndk directory. Required by openssl-build-scripts #####case $&#123;OPENSSL_VERSION&#125; in 1.1.1*) export ANDROID_NDK_HOME=$ANDROID_NDK ;; *) export ANDROID_NDK_ROOT=$ANDROID_NDK ;;esacexport PATH=$ANDROID_NDK/toolchains/llvm/prebuilt/$HOST_TAG/bin:$PATH##### build-function #####build_the_thing() &#123; make clean ./Configure $SSL_TARGET -D__ANDROID_API__=$API_LEVEL &amp;&amp; \\ make -j128 SHLIB_EXT=.so &amp;&amp; \\ make install SHLIB_EXT=.so DESTDIR=$DESTDIR || exit 128&#125;##### set variables according to build-tagret #####for build_target in $BUILD_TARGETSdo case $build_target in armeabi-v7a) DESTDIR=&quot;$BUILD_DIR/armeabi-v7a&quot; SSL_TARGET=&quot;android-arm&quot; ;; x86) DESTDIR=&quot;$BUILD_DIR/x86&quot; SSL_TARGET=&quot;android-x86&quot; ;; x86_64) DESTDIR=&quot;$BUILD_DIR/x86_64&quot; SSL_TARGET=&quot;android-x86_64&quot; ;; arm64-v8a) DESTDIR=&quot;$BUILD_DIR/arm64-v8a&quot; SSL_TARGET=&quot;android-arm64&quot; ;; esac rm -rf $DESTDIR build_the_thing#### copy libraries and includes to output-directory ##### mkdir -p $OUT_DIR/$build_target/include cp -R $DESTDIR/usr/local/include/* $OUT_DIR/$build_target/include cp -R $DESTDIR/usr/local/ssl/* $OUT_DIR/$build_target/ mkdir -p $OUT_DIR/$build_target/lib cp -R $DESTDIR/usr/local/lib/*.so $OUT_DIR/$build_target/lib cp -R $DESTDIR/usr/local/lib/*.a $OUT_DIR/$build_target/libdoneecho Success chmod 777 mkssl 执行命令编译: 例如 1./mkssl -n /data/android/Sdk/ndk/25.2.9519653 -a 21 -t &quot;armeabi-v7a&quot; -o 1.1.1l -d ./ -h linux-x86_64 根据不同的需求更改-t 后面的参数,例如x86 1./mkssl -n /data/android/Sdk/ndk/25.2.9519653 -a 21 -t &quot;x86&quot; -o 1.1.1l -d ./ -h linux-x86_64 脚本的参数含义如下： 1234567891011-n： NDK的根目录-a：ABI 的级别-t：ABI-o：openssl的版本-d：输出目录-h：host的架构 五. 拷贝动态库到指定目录 参考第一张图，将openssl生成的动态库拷贝到mqtt目录下的libs中 六. 拷贝头文件 参考第一张图，将openssl生成的头文件拷贝到cpp中 七. 在cmake中包含这些头文件 关键语法如下：这句话的意思就是编译的时候根据不同的ABI去引用不同的头文件，我们这里包含了四个ABI的头文件 1target_include_directories(mqtt PUBLIC openssl/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;/include) 八. 编译就行了 九. 封装待续…….","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/7.mmkv编译/","text":"MMKV简介 12MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。近期也已移植到 Android / macOS / Win32 / POSIX 平台，一并开源。 github地址：https://github.com/Tencent/MMKV 通过github的中文文档查看编译指导：https://github.com/Tencent/MMKV/blob/master/README_CN.md 直接查看POSIX 指南（POSIX是可移植操作系统接口是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称） POSIX 安装指南原文： 12345678910111213141516171819202122232425262728POSIX 安装指南基本要求MMKV 支持 Linux(Ubuntu, Arch Linux, CentOS, Gentoo)、Unix(macOS, FreeBSD, OpenBSD) 等 POSIX 平台；MMKV 需使用 CMake 3.8.0 或以上进行编译；C++ 编译器需支持 C++ 17 标准。通过 CMake 安装引入获取 MMKV 源码:git clone https://github.com/Tencent/MMKV.git打开你项目的 CMakeLists.txt, 添加这几行:add_subdirectory(mmkv/POSIX/src mmkv)target_link_libraries(MyApp mmkv)添加头文件 #include &quot;MMKV.h&quot;，就可以愉快地开始你的 MMKV 之旅了。注意：你也可以编译运行 demo 工程来测试 MMKV：cd mmkv/POSIXmkdir buildcd buildcmake -DCMAKE_BUILD_TYPE=Release ..makecd demo &amp;&amp; ./demoMMKV 依赖 zlib 库。如果你的系统没有安装 zlib1g-dev 库也不用担心，MMKV 会使用内置的精简版(zlib v1.2.11)。如果你确定不需要加密功能，你可以在Core/MMKVPredef.h 文件中打开宏MMKV_DISABLE_CRYPT，以减小一些二进制大小。 简略编译过程（将mmkv源码引入 ndk编译） 123451. git clone https://github.com/Tencent/MMKV.git2. 创建一个空的Android 工程3. 创建一个moudle，选择Android Native Livrary4. 将mmkv中的Core目录直接复制到新建的moudle中5. 修改CMakeList.txt 关键部分如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html.# For more examples on how to use CMake, see https://github.com/android/ndk-samples.# Sets the minimum CMake version required for this project.cmake_minimum_required(VERSION 3.22.1)# Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,# Since this is the top level CMakeLists.txt, the project name is also accessible# with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level# build script scope).project(&quot;mmkv&quot;)# 添加头文件,方便自己的源码中引用Core下的头文件include_directories(Core)# 添加mmkv的子CMakeList,在编译时会首先执行子目录的CMakeListadd_subdirectory(Core)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.## In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define# the target library name; in the sub-module&#x27;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;# is preferred for the same purpose.## In order to load a library into your app from Java/Kotlin, you must call# System.loadLibrary() and pass the name of the library defined here;# for GameActivity/NativeActivity derived applications, the same library name must be# used in the AndroidManifest.xml file.add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. # 添加源文件，这个源文件可加可不加，随意 libmmkv.cpp mmkv.cpp)# Specifies libraries CMake should link to your target library. You# can link libraries from various origins, such as libraries defined in this# build script, prebuilt third-party libraries, or Android system libraries.target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; mmkv core # pthread 这里注意，不能链接pthread，在NDK中使用stdc++ stdc++ # List libraries link to the target library android log) 然后直接编译项目即可，具体封装可按照mmkv的api文档进行。详细内容可直接给项目导入Android studio查看","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/6.libusb/","text":"libusb简介 1234libusb 是一个 C 库，提供对 USB 设备的通用访问。开发人员旨在使用它来促进与 USB 硬件通信的应用程序的生产。它是可移植的：使用单个跨平台 API，它提供对 Linux、macOS、Windows 等 USB 设备的访问它是用户模式：应用程序与设备通信不需要特殊权限或提升权限。它与版本无关：支持从 1.0 到 3.1（最新）的所有 USB 协议版本。 官网：https://libusb.info/ 仓库：https://github.com/libusb/libusb/tree/master git clone https://github.com/libusb/libusb.git 编译 官方的android目录下的编译指导文档原文： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152libusb for Android==================Building:---------To build libusb for Android do the following: 1. Download the latest NDK from: http://developer.android.com/tools/sdk/ndk/index.html 2. Extract the NDK. 3. Open a shell and make sure there exist an NDK global variable set to the directory where you extracted the NDK. 4. Change directory to libusb&#x27;s &quot;android/jni&quot; 5. Run &quot;$NDK/ndk-build&quot;.The libusb library, examples and tests can then be found in: &quot;android/libs/$ARCH&quot;Where $ARCH is one of: armeabi armeabi-v7a mips mips64 x86 x86_64Installing:-----------If you wish to use libusb from native code in own Android applicationthen you should add the following line to your Android.mk file: include $(PATH_TO_LIBUSB_SRC)/android/jni/libusb.mkYou will then need to add the following lines to the buildconfiguration for each native binary which uses libusb: LOCAL_C_INCLUDES += $(LIBUSB_ROOT_ABS) LOCAL_SHARED_LIBRARIES += libusb1.0The Android build system will then correctly include libusb in theapplication package (APK) file, provided ndk-build is invoked beforethe package is built.Runtime Permissions:--------------------The Runtime Permissions on Android can be transferred from Java to Nativeover the following approach: JAVA: --&gt; Obtain USB permissions over the android.hardware.usb.UsbManager class usbManager = (UsbManager) getSystemService(Context.USB_SERVICE); HashMap&lt;String, UsbDevice&gt; deviceList = usbManager.getDeviceList(); for (UsbDevice usbDevice : deviceList.values()) &#123; usbManager.requestPermission(usbDevice, mPermissionIntent); &#125; --&gt; Get the native FileDescriptor of the UsbDevice and transfer it to Native over JNI or JNA UsbDeviceConnection usbDeviceConnection = usbManager.openDevice(camDevice); int fileDescriptor = usbDeviceConnection.getFileDescriptor(); --&gt; JNA sample method: JNA.INSTANCE.set_the_native_Descriptor(fileDescriptor); NATIVE: --&gt; Initialize libusb on Android set_the_native_Descriptor(int fileDescriptor) &#123; libusb_context *ctx; libusb_device_handle *devh; libusb_set_option(&amp;ctx, LIBUSB_OPTION_NO_DEVICE_DISCOVERY, NULL); libusb_init(&amp;ctx); libusb_wrap_sys_device(NULL, (intptr_t)fileDescriptor, &amp;devh); &#125; /* From this point you can regularly use all libusb functions as usual */ About LIBUSB_OPTION_NO_DEVICE_DISCOVERY: The method libusb_set_option(&amp;ctx, LIBUSB_OPTION_NO_DEVICE_DISCOVERY, NULL) does not affect the ctx. It allows initializing libusb on unrooted Android devices by skipping the device enumeration.Rooted Devices:--------------- For rooted devices the code using libusb could be executed as root using the &quot;su&quot; command. An alternative would be to use the &quot;su&quot; command to change the permissions on the appropriate /dev/bus/usb/ files. Users have reported success in using android.hardware.usb.UsbManager to request permission to use the UsbDevice and then opening the device. The difficulties in this method is that there is no guarantee that it will continue to work in the future Android versions, it requires invoking Java APIs and running code to match each android.hardware.usb.UsbDevice to a libusb_device. For a rooted device it is possible to install libusb into the system image of a running device: 1. Enable ADB on the device. 2. Connect the device to a machine running ADB. 3. Execute the following commands on the machine running ADB: # Make the system partition writable adb shell su -c &quot;mount -o remount,rw /system&quot; # Install libusb adb push obj/local/armeabi/libusb1.0.so /sdcard/ adb shell su -c &quot;cat &gt; /system/lib/libusb1.0.so &lt; /sdcard/libusb1.0.so&quot; adb shell rm /sdcard/libusb1.0.so # Install the samples and tests for B in listdevs fxload xusb sam3u_benchmark hotplugtest stress do adb push &quot;obj/local/armeabi/$B&quot; /sdcard/ adb shell su -c &quot;cat &gt; /system/bin/$B &lt; /sdcard/$B&quot; adb shell su -c &quot;chmod 0755 /system/bin/$B&quot; adb shell rm &quot;/sdcard/$B&quot; done # Make the system partition read only again adb shell su -c &quot;mount -o remount,ro /system&quot; # Run listdevs to adb shell su -c &quot;listdevs&quot; 4. If your device only has a single OTG port then ADB can generally be switched to using Wifi with the following commands when connected via USB: adb shell netcfg # Note the wifi IP address of the phone adb tcpip 5555 # Use the IP address from netcfg adb connect 192.168.1.123:5555 执行编译 1.cd libusb 2.cd android/jni 3.找到自己的ndk目录，例如下面直接使用绝对路径 /home/tyl/Android/Sdk/ndk/26.1.10909125 4./home/tyl/Android/Sdk/ndk/26.1.10909125/ndk-build 5.生成的so文件在libusb/android/libs中 编译好的库可以直接集成到Android中了。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/5.OPUS编译/","text":"opus官网：https://opus-codec.org github:https://github.com/xiph/opus opus简介 12Opus 是一个完全开放、免版税、高度通用的音频编解码器。Opus 在互动方面无与伦比 通过互联网传输语音和音乐，但也用于存储和流式传输应用。它被互联网工程任务组 （IETF） 标准化为 RFC 6716，它结合了 Skype 的 SILK 编解码器和 Xiph.Org 的 CELT 编解码器的技术; 下载opus 1231.官网download页面找到Source code: opus-1.4.tar.gz，点击后自动下载2.通过github的cmake页面内的指南:git clone https://gitlab.xiph.org/xiph/opus（https://github.com/xiph/opus/tree/master/cmake） 编译opus 123456789101112通过查看cmake内的编译介绍1.cd opus2.mkdir build3.cd build4.cmake .. -DCMAKE_TOOLCHAIN_FILE=/home/tyl/Android/Sdk/ndk/26.1.10909125/build/cmake/android.toolchain.cmake -DANDROID_ABI=arm64-v8a//需要修改为本机的ndk路径，执行成功5.make //执行完成后在build目录中就会看到libopus.a//如果需要so文件则需要进行配置 -DOPUS_BUILD_SHARED_LIBRARY=y 6.cmake .. -DCMAKE_TOOLCHAIN_FILE=/home/tyl/Android/Sdk/ndk/26.1.10909125/build/cmake/android.toolchain.cmake -DANDROID_ABI=arm64-v8a -DOPUS_BUILD_SHARED_LIBRARY=y7.make//执行完毕后build目录下可以看到libopus.so文件 自建编译脚本android.sh (自定义名字) 12345678910111213141516171819202122232425262728#!/bin/bash# 每次编译删除原来的编译文件rm build -rfrm install -rf# 创建临时编译目录，避免污染源文件mkdir build# 定义一个数组，存储架构类型，用来循环编译ARCH_ARRAY=(armeabi-v7a arm64-v8a x86 x86_64)mkdir installcd buildfor item in &quot;$&#123;ARCH_ARRAY【@】&#125;&quot;; do mkdir -p install/$item echo &quot;$item&quot; echo &quot;$ANDROID_HOME&quot; rm * -rf cmake .. \\ -DCMAKE_TOOLCHAIN_FILE=$&#123;ANDROID_HOME&#125;/ndk/26.1.10909125/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=$item \\ -DOPUS_BUILD_SHARED_LIBRARY=y make -j8 mkdir -p ../install/$item mv *.so ../install/$item/done# 拷贝头文件到安装目录cp ../include -rf ../install","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/4.JavaVM/","text":"一. NDK开发之JavaVM ​ JNI定义了两个关键数据结构，一个是JavaVM，一个是JNIEnv,在前面我们看jni.h的时候也看到了，只是没有仔细查看他们的定义，这里先看第一个JavaVM，本质上，JavaVM是一个指向函数表的二级指针(在C++版本中，它们是一些类，这些类具有指向函数表的指针，并具有每个通过该函数表间接调用的JNI函数的成员函数。)JavaVM提供”调用接口”函数，我们可以利用此类的函数创建和销毁JavaVM。理论上，每个进程可以有多个JavaVM，但在Android中只允许有一个。 上面这段话为官方原话，但对于初学者来讲，可能还不是很好理解，所以我们就以官方所描述的内容进行讲解分析。 首先，说JavaVM本质上是一个二级指针，也就是我们说的指针的指针; 首先说指针： 12345概念，它其实就是内存地址，比如说我们有一个变量，存放在某个位置，那么这个位置的地址就是这个位置的指针，指向这个位置。举个最简单 的例子就是，我们一般会在C语言中申请一块空间来存储东西，申请空间一般用malloc，这个函数返回了一个void *类型的返回值，返回的 这个值就是这块空间的地址。我们拿着这个地址就可以去操作这块空间了。 指针变量： 12指针变量首先是一个变量，它和我们平时定义的int，char，float，double等等变量没有任何区别，本身都是用来存数据的，只是int， char，float，double等存的是一个值，而指针变量存放的是一个地址，这个地址指向了一块空间。 理解了这两个概念，我们再说几个常见的概念： 12函数指针：指向函数的指针，我们拿着这个指针就可以直接调用这个函数。结构体指针：指向结构体的指针，我们拿着这个指针就可以操作结构体。 所以，简单理解，我们有指针就可以做相关的操作。 指针和指针的指针(所谓二级指针)： 指针，也叫一级指针，它指向的是直接可以操作的内存空间。 指针的指针，也叫二级指针，它指向的是一级指针，一级指针指向的是可以操作的内存空间。如下图，一级指针直接指向可操作的内存空间，指针的指针是指向了指针，然后通过指针再指向可操作的内存空间(图中的102也是一个指针)。 在了解了上面的基本概念之后，补充一下在C中和C++中调用上的一些区别，我们看一下jni.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * JNI invocation interface. */struct JNIInvokeInterface &#123; void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);&#125;;/* * C++ version. */struct _JavaVM &#123; const struct JNIInvokeInterface* functions;#if defined(__cplusplus) jint DestroyJavaVM() &#123; return functions-&gt;DestroyJavaVM(this); &#125; jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;#endif /*__cplusplus*/&#125;;// 这里，可以看出来，对于C++来说，JavaVM是一个结构体(C++中结构体和C中的不太一样，C++中允许有函数，和类相似)，结构体中有很//多的成员函数，这个类等于说是一个代理，它帮我们调用了JNIInvokeInterface中的函数。#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#else// 而C语言版本中，JavaVM是一个JNIInvokeInterface*类型的指针变量，这里注意一下，正是因为这样，在C和C++中，才会出现使用上的//差别。typedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif 知道了他们的调用区别之后，再看一下JavaVM到底有什么用,那就要看他的函数了 123456789101112131415161718192021222324/* * C++ version. */struct _JavaVM &#123; const struct JNIInvokeInterface* functions;#if defined(__cplusplus) jint DestroyJavaVM() // 释放JavaVM &#123; return functions-&gt;DestroyJavaVM(this); &#125; // 将当前线程附着到虚拟机 jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; // 讲当前线程和虚拟机分离 jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; // 获取ENV jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; // AttachCurrentThreadAsDaemon()函数在JNI中的作用是将当前线程附加到Java虚拟机中作为一个守护线程，以便在非Java线程中调用Java API，并使得当所有非守护线程结束时，Java虚拟机可以退出。 jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;#endif /*__cplusplus*/&#125;; 通过上面的注释可以看到，JavaVM提供了获取JNIEnv的函数，将当前线程附着到java虚拟机中以及分离等功能。 本质上就是和javaVM取得联系，使得我们可以和java端进行通信，因为虚拟机并不知道我们C&#x2F;C++层的线程，所以他们不能直接通信，所以，需要将线程附着到虚拟机上，这样我们就可以获得虚拟机的环境，从而和Java端通信。 二. NDK开发之JNIEnv ​ 前面了解了JavaVM之后，我们再看一下JNIEnv，了解一下它是干什么的。同样的，看一下它的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * C++ object wrapper. * * This is usually overlaid on a C struct whose first element is a * JNINativeInterface*. We rely somewhat on compiler behavior. */struct _JNIEnv &#123; /* do not rename this; it does not seem to be entirely opaque */ const struct JNINativeInterface* functions;#if defined(__cplusplus) // ... 省略若干 jstring NewString(const jchar* unicodeChars, jsize len) &#123; return functions-&gt;NewString(this, unicodeChars, len); &#125; jsize GetStringLength(jstring string) &#123; return functions-&gt;GetStringLength(this, string); &#125; const jchar* GetStringChars(jstring string, jboolean* isCopy) &#123; return functions-&gt;GetStringChars(this, string, isCopy); &#125; void ReleaseStringChars(jstring string, const jchar* chars) &#123; functions-&gt;ReleaseStringChars(this, string, chars); &#125; jstring NewStringUTF(const char* bytes) &#123; return functions-&gt;NewStringUTF(this, bytes); &#125; jsize GetStringUTFLength(jstring string) &#123; return functions-&gt;GetStringUTFLength(this, string); &#125; const char* GetStringUTFChars(jstring string, jboolean* isCopy) &#123; return functions-&gt;GetStringUTFChars(this, string, isCopy); &#125; void ReleaseStringUTFChars(jstring string, const char* utf) &#123; functions-&gt;ReleaseStringUTFChars(this, string, utf); &#125; jsize GetArrayLength(jarray array) &#123; return functions-&gt;GetArrayLength(this, array); &#125; jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement) &#123; return functions-&gt;NewObjectArray(this, length, elementClass, initialElement); &#125; jobject GetObjectArrayElement(jobjectArray array, jsize index) &#123; return functions-&gt;GetObjectArrayElement(this, array, index); &#125; void SetObjectArrayElement(jobjectArray array, jsize index, jobject value) &#123; functions-&gt;SetObjectArrayElement(this, array, index, value); &#125; // ... 省略若干#endif /*__cplusplus*/&#125;; 看一下上面的函数，时不是很眼熟，就是前面我们讲过的常用函数的使用，所以JNIEnv的作用就是提供了我们和JavaVM通信的一些接口函数。 另外，它和JavaVM一样，也分别定义了C++和C的版本。原理也是一样的，在C++中通过一个结构体封装了一下，C中直接使用的是指针重命名的。所以调用上也和JavaVM一样。 1234// C++中env-&gt;xxxxx();// C中(这里为什么要带*，是因为它是一个指针的指针)(*env)-&gt;xxxxx(); 三. 全局引用和局部引用和弱全局引用 局部引用： 引用在C++和java以及一些面向对象的语言中都存在，对于传递给原生方法的每个参数，以及JNI函数返回的几乎每个对象都属于局部引用，这意味着，局部引用在当前线程中的当前原生方法运行期间有效。在原生方法返回后，即使对象本身继续存在，该引用也无效。 这适用于jobject的所有子类，包括jclass、jstring和jarray。所有我们在函数中直接获取到的对象都是局部的，如果想让它在全局可用，需要将他变成全局引用。 这个规则对于JNIEnv不适用，它属于线程。 全局引用：局部引用在函数返回后便不能使用了，但如果想让局部引用在函数返回后依旧可以使用，就要将它变成全局的。 将一个局部引用变成全局引用可以通过NewGLobalRef方法,比如我们不想在每个地方都去获取java的class对象，就可以在一次获取后，将他变成全局的。 12345678jclass localClazz;jclass globalClazz;jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass));// TODO 记住，一定要记住，在不使用它的时候要进行释放，否则，内存泄漏env-&gt;DeleteGlobalRef(globalClass); 以上两种是我们比较常用的，还有一种引用叫弱全局引用 弱全局引用： 它是全局引用的一种类型，与全局引用一样，它也可以在方法返回之后，依旧可以使用，但和全局引用不同的是弱全局引用不会阻止潜在的对象被垃圾回收，所以使用的时候记得检测这个对象是否还有效，避免崩溃。 12345678910111213141516jclass localClazz;jclass weakGlobalClazz;jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);// 将局部引用变成弱全局引用jclass weakGlobalClazz = reinterpret_cast&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(localClass));// 使用时检查,IsSameObject判断两个引用是否引用同一对象，必须使用 IsSameObject 函数，不能用 ==// 这里和NULL比较，如果不同，说明有效if (JNI_FALSE == env-&gt;IsSameObject(weakGlobalClazz, NULL))&#123; // 说明对象还存活，可以使用&#125;else&#123; // 被回收了，不能再用了&#125; 四. JNI_OnLoad 最后一个知识点，JNI_OnLoad,这个函数我们还没有使用过，这是一个被系统调用的函数，当库被加载的时候，系统会主动调用它。 那么它有什么用处？ 一般情况下，我们在这个函数中获取JavaVM 对象保存到全局。 或者在这里动态注册JNI函数。再或者在这里获取一些类的class缓存起来。 1234567891011121314151617181920JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) &#123; JNIEnv* env; if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123; return JNI_ERR; &#125; // Find your class. JNI_OnLoad is called from the correct class loader context for this to work. jclass c = env-&gt;FindClass(&quot;com/example/app/package/MyClass&quot;); if (c == nullptr) return JNI_ERR; // Register your class&#x27; native methods. static const JNINativeMethod methods[] = &#123; &#123;&quot;nativeFoo&quot;, &quot;()V&quot;, reinterpret_cast&lt;void*&gt;(nativeFoo)&#125;, &#123;&quot;nativeBar&quot;, &quot;(Ljava/lang/String;I)Z&quot;, reinterpret_cast&lt;void*&gt;(nativeBar)&#125;, &#125;; int rc = env-&gt;RegisterNatives(c, methods, sizeof(methods)/sizeof(JNINativeMethod)); if (rc != JNI_OK) return rc; return JNI_VERSION_1_6; &#125; 以上就是今天所讲解的全部内容了。这章内容稍微偏理论，我们将在下节课讲解其他内容时用到上面的所有知识点，所以务必掌握。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/3.JNI数据类型/","text":"在jni中，数据类型和java中的数据类型是不同的，在了解java和jni类型之间的关系之后，我们才能更好的在java和native之间传递数据。 数据类型的分类 基本类型 java jni C&#x2F;C++ 大小 boolean jboolean uint8_t 无符号8位 byte jbyte int8_t 有符号8位 char jchar uint16_t 无符号16位 short jshort int16_t 有符号16位 int jint int32_t 有符号32位 long jlong int64_t 有符号64位 float jfloat float 32位 double jdouble double 64位 引用类型 java jni C C++ java.lang.Class jclass jobject _jclass* java.lang.Throwable jthrowable jobject _jthrowable* java.lang.String jstring jobject _jstring * Other objects jobject void * _jobject* java.lang.Object[] jobjectArray jarray _jobjectArray* boolean[] jbooleanArray jarray _jbooleanArray* byte[] jbyteArray jarray _jbyteArray* char[] jcharArray jarray _jcharArray* short[] jshortArray jarray _jshortArray* int[] jintArray jarray _jintArray* long[] jlongArray jarray _jlongArray* float[] jfloatArray jarray _jfloatArray* double[] jdoubleArray jarray _jdoubleArray* Other arrays Jarray jarray jarray* 对于引用类型，我们知道，在java中，所有类的父类都是java.long.Object,由于C语言中没有类的概念，所以在C语言中，使用void *代替，这是一个万能类型，在C++中定义了一个空的类 class _jobject {};来代替java中的类。 基本类型在jni.h中的定义： 123456789101112/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* &quot;cardinal indices and sizes&quot; */typedef jint jsize; 以下是使用C语言时jni.h中定义的数据类型 123456789101112131415161718/* * Reference types, in C. */typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak; 以下是使用C++时jni.h定义的数据类型 123456789101112131415161718192021222324252627282930313233/* * Reference types, in C++ */class _jobject &#123;&#125;;class _jclass : public _jobject &#123;&#125;;class _jstring : public _jobject &#123;&#125;;class _jarray : public _jobject &#123;&#125;;class _jobjectArray : public _jarray &#123;&#125;;class _jbooleanArray : public _jarray &#123;&#125;;class _jbyteArray : public _jarray &#123;&#125;;class _jcharArray : public _jarray &#123;&#125;;class _jshortArray : public _jarray &#123;&#125;;class _jintArray : public _jarray &#123;&#125;;class _jlongArray : public _jarray &#123;&#125;;class _jfloatArray : public _jarray &#123;&#125;;class _jdoubleArray : public _jarray &#123;&#125;;class _jthrowable : public _jobject &#123;&#125;;typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak; typedef 是为类型定义别名，从上面的代码来看，除了基本类型，在引用类型中，C最终是可以看成是void *, 而C++可以看成_jobject*。 全部写成void* 或者_jobject* 也是可以的,这里这么写主要是为了可读性和可扩展性。 字符集 123在讲解数据类型的操作函数之前，先看一下字符集，为什么要讲解字符集，回到前面仔细观察一下基本类型的char，这个类型，在java中 和C/C++中占用的空间是不同的。熟悉C的朋友都知道，C语言中的char类型占用的是一个字节，而在java中char是占用了两个字节的， 而jchar也是占用了两个字节。这是因为java和C/C++使用的字符集不同，java使用的是Unicode字符集，而C使用的是ASCII字符集。 Unicode字符集 1234Unicode是一个全球性的字符编码标准，它为世界上几乎所有的字符（包括各种文字、符号、标点符号等）都分配了唯一的代码点。每个代码 点用十六进制表示，例如U+0041代表拉丁字母&quot;A&quot;，U+4E2D代表汉字&quot;中&quot;。Unicode字符集的目标是为了包含地球上所有的书写系统。Unicode有不同的编码方案，最常见的是UTF-8、UTF-16和UTF-32。这些编码方案允许将Unicode代码点转换为字节序列以便存储和传输。 ASCII字符集 12345678910111213ASCII字符集仅包含128个字符，包括英文字母、数字和一些特殊符号。这个字符集不足以表示全球范围内的所有字符，因此对于多语言支持 和Unicode字符，C语言需要借助宽字符类型（wchar_t）和相关的函数。所以，总的来说，Unicode字符集是一个包含全球字符的标准，可以表示各种语言和符号。而C中的char类型在默认情况下使用的是较小的字 符集（通常是ASCII或其扩展），需要通过宽字符类型和函数来支持Unicode字符。要在C中完全支持Unicode字符集，推荐使用wchar_t和 相关的宽字符函数。由于上面的不同，所以在使用jchar的时候要格外注意。如果java中的字符串仅包含了ASCII的字符，可以直接将jchar转换成char使用，这 是因为ASCII字符在Unicode中的表示和ASCII字符集中的表示是一致的。但是，如果java中的字符串包含了非ASCII的字符，比如汉字(一个字节无法表示)，则需要注意字符编码的转换，一般这种情况可以使用java 中的String类的getBytes方法将字符串转化为字节数组，指定为UTF-8字符集，然后在C中直接使用对应的字符集函数将字节数组转换成char 数组。 所以，接下来我们看一下常用的几类数据类型的操作。 常用数据操作函数 基本数据类型操作 字符转换 123456789101112131415161718192021extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_jiangc_example1_MainActivity_charTest(JNIEnv *env, jobject thiz, jchar a, jchar b) &#123; int codePoint = (int) b; char utf8Char[4]; if (codePoint &lt; 0x80) &#123; // 128 utf8Char[0] = (char) codePoint; utf8Char[1] = &#x27;\\0&#x27;; &#125; else if (codePoint &lt; 0x800) &#123; // 对于UTF-8编码来说，对于范围在0x80到0x7FF之间的Unicode字符用两个字节 // 0x7ff utf8Char[0] = (char)(0xC0 | (codePoint &gt;&gt; 6)); utf8Char[1] = (char)(0x80 | (codePoint &amp; 0x3F)); utf8Char[2] = &#x27;\\0&#x27;; &#125;else&#123; utf8Char[0] = (char)(0xE0 | (codePoint &gt;&gt; 12)); utf8Char[1] = (char)(0x80 | ((codePoint &gt;&gt; 6) &amp; 0x3F)); utf8Char[2] = (char)(0x80 | (codePoint &amp; 0x3F)); utf8Char[3] = &#x27;\\0&#x27;; &#125; LOGE(&quot;jchar ============================== a = %c b = %s\\n&quot;, a, utf8Char);&#125; 字符串创建 123456789101112// 使用示例jstring str = env-&gt;NewStringUTF(&quot;hello world&quot;);// 函数含义// 这个函数在正常情况下会返回一个jstring，可以直接返回给JAVA端使用。// 使用时需要做判断，如下if (NULL == str)&#123; // 出错了&#125;// 其他深入的用法后面再说，这里先了解简单用法 获取java端的字符串并转化成C&#x2F;C++端字符串 12345678910111213141516171819202122/** * TODO 获取jstring转化成C字符串 * string: 要转换的Java字符串（jstring对象） * isCopy: 一个可选的指向jboolean变量的指针。当isCopy不为NULL时， * 函数将通过它返回一个标志，表示返回的C字符串是从Java字符串拷贝而来（JNI_TRUE） * 还是直接指向Java字符串的内部数据（JNI_FALSE）。 * * 函数返回值： * 如果成功，返回一个指向UTF-8编码的C字符串的指针。 * 如果发生错误（如内存不足），返回NULL。 * * TODO： 最终，这里调用的都是三个参数的 GetStringUTFChars(JNIEnv*, jstring, jboolean*); * 只是，封装了一次罢了，这里我们先不管env是什么，后面再讲，先使用两个参数的函数 */const char *cString = env-&gt;GetStringUTFChars(str, NULL);if (NULL == cString) &#123; LOGE(&quot;获取C字符串失败\\n&quot;); return env-&gt;NewStringUTF(&quot;error&quot;);&#125;// TODO: 这里注意，一定一定要记得释放，否则会内存泄漏// TODO: 即便返回的字符串直接指向java字符串的内部数据，也不要修改它，不然会导致一些不确定的行为。env-&gt;ReleaseStringUTFChars(str, cString); 函数的使用看上面的代码注释就可以了，需要注意的就是，在不使用的情况下，要对字符串进行释放，而且不要尝试修改获取到的字符串。 获取字符串的长度 123456// 这个视频里面没有讲，函数使用也很简单，看一下就知道了jsize GetStringLength(jstring string);// 这个函数返回一个jsize，也就是jint，也就是int// 使用方式：int length = env-&gt;GetStringLength(str); 数组操作 注意：对于数组，我们只讲一种类型，因为其他类型操作方式一样，大家可以自己尝试使用一下其他类型的数组函数 复制数组到native 123456789101112131415161718/** * 这个函数是将java端的数组内容复制到native端提供的数组中 * @param array java端数组 * @param start 从哪里开始复制，比如从0开始 * @param len 复制几个元素 * @param buf native端的数组地址 */void GetIntArrayRegion(jintArray array, jsize start, jsize len, jint* buf);// 使用也很简单// TODO 1. 数组复制 int *pArray = nullptr; pArray = static_cast&lt;int *&gt;(malloc(length * sizeof(int))); // 数组复制到了pArray中 // 对应了 Get&lt;Type&gt;ArrayRegion env-&gt;GetIntArrayRegion(array, 0, length, pArray); 这样，就可以对数组进行操作了，但是，操作的修改不会被同步到java中，因为是复制的。 如果想将修改同步到java端，需要进行提交操作 数组设置(将native中的数组数据同步到java) 123456789101112131415/** * 将native的数组内容设置到java端的数组中 * @param array 被设置的java端的数组 * @param start 从哪里开始设置 * @param len 设置几个元素 * @param buf native的数组 */void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint* buf); // 修改 pArray[3] = 9; LOGE(&quot;after pArray[3] = %d\\n&quot;, pArray[3]); // 如果想给数组提交到java,可以使用下面的方法 // 对应了Set&lt;Type&gt;ArrayRegion env-&gt;SetIntArrayRegion(array, 0, length, pArray); 注意： 一般来讲，我们不会大量使用复制数组，然后将改变的数据再同步到java，这样效率太低，一般使用指针的方式进行操作。 获取java端数组指针 1234567891011121314151617181920212223242526272829/** * 获取java端数组指针 * @param array * @param isCopy * @return */jint* GetIntArrayElements(jintArray array, jboolean* isCopy);// 函数使用方法如下： // 对应了 Get&lt;Type&gt;ArrayElements jint *elements = env-&gt;GetIntArrayElements(array, nullptr); if (nullptr == elements) &#123; return nullptr; &#125; // 通过指针访问数组 for (int i = 0; i &lt; length; ++i) &#123; elements[i] = i + 1; &#125; // TODO 在获取到数组指针之后也要记得释放，否则会内存泄漏 /** * 这个函数，前面两个参数一看就知道了，主要说明一下最后一个参数 * mode: 释放数组元素时的标志 * 主要有以下取值： * 0： 对Java的数组进行更新并释放C/C++的数组 * JNI_COMMIT ：对Java的数组进行更新但是不释放C/C++的数组，一般用于周期性的修改java数组 * JNI_ABORT：对Java的数组不进行更新,释放C/C++的数组 */ // 对应了 Release&lt;Type&gt;ArrayElements env-&gt;ReleaseIntArrayElements(javaArray, elements, 0); 注意： 和string一样，凡是获取了指针的，一律记得释放，否则内存泄漏。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android FrameWork/Selinux&SeAndroid/","text":"前言做Android平台SDK开发，在Android 8.0版本之后面临不少系统权限问题，经过这几年的开发和适配以及平时的探索，我在系统权限和安全方面学习和掌握了不少这方面的知识。 本文基于Android 11.0, 主要介绍下SELinux和SEAndroid，本文在阅读参考了国内外不少大牛的资料基础上，加上平时的实战总结出来的，希望对大家有所帮助。 自编故事很久以前，有个公司成立了，公司里有总经理张总一人，秘书小王一人，还有李赵等小兵若干，有一天总经理写了一封信，信中写了公司员工每个人的薪水等级，写完后，放在一个柜子里， 结果总经理为了方便，设置了柜子权限为老铁666，然后下班回家睡觉了 秘书小王有事进到张工办公司发现没人，本来想离开的，但是看到屋里有个柜子，上面钥匙挂在上面(可读写)，小王就忍不住打开偷看了一下，看完之后，心生一计，偷偷改了自己的薪水等级，然后关上柜子走了 小李小赵有事请教来找张总，结果也发现了柜子，然后也偷偷改了数据(可读写)， 等第二天张总上班后，再拿出来信的时候，倒吸一口凉气，大事不妙。。。。 心想，这种不小心就把文件的权限暴露给其他人的情况，太不安全了，必须要改革！ 张总熬了几个通宵，掉了一把头发，终于新的机制2.0诞生了, 2.0模式是这样的，公司里面的每个人都有一个公司派发的身份证，每个文件，也有一个身份证，公司还雇用了一个保安大爷(董事长化身)，实时监控每个人对于每个文件的行为。 首先张总写信的时候，还是保持以前的模式，每次都检查下其他人是否有可读写的权限， 然后小李在打开柜子想要读写信的时候，保安是会立即检查小李的身份证和信的身份证，然后在一台只能读的电脑上，搜索小李的权限，看看人有没有读写信的权限 如果没有的话，那么保安会立即传送到小李身边，揪住小李拖出去，然后利用公司大喇叭广播所有人，小李想读信，被我阻止了，大家下次别干了啊， 张总每天最开心的事，就是听保安喋喋不休的说谁谁谁没干成什么什么事。。。。 安全系统的重要性对于安卓系统，比如一台手机，如果系统不安全，不稳定，那么很可能就会出现如下问题： 系统经常崩溃，影响用户体验 对于各种bug的第三方应用，影响系统使用 对于恶意应用，会入侵入侵用户的私有数据，串改数据等 系统被网络黑客入侵与控制 可以想象，对于生产厂家和用户来说，如上的情况是多么的糟糕，公司倒闭，各种被唾弃都能可能出现。。。 所以构建一个坚固的系统多么的重要 Linux标准安全机制介绍：众所周知，Android底层是Linux内核，那么关于安全部分，肯定离不开Linux，首先简单介绍下Linux的权限机制。 我们平时登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号（也就是一串数字）。 Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和当前工作组 ID（Group ID，简称 GID），这与文件有拥有者和拥有群组两种属性相对应，另外还有一个用户所有组ID(Groups ID，简称GIDS) Linux id命令用于显示用户的ID，以及所属群组的ID 12pi@raspberrypi:~ $ iduid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),997(gpio),998(i2c),999(spi) 如上，可以看到我的树莓派当前uid是1000，当前工作组gid是1000，当前用户所属的所有组的gids是后面那一长串 更多id 命令用法，请用id --help 同样，linux进程也有uid,gid,gids，某个用户启动的进程，那么这个进程就会继承用户的uid,gid,gids 查看命令为ps -aux 1234567pi@raspberrypi:~ $ ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 2 0.0 0.0 0 0 ? S 09:43 0:00 [kthreadd]root 510 0.2 0.4 32796 17400 ? S 09:43 0:05 /usr/bin/vncserver-x11-core -servicepi 617 0.0 0.0 9932 3096 ? Ss 09:43 0:00 /usr/bin/vncserver -depth 16 -geometry 1024x768 :1pi 782 0.0 0.0 9788 2556 pts/0 R+ 10:24 0:00 ps -aux pi 1638 0.0 0.0 8516 3776 pts/0 Ss 09:43 0:00 bash 如上截取部分输出，可以看到我用当前用户pi执行ps -aux这个执行，那么其进程的uid（USER那一列为pi） 最后介绍linux文件系统，只有uid gid 以及相对应的rwx权限 查看命令为ls -l 可以看到文件型态、权限、拥有者、文件大小以及时间等内容 12345678910pi@raspberrypi:~/Downloads $ touch abcpi@raspberrypi:~/Downloads $ ls -ltotal 0-rw-r--r-- 1 pi pi 0 Jul 18 10:32 abcpi@raspberrypi:~/Downloads $ sudo touch bbbpi@raspberrypi:~/Downloads $ ls -ltotal 0-rw-r--r-- 1 pi pi 0 Jul 18 10:32 abc-rw-r--r-- 1 root root 0 Jul 18 10:32 bbbpi@raspberrypi:~/Downloads $ 如上，我在当前目录下使用当前用户pi创建了一个文件，那么从结果来看-rw-r--r-- 1 pi pi 0 Jul 18 10:32 abc我们就知道了这个文件的uid为pi ,gid为pi，其rwx权限为-rw-r--r--,其中第一个横杠-代表是一个文件,其余的9位，以3位为一组，分别代表当前用户对着文件的所有权，当前用户组对这个文件的所有权，以及其他用户组对这个文件的所有权， 当我切换到root用户去创建一个文件夹的时候，那么可以看到其uid gid也变成了root 总结一下： 系统上的每个进程(运行中的程序)都作为一个特定的用户来运行 每个文件都归一个特定的用户所有 对资源(文件和目录等)的访问受用户所限制 正在运行的进程所关联的用户可以决定该进程可访问的资源(文件&#x2F;目录等） DAC介绍全称：Discretionary access control (DAC) 自主式权限控制 概念：如果一个用户拥有一个文件，那么用户可以允许自由的控制文件的读写和执行权限，那么就叫DAC 上一节介绍的Linux标准安全机制就是属于DAC，那么这个机制有什么特点(缺点)吗 资源所有权掌握在特定用户的手里，导致资源可能被乱用 用户的区分度比较低，系统上只有两个特权等级：普通user和超级用户root 读权限可以转移，导致信息可以任意流动，比如用户A允许文件被B用户读，那么B读到文件后，可以转手传递给C 可以看到这种DAC模式无论是用户和资源都难以控制，因此大家都想疯狂拿到root权限，然后就可以为所欲为 Android沙箱介绍Application Sandbox，官网地址：应用沙盒 简单来说主要是 基于Linux保护应用资源 每个app分配唯一的UID&#x2F;GID,在各自的的进程中运行 互相不能访问(默认) 既然Android是基于Linux的，那么进程和资源也有uid/gid/gids,下面就介绍一下 每个app安装之后都会被分配一个uid叫aid，源码路径/system/core/include/private/android_filesystem_config.h id查看uid&#x2F;gid，命令没变,cat /proc/xxx/status查看进程信息，包括uid、gid、gids ps -l查看进程uid/gid 比如 u0_a36那么意思就是10000 add 36 为10036, 其中#define AID_APP 10000 /* first app user */ 资源或者说文件的uid/gid定义路径:/system/core/include/private/android_filesystem_config.h 最后说下Android 服务service，其一般会伴随着一个xxx.rc文件,并在其中声明其uid&#x2F;gid,例如下面中声明user和group，对应的就是uid和gid 123456service surfaceflinger /system/bin/surfaceflinger class core user system group graphics drmrpc readproc onrestart restart zygote writepid /sys/fs/cgroup/stune/foreground/tasks 另外设备节点如/dev/binder 的uid和gid一般定义在各个ueventd.rc文件中 一般放在/system/etc/ueventd.rc下 那么Android中的权限Permission除了上面介绍的rwx，对于APK开发，还包括清单文件中需要配置的权限，路径：/frameworks/base/core/res/AndroidManifest.xml 无论是通过Android API，Java API，NDK C API，还是执行shell命令，那么要么在api调用过程中，如framework，要么是在底层，通过uid&#x2F;gid等进行权限管理和控制。道理是相通的。 SELinux介绍全称Security-Enhanced Linux (SELinux) ，安全增强型Linux，是增强安全的一个机制，那么就探究下到底相比DAC模式，如何增强的？ 首先说下背景知识，简单了解下： 是集成在kernel 2.6.x中一个安全架构 是Linux Security Modules (LSM)的一部分 是美国国家安全局和linux社区开发的一个项目 是MAC (Mandatory Access Control)在Linux内核级的一个实现 其实最重要的就是它是MAC的一个linux实现，那么MAC是什么，跟DAC什么关系呢？ MAC介绍 MAC被预置到内核级的系统中，对于linux，是预置在kernel里面的 MAC限制主体(英文叫subject，比如用户或进程)对客体(英文名叫object，比如文件等资源)的访问和操作的能力 MAC机制会给所有主体和客体分配一个安全标签(Security label)，包括用户user，进程process，访问的资源等 MAC机制会定义一个清晰明确的的访问规则，限制每个用户或者进程只允许访问它已经定义好的资源，所以即使是Root权限也能被限制 是非DAC的，不能被资源的所有者修改 如上可以看出，我们想要了解SELinux以及相关的概念，那么会出现很多名词，当然这些名词其实只是在不同场景下的不同叫法而已，大家习惯就好，我也是经常用，所以有时候会说出好几个名词，但是其实都是表达一个意思。 SELinux 引入**标签(label)**这个东西来进行权限的操作和规则的制定，在SELinux世界里，任何一个对象都有标签，比如进程，文件，目录等等，全都有标签，就像每个人身份证上的名字一样，与生俱来，而且每个对象的标签都是唯一的。SELinux 在做决定时，就会根据这些标签以及系统根据标签来制定的规则进行权检查。 SELinux架构流程 我这边画了一个图，大致说下流程，首先主体(Subject比如user或Process)想要访问(Access) 一个客体(Object，比如一个文件file吧),那么首先需要经过DAC判断，如果DAC判断失败了(比如rwx权限不足等)，那么直接就会拒绝 如果DAC验证通过，那么就会进入MAC的判断，其中MAC，我又把具体内容扩展了一下，见图中虚线方框内， 进入MAC时，首先会通过AVC(访问向量缓存)，看名字cache缓存，那么缓存什么呢？缓存的是Security Server(相当于数据库) 对于主体访问客体的策略是否命中，如果命中了，那么为了提高判断效率，直接会把这个策略放到AVC里缓存，下次判断时，直接缓存里查找，速度更快。 最后通过AVC检查后，才能得到访问客体的权限，拿到相应的资源。我这里省略了图中的MLS，这个在后续会单独介绍。 如上可以知道，DAC和MAC是互为补充的，先要经过DAC后才能进行MAC，所以SELinux也叫增强安全型 SEAndroid介绍了解过SELinux之后，那么SEAndroid就比较好理解了，其实： SELinux + Android &#x3D; SEAndroid 也就是说安卓平台对于SELinux的一个实现，或者应用于安卓上，就叫SEAndroid 官网地址：https://source.android.google.cn/security/selinux 简单说下历史演变过程： Android 4.3（宽容模式） Android 4.4（部分强制模式） Android 5.0 及更高版本中，已全面强制执行 SELinux Android 6.0 高度限制对 &#x2F;proc 的访问 Android 8.0 更新了 SELinux 以便与 Treble 配合使用 这里解释下宽容模式（Permissive）和强制模式（Enforcing），SELinux 按照默认拒绝的原则运行：任何未经明确允许的行为都会被拒绝。SELinux 可按两种全局模式运行： 宽容模式：权限拒绝事件会被记录下来，但不会被强制执行。 强制模式：权限拒绝事件会被记录下来并强制执行。 Android CDD提到安卓，不得不提CDD兼容性文档，谷歌认证必备的， CDD中对于SELinux部分也是有强制要求的，具体链接如下：https://source.android.google.cn/compatibility/11/android-11-cdd#9_7_security_features 这里我直接粘贴过来翻译过的内容 1234567如果设备要使用 Linux 内核，则：•[C-1-1] 必须实现 SELinux。•[C-1-2] 必须将 SELinux 设置为全局强制模式。•[C-1-3] 必须将所有域配置为强制模式。不允许使用宽容模式域，包括特定于设备/供应商的域。•[C-1-4] 对于 AOSP SELinux 域以及特定于设备/供应商的域，不得修改、省略或替换上游 Android 开源项目 (AOSP) 中提供的 system/sepolicy 文件夹中存在的 neverallow 规则，并且政策必须在所有 neverallow 规则都存在的情况下编译。•[C-1-5] 必须在每个应用的 SELinux 沙盒中运行面向 API 28 级或更高级别的第三方应用，并对每个应用的私有数据目录设定应用级 SELinux 限制。•应保留上游 Android 开源项目的 system/sepolicy 文件夹中提供的默认 SELinux 政策，并且应仅针对自己的设备特定配置向该政策进一步添加内容。 可以看出，谷歌对于安卓系统的要求还是挺严格的，当然国内厂家如果不需要满足CDD的话， 很多都是为了拿到更多权限而直接宽容模式运行的，但是这样的话，系统安全就得不到保证，所以说安全和权限总是鱼和熊掌不可兼得 SEAndroid 标签Label 下面介绍重要概念标签label，我这里又画了一个图，便于理解这个概念，首先label是给所有对象贴的，包括进程和资源 首先标签label又叫Security Context安全上下文，然后进程的标签，我们也叫scontext(source context)源上下文，而资源的标签也叫tontext(target context)目标上下文名字如意思，比较好理解。 然后它长什么样子呢，就是user:role:domain或者type:mls_level 也就是三个冒号分隔成四个部分 其中user叫用户，在SEAndroid中只定义了一个用户叫u, 然后role角色，在SEAndroid中也定义了两个角色叫r和object_r 什么区别的，r是给进程用的，而object_r是给访问的对象或者叫资源用的，因为object就是对象的意思 然后domain或者type什么区别呢？如果进程的标签，那么就是domain域,如果是资源，那就是type 最后是mls_level在SEAndroid里面只定义了一个级别s0 其实从标签的样子,大家可以知道，四部分中主要变化的是第三部分(domain&#x2F;type)，所以安卓中主要以这个部分定义相关规则 SEAndroid 的标签大致分为五类： 首先是Service服务相关的标签。 其次，对于基于 Binder 的服务，允许向 Service Manager 注册的标签。 第三，系统属性Property的标签。 第四，设备节点相关的标签。 第五，文件相关的标签 最后，app应用相关的标签。 这里先说下SEAndroid中文件相关的标签 file_contexts 为文件分配标签，为&#x2F;system &#x2F;sys &#x2F;dev &#x2F;data 等文件分配标签 genfs_contexts 用于为不支持扩展属性的文件系统（例如，proc 或 vfat）分配标签 property_contexts 用于为 Android 系统属性分配标签。在启动期间，init 进程会读取此配置。 service_contexts 用于为 Android Binder 服务分配标签，以便控制哪些进程可以为相应服务添加（注册）和查找（查询）Binder 引用。在启动期间，servicemanager 进程会读取此配置。 seapp_contexts 用于为应用进程和 &#x2F;data&#x2F;data 目录分配标签。在每次应用启动时，zygote 进程都会读取此配置；在启动期间，installd 会读取此配置。 mac_permissions.xml 用于根据应用签名和应用软件包名称（后者可选）为应用分配 seinfo 标记。随后，分配的 seinfo 标记可在 seapp_contexts 文件中用作密钥，以便为带有该 seinfo 标记的所有应用分配特定标签。在启动期间，system_server 会读取此配置。 最后说下如下的信息含义 1W com.aa.bb: type=1400 audit(0.0:199): avc: denied &#123; call &#125; for scontext=u:r:system_app:s0 tcontext=u:object_r:update_engine:s0 tclass=binder permissive=0 app=com.aa.bb 我们平时一般会通过logcat查看相关打印信息，这里介绍两个命令来抓取selinux的拒绝事件打印：logcat |grep avc 或者dmess |grep avc 就会过滤出一大堆类似如上的信息，我们要从这些信息中提取出有用的关键信息，并修改系统的规则来满足我们产品的要求。 下面我会介绍SELinux的规则，并解释如上的信息含义 SEAndroid 规则1 Rule&#x2F;Policy每个对象都有标签了，那么如何利用这些标签来干事情呢，重要的规则或者叫策略登场了 基于安卓源码，介绍下SDK中源码相关的内容： system/sepolicy 是android 关于selinux核心策略配置的所有内容，我们不应该去修改这个路径下任何文件 /device/manufacturer/device-name/sepolicy 这个路径会包含芯片厂家所有平台相关的配置，我们主要修改这里 BOARD_VENDOR_SEPOLICY_DIRS += vendor/oem/sepolicy 我一般会把自定义的规则放在自定义的目录里面，便于跟芯片厂家的分区开 *.te策略配置文件的后缀，其中的语言从global_macros, te_macros attributes 这些配置文件中读取和使用 Android 8.0 之后 system&#x2F;sepolicy&#x2F;public 平台共有策略的全部定义 system&#x2F;sepolicy&#x2F;private 平台私有规则，不会向vendor部分暴露。 system&#x2F;sepolicy&#x2F;vendor 厂商规则，可引用public的规则，不能引用private的规则 device&#x2F;manufacturer&#x2F;device-name&#x2F;sepolicy 厂商自定义的规则，包括如上的vendor部分 总之大家没事可以多去上面说的几个目录下点击文件看看内容，其中厂家一般都只修改device里面定义的规则，否则可能会引起谷歌认证失败的情况。大家还是遵守规则比较好 SEAndroid 规则2 下面介绍下*.te中常用的语法规则，目的是让大家能看到，会写 上面图中以adbd.te为例，介绍具体的内容 首先说下domain域定义的规则，如下面两行 123type adbd, domain; //解释下type就是定义的意思，定义adbd 为domain，看到domain，意思就是adbd是给进程或者用户贴的标签类型type adbd_exec, exec_type, file_type; //这行意思是定义一个adbd_exec这个类型，然后属于exec_type和file_type,意思就是adbd这个文件的标签为adbd_exec，那么它是可执行文件(exec_type)，也是文件类型(file_type)//图中标注为红色的，都可以通过箭头找到原始定义的源码路径，大家可以自己查看 域定义完了之后，紧接着就是定义规则了 1allow domains types:classes permissions; //这行是语法规则，意思就是允许(allow) 某个域(domains) 对于某个资源(types)：资源类型(classes) 拥有资源类型相关的权限(permissions) 举个例子 12allow bootanim system_file:dir r_dir_perms;允许 域类型为bootanim的进程 对于资源为system_file的目录dir 有读r权限 另外介绍下有4种情况： allow - 允许主体对客体执行许可的操作。 neverallow - 表示不允许主体对客体执行制定的操作。 auditallow - 表示允许操作并记录访问决策信息。 dontaudit - 表示不记录违反规则的决策信息，切违反规则不影响运行。 SEAndroid 规格3说下SDK编译这些规则最终的产出物策略生成位置 boot.img（针对非 A&#x2F;B 设备）或 system.img/vendor.img（针对 A&#x2F;B 设备）。 (&#x2F;system &#x2F;vendor &#x2F;product)&#x2F;etc&#x2F;selinux 所有分区中的策略配置文件位置,包括如下内容 (plat vendor product)_sepolicy.cil: 所有策略转成cil (CIL(common Intermediate Language)) *_file_contexts: 文件的security contexts 其中* 代表plat|vendor|product *_property_contexts: 属性的security contexts *_seapp_contexts: App 的security contexts *_mac_permissions.xml SEAndroid 命令平时开发中，我这里总结了常用的命令来查看或者设置SELinux相关的内容 Command Action setenforce 0&#x2F;1 或 getenforce 临时关闭或打开安全策略 ，或者获取当前策略 Permissive&#x2F;Enforcing Ls -Z 显示文件的Security Context ps -Z 显示进程的Security Context id (user) 显示进程&#x2F;用户的Security Context chcon 修改文件的Security Context restorecon 恢复文件的默认Security Context dmesg |grep avc 或 logcat |grep avc 查看所有denied的信息 如下是一些实际操作的效果 1234567891011121314151617181920212223console:/sdcard # ps -AZLABEL USER PID PPID VSZ RSS WCHAN ADDR S NAME u:r:init:s0 root 1 0 46160 6772 SyS_epoll_wait 0 S initu:r:kernel:s0 root 2 0 0 0 kthreadd 0 S [kthreadd]u:r:netd:s0 root 306 281 17776 2632 pipe_wait 0 S iptables-restoreu:r:audioserver:s0 audioserver 332 1 58772 17608 binder_ioctl_write_read 0 S audioserveru:r:su:s0 root 5414 5149 10864 2932 0 0 R psconsole:/sdcard # id systemuid=1000(system) gid=1000(system) groups=1000(system) context=u:r:su:s0console:/ $ id uid=2000(shell) gid=2000(shell) groups=2000(shell),1007(log),3009(readproc) context=u:r:shell:s0console:/ $ id log uid=1007(log) gid=1007(log) groups=1007(log) context=u:r:shell:s0console:/sys/fs # ls -Zl total 0drwxrwxrwt 2 root root u:object_r:fs_bpf:s0 0 2021-07-20 23:28 bpfdr-xr-xr-x 2 root root u:object_r:sysfs:s0 0 2021-07-20 23:51 cgroupdrwxr-xr-x 10 root root u:object_r:sysfs:s0 0 2021-07-20 23:51 ext4drwxr-xr-x 3 root root u:object_r:sysfs_fs_f2fs:s0 0 2021-07-20 23:28 f2fsdrwxr-xr-x 3 root root u:object_r:sysfs:s0 0 2021-07-20 23:28 fusedrwxr-xr-x 3 root root u:object_r:sysfs:s0 0 2021-07-20 23:51 incremental-fsdr-xr-x--- 2 system log u:object_r:pstorefs:s0 0 2021-07-20 23:28 pstoredrwxr-xr-x 8 root root u:object_r:selinuxfs:s0 0 1970-01-01 08:00 selinux 这里说一下，系统开机后，selinux会把文件系统挂在到&#x2F;sys&#x2F;fs&#x2F;selinux这个节点下面，里面有所有android所定义的对象以及相应的权限控制,部分列举如下 1234567891011121314151617181920212223242526272829303132333435console:/sys/fs/selinux/class # ls -ltotal 0dr-xr-xr-x 3 root root 0 2021-07-20 23:28 binderdr-xr-xr-x 3 root root 0 2021-07-20 23:28 blk_filedr-xr-xr-x 3 root root 0 2021-07-20 23:28 bluetooth_socketdr-xr-xr-x 3 root root 0 2021-07-20 23:28 capabilitydr-xr-xr-x 3 root root 0 2021-07-20 23:28 capability2dr-xr-xr-x 3 root root 0 2021-07-20 23:28 chr_filedr-xr-xr-x 3 root root 0 2021-07-20 23:28 dirdr-xr-xr-x 3 root root 0 2021-07-20 23:28 fddr-xr-xr-x 3 root root 0 2021-07-20 23:28 fifo_filedr-xr-xr-x 3 root root 0 2021-07-20 23:28 filedr-xr-xr-x 3 root root 0 2021-07-20 23:28 filesystemdr-xr-xr-x 3 root root 0 2021-07-20 23:28 hwservice_managedr-xr-xr-x 3 root root 0 2021-07-20 23:28 ipcdr-xr-xr-x 3 root root 0 2021-07-20 23:28 keystore_keydr-xr-xr-x 3 root root 0 2021-07-20 23:28 lnk_filedr-xr-xr-x 3 root root 0 2021-07-20 23:28 packet_socketdr-xr-xr-x 3 root root 0 2021-07-20 23:28 processdr-xr-xr-x 3 root root 0 2021-07-20 23:28 process2dr-xr-xr-x 3 root root 0 2021-07-20 23:28 property_servicedr-xr-xr-x 3 root root 0 2021-07-20 23:28 service_managerdr-xr-xr-x 3 root root 0 2021-07-20 23:28 sock_filedr-xr-xr-x 3 root root 0 2021-07-20 23:28 socketdr-xr-xr-x 3 root root 0 2021-07-20 23:28 systemdr-xr-xr-x 3 root root 0 2021-07-20 23:28 tcp_socketdr-xr-xr-x 3 root root 0 2021-07-20 23:28 udp_socketdr-xr-xr-x 3 root root 0 2021-07-20 23:28 unix_stream_socketconsole:/sys/fs/selinux/class/binder/perms # ls -lZtotal 0-r--r--r-- 1 root root u:object_r:selinuxfs:s0 0 2021-07-20 23:28 call-r--r--r-- 1 root root u:object_r:selinuxfs:s0 0 2021-07-20 23:28 impersonate-r--r--r-- 1 root root u:object_r:selinuxfs:s0 0 2021-07-20 23:28 set_context_mgr-r--r--r-- 1 root root u:object_r:selinuxfs:s0 0 2021-07-20 23:28 transferconsole:/sys/fs/selinux/class/binder/perms # 如上可以看到binder所有的权限，可以与其它进程进行binder ipc通信（call），能够向这些进程传递Binder对象（transfer），以及将自己设置为Binder上下文管理器（set_context_mgr） 具体可以查看每个class里面 perms文件夹内的内容。 SEAndroid 实战1 Service 对于在 Android 6.x （Marshmallow） 之后添加的 Service，如果缺少相关文件或编写不正确，则 开机时service是无法正常启动和运行的。 图中定义了一个mytest_service的服务，声明了一个mytest.rc文件，这样放入system/etc/init/mytest.rc里面，那么开机后是无法启动的，原因就是缺少安全策略 那么如何定义安全策略呢？ 1234//一共需要如下这些文件mytest_servicemytest.rcfile_context 想开机运行服务，需要将相关内容添加到与服务相关的安全标签中（图中file_contexts 和mytest.te）即可 但是这种开机起来的服务是不能注册到binder里面的，也就是不能作为binder服务 那么如何作为binder服务并开机注册呢？请看下图 1234567//一共需要如下这些文件mytest_servicemytest.rcfile_contextservice_context.teservice.te SEAndroid 实战2 PropertyGoogle在Android O以后,为了降低vendor和system之间的耦合度,对property的作用区域也做了明确的区分,分为vendor的property和system里的property. 一般我们自定义property的时候，OEM厂家都应该以vendor.开头，或者persist,ro这种的，而不能是xx.yy.zz，否则谷歌认证会报错 1234//一共需要如下这些文件mytest.te //主要是声明权限控制的property_contexts //主要是定义你的某个prop的完整标签上下文property.te //定义一个新标签类型type 这样，你的property，开机后就会能读取或者写入等操作， 也可以使用getprop -Z 来看你定义的prop的标签内容 SEAndroid 实战3 Device设备节点项目中有可能需要自定义了一个设备节点，比如/dev/test_dev ，然后要求访问特定设备节点， 那么在SEAndroid中也需要设置相关文件 同时如果你发现系统内某个设备节点无法访问，权限不足，那么你也有能需要重新修改下这个设备节点的SELinux标签，满足权限要求 下面介绍下 比如一个服务mytest_service想要打开一个设备节点，如上图，那么一般会设计到如下设置 1234涉及到设备相关的文件device.te //主要是定义一个设备节点的typefile_contexts //给具体的设备节点路径定义一个完整的标签，标签中加入你新定义的typemytest.te //最后在你的服务的域中，定义相关的权限即可 当然，如果系统内已经定义好了相关设备节点的标签，那么你直接修改为你自定义的，然后权限自然就有了哦 查看设备节点的标签命令ls -Z 因为设备节点属于资源，不是进程 SEAndroid 实战4 Binder&#x2F;HIDL在Android 8.0以后，system和vendor进行了隔离，那么就引入了HIDL来进行通信，其实也是binder通信， 这里总结下Android中的三种binder，以及涉及到的SELinux文件，大家具体可以查看自己家平台里面相关的内容 1234567891011121314151617//System binder service相关file_contextsservice.teservice_contextservicemanager.te //HIDL binder service相关file_contextshwservice.tehwservice_contexthwservicemanager.te //vendor中的binder service相关file_contextsvndservicevndservice_contexts vndservicemanager.te MLS介绍当大家查看进程标签时ps -AZ，一般会发现如下的标签中有个c512,c768,这种的 1u:r:platform_app:s0:c512,c768 u0_a58 747 287 1140388 136964 SyS_epoll_wait 0 S com.android.systemui SEAndroid里，只定义了s0一个敏感度sensitive，但是定义了0~1023个category。在敏感度只有一个值的情况下，其实MLS已经变成了MCS（Multi-category Security），多组安全。MCS用于隔离，阻断不同组之间的信息流动。颗粒度更细 相关源码定义： system/sepolicy/private/mls 主要策略控制位置 如上 小写l代表level，小写t 代表type， l1表示subject的MLS level，l2表示object的MLS level t1表示subject的type，t2表示object的type 上图的mlsconstrain规则，定义了只有在满足下面四个条件其中之一的情况下，才能对系统的任何目录和文件拥有写、追加、重命名等权限： （1）dir&#x2F;file的类型为app_data_file（t2 &#x3D;&#x3D; app_data_file，t2表示object的类型） （2）主体和客体的MLS相等（l1 eq l2，l1表示subject的MLS level，l2表示object的MLS level） （3）主体拥有mlstrustedsubject属性（t1 &#x3D;&#x3D; mlstrustedsubject ） （4）客体拥有mlstrustedobject属性（t2 &#x3D;&#x3D; mlstrustedsubject ）mlstrustedsubject和mlstrustedobject分别是subject和object的属性，相应的类型关联到这两种属性后，可以绕过MLS的限制。 system/sepolicy/private/mls_decl 使用了宏生成sensitive和category 1system/sepolicy/private/mls_macros /system/sepolicy/private/seapp_contexts 文件中的levelFrom字段决定应用和目录&#x2F;文件的level external/selinux/libselinux/src/android/android_platform.c 文件中，通过对levelFrom的值的判断，赋予应用、应用的数据对应level。 Code &amp; Doc主要代码和文档汇总 谷歌在线文档：https://source.android.google.cn/security/selinux 源码路径 ：/system/sepolicy 其他在线文档，排名不分先后 https://jung-max.github.io/2019/09/16/Android-SEAndroid%EC%A0%81%EC%9A%A9/ https://milestone-of-se.nesuke.com/en/sv-advanced/selinux/selinux-summary/ https://blog.csdn.net/innost/article/details/19299937/ https://blog.csdn.net/luoshengyang/article/details/35392905 http://androidxref.com/ https://www.jianshu.com/p/3f6006e74821 感谢!","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/2.Cmake基础知识/","text":"预编译库和源码编译的库的区别 12345678910111213141516171819202122232425预编译库及非预编译库是什么 - 预编译库是指已经经过编译的二进制文件，可以直接在 Android 应用中使用如静态库（.a）或共享库（.so）。 预编译库可以直接加载到应用程序中，并通过JNI与 Java 层进行交互 - 非预编译库是指将 C/C++ 代码直接放在 Android 项目中，并在构建时进行编译，这种方式会将 C/C++ 代码与 Java 代码一起 编译成最终的应用程序，而不是单独生成预编译库。什么是动态库:动态库是一种可重复利用的代码和数据的集合，它可以在程序运行的时候动态的加在和连接到应用程序中。在编译时动态库不会被连接到应用程序中，而是在程序运行时被加载到内存中。动态库的主要优点是它可以被多个程序共享，并且可以在运行时更新或替换。这意味着一个库被更新时，无需重新编译整个程序，只需要替换对应的库文件就可以了，这样可以降低程序维护的成本，提供更好的灵活性。什么是静态库:静态库也是一种包含了可重复利用的代码和数据的集合，它和动态库最大的不同就是，动态库在程序运行时，需要的时候才会加载链接，而静态库在编译的时候就会被直接链接到程序中，成为程序的一部分。相对动态库而言，静态库是独立存在的，动态库是共享的，这是他们最重要的区别之一，也正是因为这个原因，静态库相对于动态库而言，对其他的依赖更低。运行速度相对静态库会快一些，因为程序在执行过程中不需要再额外加载和链接动作。什么时候用静态库，什么时候用动态库？一般情况下，可以从几个方面考虑：a. 内存： 一些通用的库可以使用动态库，它是共享的，相对节省内存，比如log，utilsb. 存储：动态库只需要一份就可以了，所以依赖越多，相对空间节省越多c. 环境: 如果是标准环境，比如pc,对于通用库一般依赖动态库(比如系统库)，但如果是一些环境情况不清楚，或者为了减少兼容性问题，则 选择静态库d. 速度： 静态库运行速度比动态库快(理论上是，实际上基本察觉不出); 编译ffmpeg 123456781.官网下载：download下面有个more release版本；https://ffmpeg.org/download.html#releases2.Download gzip tarball （选择压缩包下载）3.linux下执行解压（tar vxf ffmpeg-6.1.tar.gz）4.touch build.sh 新建build.sh文件5.gedit build.sh打开文件，将下面的build.sh文件内的内容复制进去6.通过./build.sh命令执行开始编译//报错bash: ./build.sh: Permission denied//解决：chmod 777 build.sh build.sh的文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#!/bin/bash# 指定ndk路径NDK=/usr/local/android-ndk-r21d# 指定平台路径PLATFORM=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot# 指定交叉编译链TOOLCHHAINS=$NDK/toolchains/llvm/prebuilt/linux-x86_64#可变参数API=&quot;&quot;ABI=&quot;&quot;ARCH=&quot;&quot;CPU=&quot;&quot;CC=&quot;&quot;CXX=&quot;&quot;CROSS_PREFIX=&quot;&quot;OPTIMIZE_CFLAGS=&quot;&quot;#关闭ASM:仅在X86架构上使用，实际使用发现--disable-x86asm并没有什么用，在Android API&gt;= 23时还是会出现 has text relocations的问题，其他ABI没有问题，所以X86在编译的时候需要加上 --disable-asmDISABLE_ASM=&quot;&quot;#输出路径PREFIX=./androidAPI=21function buildFF&#123; echo &quot;开始编译ffmpeg $ABI&quot; ./configure \\ --prefix=$PREFIX/$ABI \\ --target-os=android \\ --cross-prefix=$CROSS_PREFIX \\ --arch=$ARCH \\ --cpu=$CPU \\ --sysroot=$PLATFORM \\ --extra-cflags=&quot;-I$PLATFORM/usr/include -fPIC -DANDROID -mfpu=neon -mfloat-abi=softfp $OPTIMIZE_CFLAGS&quot; \\ --cc=$CC \\ --ar=$AR \\ --cxx=$CXX \\ --enable-shared \\ --enable-runtime-cpudetect \\ --enable-gpl \\ --enable-cross-compile \\ --enable-jni \\ --enable-mediacodec \\ --enable-decoder=h264_mediacodec \\ --enable-hwaccel=h264_mediacodec \\ --disable-x86asm \\ --disable-debug \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-postproc \\ --disable-avdevice \\ --disable-symver \\ --disable-stripping \\ $DISABLE_ASM make -j4 make install echo &quot;编译结束&quot;&#125;# armv7-a function build_armv7()&#123; API=21 ABI=armeabi-v7a ARCH=arm CPU=armv7-a CC=$TOOLCHHAINS/bin/armv7a-linux-androideabi$API-clang CXX=$TOOLCHHAINS/bin/armv7a-linux-androideabi$API-clang++ CROSS_PREFIX=$TOOLCHHAINS/bin/arm-linux-androideabi- DISABLE_ASM=&quot;&quot; # 编译 buildFF&#125;# armv8-a aarch64function build_arm64()&#123; API=21 ABI=arm64-v8a ARCH=arm64 CPU=armv8-a CC=$TOOLCHHAINS/bin/aarch64-linux-android$API-clang CXX=$TOOLCHHAINS/bin/aarch64-linux-android$API-clang++ CROSS_PREFIX=$TOOLCHHAINS/bin/aarch64-linux-android- OPTIMIZE_CFLAGS=&quot;-march=$CPU&quot; DISABLE_ASM=&quot;&quot; # 编译 buildFF&#125;# x86 i686function build_x86()&#123; API=21 ABI=x86 ARCH=x86 CPU=x86 CC=$TOOLCHHAINS/bin/i686-linux-android$API-clang CXX=$TOOLCHHAINS/bin/i686-linux-android$API-clang++ CROSS_PREFIX=$TOOLCHHAINS/bin/i686-linux-android- OPTIMIZE_CFLAGS=&quot;-march=i686 -mno-stackrealign&quot; DISABLE_ASM=&quot;--disable-asm&quot; # 编译 buildFF&#125;# x86_64function build_x86_64()&#123; API=21 ABI=x86_64 ARCH=x86_64 CPU=x86-64 CC=$TOOLCHHAINS/bin/x86_64-linux-android$API-clang CXX=$TOOLCHHAINS/bin/x86_64-linux-android$API-clang++ CROSS_PREFIX=$TOOLCHHAINS/bin/x86_64-linux-android- OPTIMIZE_CFLAGS=&quot;-march=$CPU&quot; DISABLE_ASM=&quot;&quot; # 编译 buildFF&#125;# allfunction build_all()&#123; make clean build_armv7 make clean build_arm64 make clean build_x86 make clean build_x86_64&#125;# 编译全部build_all cmake基础语法(判断语句) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 声明最小版本cmake_minimum_required(VERSION 3.18.1)# 声明项目名称project(test)#[[################################## 首先说最常见的if else ################################### 在讲if else之前，先看一下变量的使用# 一般使用set(SET)命令声明一个变量# 下面声明了一个变量BL 它的值是1set(BL 1)# 移除一个变量,这样，这个变量就不能用了unset(BL)# 下面这些都是代表true# true: 1, ON, YES, TRUE, Y,非0值# 下面这些代表false# false： 0, OFF， NO， FALSE， N， IGNORE， NOTFOUND# 比如下面定义一个变量set(BT FALSE)set(TEST NO)if ($&#123;BT&#125;) message(&quot;if BT is true&quot;)elseif($&#123;TEST&#125;) message(&quot;if TEST is true&quot;)else() message(&quot;else else else&quot;)endif() # 这里是结束，别忘了，其中elsif可以不要，直接结束]]####################################### 再说 for循环 ####################################### 在讲for循环之前还要插入讲一下数组的定义# 下面定义了一个数组,从1 ～ 10set(array_list 1 2 3 4 5 6 7 8 9 10)#[[# 第一种，常用的foreach(i $&#123;array_list&#125;) message(&quot; i = $&#123;i&#125;&quot;)endforeach()]]#[[# 第二种foreach(i IN LISTS array_list) message(&quot; i = $&#123;i&#125;&quot;)endforeach()]]#[[# 第三种 RANGEforeach(i RANGE 1 10 2) # 后面三个数字的意思是，从1～10的范围，每次步长为2, 打印1,3,5,7,9 message(&quot; i = $&#123;i&#125;&quot;)endforeach()]]#[[# 第四种 RANGEforeach(i RANGE 10) # 如果只有一个数字，那就是从0开始，到10,打印0～10 message(&quot; i = $&#123;i&#125;&quot;)endforeach()]]#[[ # 第五种 直接列表型foreach(i 1 2 3 4 5 6) # 直接循环 1~6 message(&quot; i = $&#123;i&#125;&quot;)endforeach()]]#################################### 再说 while 循环 ####################################### 格式:#while(表达式)# COMMAND(ARGS...)#endwhile(表达式)文章来源地址https://www.yii666.com/blog/366023.html# 示例while(NOT a STREQUAL &quot;xxx&quot;) set(a &quot;$&#123;a&#125;x&quot;) message(&quot;&gt;&gt;&gt;&gt;&gt;&gt;a = $&#123;a&#125;&quot;)endwhile() 多文件包含 1234567891011121314151617181920212223对于普通的三方库，我们可能直接就给包含到一个cmake中了，但是有的三方库相当的庞大，并且会依赖其他库，而这些依赖库又是独立的， 会独立更新，这时候我们为了方便控制，会使用多cmake文件的方式编译。多文件方式编译关键点如下：1. 注意依赖顺序，需要先编译被依赖的，然后再编译当前的库关键语法：# 包含子目录CMakeLists,这个目录下必须要有CMakeLists.txtadd_subdirectory(test)# 报行子目录相关头文件,这样才能在主库中使用相关的函数include_directories(test/include)target_link_libraries( # Specifies the target library. secondlesson # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; # 这里可以直接使用子目录生成的这个库 test) 示例demo：NDK&#x2F;Lesson2&#x2F;example2 at main · jiangchaochao&#x2F;NDK · GitHub ​ ​","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/Jetpack/10.Navigation/","text":"10.Navigation Navigation概述 12Navigation是指支持用户导航、进入和退出应用中不同内容片段的交互。用于处理Fragment事务，使fragment之间可以自由切换和跳转，同时还包括导航界面模式（例如抽屉式导航栏和底部导航），可以降低用户工作量; Navigation组成(核心三件套) 123451.导航图：在一个集中位置包含所有导航相关信息的 XML 资源。包含用户可以跳转的所有路径，对Navigation来说就像是地图。2.NavHost：用来显示导航图中目标所要展示的内容。3.NavController：在 NavHost 中管理应用导航的对象。负责NavHost里内容的改变如果要在应用中导航，则通过NavController，沿导航图中的特定路径导航至特定目标，或直接导航至特定目标。NavController 就可以在NavHost里进行跳转。 1234567891011 // 指定Navigation的版本 def nav_version = &quot;2.5.3&quot; // Java language implementation implementation &quot;androidx.navigation:navigation-fragment:$nav_version&quot; implementation &quot;androidx.navigation:navigation-ui:$nav_version&quot;// Kotlin implementation &quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot; implementation &quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot; 导航图使用方法 1.创建导航图 导航图是一种资源文件，其中包含Navigation所有目的地和操作。会显示应用的所有导航路径。 1.1. 具体操作 12341.在“Project”窗口中，点击 res 目录，然后依次选择 New &gt; Android Resource File。此时系统会显示 New Resource File 对话框。2.在 File name 字段中输入Navigation的名称，例如“graph”。3.从 Resource type 下拉列表中选择 Navigation，然后点击 OK。这样就完成了空白导航图的创建，这时来到res文档下就会看到navigation文件夹还有你创建的导航图 2.向Activity添加NavHost 分成两种方法： 121. 通过 XML 添加2. 使用布局编辑器添加(暂不介绍) 2.1. 通过 XML 添加 在activity中加入如下代码 12345678910&lt;!-- 这里navGraph的值要改为自己导航图的名字 --&gt;&lt;!-- app.defaultNavHost=&quot;true&quot;表示回退栈由fragment管理 --&gt;&lt;androidx.fragment.app.FragmentContainerView android:id=&quot;@+id/fragmentContainerView&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;409dp&quot; android:layout_height=&quot;729dp&quot; app:defaultNavHost=&quot;true&quot; app:navGraph=&quot;@navigation/navigation_map&quot; /&gt; 3.在导航图中创建目的地 目的地相当于是导航图中的一个个地点，展示各种界面内容 3.1. 具体操作 1.双击导航图，点击右上角的Design，来到下图的 Navigation Editor 界面，点击图中标红图标，然后点击 Create new destination。 2.在接下来的对话框中，创建 Fragment，Android Studio会按照如下配置创建BlankFragment类和fragment_layout布局（fragment_layout中默认采用FrameLayout的布局，可以改成ConstraintLayout） 回到 Navigation Editor 界面就可以看到导航图中已经有了一个目的地 3.连接目的地 操作会将一个目的地连接到另一个目的地，即一个界面是否可以跳转到另一个界面 为了演示，我在上面的基础上再建了一个BFragment 3.1. 具体操作 12345678910111213141516171819201.在系统生成的AFragment类里的onCreateView方法里进行改动2.通过 Navigation.findNavController(view) 方法得到对应 NavController3.使用 NavController 里的 navigate(int) 方法进行导航，该方法的参数为两目的地之间连接的id或者要导向的目的地idpublic class AFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.fragment_a, container, false); inflate.findViewById(R.id.tv_text).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // action_AFragment_to_BFragment为两目的地之间连接的id或者要导航向的目的地id，这个id在navigation_map //的右上角自动生成的 Navigation.findNavController(v).navigate(R.id.action_AFragment_to_BFragment); &#125; &#125;); return inflate; &#125;&#125; 3.2Navigation的返回 1234567891011121314151617181920212223Navigation支持多个返回堆栈可让用户在各个页面之间自由切换，同时不会在任何页面中丢失所处的位置，不需要导航图中有对应的连接就可 以进行返回操作具体操作: 1.在系统生成的BlankFragment类里的onCreateView方法里进行改动 2.通过 Navigation.findNavController(view) 方法得到对应 NavController 3.使用 NavController 里的 popBackStack() 方法即可完成返回public class BFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.fragment_b, container, false); inflate.findViewById(R.id.tvback).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //返回 Navigation.findNavController(v).popBackStack(); &#125; &#125;); return inflate; &#125;&#125; 4.在目的地间传递数据(不研究导航地图的传参了，麻烦无用) 123Bundle bundle=new Bundle();bundle.putString(&quot;name&quot;, &quot;tyl&quot;);Navigation.findNavController(v).navigate(R.id.action_AFragment_to_BFragment,bundle); 接收方通过 getArguments() 方法得到 Bundle 对象并可以使用里面的内容 1String name = getArguments().getString(&quot;name&quot;); &#x2F;&#x2F;BottomNavigationView看了下可扩展性差，不适合正式项目使用，直接不采用这个框架","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/9.WorkManager/","text":"9.WorkManager WorkManager概述 123WorkManager 是适合用于持久性工作的推荐解决方案。如果工作始终要通过应用重启和系统重新启动来调度，便是持久性的工作。由于大多 数后台处理操作都是通过持久性工作完成的，因此 WorkManager 是适用于后台处理操作的主要推荐 API。不依赖于当前用户进程:当前用户进行killed，任务能够继续执行; 12345WorkManager 适用于需要可靠运行的工作，即使用户导航离开屏幕、退出应用或重启设备也不影响工作的执行。例如：向后端服务发送日志或分析数据。定期将应用数据与服务器同步。WorkManager 不适用于那些可在应用进程结束时安全终止的进程内后台工作。它也并非对所有需要立即执行的工作都适用的通用解决方案。 3个主要的核心类 基础使用 1implementation &quot;androidx.work:work-runtime:$work_version&quot; work类定义 (extends Worker) 12345678910111213141516171819202122232425262728public class DemoWork extends Worker &#123; public static final String TAG = DemoWork.class.getSimpleName(); private Context context; private WorkerParameters workerParams; public DemoWork(@NonNull Context context, @NonNull WorkerParameters workerParams) &#123; super(context, workerParams); this.context = context; this.workerParams = workerParams; &#125; @NonNull @Override public Result doWork() &#123; Log.e(TAG, &quot;doWork----------**-----------: 后台任务执行了&quot;); // 接收Activity传递过来的数据 final String dataString = workerParams.getInputData().getString(&quot;data&quot;); Log.e(TAG, &quot;doWork: 接收Activity传递过来的数据:&quot; + dataString); // 反馈数据 给 Activity // 把任务中的数据回传到activity中// Data outputData = new Data.Builder().putString(&quot;data&quot;, &quot;执行完任务将结果和数据回传给Activity&quot;).build(); @SuppressLint(&quot;RestrictedApi&quot;) Result.Success success = new Result.Success(); // return new Result.Failure(); // 本地执行 doWork 任务时 失败 // return new Result.Retry(); // 本地执行 doWork 任务时 重试 // return new Result.Success(); // 本地执行 doWork 任务时 成功 执行任务完毕 return success; &#125;&#125; 单次执行及延迟调用的示例 1234567 //工作通过把WorkRequest传入WorkManager中进行定义。使WorkManager可以调度任何工作; OneTimeWorkRequest oneTimeWorkRequest = new OneTimeWorkRequest.Builder(DemoWork.class) .setInitialDelay(10,TimeUnit.SECONDS) .build();WorkManager.getInstance(this).enqueue(oneTimeWorkRequest); WorkRequest 对象包含 WorkManager 调度和运行工作所需的所有信息 WorkRequest 本身是抽象基类。该类有两个派生实现，可用于创建 OneTimeWorkRequest和 PeriodicWorkRequest 请求。顾名思义，OneTimeWorkRequest 适用于调度非重复性工作，而PeriodicWorkRequest则更适合调度以一定间隔重复执行的工作。 调度一次性工作 123456WorkRequest myWorkRequest = OneTimeWorkRequest.from(MyWork.class);//对于更复杂的工作，可以使用构建器：WorkRequest myWorkRequest = new OneTimeWorkRequest.Builder(MyWork.class) //添加自定义规则 .build(); 调度定期工作 12345678有时可能需要定期运行某些工作。例如，您可能要定期备份数据、定期下载应用中的新鲜内容或者定期上传日志到服务器。使用 PeriodicWorkRequest 创建定期执行的 WorkRequest 对象的方法如下：PeriodicWorkRequest saveRequest = new PeriodicWorkRequest.Builder(SaveImageToFileWorker.class, 1, TimeUnit.HOURS) // Constraints .build();//在此示例中，工作的运行时间间隔定为一小时 1234//执行加急工作 (从 WorkManager 2.7 开始支持).setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)//延迟工作*.setInitialDelay(10, TimeUnit.MINUTES) 工作约束 12345678910111213141516为了让工作在指定的环境下运行，我们可以给WorkRequest添加约束条件，常见的约束条件如下所示。 - **NetworkType**：约束运行工作 所需的网络类型，例如 Wi-Fi (UNMETERED)。 - **BatteryNotLow** ：如果设置为 true，那么当设备处于“电量不足模式”时，工作不 会运行。 - **RequiresCharging**：如果设置为 true，那么工作只能在设备充电时运行。 - **DeviceIdle**：如果设置为 true，则 要求用户的设备必须处于空闲状态才能运行工作。 - **StorageNotLow**：如果设置为 true，那么当用户设备上的存储空间不足时，工作 不会运行。 例如，以下代码会构建了一个工作请求，该工作请求仅在用户设备正在充电且连接到 Wi-Fi 网络时才会运行。Constraints constraints = new Constraints.Builder() .setRequiredNetworkType(NetworkType.UNMETERED) .setRequiresCharging(true) .build();WorkRequest myWorkRequest = new OneTimeWorkRequest.Builder(MyWork.class) .setConstraints(constraints) .build();","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/8.Paging/","text":"8.Paging Paging概述 1Paging 库可帮助您加载和显示来自本地存储或网络中更大的数据集中的数据页面。此方法可让您的应用更高效地利用网络带宽和系统资源; 使用 Paging 库的优势 12345- 分页数据的内存中缓存。该功能有助于确保您的应用在处理分页数据时高效使用系统资源。- 内置的请求去重功能，可确保您的应用高效利用网络带宽和系统资源。- 可配置的RecyclerView适配器，会在用户滚动到已加载数据的末尾时自动请求数据。- 对 Kotlin 协程和数据流以及LiveData和 RxJava 的一流支持。- 内置对错误处理功能的支持，包括刷新和重试功能。 1implementation &#x27;androidx.paging:paging-runtime:2.1.0&#x27; &#x2F;&#x2F;没有认真研究，写真实项目时再认真学习下，以下是简单的使用案例，真实项目可能不一样 1234567891011121314151617181920212223/** * PagedList: 数据源获取的数据最终靠PagedList来承载。 * 对于PagedList,我们可以这样来理解，它就是一页数据的集合。 * 每请求一页，就是新的一个PagedList对象。 */public class StudentViewModel extends ViewModel &#123; // 看源码：@1 listLiveData 数据怎么来的 private final LiveData&lt;PagedList&lt;Student&gt;&gt; listLiveData; public StudentViewModel() &#123; StudentDataSourceFactory factory = new StudentDataSourceFactory(); // 初始化 ViewModel,如何生产一页数据出来给我！ this.listLiveData = new LivePagedListBuilder&lt;Integer, Student&gt;(factory, Flag.SIZE) .setBoundaryCallback(new MyBoundaryCallback()) .build(); &#125; // TODO 暴露数据出去 public LiveData&lt;PagedList&lt;Student&gt;&gt; getListLiveData() &#123; return listLiveData; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RecyclerPagingAdapter extends PagedListAdapter&lt;Student, RecyclerPagingAdapter.MyRecyclerViewHolder&gt; &#123; // TODO 比较的行为 private static DiffUtil.ItemCallback&lt;Student&gt; DIFF_STUDNET = new DiffUtil.ItemCallback&lt;Student&gt;() &#123; // 一般是比较 唯一性的内容， ID @Override public boolean areItemsTheSame(@NonNull Student oldItem, @NonNull Student newItem) &#123; return oldItem.getId().equals(newItem.getId()); &#125; // 对象本身的比较 @Override public boolean areContentsTheSame(@NonNull Student oldItem, @NonNull Student newItem) &#123; return oldItem.equals(newItem); &#125; &#125;; protected RecyclerPagingAdapter() &#123; super(DIFF_STUDNET); &#125; @NonNull @Override public MyRecyclerViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item, null); return new MyRecyclerViewHolder(view); &#125; @Override public void onBindViewHolder(@NonNull MyRecyclerViewHolder holder, int position) &#123; Student student = getItem(position); // item view 出来了， 分页库还在加载数据中，我就显示 Id加载中 if (null == student) &#123; holder.tvId.setText(&quot;Id加载中&quot;); holder.tvName.setText(&quot;Name加载中&quot;); holder.tvSex.setText(&quot;Sex加载中&quot;); &#125; else &#123; holder.tvId.setText(student.getId()); holder.tvName.setText(student.getName()); holder.tvSex.setText(student.getSex()); &#125; &#125; // Item 优化的 ViewHolder public static class MyRecyclerViewHolder extends RecyclerView.ViewHolder &#123; TextView tvId; TextView tvName; TextView tvSex; public MyRecyclerViewHolder(View itemView) &#123; super(itemView); tvId = itemView.findViewById(R.id.tv_id); // ID tvName = itemView.findViewById(R.id.tv_name); // 名称 tvSex = itemView.findViewById(R.id.tv_sex); // 性别 &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; private RecyclerView recyclerView; RecyclerPagingAdapter recyclerPagingAdapter; StudentViewModel viewModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = findViewById(R.id.recycle_view); recyclerPagingAdapter = new RecyclerPagingAdapter(); // 最新版本初始化 viewModel viewModel = new ViewModelProvider(this, new ViewModelProvider.NewInstanceFactory()) .get(StudentViewModel.class); // LiveData 观察者 感应更新 viewModel.getListLiveData().observe(this, new Observer&lt;PagedList&lt;Student&gt;&gt;() &#123; @Override public void onChanged(PagedList&lt;Student&gt; students) &#123; // 再这里更新适配器数据 recyclerPagingAdapter.submitList(students); &#125; &#125;); recyclerView.setAdapter(recyclerPagingAdapter); recyclerView.setLayoutManager(new LinearLayoutManager(this)); &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/7.Hilt/","text":"7.Hilt HILT 是什么 123456789Hilt 提供了一种合并 Dagger 的标准方法 依赖项注入到 Android 应用程序中。Hilt 的目标是： 1.简化 Android 应用的 Dagger 相关基础架构。 2.要创建一组标准的组件和示波器以简化设置， 可读性/理解力，以及应用程序之间的代码共享。 3.提供一种简单的方法来为各种生成提供不同的绑定 类型（例如测试、调试或发布）。Hilt 通过代码为您生成 Dagger 设置代码。这带走了 大多数使用 Dagger 的样板，实际上只留下了 定义如何创建对象以及注入对象的位 置。Hilt 将生成 Dagger 组件和用于自动注入 Android 类的代码 添加依赖项 12345678910111213141516171819202122232425262728293031323334353637383940//1. 配置Hilt的插件路径(project-&gt;build.gradle)buildscript &#123; ... dependencies &#123; ... classpath &#x27;com.google.dagger:hilt-android-gradle-plugin:2.28-alpha&#x27; &#125;&#125;或buildscript &#123;//需要放在plugins之前 dependencies &#123; classpath &#x27;com.google.dagger:hilt-android-gradle-plugin:2.28-alpha&#x27; &#125;&#125;plugins &#123; id &#x27;com.android.application&#x27; version &#x27;7.1.3&#x27; apply false id &#x27;com.android.library&#x27; version &#x27;7.1.3&#x27; apply false&#125;//2. 引入Hilt的插件(app-&gt;build.gradle )apply plugin: &#x27;com.android.application&#x27;apply plugin: &#x27;dagger.hilt.android.plugin&#x27;或plugins &#123; id &#x27;com.android.application&#x27; id &#x27;dagger.hilt.android.plugin&#x27;&#125;//3. 添加Hilt的依赖库及java8android&#123; ... compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;dependencies &#123; ... implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot; annotationProcessor &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;&#125; Hilt 目前支持以下 Android 类： 1234561.Application2.Activity 3.Fragment4.View 5.Service6.BroadcastReceiver 最简单的使用 1234567891011121314151617181920212223242526272829303132333435361.提供一个对象 public class HttpObject &#123;&#125;2.编写Module@InstallIn(ActivityComponent.class)@Modulepublic class HttpModule &#123; @Provides public HttpObject getHttpObject()&#123; return new HttpObject(); &#125;&#125;3.注入到Activity@AndroidEntryPointpublic class MainActivity extends AppCompatActivity &#123; @Inject HttpObject httpObject; @Inject HttpObject httpObject2; 4.Application中注册 @HiltAndroidApppublic class MyApplication extends Application &#123;&#125;5.全局单例使用@InstallIn(ApplicationComponent.class)@Modulepublic class HttpModule &#123; @Provides @Singleton public HttpObject getHttpObject()&#123; return new HttpObject(); &#125;&#125;注意：Hilt注入的字段是不可以声明成private -为接口注入实例 12345678910111213141516171819202122//1public interface AnalyticsService &#123; void analyticsMethods();&#125;//2public class AnalyticsServiceImpl implements AnalyticsService &#123; ... @Inject AnalyticsServiceImpl(...) &#123; ... &#125;&#125;//3@Module@InstallIn(ActivityComponent.class)public abstract class AnalyticsModule &#123; @Binds public abstract AnalyticsService bindAnalyticsService( AnalyticsServiceImpl analyticsServiceImpl );&#125; HILT 常用的注解的含义 123456789101112131415161718192021@HiltAndroidApp@HiltAndroidApp 将会触发 Hilt 的代码生成，作为程序依赖项容器的基类生成的 Hilt 依附于 Application 的生命周期，他是 App 的父组件，提供访问其他组件的依赖在 Application 中配置好后，就可以使用 Hilt 提供的组件了；组件包含 Application，Activity，Fragment，View，Service 等。@HiltAndroidApp创建一个依赖容器，该容器遵循 Android 的生命周期类，目前支持的类型是: Activity, Fragment, View, Service, BroadcastReceiver.@Inject使用 @Inject 来告诉 Hilt 如何提供该类的实例，常用于构造方法，非私有字段，方法中。Hilt 有关如何提供不同类型的实例信息也称之为绑定@Modulemodule 是用来提供一些无法用 构造@Inject 的依赖，如第三方库，接口，build 模式的构造等。使用 @Module 注解的类，需要使用 @InstallIn 注解指定 module 的范围增加了 @Module 注解的类，其实代表的就是一个模块，并通过指定的组件来告诉在那个容器中可以使用绑定安装。@InstallIn使用 @Module 注入的类，需要使用 @InstallIn 注解指定 module 的范围。例如使用 @InstallIn(ActivityComponent::class) 注解的 module 会绑定到 activity 的生命周期上。@Provides常用于被 @Module 注解标记类的内部方法上。并提供依赖项对象。@EntryPointHilt 支持最常见的 Android 类 Application、Activity、Fragment、View、Service、BroadcastReceiver 等等，但是您可能需要在Hilt 不支持的类中执行依赖注入，在这种情况下可以使用 @EntryPoint 注解进行创建，Hilt 会提供相应的依赖。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/6.Room/","text":"6.Room Room是什么？ 12Room 是一个轻量级 orm 数据库，本质上是一个SQLite抽象层，但是使用起来会更加简单，类似于Retrofit库。Room 在开发阶段通过注解 的方式标记相关功能，编译时自动生成响应的 impl 实现类 ORM映射关系设计与详解 123对象关系映射(英语:Object Relational Mapping，简称ORM，或0/RM，或0/R mapping),是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。如今已有很多免费和付费的ORM产品，而有些程序员更倾向于创建自己的ORM工具。 Room使用： 12implementation &quot;androidx.room:room-runtime:2.2.3&quot;annotationProcessor &quot;androidx.room:room-compiler:2.2.3&quot; 1234官网的文档也指出，我们需要创建这三个文件，才能正式的使用Room:1.Entity：普通Java Bean类2.DAO：定义一个接口类3.Room Database：定义一个抽象类，并继承Room Database 1.定义Entity： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 1.Entity类需要使用@Entity注解标注，并且其中的tableName即数据表名，可以改为自己想取的名字 * 2.构造函数：构造函数可以允许多个，但只允许只有一个不加@Ignore注解，其它的都得加上@Ignore注解，实际运行发现，若多个构造函数不 * 加@Ignore，将无法通过编译。至于多个构造函数的存在是因为CRUD的特性决定的，例如删除，只需要id主键就行了。因此提供了多个构造 * 函数 * 3.Getter和Setter方法：这些方法是必须要的，否则无法对对象属性进行读取或修改 *///Entity类需要使用@Entity注解标注，并且其中的tableName即数据表名，可以改为自己想取的名字@Entity(tableName = &quot;StudentDao&quot;)public class StudentEntity &#123; /** * 使用@PrimaryKey声明为主键，并且允许自动生成 * 使用@ColumnInfo表明这个属性是表中的一列列名，并可以指明列的名称 */ @PrimaryKey(autoGenerate = true)//autoGenerate = true 使得主键的值自动生成 @ColumnInfo(name = &quot;id&quot;) private int id; @ColumnInfo private String name; @ColumnInfo private String pwd; @ColumnInfo private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 2.定义 Dao： DAO类主要是提供对数据库的访问方法，是一个接口类。通过将SQL语句与方法结合的方式，降低结构的复杂程度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * DAO层接口,需要添加@Dao注解声明 * 所有的操作都以主键为依托进行 */@Daopublic interface StudentDao &#123; /** * 查询所有的数据，返回List集合 * @return */ @Query(&quot;Select * from StudentDao&quot;) List&lt;StudentEntity&gt; getAllStudentList(); /** * 传递参数的集合，注意 Room通过参数名称进行匹配，若不匹配，则编译出现错误 * @param personId * @return */ @Query(&quot;select * from StudentDao where id in (:personId)&quot;) List&lt;StudentEntity&gt; getStudentById(int[] personId); /** * 返回一定条件约束下的数据，注意参数在查询语句中的写法 * @param minAge * @param maxAge */ @Query(&quot;select * from StudentDao where age between :minAge and :maxAge&quot;) List&lt;StudentEntity&gt; getStudentByAgeRange(int minAge, int maxAge); /** * 插入数据，onConflict = OnConflictStrategy.REPLACE表明若存在主键相同的情况则直接覆盖 * 返回的long表示的是插入项新的id */ @Insert(onConflict = OnConflictStrategy.REPLACE) long insertStudent(StudentEntity studentEntity); /** * 更新数据，这意味着可以指定id然后传入新的person对象进行更新 * 返回的long表示更新的行数 */ @Update int updatePerson(StudentEntity studentEntity); /** * 删除数据，根据传入实体的主键进行数据的删除。 * 也可以返回long型数据，表明从数据库中删除的行数 */ @Delete int deletePerson(StudentEntity studentEntity);&#125; 3.Room Database类构建 得益于Room的良好封装，这个类的构建步骤只有两步，非常的简单。 创建一个StudentDatabase抽象类并继承自RoomDatabase类 声明一个StudentDao()的抽象方法并返回StudentDao的对象引用 1234567/** * 指明是需要从那个class文件中创建数据库，并必须指明版本号 */@Database(entities = &#123;StudentEntity.class&#125;, version = 1)public abstract class StudentDataBase extends RoomDatabase &#123; public abstract StudentDao studentDao();&#125; 这样就完成了对RoomDatabase的构建，这里要注意引入@Database注解，它表明需要与哪一个Entity类产生联系，生成对应的数据库表。并且version版本号是一个必填字段，在这里，我们定义为1即可。 4.在Activity中操作Room 这里要特别注意的是：虽然Room可以通过调用.allowMainThreadQueries()方法允许在主线程中进行查询，但是实际操作中禁止在主线程操作数据库，避免出现ANR问题。需要开启子线程进行数据的操作！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class RoomActivity extends AppCompatActivity &#123; private StudentDataBase studentDataBase; private StudentDao studentDao; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_room); studentDataBase = Room.databaseBuilder( getApplicationContext(), StudentDataBase.class, &quot;StudentDao&quot; ).build(); studentDao = studentDataBase.studentDao(); &#125; private int defaultClick=1; public void addData(View view) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; StudentEntity studentEntity = new StudentEntity(); studentEntity.setName(&quot;name:&quot;+defaultClick); studentEntity.setAge(defaultClick); studentEntity.setPwd(&quot;pwd:&quot;+defaultClick); long l = studentDao.insertStudent(studentEntity); defaultClick++; if (l!=0)&#123; Log.e(&quot;tyl&quot;,&quot;添加成功&quot;); &#125;else &#123; Log.e(&quot;tyl&quot;,&quot;添加失败&quot;); &#125; &#125; &#125;).start(); &#125; public void deleteData(View view) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; List&lt;StudentEntity&gt; allStudentList = studentDao.getAllStudentList(); if (allStudentList!=null&amp;&amp;allStudentList.size()!=0)&#123; studentDao.deletePerson(allStudentList.get(allStudentList.size()-1)); &#125; &#125; &#125;).start(); &#125; public void changeData(View view) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; List&lt;StudentEntity&gt; allStudentList = studentDao.getAllStudentList(); if (allStudentList!=null&amp;&amp;allStudentList.size()!=0)&#123; StudentEntity studentEntity = allStudentList.get(allStudentList.size() - 1); studentEntity.setName(&quot;upData&quot;); studentEntity.setAge(0); studentDao.updatePerson(studentEntity); &#125; &#125; &#125;).start(); &#125; public void queryData(View view) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; List&lt;StudentEntity&gt; allStudentList = studentDao.getAllStudentList(); if (allStudentList!=null&amp;&amp;allStudentList.size()!=0)&#123; for (int i = 0; i &lt;allStudentList.size() ; i++) &#123; StudentEntity studentEntity = allStudentList.get(i); Log.e(&quot;tyl&quot;,&quot;id:&quot;+studentEntity.getId()); Log.e(&quot;tyl&quot;,&quot;name:&quot;+studentEntity.getName()); Log.e(&quot;tyl&quot;,&quot;pwd:&quot;+studentEntity.getPwd()); Log.e(&quot;tyl&quot;,&quot;age:&quot;+studentEntity.getAge()); &#125; &#125; &#125; &#125;).start(); &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/5.ViewModle/","text":"5.ViewModle 什么是ViewModel 1234它是介于View(视图)和Model(数据模型)之间的一个东西。它起到了桥梁的作用，使视图和数据既能分离，也能保持通信。即ViewModel 是以生命周期的方式存储与管理UI相关数据。用于分离 UI 逻辑与 UI 数据。在发生 Configuration Changes 时，它不会被销毁。在界面重建后，方便开发者呈现界面销毁前 的 UI 状态。 ViewModel的特性 123456789101112131415161.数据持久化2.异步回调问题，不会造成内存泄漏3.隔离Model层与View层4.Fragments间共享数据ViewModel出现所解决的问题： 1.Activity的具体生命周期管理，每一次反转都是去重新创建了一个Activity 2.Activity的使用，正常onDestory都会清空数据，每次onCreate都会重新加载进来 （手机旋转时，activity会销毁后新建1个activity,viewmodel相当于在做了数据恢复，onCreate数据恢复） 业务目的： 是为了达成数据持久化，去规避Activity在设计当中对于旋转处理造成的实例Activity重置下的数据保存问题 1.ViewModel = Boudle使用！ 2.只不过是作了上层的封装！ 3.利用了jetpack组件套当中的应用！ 4. 在上一个被销毁的Activity与新建的这个Activity之间建立一个Boudle数据传递！ 1.依赖库 1implementation &#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27; 2.使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//1.model类public class DataModel extends ViewModel &#123; private int age=0; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;//2.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_display&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/black&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot;/&gt; &lt;Button android:id=&quot;@+id/bn_change&quot; android:onClick=&quot;change&quot; android:text=&quot;change&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;Button android:id=&quot;@+id/bn_rote&quot; android:onClick=&quot;rote&quot; android:text=&quot;rote&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt;//3.使用类public class ViewModelActivity extends AppCompatActivity &#123; private ActivityViewModelBinding binding; private DataModel dataModel; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.activity_view_model); //不能直接 new DataModel()，这种方式无法自动恢复数据 dataModel = new ViewModelProvider(this).get(DataModel.class); Log.e(&quot;tyl&quot;,&quot;age=&quot;+ dataModel.getAge()); &#125; public void change(View view) &#123; dataModel.setAge(dataModel.getAge()+1); binding.tvDisplay.setText(dataModel.getAge()+&quot;&quot;); &#125; //旋转后activity销毁后重新onCreate，但是会恢复age在销毁前的值 private Boolean isLand=false; public void rote(View view) &#123; setScreenOrientation(isLand); &#125; public void setScreenOrientation(boolean isLandScape)&#123; if (isLandScape)&#123; setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);// 横屏 &#125;else &#123; setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);// 横屏 &#125; isLand=!isLand; &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/4.Dagger2/","text":"4.Dagger2 什么是Dagger2 12Dagger 2是由Google开发的 依赖注入框架，它利用Java和Java注解处理器的强大功能，提供了一种优雅的方式来进行依赖注入。Dagger 2基于一组注解和代码生成器，可以在编译时自动生成依赖注入的代码，从而提高性能和类型安全性。 dagger2 简单理解 123451.一般我们使用一个实体类或者工具或者请求，比如在MainActivity中使用UerInfo.class，我们会在new Userinfo()，去使用而dagger帮我们省略了这一步，dagger去管理new UserInfo()，我们直接在Activity中使用。2.dagger 理解其实就是相当于买了快递后，快递送货流程实现此流程需要四个注解 @Module @Component @Provides @Inject如下图： dagger2 的使用 1.在build.gradle中引入插件 1234// dagger2 的功能支持implementation &#x27;com.google.dagger:dagger:2.4&#x27;// dagger2 自己的注解处理器annotationProcessor &#x27;com.google.dagger:dagger-compiler:2.4&#x27; 2.简单使用： 123456789101112131415161718192021222324252627282930313233343536373839404142//1.HttpObject 对象--&gt;快递public class HttpObject &#123; private String HttpClient=&quot;client&quot;; public String getHttpClient() &#123; return HttpClient; &#125; public void setHttpClient(String httpClient) &#123; HttpClient = httpClient; &#125;&#125;//2.HttpModule--&gt;包裹@Module// 包裹注解public class HttpModule &#123; @Provides // 暴露出去注解 public HttpObject providerHttpObject()&#123; //........ return new HttpObject(); &#125;&#125;//3.Component 类似于快递员，拿到所有包裹-&gt;根据地址配给用户//存放module的组件@Component(modules = &#123;HttpModule.class, DataModule.class&#125;)public interface MyComponent &#123; //注入的位置就写在参数上 不能用多态 void injectMainActivity(Dagger2Activity mainActivity);&#125;//4.用户使用--&gt;接收快递public class Dagger2Activity extends AppCompatActivity &#123; @Inject HttpObject httpObject; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger); //rebuild项目后才有DaggerMyComponent文件,Dagger+自定义的Component名字 // 方式1： 注入// DaggerMyComponent.create().injectMainActivity(this); // 方式2： DaggerMyComponent.builder().httpModule(new HttpModule()).build().injectMainActivity(this); Log.e(&quot;tyl&quot;,httpObject.getHttpClient()); &#125;&#125; 3.dagger2 单例使用 1231.局域单例：存在于当前类中，只有一个实例，需要增加一个单例注解 @Singleton。2.全局单例：存在于整个项目，只有一个实例，需要增加一个单例注解 @Singleton，全局单例需要配合Application使用，否则只能是 当前activity单例。 局域单例示例：(在moudle和Component类中添加@Singleton注解) 123456789101112131415161718192021222324252627282930313233343536//1.moudle@Modulepublic class HttpModule &#123; @Singleton @Provides // 暴露出去注解 public HttpObject providerHttpObject()&#123; //........ return new HttpObject(); &#125;&#125;//2.Compinent类@Singleton@Component(modules = &#123;HttpModule.class&#125;)public interface MyComponent &#123; void injectMainActivity(Dagger2Activity dagger2Activity);&#125;//3.使用示例：public class Dagger2Activity extends AppCompatActivity &#123; @Inject HttpObject httpObject; @Inject HttpObject httpObject2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger); //rebuild项目后才有DaggerMyComponent文件,Dagger+自定义的Component名字 // 方式1： 注入// DaggerMyComponent.create().injectMainActivity(this); // 方式2： DaggerMyComponent.builder().httpModule(new HttpModule()).build().injectMainActivity(this); Log.e(&quot;tyl&quot;,httpObject.hashCode()+&quot;&quot;); Log.e(&quot;tyl&quot;,httpObject2.hashCode()+&quot;&quot;); //得出结果值一样 &#125;&#125; 全局单例示例：(在moudle和Component类中添加@Singleton注解) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//1.Component中添加次级要调用的类@Singleton@Component(modules = &#123;HttpModule.class&#125;)public interface MyComponent &#123; //多少个类就自定义多少个方法 void injectMainActivity(Dagger2Activity dagger2Activity); void injectSecActivity(Dagger2Activity2 dagger2Activity2);&#125;//2.application中注入public class MyApplication extends Application &#123; private MyComponent myComponent; private static MyApplication context; @Override public void onCreate() &#123; super.onCreate(); context = this; myComponent = DaggerMyComponent.builder() .httpModule(new HttpModule()) .build(); &#125; public static MyApplication getInstance() &#123; return context; &#125; public MyComponent getMyComponent() &#123; return myComponent; &#125;&#125;//3.主activity中执行调用public class Dagger2Activity extends AppCompatActivity &#123; @Inject HttpObject httpObject; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger); MyApplication.getInstance().getMyComponent().injectMainActivity(this); Log.e(&quot;tyl&quot;,httpObject.hashCode()+&quot;&quot;); &#125; public void jump(View view) &#123; startActivity(new Intent(this,Dagger2Activity2.class)); &#125;&#125;//4.次activity中执行调用public class Dagger2Activity2 extends AppCompatActivity &#123; @Inject HttpObject httpObject; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyApplication.getInstance().getMyComponent().injectSecActivity(this); Log.e(&quot;tyl&quot;,httpObject.hashCode()+&quot;&quot;); &#125;&#125; 4.多个Component组合依赖 dagger2不能使用多个Component同时注入同一个类中 这种情况需要进行Component的组合; 先确定使用哪个 Component 作为主 Component，确定后，主 Component 仍然执行注入操作，而其他 Component 作为依赖项，不再执行注入，转而提供 Module 提供的对象。一般我们会选择 ApplicationComponent 作为主 Component。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//1.新建一个对象DataObjectpublic class DataObject &#123; private String data=&quot;data&quot;; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125;//2.新建一个moudle@Modulepublic class DataModule &#123; @Provides public DataObject providerDatabaseObject()&#123; //........ return new DataObject(); &#125;&#125;//3.新建一个Component@Component(modules = &#123;DataModule.class&#125;)public interface SecondComponent &#123; //使用依赖关系，就不再使用这种语法 //void injectMainActivity(Dagger2Activity dagger2Activity); //直接提供object对象及自定义方法名 DataObject providerDatabaseObject();&#125;//4.在ApplicationComponent 的 @Component 注解值中增加 dependencies，指定依赖的 Component：@Singleton@Component(modules = &#123;HttpModule.class&#125;,dependencies = &#123;SecondComponent.class&#125;)public interface MyComponent &#123; void injectMainActivity(Dagger2Activity dagger2Activity); void injectSecActivity(Dagger2Activity2 dagger2Activity2);&#125;//5.application中新增指定的实现类public class MyApplication extends Application &#123; private MyComponent myComponent; private static MyApplication context; @Override public void onCreate() &#123; super.onCreate(); context = this; myComponent = DaggerMyComponent.builder() .httpModule(new HttpModule()) //指定 PresenterComponent 的实现类 .secondComponent(DaggerSecondComponent.create()) .build(); &#125; public static MyApplication getInstance() &#123; return context; &#125; public MyComponent getMyComponent() &#123; return myComponent; &#125;&#125;//6.使用public class Dagger2Activity extends AppCompatActivity &#123; @Inject HttpObject httpObject; @Inject DataObject dataObject; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger); MyApplication.getInstance().getMyComponent().injectMainActivity(this); Log.e(&quot;tyl&quot;,httpObject.hashCode()+&quot;&quot;); Log.e(&quot;tyl2&quot;,dataObject.getData()+&quot;&quot;); &#125;&#125; @Scope 假如现在有个需求，想让 DataObject 也变成个单例对象，按照我们之前的做法，给 PresenterModule 中的 Provides 方法和 PresenterComponent 加上 @Singleton 之后，会发现编译报错了： 1com.demo.dagger.component.ApplicationComponent also has @Singleton 它说 ApplicationComponent 中已经有 @Singleton 了。显然，Dagger2 要求 @Singleton 不能用在多个组件上。 123456使用 @Scope 的原则：1.多个 Component 上面的 Scope 不能相同2.没有 Scope 的 Component 不能依赖有 Scope 的组件3.使用作用域注解的模块只能在带有相同作用域注解的组件中使用4.使用构造方法注入（通过 @Inject）时，应在类中添加作用域注解；使用 Dagger 模块时，应在 @Provides 方法中添加作用域注解 @Scope 注解表示作用域，被其修饰的类或提供对象的方法会被做成单例，所以我们可以用 @Scope 自定义一个作用域注解： 123@Scope@Retention(RetentionPolicy.RUNTIME)public @interface MyScope &#123;&#125;//自定义名字 实际上它和 @Singleton 一样只是名字不同： 1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 以下示例编译报错，未查明原因 Component使用 1234567@MyScope@Component(modules = &#123;DataObject.class&#125;)public interface SecondComponent &#123; //使用依赖关系，就不再使用这种语法// void inject(MainActivity activity); DataObject providerDatabaseObject();&#125; moudle使用 12345678910@Module@MyScopepublic class DataModule &#123; @MyScope @Provides public DataObject providerDatabaseObject()&#123; //........ return new DataObject(); &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/3.DataBinding/","text":"3.DataBinding 什么是DataBinding 1234DataBinding 是谷歌官方发布的一个框架，顾名思义即为数据绑定，是 MVVM 模式在 Android 上的一种实现，用于降低布局和逻辑的耦合性，使代码逻辑更加清晰。DataBinding 能够省去我们一直以来的 findViewById() 步骤，大量减少 Activity 内的代码，数据能够单向或双向绑定到 layout 文件中，有助于防止内存泄漏，而且能自动进行空检测以避免空指针异常。 启用 DataBinding 的方法是在对应 Model 的 build.gradle 文件里加入以下代码，同步后就能引入对 DataBinding 的支持 123456android &#123; ... buildFeatures &#123; dataBinding true &#125;&#125; 简单使用 启用 DataBinding 后，这里先来看下如何在布局文件中绑定指定的变量 打开布局文件，选中根布局的 ViewGroup，按住 Alt + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则 这里先来声明一个 Modle 12345678910111213141516171819202122public class User &#123; private String name; private String pwd; public User(String name, String pwd) &#123; this.name = name; this.pwd = pwd; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 和原始布局的区别在于多出了一个 layout 标签将原布局包裹了起来，data 标签用于声明要用到的变量以及变量类型，要实现 MVVM 的 ViewModel 就需要把数据（Model）与 UI（View）进行绑定，data 标签的作用就像一个桥梁搭建了 View 和 Model 之间的通道 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type= &quot;com.tyl.mystudy2.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:textSize=&quot;50dp&quot; android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.name&#125;&quot; /&gt; &lt;TextView android:textSize=&quot;50dp&quot; android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.pwd&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 通过 @&#123;viewModel.name&#125; 使 TextView 引用到相关的变量，DataBinding 会将之映射到相应的 getter 方法 之后可以在 Activity 中通过 DataBindingUtil 设置布局文件，省略原先 Activity 的 setContentView() 方法，并为变量 userInfo 赋值 如果 User 类型要多处用到，也可以直接将之 import 进来，这样就不用每次都指明整个包名路径了，而 java.lang.* 包中的类会被自动导入，所以可以直接使用 123456&lt;data&gt; &lt;import type=&quot;com.tyl.mystudy2.User&quot;/&gt; &lt;variable name=&quot;user&quot; type= &quot;User&quot;/&gt; &lt;/data&gt; 由于 @&#123;user.name&#125;在布局文件中并没有明确的值，所以在预览视图中什么都不会显示，不便于观察文本的大小和字体颜色等属性，此时可以为之设定默认值（文本内容或者是字体大小等属性都适用），默认值将只在预览视图中显示，且默认值不能包含引号 1android:text=&quot;@&#123;user.name,default=defaultValue&#125;&quot; 在 Activity 中通过 DataBindingUtil 设置布局文件，省略原先 Activity 的 setContentView() 方法，并为变量 userInfo 赋值 1234567891011121314public class DataBindingActivity extends AppCompatActivity &#123; private ActivityDatabindingBinding binding; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //注意DataBindingUtil.setContentView()的返回值是DataBindingUtil工具生成的Binding类， //布局文件名来生成，将之改为首字母大写的驼峰命名法来命名，并省略布局文件名包含的下划线 binding = DataBindingUtil.setContentView(this, R.layout.activity_databinding); //数据是从网络或是数据库拿来的 User user=new User(&quot;jett&quot;,&quot;123&quot;); binding.setUser(user);//view.setText(text); binding.setVariable(BR.name,&quot;jett&quot;); &#125;&#125; 此外，也可以通过 ActivityMain2Binding 直接获取到指定 ID 的控件 1binding.tv1.setText(&quot;tyl&quot;); Databinding 同样是支持在 Fragment 和 RecyclerView 中使用 。例如，可以看 Databinding 在 Fragment 中的使用 123456@Override public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; FragmentBlankBinding fragmentBlankBinding = DataBindingUtil.inflate(inflater, R.layout.fragment_blank, container, false); fragmentBlankBinding.setHint(&quot;Hello&quot;); return fragmentBlankBinding.getRoot(); &#125; 以上实现数据绑定的方式，每当绑定的变量发生变化的时候，都需要重新向 ViewDataBinding 传递新的变量值才能刷新 UI 。接下来看如何实现自动刷新 UI 驱动 UI 刷新 实现数据变化自动驱动 UI 刷新的方式有三种：BaseObservable、ObservableField、ObservableCollection BaseObservable 一个纯净的 ViewModel 类被更新后，并不会让 UI 自动更新。而数据绑定后，我们自然会希望数据变更后 UI 会即时刷新，Observable 就是为此而生的概念 BaseObservable 提供了 notifyChange() 和 notifyPropertyChanged() 两个方法，前者会刷新所有的值域，后者则只更新对应 BR 的 flag，该 BR 的生成通过注释 @Bindable 生成，可以通过 BR notify 特定属性关联的视图 1234567891011121314151617181920212223242526272829public class User extends BaseObservable &#123; //如果是 public 修饰符，则可以直接在成员变量上方加上 @Bindable 注解 @Bindable public String name; //如果是 private 修饰符，则在成员变量的 get 方法上添加 @Bindable 注解 private String pwd; public User(String name, String pwd) &#123; this.name = name; this.pwd = pwd; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Bindable public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; //更新所有字段 this.pwd = pwd; notifyChange(); &#125;&#125; 在 setName() 方法中更新的只是本字段，而 setPwd() 方法中更新的是所有字段","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/2.LiveData/","text":"2.LiveData MyJetpackStudy: jetpack学习 (gitee.com) 1.什么是LiveData 12345LiveData是Jetpack组件的一部分，更多的时候是搭配ViewModel来使用，相对于Observable，LiveData的最大优势是其具有生命感知的， 换句话说，LiveData可以保证只有在组件（ Activity、Fragment、Service）处于活动生命周期状态的时候才会更新数据。LiveData是一个可观察的数据持有者类，与常规的Observable不同，LiveData可感知Activity、Fragment、Service的生命周期，确保 LiveData仅更新处于活动生命周期状态的组件观察者。如果应用程序组件观察者处于started或者resumed，则LiveData认为该组件处于 活跃状态，该组件会收到LiveData的数据更新，而其他注册的组件观察者将不会收到任何数据更新。 LiveData的优点 12345678910111213141516171.确保界面符合数据状态LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中 更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。2.不会发生内存泄漏观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。3.不会因 Activity 停止而导致崩溃如果观察者的生命周期处于非活跃状态（如返回堆栈中的 activity），它便不会接收任何 LiveData 事件。4.不再需要手动处理生命周期界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。5.数据始终保持最新状态如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。6.适当的配置更改如果由于配置更改（如设备旋转）而重新创建了 activity 或 fragment，它会立即接收最新的可用数据。7.共享资源您可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。 使用 LiveData 对象 123456789101112请按照以下步骤使用LiveData对象：1. 创建 LiveData的实例以存储某种类型的数据。这通常在ViewModel类中完成。2. 创建可定义 onChanged()对象，该方法可以控制当LiveData对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器 （如 activity 或 fragment）中创建 Observer对象。3. 使用 observe()方法将Observer对象附加到 LiveData对象。observe()方法会采用LifecycleOwner对象。这样会使Observer对象 订阅LiveData对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 activity 或 fragment）中附加Observer对象。 当您更新存储在LiveData对象中的值时，它会触发所有已注册的观察者（只要附加的LifecycleOwner处于活跃状态）。LiveData允许界面控制器观察者订阅更新。当LiveData对象存储的数据发生更改时，界面会自动更新以做出响应。 LiveData的使用 常用方法： 方法名 作用 setValue(T value)： 设置 LiveData 的值，并通知所有活跃的观察者进行更新。此方法应在主线程中调用 postValue(T value) 与setValue()类似，但可以在任何线程中调用。内部使用 Handler 来确保更新操作在主线程执行。 getValue() 获取当前 LiveData 实例的值 observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) 将观察者（Observer）添加到 LiveData。当 LiveData 的值发生变化时，会通知观察者。该方法传入一个 LifecycleOwner 对象（如 Activity 或 Fragment），LiveData 将观察者与该 LifecycleOwner 的生命周期关联起来，以自动管理观察者的注册和取消注册。 hasObservers() 检查 LiveData 是否有活跃的观察者。 removeObserver(Observer&lt;? super T&gt; observer) 从 LiveData 中移除观察者。 observeForever(Observer&lt;? super T&gt; observer) 与 observe()类似，但观察者不会自动注销。需要手动调用 removeObserver()方法来取消观察。 简单示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class NameViewModel extends ViewModel &#123; // 使用字符串创建LiveData private MutableLiveData&lt;String&gt; currentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (currentName == null) &#123; currentName = new MutableLiveData&lt;String&gt;(); &#125; return currentName; &#125;&#125;public class LiveDataActiviry extends BaseActivity &#123; private NameViewModel model; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=findViewById(R.id.button); Button button2=findViewById(R.id.button2); model = new ViewModelProvider(this).get(NameViewModel.class); // 创建用于更新UI的观察者 Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String newName) &#123; // 更新UI button.setText(newName); &#125; &#125;; // 观察LiveData，将此活动作为LifecycleOwner和observer传入 model.getCurrentName().observe(this, nameObserver); //更新LiveData对象的值 button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String anotherName = &quot;John Doe&quot;; //主线程传值 model.getCurrentName().setValue(anotherName); //子线程传值// new Thread(new Runnable() &#123;// @Override// public void run() &#123;// model.getCurrentName().postValue(&quot;anotherName&quot;);// &#125;// &#125;).start(); &#125; &#125;); &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android进阶/Jetpack/1.LifeCycle/","text":"1.LifeCycle MyJetpackStudy: jetpack学习 (gitee.com) Lifecycle是什么？ 1234lifecycle 是属于Android Jetpack（官方开发工具包）—— Architecture（架构组件）中的一员。官方介绍:构建生命周期感知型组件，这些组件可以根据 Activity 或 Fragment 的当前生命周期状态调整行为。白话:lifecycle可以和Activity或Fragment生命周期绑定，方便我们做一些跟生命周期相关的业务逻辑。 Lifecycle的特点 12345671.生命周期感知：Lifecycle 可以感知应用组件的生命周期状态，包括活动状态、暂停状态、停止状态等。2.简化生命周期回调：使用 Lifecycle，可以避免在应用组件中手动实现繁琐的生命周期回调。3.灵活性：Lifecycle 可以与其他 Jetpack 组件（如 ViewModel、LiveData 等）结合使用，提供更灵活的生命周期管理方案。4.生命周期安全性：Lifecycle 能够确保在正确的生命周期状态下执行相应的操作，避免了可能导致崩溃或内存泄漏的问题。通过 Lifecycle，开发者可以更好地管理和控制应用组件的生命周期，执行与生命周期相关的操作，如初始化资源、释放资源、注册/注销观察者等。它可以帮助开发者编写更健壮、可维护的代码，并提供更好的用户体验。 Lifecycle使用 1.先看看可以引用哪些？ 12//androidximplementation &#x27;androidx.appcompat:appcompat:1.3.0&#x27; 12345678910111213141516171819 //非androidx dependencies &#123; def lifecycle_version = &quot;1.1.1&quot; // 包含ViewModel和LiveData implementation &quot;android.arch.lifecycle:extensions:$lifecycle_version&quot; // 仅仅包含ViewModel implementation &quot;android.arch.lifecycle:viewmodel:$lifecycle_version&quot; // For Kotlin use viewmodel-ktx // 仅仅包含LiveData implementation &quot;android.arch.lifecycle:livedata:$lifecycle_version&quot; // 仅仅包含Lifecycles implementation &quot;android.arch.lifecycle:runtime:$lifecycle_version&quot; annotationProcessor &quot;android.arch.lifecycle:compiler:$lifecycle_version&quot; // For Kotlin use kapt instead of annotationProcessor // 如果用Java8, 用于替代compiler implementation &quot;android.arch.lifecycle:common-java8:$lifecycle_version&quot; // 可选，ReactiveStreams对LiveData的支持 implementation &quot;android.arch.lifecycle:reactivestreams:$lifecycle_version&quot; // 可选，LiveData的测试 testImplementation &quot;android.arch.core:core-testing:$lifecycle_version&quot;&#125; 除了Activity和Fragment外，还可以绑定Service和Application的生命周期。只要引入支持相关的可选库即可；官方提到最多的是Activity和Fragment，是因为平时主要用于这两个组件；其实只要有生命周期的组件都可以跟它绑定。而在Android中大多数的组件都是有生命周期的。 2.简单使用案例： 1234567891011121314151617181920212223242526272829303132333435363738package com.example.lifecycledemo1;import android.arch.lifecycle.Lifecycle;import android.arch.lifecycle.LifecycleObserver;import android.arch.lifecycle.OnLifecycleEvent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; private static final String TAG = &quot;MainActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getLifecycle().addObserver(new MyObserver());//1 &#125; public class MyObserver implements LifecycleObserver&#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) void onResume()&#123; Log.d(TAG, &quot;Lifecycle call onResume&quot;); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause()&#123; Log.d(TAG, &quot;Lifecycle call onPause&quot;); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onResume&quot;); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG, &quot;onPause&quot;); &#125;&#125; 工具类封装： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//使用：被观察者继承BaseActivity或者添加getLifecycle().addObserver(new BaseLifeCycle());即可public abstract class BaseActivity &lt;T extends BaseLifeCycle&gt; extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getLifecycle().addObserver(new BaseLifeCycle()); &#125;&#125; //观察者类public class BaseLifeCycle implements LifecycleObserver&#123; private String TAG=&quot;tyl&quot;; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate(LifecycleOwner owner) &#123; Log.e(TAG, &quot;BaseLifeCycle-onCreate:&quot;+owner.getClass().toString()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart(LifecycleOwner owner) &#123; Log.e(TAG, &quot;BaseLifeCycle-onStart:&quot;+owner.getClass().toString()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void onStop(LifecycleOwner owner) &#123; Log.e(TAG, &quot;BaseLifeCycle-onStop:&quot;+owner.getClass().toString()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) void onResume(LifecycleOwner owner) &#123; Log.e(TAG, &quot;BaseLifeCycle-onResume:&quot;+owner.getClass().toString()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause(LifecycleOwner owner) &#123; Log.e(TAG, &quot;BaseLifeCycle-onPause:&quot;+owner.getClass().toString()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestory(LifecycleOwner owner) &#123; Log.e(TAG, &quot;BaseLifeCycle-onDestory:&quot;+owner.getClass().toString()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onAny(LifecycleOwner owner) &#123;//无论当前活动处于何种生命周期状态，都会触发相应的生命周期方法// Log.e(TAG, &quot;BaseLifeCycle-onAny:&quot;+owner.getClass().toString()); &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/Android FrameWork/wine安装及使用/","text":"Wine介绍： 1234567Wine是一个允许在Linux和其他类Unix操作系统上运行Windows应用程序的兼容层。它通过将Windows API转换为本地系统调用来实现这一目标。使用Wine，用户可以在Linux系统上运行许多Windows应用程序，而无需安装Windows操作系统。要使用Wine，用户需要首先安装Wine软件包。然后，他们可以使用“wine”命令来运行Windows应用程序。官网主页：https://wiki.winehq.org/%E4%B8%BB%E9%A1%B5官网：https://wiki.winehq.org/Download官网 ubuntu 安装步骤链接：https://wiki.winehq.org/Ubuntu_zhcn 安装 Wine 方法: 1234567891011121314151617181920212223242526272829301、如果您使用的是 64 位系统，请开启 32 bit 架构支持（如果您之前没有开启的话）： sudo dpkg --add-architecture i386 2、下载添加仓库密钥： sudo mkdir -pm755 /etc/apt/keyrings sudo wget -O /etc/apt/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key3、并添加仓库： Ubuntu 22.04: sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/jammy/winehq-jammy.sources4、更新安装包： sudo apt update5、然后安装 以下任一一个安装包： 稳定分支： sudo apt install --install-recommends winehq-stable 开发分支： sudo apt install --install-recommends winehq-devel Staging 分支： sudo apt install --install-recommends winehq-staging 如果 apt-get 提示缺少依赖，请先安装缺少的依赖，然后重复以上两步（update 和 install）。//遇到依赖问题：0468:err:mscoree:CLRRuntimeInfo_GetRuntimeHost Wine Mono is not installed解决方案：1.将所有软件及系统更新到最新；2.sudo apt-get install mono-complete3.上面还是没有安装成功的话则： sudo aptitude install mono-complete //aptitude可能需要安装 安装winetricks 123451.在软件商城里面搜索安装winetricks。安装后在终端输入winetricks，会打开图形界面设置。 在winetricks选择一些常用的元件保证常用windows程式的运行。2.推荐选择的Windows部件主要有：riched20，riched30，ie8，vcrun6，flash11，gdiplus，msls31，msxml6，vcrun2005，vcrun2008， winhttp元件。//有些部件没有，可不安装 字体乱码 1winetricks上可以安装字体。也可手动将 Windows 下面的字体复制到~/.wine/drive_c/windows/Fonts/ 。 安装&#x2F;卸载软件 1234567安装：在exe文件目录，执行：wine xx.exe卸载： 运行 wine uninstall.exe往往没用。直接手动删除。 1、进入 ~/.wine/drive_c(wine的虚拟C盘) 在Program Files 和 Program Files (x86) 找到相应目录删除 2、进入 ~/.local/share/applications/wine/Programs/ 删除 3、进入~/.config/menus/applications-merged删除对应文件（这里对应显示的图标） 如果同时使用 deepin-wine 和 wine，wine下安装的软件目录可能跑到deepin-wine的目录下。 wine的常用命令 12345678910111213141516171819202122wine [程序名] （运行Windows程序）winecfg （配置Wine的图形界面设置，可以设置Windows版本、驱动程序、DLL文件等）wine control （控制面板）wine taskmgr （任务管理器）wine uninstaller （卸载安装的Windows应用程序,稍等即可出现添加-删除程序的界面）wine regedit / regedit （打开wine中Windows注册表编辑器。）wine notepad （记事本）wineboot （ 模拟Windows启动和关闭过程）winefile （打开模拟的Windows文件管理器；）wineserver 启动wine服务器进程，用于管理wine进程。winemine 运行Windows版的扫雷游戏；winetricks 安装特定的Windows应用程序； winepath [路径] 转换Windows路径到Unix路径；winemaker 自动生成Makefiles；regsvr32 [DLL文件名] 注册DLL文件。wineconsole [程序名] 在控制台中运行Windows程序。wine msiexec /i install.msi //有些windows的安装程序是使用msi来安装的.wine start install.msi //使用msi来安装window应用wine eject d: //如果安装程序需要你换CD，而系统却说不能推出CD，那就打开一个新终端wine uninstaller //使用命令“uninstaller”来卸载安装的程序,稍等即可出现添加-删除程序的界面 所有命令列表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551、这些子程序通常可通过运行以下程序访问： wine wineprogram arg1 arg2 ...2、只要Wine安装在用户的$PATH中）。 这些程序的完整列表可以在Wine的源代码中的programs/下找到。cacls - 编辑ACLclock - 显示基本时钟cmd - 命令提示符实现cmdlgtst - （用于开发人员）commdlg.dll测试夹具control - 控制面板实施eject - 弹出光盘（请注意，wine eject与正常的弹出命令不同）expand - 展开cabinet（.cab）文件explorer - explorer.exe实现hh - HTML帮助（.chm文件）查看器icinfo - 显示已安装的Wine视频压缩器iexplore - Internet Explorer实现lodctr - 加载性能监视器计数器msiexec - miexec.exe安装.msi文件的实现net - 启动和停止服务notepad - 记事本，一个简单的文本编辑器oleview - 允许浏览和探索COM对象以及配置DCOMprogman - 程序管理器实现reg - 基于reg控制台的注册表编辑器regedit - 注册表编辑器实现regsvr32 - 在注册表中注册OLE组件rpcss - rpcss.exe的准实现rundll32&quot;] - 加载DLL并使用指定参数运行入口点secedit - 安全配置编辑命令services - 管理服务spoolsv - 打印包装start - 启动程序或打开程序中的文档，该程序通常用于带有该后缀的文件svchost - 服务的（内部）主机进程taskmgr - 任务管理器实现uninstaller - 基本程序卸载程序unlodctr - 卸载性能监视器计数器view - 图元文件查看器wineboot - “重新启动”（restarts）Wine，用于Windows应用程序需要真正重新启动时。winebrowser - 启动本地OS浏览器或邮件客户端winecfg - Wine的GUI配置工具wineconsole - 显示Windows控制台winedbg - Wine调试器内核winedevice - （内部）管理设备winefile - 文件资源管理器实现winemenubuilder - 帮助构建Unix菜单项winemine - 经典扫雷游戏winepath - 在Windows和Unix路径格式之间转换winetest - 适用于无人值守测试和报告提交的所有DLL一致性测试程序winevdm - Wine虚拟DOS程序winhelp - 帮助查看器winhlp32 - 帮助查看器（32位）winver - 显示“关于葡萄酒”窗口wordpad - wordpad.exe实现write - 启动字板（用于Win16兼容性）xcopy - 与Wine兼容的xcopy程序 这些程序直接运行（即不是“葡萄酒程序”，只是“程序”）： 123winelauncher-尝试智能地管理使用Wine启动程序的程序。wineserver-为Wine提供与Windows内核在Windows上提供的服务大致相同的守护进程。 工具 123456789101112131415161718192021这些工具是帮助Wine开发的脚本和可执行文件的集合。在工具目录（例如~/wine git/tools/wineinstall）中，它们作为独立命令调用。这些命令的完整列表可以在wine-&lt;version&gt;/tools的源代码中找到/buildimage - 从SVG文件生成位图和图标文件c2man.pl - 生成API文档config.guess - 尝试猜测规范系统名称findfunc - 尝试查找指定的Wine程序/工具install-sh - 安装程序、脚本或数据文件makedep - 在构建Wine之前生成makefile和依赖项make_fir - 生成dsound使用的fir滤波器make_makefiles - 根据对源树的更改更新configure和Makefile.in文件make_requests - 更新Wine服务器协议描述文件make_specfiles - 在发生更改时更新.spec文件make_unicode - 基于unicode.org中的文件重建unicode表make_xftmpl - 从.x源文件生成二进制标头runtest - wapper脚本，用于从构建树内部运行Wine回归测试之一sfnt2fon - 仅将位图ttf转换为窗口字体文件wineapploader - 安装Winelib应用程序后启动该应用程序的包装器脚本wineinstall - Wine安装脚本（上次更新于2009年；不推荐）winemaker - 帮助将Windows源代码转换为Winelib程序","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/Framework相关/SystemUI/","text":"环境：android13.0.0_r6 1、SystemUI介绍 1.1、SystemUI摘要 12在Android系统中SystemUI是以应用的形式运行在Android系统当中，即编译SystemUI模块会生产APK文件，源代码路径在frameworks/base/packages/SystemUI/，安装路径system/priv-app/-SystemUI。 1.2、什么是SystemUI 123456789在前文1.1章节中可知，SystemUI是一个普通的APK文件，即是一个普通的APP，但是，手机使用者看见的所有SystemUI的内容都不像是一个APP，为什么？既然是一个应用，就是完成特定的功能，SystemUI主要完成的功能有：（1）、Status bars（2）、Navigation bars（3）、Notification（4）、Lockscreen（5）、Quick settings（6）、Overview（recent task switcher）（7）、VolumeUI 2、SystemUI的架构 SystemUI的整体架构： Android SystemUI采用了MVC（Model-View-Controller）架构，以实现界面元素的管理和交互。它由多个关键组件组成，包括状态栏、导航栏、通知管理器、快捷设置等。各个组件的功能和相互关系： 12345678910111213状态栏（Status Bar）：显示系统状态信息，如时间、电池电量、信号强度等，并提供快速访问通知和快捷设置的入口。导航栏（Navigation Bar）：提供设备导航和操作控制，包括返回、主页和最近任务等按钮。通知管理器（Notification Manager）：负责接收、管理和展示通知，包括应用推送的通知和系统事件的通知。快捷设置（Quick Settings）：提供快速访问常用系统设置的面板，如Wi-Fi、蓝牙、亮度等，以方便用户进行快速调整。锁屏界面（Lock Screen）：显示在设备锁定状态下的界面，提供时间、日期、通知预览和快速启动应用等功能。系统UI控制器（System UI Controller）：作为整个SystemUI的控制中心，负责协调各个组件之间的交互和管理。其他辅助组件：还有一些辅助组件，如电源管理器、音量控制器等，用于管理设备的电源和音量控制。 这些组件相互配合，构成了SystemUI的整体架构。每个组件负责不同的功能和交互，并通过事件触发和消息传递等机制相互关联。理解SystemUI的架构和组件之间的相互关系，有助于我们深入了解系统界面的实现原理，并进行自定义和扩展。 3、SystemUI的启动过程 SystemUI任何内容都不像一个APP，自然它的启动也不像大多APP一样启动一个Activity。SystemUI顾名思义就是全局UI，必须在开机过程中完成启动，并不可退出。回顾Android系统开机的过程，会创建server进程维护系统各种服务，如下： 1234567Android系统启动流程: 1.按下电源，系统上电 2.从固定地址启动固化在ROM的BootLoader程序 3.启动Linux内核，加载init进程 4.启动init进程，fork出zygote进程 5.启动SystemServer，启动Binder线程池以及各种服务 6.AMS启动Launcher， 然后你就看到该看到的了 SystemUI作为系统主要进程，就是在SystemServer启动的服务其中之一 SystemServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public static void main(String[] args) &#123; new SystemServer().run(); &#125; private void run() &#123; ...... // Start services. try &#123; traceBeginAndSlog(&quot;StartServices&quot;); startBootstrapServices(); startCoreServices(); startOtherServices(); SystemServerInitThreadPool.shutdown(); &#125; catch (Throwable ex) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; &#125; finally &#123; traceEnd(); &#125; ......&#125; private void startOtherServices() &#123; ...... mActivityManagerService.systemReady(() -&gt; &#123; Slog.i(TAG, &quot;Making services ready&quot;); traceBeginAndSlog(&quot;StartActivityManagerReadyPhase&quot;); ...... try &#123; startSystemUi(context, windowManagerF); &#125; catch (Throwable e) &#123; reportWtf(&quot;starting System UI&quot;, e); &#125; ...... &#125; &#125; static final void startSystemUi(Context context, WindowManagerService windowManager) &#123; PackageManagerInternal pm = LocalServices.getService(PackageManagerInternal.class); Intent intent = new Intent(); intent.setComponent(pm.getSystemUiServiceComponent());//从本地获取systemuiService的包名 intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); //Slog.d(TAG, &quot;Starting service: &quot; + intent); context.startServiceAsUser(intent, UserHandle.SYSTEM); windowManager.onSystemUiStarted(); &#125; 总结下代码流程：SystemServermain()方法会调用SystemServer.run()方法，在run方法中，会启动bootStrapService，coreService，以及其他服务otherService，在startOtherServices()中，会注册AMS的systemReady回调，在回调中启动SystemUI，其实就是启动了SystemUIService。 SystemUIService.java 1234567//frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIService.java@Override public void onCreate() &#123; super.onCreate(); ((SystemUIApplication) getApplication()).startServicesIfNeeded(); ..... &#125; SystemUIApplication.java 12345678910111213//frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIApplication.java public void startServicesIfNeeded() &#123; final String vendorComponent = SystemUIFactory.getInstance() .getVendorComponent(getResources()); // Sort the startables so that we get a deterministic ordering. // TODO: make #start idempotent and require users of CoreStartable to call it. Map&lt;Class&lt;?&gt;, Provider&lt;CoreStartable&gt;&gt; sortedStartables = new TreeMap&lt;&gt;( Comparator.comparing(Class::getName)); sortedStartables.putAll(SystemUIFactory.getInstance().getStartableComponents()); sortedStartables.putAll(SystemUIFactory.getInstance().getStartableComponentsPerUser()); startServicesIfNeeded( sortedStartables, &quot;StartServices&quot;, vendorComponent); &#125; SystemUIApplication.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private void startServicesIfNeeded( Map&lt;Class&lt;?&gt;, Provider&lt;CoreStartable&gt;&gt; startables, String metricsPrefix, String vendorComponent) &#123; if (mServicesStarted) &#123;//如果服务已经启动，则直接返回。 return; &#125; //初始化一个 CoreStartable 类型的数组 mServices，它的长度为 startables 元素的数量加上（如果有）一个 vendorComponent 的长度。 mServices = new CoreStartable[startables.size() + (vendorComponent == null ? 0 : 1)]; //如果检测到系统还未启动完成，则检查系统属性 “sys.boot_completed” 是否为 1。如果是 1，则设置启动完成标志，并记录日志 if (!mBootCompleteCache.isBootComplete()) &#123; // check to see if maybe it was already completed long before we began // see ActivityManagerService.finishBooting() if (&quot;1&quot;.equals(SystemProperties.get(&quot;sys.boot_completed&quot;))) &#123; mBootCompleteCache.setBootComplete(); if (DEBUG) &#123; Log.v(TAG, &quot;BOOT_COMPLETED was already sent&quot;); &#125; &#125; &#125; //使用 mSysUIComponent（也就是 SystemUI 的组件）创建一个 DumpManager 对象，用于管理系统 UI 相关的 dump 文件 mDumpManager = mSysUIComponent.createDumpManager(); //记录一条日志，表示正在启动 SystemUI 服务。 Log.v(TAG, &quot;Starting SystemUI services for user &quot; + Process.myUserHandle().getIdentifier() + &quot;.&quot;); TimingsTraceLog log = new TimingsTraceLog(&quot;SystemUIBootTiming&quot;, Trace.TRACE_TAG_APP); log.traceBegin(metricsPrefix); int i = 0; //对于 startables 中的每个元素，获取它的类名和 CoreStartable 实现类的提供者，然后初始化一个 int 类型的变量 j， //并将其赋值为 i，以便接下来在lambda 函数中使用。接着调用 timeInitialization 方法，其作用是计时和执行初始化 for (Map.Entry&lt;Class&lt;?&gt;, Provider&lt;CoreStartable&gt;&gt; entry : startables.entrySet()) &#123; String clsName = entry.getKey().getName(); int j = i; // Copied to make lambda happy. timeInitialization( clsName, () -&gt; mServices[j] = startStartable(clsName, entry.getValue()), log, metricsPrefix); i++; &#125; //如果 vendorComponent 不为 null，则调用 timeInitialization 方法，初始化包含 vendorComponent 的 CoreStartable 实现类并将其存储在 \\ // mServices 数组的最后一个位置。 if (vendorComponent != null) &#123; timeInitialization( vendorComponent, () -&gt; mServices[mServices.length - 1] = startAdditionalStartable(vendorComponent), log, metricsPrefix); &#125; //对于 mServices 数组中的每个元素，如果系统已经启动完成，则调用其 onBootCompleted 方法，表示启动完成了。然后注册每个 // CoreStartable 实现类的 dump，以便可以进行 dumpsys 命令后的分析 for (i = 0; i &lt; mServices.length; i++) &#123; if (mBootCompleteCache.isBootComplete()) &#123; mServices[i].onBootCompleted(); &#125; mDumpManager.registerDumpable(mServices[i].getClass().getName(), mServices[i]); &#125; //执行 SystemUI 组件的 InitController 中注册的所有后置初始化任务 mSysUIComponent.getInitController().executePostInitTasks(); //使用 TimingsTraceLog 停止记录启动时间的追踪，记录所有记录的时间，并结束执行 startServicesIfNeeded 方法的过程。 log.traceEnd(); mServicesStarted = true; &#125; 12345678910111213141516171819202122232425262728&lt;!-- SystemUI Services: The classes of the stuff to start. --&gt;&lt;string-array name=&quot;config_systemUIServiceComponents&quot; translatable=&quot;false&quot;&gt; &lt;item&gt;com.android.systemui.Dependency&lt;/item&gt; &lt;item&gt;com.android.systemui.util.NotificationChannels&lt;/item&gt; &lt;item&gt;com.android.systemui.statusbar.CommandQueue$CommandQueueStart&lt;/item&gt; &lt;item&gt;com.android.systemui.keyguard.KeyguardViewMediator&lt;/item&gt; &lt;item&gt;com.android.systemui.recents.Recents&lt;/item&gt; &lt;item&gt;com.android.systemui.volume.VolumeUI&lt;/item&gt; &lt;item&gt;com.android.systemui.stackdivider.Divider&lt;/item&gt; &lt;item&gt;com.android.systemui.SystemBars&lt;/item&gt; &lt;item&gt;com.android.systemui.usb.StorageNotification&lt;/item&gt; &lt;item&gt;com.android.systemui.power.PowerUI&lt;/item&gt; &lt;item&gt;com.android.systemui.media.RingtonePlayer&lt;/item&gt; &lt;item&gt;com.android.systemui.keyboard.KeyboardUI&lt;/item&gt; &lt;item&gt;com.android.systemui.pip.PipUI&lt;/item&gt; &lt;item&gt;com.android.systemui.shortcut.ShortcutKeyDispatcher&lt;/item&gt; &lt;item&gt;@string/config_systemUIVendorServiceComponent&lt;/item&gt; &lt;item&gt;com.android.systemui.util.leak.GarbageMonitor$Service&lt;/item&gt; &lt;item&gt;com.android.systemui.LatencyTester&lt;/item&gt; &lt;item&gt;com.android.systemui.globalactions.GlobalActionsComponent&lt;/item&gt; &lt;item&gt;com.android.systemui.ScreenDecorations&lt;/item&gt; &lt;item&gt;com.android.systemui.fingerprint.FingerprintDialogImpl&lt;/item&gt; &lt;item&gt;com.android.systemui.SliceBroadcastRelayHandler&lt;/item&gt;&lt;/string-array&gt; &lt;!-- SystemUI vender service, used in config_systemUIServiceComponents. --&gt;&lt;string name=&quot;config_systemUIVendorServiceComponent&quot; translatable=&quot;false&quot;&gt;com.android.systemui.VendorServices&lt;/string&gt; SystemUIService的onCreate()方法中，直接调用SystemUIApplication.startServicesIfNeeded()方法，最终会将所有服务一一加载并通过start()方法启动起来。 至此，SystemUI基本启动流程就结束了。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework相关","slug":"Android-FrameWork/Framework相关","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E7%9B%B8%E5%85%B3/"}]},{"path":"wiki/Android FrameWork/Linux 设置swap/","text":"swap设置大小建议 1234567891011- 安装系统时，选择swap分区；swap不是越大越好，越大的时候说明内存不够用，应该增加内存。- redhat官方建议： 物理内存小于等于2GB的swap, 设置为物理内存的2倍 物理内存大于2GB小于等于8G时swap, 置为等同与物理内存的大小 物理内存大于8GB时swap, 置为大于等于4GB但不超过8GB。- 建议 内存小于 4GB 时，推荐不少于 2GB 的 swap 空间 内存 4GB~16GB，推荐不少于 4GB 的 swap 空间 内存 16GB~64GB，推荐不少于 8GB 的 swap 空间 内存 64GB~256GB，推荐不少于 16GB 的 swap 空间//实际我本机内存32G分配ubantu24G，仍然会报错，建议wsap大于16G 新建或修改swap分区 12345678910111213141516方案一：修改原有文件大小方式第一步：进入系统根目录cd /;第二步：执行：sudo dd if=/dev/zero of=/swap bs=1M count=16384 //每段块1M共16384块，即16G第三步：执行：sudo mkswap /swap // 激活swap空间第四步：执行：sudo swapon /swap最后，使用free -m命令，验证是否ok。方案二：设置新的交换分区进入根目录：cd /创建一个新的交换分区文件：sudo dd if=/dev/zero of=/swap bs=1M count=16384创建swap文件系统sudo mkswap -f swap;开启新的swap sudo swapon swap关闭并删除原有的swap文件sudo swapoff swapfile &amp;&amp; sudo rm /swapfile设置开机启动:将/etc/fstab中的swapfile改为swap最后，使用free -h命令，验证是否ok。 设置linux物理内存使用多少开始使用swap的阈值 12345678910111213141516171.查询默认的值 - cat /proc/sys/vm/swappiness - centos7默认值可能是30；就是当内存使用&gt;=(100-30=70)%内存总量时，开始使用内存； - 当值为0时，表示内存使用率&gt;100%时使用内存，则表明不使用swap; - 当值为100时，表示内存使用率&gt;0%时使用内存，这样则无时无刻不使用swap; 2.如何修改swappiness（开启的阀值） - 当使用内存&gt;=90%时才使用内存； - `临时设置` sudo -i echo 20 &gt; /proc/sys/vm/swappiness sysctl -p #生效 - `永久设置` sudo -i echo &quot;vm.swappiness=20&quot; &gt;&gt; /etc/sysctl.conf #永久修改 sysctl -p #生效 - 能有效使用内存，增强性能；如果机器一直长期超过70%的内存使用量，实际应该想想是不是要增加内存；","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/导入系统源码到Studio/","text":"系统应用编译有2种方式： 123451.源码编译（Aidegen）：适用于需要与framework代码统一版本或修改较少的情况， 缺点是修改后无法直接运行需要单编后整编再运行查看效果；2.源码导入Studio：适用于修改的地方较多的情况， 需要手动去把原生源码的代码提出来，手动剔除无用代码； 和普通app一样调试方便，但是需要注意与framework的版本管理； 下载指定版本的源码： 12345官网地址：https://android.googlesource.com/platform/packages/apps/git clone https://android.googlesource.com/platform/packages/apps/Launcher3如Launcher3：git clone -b android-13.0.0_r6 https://android.googlesource.com/platform/packages/apps/Launcher3清华镜像：https://mirrors.tuna.tsinghua.edu.cn/git/AOSPgit clone -b android-13.0.0_r6 https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/packages/apps/Launcher3","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/Framework遇到的问题/","text":"问题：Failed to find Platform SDK with path: platforms;android-S 1234原因：gradle.properties中的COMPILE_SDK=android-S找不到,缺少sdk；解决：1.通过tool-SDK Manager-Android SDK中查看已安装的sdk版本如：android-13(对应的API LEVEL 33)2.gradle.properties中的COMPILE_SDK修改为COMPILE_SDK=android-33 问题： Failed to connect to android.googlesource.com port 443 after 21168 ms: Timed out 12345678910原因：使用了vpn，浏览器可以正常访问aomedia.googlesource.com，但是使用git就报错，需要设置git也是用vpn解决方案1：git config --global http.proxy 127.0.0.1:你的vpn所用端口号 //比如vpn默认代理端口是1080，那上面的命令就是git config --global http.proxy 127.0.0.1:1080解决方案2： 在使用时，将 https://android.googlesource.com/ 全部使用清华镜像： https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/ 代替即可。 例如：原来为 git clone https://android.googlesource.com/platform/packages/apps/Launcher3 替换为 git clone https://mirrors.tuna.tsinghua.edu.cn/git/AOSP//platform/packages/apps/Launcher3","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/Android 源码根目录介绍/","text":"整体目录介绍： Android源码根目录 描述 art Android Runtime，一种App运行模式，区别于传统的Dalvik虚拟机，旨在提高Android系统的流畅性 abi abi 相关代码，abi：application binary interface，应用程序二进制接口 bionic bionic C 库 bootable 启动引导相关代码 build 存放系统编译规则及 generic 等基础开发配置包 compatibility 兼容性的一些资源 cts Android 兼容性测试套件标准 dalvik dalvik Java 虚拟机 developers Android开发者参考文档 development 应用程序开发相关 device 设备相关代码 disregard 清空 Android.mk 内容，以阻止 Android 构建系统更深入地扫描 Android.mk 的子目录。 docs 介绍开源的相关代码 external Android 使用的一些开源的模组 frameworks 核心框架 - Java 及 C++语言，是 Android 应用程序的框架 gdk 即时通信模块 hardware 主要是硬件适配层 HAL 代码 kernel Linux 的内核文件 libcore 核心库相关 libnativehelper 是 Support functions for Android‘s class libraries 的缩写，表示动态库，是实现 JNI 库的基础 ndk ndk 相关代码。Android NDK（Android Native Development Kit）是一系列的开发工具，允许程序开发人员在 Android 应用程序中嵌入 C&#x2F;C++ 语言编写的非托管代码。 out 编译完成后的代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，是本地开发套件 platform_testing Android平台测试程序 prebuilts x86 和 ARM 架构下预编译的一些资源 sdk SDK 及模拟器 shortcut-fe 根据手机平台芯片改变，这里是高通xx加速 system 文件系统和应用及组件，是用 C 语言实现的 test Android Vendor测试框架 toolchain Android工具链 tools 工具文件夹 vendor 厂商定制代码 Makefile 全局的 Makefile 详细目录介绍： art 目录 1234567891011121314151617181920|- benchmark // 程序测试基准。|- build // 编译文件。 |- cmdline // 命令行工具的初始化与解析。|- compiler // 编译套件。 |- dalvikvm // Dalvik虚拟机启动程序。 |- dex2oat // 文件dex格式转换为oat格式的转换程序。|- dexdump // 文件dex格式的内容获取程序。 |- dexlayout // 文件dex格式的布局。|- dexlist // 文件dex格式的函数获取程序。|- dexoptanalyzer //文件dex格式的分析程序 |- disassembler // 几种反汇编实现，包括arm64、arm、mips和x86。 |- imgdiag // image诊断程序。 |- libart_fake // 一个虚假的art库，用于那些企图链接ark库的作弊程序。 |- oatdump // 文件oat格式的内容获取程序。 |- patchoat // 文件oat格式的补丁管理程序。 |- profman // 程序性能分析助手。|- runtime // art库实现，主要为C++和汇编文件。 |- sigchainlib // 信号处理库。 |- test // 测试程序。 |- tools // 一些工具，包括python和shell脚本。 bionic 目录 12345678910111213141516171819202122232425262728293031323334353637|- libc （C库） |- arch-arm （ARM架构，包含系统调用汇编实现） |- arch-mips （mips架构，包含系统调用汇编实现） |- arch-x86 （x86架构，包含系统调用汇编实现） |- bionic （由C实现的功能，架构无关） |- include （头文件） |- kernel （Linux内核中的一些头文件） |- netbsd （nesbsd系统相关，具体作用不明） |- private （一些私有的头文件） |- stdio （标准输入输出的实现） |- stdlib （标准库函数的实现） |- string （标准字符串函数的实现） |- tools （几个工具） |- tzcode （时区相关代码） |- unistd （unistd实现） |- upstream-dlmalloc (包含由Doug Lea实现的malloc / free例程) |- upstream-freebsd （这个目录包含上游FreeBSD的来源） |- upstream-netbsd （这个目录包含上游NetBSD的来源） |- wchar （字符串函数，具体作用不明） |- zoneinfo （时区信息）|- libdl （提供访问动态链接库的功能）|- libm （libm数学库的实现） |- arm （arm架构） |- i386 （i386架构） |- i387 （i387架构） |- include （头文件） |- mips （mips架构） |- upstream-freebsd （这个目录包含上游FreeBSD的来源）|- libstdc++ （libstdc++ C++实现库） |- include （头文件） |- src （源码）|- libthread_db （多线程调试器库） |- include （头文件）|- linker （动态链接器）|- tests （一些测试用例）|- benchmarks // 程序测试基准。 |- build // 编译文件。 bootable目录 12345678910111213141516|- recovery（系统恢复相关） |- applypatch（二进制补丁文件） |- edify（升级脚本使用的edify脚本语言） |- etc（init.rc恢复脚本） |- fonts（字体文件夹） |- minadb（精简版的adbd守护进程） |- minelf（updater的子项目使用的库） |- minui（一个简单的UI） |- minzip（一个简单的压缩工具） |- mtdutils（读写flash的库） |- res（在recovery模式中显示的一些图片） |- simg2img (一个工具，将VMS Alpha executable文件转换成镜像文件) |- testdata（里面的文件用于测试更新过程） |- tools（工具） |- ubi |- updater（可执行文件运行更新脚本） build目录 1234567891011121314151617181920212223242526|- core （核心编译规则）|- libs |- host （主机端库，有android “cp”功能替换）|- target （目标机编译对象） |- board （开发平台） |- emulator （模拟器） |- generic （通用） |- generic_armv5 （armv5） |- generic_mips （mips） |- generic_x86 （x86） |- vbox_x86 （虚拟x86） |- product （开发平台对应的编译规则） |- security （密钥相关）|- tools （编译中主机使用的工具及脚本） |- acp （Android &quot;acp&quot; 命令） |- apicheck （api检查工具） |- atree （tree工具，类似于ls命令） |- check_prereq （检查编译时间戳工具） |- droiddoc （文档模板,用于生成使用Javadoc文档） |- fs_config （主机工具的一部分） |- fs_get_stats （获取文件系统状态） |- imgpack |- releasetools （生成镜像的工具及脚本） |- rgb2565 （rgb转换为565） |- signapk （apk签名工具） |- zipalign （zip归档对齐工具） dalvik目录 12345678910111213|- dexdump （dex反汇编）|- dexgen （敏捷项目代码生成器,使用gradle工具编译dex文件的解析工具）|- dexlist （在一个或多个敏捷文件中列出所有具体类中的所有方法）|- dexopt （预验证与优化）|- docs （文档）|- dx （dx工具，将多个java转换为dex）|- hit （读HPRO文件）|- libdex （dex相关的库）|- opcode-gen （已定义的操作码和Dalvik的指令格式）|- tests （测试代码）|- tools （工具）|- unit-tests （测试单元）|- vm （虚拟机实现） developers 123|- build //gradle编译系统。|- demos //使用了gradle的例子。|- samples //AndroidSDK中的例子。 development目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103|- apps（一些核心应用程序） |- BluetoothDebug（蓝牙调试程序） |- BuildWidget （定义一个简单小部件） |- CustomLocale（自定义区域设置） |- Development（开发系统应用） |- DevelopmentSettings（开发系统应用设置） |- Fallback（和语言相关的一个程序） |- GestureBuilder（手势动作） |- launchperf（装载前的预处理） |- NinePatchLab // 点九图片相关 |- OBJViewer（OBJ查看器） |- SdkSetup（SDK安装器） |- SettingsInjectorSample // 高级设置 |- WidgetPreview（预览应用的小部件）|- build（编译文件，包括打包用的atree文件）|- cmds（有个monkey工具）|- docs（文档）|- host（主机端USB驱动等）|- ide（集成开发环境）|- libraries （立体相机库）|- ndk（c/c++开发套件）|- python-packages // python工具包，包括adb、fastboot和gdbrunner。|- samples // 示例代码。 |- AccelerometerPlay // 展示加速计用法App |- AdaptiveIconSample // 自适应图标App |- Alarm // 紧急报警App |- AliasActivity // 应用程序命别名App |- AndroidBeamDemo // Android光束示例App |- ApiDemosAPI // 演示程序 |- AppNavigation // 导航 |- BackupRestore // 备份 |- BasicGLSurfaceView // 基础GL界面展示 |- BluetoothChat // 蓝牙聊天 |- BluetoothHDP // 蓝牙传输 |- BluetoothLeGatt // 蓝牙4.0模块 |- BrokenKeyDerivation // |- browseable // 浏览 |- BusinessCard // 车卡 |- Compass // 指南针 |- ContactManager // 联系人管理器 |- ControllerSample // 管理员示例 |- CrossCompatibility // 跨平台兼容 |- CubeLiveWallpaper // 动态壁纸的一个简单例程 |- DataWiper // 数据擦除 |- devbytes // 二进制读取 |- FixedGridLayout // 自动布局 |- HeavyWeight // 超重 |- HelloActivity // Hello |- HelloEffects // Hello接收 |- Home // 家 |- HoneycombGallery // 动态图 |- JetBoy // jetBoy游戏 |- KeyChainDemo // 密码管理 |- LceDemo // 天线设备参数示例 |- LunarLander // LunarLander游戏 |- MultiResolution // 多任务处理应用 |- MultiWindow // 分屏应用 |- MySampleRss // RSS |- NotePad // 记事本 |- Obb // 安卓游戏通用数据包示例 |- OpenGL // 图像库示例 |- RandomMusicPlayer // 音乐播放器 |- ReceiveShareDemo // 接收分享示例 |- RenderScript // 提升轮廓提取速度示例 |- RSSReader // RSS阅读器 |- samples_source.prop_template // |- SampleSyncAdapter // 更新接口 |- SearchableDictionary // 目录搜索 |- ShortcutDemo // 小图标 |- ShortcutSample // 小图标示例 |- SimpleJNI // JNI例程 |- SipDemo // 支持会话发起协议(SIP)应用示例 |- SkeletonApp // 空壳APP |- Snake // snake程序 |- SoftKeyboard // 软键盘 |- SpellChecker // 拼写检查 |- Spinner // Spinner控件 |- SpinnerTest // Spinner控件测试 |- StackWidget // 小部件堆叠示例 |- TicTacToeLib // 多库示例 |- TicTacToeMain // 主库示例 |- ToyVpn // vpn示例 |- training // 训练 |- TtsEngine // 文字语音转换(TTS)引擎 |- UiAutomator // ui自动测试 |- USB // usb使用 |- Vault // 缺陷控制 |- VoicemailProviderDemo // 读邮件应用示例 |- VoiceRecognitionService // 语音识别 |- WeatherListWidget // 天气小部件 |- WiFiDirectDemo // WIFI直连 |- WiFiDirectServiceDiscovery // WiFi直连服务发现 |- Wiktionary // 维基百科 |- WiktionarySimple // 维基百科示例 |- XmlAdapters // xml接口应用|- scripts（脚本）|- sdk（sdk配置）|- sdk_overlay （覆盖资源文件用于不同的设备）|- sys-img // 系统镜像信息。 |- testrunner（运行基于python的测试用例）|- tools（一些工具）|- tutorials （记事本教程和应用开发教程）|- vndk // 供应商本地开发工具包 device 目录 123456789|- asus//华硕|- common//设备间共有的配置。|- generic//不同的CPU架构，包括arm、goldfish、emulator、mips、x86等。|- google//谷歌|- huawei//华为|- lge//LG|- linaro//Linario|- qcom//高通|- sample//例子 external目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297|- aac // Advanced Audio Coding，高级音频编码。|- abi-compliance-checker // ABI兼容性分析工具。|- abi-dumper // ABI数据解析工具。 |- alsa-lib|- alsa-utils|- android-clat // Android中用NAT64/DNS64支持IPv4的程序运行于IPv6的网络。 |- androidplot // Android中用以创建动态的或静态的图表。 |- android-mock （简单模拟的包装器）|- ant-glob // ANT模式匹配工具。 |- antlr （语言识别工具// Language Recognition，一款语法分析器，可根据输入自动生成语法树并显示出来。 ）|- apache-commons-math // Apache数学库。 |- apache-harmony （一个具有类库和相关工具的模块化的java运行时，// Apache Java SE运行时类库及一些工具。 ）|- apache-http （网页服务器）// Apache HTTP服务。 |- apache-xml // Apache XML解决方案。 |- archive-patcher // 补丁管理库|- arm-neon-tests // arm基于NEON指令的数学库 |- autotest // 自动测试框架，Python实现，起初用于Linux Kernel，后扩展到Chrome OS和Android。 |- avahi // Zeroconf规范的一种实现，可以在本地网络中发布和获知各种服务和主机。 |- avb // Ethernet Audio/Video Bridging，以太网音视频桥接技术。 |- arduino|- bison （生成语法分析器）|- blktrace （阻塞IO跟踪） // 收集磁盘IO信息中当IO进行到块设备层即block设备时的详细信息|- boringssl // BoringSSL为OpenSSL的一个分支，优化了一些加密算法。 |- bluetooth （蓝牙相关、协议栈）|- bouncycastle （加密的Bouncycastle.org项目）|- bsdiff （bsdiff和bspatch项目）|- busybox|- bzip2 （压缩工具）// 基于Burrows-Wheeler算法的无损压缩技术。|- c-ares // DNS请求异步处理库。 |- caliper // 基准测量工具。 |- cblas // C interface to Legacy BLAS。|- ceres-solver|- checkpolicy|- chromium （chromium 工程）|- chromium_org|- chromium_libpac // 基于proxy_resolver_v8。 |- chromium_trace // 以HTML的形式显示数据使用情况。 |- chromium-webview // Webview。|- clang （Clang 工程）|- cmockery // 用于C程序的单元测试。|- clearsilver|- compiler-rt // Compiler Routine。|- conscrypt // A Java Security Provider。 |- crcalc // Constructive Real Calculator。 |- cros // 一些常量和定义，只有一些头文件和proto文件。 |- curl // 文件传输|- dagger2 // A fast dependency injector for Android and Java。 |- dbus // 数据总线，是一个低延迟，低开销，高可用性的ipc机制 |- dbus-binding-generator // dbus bind。 |- deqp // GPU测试框架。|- dexmaker // dex maker|- dhcpcd // DHCP client daemon（dhcp客户端的示例）|- dlmalloc // malloc/free routines implemented by Doug Lea。 |- dng_sdk // DNG文件读写库。|- dnsmasq （一个轻量级的、易于配置DNS转发器和DHCP服务器的工具）|- doclava （生成文档的工具）|- doclava // Javadoc工具。 |- drm_gralloc // gralloc for drm，Direct Rendering Manager。 |- drm_hwcomposer // hwcompositor for drm。|- droiddriver // Android UI testing library|- dropbear （小型的ssh服务器和客户端）|- dtc // Device Tree Compiler。|- e2fsprogs （维护ext2、ext3和ext4文件系统的工具）// 文件系统工具集|- easymock （一个提供了简单方法的在单元测试时使用mock对象的工具）// 单元测试模拟框架|- eclipse-basebuilder // eclipe插件编译相关|- eclipse-windowbuilder // eclipse编译相关|- eigen // 用于线性代数的C++模板库|- elfutils （ELF文件相关的库和工具）|- embunit （一个针对嵌入式C系统的单元测试框架）|- emma // 单元测试覆盖率统计|- esd // 音频相关|- ethtool |- exfat-fuse|- expat （一个用于解析XML的C库）|- eyes-free // 语音交互|- fdlibm （一个用于可以支持IEEE 754浮点运算的机器的c数学库）|- f2fs-tools // Flash Friendly File System。 |- fec // Forward error correction。 |- fio / io测试工具。 |- flatbuffers // |- fmtlib // format。 |- fonttools // 字体处理工具。 |- freetype // 字体引擎。 |- fsck_msdos // 文件系统检查工具|- ffmpeg|- flac （FLAC工程的源码）// Free Lossless Audio Codec|- fsck_msdos (ms-dos文件系统的检查代码)|- fw_env|- ganymed-ssh2|- gcc-demangle|- genext2fs （在普通用户的权限之下生成ext2文件系统）|- giflib （gif图片库）|- google-diff-match-patch|- grub （多操作系统引导程序）|- gtest （在不同的平台上编写C++测试用例的框架）|- guava （开源的实用工具集合）// Google Core Libraries for Java|- glide // media管理框架|- gemmlowp // low-precision for general matrix multiplication。 |- google-benchmark // 支持benchmark的库，类似于单元测试。 |- google-breakpad // crash报告系统，包括client、server。 |- google-fonts // 字体。 |- googletest // C++ test framework。 |- google-tv-pairing-protocol // tv配对协议。 |- gptfdisk // 文本模式的磁盘分区工具。 |- guice // 依赖注入框架。 |- hamcrest （一个布局引擎库）// 用于测试的可以合成各种表达式的匹配器类库|- harfbuzz |- harfbuzz_ng // 字体排版引擎|- hyphenation （一个使用tex断字模式的断字库）|- hyphenation-patterns // 各种语言的字体连接模式。|- icu // Unicode组件|- icu4c （使用c/c++和java库来对应用程序提供Unicode和全球化支持）|- iproute2 （iproute2是在Linux中控制tcp/ip网络的工具集合）|- ipsec-tools （IPsec-Tools工程）// 加密的ip协议工具包|- iptables (iptables工程)// IP信息包过滤系统|- iputils // 网络工具包|- ImageMagick // bitmap图片管理，支持多种格式。 |- ims // IP Multi-media System，包括rcs融合通信。 |- iw // Netlink 802.11|- jacoco // 测试覆盖率工具。 |- jarjar // Java包管理工具。 |- javasqlite // sqlite |- javassist // Java字节码编辑。 |- jcommander // 参数解析。 |- jdiff // Java代码比较工具。 |- jemalloc // 更好的内存管理工具，解决内存碎片问题。 |- jetty // servlet容器。 |- jline // 处理控制台输入。 |- jmdns // 多播DNS实现，可在本地局域网中发现和注册服务。 |- jsilver // HTML模板系统。 |- jsmn // JSON解析。 |- jsoncpp // C++处理JSON，序列化和反序列化。 |- jsr305 // Java Specification Request。 |- jsr330 // Java Specification Request。 |- junit // Java单元测试框架。 |- junit-params // jnit升级版，添加了更好用的参数化测试。|- jhead （jpeg头部信息工具）|- jmonkeyengine|- jpeg （jpeg图像的压缩和解压缩）|- jsr305|- kernel-headers // Kernel级别头文件。 |- ksoap2 // 访问Web Service。|- libavc // 流媒体|- libcap-ng|- libffi （libffi项目）|- libgsm （网络数据包捕获函数）|- liblzf （liblzf项目，一个非常快速的压缩算法）|- libmtp|- libnfc-nci|- libnfc-nxp （来自NXP半导体的nfc库）|- libnl-headers （网络相关的库）|- libogg|- libpcap （libcap的源码）|- libphonenumber （google处理电话号码的库）|- libpng （png格式的库）|- libppp|- libselinux|- libsepol|- libusb|- libusb-compat|- libvorbis|- libvpx|- libxml2 （xml解析库）|- libxslt （XLST工具包的源代码）|- libyuv|- linux-kselftest // linux test。|- libzvbi|- linux-tools-perf|- littlemock // mock框架|- lld // LLVM linker|- llvm （一个低级的虚拟机）// Low Level Virtual Machine|- ltp // Linux Test Project|- lz4 // 快速的无损压缩算法|- lzma // 压缩|- marisa-trie|- markdown （文本转成html工具）|- mdsnresponder // Appple Bonjour组件，方便IP网络配置。|- mksh （最小的mkshrc应用程序的实现）// MirBSD Korn Shell|- mockwebserver （用于测试http和https客户端的库）|- mtd-utils |- mesa3d // 三维计算机图形库|- messageformat // International Components for Unicode for Java。 |- Microsoft-GSL // Guideline Support Library。 |- minijail // 沙盒，运行不信任的程序。 |- mmc-utils // mmc卡管理。 |- mockftpserver // 模拟FTP服务以进行FTP客户端测试。 |- mockito // 测试框架。 |- modp_b64 // base64编码、解码。 |- mp4parser // mp4解析。 |- mtpd // Media Transfer Protocol |- netcat （简单的unix读写数据工具）// 网络使用查看工具|- netperf （简单的unix网络性能测量工具）// 网络性能测试 |- nist-skip （VOIP实现的代码）// nist实现的sip协议，ip电话|- ntfs-3g|- nanohttpd // HTTP Server，用于嵌入其它的程序。 |- nanopb-c // ANSI-C实现的Protocol Buffer。 |- naver-fonts // 字体。 |- neven // 人脸识别算法。 |- nfacct // 流量统计。 |- nist-pkits // NIST PKI Test Suite。 |- noto-fonts // 汉语、日语、韩语字体。 |- oauth （oauth身份验证项目的代码）// 关于授权的开放网络标准|- opencv （opencv的一个优化端口）// 计算机视觉库|- openfst|- openssh （ssh相关）|- openssl （SSL加密相关）|- open-vcdiff |- oprofile （OProfile是一个低开销的分析器） |- objenesis // Java对象实例化库。 |- okhttp // HTTP&amp;SPDY Client。 |- opencv3 // 计算机视觉库。 |- owasp // Web Application。|- pixman|- pppoe （pppoe协议的源码）|- proguard （ProGuard的源码）|- parameter-framework // system-wide parameter management。 |- pcre // Perl兼容的正则表达式库。 |- pdfium // PDF渲染引擎。 |- piex // Preview Image Extractor。 |- ppp // Point to Point Protocol，链路层协议。 |- proguard // Java class file shrinker, optimizer, obfuscator and preverifier. |- qemu （arm模拟器）|- qemu-pc-bios （生成bios.bin和vgabios-cirrus.bin的源码）|- remoteconf|- regex-re2 // 正则表达式库。 |- replicaisland // A side scrolling video game for Android。 |- rmi4utils // Remote Method Invoke。 |- robolectric // 黑盒测试。 |- roboto-fonts // roboto font。 |- rootdev // Chromium OS version of rootdev。|- safe-iop （safe-iop工程的源码）// safe integer operation|- sepolicy|- sil-fonts|- skia （一个完整的2D图形库）|- smack|- sonivox （嵌入式音频合成项目的源码和二进制文件）|- speex （一个开源的音频压缩格式）|- sqlite （数据库）|- srec （嵌入式语音识别引擎）|- srtp （提供安全的实时传输协议的实现）|- stlport （完整的ANSI C++标准库）|- strace （系统跟踪工具）// system call tracer|- stressapptest|- svox （文字-语音转换工具）|- scrypt // 加密相关。 |- seccomp-tests // Seccomp-BPF Kernel Self-Test Suite。 |- selinux // Secure Linux。 |- sfntly // 字体库。 |- shflags // shell script。 |- sl4a // Scripting Layer for Android。 |- slf4j // Simple Logging Facade for Java。 |- smali // Dalvik虚拟机的dex格式的汇编与反汇编。 |- snakeyaml // 用于Java虚拟机的YAML文件解析器。 |- sonic // 语音开发库。 |- sonivox // 语音开发库。 |- spirv-llvm // Khronos LLVM-SPIRV图形渲染语言格式转换 |- squashfs-tools // 只读的高压缩的文件系统。 |- swiftshader|- syslinux |- tagsoup （一个Java开发符合SAX的HTML解析器）|- tcpdump （抓TCP包的软件）// 网络监听|- tinyalsa （提供基本pcm和混合器API）// ALSA处理|- tinyxml (用来解析某个特定的xml文件)|- tinyxml2 // XML解析|- tremolo （针对arm进行了优化的tremolo） |- testng // 实机测试及数据收集。 |- timezonepicker-support // Time Zone。 |- tinycompress // 用于ALSA格式的读取，如mp3。 |- tinyxml // XML解析工具，C++实现。 |- tlsdate // 时间更新服务，TCP实现。 |- toybox // 命令行工具包。 |- tpm2 // Trusted Platform Module。 |- tremolo // ogg音频解压。|- unicode // Unicode。 |- universal-tween-engine // Java对象插值|- v8 （java脚本引擎）// JavaScript引擎，C++实现|- valgrind （提供大量的调试和分析工具）// 内存、性能分析工具|- verity |- vboot_reference // Chrome OS verified boot in firmware。 |- vixl // ARMv8 Runtime Code Generation Library。 |- vogar // vogar.|- volley/ |- vulkan-validation-layers // Vulkan组件，包括ICD Loader和Validation Layer。|- webo （浏览器核心）|- wpa_supplicant_6 （无线网卡管理）|- webp // 处理WebP格式的图片。 |- webrtc // 支持浏览器、移动App的Real-time Communication。 |- wpa_supplicant_8 // WIFI Protected Access。|- wycheproof|- xmlwriter （XML 编辑工具）|- x264|- xmlrpcpp // XmlRpc协议的C++实现。 |- xmp_toolkit // xmp |- yaffs2 （快速可靠的文件系统，针对nand flash和nor flash）|- zlib （一个通用的数据压缩库）// 使用了DEFLATE算法的数据压缩库|- zxing (一个大规模的精致低调的压缩库)// Java库，用于识别1D/2D条形码|- zopfli // C库，一种压缩算法。 frameworks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180|- base （基本内容） |- api （api android application interface） |- awt （AWT库） |- build |- camera （摄像头服务程序库） |- cmds （重要命令：am、app_proce等） |- core （核心库） |- data （字体和声音等数据文件） |- docs （文档） |- graphics （图形相关） |- include （头文件） |- keystore （和数据签名证书相关） |- libs （库） |- location （地区库） |- media （媒体相关库） |- obex （蓝牙传输库） |- opengl （2D-3D加速库） |- packages （设置、TTS、VPN程序） |- sax （XML解析器） |- services （各种服务程序） |- telephony （电话通讯管理） |- test-runner （测试工具相关） |- tests （各种测试） |- tools （一些叫不上名的工具） |- vpn （VPN） - wifi （无线网络）|- opt （可选部分） |- com.google.android （有个framework.jar） |- com.google.android.googlelogin （有个client.jar） |- emoji （standard message elements）|- policies （Product policies are operating system directions aimed at specific uses） |- base |- mid （MID设备） |- phone （手机类设备，一般用这个） |- av // 多媒体框架 |- camera // 多媒体的相机相关部分 |- cmds // 命令源码 |- drm // 数据保护 |- include // 头文件 |- media // 多媒体部分 |- radio // 无线射频部分 |- services // 服务部分 |- soundtrigger // 语音识别架构 |- tools // 工具包 |- base // base，包括以下几个目录。 |- apct-tests // 性能优化测试 |- api // java的api接口，修改了接口文件请及时更新此目录下的文件（make update-api） |- cmds // 重要命令：am、app_proce等的源码 |- core // framework层核心库 |- java // java库 |- jni // jni层 |- proto // 协议层 |- res // 资源文件 |- tests // 测试工具 |- data // 字体和声音等数据文件 |- docs // 文档 |- drm // 数据保护 |- graphics // 图形相关 |- keystore // 和数据签名证书相关 |- legacy-test // 安全相关测试 |- libs // lib库 |- androidfw // fw功能库 |- common_time // 常用功能和工具集合，缓存，包括图片缓存、预取缓存、网络缓存;公共 View，即功能封装好的部件，包括下拉获得最新和上拉加载更多 ListView、底部加载更多 ScrollView、滑动一页 Gallery 等等。;常用工具类，包括网络、下载、资源操作、Shell、文件读写、Json、序列化/反序列化、随机数、集合（Array、List、Map）、APK 包等等。 |- hwui // 硬件渲染库 |- incident // 事件驱动机制库 |- input // 输入库 |- services // 服务库 |- storage // 存储库 |- usb // USB库 |- location // 定位功能 |- media // 媒体相关库 |- native // native框架 |- nfc-extras // nfc额外框架 |- obex // 蓝牙传输库 |- opengl // 2D-3D加速库 |- packages // 设置、TTS、VPN程序 |- proto // 协议框架 |- rs // 资源框架 |- samples // 例子程序 |- sax // XML解析器 |- services // 各种服务程序 |- telecomm // Telecom通信框架 |- telephony // 电话通讯框架 |- test-runner // 测试工具相关 |- tests // 各种测试 |- tools // 工具 |- vr // 虚拟现实相关 |- wifi // 无线 |- compile // 编译相关 |- libbcc // 用于Linux性能监视的动态跟踪工具的库 |- bcinfo // 获取硬件设备信息库 |- gdb_plugin // gdb插件 |- include // 头文件 |- lib // 库文件 |- tests // 测试程序 |- tools // 测试工具 |- mclinker // MCLinker链接器 |- include // 头文件 |- lib // 库文件 |- templates // 模板 |- tools // 工具 |- unittests // 单元测试工具 |- slang // 异常框架 |- data-binding // 数据绑定。 |- ex // ex文件解析器 |- camera2 // 相机相关 |- common // 共有的 |- framesequence // GIF图片工具包 |- photoviewer // 图片预览 |- widget // 小部件 |- hardware // 硬件适配接口 |- interfaces // 接口文件 |- current.txt // 接口记录文件 |- displayservice // 显示服务 |- schedulerservice // JobScheduler主要用于在未来某个时间下满足一定条件时触发执行某项任务的情况 |- sensorservice // 传感器服务 |- update-makefiles.sh // 更新makefile文件脚本 |- vr // 虚拟现实硬件接口 |- minikin // Android原生字体，连体字效果 |- ml // 机器学习 |- bordeaux // |- learning // 学习算法 |- service // 服务 |- multidex // Multi-dex Loader。 |- native // native实现 |- aidl // aidl层，Android 接口定义语言 |- build // 编译配置 |- cmds // 命令行 |- data // 数据文件 |- docs // 文档 |- include // 头文件 |- libs // 库 |- arect // 图形库 |- binder // binder通信库 |- diskusage // 硬盘读取库 |- gui // ui显示库 |- hwc2on1adapter // |- input // 输入库 |- math // 数学库 |- nativewindow // native窗口库 |- sensor // 传感器库 |- ui // ui库 |- vr // 虚拟现实库 |- opengl // 2D-3D接口框架 |- services // 服务 |- audiomanager // 音频服务 |- batteryservice // 电源服务 |- displayservice // 显示服务 |- inputflinger // 输入框架服务 |- nativeperms // 属性服务 |- powermanager // 电池管理 |- schedulerservice //事件消息服务 |- sensorservice // 传感器服务 |- surfaceflinger // 显示服务 |- vr // 虚拟现实服务 |- vulcan // 隐式框架 |- opt // 一些软件。 |- bitmap // 二进制图 |- bluetooth // 蓝牙 |- calendar // 日历 |- chips // 芯片工具 |- colorpicker // 色彩拾取工具 |- datetimepicker // 时间选择工具 |- emoji // standard message elements 表情 |- inputconnectioncommon // 输入连接工具 |- inputmethodcommon // 输入方法工具 |- net // 网络相关工具 |- ethernet // 有线网络 |- ims // ims |- voip // 数据网络 |- wifi // 无线网络 |- photoviewer // 照片预览工具 |- setupwizard // 开机向导工具 |- telephony // 通信工具 |- timezonepicker // 时区工具 |- vcard // 芯片卡片工具 |- rs // Render Script，可创建3D接口。 |- support // framework支持文件 |- webview // webview framework层的接口 |- wilhelm // Wilhelm，基于Khronos的OpenSL ES/OpenMAX AL的audio/multimedia实现。 hardware 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283|- libhardware （硬件库） |- include （头文件） |- modules （Default (and possibly architecture dependents) HAL modules） |- gralloc （gralloc显示相关） |- overlay （Skeleton for the &quot;overlay&quot; HAL module.）|- libhardware_legacy （旧的硬件库） |- flashlight （背光） |- gps （GPS） |- include （头文件） |- mount （旧的挂载器） |- power （电源） |- qemu （模拟器） |- qemu_tracing （模拟器跟踪） |- tests （测试） |- uevent （uevent） |- vibrator （震动） |- wifi （无线网络）|- msm7k （高通7k处理器开源抽象层） |- boot （启动） |- libaudio （声音库） |- libaudio-qsd8k （qsd8k的声音相关库） |- libcamera （摄像头库） |- libcopybit （copybit库） |- libgralloc （gralloc库） |- libgralloc-qsd8k （qsd8k的gralloc库） |- liblights （背光库） - librpc （RPC库）|- ril （无线电抽象层） |- include （头文件） |- libril （库） |- reference-cdma-sms （cdma短信参考） |- reference-ril （ril参考） |- rild （ril后台服务程序）- ti （ti公司开源HAL） |- omap3 （omap3处理器） |- dspbridge （DSP桥） |- libopencorehw （opencore硬件库） |- liboverlay （overlay硬件库） |- libstagefrighthw （stagefright硬件库） |- omx （omx组件） |- wlan （无线网卡）|- akm // AK8975传感器，包括SensorControl和HAL层的libsensors。 |- broadcom // Boradcom，包括libbt和wlan。 |- google // Google，包括Android Packet Filter。 |- intel // Intel，包括audio、media、bootstub、img、sensor等。 |- interfaces // HAL接口 |- audio // 音频 |- automotive // 车载 |- benchmarks // 标准库 |- bluetooth // 蓝牙 |- boot // 内核 |- broadcastradio // 无线广播 |- camera // 相机|- libhardware // 硬件库 |- include // 头文件 |- modules //模块 |- audio // 音频 |- audio_remote_submix // 音频 |- camera // 相机 |- consumerir // 红外的脉冲序列 |- fingerprint // 指纹 |- gralloc // Gralloc模块，封装了对帧缓冲区的所有访问操作 |- hwcomposer // 视频渲染 |- input // 输入 |- local_time // 本地时钟 |- nfc // 短程通信 |- nfc-nci // 短程通信 |- power // 电源 |- radio // 射频 |- sensors // 传感器 |- soundtrigger // 音频触发 |- thermal // 终端 |- tv_input // 电视输入 |- usbaudio // usb音频 |- usbcamera // usb相机 |- vehicle // 车载 |- vibrator // 震动 |- vr // 虚拟|- libhardware_legacy // hardware legacy |- audio // 音频 |- include // 头文件 |- power.c // 电源 |- uevent.c // 事件 libcore 1234567891011121314151617181920|- crypto|- dex|- dom（DOM的测试类）|- expectations（测试的一些情况信息）|- harmony-tests|- include（头文件）|- json（给予json的java实现）|- libdvm|- luni（加载.jar和.dex文件的测试源码）|- support（测试虚拟机的测试类）|- xml（xml的pull和push解析的实现）|- benchmarks//标准库|- dalvik//dalvik虚拟机|- include//头文件|- jsr166-tests//JSR是指向JCP提出新增标准化技术规范的正式请求，以向Java平台增添新的API和服务。JSR-166主要是关于J.U.C的技术规范(jdk5)|- libart//art虚拟机库|- ojluni//openjdkAPI|- test-rules//测试规则|- tools//工具|- tzdata//时区解析 libnativehelper 123|- include // 头文件|- platform_include // 平台头文件|- tests // 测试程序。 ndk 1234567891011121314|- build |- awk （辅助从应用的androidmanifest.xml中提取信息的一些脚本） |- core （创建NDK的一些makefile） |- gmsl （GNU的make标准库） |- tools （仅用于开发NDK的一些脚本）|- docs （NDK相关的文档）|- sources （NDK的源码和库） |- android （cpufeatures和libthread_db的源码） |- cpufeatures |- cxx-stl |- host-tools （linux主机的一些工具） |- third_party |- tests （测试相关）|- toolchains （基于arm和x86架构的工具链） packages 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156|- apps （应用程序库） |- AlarmClock （闹钟） |- Bluetooth （蓝牙） |- Browser （浏览器） |- Calculator （计算器） |- Calendar （日历） |- Camera （相机） |- CertInstaller （在Android中安装数字签名，被调用） |- Contacts （拨号(调用)、联系人、通话记录） |- DeskClock （桌面时钟） |- Email （Email） |- Gallery （相册，和Camera类似，多了列表） |- Gallery3D （3D相册） |- GlobalSearch （为google搜索服务，提供底层应用） |- GoogleSearch （google搜索） |- HTMLViewer （浏览器附属界面，被浏览器应用调用，同时提供存储记录功能） |- IM （即时通讯，为手机提供信号发送、接收、通信的服务） |- Launcher （登陆启动项，显示图片框架等等图形界面） |- Launcher2 （登陆启动项，负责应用的调用） |- Mms （彩信业务） |- Music （音乐播放器） |- PackageInstaller （安装、卸载程序的响应） |- Phone （电话拨号程序） |- Provision （预设应用的状态，使能应用） |- Settings （开机设定，包括电量、蓝牙、设备信息、界面、wifi等） |- SoundRecorder （录音机，可计算存储所需空间和时间） |- Stk （SIM卡开发工具） |- Sync |- Updater |- VoiceDialer （语音通话）|- inputmethods （输入法） |- LatinIME （拉丁文输入法） |- OpenWnn （OpenWnn输入法） |- PinyinIME （拼音输入法）|- providers （提供器，提供应用程序、界面所需的数据） |- ApplicationsProvider （应用程序提供器，提供应用程序启动项、更新等） |- CalendarProvider （日历提供器） |- ContactsProvider （联系人提供器） |- DownloadProvider （下载管理提供器） |- DrmProvider （创建和更新数据库时调用） |- GoogleContactsProvider （联系人提供器的子类，用以同步联系人） |- GoogleSubscribedFeedsProvider（设置信息提供器） |- ImProvider |- ManagementProvider |- MediaProvider （媒体提供器，提供存储数据） |- TelephonyProvider （彩信提供器） |- UserDictionaryProvider （用户字典提供器，提供用户常用字字典） |- WebSearchProvider |- services |- EasService |- LockAndWipe |- wallpapers （墙纸） |- Basic （基本墙纸，系统内置墙纸） |- LivePicker （选择动态壁纸） |- MagicSmoke （壁纸特殊效果） |- MusicVisualization （音乐可视化，图形随音乐而变化）|- apps // 各种app。 |- BasicSmsReceiver // 基础短信接收 |- Bluetooth // 蓝牙 |- Browser2 // 浏览器 |- Calendar // 日历 |- Camera2 // 相机 |- Car // 车载 |- CarrierConfig // 运营商配置 |- CellBroadcastReceiver // 小区广播服务 |- CertInstaller // 在Android中安装数字签名，被调用 |- Contacts // 联系人 |- DeskClock // 桌面时钟 |- DevCamera // 相机 |- Dialer // 拨号盘 |- DocumentsUI // 下载 |- Email // 邮件 |- EmergencyInfo // 工程信息 |- ExactCalculator // 计算器 |- Gallery // 图库 |- Gallery2 // 图库 |- HTMLViewer // HTML阅读器 |- KeyChain // 秘钥链 |- Launcher2 // 桌面启动器 |- Launcher3 // 桌面启动器 |- LegacyCamera // 安全相机 |- ManagedProvisioning // |- Messaging // 短信 |- Music // 音乐 |- MusicFX // MusicFX是一款系统专用的音频控制面板 |- Nfc // 短程通信 |- OneTimeInitializer // 谷歌服务框架 |- PackageInstaller // 安装 |- Phone // 电话 |- PhoneCommon // 电话 |- Protips // 主屏幕提示 |- Provision // 预设应用的状态，使能应用 |- QuickSearchBox // 搜索框 |- RetailDemo // |- SafetyRegulatoryInfo // 安全监管 |- Settings // 设置 |- SoundRecorder // 录音 |- SpareParts // 高级设置 |- SpeechRecorder // 录音机 |- Stk // SIM卡智能工具包 |- StorageManager // 存储管理 |- Tag // 标签 |- Terminal // 终端 |- Test // 测试 |- TV // 电视 |- TvSettings // 电视设置 |- UnifiedEmail // 未定义邮件 |- WallpaperPicker // 壁纸 |- experiment // 非release/public的测试程序。 |- BugReportSender // bug上传测试 |- Bummer // 懒汉测试 |- CameraPreviewTest // 相机预览测试 |- DreamTheater // |- ExampleImsFramework // ims框架测试 |- FilledApp // apk上限测试 |- FillService // 服务上限测试 |- InstantCookieApp // 小程序 |- LoaderApp // 加载apk |- MultiPackageApk // 安卓多渠道打包工具 |- NotificationListenerSample // 消息监听测试 |- NotificationLog // 消息log测试 |- NotificationShowcase // 消息展示测试 |- PermissionApp // 权限测试 |- PrintApp // 打印测试 |- PrintService // 打印服务测试 |- procstatlog // |- RpcPerformance // 远程过程调用测试 |- StrictModeTest // StrictMode最常用来捕捉应用程序的主线程，它将报告与线程及虚拟机相关的策略违例 |- TestBack // 回测 |- inputmethods // 输入法，包括LatinIME和OpenWnn。 |- LatinIME // 拉丁文输入法 |- OpenWnn // OpenWnn输入法 |- providers // 各种provider。 |- ApplicationsProvider // 应用程序提供器，提供应用程序启动项、更新等 |- BlockedNumberProvider // 黑名单电话提供器 |- BookmarkProvider // 书签提供器 |- CalendarProvider // 日历提供器 |- CallLogProvider // 通话记录提供器 |- ContactsProvider // 联系人提供器 |- DownloadProvider // 下载管理提供器 |- MediaProvider // 媒体提供器，提供存储数据 |- PartnerBookmarksProvider // 浏览器书签提供器 |- TelephonyProvider // 彩信提供器 |- TvProvider // 电视提供器 |- UserDictionaryProvider // 用户字典提供器，提供用户常用字字典 |- screensavers // 屏保 |- Basic // 默认屏保应用 |- PhotoTable // 照片屏保应用 |- WebView // 网络屏保应用 |- services // 各种service。 |- BuiltInPrintService // 预览打印服务 |- Car // 车载服务 |- Mms // 短信服务 |- NetworkRecommendation // 网络建议 |- Telecomm // Telecom通信服务 |- Telephony // Telephony通话服务 pdk 123456|- apps // 平台测试应用 |- HelloPDK // 平台测试示例 |- TestingCamera // 相机测试 |- TestingCamera2 // 相机测试|- build // 编译配置|- util // 工具包 platform_testing 12345|- build // 平台测试 |- libraries // lib库 |- scripts // 脚本 |- tests // 测试 |- utils // 工具包 prebuilts 123456789101112131415161718192021222324252627282930313233343536373839404142|- abi-dumps // applicationbinary interface，应用程序二进制接口的内存镜像调试工具 |- android-emulator // Android模拟器，由external/qemu/android/scripts/package-release.sh生成。 |- build-tools // Ninja编译系统的辅助工具。 |- checkcolor // 色彩规范检查 |- checkstyle // Java编码规范检查。 |- clang // c/c++/object-c代码编译器。 |- deqp // Draw Elements Quality Program，适用于OpenGL ES/OpenCL的GPU应用分析。 |- devtools // 开发工具，如常见的adt、android、ddms、lint等。 |- eclipse // eclipse。 |- gcc // gcc。 |- gdb // gdb。 |- go // go。 |- gradle-plugin // gradle插件。 |- libs // libedit，这是NetBSD Editline库（libedit）的自动工具和libtoolized端口。 这个Berkeley风格的授权命令行编辑器库提供了通用的行编辑，历史记录和标记化功能，与GNU Readline中的类似。 |- maven_repo // maven。 |- misc // 宏指令系统。 |- ndk // ndk。 |- python // python。 |- qemu-kernel // qemu 内核，QEMU是一套由法布里斯·贝拉(Fabrice Bellard)所编写的以GPL许可证分发源码的模拟处理器，在GNU/Linux平台上使用广泛。Bochs，PearPC等与其类似，但不具备其许多特性，比如高速度及跨平台的特性，通过KQEMU这个闭源的加速器，QEMU能模拟至接近真实电脑的速度。 |- sdk // 开发包。 |- tools // 工具|- android-arm （arm-android相关） |- gdbserver （gdb调试器） |- kernel （模拟的arm内核）|- android-x86 （x86-android相关） |- kernel |- common （通用编译好的代码，应该是java的）|- darwin-x86 （drawin x86平台）|- toolchain （工具链） |- arm-eabi-4.2.1 |- arm-eabi-4.3.1 |- arm-eabi-4.4.0 |- darwin-x86_64 （drawin x86 64bit平台）|- linux-x86 （linux x86平台） |- toolchain （工具链，我们应该主要用这个） |- arm-eabi-4.2.1 |- arm-eabi-4.3.1 |- arm-eabi-4.4.0 |- i686-unknown-linux-gnu-4.2.1 （x86版编译器）|- linux-x86_64 （linux x86 64bit平台）|- windows （windows平台）|- windows-x86_64 （64bit windows平台） sdk 12345678910111213141516171819202122232425|- annotations // 注释源码 |- apkbuilder // apk打包工具源码|- apps // sdk自带的应用 |- DeviceConfig // 设备配置 |- NotificationStudio // 消息提示 |- SdkController // sdk管控 |- attribute_stats // 属性状态 |- avdlauncher // 模拟器启动 |- bash_completion // bash工具 |- build // sdk编译配置|- docs // 文档 |- dumpeventlog // 事件记录log|- eclipse // eclipse开发sdk配置|- emulator // 模拟器源码 |- eventanalyzer // 事件分析 |- files // 文件 |- find_java // java文件查找|- find_java2 // class文件查找 |- find_lock // 锁查找 |- hierarchyviewer // hierarchyviewer工具源码 |- icons // |- sdklauncher // sdk加载源码 |- settings // sdk设置源码 |- templates // 模板|- testapps // 测试应用 system 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130|- bt // 蓝牙相关 |- ca-certificates // 证书颁发机构|- chre // 校验读出 |- connectivity // WIFI，包括wificond和wifilogd两个daemon。 |- wificond // WIFI配置 |- wifilogd // WIFI 的log系统 |- core // 系统核心工具盒接口。 |- adb // adb调试工具 |- adf // ADF file format解析库 |- base // 通用基础库 |- bootstat // 记录启动状态工具库 |- cpio // cpio工具，创建img |- debuggerd // 调试工具 |- demangle // 还原库 |- fastboot // 快速启动相关 |- fingerprintd // 指纹库 |- fs_mgr // 磁盘引导头 |- gatekeeperd // 锁屏密码服务系统接口 |- healthd // healthd是android4.4之后提出来的一种中介模型，该模型向下监听来自底层的电池事件，向上传递电池数据信息给framework层的batteryservice用以计算电池电量相关状态信息，batteryservice通过传递来的数据来计算电池电量显示，剩余电量，电量级别等信息 |- include // 系统接口头文件 |- init // init程序源代码 |- libappfuse // AppFuse是一个集成了众多当前最流行开源框架与工具(包括Hibernate、ibatis、Struts、Spring、DBUnit、Maven、Log4J、Struts Menu、Xdoclet、SiteMesh、OSCache、JUnit、JSTL等（现在还有lucene的，无敌了）)于一身的Web开发框架。AppFuse提供了Web系统开发过程中都需要开发的一些功能，如登陆、用户密码加密，用户管理、根据不同的用户可以展现不同的菜单.J2EE开发者也可以在此基础上开发加入自己的功能模块。利用这个框架可以大幅度的提高开发速度 |- libbacktrace // 进程堆栈库 |- libbinderwrapper // binder底层库 |- libcrypto_utils // 加密库 |- libcutils // 网络工具库 |- libdiskconfig // 磁盘配置库 |- libgrallocusage // 显示系统库 |- libion // ION是Google的下一代内存管理器，用来支持不同的内存分配机制，如CARVOUT(PMEM)，物理连续内存(kmalloc), 虚拟地址连续但物理不连续内存(vmalloc)， IOMMU等 |- liblog // log库 |- libmemtrack // 内存堆栈库 |- libmemunreachable // |- libmetricslogger // |- libnativebridge // native层库 |- libnativeloader // native加载库 |- libnetutils // 网络工具包库 |- libpackagelistparser //包解析库 |- libpixelflinger // Pixelflinger是Android系统中为OpenGLES引擎提供的一套软件渲染器（renderer）。OpenGLES引擎提供了一系列基础绘图功能。这些功能包括定义各种颜色格式像素位置、画点画线、绘制矩形及三角形、填充纹理等等。由于OpenGLES相当于一个状态机，配置OpenGLEs状态的函数也均由Pixelflinger提供 |- libprocessgroup // 进程组库 |- libprocinfo // 系统属性信息 |- libsparse // 稀疏矩阵库 |- libsuspend // 跟电源管理相关 |- libsync // 网络数据同步开发库 |- libsysutils // 系统工具库 |- libunwindstack // libunwind库为基于64位CPU和操作系统的程序提供了基本的堆栈辗转开解功能 |- libusbhost // usb库 |- libutils // 系统基本库 |- libziparchive // zip压缩算法库 |- lmkd // 低内存库 |- logcat // logcat工具源码 |- logd // log进程 |- logwrapper // log封装工具 |- mkbootimg // 制作启动boot.img的工具盒脚本 |- reboot // 重启 |- rootdir // rootfs，包含一些etc下的脚本和配置 |- run-as // 权限控制 |- sdcard // SD卡管理器 |- shell_and_utilities // shell工具包 |- storaged // 存储 |- toolbox // toolbox，类似busybox的工具集 |- trusty // 授权底层 |- tzdatacheck // 时区检查底层 |- extras // 核心库之外的程序，包括以下几个目录。 |- alloc-stress // 内存释放 |- ANRdaemon // 系统无响应库 |- app-launcher // launcher应用库 |- boot_control_copy // boot控制复制 |- bootctl // boot控制 |- brillo_config // Brillo 系统配置 |- cppreopts // |- cpustats // cpu状态 |- crypto-perf // 加密性能分析工具 |- ext4_utils // ext4文件系统 |- f2fs_utils // f2fs文件系统 |- ioshark // io流操作泄露回收 |- iotop // io操作相关 |- kexec_tools // Kexec是Linux和Xen提供的软重启和崩溃转储工具。 这个页面是kexec各种工作的反弹点 |- ksmutils // KSM是一种节省内存的重复数据删除功能，可以合并匿名（专用）页面（不是页面缓存）。 虽然它是以这种方式开始的，但KSM目前适用于不止于虚拟机的使用，因为它对任何生成相同数据的许多实例的应用程序都是有用的 |- latencytop // a tool for software developers ，identifying system latency happen |- libfec // fec库 |- libpagemap // pagemap库 |- librank // rank库 |- memcpy-perf // 内存性能分析 |- memory_replay // 内存重写 |- memtrack // 内存堆栈 |- micro_bench // sim相关 |- mmap-perf // 系统级性能分析工具 |- multinetwork // 多网络系统实现 |- pagecache // |- perfprofd // 系统安装相关 |- postinst // |- preopt2cachename // dex文件优化相关 |- procmem // 用于查看系统中的内存使用情况，procrank可以查看系统中所有进程的整体内存占用情况，并按照规则排序 |- procrank // 用于查看系统中的内存使用情况，procmem可以针对某个特定的进程分析其堆、栈、共享库等内存占用情况 |- puncture_fs // |- runconuid // |- sane_schedstat // 射频库 |- showmap // showmap工具 |- showslab // showslab工具 |- simpleperf // Simpleperf是Android平台的一个本地层性能分析工具。它的命令行界面支持与linux-tools perf大致相同的选项，但是它还支持许多Android特有的改进 |- slideshow // 幻灯片展示 |- sound // 声音相关 |- squashfs_utils // SquashFS是一套基于Linux内核使用的压缩只读文件系统。该文件系统能够压缩系统内的文档,inode以及目录，文件最大支持2^64字节。 |- su // su命令源码 |- systrace_analysis // 系统性能分析 |- taskstats // 任务管理 |- tests // 测试工具 |- tools // 工具 |- verity // 认证 |- zram-perf // ZRAM是linux的一种内存优化技术，基本工作原理是：通过划定一片区域，将压缩过后的硬盘数据放入该区域，以实现高速读取 |- gatekeeper // 防护程序，如锁屏密码等。|- hardware // |- hwservicemanager // Hardware Service Manager。 |- keymaster // HAL密钥管理。 |- libfmq // Message Queue。 |- libhidl // Hardware Interface Description Language。 |- libhwbinder // Hardware Binder。 |- libufdt // Unflattened Device Tree。 |- libvintf // Vendor Interface。 |- media // 包括alsa、audio、brillo、camera和radio。 |- nativepower // 用于Brillo的电源管理模块，包括客户端的libnativepower和服务端的nativepowerman以及示例代码。 |- netd // 网络模块，包括client和server。 |- nfc // Near Field Communication。 |- nvram // NVRAM访问控制。 |- security // 安全模块，包括keystore和软件模拟的softkeymaster。 |- sepolicy // Android SELinux policy configuration。 |- tools // 包括aidi和hidl。 |- tpm // Trusted Platform Module，一种安全防御工具。 |- update_engine // 系统升级。 |- vold // Volume服务，如sdk卡、usb等。 test 目录 12|- vts // Vendor Test Suite。 |- vts-testcase // VTS测试用例，包括fuzz、kernel、performance和security。 tools 目录 12345678|- apksig // APK签名，包括一个Java库和一个Java命令行工具。 |- external // 外部工具，包括以下几个目录。 |- fat32lib // 用于FAT文件系统。 |- gradle // Gradle各种版本的源码压缩包。 |- loganalysis // log分析的Java类库。 |- repohooks // 用于repo upload，报告各仓库的修改情况。 |- test // 测试框架，Python实现。 |- tradefederation // 服务于测试。 vendor 12345678910111213|- aosp （android open source project） |- products （一些板级规则）|- qcom （高通的配置）|- sample （google提供的样例） |- apps （应用） |- client （用户） |- upgrade （升级） |- frameworks （框架） |- PlatformLibrary （平台库） |- products （产品） |- sdk_addon （sdk添加部分） |- skins （皮肤） |- WVGAMedDpi （WVGA适用的图片） cts 目录 123456789|- apps // cts测试所使用的apk源码 |- build // cts套件的编译配置 |- common // cts套件的通用代码|- development // cts套件兼容之前使用eclipse ADT开发apk的脚本 |- hostsidetests // cts套件新增host测试项 |- libs // cts套件使用的第三方库 |- suite // cts套件 |- tests // cts套件进行的测试项 |- tools // cts套件使用的测试工具源码 out &#x2F;&#x2F; 编译产生的目录 1234567891011121314151617181920212223242526|- host // 在主机PC host上使用的工具，包括二进制程序以及JAVA的程序） |- common |- obj // JAVA 库 |- linux-x86 |- bin // 二进制程序 |- framework // JAVA 库,*.jar 文件 |- lib // 共享库*.so |- obj // 中间生成的目标文件|- target // 在目标机(如ARM)上运行的内容，多数编译资源会暂存在这里|- common // common表示通用的内容 |- R // 资源文件 |- docs |- obj // 目标文件，APPS中包含了打成APK包的JAVA应用程序， JAVA_LIBRARIES中包含了JAVA的库|- product // product 中则是针对产品的内容 |- generic |- android-info.txt |- clean_steps.mk |- symbols |- obj // obj/APPS目录中包含了各种打成了APK包的JAVA应用，obj/SHARED_LIBRARIES中存放所有动态库，obj/STATIC_LIBRARIES中存放所有静态库 |- root/ |- ramdisk.img // 对应于root/目录，挂载在/ |- system/ |- system.img // 挂载在system/目录，包括了主要系统apps，priv-apps |- data/ |- userdata.img // 挂载在data/目录，用户数据 |- userdata-qemu.img","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/CMake语法/","text":"常用CMake 语法 一. cmake 版本号声明 12# 声明一个我们使用的最小版本cmake_minimum_required(VERSION 3.10.2) 二. 设置项目名称 12# 这个项目名称一般和生成的库名称相同project(test) 三. 添加头文件搜索目录 1include_directories(../../../include) 四. 添加源文件 1234# 使用变量添加set(SOURCES test.cpp xxx.cpp)# 添加所有FILE(GLOB SRCS &quot;*.CPP&quot; &quot;*.h&quot;) 五. 生成一个库 12345678910111213141516动态库和静态库的区别： 动态库是共享的 静态库是独占的举个例子就是，有两个应用程序，A和B，他们两个都依赖 test.so,这个test.so在内存中就只有一份，占用也是一份内存如果我们给test库打包成test.a,那么A和B会各自独占一份test.a那么在内存上，就会占用两份空间add_library( # Sets the name of the library. srt-lib # 库的名字 # Sets the library as a shared library. SHARED # 动态库 # Provides a relative path to your source file(s). srt-lib.cpp srt1-lib.cpp) # 源文件列表 六. 搜索一个库(预构建库) 1234567find_library( # Sets the name of the path variable. log-lib # 可以理解别名 # Specifies the name of the NDK library that # you want CMake to locate. log # 这个是liblog.so 在ndk目录中自带的一个库 ) 七. 设置一个变量 12# 设置LIBDIR为 $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;set(LIBDIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;) 八. 导入预构建库 123456# 导入静态库add_library(ssl STATIC IMPORTED)set_target_properties(srt PROPERTIES IMPORTED_LOCATION $&#123;LIBDIR&#125;/libssl.a)# 导入动态库add_library(ssl SHARED IMPORTED)set_target_properties(srt PROPERTIES IMPORTED_LOCATION $&#123;LIBDIR&#125;/libssl.so) 九. 链接库 123456target_link_libraries( # Specifies the target library. test # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;) 十. 设置库的输出目录 1set_target_properties(test PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY_$&#123;ARCH&#125;&#125;)","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/NDK/蒋超大佬扫盲/1.基础知识/","text":"NDK概念及疑问 12345678910111213141516171819202122232425262728291.ndk是什么 NDK是一个工具集，允许你的App使用一些底层语言代码，例如C和C++。针对特定类型的应用，能使用C和C++的代码， 将会很有用，因为这样你可以复用已经存在的C和C++库代码。 2.jni是什么 - Java Native Interface Java本地接口， - Java层调用本地C，C++等 - JNI是Java调用本Native语言的一种特性，与Android无直接关系 - 实际中的驱动都是C/C++开发的，通过JNI，Java可以调用C/C++实现的驱动，从而扩展Java虚拟机的能力。另外， 在高效的数学运算、游戏的实时渲染、音视频的编码和解码等方面，一般都是用C开发的。3.为什么用ndk - 进一步提升设备性能，以降低延迟或运行游戏或物理模拟等计算密集型应用。 - 重复使用您自己或其他开发者的 C 或 C++ 库。4.ndk的开发资料 - 官方文档：https://developer.android.google.cn/ndk?hl=zh_cn5.ndk的学习方法 - 参考官方文档学习6.交叉编译概念 - 交叉编译就是程序的编译环境和实际运行环境不一致，即在一个平台上生成另一个平台上的可执行代码。 - 比如NDK，你在Mac、Win或者Linux上生成的C/C++的代码要在Android平台上运行，就需要使用到交叉编译了。 -通俗点说就是你的电脑和手机使用的CPU不同，所以CPU的指令集就不同，比如arm的指令集在X86上就不能运行。7.预编译库及非预编译库是什么 - 预编译库是指已经经过编译的二进制文件，可以直接在 Android 应用中使用如静态库（.a）或共享库（.so）。 预编译库可以直接加载到应用程序中，并通过JNI与 Java 层进行交互 - 非预编译库是指将 C/C++ 代码直接放在 Android 项目中，并在构建时进行编译，这种方式会将 C/C++ 代码与 Java 代码一起 编译成最终的应用程序，而不是单独生成预编译库。8.cmake是什么以及它的常用语法 - CMake 是一个跨平台的构建工具，用于管理和构建 C/C++ 项目。它提供了简洁易用的语法和命令来描述项目的构建过程， 并自动生成与构建环境相关的构建脚本，使项目能够方便地在不同的平台上进行构建。 - 见 CMake语法.md文件 常用CMake 语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364一. cmake 版本号声明# 声明一个我们使用的最小版本cmake_minimum_required(VERSION 3.10.2)二. 设置项目名称# 这个项目名称一般和生成的库名称相同project(test)三. 添加头文件搜索目录include_directories(../../../include)四. 添加源文件# 使用变量添加set(SOURCES test.cpp xxx.cpp)# 添加所有FILE(GLOB SRCS &quot;*.CPP&quot; &quot;*.h&quot;)五. 生成一个库动态库和静态库的区别： 动态库是共享的 静态库是独占的举个例子就是，有两个应用程序，A和B，他们两个都依赖 test.so,这个test.so在内存中就只有一份，占用也是一份内存如果我们给test库打包成test.a,那么A和B会各自独占一份test.a那么在内存上，就会占用两份空间add_library( # Sets the name of the library. srt-lib # 库的名字 # Sets the library as a shared library. SHARED # 动态库 # Provides a relative path to your source file(s). srt-lib.cpp srt1-lib.cpp) # 源文件列表 六. 搜索一个库(预构建库) find_library( # Sets the name of the path variable. log-lib # 可以理解别名 # Specifies the name of the NDK library that # you want CMake to locate. log # 这个是liblog.so 在ndk目录中自带的一个库 )七. 设置一个变量 # 设置LIBDIR为 $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;set(LIBDIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;)八. 导入预构建库# 设置LIBDIR为 $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;set(LIBDIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;)九. 链接库target_link_libraries( # Specifies the target library. test # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;)十. 设置库的输出目录 set_target_properties(test PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY_$&#123;ARCH&#125;&#125;) NDK中打印日志 1234567891011#include &lt;android/log.h&gt;#define LOG_TAG &quot;tyl&quot;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)//通过#define的宏定义组装我们的__android_log_print方法extern &quot;C&quot;JNIEXPORT jint JNICALLJava_com_tyl_ndk_1study_MainActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) &#123; LOGI(&quot;a+b=%d&quot;,a+b); //输出则为a+b=3,tag=tyl return a+b;&#125; NDK开发实际集成源码的场景 1.使用Android Studio 源码直接集成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 - 新建项目时选择Table的时候滑倒最后选择Native C++,main目录下会自动添加一个cpp目录里面就是c++文件； - 使用示例： public native int add(int a, int b);//在MainActivity中新增方法，新建的方法会报红， //鼠标放到报红的地方alt+enter出现Create JNI function for add按钮，点击会自动在cpp文件中创建jni的add方法； extern &quot;C&quot; JNIEXPORT jint JNICALL //java+包名+方法名 Java_com_tyl_myjnistudy_MainActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) &#123; return a+b; &#125; //上面是cpp文件中的代码，在方法中实现自己的逻辑代码即可； //activity中使用再加载了库后 System.loadLibrary(&quot;ndkdemo&quot;)，直接调用方法执行即可; 完整代码： //MainActivity public class MainActivity extends AppCompatActivity &#123; static &#123; System.loadLibrary(&quot;ndkdemo&quot;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.e(&quot;tyl&quot;,&quot;add=&quot;+add(1,2)); &#125; public native String stringFromJNI(); public native int add(int a, int b);&#125;//native-lib.cpp#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define LOG_TAG &quot;tyl&quot;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_tyl_ndkdemo_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125;extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_tyl_ndk_1study_MainActivity_stringFromJNI(JNIEnv *env, jobject thiz) &#123; // TODO: implement stringFromJNI()&#125;extern &quot;C&quot;JNIEXPORT jint JNICALLJava_com_tyl_ndk_1study_MainActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) &#123; LOGI(&quot;a+b=%d&quot;,a+b); return a+b;&#125; 2.使用命令编译出符合平台相关的预编译库 配置ndk环境 12345678910111213141516171819201.下载并安装 NDK打开 Android Studio。点击菜单栏中的 “File”，选择 “Project Structure”。在弹出的窗口中，选择 “SDK Location”。在 “Android NDK location” 的文本框中，点击 “Download” 按钮。在弹出的 “SDK Components Setup” 窗口中，勾选 “LLDB” 和 “CMake”，然后点击 “Next”。在 “SDK Platforms” 窗口中，选择你需要的 NDK 版本，并点击 “Next”。在 “SDK Tools” 窗口中，选择 “LLDB” 和 “CMake”，然后点击 “Finish”。Android Studio 将自动下载并安装 NDK。4. 配置 Android Studio 的 NDK 路径现在，我们需要配置 Android Studio 的 NDK 路径，以便在项目中正确使用 NDK。2.打开 Android Studio。点击菜单栏中的 “File”，选择 “Project Structure”。在弹出的窗口中，选择 “SDK Location”。在 “Android NDK location” 的文本框中，填入你的 NDK 路径。如果你使用默认的 Android Studio 安装路径，NDK 路径应为：&lt;Android Studio 安装路径&gt;/ndk/&lt;NDK 版本号&gt;。例如：C:\\android\\android-studio\\ndk\\22.0.7026061点击 “OK” 保存配置。 2.1.test.cpp 测试的c++文件 12345678#include &lt;iostream&gt;#include &quot;test.h&quot;using namespace std;int test::add(int a, int b) &#123; std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; std::endl; return a + b;&#125; 2.2.test.h 测试的c++头文件 1234567#ifndef TEMPLATE_TEST_H#define TEMPLATE_TEST_Hclass test &#123; public: int add(int a, int b);&#125;;#endif 2.3.CMakeLists.txt cmake编译文件 1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required(VERSION 3.22.1)project(test)set(CMAKE_CXX_STANDARD 17)# 设置NDK路径set(ANDROID_NDK &quot;/home/jiangc/Android/Sdk/ndk/25.1.8937393&quot; CACHE PATH &quot;Android NDK path&quot;)# 设置架构，用来设置输出目录set(ARCHS &quot;armeabi-v7a&quot; &quot;arm64-v8a&quot; &quot;x86&quot; &quot;x86_64&quot;)# 设置Android API级别set(ANDROID_API_LEVEL 22)# 添加每个架构的输出目录foreach(ARCH $&#123;ARCHS&#125;) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_$&#123;ARCH&#125; $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/$&#123;ARCH&#125;)endforeach()# 设置头文件include_directories(.)# 设置源文件set(SOURCES test.cpp)# 编译某一个架构的function(build_library ARCH) set(CMAKE_ANDROID_ARCH_ABI $&#123;ARCH&#125;) set(CMAKE_ANDROID_NDK $&#123;ANDROID_NDK&#125;) set(CMAKE_SYSTEM_NAME Android) set(CMAKE_SYSTEM_VERSION $&#123;ANDROID_API_LEVEL&#125;) add_library(test SHARED $&#123;SOURCES&#125;) set_target_properties(test PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY_$&#123;ARCH&#125;&#125;)endfunction()message(&quot;--------------------------------------------- $&#123;ANDROID_ABI&#125;&quot;)build_library($&#123;ANDROID_ABI&#125;) 2.4.build.sh 1234567891011//遇到的问题：1. bash: ./build.sh: /bin/bashsM: bad interpreter: No such file or directory原因是window环境过去的文件，用vim -b 打开会看到很多^M的字符解决方式：vim -b 打开，shift+: 组合键输入： %s/\\r//g 回车后后:wq保存退出2./build.sh: line 2: cmake: command not found原因是未安装cmake,解决方式：sudo apt install cmake3.Make Error at CMakeLists.txt:1 (cmake_minimum_required): CMake 3.22.1 or higher is required. You are running version 3.16.3原因是CMakeLists.txt文件中的最低版本号过高，解决方案是：打开CMakeLists.txt将cmake_minimum_required(VERSION 3.22.1)修改为cmake_minimum_required(VERSION 3.16.3) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/bashrm build -rf rm libs -rfmkdir buildcd buildANDROID_NDK=&quot;/home/jiangc/Android/Sdk/ndk/25.1.8937393&quot;ARCHS=(&#x27;armeabi-v7a&#x27; &#x27;arm64-v8a&#x27; &#x27;x86&#x27; &#x27;x86_64&#x27; )function compile()&#123; for i in $&#123;ARCHS[@]&#125;; do cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=&quot;$i&quot; \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=android-22 \\ .. make done&#125;compile:&lt;&lt;!cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=&quot;armeabi-v7a&quot; \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=android-22 \\ ..make cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=&quot;arm64-v8a&quot; \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=android-22 \\ ..make cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=&quot;x86&quot; \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=android-22 \\ ..make cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=&quot;x86_64&quot; \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=android-22 \\ ..make! 12./build.sh //执行编译成功后生成lib包，里面包含有各个版本的so文件 3.使用Android Studio 直接集成预编译库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//1.导入资源app目录下新建include文件夹，将test.h文件导入将so包复制到lib路径下//2.修改CMakeLists.txt添加资源cmake_minimum_required(VERSION 3.16.3)project(&quot;ndkdemo&quot;)# 包含头文件include_directories(../../../include)# 设置依赖库路径set(LIBDIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;)# 库的导入add_library(test SHARED IMPORTED)set_target_properties(test PROPERTIES IMPORTED_LOCATION $&#123;LIBDIR&#125;/libtest.so)add_library( # Sets the name of the library. ndkdemo SHARED native-lib.cpp)foreach(item RANGE 1 5 2) message(&quot;item = $&#123;item&#125;&quot;)endforeach(item)find_library( # Sets the name of the path variable. log-lib log)#添加 testtarget_link_libraries( # Specifies the target library. ndkdemo test $&#123;log-lib&#125;) //3.make androidStudio同步文件后，导入test.h及使用示例#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include &quot;../../../include/test.h&quot;#define LOG_TAG &quot;tyl&quot;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)extern &quot;C&quot;JNIEXPORT jint JNICALLJava_com_tyl_ndk_1study_MainActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) &#123; LOGI(&quot;a+b=%d&quot;,a+b); test t; int c= t.add(3,4); LOGI(&quot;A+B=%d&quot;,c); return a+b;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"}]},{"path":"wiki/Android进阶/网络请求库Retrofit/","text":"Retrofit简介 12Retrofit 是一个Square开发的安卓客户端请求库。其中内部封装了okhttp库。官方的介绍是使用非常简短 Retrofit使用注解,能够极大的简化网络请求数据的代码; 与其它网络库的对比 1234AndroidAsynHttp - 基于HttpClient作者已停止维护，Android5.0不再使用HttpClient,因此不推荐使用。Volley - 基于HttpUrlConnection,Google官方推出，只适合轻量级网络交互如数据传输小，不适合大文件下传下载场景； Retrofit优点 1API设计简洁易用、注解化配置高度解耦、支持多种解析器、支持Rxjava Retrofit使用 1.Retrofit开源库、OkHttp网络库、数据解析器集成注册网络权限 123456//依赖包导入implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;implementation &#x27;com.squareup.okhttp3:okhttp:3.14.9&#x27;implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27;//网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2.创建接口设置请求类型与参数 12345新建UserInfoModel类和UserMgrService接口public interface RequestInterface &#123; @GET(&quot;login&quot;) Call&lt;LoginBean&gt; getCloseTime(@Query(&quot;ip&quot;) String devideIp);&#125; 请求示例 &#x2F;&#x2F;假设BASE_URL &#x3D; “http://192.168.0.1/“ @Url 123//整个地址都要变化，甚至是baseUrl@GET Call&lt;List&lt;Repo&gt;&gt; getData(@Url String user); @Path 1234//用于替换Url路径中的变量字符。@GET(&quot;weather/&#123;city_name&#125;&quot;)Observable&lt;Object&gt; getWeather(@Path(&quot;city_name&quot;) String city_name);//完整结果：http://192.168.0.1/weather/北京 2.1Get请求 @Query 1234//主要用于Get请求数据，用于拼接在拼接在Url路径后面的查询参数，一个@Query相当于拼接一个参数，多个参数中间用，隔开。@GET(&quot;weather&quot;)Observable&lt;WeatherEntity&gt; getWeather(@Query(&quot;city&quot;) String city);//完整结果：http://192.168.0.1/weather?city=北京 @QueryMap 1234//主要的效果等同于多个@Query参数拼接，主要也用于Get请求网络数据。@GET(&quot;weather/&#123;city_name&#125;&quot;)Observable&lt;Object&gt; getWeather(@Path(&quot;city_name&quot;) String city_name, @QueryMap Map&lt;String, String&gt; queryParams);//完整结果：http://192.168.0.1/weather/北京?user_id=1&amp;user_name=jojo 2.2Post请求 @Filed 123456//@Field的用法类似于@Query，于拼接在拼接在Url路径后面的查询参数。@FormUrlEncoded //使用@Field时记得添加@FormUrlEncoded@POST(&quot;comment&quot;)void doComments(@Field(&quot;content&quot;) String content, @Field(&quot;user_id&quot;) String user_id);//完整结果：http://192.168.0.1/comment//body参数：&#123;content&quot;:&quot;我是评论&quot;,&quot;user_id&quot;:&quot;1001&quot;&#125; @FieldMap 1234567//用法类似于@QueryMap,主要用于Map拼接多个参数@FormUrlEncoded@POST(&quot;comment&quot;)void doComments(@FieldMap Map&lt;String, String&gt; paramsMap );// HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();// hashMap.put(&quot;content&quot;,&quot;我是评论&quot;);// hashMap.put(&quot;user_id&quot;,&quot;1001&quot;); @Body 12345678910111213141516//例1@POST(&quot;comment&quot;)void doComments(@Body Object reqBean);//例2@POST(&quot;comment&quot;)void doComments(@Body List&lt;Object&gt; requestList);//例3 文件上传@POST(&quot;upload/&quot;)Observable&lt;Object&gt; uploadFile(@Body RequestBody requestBody);//只不过文件上传传入的是RequestBody类型,下面是构建RequestBody的方式： File file = new File(mFilePath); //mImagePath为上传的文件绝对路径 //构建body RequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;file&quot;, file.getName(), RequestBody.create(MediaType.parse(&quot;multipart/form-data&quot;), file)) .build(); 2.3Put请求 123@PUT(&quot;comment/&#123;comment_id&#125;&quot;)void comment(@Path(&quot;comment_id&quot;) String comment_id);//完整结果：http://192.168.0.1/comment/88 123@PUT(&quot;comment/&#123;comment_id&#125;&quot;)void comment(@Path(&quot;comment_id&quot;) String comment_id @Query(&quot;user_id&quot;) String user_id);//完整结果：http://192.168.0.1/comment/88?user_id=1001 1234567891011121314//加body参数：&#123;&quot;content&quot;:&quot;我是评论&quot;，&quot;type&quot;:&quot;1&quot;&#125;//此类请求的应用场景：适合于body中需要传入多个请求参数，这样可以将多个请求的参数字段封装到一个实体中，这样就不用写多个@Filed了public class RequestBean &#123; public String content; public String type; //实际中可能还有多个请求字段&#125;...RequestBean requestBean = new RequestBean(); requestBean .content = &quot;我是评论&quot;; requestBean .type = &quot;1&quot;;...@PUT(&quot;comment/&#123;comment_id&#125;&quot;)void comment(@Path(&quot;comment_id&quot;) String comment_id @Query(&quot;user_id&quot;) String user_id @Body RequestBean reqBean); 2.4Delete 123@DELETE(&quot;comment/&#123;comment_id&#125;&quot;)void comment(@Path(&quot;comment_id&quot;) String comment_id);//假如删除评论：http://192.168.0.1/comment/88 综上所述，可以归纳出上面几个注解的用法： 123456@Path ： 请求的参数值直接跟在URL后面时，用@Path配置@Query： 表示查询参数，以?key1=value1&amp;key2=value2的形式跟在请求域名后面时使用@Query@QueryMap ：以map的方式直接传入多个键值对的查询参数@Field： 多用于post请求中表单字段，每个@Field后面，对应一对键值对。@FieldMap ：以map的方式传入多个键值对，作为body参数@Body: 相当于多个@Field，以对象的形式提交 注意：Filed和FieldMap需要FormUrlEncoded结合使用，否则会抛异常！ 3.创建Retrofit对象、设置数据解析器 12Retrofit retrofit = new Retrofit.Builder().baseUrl(&quot;http://149.0.171.247:8088/&quot;).addConverterFactory(GsonConverterFactory.create().build(); baseUrl： 123这里的baseUrl是自己访问的Url的基类地址，加上刚才@GET(“login”)中的login才是我们真正要访问的地址，因为使用了@Query(&quot;ip&quot;)，所以最终的访问地址为http://149.0.171.247:8088/login?ip=devideIp，此处的ip为自己传入的参数。注意: baseUrl必须要以/结尾！！！ 4.生成接口对象 1RequestInterface service= retrofit.create(RequestInterface.class); 5.调用接口方法返回Call对象 1Call&lt;LoginBean&gt; call=service.login(&quot;zhangsan&quot;&quot;123456&quot;) 6.发送请求(同步、异步) 12345678910111213同步:调用Call对象的execute()，返回结果的响应体异步:调用Call对象的enqueue0，参数是一个回调call.enqueue(new Callback&lt;LoginBean&gt;() &#123; @Override public void onResponse(Call&lt;LoginBean&gt; call, Response&lt;LoginBean&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;LoginBean&gt; call, Throwable t) &#123; &#125; &#125;); 问题： 1234567使用时别忘了申请网络权限哦，使用时可能会遇到以下问题：CLEARTEXT communication to mock-api.com not permitted by network security policy这是因为Android P不允许明文访问，而前面的mock地址是http开头的，解决办法是在AndroidManifest中的application内加入下面这段代码即可：android:usesCleartextTraffic=&quot;true&quot; 一、Retrofit工具类的封装（核心类） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * Retrofit工具类 */public class RetrofitUtils &#123; public static final String BASE_URL = &quot;http://XXX&quot;; /** * 超时时间 */ public static final int TIMEOUT = 60; private static volatile RetrofitUtils mInstance; private Retrofit mRetrofit; public static RetrofitUtils getInstance() &#123; if (mInstance == null) &#123; synchronized (RetrofitUtils.class) &#123; if (mInstance == null) &#123; mInstance = new RetrofitUtils(); &#125; &#125; &#125; return mInstance; &#125; private RetrofitUtils() &#123; initRetrofit(); &#125; /** * 初始化Retrofit */ private void initRetrofit() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); // 设置超时 builder.connectTimeout(TIMEOUT, TimeUnit.SECONDS); builder.readTimeout(TIMEOUT, TimeUnit.SECONDS); builder.writeTimeout(TIMEOUT, TimeUnit.SECONDS); OkHttpClient client = builder.build(); mRetrofit = new Retrofit.Builder() // 设置请求的域名 .baseUrl(BASE_URL) // 设置解析转换工厂，用自己定义的 .addConverterFactory(ResponseConvert.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client(client) .build(); &#125; /** * 创建API */ public &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; return mRetrofit.create(clazz); &#125;&#125; 代码很简单，创建后台请求接口，调用create即可。 二、Converter.Factory的封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 自定义Gson解析转换 */public class ResponseConvert extends Converter.Factory &#123; public static ResponseConvert create() &#123; return new ResponseConvert(); &#125; /** * 转换的方法 */ @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return new BodyConverter&lt;&gt;(type); &#125; private class BodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private Gson gson; private Type type; public BodyConverter(Type type) &#123; this.type = type; gson = new GsonBuilder() .registerTypeHierarchyAdapter(List.class, new ListTypeAdapter()) .create(); &#125; @Override public T convert(ResponseBody value) throws IOException &#123; String json = value.string(); return gson.fromJson(json, type); &#125; &#125; /** * 空列表的转换 */ private static class ListTypeAdapter implements JsonDeserializer&lt;List&lt;?&gt;&gt; &#123; @Override public List&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123; if (json != null &amp;&amp; json.isJsonArray()) &#123; JsonArray array = json.getAsJsonArray(); Type itemType = ((ParameterizedType) typeOfT).getActualTypeArguments()[0]; java.util.List list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; array.size(); i++) &#123; JsonElement element = array.get(i); Object item = context.deserialize(element, itemType); list.add(item); &#125; return list; &#125; else &#123; //和接口类型不符，返回空List return Collections.EMPTY_LIST; &#125; &#125; &#125;&#125; 三、Retrofit网络请求基类的封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 后台统一接口API */public interface ServerApi &#123; // 联系人编辑 @POST(URLS.LOGIN) Observable&lt;ResponseBean&lt;LoginBean&gt;&gt; login(@Body RequestBody requestBody);&#125;/** * 请求网络业务的基类，AppPresenterr 的封装 */public class AppPresenter &#123; protected ServerApi mApi = RetrofitUtils.getInstance().create(ServerApi.class); private static final Gson gson = new Gson(); /** * 1. 转换 * 统一处理一些动作 */ public static &lt;T&gt; void convert(Observable&lt;ResponseBean&lt;T&gt;&gt; observable, Observer&lt;T&gt; observer) &#123; observable .map(new Function&lt;ResponseBean&lt;T&gt;, T&gt;() &#123; @Override public T apply(ResponseBean&lt;T&gt; httpResult) throws Exception &#123; // 打印响应的对象 LogUtils.object(httpResult); // TODO 实际开发的时候统一处理一些东西 if (httpResult == null || httpResult.head == null) &#123; throw new RuntimeException(&quot;请求数据异常&quot;); &#125; else if (!&quot;1&quot;.equals(httpResult.head.bcode)) &#123; throw new RuntimeException(httpResult.head.bmessage); &#125; return httpResult.data; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; /** * 2. 执行的方法 */ public static &lt;T&gt; void execute(Observable&lt;ResponseBean&lt;T&gt;&gt; observable, Observer&lt;ResponseBean&lt;T&gt;&gt; observer) &#123; observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; /** * 3.请求数据是Json，Json转成RequestBody */ public static RequestBody createRequestBody(Object obj) &#123; RequestBean bean = new RequestBean&lt;&gt;(obj); String json = gson.toJson(bean); // 打印请求的Json LogUtils.json(json); RequestBody body = RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), json); return body; &#125;&#125;有三个通用的方法： 1.convert方法，转换、统一处理网络请求，将公共处理部分放在这方法里面。 2.execute方法，只执行，不做任何处理操作，适用于一些不能统一处理的接口。 3.createRequestBody方法，就是统一创建请求的RequestBody。 四、具体网络请求业务类 1234567891011121314/** * 登录的业务类 */public class LoginPresenter extends AppPresenter &#123; /** * 登录的接口 */ public void login(LoginData data, Observer&lt;LoginBean&gt; observer) &#123; Observable&lt;ResponseBean&lt;LoginBean&gt;&gt; login = mApi.login(createRequestBody(data)); // 转换 convert(login, observer); &#125;&#125; 五、测试和使用 12345678910111213/** * 调用登录接口 */public void open(View view) &#123; LoginData loginData = new LoginData(&quot;135****5219&quot;, &quot;12***56&quot;); presenter.login(loginData, new DialogObserver&lt;LoginBean&gt;(getAppActivity()) &#123; @Override public void onNext(LoginBean data) &#123; // TODO 做登录的成功的操作 Toast.makeText(getAppActivity(), &quot;&quot; + data.userInfo.nickName, Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 六、补充，对于Observer需要再次封装。 12341.如调用登录要显示Dialog2.如Activity销毁要取消请求。3.结合加载数据各种状态页面，如：加载中、加载失败、网络异常、数据为空等等 这些都是可以统一封装在Observer&lt;T&gt;里面。 工具类原文：https://www.jianshu.com/p/7f843d65a7c6","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"}]},{"path":"wiki/Android进阶/性能优化/11.专项技术优化/","text":"11.专项技术优化 一、列表页卡顿优化 常规方案 121.convertView复用、使用ViewHolder2.耗时任务异步处理 布局相关 121.减少布局层级、避免过度绘制2.异步inflate或者X2C 图片相关 121.避免过大尺寸:GC频繁、内存抖动2.滑动时取消加载 线程相关 121.使用线程池收敛线程，降低线程优先级2.避免UI线程时间片被抢占 TextView优化 1234561.原因:面对复杂文本性能不佳2.BoringLayout 单行、StaticLayout 多行3.DynamicLayout可编辑4.展示类StaticLayout即可，性能优于DynamicLayout5.异步创建StaticLayout6.facebook/TextLayoutBuilder 其它 1SysTrace跟踪 二、存储优化 常规方案 121.确保IO操作发生在非主线程2.Hook或者是AOP辅助 SharePreferences相关 123加载慢:初始化加载整个文件全量写入:单次改动都会导致整体写入卡顿:补偿策略导致 SharePreferences替代者MMKV 123mmap和文件锁保证数据完整增量写入、使用Protocol Buffer支持从SharePreferences迁移 日志存储优化 12大量服务需要日志库支持对于性能的要求:不影响性能、日志不丢失、安全 常规实现 123每产生一个日志，写一遍到磁盘中:不丢失、性能损耗开辟一个内存buffer，先存buffer，再存文件:丢日志 mmap 12内存映射文件优势:高性能、不丢失 业界实现:Xlog、Logan 其它 12常用数据的缓存，避免多次读取合理选择缓冲区Buffer大小:4-8KB 三、WebView异常监控 简介 121.重要控件2.问题:性能与适配 问题 1WebView版本及对接业务方众多 思路 121.监控屏幕是否白屏，白屏则WebView有问题2.确认白屏:所有像素一直则认为白屏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.optimize.performance.webview;import android.graphics.Bitmap;import android.graphics.Canvas;import android.os.Build;import android.view.View;import java.util.Arrays;/** * WebView白屏检测 */public class BlankDetect &#123; /** * 判断Bitmap是否都是一个颜色 * @param bitmap * @return */ public static boolean isBlank(View view) &#123; Bitmap bitmap = getBitmapFromView(view); if (bitmap == null) &#123; return true; &#125; int width = bitmap.getWidth(); int height = bitmap.getHeight(); if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; int originPix = bitmap.getPixel(0, 0); int[] target = new int[width]; Arrays.fill(target, originPix); int[] source = new int[width]; boolean isWhiteScreen = true; for (int col = 0; col &lt; height; col++) &#123; bitmap.getPixels(source, 0, width, 0, col, width, 1); if (!Arrays.equals(target, source)) &#123; isWhiteScreen = false; break; &#125; &#125; return isWhiteScreen; &#125; return false; &#125; /** * 从View获取转换到的Bitmap * @param view * @return */ private static Bitmap getBitmapFromView(View view)&#123; Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); if (Build.VERSION.SDK_INT &gt;= 11) &#123; view.measure(View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(view.getHeight(), View.MeasureSpec.EXACTLY)); view.layout((int) view.getX(), (int) view.getY(), (int) view.getX() + view.getMeasuredWidth(), (int) view.getY() + view.getMeasuredHeight()); &#125; else &#123; view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); &#125; view.draw(canvas); return bitmap; &#125;&#125; 12345678910111213141516//使用public class TestBlankActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.testblank); final TextView textView = findViewById(R.id.tv_testblank); textView.postDelayed(new Runnable() &#123; @Override public void run() &#123; boolean isBlank = BlankDetect.isBlank(textView); LogUtils.i(&quot;isBlank &quot;+ isBlank); &#125; &#125;,2000); &#125;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/10.稳定性优化/","text":"10.稳定性优化 12345//稳定性优化1.统一编码规范、增强编码功底、技术评审2.架构优化:统一容错，功能模块解耦3.回归测试，压力测试，兼容性测试，4.容灾方案：热更新(bugly),功能开关，崩溃后自启等 一、如何提升App的稳定性 正确认识 121.稳定性是大问题，Crash是PO优先级2.稳定性可优化的面很广 稳定性纬度 1231.Crash纬度2.性能纬度3.业务高可用纬度 稳定性优化概述 1231.重在预防、监控必不可少2.思考更深一层、重视隐含信息3.长效保持需要科学流程 二、高Crash率的破解之道 Crash相关指标 12345678910111213141516171.UV、PV Crash率(uv主要针对用户使用量，用户使用崩溃率，pv是用户使用的频率，用户使用崩溃的频率) - UV Crash率= Crash UV/DAU - UV 方便评估用户影响范围，结合 PV - 注意:沿用同一种衡量方式2.Java、Native Crash率3.启动、重点流程Crash率4.增量、存量Crash率5.启动Crash率（启动时崩溃） - 影响最严重的Crash - 结合客户端容灾6.增量、存量Crash率（增量指新增的crash，存量指以前老版本就存在的crash） - 增量Crash是新版本重点 - 存量Crash是持续啃的硬骨头 - 优先解决增量、持续跟进存量7.Crash率评价 - 务必在千分之二以下 - Crash率万分位优秀 Crash关键问题 123456789101112尽可能还原Crash现场 - 堆栈、设备、OS版本、进程、线程名、Logcat - 前后台、使用时长、App版本、小版本、渠道 - CPU架构、内存信息、线程数、资源包信息、行为日志APM后台聚合展示 - Crash现场信息 - Crash Top机型、OS版本、分布版本、区域 - Crash起始版本、上报趋势、是否新增、持续、量级责任归属 - 专项小组轮值 - 自动匹配分配 - 处理流程全记录 整体结构 12341.采集层:错误堆栈、设备信息、行为日志、其它信息2.处理层:数据清洗、数据聚合、纬度分类、趋势对比3.展示层:数据还原、纬度信息、起始版本、其它信息4.报警层:环比、同比、邮件、IM、电话 单个Crash处理方案 1231.根据堆栈及现场信息找答案2.找共性:机型、OS、实验开关、资源包3.线下复现、远程调试 Crash率治理方案 1231.解决线上常规Crash2.系统级Crash尝试Hook绕过3.疑难Crash重点突破、更换方案 三、移动端业务高可用方案建设 业务高可用重要性 1231.高可用:性能+业务2.业务高可用侧重于用户功能完整可用3.业务高可用真实的影响收入 业务高可用方案建设 12345678910111213141516数据采集 - 梳理项目主流程、核心路径、关键节点 - Aop自动采集、统一上报报警策略 - 闽值报警 - 趋势报警 - 特定指标报警、直接上报异常监控 - Catch代码块 - 异常逻辑单点追查 - 需要针对性分析的特定问题 - 全量日志回捞，专项分析兜底策略 - 配置中心，功能开关 - 跳转分发中心 四、移动端容灾方案 移动端容灾必要性 12灾:性能、业务异常传统流程:用户反馈、重新打包、渠道更新，不可接受 容灾方案建设 1234567891011121314功能开关 - 配置中心，服务端下发配置控制 - 针对场景:功能新加或代码改动统跳中心 - 界面切换通过路由，路由决定是否重定向 - eg:Native Bug不能热修则跳转到临时H5动态化修复 - 热修复能力，可监控、灰度、回滚、清除 - 推拉结合、多场景调用保证到达率 - Weex、RN增量更新安全模式 - 根据Crash信息自动恢复，多次启动失败重置App - 严重Bug可阻塞性热修 - 异常熔断:多次请求失败则主动拒绝 容灾方案集合 1功能开关-&gt;统跳中心-&gt;动态修复-&gt;安全模式 五、稳定性长效治理 全流程Crash长效治理 1234567891011121314151617开发阶段 - 统一编码规范、增强编码功底、技术评审、CodeReview机制 - 架构优化:能力收敛、统一容错测试阶段 - 功能测试、自动化测试、 回归测试、覆盖安装 - 特殊场景、机型等边界测试 - 云测平台合码阶段 - 编译检测、静态扫描 - 预编译流程、主流程自动回归发布阶段 - 多轮灰度 - 分场景、纬度全面覆盖运维阶段 - 灵敏监控 - 回滚、降级策略 - 热修、容灾方案 六、问题 你们做了哪些稳定性方面的优化 1231.Crash专项优化2.性能稳定性优化3.业务稳定性优化 性能稳定性是怎么做的? 1231.线下发现问题、优化为主2.线上监控为主3.Crash专项 业务稳定性如何保障 ? 121.数据采集+报警2.异常监控 + 单点追查 如果发生了异常情况，怎么快速止损? 1231.能力:功能开关、统跳中心2.动态修复:热修、资源包更新3.自主修复:安全模式","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/9.瘦身优化/","text":"9.瘦身优化 12345678//瘦身优化1.代码混淆，统一三方库、删除无用代码2.资源在线化3.So:只保留Armeabi、或者只保留armeabi-v7a、arm64-v8a4. 图片优化： 1.根据场景使用不同的文件，比如将png换成webp，像什么需要来回改变的简单的图可以使用svg替换，去除不需要的图片资源 2.图片压缩5. 备用资源：默认情况下Android会有很多备用资源，比如string，包含了多国语言，我们可以指定需要的语言即可； 一、瘦身优化及Apk分析方案介绍 瘦身优势 1231.最主要是转换率:下载转换率2.头部App都有Lite版3.渠道合作商要求 Apk组成 1231.代码相关:classes.dex2.资源相关:res、asserts、resources.arsc3.So相关:lib Apk分析 12345678910111213ApkTool，反编译工具 - 官网:https://ibotpeaches.github.io/Apktool/apktool d xx.apkAnalyze APK:Android Studio 2.2之后 - 查看Apk组成、大小、占比 - 插看Dex文件组成 - Apk对比App性能分析 https://nimbledroid.com/ - 文件大小及排行 - Dex方法数、SDK方法数 - 启动时间、内存等android-classyshark:二进制检查工具 - https://github.com/google/android-classyshark - 支持多种格式:Apk、Jar、Class、So等 二、代码瘦身实战 代码混淆 12345678910花指令，功能等价但改变形式 - 代码中各个元素改写成无意义的名字 - 以更难理解的形式重写部分逻辑 - 打乱代码格式Proguard:Java类文件处理工具，优化字节码 - 代码中元素名称改短，移除冗余代码 - 增加代码被反编译难度 - 使用： - 配置minifyEnabled为true，debug下不要配置 - proguard-rules中配置相应规则 三方库处理 1231.基础库统一2.选择更小的库，Android Methods Count3.仅引入所需的部分代码:Fresco的webp支持 移除无用代码 1231.业务代码只加不减2.代码太多不敢删除3.AOP统计使用情况 三、资源瘦身实战 元余资源 1studio中文件目录-右键-Refactor-Remove Unused Resource 图片压缩 1231.快速发展期的App没有相关规范2.https://tinypng.com/及TinyPngPlugin3.图片格式选择 资源混淆 12https://github.com/shwenzhang/AndResGuard元长的资源路径变短 其它 121.图片只保留一份2.资源在线化 四、so文件瘦身实战 So移除 12341.So是Android上的动态链接库2.七种不同类型的CPU架构3.abiFilters:设置支持的So架构4.一般选择armeabi(万金油可以支持其他架构，会损耗能效) 更优方案 121.完美支持所有类型设备代价太大2.基础架构的都放在armeabi目录，根据CPU类型加载对应架构So(特定功能的so可以动态加载或放入其他架构包) 其它方案 121.So动态下载2.插件化 五、问题 怎么降低Apk包大小 123代码:Proguard、统一三方库、无用代码删除资源:无用资源删除、混淆So:只保留Armeabi、更优方案 Apk瘦身问题长效治理 12发版之前与上个版本包体积对比，超过闯值则必须优化推进插件化架构改造","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/8.电量优化/","text":"8.电量优化 1234567891011121314//电量优化1.电量优化检测方案： Battery Historian - Google推出的一款Android系统电量分析工具 - 支持50(API21)及以上系统的电量分析 - 功能强大，推荐使用 - 可视化展示指标:耗电比例、执行时间、次数 - 适合线下使用2.电量优化套路总结： 1.网络相关:控制请求时机及次数,数据压缩，减少时间 2.传感器相关: 1.根据场景谨慎选择定位模式 2.考虑网络定位代替GPS 3.使用后务必及时关闭，减少更新频率 一、电量优化介绍及方案选择 正确认识 121.电量重视度不够:开发中一直连接手机2.电量消耗线上难以量化 方案介绍 1234567891011121314151617设置-&gt;耗电排行 - 直观，但没有详细数据，对解决问题没有太多帮助 - 找特定场景专项测试ACTION BATTERY CHANGED - 获取电池电量、充电状态、电池状态等信息 - 示例： IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_BATTERY_CHANGED); Intent intent = registerReceiver(null, filter); LogUtils.i(&quot;battery &quot; + intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)); - 价值不大:针对手机整体的耗电量，而非特定AppBattery Historian（推荐） - Google推出的一款Android系统电量分析工具 - 支持50(API21)及以上系统的电量分析 - 功能强大，推荐使用 - 可视化展示指标:耗电比例、执行时间、次数 - 适合线下使用 测试相关 1231.耗电场景测试:复杂运算、视频播放2.传感器相关: 使用时长、耗电量、发热3.后台静默测试 二、Battery Historian实战及分析 安装 123https://github.com/google/battery-historian安装Dockerdocker -- run -p &lt;port&gt;:9999 gcr.io/android-batterynistorian/stable:3.0 --port 9999 导出电量信息 123adb shell dumpsys batterystats --resetadb shell dumpsys batterystats --enable full-wakehistoryadb bugreport bugreport.zip 上传分析 123http://localhost:9999上传bugreport文件即可备用:https://bathist.ef.lc/(需翻墙) 使用方式：代码过多百度查看，如：https://blog.csdn.net/hpc19950723/article/details/54381246 三、电量辅助监控实战 运行时能耗 12adb pull /system/framework/framework-res.apk//导出apk反编译，xml-》power_profile 运行时获取使用时长 121.Aop辅助统计:次数、时间2.以WakeLock为例 123456789101112131415161718192021222324252627282930313233343536373839package com.optimize.performance.wakelock;import android.annotation.SuppressLint;import android.content.Context;import android.os.PowerManager;public class WakeLockUtils &#123; private static PowerManager.WakeLock sWakeLock; public static void acquire(Context context)&#123; if(sWakeLock == null)&#123; sWakeLock = createWakeLock(context); &#125; if(sWakeLock != null &amp;&amp; !sWakeLock.isHeld())&#123; sWakeLock.acquire(); sWakeLock.acquire(1000); &#125; &#125; public static void release()&#123; // 一些逻辑 try&#123; &#125;catch (Exception e)&#123; &#125;finally &#123; // 为了演示正确的使用方式 if(sWakeLock != null &amp;&amp; sWakeLock.isHeld())&#123; sWakeLock.release(); sWakeLock = null; &#125; &#125; &#125; @SuppressLint(&quot;InvalidWakeLockTag&quot;) private static PowerManager.WakeLock createWakeLock(Context context)&#123; PowerManager pm = (PowerManager) context.getApplicationContext().getSystemService(Context.POWER_SERVICE); if(pm != null)&#123; return pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,&quot;&quot;); &#125; return null; &#125;&#125; 四、电量优化套路总结 CPU时间片 121.获取运行过程线程CPU消耗，定位CPU占有率异常方法2.减少后台应用的主动运行 网络相关 1231.请求时机及次数控制2.数据压缩，减少时间3.禁止使用轮询功能 定位相关 1231.根据场景谨慎选择定位模式2.考虑网络定位代替GPS3.使用后务必及时关闭，减少更新频率 界面相关 121.离开界面后停止相关活动2.耗电操作判断前后台 WakeLock相关 1231.注意成对出现:acquire与release2.使用带参数的acquire3.finally确保一定会被释放 JobScheduler 121.在符合某些条件时创建执行在后台的任务2.把不紧急的任务放到更合适的时机批量处理 五、问题 怎么做电量测试 1231.分场景逐个击破2.Battery Historian3.辅助监控 有哪些有效的电量优化手段 1231.网络相关2.传感器相关3.WakeLock与JobScheduler","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/7.网络优化/","text":"7.网络优化 12345678910111213141516//网络优化1.网络缓存： 1.服务端返回加上过期时间，避免每次重新获取 2.OkHttp、Retfort、Volley都有较好实践 3.无网络时展示数据缓存；2.网络质量： 1.时长、业务成功率、失败率的统计，在OkHttp、Retfort、Volley等自行统计相关数据并在特定场景合并上报； 2.弱网络模拟3.增量更新： 1.加上版本的概念，只传输有变化的数据4.数据压缩: 1.Post请求Body使用GZip压缩(字符压缩) 2.图片上传之前必须压缩5.图片相关： 1.图片使用策略细化:优先缩略图 2.使用WebP格式图片 一、网络优化从哪些纬度开展 正确认识 1234561.网络优化的纬度:多维2.仅仅重视流量不够3.网络流量的消耗量:精确4.整体均值掩盖单点问题5.网络相关监控:全面6.粗粒度监控不能帮助我们发现、解决深层次问题 网络优化纬度 12345678910流量消耗 - 一段时间流量消耗的精准度量，网络类型、前后台 - 监控相关:用户流量消耗均值、异常率( 消耗多、次数多) - 完整链路全部监控(Request、Response)，主动上报网络请求质量 - 用户体验:请求速度、成功率 - 监控相关: 请求时长、业务成功率、失败率、T失败接口其它 - 公司成本:带宽、服务器数、CDN - 耗电 网络优化误区 121.只关注流量消耗，忽视其它纬度2.只关注均值、整体，忽视个体 二、网络优化工具选择 Network Profiler 1231.显示实时网络活动:发送、接收数据及连接数2.需要启用高级分析(androidStudio顶部-run-Edit Configurations...-&gt;勾上（Profiling-Enable advanced profiling (required for API level &lt; 26 only))3.只支持 HttpURLConnection和OkHttp网络库 发送一个请求后在prifoler中出现下图情况，选中请求的时间端后可以查看到请求的状态及大小等信息； 抓包工具 12341.Charles2.Fiddler3.Wireshark4.TcpDump Charles使用 1231.断点功能2.Map Local3.弱网环境模拟 启动软件后发送请求，会自动抓包 Stetho 12强大的应用调试桥，连接Android和Chrome网络监控、视图查看、数据库查看、命令行扩展等 Stetho使用 12341.com.facebook.stetho:stetho-okhttp3:1.5.02.Stetho.initializeWithDefaults(this):3.addNetworkInterceptor4.Chrome浏览器:chrome://inspect(需翻墙) 三、精准获取流量消耗实战 问题思考 1234如何判断App流量消耗偏高 - 绝对值看不出高低 - 对比竞品，相同Case对比流量消耗 - 异常监控超过正常指标(线上) 测试方案 1231.设置-流量管理2.抓包工具:只允许本App联网3.可以解决大多数问题，但是线上场景线下可能遇不到 线上流量获取方案 12345678910TrafficStats:API8以上重启以来的流量数据统计 - TrafficStats:API8以上重启以来的流量数据统计 - getUidRxBytes(int uid)指定Uid的接收流量 - getTotalTxBytes0)总发送流量 缺点： - 无法获取某个时间段内的流量消耗NetworkStatsManager:API23之后流量统计（推荐） - 可获取指定时间间隔内的流量信息 - 可获取不同网络类型下的消耗 - 使用示例查看百度 前后台流量获取方案 1231.难题:线上反馈App后台跑流量2.只获取一个时间段的值不够全面后台定时任务-&gt;获取间隔内流量-&gt;记录前后台-&gt;分别计算-&gt;上报APM后台-&gt;流量治理依据 前后台流量获取方案总结 121.有一定误差，可接受范围内2.结合精细化的流量异常报警针对性的解决后台跑流量 四、网络请求流量优化实战 使用网络的场景概述 123数据:Api、资源包(升级包、H5、RN)、配置信息图片:下载、上传监控:APM相关、单点问题相关 数据缓存 1231.服务端返回加上过期时间，避免每次重新获取2.节约流量且大幅提高数据访问速度，更好的用户体验3.OkHttp、Volley都有较好实践 无网络时使用缓存数据示例，不同框架不一样，只做参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.optimize.performance.net;import com.optimize.performance.PerformanceApp;import com.optimize.performance.utils.Utils;import java.io.IOException;import okhttp3.CacheControl;import okhttp3.Interceptor;import okhttp3.Request;import okhttp3.Response;public class NoNetInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder builder = request.newBuilder(); if(!Utils.isNetworkConnected(PerformanceApp.getApplication()))&#123; builder.cacheControl(CacheControl.FORCE_CACHE); &#125; return chain.proceed(builder.build()); &#125;&#125;package com.optimize.performance.net;import com.optimize.performance.PerformanceApp;import okhttp3.Cache;import okhttp3.OkHttpClient;import okhttp3.logging.HttpLoggingInterceptor;import retrofit2.Retrofit;import retrofit2.converter.fastjson.FastJsonConverterFactory;public class RetrofitNewsUtils &#123; private static final APIService API_SERVICE; public static APIService getApiService() &#123; return API_SERVICE; &#125; public static final String HTTP_SPORTSNBA_QQ_COM = &quot;http://sportsnba.qq.com/&quot;; static &#123; OkHttpClient.Builder client = new OkHttpClient.Builder(); HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BODY); Cache cache = new Cache(PerformanceApp.getApplication().getCacheDir(),10*1024*1024); client. eventListenerFactory(OkHttpEventListener.FACTORY). dns(OkHttpDNS.getIns(PerformanceApp.getApplication())). addInterceptor(new NoNetInterceptor()). addInterceptor(logging); final Retrofit RETROFIT = new Retrofit.Builder() .baseUrl(HTTP_SPORTSNBA_QQ_COM) .addConverterFactory(FastJsonConverterFactory.create()) .client(client.build()) .build(); API_SERVICE = RETROFIT.create(APIService.class); &#125;&#125; 增量数据更新 121.加上版本的概念，只传输有变化的数据2.配置信息、省市区县等更新 数据压缩 1231.Post请求Body使用GZip压缩2.请求头压缩3.图片上传之前必须压缩 优化发送频率和时机 121.合并网络请求、减少请求次数2.性能日志上报:批量+特定场景上报 图片相关 121.图片使用策略细化:优先缩略图2.使用WebP格式图片 总结 12数据缓存、增量更新、压缩、图片相关等需要结合实际情况进行选择 五、网络请求质量优化实战 质量指标 121.网络请求成功率2.网络请求速度 Http请求过程 1231.请求到达运营商的Dns服务器并解析成对应的IP地址2.创建连接，根据IP地址找到相应的服务器，发起一个请求3.服务器找到对应的资源原路返回访问的用户 DNS相关 123问题:DNS被劫持、DNS解析慢方案:使用HttpDNS，绕过运营商域名解析过程优势:降低平均访问时长、提高连接成功率 123456789101112131415161718192021222324252627282930313233343536373839//示例：package com.optimize.performance.net;import android.content.Context;import com.alibaba.sdk.android.httpdns.HttpDns;import com.alibaba.sdk.android.httpdns.HttpDnsService;import java.net.InetAddress;import java.net.UnknownHostException;import java.util.Arrays;import java.util.List;import okhttp3.Dns;public class OkHttpDNS implements Dns &#123; private HttpDnsService dnsService; private static OkHttpDNS instance = null; private OkHttpDNS(Context context) &#123; dnsService = HttpDns.getService(context, &quot;&quot;); &#125; public static OkHttpDNS getIns(Context context) &#123; if (instance == null) &#123; synchronized (OkHttpDNS.class) &#123; if (instance == null) &#123; instance = new OkHttpDNS(context); &#125; &#125; &#125; return instance; &#125; @Override public List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException &#123; String ip = dnsService.getIpByHostAsync(hostname); if(ip != null)&#123; List&lt;InetAddress&gt; inetAddresses = Arrays.asList(InetAddress.getAllByName(ip)); return inetAddresses; &#125; return Dns.SYSTEM.lookup(hostname); &#125;&#125; 协议版本升级 123- 1.0:版本TCP连接不复用- 1.1:引入持久连接，但数据通讯按次序进行- 2:多工，客户端、服务器双向实时通信 网络请求质量监控 12接口请求耗时、成功率、错误码图片加载的每一步耗时 网络容灾机制 12备用服务器分流多次失败后一定时间内不进行请求，避免雪崩效应 其它 12CDN加速、提高带宽、动静资源分离(更新后清理缓存)减少传输量，注意请求时机及频率 总结 12网络请求质量指标提升网络请求质量的方式 六、网络体系化方案建设 线下测试 12方案:只抓单独App侧重点:请求有误、多余，网络切换、弱网、无网测试 线上监控 123456789101112服务端监控 - 请求耗时(区分地域、时间段、版本、机型 - 失败率(业务失败与请求失败) - Top失败接口、异常接口客户端监控 - 接口的每一步详细信息(DNS、连接、请求等) - 请求次数、网络包大小、失败原因 - 图片监控异常监控体系 - 服务器防刷:超限拒绝访问 - 客户端:大文件预警、异常兜底策略 - 单点问题追查 七、问题 123456789101112在网络方面你们做了哪些监控，建立了哪些指标 - 演进过程、优化背景 - 质量:请求成功率、每步耗时、状态码 - 流量:精确统计、前后台如何有效的降低用户流量消耗 - 数据:缓存、增量更新 - 上传:压缩 - 图片:缩略图、webp用户反馈消耗流量多这种问题怎么查 - 精准流量获取能力 - 所有请求大小及次数的监控 - 主动预警能力","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/6.线程优化/","text":"6.线程优化 一、线程调度原理分析 线程调度原理 1231.任意时刻，只有一个线程占用CPU，处于运行状态2.多线程并发:轮流获取CPU使用权3.JVM负责线程调度:按照特定机制分配CPU使用权 线程调度模型 121.分时调度模型:轮流获取、均分CPU时间2.抢占式调度模型:优先级高的获取，JVM采用 Android线程调度 12345671.nice值 - Process中定义 - 值越小，优先级越高 - 默认是THREAD_PRIORITY_DEFAULT，02.cgroup - 更严格的群组调度策略(前台/后台) - 保证前台线程可以获取到更多的CPU 注意点 1231.线程过多会导致CPU频繁切换，降低线程运行效率2.正确认识任务重要性决定哪种优先级(工作量越低，优先级应该越低)3.优先级具有继承性（A线程中启动线程B，则B基础A的优先级） 二、android异步方式汇总 Thread 123最简单、常见的异步方式 - 不易复用，频繁创建及销毁开销大 - 复杂场景不易使用 HandlerThread 123自带消息循环的线程 - 串行执行 - 长时间运行，不断从队列中获取任务 IntentService 123继承自Service在内部创建HandlerThread - 异步，不占用主线程 - 优先级较高，不易被系统Kill AsyncTask 123Android提供的工具类 - 无需自己处理线程切换 - 需注意版本不一致问题(14以下存在，目前几乎不用管) 线程池 123Java提供的线程池 - 易复用，减少频繁创建、销毁的时间 - 功能强大:定时、任务队列、并发数控制等 RxJava 12由强大的 Scheduler 集合提供 - 不同类型的区分 :IO、Computation 异步方式总结 12推荐度:从前往后排列正确场景选择正确的方式 三、线程优化实战 线程使用准则 12345678910111213141.严禁直接 new Thread2.提供基础线程池供各个业务线使用 - 避免各个业务线各自维护一套线程池，导致线程数过多3.根据任务类型选择合适的异步方式 - 优先级低，长时间执行，HandlerThread4.创建线程必须命名 - 方便定位线程归属 - 运行期Thread.currentThread0.setName修改名字5.关键异步任务监控 - 异步不等于不耗时 - 可通过AOP的方式来做监控6.重视优先级设置 - Process.setThreadPriority(); - 可以设置多次; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ThreadPoolUtils工具类package com.optimize.performance.async;import android.os.Process;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class ThreadPoolUtils &#123; private int CPUCOUNT = Runtime.getRuntime().availableProcessors(); private ThreadPoolExecutor cpuExecutor = new ThreadPoolExecutor(CPUCOUNT, CPUCOUNT, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(), sThreadFactory); private ThreadPoolExecutor iOExecutor = new ThreadPoolExecutor(64, 64, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(), sThreadFactory); private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;ThreadPoolUtils #&quot; + mCount.getAndIncrement()); &#125; &#125;; public static ExecutorService getService() &#123; return sService; &#125; private static ExecutorService sService = Executors.newFixedThreadPool(5, new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, &quot;ThreadPoolUtils&quot;); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); return thread; &#125; &#125;);&#125; 1234567891011//使用示例 ThreadPoolUtils.getService().execute(new Runnable() &#123; @Override public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(&quot;new Name&quot;); LogUtils.i(&quot;&quot;); Thread.currentThread().setName(oldName); &#125; &#125;); 四、如何锁定线程创建者 锁定线程创建背景 1231.项目变大之后收敛线程2.项目源码、三方库、aar中都有线程的创建3.避免恶化的一种监控预防手段 锁定线程创建方案 1234561.分析 - 创建线程的位置获取堆栈 - 所有的异步方式，都会走到new Thread2.特别适合Hook手段3.找Hook点:构造函数或者特定方法4.Thread的构造函数 12345678DexposedBridge.hookAllConstructors(Thread.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Thread thread = (Thread) param.thisObject; LogUtils.i(thread.getName()+&quot; stack &quot;+Log.getStackTraceString(new Throwable())); &#125; &#125;); 五、线程收敛优雅实现 线程收敛常规方案 121.根据线程创建堆栈考量合理性，使用统一线程库2.各业务线下掉自己的线程库 基础库怎么使用线程 121.直接依赖线程库2.缺点:线程库更新可能会导致基础库更新 基础库优雅使用线程 121.基础库内部暴露API:setExecutor2.初始化的时候注入统一的线程库 12345678910111213141516171819202122package com.optimize.performance.utils;import android.util.Log;import com.optimize.performance.PerformanceApp;import java.util.concurrent.ExecutorService;public class LogUtils &#123; private static ExecutorService sExecutorService; public static void setExecutor(ExecutorService executorService)&#123; sExecutorService = executorService; &#125; public static final String TAG = &quot;performance&quot;; public static void i(String msg)&#123; if(Utils.isMainProcess(PerformanceApp.getApplication()))&#123; Log.i(TAG,msg); &#125; // 异步 if(sExecutorService != null)&#123;// sExecutorService.execute(); &#125; &#125;&#125; 统一线程库 1231.区分任务类型:IO、CPU密集型2.IO密集型任务不消耗CPU，核心池可以很大3.CPU密集型任务:核心池大小和CPU核心数相关 1234567891011121314151617181920212223242526272829303132333435363738394041package com.optimize.performance.async;import android.os.Process;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class ThreadPoolUtils &#123; private int CPUCOUNT = Runtime.getRuntime().availableProcessors(); private ThreadPoolExecutor cpuExecutor = new ThreadPoolExecutor(CPUCOUNT, CPUCOUNT, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(), sThreadFactory); private ThreadPoolExecutor iOExecutor = new ThreadPoolExecutor(64, 64, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(), sThreadFactory); private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;ThreadPoolUtils #&quot; + mCount.getAndIncrement()); &#125; &#125;; public static ExecutorService getService() &#123; return sService; &#125; private static ExecutorService sService = Executors.newFixedThreadPool(5, new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r, &quot;ThreadPoolUtils&quot;); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); return thread; &#125; &#125;);&#125; 六、问题 线程使用为什么会遇到问题 121.项目发展阶段2.问题原因及表现形式 怎么在项目中对线程进行优化 1231.线程收敛2.统一线程池:任务区分3.其他细节","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/5.卡顿优化&ANR/","text":"5.卡顿优化 1234//卡顿优化1.硬件性能导致卡顿：CPU Profiler/Systrace 分析查看CPU利用率2.使用blockcanary可以实现自动化监测卡顿3.anr检测：ANR-WatchDog，logcat/trace.txt日志分析信息 一、卡顿介绍及工具选择 背景介绍 121.很多性能问题不易被发现，但是卡顿很容易被直观感受2.卡顿问题难以定位 CPU Profiler 12345671.图形的形式展示执行时间、调用栈等2.信息全面，包含所有线程3.运行时开销严重，整体都会变慢4.使用方式 - Debug.startMethodTracing(&quot;); - Debug.stopMethodTracing(); - 生成文件在sd卡:Android/data/packagename/files Systrace 1234567891.监控和跟踪Api调用、线程运行情况，生成Html报告2.API18以上使用，推荐TraceCompat3.使用方式 python systrace.py -t 10 [other-options] [categories] 文档：https://developer.android.com/studio/command-line/systrace#command options4.优点 1.轻量级，开销小 2.直观反映CPU利用率 3.给出建议 StrictMode 12345678910111.严苛模式，Android提供的一种运行时检测机制2.方便强大，容易被忽视3.包含: 线程策略和虚拟机策略检测4.线程策略 自定义的耗时调用，detectCustomSlowCalls() 磁盘读取操作，detectDiskReads 网络操作，detectNetwork5.虚拟机策略 Activity泄露，detectActivityLeaks() Sqlite对象泄露，detectLeakedSqlLiteObjects 检测实例数量，setClassInstanceLimit() 123456789101112131415161718//使用示例：private void initStrictMode() &#123; if (DEV_MODE) &#123; StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectCustomSlowCalls() //API等级11，使用StrictMode.noteSlowCode .detectDiskReads() .detectDiskWrites() .detectNetwork()// or .detectAll() for all detectable problems .penaltyLog() //在Logcat 中打印违规异常信息 .build()); StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectLeakedSqlLiteObjects() .setClassInstanceLimit(NewsItem.class, 1) .detectLeakedClosableObjects() //API等级11 .penaltyLog() .build()); &#125;&#125; 运行后的开始自动检测结果如下： 二、自动化卡顿检测方案及优化 为什么需要自动化检测方案 121.系统工具适合线下针对性分析2.线上及测试环节需要自动化检测方案 方案原理 1231.消息处理机制，一个线程只有一个Looper2.mLogging对象在每个message处理前后被调用3.主线程发生卡顿，是在dispatchMessage执行耗时操作 具体实现 1231.Looper.getMainLooper().setMessageLogging();2.匹配&gt;&gt;&gt;&gt;&gt;Dispatching,闽值时间后执行任务(获取堆栈)3.匹配&lt;&lt;&lt;&lt;&lt;Finished,任务启动之前取消掉 AndroidPerformanceMonitor 12345678910111213141516171819非侵入式的性能监控组件，通知形式弹出卡顿信息 - com.github.markzhai:blockcanary-android - https://github.com/markzhai/AndroidPerformanceMonitor使用：implementation &#x27;com.github.markzhai:blockcanary-android:1.5.0&#x27;//application中执行初始化BlockCanary.install(this, new AppBlockCanaryContext()).start();//mainActivity演示Msg导致的主线程卡顿 new Handler().post(new Runnable() &#123; @Override public void run() &#123; LogUtils.i(&quot;Msg 执行&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//自定义类package com.optimize.performance.block;import android.content.Context;import android.util.Log;import com.github.moduth.blockcanary.BlockCanaryContext;import com.github.moduth.blockcanary.internal.BlockInfo;import java.io.File;import java.util.LinkedList;import java.util.List;/** * BlockCanary配置的各种信息 */public class AppBlockCanaryContext extends BlockCanaryContext &#123; /** * Implement in your project. * * @return Qualifier which can specify this installation, like version + flavor. */ public String provideQualifier() &#123; return &quot;unknown&quot;; &#125; /** * Implement in your project. * * @return user id */ public String provideUid() &#123; return &quot;uid&quot;; &#125; /** * Network type * * @return &#123;@link String&#125; like 2G, 3G, 4G, wifi, etc. */ public String provideNetworkType() &#123; return &quot;unknown&quot;; &#125; /** * Config monitor duration, after this time BlockCanary will stop, use * with &#123;@code BlockCanary&#125;&#x27;s isMonitorDurationEnd * * @return monitor last duration (in hour) */ public int provideMonitorDuration() &#123; return -1; &#125; /** * Config block threshold (in millis), dispatch over this duration is regarded as a BLOCK. You may set it * from performance of device. * * @return threshold in mills */ public int provideBlockThreshold() &#123; return 500; &#125; /** * Thread stack dump interval, use when block happens, BlockCanary will dump on main thread * stack according to current sample cycle. * &lt;p&gt; * Because the implementation mechanism of Looper, real dump interval would be longer than * the period specified here (especially when cpu is busier). * &lt;/p&gt; * * @return dump interval (in millis) */ public int provideDumpInterval() &#123; return provideBlockThreshold(); &#125; /** * Path to save log, like &quot;/blockcanary/&quot;, will save to sdcard if can. * * @return path of log files */ public String providePath() &#123; return &quot;/blockcanary/&quot;; &#125; /** * If need notification to notice block. * * @return true if need, else if not need. */ public boolean displayNotification() &#123; return true; &#125; /** * Implement in your project, bundle files into a zip file. * * @param src files before compress * @param dest files compressed * @return true if compression is successful */ public boolean zip(File[] src, File dest) &#123; return false; &#125; /** * Implement in your project, bundled log files. * * @param zippedFile zipped file */ public void upload(File zippedFile) &#123; throw new UnsupportedOperationException(); &#125; /** * Packages that developer concern, by default it uses process name, * put high priority one in pre-order. * * @return null if simply concern only package with process name. */ public List&lt;String&gt; concernPackages() &#123; return null; &#125; /** * Filter stack without any in concern package, used with @&#123;code concernPackages&#125;. * * @return true if filter, false it not. */ public boolean filterNonConcernStack() &#123; return false; &#125; /** * Provide white list, entry in white list will not be shown in ui list. * * @return return null if you don&#x27;t need white-list filter. */ public List&lt;String&gt; provideWhiteList() &#123; LinkedList&lt;String&gt; whiteList = new LinkedList&lt;&gt;(); whiteList.add(&quot;org.chromium&quot;); return whiteList; &#125; /** * Whether to delete files whose stack is in white list, used with white-list. * * @return true if delete, false it not. */ public boolean deleteFilesInWhiteList() &#123; return true; &#125; /** * Block interceptor, developer may provide their own actions. */ public void onBlock(Context context, BlockInfo blockInfo) &#123; Log.i(&quot;lz&quot;,&quot;blockInfo &quot;+blockInfo.toString()); &#125;&#125; 代码运行后点击顶部通知栏出现下图： 方案总结 123451.非侵入式2.方便精准，定位到代码某一行缺点：1.确实卡顿了，但卡顿堆栈可能不准确2.和OOM一样，最后的堆栈只是表象，不是真正问题 自动检测方案优化 12获取监控周期内的多个堆栈，而不仅是最后一个startMonitor-&gt;高频采集堆栈-&gt;endMonitor-&gt;记录多个堆栈-&gt;上报 海量卡顿堆栈处理 1234高频卡顿上报量太大，服务端有压力分析:一个卡顿下多个堆栈大概率有重复解决:对一个卡顿下堆栈进行hash排重，找出重复的堆栈效果:极大的减少展示量同时更高效找到卡顿堆栈 三、ANR分析与实战 ANR介绍 123KeyDispatchTimeout，5sBroadcastTimeout，前台10s，后台60sServiceTimeout，前台20s，后台200s ANR执行流程 123发生ANR进程接收异常终止信号，开始写入进程ANR信息弹出ANR提示框(Rom表现不一,有的手机可能不弹) ANR解决套路 12adb pull data/anr/traces.txt 存储路径(发送anr系统会保存自动保存信息到该文件)详细分析:CPU、IO、锁 模拟anr触发 12345678910111213141516171819 @Override protected void onCreate(Bundle savedInstanceState) &#123; ... new Thread()&#123; @Override public void run() &#123; super.run(); synchronized (MainActivity.this)&#123; try &#123; Thread.sleep( millis: 20000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;.start(); ... synchronized (MainActivity.this)&#123; LogUtils.i( msg:&quot;); &#125; ...&#125; 发送anr(弹框弹出来的时间不止5m钟，因为系统会先将anr信息写入文件后再弹窗) 执行adb pull data&#x2F;anr&#x2F;traces.txt后分析日志 线上ANR监控方案 1通过FileOberver监控文件变化，高版本权限问题(高版本上权限问题导致无法监控到文件变化) ANR-WatchDog 1234567891011非侵入式的ANR监控组件 - com.github.anrwatchdog:anrwatchdog:1.3.0 - https://github.com/SalomonBrys/ANRWatchDog使用： new ANRWatchDog().start();（Application中）ANR-WatchDog原理： start-&gt;post消息改值-&gt;sleep-&gt;检测是否修改-&gt;判断ANR发生-&gt;抛出异常（线下调试方便，自动定位到异常代码位置） //可以复写他的异常处理代码，改为上传到自己服务器上而不跑出异常优点： - 非侵入式 - 弥补高版本无权限问题 区别 1231.AndroidPerformanceMonitor:监控Msg2.ANR-WatchDog :看最终结果3.前者适合监控卡顿，后者适合补充ANR监控 四、卡顿单点问题检测方案 背景介绍 1231.自动卡顿监测方案并不够（有卡顿但是不到阈值）2.体系化解决方案务必尽早暴露问题3.单点问题:主线程IPC、DB IPC问题监测 123456789101112131415161718监测指标 - IPC调用类型 - 调用耗时、次数 - 调用堆栈、发生线程常规方案 - IPC前后加埋点 - 不优雅、容易忘记 - 维护成本大IPC问题监测技巧 - adb 命令 - adb shell am trace-ipc start - adb shell am trace-ipc stop -dump-file/data/local/tmp/ipc-trace.txt - adb pull /data/local/tmp/ipc-trace.txtIPC问题监测 - 优雅方案 - ARTHook 还是AspectJ ? - ARTHook:可以Hook系统方法 - AspectJ:非系统方法 1234567891011121314示例：try &#123; DexposedBridge.findAndHookMethod(Class.forName(&quot;android.os.BinderProxy&quot;), &quot;transact&quot;, int.class, Parcel.class, Parcel.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; LogUtils.i( &quot;BinderProxy beforeHookedMethod &quot; + param.thisObject.getClass().getSimpleName() + &quot;\\n&quot; + Log.getStackTraceString(new Throwable())); super.beforeHookedMethod(param); &#125; &#125;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 卡顿问题监测方案 121.利用ARTHook完善线下工具2.开发阶段Hook相关操作，暴露、分析问题 监控纬度 1231.IPC2.IO、DB3.View绘制 五、如何实现界面秒开 界面秒开实现 1231.SysTrace，优雅异步+优雅延迟初始化2.异步Inflate、X2C、绘制优化3.提前获取页面数据 界面秒开率统计 121.onCreate到onWindowFocusChanged2.特定接口 Lancet 1234567轻量级Android AOP框架 - 编译速度快，支持增量编译 - API简单，没有任何多余代码插入 apk - https://github.com/eleme/lancet使用介绍 - @Proxyi通常用与对系统API调用的Hook - @Insert 常用于操作App与library的类 使用示例： 123implementation &#x27;me.ele:lancet-base:1.0.4&#x27;//相当于hook acitivity的生命周期实现展开时间的计算//也可自定义hook其他系统方法，如log.i实现自定义消息拼接或处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.optimize.performance.aop;import android.content.Context;import android.os.Bundle;import android.os.Handler;import android.util.Log;import com.optimize.performance.utils.LogUtils;import com.optimize.performance.wakelock.WakeLockUtils;import me.ele.lancet.base.Origin;import me.ele.lancet.base.Scope;import me.ele.lancet.base.annotations.Insert;import me.ele.lancet.base.annotations.Proxy;import me.ele.lancet.base.annotations.TargetClass;public class ActivityHooker &#123; public static ActivityRecord sActivityRecord; static &#123; sActivityRecord = new ActivityRecord(); &#125; public static String trace; @Insert(value = &quot;onCreate&quot;,mayCreateSuper = true) @TargetClass(value = &quot;android.support.v7.app.AppCompatActivity&quot;,scope = Scope.ALL) protected void onCreate(Bundle savedInstanceState) &#123; sActivityRecord.mOnCreateTime = System.currentTimeMillis(); Origin.callVoid(); &#125; @Insert(value = &quot;onWindowFocusChanged&quot;,mayCreateSuper = true) @TargetClass(value = &quot;android.support.v7.app.AppCompatActivity&quot;,scope = Scope.ALL) public void onWindowFocusChanged(boolean hasFocus) &#123; sActivityRecord.mOnWindowsFocusChangedTime = System.currentTimeMillis(); LogUtils.i(&quot;onWindowFocusChanged cost &quot;+(sActivityRecord.mOnWindowsFocusChangedTime - sActivityRecord.mOnCreateTime)); Origin.callVoid(); &#125; public static long sStartTime = 0; @Insert(value = &quot;acquire&quot;) @TargetClass(value = &quot;com.optimize.performance.wakelock.WakeLockUtils&quot;,scope = Scope.SELF) public static void acquire(Context context)&#123; trace = Log.getStackTraceString(new Throwable()); sStartTime = System.currentTimeMillis(); Origin.callVoid(); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; WakeLockUtils.release(); &#125; &#125;,1000); &#125; @Insert(value = &quot;release&quot;) @TargetClass(value = &quot;com.optimize.performance.wakelock.WakeLockUtils&quot;,scope = Scope.SELF) public static void release()&#123; LogUtils.i(&quot;PowerManager &quot;+(System.currentTimeMillis() - sStartTime)+&quot;/n&quot;+trace); Origin.callVoid(); &#125; public static long runTime = 0; @Insert(value = &quot;run&quot;) @TargetClass(value = &quot;java.lang.Runnable&quot;,scope = Scope.ALL) public void run()&#123; runTime = System.currentTimeMillis(); Origin.callVoid(); LogUtils.i(&quot;runTime &quot;+(System.currentTimeMillis() - runTime)); &#125; @Proxy(&quot;i&quot;) @TargetClass(&quot;android.util.Log&quot;) public static int i(String tag, String msg) &#123; msg = msg + &quot;&quot;; return (int) Origin.call(); &#125;&#125;package com.optimize.performance.aop;public class ActivityRecord &#123; public long mOnCreateTime; public long mOnWindowsFocusChangedTime;&#125; 界面秒开监控纬度 1231.总体耗时2.生命周期耗时3.生命周期间隔耗时 六、优雅监控耗时盲区 耗时盲区监控背景 1231.生命周期的间隔2.onResume到Feed展示的间隔3.举例 : postMessage，很可能在Feed之前执行(handler的消息中存在耗时操作) 耗时盲区监控难点 121.只知道盲区时间，不清楚具体在做什么2.线上盲区无从追查 耗时盲区监控线下方案 123TraceView - 特别适合一段时间内的盲区监控 - 线程具体时间做了什么，一目了然 耗时盲区监控线上方案 1234思考分析 - 所有方法都是Msg，mLogging ?没有Msg具体堆栈 - AOP切Handler方法?不清楚准确执行时间 //上面2种方式都有各自的问题 耗时盲区监控线上方案 121.使用统一的Handler:定制具体方法2.定制gradle插件，编译期动态替换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.optimize.performance.handler;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.util.Log;import com.optimize.performance.utils.LogUtils;import org.json.JSONObject;public class SuperHandler extends Handler &#123; private long mStartTime = System.currentTimeMillis(); public SuperHandler() &#123; super(Looper.myLooper(), null); &#125; public SuperHandler(Callback callback) &#123; super(Looper.myLooper(), callback); &#125; public SuperHandler(Looper looper, Callback callback) &#123; super(looper, callback); &#125; public SuperHandler(Looper looper) &#123; super(looper); &#125; @Override public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; boolean send = super.sendMessageAtTime(msg, uptimeMillis); if (send) &#123; GetDetailHandlerHelper.getMsgDetail().put(msg, Log.getStackTraceString(new Throwable()).replace(&quot;java.lang.Throwable&quot;, &quot;&quot;)); &#125; return send; &#125; @Override public void dispatchMessage(Message msg) &#123; mStartTime = System.currentTimeMillis(); super.dispatchMessage(msg); if (GetDetailHandlerHelper.getMsgDetail().containsKey(msg) &amp;&amp; Looper.myLooper() == Looper.getMainLooper()) &#123; JSONObject jsonObject = new JSONObject(); try &#123; jsonObject.put(&quot;Msg_Cost&quot;, System.currentTimeMillis() - mStartTime); jsonObject.put(&quot;MsgTrace&quot;, msg.getTarget() + &quot; &quot; + GetDetailHandlerHelper.getMsgDetail().get(msg)); LogUtils.i(&quot;MsgDetail &quot; + jsonObject.toString()); GetDetailHandlerHelper.getMsgDetail().remove(msg); &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; &#x2F;&#x2F;视频中使用的普通handler发送消息后拿到的log日志 耗时盲区监控方案总结 1231.卡顿监控重要的一环，全面性保障2.TraceView适合线下，可以监控系统Msg3.动态替换适合线上，只有应用自身的Msg 七、卡顿优化技巧总结 卡顿优化实践经验 123耗时操作:异步、延迟布局优化:异步Inflate、X2C、重绘解决内存:降低内存占用，减少GC时间 卡顿优化工具建设 1234567891011121314系统工具认识、使用 - SysTrace - TraceView - StrictMode自动化监控及优化 - AndroidPerformanceMonitor、ANR-WatchDog - 高频采集，找出重复率高的堆栈卡顿监控工具 - 单点问题:AOP、Hook - 盲区监控: gradle编译期替换卡顿监控指标 - 卡顿率、ANR率、界面秒开率 - 交互时间、生命周期时间 - 上报环境、场景信息 八、问题 12345678910111.你是怎么做卡顿优化的 - 第一阶段:系统工具定位、解决 - 第二阶段:自动化卡顿方案及优化 - 第三阶段:线上监控及线下监测工具建设2.怎么自动化的获取卡顿信息 - mLogging.println - 高频采集，找出重复堆栈3.卡顿的一整套解决方案是怎么做的 - 线下、线上工具相结合 - 特定难题突破:单点问题、盲区监控 - 线上监控建设","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/4.布局优化/","text":"4.布局优化 1234567891011121314151617181920//布局优化1. 绘制时长检测： 1.AOP（面向切面编程,在指定的地方执行特定的代码）的方式获取每个界面的绘制耗时; 1.Systrace查看整体绘制情况，查看是否存在绘制耗时等情况； 2.as自带的布局检测工具Inspector，查看视图层次结构；2.如存在io加载布局文件慢 1.使用AsyncLayoutInflater/X2C异步加载布局3. 布局层级:减少布局层级，减少过度绘制 1.减少View树层级 2.宽而浅，避免窄而深 3.尽量使用 ConstraintLayout布局控件 2.gpu过度绘制//开发者选项-调试gpu过度绘制打开设置 1.一个像素最好只被绘制一次 2.调试GPU过度绘制 3.蓝色可接受 3. 卡顿的原因就是CPU数据处理不过来，比如层级过深，CPU太忙，GC，之类的，可以通过systrace 工具进行检测， 然后通过编舞者监测帧率定位时间，再然后可以通过looper的日志功能定位到卡顿点。网上也有库blockcanary 3.在Systrace 报告中，你可以查看应用程序布局绘制的相关事件，包括布局计算、绘制命令的发送、GPU 图形呈现等阶段所花费的时间 一、绘制原理及工具选择 绘制原理 12341.CPU负责计算显示内容2.GPU负责栅格化(UI元素绘制到屏幕上)3.16ms发出VSync信号触发UI渲染4.大多数的Android设备屏幕刷新频率:60Hz 优化工具 1234Systrace - 关注Frames - 正常:绿色圆点，丢 :黄色或红色 - Alerts栏 Layout Inspector 1231.AndroidStudio自带工具2.查看视图层次结构androidStudio顶部tools-Layout Inspector-选择对应进程-生成当前界面的检测信息 Choreographer 12345678910111213141516171819202122232425262728获取FPS，线上使用，具备实时性 - Api 16之后 - Choreographer.getInstance().postFrameCallback使用示例：@TargetApi(Build.VERSION_CODES.JELLY_BEAN) private void getFPS() &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; return; &#125; Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() &#123; @Override public void doFrame(long frameTimeNanos) &#123; if (mStartFrameTime == 0) &#123; mStartFrameTime = frameTimeNanos; &#125; long interval = frameTimeNanos - mStartFrameTime; if (interval &gt; MONITOR_INTERVAL_NANOS) &#123; double fps = (((double) (mFrameCount * 1000L * 1000L)) / interval) * MAX_INTERVAL; mFrameCount = 0; mStartFrameTime = 0; &#125; else &#123; ++mFrameCount; &#125; Choreographer.getInstance().postFrameCallback(this); &#125; &#125;); &#125; 获取fps的日志打印 二、布局加载原理 性能瓶颈 12布局文件解析:IO过程创建View对象:反射 LayoutInflater.Factory 12LayoutInflater创建View的一个Hook定制创建View的过程:全局替换自定义TextView等 Factory与Factory2 12Factory2继承于Factory多了一个参数:parent 三、优雅获取界面布局耗时 常规方式 12背景:获取每个界面加载耗时实现:覆写方法、手动埋点 AOP实现 12切Activity的setContentView@Around(&quot;execution(*android.app.Activity.setContentView(..))&quot;) 12345678910111213141516171819202122package com.optimize.performance.aop;import com.optimize.performance.utils.LogUtils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect; @Aspectpublic class PerformanceAop &#123; @Around(&quot;execution(* android.app.Activity.setContentView(..))&quot;) public void getSetContentViewTime(ProceedingJoinPoint joinPoint) &#123; Signature signature = joinPoint.getSignature(); String name = signature.toShortString(); long time = System.currentTimeMillis(); try &#123; joinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; LogUtils.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time)); &#125; &#125; 随意点击2个页面后查看日志： ARTHook实现：切Activity的setContentView 获取每一个控件加载耗时 121.低侵入性2.LayoutInflater.Factory 1234567891011121314151617181920212223@Override protected void onCreate(Bundle savedInstanceState) &#123; LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() &#123; @Override public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; if (TextUtils.equals(name, &quot;TextView&quot;)) &#123; // 生成自定义TextView &#125; long time = System.currentTimeMillis(); View view = getDelegate().createView(parent, name, context, attrs); LogUtils.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time)); return view; &#125; @Override public View onCreateView(String name, Context context, AttributeSet attrs) &#123; return null; &#125; &#125;); ...//需要在下面2句代码之前执行否则无效 setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); ... &#125; 四、异步Inflate实战 背景介绍 121.布局文件读取慢:IO过程2.创建View慢:反射(比new慢3倍) AsyncLayoutInflater 1234简称异步Inflate - WorkThread加载布局 - 回调主线程 - 节约主线程时间 AsyncLayoutInflater使用(相当于侧面解决方案，从子线程加载xml资源文件) 123456789101112131415161718com.android.support:asynclayoutinflater @Override protected void onCreate(Bundle savedInstanceState) &#123; new AsyncLayoutInflater(MainActivity.this).inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() &#123; @Override public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) &#123; setContentView(view); mRecyclerView = findViewById(R.id.recycler_view); mRecyclerView.setLayoutManager(new LinearLayoutManager(MainActivity.this)); mRecyclerView.setAdapter(mNewsAdapter); mNewsAdapter.setOnFeedShowCallBack(MainActivity.this); &#125; &#125;); setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); ... &#125; AsyncLayoutInflater缺点 121.不能设置LayoutInflater.Factory (自定义解决2.注意View中不能有依主线程的操作 Java代码写布局 121.本质上解决了性能问题2.引入新问题:不便于开发、可维护性差 X2C介绍 123保留XML优点，解决其性能问题 - 开发人员写XML，加载Java代码 - 原理:APT编译期翻译XML为Java代码(相当于自动将xml布局转为java代码后再加载) X2C使用 123456789101112131.AnnotationProcessor &#x27;com.zhangyue.we:x2c-apt:1.1.2&#x27;(appMoudle的build.gradle中添加)2.implementation &#x27;com.zhangyue.we:x2c-lib:1.0.6&#x27;3.@Xml(layouts = &quot;activity_main&quot;) (类名上面，如： @Xml(layouts = &quot;activity_main&quot;) public class MainActivity extends AppCompatActivity)&#123; setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main); X2C.setContentView(MainActivity.this, R.layout.activity_main); &#125; ) //build中可以看到出现了2个MainActivity，一个是x2c将xml转为java代码的类 X2C问题 121.部分属性Java不支持2.失去了系统的兼容(AppCompat) 五、视图绘制优化 视图绘制流程 123测量:确定大小（自顶向下遍历确定每个布局的大小）布局:确定位置（根据测量大小确定控件位置）绘制:绘制视图 性能瓶颈 1231.每个阶段耗时2.自顶而下的遍历3.触发多次 布局层级及复杂度 123准则 1.减少View树层级 2.宽而浅，避免窄而深 ConstraintLayout 1231.实现几乎完全扁平化布局2.构建复杂布局性能更高3.具有RelativeLayout和LinearLayout特性 布局层级及复杂度 1231.不嵌套使用RelativeLayout2.不在嵌套LinearLayout中使用weight3.merge标签:减少一个层级，只能用于根View 过度绘制 1234//过度绘制-开发者选项-调试gpu过度绘制打开设置1.一个像素最好只被绘制一次2.调试GPU过度绘制3.蓝色可接受 避免过度绘制方法 1231.去掉多余背景色，减少复杂shape使用2.避免层级叠加3.自定义View使用clipRect屏蔽被遮盖View绘制 其它技巧 1231.Viewstub:高效占位符、延迟初始化2.onDraw中避免:创建大对象、耗时操作3.TextView优化 六、问题 1234567891011你在做布局优化过程中用到了哪些工具 - Choreographer - AOP、Hook - Systrace、Layout Inspector 布局为什么会导致卡顿，你又是怎么优化的 ? - IO、反射、遍历、重绘 - 异步Inflate、X2C、减少层级、重绘做完布局优化有哪些成果产出 - 体系化监控手段:线下+线上 - 指标:FPS、加载时间、布局层级 - 核心路径保障","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/3.内存优化/","text":"3.内存优化 1234//内存优化：内存优化主要体现在两个地方，第一个是内存抖动，第二个是内存泄漏1. 内存抖动： 主要是由于快速的内存创建和释放造成的，容易产生GC(Profiler);2. 内存泄漏：主要是由于长生命周期的引用了短生命周期的对象造成的(leakcary);3. 检测方式：AS的Profiler（Memory Profiler/Memory Analyzer）主动检测，leakcary被动的自动检测； 一、背景介绍 121.内存是大问题但缺乏关注2.压死骆驼的最后一根稻草 内存问题 1231.内存抖动:锯齿状、GC导致卡顿2.内存泄露:可用内存减少、频繁GC3.内存溢出:OOM、程序异常 工具选择 1231.Memory Profiler2.Memory Analyzer3.LeakCanary Memory Profiler(点击Studio底部Android Profiler界面中MEMORY区域的任意位置，即可开启Memory Profiler) 123456优点：1.实时图表展示应用内存使用量2.识别内存泄露、抖动等3.提供捕获堆转储、强制GC以及跟踪内存分配的能力4.方便直观5.线下平时使用 1234567891对应的按键用于强制内存回收。2对应的按键用于抓取进程内存的dump信息。3对应的按键用于记录内存的分配信息(连接Android 7.1及以下才会有此按键)。 初次点击时，对应统计的开始时间点；再次点击时，对应统计的结束时间点。 进程在两个时间点之间的内存分配信息，将被Memory Profiler记录和分析。4对应的区域用于缩放时间轴。5对应的按键用于显示实时的内存数据。6对应的区域用于记录事件发生的时间点及大致持续的时间(例如activity状态改变、用户操作界面等事件）。7对应的区域用于显示内存使用情况对应的时间轴(与标注6结合，就可以看出各事件带来的内存变化情况)。 123456789如上图所示，其中： Java表示Java代码或Kotlin代码分配的内存；Native表示C或C++代码分配的内存(即使App没有native层，调用framework代码时，也有可能触发分配native内存)；Graphics表示图像相关缓存队列占用的内存；Stack表示native和java占用的栈内存；Code表示代码、资源文件、库文件等占用的内存；Others表示无法明确分类的内存；Allocated表示Java或Kotlin分配对象的数量(Android8.0以下时，仅统计Memory Profiler启动后，进程再分配的对象数量； 8.0以上时，由于系统内置了统计工具，Memory Profiler可以得到整个app启动后分配对象的数量)。 点击左上角的标记2按钮，则出现下图可以查看各个对象的对应信息，如bitmap的大小和预览图 Memory Analyzer 123强大的Java Heap分析工具，查找内存泄露及内存占用生成整体报告、分析问题等线下深入使用 LeakCanary 1231.自动内存泄露检测 文档：https://github.com/square/leakcanary2.线下集成 二、Android内存管理机制 Java内存区域划分 123456781.方法区(Method Area):用于存储类的信息、常量、静态变量等，方法区在程序启动时就被创建，所有线程共享。 其中，常量池用于存放字符串常量、类和接口常量等.2.堆(Heap):用于存储对象实例。堆在程序运行时动态分配和回收，由垃圾回收器负责管理。 堆可以分为新生代和老年代两部分新生代又分为Eden空间、Survivor 0空间和Survivor 1空间. 虚拟机栈(VM Stack):每个线程在运行时都会创建一个栈，用于存储方法的局部变量、操作数栈、动态连接等。 栈顺随着方法3的进入和退出而动态创建和销毁。4.本地方法栈(Native Method Stack): 与虚拟机栈类似，但用于执行本地方法(即使用其他语言编写的方法)5.程序计数器(Program Counter) : 用于记录当前线程执行的字节码指令地址。 java内存回收算法 12345678910111213141516171819202122232425262728293031321. 标记-清除算法（Mark and Sweep）： 首先标记所有活动对象，然后清除所有未标记的对象。这种算法存在的问题是标记和清除效率不高并会产生大量的碎片， 导致内存空间的浪费。 2. 复制算法（Copying）： 2.1将内存划分为大小相等的两块 2.2一块内存用完之后复制存活对象到另一块 2.3清理另一块内存 2.4实现简单，运行高效（相对标记算法而言） 2.5浪费一半空间，代价大 将内存分为两个区域，每次只使用其中一个区域，当该区域满了之后，将所有活动对象复制到另一个区域中， 然后清除原来的区域。这种算法的优点是简单高效，但是会浪费一半的内存空间。 3. 标记-整理算法（Mark and Compact）： 1.标记过程与“标记-清除”算法一样 2.存活对象往一端进行移动 3.清理其余内存 4.避免标记-清理导致的内存碎片 5.避免复制算法的空间浪费 首先标记所有活动对象，然后将它们移动到内存的一端，然后清除另一端的所有未标记对象。 这种算法可以避免碎片问题，但是需要移动对象，可能会影响程序的性能。4. 分代收集算法（Generational）： 1.结合多种收集算法优势 2.新生代对象存活率低，复制 3.老年代对象存活率高，标记-整理 将内存分为几个代，每个代的对象生命周期不同。新创建的对象放在第一代，经过多次回收后仍然存活的对象会被移到下一代， 最终存活的对象会被移到老年代。这种算法可以根据对象的生命周期来优化回收效率。5. 引用计数算法（Reference Counting）： 对每个对象维护一个引用计数器，当有新的引用指向该对象时，计数器加一，当引用失效时，计数器减一。 当计数器为零时，说明该对象已经不再被引用，可以回收。这种算法的问题是无法处理循环引用的情况 Android内存管理机制 12345678910111213141.内存弹性分配，分配值与最大值受具体设备影响2.OOM场景:内存真正不足、可用内存不足3.Dalvik与Art区别 1.Dalvik仅固定一种回收算法 2.Art回收算法可运行期选择(5.0之后都是这种算法) 3.Art具备内存整理能力，减少内存空洞4.Low Memory Killer 1.进程分类（根据进程下面优先级，先考虑优先级低的进程进行回收） 1.前台进程 2.可见进程 3.服务进程 4.后台进程 5.空进程 2.回收收益 三、内存抖动实战 内存抖动介绍 123定义:内存频繁分配和回收导致内存不稳定表现:频繁GC、内存曲线呈锯齿状危害:导致卡顿、OOM 内存抖动导致OOM 121.频繁创建对象，导致内存不足及碎片(不连续)2.不连续的内存片无法被分配，导致OOM 内存抖动解决实战:使用Memory Profiler初步排查 创建一个模拟内存抖动的类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.optimize.performance.memory;import android.annotation.SuppressLint;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.optimize.performance.R;/** * 模拟内存抖动的界面 */public class MemoryShakeActivity extends AppCompatActivity implements View.OnClickListener &#123; @SuppressLint(&quot;HandlerLeak&quot;) private static Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); // 创造内存抖动 for (int index = 0; index &lt;= 100; index++)&#123; String arg[] = new String[100000]; &#125; mHandler.sendEmptyMessageDelayed(0,30); &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memory); findViewById(R.id.bt_memory).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; mHandler.sendEmptyMessage(0); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mHandler.removeCallbacksAndMessages(null); &#125;&#125; 点击执行后发送内存抖动时Memory Profiler的现象： 查找具体引起抖动的方式：点击record开始记录，再点击stop停止记录（如下图）； 左侧可以查看到不同对象的size大小，选中后右侧上面随意选择一个对象底部则会显示对象的调用信息，点击右键出现Jump to Source跳转到方法的调用处； 内存抖动解决技巧：找循环或者频繁调用的地方 四、内存泄漏实战 内存泄露介绍 123定义:内存中存在已经没有用的对象表现:内存抖动、可用内存逐渐变少危害:内存不足、GC频繁、OOM Memory Analyzer 12文档：https://www.eclipse.org/mat/downloads.ph转换: hprof-conv 原文件路径 转后文件路径 模拟内存泄漏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.optimize.performance.memory;import java.util.ArrayList;public class CallBackManager &#123; public static ArrayList&lt;CallBack&gt; sCallBacks = new ArrayList&lt;&gt;(); public static void addCallBack(CallBack callBack) &#123; sCallBacks.add(callBack); &#125; public static void removeCallBack(CallBack callBack) &#123; sCallBacks.remove(callBack); &#125;&#125; package com.optimize.performance.memory;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.widget.ImageView;import com.optimize.performance.R;/** * 模拟内存泄露的Activity */public class MemoryLeakActivity extends AppCompatActivity implements CallBack&#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memoryleak); ImageView imageView = findViewById(R.id.iv_memoryleak); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.splash); imageView.setImageBitmap(bitmap); CallBackManager.addCallBack(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //这行解决内存泄漏的代码 CallBackManager.removeCallBack(this); &#125; @Override public void dpOperate() &#123; // do sth &#125;&#125; 通过多次进入再退出上面的MemoryLeakActivity类则会出现下图这种内存泄漏情况： 通过record左边的down按钮并保存文件，再通过命令转换文件格式: 在使用Eclipse Memory Analyzer软件打开转换后的文件 点击 Histogram 按钮 在上图位置可以搜索怀疑存在内存泄漏的类，并查看显示的该类剩余的对象数量； 选中类的对象右键点击List Objects-&gt;with incoming references(哪些强引用引向了我)-&gt;选中类对象-&gt;Path to GC-&gt;with all references(所有对象都计算在内)分析后如下图，有个小圆点的则是目标内存泄漏的类 总结 121.使用Memory Profiler初步观察2.通过Memory Analyzer结合代码确认 五、MAT的使用 123MAT工具全称为Memory Analyzer Tool，一款详细分析Java堆内存的工具，该工具非常强大代码太多，可百度查看使用教程：如https://www.jianshu.com/p/034b72b91d3a/ 六、优雅的检测不合理的图片 Bitmap内存模型 1234561.API10之前Bitmap自身在Dalvik Heap中，像素在Native2.API10之后像素也被放在Dalvik Heap中3.API26之后像素在Native4.获取Bitmap占用内存 - getByteCount - 宽*高*一像素占用内存 常规方式 123当景:图片对内存优化至关重要、图片宽高大于控件宽高实现:继承ImageView，覆写实现计算大小缺点：侵入性强，不通用 ARTHook介绍 12345678挂钩，将额外的代码钩住原有方法，修改执行逻辑 - 运行时插桩 - 性能分析优点： - 无侵入性 - 通用性强缺点： - 兼容问题大，开源方案不能带的线上环境 Epic简介 1234567Epic是一个虚拟机层面、以Java Method为粒度的运行时Hook框架 - 支持Android4.0-9.0 - https://github.com/tiann/epicEpic使用 - compile &#x27;me.weishu:epic:0.3.6 - 继承XC_MethodHook，实现相应逻辑 - 注入Hook : DexposedBridge.findAndHookMethod 实战自定义Epic 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//compile &#x27;me.weishu:epic:0.3.6package com.optimize.performance.memory;import android.graphics.Bitmap;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.util.Log;import android.view.View;import android.view.ViewTreeObserver;import android.widget.ImageView;import com.optimize.performance.utils.LogUtils;import com.taobao.android.dexposed.XC_MethodHook;public class ImageHook extends XC_MethodHook &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); // 实现我们的逻辑 ImageView imageView = (ImageView) param.thisObject; checkBitmap(imageView,((ImageView) param.thisObject).getDrawable()); &#125; private static void checkBitmap(Object thiz, Drawable drawable) &#123; if (drawable instanceof BitmapDrawable &amp;&amp; thiz instanceof View) &#123; final Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap(); if (bitmap != null) &#123; final View view = (View) thiz; int width = view.getWidth(); int height = view.getHeight(); if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; // 图标宽高都大于view带下的2倍以上，则警告 if (bitmap.getWidth() &gt;= (width &lt;&lt; 1) &amp;&amp; bitmap.getHeight() &gt;= (height &lt;&lt; 1)) &#123; warn(bitmap.getWidth(), bitmap.getHeight(), width, height, new RuntimeException(&quot;Bitmap size too large&quot;)); &#125; &#125; else &#123; final Throwable stackTrace = new RuntimeException(); view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; @Override public boolean onPreDraw() &#123; int w = view.getWidth(); int h = view.getHeight(); if (w &gt; 0 &amp;&amp; h &gt; 0) &#123; if (bitmap.getWidth() &gt;= (w &lt;&lt; 1) &amp;&amp; bitmap.getHeight() &gt;= (h &lt;&lt; 1)) &#123; warn(bitmap.getWidth(), bitmap.getHeight(), w, h, stackTrace); &#125; view.getViewTreeObserver().removeOnPreDrawListener(this); &#125; return true; &#125; &#125;); &#125; &#125; &#125; &#125; private static void warn(int bitmapWidth, int bitmapHeight, int viewWidth, int viewHeight, Throwable t) &#123; String warnInfo = new StringBuilder(&quot;Bitmap size too large: &quot;) .append(&quot;\\n real size: (&quot;).append(bitmapWidth).append(&#x27;,&#x27;).append(bitmapHeight).append(&#x27;)&#x27;) .append(&quot;\\n desired size: (&quot;).append(viewWidth).append(&#x27;,&#x27;).append(viewHeight).append(&#x27;)&#x27;) .append(&quot;\\n call stack trace: \\n&quot;).append(Log.getStackTraceString(t)).append(&#x27;\\n&#x27;) .toString(); LogUtils.i(warnInfo); &#125;&#125; 12345678//调用执行ImageHookDexposedBridge.hookAllConstructors(ImageView.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); DexposedBridge.findAndHookMethod(ImageView.class, &quot;setImageBitmap&quot;, Bitmap.class, new ImageHook()); &#125; &#125;); 再在MemoryLeakActivity的activity_memoryleak的xml中将imageview宽高修改为50 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_memoryleak&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 启动下面MemoryLeakActivity类，然后会执行检测，运行后弹出警告 12345678910111213141516171819202122232425262728293031package com.optimize.performance.memory;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.widget.ImageView;import com.optimize.performance.R;/** * 模拟内存泄露的Activity */public class MemoryLeakActivity extends AppCompatActivity implements CallBack&#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_memoryleak); ImageView imageView = findViewById(R.id.iv_memoryleak); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.splash); imageView.setImageBitmap(bitmap); CallBackManager.addCallBack(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); CallBackManager.removeCallBack(this); &#125; @Override public void dpOperate() &#123; // do sth &#125;&#125; 七、线上内存监控方案 常规实现一 1设定场景线上Dump:Debug.dumpHprofData() 常规实现一流程 1超过最大内存80%(只在特定情况下执行，如占用可用内存超过80%)-&gt;内存Dump-&gt;回传文件(wifi或无流量空闲时上传)-&gt;MAT手动分析 实现一问题： 1231.Dump文件太大，和对象数正相关，可裁剪2.上传失败率高、分析困难3.配合一定策略，有一定效果 常规实现二 1231.LeakCanary带到线上2.预设泄露怀疑点3.发现泄露回传 实现二问题： 121.不适合所有情况，必须预设怀疑点2.分析比较耗时、也容易OOM LeakCanary原理 12341.监控生命周期，onDestroy添加RefWatcher检测2.二次确认断定发生内存泄露3.分析泄露，找引用链4.监控组件+分析组件 LeakCanary定制 1231.预设怀疑点-&gt;自动找怀疑点2.分析泄露链路慢-&gt;分析Retain size大的对象3.分析OOM-&gt;对象裁剪，不全部加载到内存 线上监控完整方案 1231.待机内存、重点模块内存、OOM率2.整体及重点模块GC次数、GC时间3.增强的LeakCanary自动化内存泄露分析 八、内存优化技巧总结 优化大方向 1231.内存泄露2.内存抖动3.Bitmap 优化细节 1234561.LargeHeap属性（如：系统默认256m，申请了LargeHeap属性则默认内存*2）2.onTrimMemory（低内存回调，低内存时主动做一些处理，关闭一些功能等）3.使用优化过的集合:SparseArray4.谨慎使用SharedPreference（调用时会将缓存的东西全部加载到内存中去，或者大数据量的东西不要用SharedPreference）5.谨慎使用外部库（怕存在隐患）6.业务架构设计合理 九、常见问题 12345678910111.你们内存优化项目的过程是怎么做的 - 分析现状、确认问题 - 针对性优化 - 效率提升2.你做了内存优化最大的感受是什么 - 磨刀不误砍柴工 - 技术优化必须结合业务代码 - 系统化完善解决方案3.如何检测所有不合理的地方 - ARTHook - 重点强调区别","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/2.App启动优化/","text":"2.App启动优化 12345//App启动优化1.获取启动耗时： 1.手动埋点，aop统一处理，systrace/traceview获取 2.优化手段：延迟加载或者异步加载(充分利用CPU，将任务放到子线程中执行分担主线程任务，jetpack的App Startup框架，或者自定义使 用线程池异步加载) 一、启动优化介绍 背景介绍 121.第一体验（应用启动的速度是第一感受）2.八秒定律（如果一个页面8秒还没有响应，70%的用户将放弃等待） 启动分类 1234App startup time - 冷启动 - 热启动 - 温启动 冷启动: 耗时最多，衡量标准 (经历了一系列的流程，因此耗时较多) 热启动：最快 温启动：较快 （重走activity的生命周期，不会重走进程的创建或application的创建等） 相关任务 1234567891011121.冷启动之前(系统的操作) - 启动App - 加载空白Window - 创建进程2.随后任务 - 创建Application - 启动主线程 - 创建MainActivity3.随后任务 - 加载布局 - 布置屏幕 - 首帧绘制 优化方向 1Application和Activity生命周期这个阶段 二、启动时间的测量方式 121.adb命令2.手动打点 adb命令 1234567adb shell am start -W packagename/首屏Activity - ThisTime:最后一个Activity启动耗时 - TotalTime:所有Activity启动耗时 - WaitTime:AMS启动Activity的总耗时缺点： - 线下使用方便，不能带到线上 - 非严谨、精确时间 手动打点 1231.精确，可带到线上，推荐使用2.避开误区，采用Feed第一条展示3.addOnDrawListener要求API16 1234567891011//方法类public class LaunchTimer &#123; private static long sTime; public static void startRecord() &#123; sTime = System.currentTimeMillis(); &#125; public static void endRecord()&#123; long cost = System.currentTimeMillis() - sTime; Log.e( &quot;tyl&quot;,&quot;cost=&quot; + cost); &#125;&#125; 12345678startTime的执行地方： - Application的attachBaseContext方法中endTime的执行地方： - 误区: activity的onWindowFocusChanged只是首帧时间，用户还没有看到画面 - 正解:真实数据展示，Feed第一条展示 (recycleView的adapter的onBindViewHolder()-&gt; holder.linearLayout.getViewTreeObserver().addOnPreDrawListener()-&gt; onPreDraw()中执行//onWindowFocusChanged和Feed中执行结束相差100多ms 三、启动优化工具选择 121.traceview2.systrace 注意 12- 两种方式互相补充- 正确认识工具及不同场景选择合适的工具 traceview和systrace各自的作用和区别 1234567891011121314151617Traceview 和 Systrace 都是用于 Android 应用程序性能分析和调试的工具，但它们在功能和用途上有一些区别：Traceview：Traceview 是 Android 开发工具包（SDK）中提供的一种效率分析工具，用于分析应用程序的方法调用、线程执行时间等信息。开发人员可以使用 Traceview 工具来查看应用程序的性能数据，包括方法的执行时间、CPU 使用率、线程的执行情况等。Traceview 会生成一个包含方法调用图、执行时间和线程等信息的 trace 文件，开发人员可以通过 Android Studio 或其他工具进行分析和 查看。主要用于分析应用程序代码的性能瓶颈、方法执行耗时等问题，帮助优化应用程序的性能。 Systrace：Systrace 是 Android 系统级的跟踪工具，用于分析整个系统的性能数据，包括应用程序、系统服务、内核等的运行情况。开发人员可以使用 Systrace 工具来查看应用程序与系统之间的交互情况、系统资源占用情况、视图绘制耗时等信息。Systrace 通过采集系统事件、函数调用、线程、CPU 使用情况等信息，生成一个详细的时间线，展示系统运行时的各种活动。主要用于分析应用程序与系统交互导致的性能问题，如绘制卡顿、I/O 操作慢、系统资源竞争等，帮助优化应用程序与系统的性能。 总的来说，Traceview 主要用于分析应用程序代码的性能问题，而 Systrace 则更侧重于分析整个系统的性能问题，包括应用程序与系统之 间的交互。开发人员可以根据具体情况选择合适的工具进行性能分析和调试，以优化应用程序的性能和稳定性。 traceview 123traceview的优点：图形的形式展示执行时间、调用栈等信息全面，包含所有线程 使用方式(查看指定方法执行时间) 12345678910111.String tracPath=getExternalCacheDir()+&quot;/myTrac.trace&quot;;Debug.startMethodTracing(tracPath);//tracPath 生成文件的文件路径，需要读写权限........要测试的方法......2.Debug.stopMethodTracing();3.生成文件在sd卡://tracPath=storage/emulated/0/Android/data/com.withub.android.cloudsharingcourt/cache/myTrac.trace//如在application的oncreate()方法中第一行加入Debug.startMethodTracing(&quot;&quot;);，//在oncreate()最后一行加入Debug.stopMethodTracing();4.点击在androidStudio的右侧有个Device File explorer,这个工具是方便打开手机中的文件；//根据传入的指定路径找到生成trace文件 trace文件打开后如下图： 底部4个菜单栏的含义： 1.CallChart:垂直方向是方法的调用栈（如A调用B则B在A的下面），另外系统API的颜色是橙色，应用自身的代码调用是绿色的，其他第三方的api调用则是蓝色； 2.FlameChart：火焰图，收集相同调用顺序完全相同的函数，相对callChart作用要小很多； 3.TopDowm:函数的调用列表，相当于CallChart的文字版； 选中方法点击右键可以点击Jump to Source跳转到对应代码； 可以查看指定方法的执行时间，Total&#x3D;self+Children，self等于执行这个A方法的时间children则是A方法内其他方法的所用时间； 右上角有个下拉选项：Wall Clock Time(所在线程真正所用的时间)，threadTime(cpu所执行的时间) 4.BottomUp:和FlameChar类似重要性不高，显示的方法的被调用列表，点击B查看B被谁调用的； traceview的缺点 1231.运行时开销严重，整体都会变慢2.可能会带偏优化方向3.traceview与cpu profiler(2者结合来分析) systrace 1234567891011121.结合Android内核的数据，生成Html报告2.API18以上使用，推荐TraceCompat3.使用方式python systrace.py -t 10 [other-options] [categories]//官方文档：https://developer.android.com/studio/commandline/systrace#command options代码中埋点：TraceCompat.beginSection(&quot;AppOncreate&quot;); ........要测试的方法......TraceCompat.endSection(); 脚本示例： -b 收集包的大小 ，-t 时间，-a 包名，-o 输出生成的文件名 systrace默认图： kernel：不同时间段只运行了4核，有时8核（如何高效的运用cpu）； 可以查看不同线程的运行情况，点击具体方法可以展开方法的详细运行时间 12345678systrace优点：轻量级，开销小直观反映cpu利用率注意：cputime与walltime区别 - walltime是代码执行时间 - cputime是代码消耗cpu的时间(重点指标) 举例:锁冲突 四、优雅获取方法耗时 1234567891011121314151617181920212223242526272829303132333435363738394041常规方式 -背景:需要知道启动阶段所有方法耗时 -实现:手动埋点 -long time = System.currentTimeMillis(); -long cost = System.currentTimeMillis() - time; - 缺点：侵入性强,工作量大AOP介绍 -Aspect Oriented Programming，面向切面编程 -针对同一类问题的统一处理 -无侵入添加代码AOP实战 -AspectJ使用(辅助实现AOP) -classpath &#x27;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0//旧版本在build.gradle buildScripe-&gt;dependencies中 -implementation &#x27;org.aspectj:aspectjrt:1.8.+ -apply plugin: &#x27;android-aspectjx//旧版本app build.gradle的顶部 -Join Points使用 -程序运行时的执行点，可以作为切面的地方 -函数调用、执行 -获取、设置变量 -类初始化 -PointCut -带条件的JoinPoints -Advice -一种Hook，要插入代码的位置 -Before : PointCut之前执行 -After:PointCut之后执行 -Around:PointCut之前、之后分别执行 -语法简介 @Before(&quot;execution(*android.app.Activity.on**(..))&quot; public void onActivityCalled(JoinPoint joinPoint) throws Throwable &#123; ... &#125; -Before:Advice，具体插入位置 -execution :处理Join Point的类型，call、execution -(*android.app.Activity.on**(..)):匹配规则 -onActivityCalled :要插入的代码 实战代码：任意自建的一个类 AOP的优点：无侵入性，修改方便 五、异步优化 优化小技巧 12345678910111213141516171819Theme切换：感官上变快了；(实际启动时间未变快)1.&lt;layer-list xmIns:android=&quot;http://schemas.android.com/apk/res/androidandroid:opacity=&quot;opaque&quot;&gt;&lt;!-- The background color, preferably the same as your normal theme --&gt;&lt;item android:drawable=&quot;@android:color/white&quot;/&gt;&lt;!-- Your product logo - 144dp color version of your app icon --&gt;&lt;item&gt; 4&lt;bitmapandroid:src=&quot;@drawable/product_ogo_144dp&#x27;android:gravity=&quot;center&quot;/&gt;&lt;/item&gt;&lt;/layer-list&gt;2.&lt;activity ...android:theme=&quot;@style/AppTheme.Launcher”/&gt;3.@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; // super.onCreate之前切换回来 setTheme(R.style.Theme_MyApp); super.onCreate(savedInstanceState);&#125; 异步优化 1核心思想:子线程分担主线程任务，并行减少时间 1234567891011121314151617181920212223242526272829303132333435363738public class MyApp extends MultiDexApplication &#123; //同步工具类，用来协调多个线程之间的同步，用来作为线程间的通信而不是互斥作用 private CountDownLatch countDownLatch = new CountDownLatch(1); @Override public void onCreate() &#123; super.onCreate(); //动态获取设备核心数量，老版本生效新版本未验证； int CORE_POOL_SIZE = Math.max(2,Math.min(Runtime.getRuntime().availableProcessors() - 1,4)); //创建线程池，java原生代码传入核心数； ExecutorService executorService = Executors.newFixedThreadPool(CORE_POOL_SIZE); //一个任务一个线程，多个任务则submit多个 executorService.submit(new Runnable() &#123; @Override public void run() &#123; initTask1(); &#125; &#125;); executorService.submit(new Runnable() &#123; @Override public void run() &#123; initTask2(); //initTask2执行完毕后通知countDownLatch； countDownLatch.countDown(); &#125; &#125;); executorService.submit(new Runnable() &#123; @Override public void run() &#123; initTask3(); &#125; &#125;); ... try &#123; countDownLatch.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 异步优化注意 1231.不符合异步要求2.需要在某阶段完成3.区分CPU密集型和IO密集型任务 六、异步优化启动器 常规异步痛点 1231.代码不优雅2.场景不好处理(依赖关系)3.维护成本高 启动器介绍: 1核心思想: 充分利用CPU多核，自动梳理任务顺序 启动器流程 1231.代码Task化，启动逻辑抽象为Task2.根据所有任务依赖关系排序生成一个有向无环图3.多线程按照排序后的优先级依次执行 启动器流程图： 启动器起源码（启动器代码太多）：https://gitee.com/cq_tyl/performance-optimization/tree/master（utils/TaskDispatcher.java） 12345678910示例：TaskDispatcher.init( context:PerformanceApp.this);TaskDispatcher dispatcher = TaskDispatcher.createInstance();dispatcher.addTask(new InitAMapTask()).addTask(new InitStethoTask())InitweexTask()).addTask(newaddTask(newInitBuglyTask())addTask(newInitFrescoTask()).addTask(newInitJPushTask()).addTask(newInitUmengTask()).addTask(newGetDeviceIdTask()).start();dispatcher.await();//如有需要等待完成后才继续往下走 七、更优的延迟初始化的解决方案 常规方案:将延迟操作放到显示之后执行 123451.New Handler().postDelayed2.Feed展示后调用缺点： - 时机不便控制 - 导致Feed卡顿 更优方案:对延迟任务进行分批初始化 1利用IdleHandler特性，空闲执行 实战源码：DelayInitDispatcher.java及其引用 （https://gitee.com/cq_tyl/performance-optimization/tree/master） 八、启动优化其他方案 优化总方针： 121.异步、延迟、懒加载2.技术、业务相结合 注意事项 123456781.wall time与cpu time2.cpu time才是优化方向3.按照systrace及cpu time跑满cpu4.监控的完善 - 线上监控多阶段时间(App、Activity、生命周期间隔时间 ) - 处理聚合看趋势5.收敛启动代码修改权限 - 结合Ci修改启动代码需要Review或通知 其他方案 12345678910111.提前加载SharedPreferences - Multidex之前加载，利用此阶段CPU - 覆写getApplicationContext0)返回this2.启动阶段不启动子进程 - 子进程会共享CPU资源，导致主进程CPU紧张 - 注意启动顺序:App onCreate 之前是ContentProvider3.类加载优化:提前异步类加载 - Class.forName0只加载类本身及其静态变量的引用类 - new 类实例 可以额外加载类成员变量的引用类4.启动阶段抑制GC5.CPU锁频 九、问题 12345678910111213141.你做启动优化是怎么做的 - 分析现状、确认问题 - 针对性优化 - 长期保持优化效果 2.是怎么异步的，异步遇到问题没有 - 体现演进过程 - 详细介绍启动器 3.你做了启动优化，觉得有哪些容易忽略的注意点 - cpu time与wall time - 注意延迟初始化的优化 4.版本迭代导致的启动变慢有好的解决方式吗 - 启动器 - 结合CI - 监控完善","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/1.App性能概览与平台化实践/","text":"1.App性能概览与平台化实践 123//性能优化性能优化:包括了启动，内存，布局，卡顿，网络，电量，瘦身，稳定性；性能监测平台：外网：听云，内网：自检各种性能检测机制，统一上报； 一、背景介绍 性能优化有哪些难题？ 1234567891011121.性能表现差 - App启动慢、卡顿、丢帧 - 内存占用高、抖动频繁 - 耗电、网络请求慢 - 崩溃率、异常率高2.线上问题无从追查 - 如何保证异常感知灵敏度 - 如何复原&quot;案发&quot;现场 - 如何快速&quot;止血&quot;（修复）成功3.性能优化的长期开销大 - 如何扼杀问题于萌芽 - 优化效果如何长期保持 相反的对性能优化要求 1231.性能表现好2.线上问题易追查3.长期投入小 二、不同项目阶段，性能解决方案的演进 1234567891011121.项目初期（快速开发阶段，快速占领市场的阶段） 只关心崩溃率、不采集性能数据 没有性能检测、优化方案 没有排查问题手段2.项目壮大期（项目的发展和用户的增多时，逐渐的开始重视性能优化） 指标采集，不够全及深入 接入成熟APM，排查手段单一 线下检测、优化，方案不成型3.项目成熟期（用户已达到数百万，重视性能优化） 重点关注性能问题，数据丰富，手段多样化 线上、线下一整套完善解决方案(重点) 自建APM，新产品可快速接入 线上线下各一套解决方案的原因 1231.误区:对线上不重视2.侧重点:线下预防、线上监控3.方案不同:线下可用黑科技 为什么自建APM(应用性能监控平台) 1231.成熟APM通用，但不满足个性化需求2.外部APM与内部系统难打通，带来的时间成本3.数据必须掌握在自己手中 三、业界优秀的平台 1231.Crash收集平台2.APM平台3.自建解决方案 Crash收集平台 1234Bugly为代表- 数据采集、上报成功率高- 包含Java、Native崩溃- 建议项目初期接入 APM平台 123听云为代表 - 通用的性能解决方案，数据采集完善 - 方便接入，但不满足个性化需求，数据隐患 自建解决方案 123美团、携程、360等 - 贴合自身业务特点，满足定制化需求 - 数据安全 四、问题 12345678910111.你们为什么要做性能优化 - 体验差影响核心指标 - 线上问题追查困难 - 降低性能优化的长期开销2.介绍一下你们的性能平台 - 交代背景 - 具体讲解3.你们为什么要自建APM - 需求层面 - 效率层面 - 数据安全","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/性能优化/3.1.leakcanary的使用/","text":"3.1.leakcanary的使用 它是什么 一句话说，就是： Android项目中，用于检测内存泄露，优化性能的工具 解决了什么问题 解决了，内存泄漏难以发现的问题。通过Leakcanary，可以轻松的找到GC中跟搜索法可达，然而不再使用的对象。一般情况下，这种问题是很难被发现的，原因是他的出现是不经意间的，其中，内存泄露常见的场景有： 内存泄露常见场景 非静态内部类的静态实例 非静态内部类会持有外部类的引用 在外部类生命周期结束后，静态实例会长期维持着外部类的引用，导致无法被gc 多线程相关的匿名内部类\\非静态内部类 匿名内部类同样也会持有外部类实例的引用，例如（AsyncTask、Tread、Runnable接口的实现类） 匿名内部类\\非静态内部类中有耗时操作，在外部类生命周期结束后，仍然长时间维持着外部类的引用，导致无法被gc Handler内存泄露 Handler定义为非静态的，即持有了外部引用 Message存储到MessageQueue中，耗时较长，无法被回收 怎样去使用它 集成进项目之中 新版本的Leakcanary只需添加依赖,无需更改代码 1debugImplementation &#x27;com.squareup.leakcanary:leakcanary-android:2.5&#x27; 发现内存泄露 Leaknary 能够发现内存泄露的位置有： 销毁的Activity 实例 销毁的Fragment 实例 销毁的View 实例 销毁的ViewModel 实例LeakCanary可以hook到Android生命周期中，从而自动检测Activity和Fragment何时destroy，并进行垃圾收集。ObjectWatcher持有这些被destroy的对象的弱引用。通过以下方法，可以找到被Destroy的对象，例如 1AppWatcher.objectWatcher.watch(myDetachedView, &quot;View was detached&quot;) 如果运行垃圾回收，并等待5秒钟后ObjectWatcher仍未清除 ，则认定可能发生内存泄漏。LeakCanary将此记录到Logcat： 在未被正常清楚的对象达到一定数量后，LeakCanary将其dump到存储堆，并显示通知： 图1.LeakCanary找到了4个未被正常清楚的对象。 注意： 当应用程序的状态是可见的时候，默认阈值为5 ，当应用程序是不可见的时候，默认阈值为1，。如果看到Leakcanary弹出通知，然后将应用程序压至后台（例如，直接上划进入主页），则LeakCanary阈值从5更改为1，并在5秒钟后dump到存储堆。若点击按钮将强制LeakCanary立即dump到存储堆。 打印堆中的信息当保留对象的数量达到阈值时，LeakCanary将Java堆dump到存储在Android文件系统上的.hprof文件中（详见LeakCanary在何处存储堆转储？）。转储堆会使应用程序停止运行一小段时间，在此期间LeakCanary会显示Toast： 图2.LeakCanary显示了在堆放时的Toast 分析堆中的信息LeakCanary.hprof使用Shark解析文件，并在该堆存储中找到保留的对象。 图3.LeakCanary在堆存储中查找保留的对象。 对于每个保留的对象，LeakCanary会查找引用路径，以防止对该保留的对象进行垃圾回收：至于泄露跟踪的具体内容，将在下一部分中展开：修复内存泄漏。 图4.LeakCanary计算每个保留对象的泄漏跟踪 分析完成后，LeakCanary将显示带有摘要的通知，并在Logcat中显示结果。注意：下图将4个保留的对象归为2个不同的泄漏。LeakCanary为每个泄漏跟踪创建一个签名，并将具有相同签名的泄漏（即，由同一bug引起的泄漏）组合在一起。 图5. 4条泄漏迹线变成2个不同的泄漏特征。 点击弹出的通知，将提供更多详细的信息。也可以通过启动Leaks来找到该条内存泄露的详细信息 图6.LeakCanary为安装的每个应用程序添加一个启动器图标。 在Leaks中，每行对应一组具有相同签名的泄漏。应用程序首次出现的内存泄露类型将标记为“New”。 图7.将4个泄漏分组为2行，每个泄漏标记对应一个 点击泄漏将展示整个泄露的跟踪信息。 图8. 显示了3个同一类别的内存泄露 泄漏签名是每个级联的散列参考怀疑导致泄漏，即，每个参考与红色下划线显示： 图9.带有3个可疑参考的泄漏跟踪。 当泄漏跟踪以文本形式共享时，这些相同的可疑引用都带有下划线：如 并计算出响应的signature ，例如上述的签名为 分类内存泄露信息 常见的内存泄露Leaknary将其分成了第三方库和程序员操作失误两种。 第三方库的泄露如下所示：（带有Library Leak） 图10.LeakCanary发现了Library Leak。 2.程序员异常操作的泄露： 图10.NewsFragment.mRootV处泄露 如何解决内存泄露 我们在代码中能不用static变量持有context就不用，非要用就用weak引用。 对于内部类，尽量用静态内部类，这样就不会持有外部类引用。如果需要外部类引用做一些事，就手动赋给一个weak引用。 对于匿名内部类，不要图简单方便，实在不行就 写成外部类 在使用handler时，记得在activity的onDestroy()中加上remove()，有待尝试","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/9_音视频基础/","text":"","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/5_c进阶_内存四驱模型/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#define _CRT_SECURE_NO_WARNINGS#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// 写一个打印数组的方法void print(int* arr,int length)&#123; // 获取数组的大小 for (int i = 0; i &lt; length; i++) &#123; printf(&quot;%d &quot;,arr[i]); &#125;&#125;struct MyStruct&#123; char* name;&#125;;typedef struct MyStruct Student;// 给 MyStruct 取一个别名叫做 Student// int32_t ，可以对基本数据类型取别名typedef int int32;//数组作为参数传递/*void main()&#123; int a;// 告诉c和c++编译器开辟一块连续大小的 4 字节的内存空间 int arr[] = &#123;1,2,3,4,5,6&#125;; // 求数组的大小？ int size = sizeof(arr) / sizeof(int); printf(&quot;size = %d\\n&quot;,size); print(arr,size);//数组作为参数传递，会退化成为一个指针，传递的是首地址，所以必须传递数组的长度过去，否则无法打印数组 getchar();&#125;//数据类型分析void main()&#123; int a;// 告诉c和c++编译器开辟一块连续大小的 4 字节的内存空间 int arr[] = &#123; 1, 2, 3, 4, 5, 6 &#125;;// arr 数据类型的内存大小空间 24 a = 10; // 12 , 16 , 12 , 36 36？ printf(&quot;%d, %d, %d ,%d&quot;, arr, arr+1, &amp;arr, &amp;arr+1); getchar();&#125;// 2.数据类型剖析// 数据类型的本质:一块连续大小的内存空向// 数据类型的别名:int32_t// void指针数据类型:vid&quot;代表任意的数据类型的指针// 3.变量的本质// 变量的本质:固定内存块大小(一块连续大小的内存空向) 的别名，通过变量可以去操作一块内存上的数据变量的三要素:内存大小，名称，作用域void main()&#123; Student stu = &#123; &quot;Darren&quot; &#125;; int32 number1 = 100; printf(&quot;number1 = %d&quot;,number1); // 获取 Bitmap ，锁定画布 void** // void number;// 错误 // memcpy();// 拷贝内存，什么用 void* getchar();&#125;char* getStr1()&#123; char* str = &quot;12345&quot;; return str;&#125;char* getStr2()&#123; char* str = &quot;12345&quot;; return str;&#125;char* getStr3()&#123; char buff[128]; strcpy(buff,&quot;12345&quot;); return buff;&#125;char* getStr4()&#123; char* buff = malloc(128); // char* buff char* 是四字节的数据类型，存的是堆区开辟的 128 个字节的首地址 strcpy(buff, &quot;12345&quot;); return buff;&#125;void main()&#123; char* str1 = NULL; char* str2 = NULL; str1 = getStr1(); str2 = getStr2(); char* str3 = getStr3(); char* str4 = getStr4(); printf(&quot;%d , %d, %s, %s&quot;,str1,str2,str3,str4);// str3 = 12345 getchar();&#125;*/void main()&#123; int a = 10; int b = 10; // 0508 , 0496 a 的地址要大于 b 的地址 （debug） // 016 , 020 a 的地址要小于 b 的地址 （release） // buffer 数据类型跟栈的开口方向无关（都是向上） char buff[10]; // buff+1 &gt; buff printf(&quot;%p , %p, %p, %p&quot;,&amp;a,&amp;b,buff,buff+1); int a = 100; int* ff = &amp;a;// 虽说是 a 的地址，但是我也可以把 ff 看做一个数组 // char** 二维数组 char** 二级指针 ff += 1; getchar();&#125;// 理解指针的关键还是在于内存 ，指针的大小是 4 字节 int* double* 指针存放的是一块内存的地址 4 字节 ，但是也会有数据类型 4.1 程序运行的流程: 1234.1.1操作系统会把物理硬盘上的代码 load 到内存4.1.2加载到内存后会把c代码分成4个区4.1.3然后系统会找到main 函数的入口去执行 4.2 四驱模型: 12344.2.1栈区:由编译器自动分配的，存放一些局部变量值和函数，这个里面内存是会自动进行回收的4.2.2 堆区:一般都是由我们自己去开辟的，这个里面的内存需要手动进行释放 malloc free new delete4.2.3 全局区:静态的一些常量，字符串等等4.2.4程序代码区:存放的是函数体的二进制代码 p65-p76没看，讲的c进阶，有点懵不如后面自己看c的完整教程","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/6_c++基础/","text":"1.c和c++的区别 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt; // c++的包#include &quot;Student.h&quot;using namespace std; // 命名的空间，java中的类部内/*// 1. c++ 代码中可以混编 c 代码，c++ 里面写 c 代码，也可以调用// 2. c++ 面向对象（Java），c 面向过程// 3. 很多的开源框架大部分都是 c++ 写的 （大部分基于 c++ ）void main()&#123;// printf(&quot;Hello World&quot;);// c 的打印// c++ 打印 opencv &lt;&lt; 操作符重载std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;getchar();&#125; 2.常量 123456789void main()&#123; const int number = 10; // number = 20; // int* numberP = &amp;number;// 不能通过地址去修改值，但是某些编译器上面能通过，但是也不能修改值 // c 是能够修改的，在 c 中可以说是一个伪命题 // *numberP = 20; // printf(&quot;%d&quot;, number); getchar();&#125; 3.引用和常量引用 1234567891011121314151617181920212223242526272829303132333435// 引用void swap(int &amp;number1, int &amp;number2)&#123; cout &lt;&lt; &quot;swap number1的地址&quot; &lt;&lt; &amp;number1 &lt;&lt; endl; int temp = 0; temp = number1; number1 = number2; number2 = temp;&#125;void main()&#123; int number1 = 10; int number2 = 20; // 引用： 四驱模型值的拷贝，引用其实是地址赋值 ，可以看成同一块内存的另外一个变量 cout &lt;&lt; &quot;main number1的地址&quot; &lt;&lt; &amp;number1 &lt;&lt; endl; swap(number1,number2); cout &lt;&lt; &quot;number1 = &quot; &lt;&lt; number1 &lt;&lt; &quot; , number2 = &quot; &lt;&lt; number2 &lt;&lt; endl; getchar();&#125;//------------------------------------------------------------------------------------------------//常量引用typedef struct &#123; char name[20]; int age;&#125;Student;void insertStu(const Student &amp;stu)&#123;// stu 不想改 常量引用 // 可以修改 stu 的值 // strcpy(stu.name,&quot;Jack&quot;); // 就变成了只读 cout &lt;&lt; stu.name &lt;&lt; &quot;,&quot; &lt;&lt; stu.age &lt;&lt; endl;&#125;void main()&#123; Student stu = &#123;&quot;Darren&quot;,20&#125;; insertStu(stu); getchar();&#125; 4.函数重载和默认参数 1234567891011121314151617181920212223242526// 1.函数重载和默认参数int add(int number1, int number2 = 200, bool cache= 0)&#123; // number2 = 200 默认的参数 kotlin 很像 return number1 + number2;&#125;// 错误 1 error C2084: 函数“int add(int,int)”已有主体 c 不允许函数的重载int add(int number1, int number2, int number3)&#123; return number1 + number2 + number3;&#125;void main()&#123; int number1 = 100; int number2 = 200; int sum = add(number1,200);//报错 // bool 类型 0是true 和 !0 都是false bool cache = -100; if (cache)&#123; cout &lt;&lt; &quot;true&quot; &lt;&lt; endl; &#125;else &#123; cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; &#125; // printf(&quot;sum = %d&quot;, sum); getchar();&#125; 5.类的初探 1231.class 定义类，跟java 几乎类似2.真正的开发过程中我们的 pp 或者 文件，最终 d 或者 库供调用者使用，所以为了确保类能正常被调用，我们般需要定义.h 头文件3实现方法的使用要用命名空间 xxx类名::xxx方法 Student.h 1234567891011121314class Student&#123; // 结构体类似private: // 私有，包装，影响下面所有的属性 char* name; int age;public: void setAge(int age); void setName(char* name); // private: // 影响到下面的所有方法 int getAge(); char* getName();&#125;; Student.cpp 1234567891011121314#include &quot;Student.h&quot;// 写实现 ,定义了另外一个方法void Student::setAge(int age)&#123;// 实现 Student 的 setAge 方法 this-&gt;age = age;&#125;void Student::setName(char* name)&#123; this-&gt;name = name;&#125;int Student::getAge()&#123; return this-&gt;age;&#125;char* Student::getName()&#123; return this-&gt;name;&#125; Simple.cpp 12345678910111213141516171819#include &quot;Student.h&quot;// 0 1 2 , 0 打印， 1 上传到后台， 2 友盟和服务器void printLog(char* content,int)&#123;// 自己平台打印，产品说了下个版本可能要上传到服务器，友盟也要备一份 cout &lt;&lt; content &lt;&lt; endl; // 补功能 有可能&#125;void main()&#123; // new ，new 出来的是一个指针 Student *stu = new Student(); printLog(&quot;xxxx&quot;,0);// 100 printLog(&quot;xxxx&quot;, 1);// 100 printLog(&quot;xxxx&quot;, 2);// 100 stu -&gt; setName(&quot;Darren&quot;); stu -&gt; age = 24; cout &lt;&lt; stu -&gt; getName() &lt;&lt; &quot; , &quot; &lt;&lt; stu -&gt; getAge() &lt;&lt; endl; getchar();&#125;// 补充：开发过程中（重要）直接写的问题所在 Student.cpp 是一个单独类 Student.cpp // 会编译成一个 so 库，必须要有一个头文件 6.构造函数&#x2F;析构函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;// 1.构造函数 class Student&#123;public: // 构造函数 Student()&#123;// 空参数构造函数 cout &lt;&lt; &quot;空参数构造函数&quot;&lt;&lt; endl; &#125; Student(char* name):age(0)&#123;// 一个参数构造函数, 相当于 this-&gt;age = 0 cout &lt;&lt; &quot;一个参数构造函数&quot; &lt;&lt; endl; this-&gt;name = name; this-&gt;age = 0; &#125; Student(char* name, int age)&#123;// 两个参数构造函数 cout &lt;&lt; &quot;两个参数构造函数&quot; &lt;&lt; endl; this-&gt;name = name; this-&gt;age = age; &#125; //默认参数赋值 // Student(char* name):age(0)，sex(1)&#123;// 一个参数构造函数, 相当于 this-&gt;age = 0 // cout &lt;&lt; &quot;一个参数构造函数&quot; &lt;&lt; endl; // this-&gt;name = name; // this-&gt;age = 0; // &#125; //析构函数:临终遗言，对象被回收的时候会被调用 //如果有在对象内部开辟堆内存，可以在析构函数中释放内存 ~Student()&#123; cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl; // 释放内存 free(this-&gt;name); this-&gt;name = NULL; &#125; private: int age; char* name;public: int getAge()&#123; return this-&gt;age; &#125; char* getName()&#123; return this-&gt;name; &#125; void setAge(int age)&#123; this-&gt;age = age; &#125; void setName(char* name)&#123; this-&gt;name = name; &#125;&#125;;/*void main()&#123; // Student stu;// 1. 默认调用空参的构造函数 // stu.setAge(24); // stu.setName(&quot;Darren&quot;); // Student stu(&quot;Darren&quot;,24); // 2. 调用两个参数的构造函数 // 3. 用 new 关键字,返回的是一个 Student 的一级指针 // Student *stu = new Student(&quot;Darren&quot;,24); // 4. 用 malloc 的方式，并没有调用空参的构造函数 // Student *stu = (Student*)malloc(sizeof(Student)); // stu-&gt;setAge(24); // stu-&gt;setName(&quot;Darren&quot;); //5.构造函数相互调用，注意：先会调用两个参数的构造函数，然后才会执行当前构造函数 Student *stu = new Student(&quot;Darren&quot;); cout &lt;&lt; stu -&gt; getName() &lt;&lt; &quot; , &quot; &lt;&lt; stu-&gt;getAge() &lt;&lt; endl; getchar();&#125; 7.malloc、free、new、delete 区别 1234567891011121314// malloc、free、new、delete 区别void main()&#123; // Student stu;// 栈中开辟内存 // malloc、free、 new、delete 都是开辟和释放内存 // 1. malloc/free 他们是一套， new/delete 它们也是配套 // 2. malloc/free 不会去调用构造函数和析构函数 // Student *stu = (Student*)malloc(sizeof(Student)); // free(stu); // 3. new/delete 会调用构造函数和析构函数 // Student *stu = new Student(); // delete(stu); // 4. 如果用了 new ，那么一定要记得 delete（释放内存） getchar();&#125; 8.可变参数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stdarg.h&gt;using namespace std;// 1. 可以变参数void sum(int count,...)&#123;// int ... ， c++ ... va_list vp; // 可变参数开始方法，count 代表从哪里开始 va_start(vp, count); int number = va_arg(vp,int); cout &lt;&lt; number &lt;&lt; endl;//2 // 读取下一个 number = va_arg(vp, int); cout &lt;&lt; number &lt;&lt; endl;//1 // 读取下一个 ，超出了默认是 0 number = va_arg(vp, int); cout &lt;&lt; number &lt;&lt; endl;//0&#125; void main()&#123; int number = sum(2,1,2); cout &lt;&lt; number &lt;&lt; endl; getchar();&#125;//----------------------------------------------------------------------------------------------int sum(int count, ...)&#123;// count数组长度 va_list vp; // 可变参数开始方法，count 代表从哪里开始 va_start(vp, count); int sum = 0; for (int i = 0; i &lt; count; i++) &#123; sum += va_arg(vp, int); &#125; // 结尾，释放内存 va_end(vp); return sum;&#125;void main()&#123; int number = sum(5,1,2,4); cout &lt;&lt; number &lt;&lt; endl; getchar();&#125; 9.静态属性static 12345678910111213141516171819202122232425262728293031323334class Student&#123;public: char* name; int age; // 静态 static int tag;// 定义 Student()&#123; tag = 12; &#125;public: static void change()&#123; tag += 12; &#125; void change1()&#123; this -&gt; change(); &#125;&#125;;// 静态属性在 c++ 中必须要初始化，初始化必须这么写int Student::tag = 12;void main()&#123; Student stu; // stu.tag = 12; // c++ 操作静态语法 :: // Student::tag += 12; // Student::change(); stu.change1(); cout &lt;&lt; Student::tag &lt;&lt; endl; getchar();&#125;//总结：// 静态 可以直接用类名去操作 :: // 静态的属性必须要初始化 （实现）// 静态的方法只能去操作静态的属性或者方法 10.类的大小 123456789101112131415161718192021222324252627282930313233343536373839404142class A&#123;public: double b; int a; char c;&#125;;class B&#123;public: double b; int a; char c; static double d;&#125;;class C&#123;public: double b; int a; char c; C(int a)&#123; this-&gt;a = a; &#125;public: int getA()&#123; return this-&gt;a; &#125;&#125;;// 1. 对象的大小与结构体的计算方式类似// 2. static 静态变量和方法并没有算到类的大小中// 3. 栈，堆，全局（静态，常量，字符串），代码区 ，类的大小只与普通属性有关系void main()&#123; cout &lt;&lt; &quot;A 的大小：&quot; &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; &quot;B 的大小：&quot; &lt;&lt; sizeof(B) &lt;&lt; endl; cout &lt;&lt; &quot;C 的大小：&quot; &lt;&lt; sizeof(C) &lt;&lt; endl; C c1(12); C c2(24); cout &lt;&lt; c1.getA() &lt;&lt; endl; cout &lt;&lt; c2.getA() &lt;&lt; endl; getchar();&#125; const 修饰函数 1234567891011121314151617181920212223242526// this 指针：代表当前的对象，因为类的方法存放在代码区，大家一起共享的，所以要有 this 做区分class Student&#123;public: char* name; int age;public: // this = const Student *const this // 第一个 const ：常量指针，代表值不能修改 // 第二个 const ：指针常量，代表指针的地址不能修改 void change() const&#123;// const 在() 之后主要用来限制 this 关键字 // this -&gt; age += 12; // 不能对类的属性进行修改 // this = (Student*)0x0012; &#125; // this = Student *const this void change1()&#123; // this = (Student*)0x0012; &#125;&#125;;// 5. const 修饰函数void main()&#123; Student stu; stu.change(); cout &lt;&lt; stu.age &lt;&lt; endl; getchar();&#125; 12.友元函数和类 12345678910111213141516171819202122232425262728class Person&#123; private: int age = 0;public: // 如果有自己写构造函数，那么会默认覆盖无参的构造函数 Person(int age)&#123; this-&gt;age = age; &#125; int getAge()&#123; return this-&gt;age; &#125; // 友元函数的声明 friend void friend_change(Person *person, int age);&#125;;// 友元函数的实现void friend_change(Person *person, int age)&#123; // 修改一下 age 的值 // 在类的内部才能访问私有属性 // 如果该方法声明成友元函数那么是可以在外部访问其私有属性的 person-&gt;age = age;&#125;void main()&#123; Person person = Person(24); friend_change(&amp;person,36); cout &lt;&lt; person.getAge() &lt;&lt; endl; getchar();&#125; 13.友元函数与普通函数的区别 Student.h 12345678910111213141516171819202122232425262728293031323334#ifndef STUDENT_H#define STUDENT_Hclass Student&#123;private: int age; char* name;public: // 静态属性的声明 static int tag;public: Student(); Student(char* name); Student(char* name,int age); // 析构函数 ~Student(); // 拷贝构造函数 Student(const Student&amp; stu);public: void setAge(int age); void setName(char* name); int getAge(); char* getName(); void print() const; // 静态和友元 static void changeTag(int tag); friend void changeAge(Student *stu,int age);&#125;;#endif // STUDENT_H Student.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;Student.h&quot;#include &lt;iostream&gt;// 一个一个来实现int Student::tag = 0;// 构造函数Student::Student(char* name) :Student(name,0)&#123;// :age(0) 赋默认值 this-&gt;name = name;&#125;Student::Student(char* name,int age)&#123; this-&gt;name = name; this-&gt;age = age;&#125;// 析构和拷贝构造函数// 析构函数Student::~Student()&#123; &#125;// 拷贝构造函数Student::Student(const Student&amp; stu)&#123; &#125;// 普通方法void Student::setAge(int age)&#123; this-&gt;age = age;&#125;void Student::setName(char* name)&#123; this-&gt;name = name;&#125;int Student::getAge()&#123; return this-&gt;age;&#125;char* Student::getName()&#123; return this-&gt;name;&#125;void Student::print() const&#123; std::cout &lt;&lt; this-&gt;name &lt;&lt; &quot; , &quot; &lt;&lt; this-&gt;age &lt;&lt; std::endl;&#125;// 静态和友元void Student::changeTag(int tag_replace)&#123; tag = tag_replace;&#125;// 实现友元方法void changeAge(Student *stu, int age)&#123; stu-&gt;age = age;&#125; Simple.cpp 12345678910111213#include &lt;iostream&gt;#include &lt;stdarg.h&gt;using namespace std;#include &quot;Student.h&quot;void main()&#123; Student *stu = new Student(&quot;Darren&quot;,24); // Student::changeTag(36); changeAge(stu,36); stu-&gt;print(); delete(stu); getchar();&#125; 14.友元类 1234567891011121314151617181920212223242526class ImageView&#123;public: // B 是 A 的友元类 friend class Class;private: int a;&#125;;class Class&#123;public: ImageView aObj; void changeA(int number)&#123; aObj.a = number;//拿到友元类的私有属性 &#125; int getA()&#123; return aObj.a; &#125;&#125;;void main()&#123; Class b; b.changeA(12); cout &lt;&lt; b.getA() &lt;&lt; endl; getchar();&#125; 15.operator重载运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;using namespace std;/*class Vector&#123;public: Vector(int x, int y)&#123; this-&gt;x = x; this-&gt;y = y; &#125; Vector(const Vector &amp;vector)&#123; this-&gt;x = vector.x; this-&gt;y = vector.y; cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl; &#125;private: int x; int y;public: void setX(int x)&#123; this-&gt;x = x; &#125; void setY(int y)&#123; this-&gt;y = y; &#125; int getX()&#123; return this-&gt;x; &#125; int getY()&#123; return this-&gt;y; &#125; // 重载减号运算符 // 为什么要用引用，为了防止重复创建对象 // const 关键常量，为了防止去修改值 Vector operator - (const Vector &amp;vector)&#123; int x = this-&gt;x - vector.x; int y = this-&gt;y - vector.y; Vector res(x, y); return res;// 不建议返回引用 &#125; // 自增减运算符 void operator ++ ()&#123;// ++X this-&gt;x = this-&gt;x++; this-&gt;y = this-&gt;y++; &#125; void operator ++ (int)&#123;// X++ this-&gt;x = this-&gt;x++; this-&gt;y = this-&gt;y++; &#125; // 自减 // 输出运算符 friend ostream &amp; operator &lt;&lt; (ostream &amp;_Ostr, const Vector &amp;vector)&#123; _Ostr &lt;&lt; vector.x &lt;&lt; &quot;,&quot; &lt;&lt; vector.y &lt;&lt; endl; return _Ostr; &#125; // 条件运算符 bool operator == (const Vector &amp;vector)&#123; return (this-&gt;x == vector.x &amp;&amp; this-&gt;y == vector.y); &#125; // 括号运算符&#125;;// 定义在类的外面，一般来讲我们定义在类的里面// 重载运算 + ：operator +Vector operator + (Vector vector1, const Vector vector2)&#123; int x = vector1.getX() + vector2.getX(); int y = vector1.getY() + vector2.getY(); Vector vector(x,y); return vector;&#125;void main()&#123; Vector vector1(2, 3); Vector vector2(2, 3); // java 中 string + string // char* str = &quot;123&quot; + &quot;456&quot;; // 重载运算符 + // Vector vector = vector1 - vector2; // Vector vector(1, 2); // vector++; // ++vector; // cout &lt;&lt; vector.getX() &lt;&lt; &quot; , &quot; &lt;&lt; vector.getY() &lt;&lt; endl; // cout &lt;&lt; vector &lt;&lt; vector; bool isEqual = vector1 == vector2; cout &lt;&lt; isEqual &lt;&lt; endl; // 可以重载加其他对象 Person getchar();&#125; 16.括号运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 括号运算符class Array&#123;public: Array(int size)&#123; this-&gt;size = size; this-&gt;array = (int*)malloc(sizeof(int)*size); &#125; ~Array()&#123; if (this-&gt;array)&#123; free(this-&gt;array); this-&gt;array = NULL; &#125; &#125; Array(const Array&amp; array)&#123; this-&gt;size = array.size; this-&gt;array = (int*)malloc(sizeof(int)*array.size); // 值的赋值 for (int i = 0; i &lt; array.size; i++) &#123; this -&gt; array[i] = array.array[i]; &#125; &#125;private: int size; int* array;public: void set(int index,int value)&#123; array[index] = value; &#125; int get(int index)&#123; return this-&gt;array[index]; &#125; int getSize()&#123; return this-&gt;size; &#125; // 操作符[] int operator[](int index)&#123; return this-&gt;array[index]; &#125;&#125;;void printfArray(Array array)&#123; for (int i = 0; i &lt; array.getSize(); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; endl; &#125;&#125;void main()&#123; Array *array = new Array(5); array-&gt;set(0,0); array-&gt;set(1, 1); array-&gt;set(2, 2); printfArray(*array); delete(array); getchar();&#125; 17.类继承 123456789101112131415161718192021222324252627282930313233343536373839404142class Person&#123; // 变量修饰符public:// 本类中使用 // protected ：子类中能使用 （默认） // public ：公开，任何地方都可以 char* name; int age;public: Person(char* name,int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; &quot;Person 构造函数&quot; &lt;&lt; endl; &#125;public: void print()&#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot; , &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125;&#125;;// 类继承 语法 : // 类继承修饰符 publicclass Student : public Person&#123;public: // : Person(name,age) 调用构造函数初始化父类的属性 Student(char* name,int age):Person(name,age)&#123;// 调用父类构造函数 cout &lt;&lt; &quot;Student 构造函数&quot; &lt;&lt; endl; &#125; void test()&#123; print(); &#125;&#125;;void main()&#123; Student stu(&quot;Darren&quot;,24); stu.name = &quot;Jack&quot;; getchar();&#125; 18.类继承修饰符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 初始化属性class Person&#123; // 变量修饰符public:// 本类中使用 // protected ：子类中能使用 （默认） // public ：公开，任何地方都可以 char* name; int age;public: Person(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; &quot;Person 构造函数&quot; &lt;&lt; endl; &#125;public: void print()&#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot; , &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;private: char* course;public: // : Person(name,age) 调用构造函数初始化父类的属性 // 不光可以给父类初始化属性，还可以给本类的属性进行初始化，用 , 隔开即可 Student(char* name, int age, char* course) :Person(name, age), course(course)&#123;// 调用父类构造函数 cout &lt;&lt; &quot;Student 构造函数&quot; &lt;&lt; endl; &#125; void print()&#123; cout &lt;&lt; &quot;course: &quot; &lt;&lt; course &lt;&lt; endl; &#125;&#125;;class Teacher: public Person&#123;public: Teacher(char*name,int age):Person(name,age)&#123; &#125;&#125;;void main()&#123; Student stu(&quot;Darren&quot;,24,&quot;语文&quot;); stu.print(); getchar();&#125; 19.属性初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;// 1. 属性初始化/*class Person&#123;protected:char* name;int age;public:Person(char* name, int age)&#123;this-&gt;name = name;this-&gt;age = age;&#125;&#125;;class Course&#123;private:// java Stringstring name;public:Course(string name)&#123;this-&gt;name = name;&#125;public:string _name()&#123;return this-&gt;name;&#125;&#125;;class Student : public Person&#123;private:// char* courseName;Course course;public:Student(char* name, int age, string courseName) : Person(name, age), course(courseName)&#123; // 初始化父类的属性// this-&gt;courseName = courseName;&#125;void print()&#123;cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; &quot;,&quot; &lt;&lt; course._name().c_str() &lt;&lt; endl;&#125;&#125;;void main()&#123; Student *stu = new Student(&quot;Darren&quot;,24,&quot;math&quot;); delete stu; getchar();&#125; 20.多继承 123456789101112131415161718192021222324252627282930313233343536class Person&#123;private: char * name;public: Person(char * name)&#123; this-&gt;name = name; &#125; char* _name()&#123; return this-&gt;name; &#125;&#125;;class Child&#123; int age;public: Child(int age)&#123; this-&gt;age = age; &#125; int _age()&#123; return this-&gt;age; &#125;&#125;;class Student : public Person, public Child // 多继承 , 并没有实现&#123;public: Student(char* name,int age):Person(name),Child(age)&#123; &#125;&#125;; void main()&#123; // 构造函数：先父类 -&gt; 再子类 // 析构函数：先子类 -&gt; 再父类 Student *stu = new Student(&quot;Darren&quot;,24); delete stu; getchar();&#125; 21.多继承-二义性(virtual虚继承) 1234567891011121314151617class A&#123;public: char* name;&#125;;class B : virtual public A&#123; //不加virtual会运行时报错，virtual确保继承过来的相同属性或者函数，只存在一份拷贝&#125;;class C :virtual public A&#123;&#125;;class D : public B ,public C&#123;&#125;;void main()&#123; D d; d.name=&quot;darren&quot;; cout&lt;&lt;d.name&lt;&lt;endl; getchar();&#125; 22.多态 123456789101112131415161718192021222324252627282930313233343536373839404142class Activity&#123;public: virtual void onCreate()&#123; // 支持多态，虚函数 cout &lt;&lt; &quot;Activity 中的 onCreate&quot; &lt;&lt; endl; &#125;&#125;;class MainActivity : public Activity&#123;public: void onCreate()&#123; cout &lt;&lt; &quot;MainActivity 中的 onCreate&quot; &lt;&lt; endl; &#125;&#125;;class WelcomeActivity : public Activity&#123;public: void onCreate()&#123; cout &lt;&lt; &quot;WelcomeActivity 中的 onCreate&quot; &lt;&lt; endl; &#125;&#125;;void startActivity(Activity* activity)&#123; activity-&gt;onCreate();&#125;void main()&#123; Activity *activity1 = new MainActivity();// 父类 = new 子类对象 Activity *activity2 = new WelcomeActivity(); // activity-&gt;onCreate(); // c++ 中的多态是怎样的，默认情况下不存在 // 父类指向子类的引用，重写 ，里氏替换原则 // 程序在编译期间并不知晓运行的状态（我需要运行那个函数），只要在真正运行的过程中才会去找需要运行的方法 startActivity(activity1); startActivity(activity2); // c++ 多态：动态多态(子父类)，静态多态（函数的重载）（编译过程确定性的区别） getchar();&#125; 23.继承中的抽象类 123456789101112131415161718192021222324252627282930// java 中类似的 抽象类，接口 纯虚函数class BaseActivity // 跟 java 中的抽象类一个概念&#123;public: void onCreate()&#123;// 普通函数 initView(); initData(); &#125; // 子类必须要实现 virtual void initData() = 0;// 虚函数，声明，没有实现的，类似于 java 中的抽象方法，如果子类不实现会报错 virtual void initView() = 0;&#125;;// 如果不实现父类的纯虚函数，那么 MainActivity 也会变成抽象类，抽象类不允许实例化class MainActivity : public BaseActivity &#123;public: void initData()&#123;//实现 cout &lt;&lt; &quot;initData&quot; &lt;&lt; endl; &#125; void initView()&#123; cout &lt;&lt; &quot;initView&quot; &lt;&lt; endl; &#125;&#125;;void main()&#123; BaseActivity *m_a = new MainActivity(); m_a-&gt;onCreate(); getchar();&#125; 24.接口 123456789101112131415161718192021222324252627282930313233class ClickListener&#123;// 所有的函数都是虚函数，那么就可以认为是接口public: virtual void click() = 0;&#125;;class ImageClickListener : public ClickListener&#123;public : void click()&#123; cout &lt;&lt; &quot;图片点击&quot; &lt;&lt; endl; &#125;&#125;;void click(ClickListener *listener)&#123; listener-&gt;click();&#125;void click()&#123; cout &lt;&lt; &quot;click点击&quot; &lt;&lt; endl;&#125;// 函数指针 07 次void click(void(*c)())&#123;// 函数指针作为参数传递 返回值(函数名)(参数) // 压缩开始 c();// 输出压缩进度 // 压缩结束&#125; void main()&#123; // 函数指针的时候：回调可以用 指针函数作为回调，纯虚函数类进行回调（接口） // ClickListener *listener = new ImageClickListener(); // listener-&gt;click(); // click(listener); // 自己再去了解加深一下 click(click); getchar();&#125; 25.构造函数和析构函数 12345678910111213141516171819202122232425262728293031323334class Person&#123;protected: char* name; int age;public: Person(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; &quot;Person 的构造函数&quot; &lt;&lt; endl; &#125; ~Person()&#123; cout &lt;&lt; &quot;Person 的析构函数&quot; &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;public: Student(char* name, int age) : Person(name, age)&#123; // 初始化父类的属性 cout &lt;&lt; &quot;Student 的构造函数&quot; &lt;&lt; endl; &#125; ~Student()&#123; cout &lt;&lt; &quot;Student 的析构函数&quot; &lt;&lt; endl; &#125;&#125;;void main()&#123; // 构造函数：先父类 -&gt; 再子类 // 析构函数：先子类 -&gt; 再父类 Student *stu = new Student(&quot;Darren&quot;,24); delete stu; getchar();&#125; 26.模版函数（java 中的泛型） 123456789101112131415161718192021222324252627int add(int number1, int number2)&#123; return number1 + number2;&#125;double add(double number1, double number2)&#123; return number1 + number2;&#125;float add(float number1, float number2)&#123; return number1 + number2;&#125;// 模板函数 算法4 看一遍敲一遍// 当普通函数和模板函数同时存在的时候，优先会调用普通函数template &lt;typename T&gt;// 模板函数的定义T add(T number1, T number2)&#123; return number1 + number2;&#125; void main()&#123; int sum1 = add(1,2); cout &lt;&lt; sum1 &lt;&lt; endl; int sum2 = add(1.0, 2.0); cout &lt;&lt; sum2 &lt;&lt; endl; int sum3 = add(1.0f, 2.0f); cout &lt;&lt; sum3 &lt;&lt; endl; getchar();&#125; &#x2F;&#x2F;day25 27.模板类 语法，跟模板函数非常类型 1234567891011121314151617181920212223242526template &lt;typename T&gt;class Callback&#123;public: void onError()&#123; &#125; void onSucceed(T result)&#123; cout &lt;&lt; result &lt;&lt; endl; &#125;&#125;;// 模板类继承 ，子类如果也是模板类// 如果子类不是模板类class HttpCallback : public Callback&lt;int&gt;&#123;&#125;;template &lt;class T&gt;class HttpCallback : public Callback&lt;T&gt;&#123;&#125;;void main()&#123; HttpCallback&lt;int&gt; *callback = new HttpCallback&lt;int&gt;(); callback-&gt;onSucceed(12); getchar();&#125; 28.类型转换 123451.1 static_cast 静态转换 用于基本数据类型之间的转换，如把int转换成char1.2 const_cast 常量转换 用于修改常量的值1.3 reinterpret_cat 强制类型转换 ，用于转换任意类型1.4 dynamic_cast 动态转换 ，更安全，转换成功返回类型，失败返回空 ， 必须要包含多态类型和 static_cast 很类似，但是更安全 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class Person&#123;public: string name; int age;public: Person(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125;&#125;;class Student : public Person&#123;public: Student(string name, int age) : Person(name,age)&#123; &#125;&#125;;class Worker : public Person&#123;&#125;;void main()&#123; double number1 = 20.02; // 直接转换 // int number2 = number1; // 1. 用于基本数据类型之间的转换，如把int转换成char // int number2 = static_cast&lt;int&gt;(number1); // cout &lt;&lt; number2 &lt;&lt; endl; // 2. 把类型转换成另一种类型，用于类层次结构中基类和派生类之间指针或引用的转换 // Student *stu = new Student(&quot;Darren&quot;,24); // jobejct -&gt; objectArray // Person *person = stu; // Person *person = static_cast&lt;Person *&gt;(stu); // 待会再试 Person person = Person(&quot;Darren&quot;, 24); // 转成Student // Student stu = person; cout &lt;&lt; person.name.c_str() &lt;&lt; &quot; , &quot; &lt;&lt; person.age &lt;&lt; endl; getchar();&#125; 29.异常的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445// NDK 异常总结// 1. 在 c++ 层如果是自己写的代码或者调用别人的方法，记得要 try 住， 如果不 try 在 java 层 try 是没有意义的// 2. 如果异常需要往外抛给 java 层，一定要按照java层抛异常的方式// 3. 如果是自己写的 NDK 层的代码，最好抛自己写的异常，声明异常// 4. 如果是做 c++/c , 或者是帮 c/c++ 写代码，最好抛系统定义好的异常或者继承系统的异常// 5. 系统异常的体系 exception 基类 https://www.cnblogs.com/QG-whz/p/5136883.htmlclass Exception&#123;public: string msg;public: Exception(string msg)&#123; this-&gt;msg = msg; &#125;public: const char *what()&#123; return this-&gt;msg.c_str(); &#125;&#125;;// 异常的处理void main()&#123; // c++ 中有自己一套异常的体系，不要去强记 // 但是 c++ 可以抛任何数据类型 try&#123;&#125;catch(数据类型 变量名)&#123;&#125; // throw 抛异常 try&#123; int i = -1; if (i == 0)&#123; throw Exception(&quot;出异常了&quot;); &#125; if (i&lt; 0)&#123; throw 12.5f; &#125; &#125; catch (int number)&#123; cout &lt;&lt; &quot;捕捉到异常&quot; &lt;&lt;number &lt;&lt; endl; &#125; catch (Exception exception)&#123; cout &lt;&lt; &quot;捕捉到异常:&quot; &lt;&lt; exception.what() &lt;&lt; endl; &#125; catch (...)&#123; cout &lt;&lt; &quot;捕捉到其他异常:&quot; &lt;&lt; endl; &#125; getchar();&#125; 30字符串 123456789101112131415161718192021222324void main()&#123; // C++ STL(Standard Template Library) 准模板库 ：容器 + 迭代器 + 算法 // 1. 对象的构建 string str1 = &quot;123&quot;; string str2(&quot;123&quot;); string str3(5, &#x27;A&#x27;);// 5 个 A = AAAAA string *str4 = new string(&quot;123&quot;); // cout &lt;&lt; str1.c_str() &lt;&lt;endl; // cout &lt;&lt; str2.c_str() &lt;&lt; endl; // cout &lt;&lt; str3.c_str() &lt;&lt; endl; // cout &lt;&lt; str4-&gt;c_str() &lt;&lt; endl; // string 与 char* 相互之间转换 c_str() // const char* c_str1 = str1.c_str(); // cout &lt;&lt; c_str1 &lt;&lt; endl; // char* -&gt; string char* c_str = &quot;Darren&quot;; string str(c_str);// 对象 cout &lt;&lt; str.c_str() &lt;&lt; endl; getchar();&#125; 31.字符串遍历 1234567891011121314151617181920212223242526272829303132#define D_SCL_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;void main()&#123; string str(&quot;1234567&quot;); // 1. 字符串的遍历 for (int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125; // 迭代器遍历 for (string::iterator it = str.begin(); it &lt; str.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; try&#123; for (int i = 0; i &lt; str.length()+2; i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; endl;// 如果越界会抛异常 &#125; for (int i = 0; i &lt; str.length()+2; i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl;// 会导致程序宕机，AS里面是可以的 &#125; &#125; catch (...)&#123; cout &lt;&lt; &quot;异常了&quot; &lt;&lt; endl; &#125; getchar();&#125; 32.字符串添加，删除，替换，查找，大小写转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void main()&#123; // 添加 string str1 = &quot;123&quot;; string str2 = &quot;456&quot;; // str1 = str1 + str2; // str1.append(str2); cout &lt;&lt; str1.c_str() &lt;&lt; endl; // 删除 string str1 = &quot;123 abc 123 abc 123&quot;; // str1.erase(0,3);// 第一个参数：从哪里开始 ； 第二个参数：删除几个（默认值，字符串的结尾） // 迭代器删除 2 bc 123 abc 123 解释 for (string::iterator it = str1.begin(); it&lt;str1.begin()+3; it++)// 删除一个字后都会从头开始计算 &#123; str1.erase(it); &#125; cout &lt;&lt; str1.c_str() &lt;&lt; endl; //替换 string str1 = &quot;123 abc 123 abc 123&quot;; // 第一个参数：从哪里开始 // 第二个参数：替换几个 // 第三个参数：替换成谁 str1.replace(0,6,&quot;1234&quot;); cout &lt;&lt; str1.c_str() &lt;&lt; endl; //查找 string str1 = &quot;123 abc 123 abc 123&quot;; // 查找谁，从哪里开始 // int position = str1.find(&quot;123&quot;,0); // 从后面往前面查 int position = str1.rfind(&quot;123&quot;); cout &lt;&lt; position &lt;&lt; endl; //#include &lt;algorithm&gt;// STL 算法包 //#include &lt;cctype&gt; //大小写转换 string str1 = &quot;AAA abc BBB abc 123&quot;; // 转换成大写 // transform(str1.begin(), str1.end(), str1.begin(), toupper); transform(str1.begin(), str1.end(), str1.begin(), tolower); cout &lt;&lt; str1.c_str() &lt;&lt; endl; getchar();&#125; 33.vector 数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;functional&gt;#include &lt;set&gt;using namespace std;/*void main()&#123; // vector 数组 // vector // 1. vector&lt;int&gt; v; // 2. vector&lt;int&gt; v(10); // 3. vector&lt;int&gt; v(10,0); vector&lt;int&gt; v; // 插入数据 // v.begin() 迭代器的开始位置 v.insert(v.begin(),12); v.insert(v.begin(), 22); v.insert(v.begin(), 32); v.insert(v.end(), 42); // 引用当左值当右值 (修改) v.front() = 33;//最前 v.back() = 44;//最后 v.push_back(55);//最后处添加 // 移除最后的元素，并没有返回值 // v.pop_back(); // 通过迭代器位置进行移除 v.erase(v.begin()); // 获取数据 for 循环 for (int i = 0; i &lt; v.size(); i++) &#123; cout &lt;&lt; v[i] &lt;&lt; &quot;\\t&quot;;// 越界程序宕机 &#125; cout &lt;&lt; endl; // for (int i = 0; i &lt; v.size(); i++) &#123; cout &lt;&lt; v.at(i) &lt;&lt; &quot;\\t&quot;; // 越界抛异常 out_of_range &#125; cout &lt;&lt; endl; // 通过迭代器 for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot;\\t&quot;; // 越界抛异常 out_of_range &#125; cout &lt;&lt; endl; getchar();&#125; 34.stack 栈， 先进后出 (链表，数组) 123456789101112131415161718192021222324252627282930313233343536void main()&#123; stack&lt;int&gt; s; // 压栈 ，压入指定位置 s.push(12); s.push(22); s.push(32); // 并不能够通过角标去插入获取值，如果在开发的过程中如果的确需要通过角标去获取值，需要自定义 for (int i = 0; i &lt; s.size(); i++) &#123; cout &lt;&lt; s. &lt;&lt; endl; &#125; // 迭代器也没有，并不支持循环的 ，非得循环 for (stack&lt;int&gt;::iterator it; i &lt; s.size(); i++) &#123; cout &lt;&lt; s. &lt;&lt; endl; &#125; int top = s.top(); cout &lt;&lt; top &lt;&lt; endl; // 弹出栈顶 s.pop(); top = s.top(); cout &lt;&lt; top &lt;&lt; endl; while (!s.empty()) &#123; int top = s.top(); cout &lt;&lt; top &lt;&lt; endl; s.pop(); &#125; getchar();&#125; 35.queue 队列 ，先进先出(链表，数组) 12345678910111213141516171819202122void main()&#123; queue&lt;int&gt; q; q.push(12); q.push(44); q.push(32); q.front() = 42; cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; q.front() &lt;&lt; endl; // 最后，最后加入的 int back = q.back(); cout &lt;&lt; back &lt;&lt; end while (!q.empty()) &#123; cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); &#125; getchar();&#125; 36.优先级队列 (数据结构 数组，排序的方式堆排序) 12345678910111213//priority_queue优先队列是一种容器适配器，采用了堆这样的数据结构，保证了第一个元素总是整个优先队列中最大的(或最小的)元素。void main()&#123; // int 存放的数据 vector&lt;int&gt; 数据类型（数组） greater 从大到小 less 从小到大 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; pq.push(12); pq.push(44); pq.push(32); pq.push(10); // 最大值 cout &lt;&lt; pq.top() &lt;&lt; endl; getchar();&#125; 37.list 链表, 双向链表(有没有回环) 12345678910111213141516171819202122void main()&#123; list&lt;int&gt; l; // 插入 l.push_front(11); l.push_back(22); l.insert(l.begin(),10); // 修改 l.back() = 33; l.front() = 44; // 不能通过角标去访问，也不能去修改 // 移除 l.erase(l.begin()); l.pop_front(); l.pop_back(); // 循环 for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; getchar();&#125; 38.set 容器（红黑树结构） ，会对你存入的数据进行排序，但是不允许元素相同 12345678910111213141516171819202122232425262728void main()&#123; // set&lt;int,less&lt;int&gt;&gt; s;// 从小到大排序 ，默认就是 less set&lt;int, greater&lt;int&gt;&gt; s;//从大到小排序 // 添加参数 , 不需要用迭代器，也不需要指定位置 s.insert(3); s.insert(5); s.insert(4); // 重复的插入，并不会报错，返回两个值 插入迭代器的位置 ，是否插入成 pair&lt;set&lt;int, greater&lt;int&gt;&gt;::iterator, bool&gt; res = s.insert(5); // res.first; 获取第一个参数 bool insert_succeed = res.second; if (insert_succeed)&#123; cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; endl; &#125; // int count = s.count(5); // s.find(); for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; getchar();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Student&#123;public: string name; int grade;public: Student(string name, int grade)&#123; this-&gt;name = name; this-&gt;grade = grade; &#125;&#125;;// 谓词（函数谓词） ：按找特定的规则所编写的函数谓词 bool compare(const Student&amp; _Left, const Student&amp; _Right)&#123; return _Left.grade &gt; _Right.grade;&#125;// 函数对象 仿函数struct comparefuction&#123; // 函数重载了 () 运算符，函数对象，仿函数 bool operator()(const Student&amp; _Left, const Student&amp; _Right) const&#123; return _Left.grade &gt; _Right.grade; &#125;&#125;;// 基本数据类型 ，对象数据类型void main()&#123; set&lt;Student, comparefuction&gt; s; Student s1(&quot;Darren1&quot;, 2); Student s2(&quot;Darren2&quot;, 9); Student s3(&quot;Darren3&quot;, 5); s.insert(s1); s.insert(s2); s.insert(s3); for (set&lt;Student&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; it-&gt;name.c_str() &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;grade &lt;&lt; endl; &#125; getchar();&#125; 39.multiset容器 , 允许重复 ，用法和 set 一样 123456789101112131415161718void main()&#123; // set&lt;int,less&lt;int&gt;&gt; s;// 从小到大排序 ，默认就是 less multiset&lt;int, greater&lt;int&gt;&gt; ms; // 添加参数 , 不需要用迭代器，也不需要指定位置 ms.insert(3); ms.insert(5); ms.insert(4); ms.insert(4); ms.insert(3); for (set&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; getchar();&#125; 40.map 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; // 预定义函数 ，已经实现好的一些算法头文件using namespace std;/*void main()&#123; // map 会对 key 排序 ，二叉树算法 map&lt;int, string&gt; map1; // 添加数据 - 第一种 map1.insert(pair&lt;int,string&gt;(01,&quot;01&quot;)); // 第二种方式 map1.insert(make_pair(02,&quot;02&quot;)); // 第三种方式 map1.insert(map&lt;int,string&gt;::value_type(03,&quot;03&quot;)); // 区别，如果用前面三种 key 重复添加 ，不生效 // map1.insert(map&lt;int, string&gt;::value_type(03, &quot;30&quot;)); // 第四种方式 = map1[key] = value map1[04] = &quot;04&quot;; //常用的是第一种和第四种 // 第四种是会覆盖的 map1[04] = &quot;40&quot;; // 如果要判断添加是否成功 - 自己思考，参考上次课内容 map1[00] = &quot;00&quot;; // 循环 - 迭代器 for (map&lt;int,string&gt;::iterator it = map1.begin(); it != map1.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; (it-&gt;second).c_str() &lt;&lt; endl; &#125; cout &lt;&lt; &quot; 遍历结束&quot; &lt;&lt; endl; // 删除 ，查找 map&lt;int,string&gt;::iterator find_it = map1.find(0); // cout &lt;&lt; find_it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; (find_it-&gt;second).c_str() &lt;&lt; endl; if (find_it != map1.end())&#123; cout &lt;&lt; find_it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; (find_it-&gt;second).c_str() &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; &quot; 找不到 &quot; &lt;&lt; endl; &#125; getchar();&#125; 123456789101112131415161718192021222324252627282930313233343536373839//map案例void main()&#123; multimap&lt;int, string&gt; map1; // 案例，1 （11，12，13），2 （21，22，23），3（31，32，33） map1.insert(pair&lt;int, string&gt;(1,&quot;11&quot;)); map1.insert(pair&lt;int, string&gt;(1, &quot;12&quot;)); map1.insert(pair&lt;int, string&gt;(1, &quot;13&quot;)); map1.insert(pair&lt;int, string&gt;(3, &quot;31&quot;)); map1.insert(pair&lt;int, string&gt;(3, &quot;32&quot;)); map1.insert(pair&lt;int, string&gt;(3, &quot;33&quot;)); map1.insert(pair&lt;int, string&gt;(2, &quot;21&quot;)); map1.insert(pair&lt;int, string&gt;(2, &quot;23&quot;)); map1.insert(pair&lt;int, string&gt;(2, &quot;22&quot;)); // 遍历 for (map&lt;int, string&gt;::iterator it = map1.begin(); it != map1.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; (it-&gt;second).c_str() &lt;&lt; endl; &#125; cout &lt;&lt; &quot; 遍历结束&quot; &lt;&lt; endl; // 分组查询 多个数据 multimap&lt;int, string&gt;::iterator find_it = map1.find(3); while (find_it != map1.end())&#123; cout &lt;&lt; find_it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; (find_it-&gt;second).c_str() &lt;&lt; endl; find_it++; // 不是我们要找的内容 if (find_it == map1.end() || find_it -&gt; first != 3)&#123; break; &#125; &#125; getchar();&#125; 41.一元谓词，二元谓词，仿函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134class Person&#123;public: string name; char* test;public: Person()&#123;&#125; Person(string name)&#123; this-&gt;name = name; test = (char*)malloc(12); &#125; // 析构函数 ~Person()&#123; free(test); cout &lt;&lt; &quot;析构函数&quot;&lt;&lt; &amp;test &lt;&lt; endl; &#125;public: void setName(string name)&#123; this-&gt;name = name; &#125;private:&#125;;// 3. 容器对象拷贝构造函数 , 就想存同一对象，在任何地方改变，集合的数据也相应发生变 （指针）void main()&#123; // java 中把对象添加到了集合 // c++ 中会调用对象的拷贝构造函数，存进去的是另一个对象 // 第一个错误：没有默认的构造函数 // 第二个错误：析构函数也可能回调用多次，如果说在析构函数中释放内存，需要在拷贝构造函数中进行深拷贝 vector&lt;Person&gt; vector1; Person person(&quot;Darren&quot;); vector1.push_back(person); person.setName(&quot;Jack&quot;); Person person1 = vector1.front(); cout &lt;&lt; person1.name.c_str() &lt;&lt; endl; getchar();&#125;class Compare&#123; // 重载了括号运算符public: void operator()()&#123; cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl; &#125;&#125;;void compare1()&#123; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl;&#125;// 函数对象（仿函数） 一元谓词，二元谓词void main()&#123; Compare compare; // 跟函数非常类似 compare(); // 普通函数调用 compare1(); getchar();&#125;// 一元谓词void print(int number)&#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// 仿函数 - 一元谓词 （能够记录状态）class PrintObj&#123;public: int count = 0;public: void operator()(int number)&#123; cout &lt;&lt; number &lt;&lt; endl; count++; &#125;&#125;;// 回调函数和仿函数的区别void main() &#123; set&lt;int&gt; set1; set1.insert(1); set1.insert(2); set1.insert(3); set1.insert(4); // for_each 迭代器 ,非常重要的一点就是：仿函数如果要保存记录状态，要确保对象一致，可以用返回值 // for_each(set1.begin(),set1.end(),print); PrintObj printObj; printObj = for_each(set1.begin(), set1.end(), printObj); cout &lt;&lt; &quot;个数：&quot; &lt;&lt; printObj.count &lt;&lt; endl; getchar();&#125;class CompareObj&#123;public: int count = 0;public: bool operator()(const string str1, const string str2)&#123; return str1 &lt; str2; &#125;&#125;;void main()&#123; // 二元谓词的仿函数 set&lt;string, CompareObj&gt; set1; set1.insert(&quot;aaa&quot;); set1.insert(&quot;aAa&quot;); set1.insert(&quot;ccc&quot;); set1.insert(&quot;ddd&quot;); // 是否包含 aaa , 遍历比较 ， 找方法 for (set&lt;string&gt;::iterator it = set1.begin(); it != set1.end(); it++) &#123; cout &lt;&lt; (*it).c_str() &lt;&lt; endl; &#125; getchar();&#125; 42.预定义函数对象和函数适配器 p118-p121 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#define _SCL_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;using namespace std;/*// 自定义重载 () 运算符// 1. 预定义函数对象和函数适配器void main()&#123; // c/c++ 提供了很多定义好的函数对象 // 常见的几个 less ，greater，plus，equal_to plus&lt;string&gt; strAdd; string str = strAdd(&quot;aaa&quot;,&quot;bbb&quot;); // cout &lt;&lt; str.c_str() &lt;&lt; endl; set&lt;string, greater&lt;string&gt;&gt; set1; set1.insert(&quot;aaa&quot;); set1.insert(&quot;bbb&quot;); set1.insert(&quot;ccc&quot;); // 判断是不是包含 aaa // 怎么写仿函数，一定要确定好你的仿函数的参数 // bind2nd 函数适配器 , aaa 相当于 equal_to 中的 right template&lt;class _Ty = void&gt; struct multiplies : public binary_function&lt;_Ty, _Ty, _Ty&gt; &#123; // functor for operator* _Ty operator()(const _Ty&amp; _Left, const _Ty&amp; _Right) const &#123; // apply operator* to operands return (_Left * _Right); &#125; &#125; set&lt;string, greater&lt;string&gt;&gt;::iterator find_it = find_if(set1.begin(), set1.end(),bind2nd(equal_to&lt;string&gt;(),&quot;aaa&quot;)); if (find_it != set1.end())&#123; cout &lt;&lt; &quot;找到了&quot; &lt;&lt; (*find_it).c_str() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl; &#125; getchar();&#125;// 1，种方式自定义仿函数（函数对象）class Equal&#123;private: int equal_number;public: Equal(int equal_number)&#123; this-&gt;equal_number = equal_number; &#125;public: bool operator()(const int&amp; number)&#123; return number == equal_number; &#125;&#125;;void main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(2); vector1.push_back(4); vector1.push_back(2); // 找集合中 等于 2 的个数 int count = count_if(vector1.begin(), vector1.end(), Equal(2)); cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl; // 预定义好的函数对象 + 函数适配器 count = count_if(vector1.begin(), vector1.end(), bind2nd(equal_to&lt;int&gt;(),2)); cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl; getchar();&#125;void print(int number)&#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// 进行修改int transform_print(int number)&#123; // cout &lt;&lt; number &lt;&lt; endl; return number + 3;&#125;// foreach，transform，find，find_if，count，count_if，megre，sort，random_shuffle，copy，replace// 常用预定义算法 循环，增，删，改，查void main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(4); // for_each(vector1.begin(), vector1.end(),print); vector&lt;int&gt; vector2; vector2.resize(vector1.size()); transform(vector1.begin(), vector1.end(), vector2.begin(), transform_print); for_each(vector2.begin(), vector2.end(), print); getchar();&#125;// find，find_ifvoid main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(4); vector&lt;int&gt;::iterator find_it = find(vector1.begin(), vector1.end(), 2); if (find_it != vector1.end())&#123; cout &lt;&lt; &quot;包含&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不包含&quot; &lt;&lt; endl; &#125; // 有没有大于2的，自定义函数对象，预定义函数对象+函数适配器，省略... getchar();&#125;// count，count_ifvoid main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(2); vector1.push_back(4); int number = count(vector1.begin(), vector1.end(), 2); cout &lt;&lt; &quot;等于2的个数:&quot; &lt;&lt; number &lt;&lt; endl; number = count_if(vector1.begin(), vector1.end(), bind2nd(less&lt;int&gt;(), 2)); cout &lt;&lt; &quot;小于2的个数:&quot; &lt;&lt; number &lt;&lt; endl; number = count_if(vector1.begin(), vector1.end(), bind2nd(greater&lt;int&gt;(), 2)); cout &lt;&lt; &quot;大于2的个数:&quot; &lt;&lt; number &lt;&lt; endl; getchar();&#125;class _merge&#123;public: bool operator()(int number1,int number2)&#123; return true; &#125;&#125;;void print(int number)&#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// megre，sort，random_shuffle，copy，replacevoid main()&#123; // 两个有序数组进行合并 - 归并排序 vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector&lt;int&gt; vector2; vector1.push_back(4); vector1.push_back(5); vector1.push_back(6); vector&lt;int&gt; vector3; vector3.resize(6); merge(vector1.begin(), vector1.end(), vector2.begin(), vector2.end(), vector3.begin()); for_each(vector3.begin(), vector3.end(), print); getchar();&#125;void print(int number)&#123; cout &lt;&lt; number &lt;&lt; endl;&#125;void main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(3); vector1.push_back(2); vector1.push_back(4); sort(vector1.begin(),vector1.end(),less&lt;int&gt;()); for_each(vector1.begin(), vector1.end(), print); cout &lt;&lt; &quot;循环结束&quot; &lt;&lt; endl; // 打乱循序 random_shuffle(vector1.begin(), vector1.end()); for_each(vector1.begin(), vector1.end(), print); getchar();&#125;void print(int number)&#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// copy，replacevoid main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(4); vector&lt;int&gt; vector2; vector2.resize(2); copy(vector1.begin(), vector1.begin() + 2, vector2.begin()); // for_each(vector2.begin(), vector2.end(), print); replace(vector1.begin(), vector1.end(), 2, 22); for_each(vector1.begin(), vector1.end(), print); getchar();&#125;// 头部的封装 ToolBar 思考：自定义 View 4中样式 // 思考问题 ，方式去解决 NavigationBar (各种源码各种框架) // 过度设计 ：扩展性不高实用性不强 ，继承(代码)过于复杂，花哨 // 模板类 _InIt 名字 , _First, _Last , 返回值 是一个类型// _Pr _Pred 这是什么？template&lt;class _InIt,class _Pr&gt; inline _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)&#123; // find first satisfying _Pred _DEBUG_RANGE(_First, _Last); _DEBUG_POINTER(_Pred); return (_Rechecked(_First, _Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred))); &#125;template&lt;class _InIt,class _Pr&gt; inline _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)&#123; // find first satisfying _Pred for (; _First != _Last; ++_First) // if 返回值是一个 bool 类型 ，往 _Pred 里面传递了一个参数 ，要么就是回调函数要么就是仿函数 if (_Pred(*_First)) break; return (_First);&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/7_银行卡识别/","text":"1234567891011121314151617181. 基本概念计算机视觉，智能识别，机器学习2. 银行卡识别步骤：（拍照，照片）c/c++ 语法编程基础 （比较重要）opencv 常用基础 （较重要）图像的算法基础 （不是很重要） 2.1. 截取到银行卡区域（扫描，可以不要这一步） 2.2. 截取到银行卡号区域 2.3. 对银行卡号区域进行特征分析提取识别3. opencv 集成https://www.jianshu.com/p/fe8dbb9f72ef4. 截取到银行卡区域（扫描，可以不要这一步）思路：会有多种： 4.1. 轮廓增强（梯度增强） 4.2 进行二值化轮廓过滤 4.3 截取卡号区域 4.3.1 找到银联区域（精度强，90%） 4.3.2 可以直接截取卡号 （1/2,3/4）区域尽量大一些;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/8_算法/","text":"p122-p128 直接看项目源代码，opencv具体流程还是不够清楚； p129-p207讲的算法，过多未看； p208-p291 opencv及ndk实战 未看","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/1_c基础/","text":"NDK 学到什么程度，该怎么学 ? 123456c/c++ 少不了，基础，进阶，linux 内核，shell 脚本，cmake 语法opencv ，fmpeg ,opengl,android nativeandroid 开发:c/c++工程师开发(精通)，java 工程师(精通)，native 和 java 层互通 NDK 开发熟悉c++.熟悉android)知道:有这么个东西，你模糊熟悉:知道这个东西，讲明白，项目中也能直接用上精通:知道这个东西，讲明白，项目中也能直接用上，知道原理( 四种启动模式，怎么解析的，怎么压栈弹栈，声明周期怎调用的) fitst.cpp文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//#include &lt;unistd.h&gt;#include &lt;Windows.h&gt;//01默认格式// int main()// &#123;// printf(&quot;Hello World!\\n&quot;);// system(&quot;pause&quot;); // 防止运行后自动退出，需头文件stdlib.h// return 0;// &#125;//02打印输出// %d：用于输出整数。// %f：用于输出浮点数。// %c：用于输出字符。// %s：用于输出字符串。// %p：用于输出指针。// %x：用于输出十六进制数。//\\n换行// int main()&#123;// int a=100;// double b=100.1;// float c=100.2;// long d=200;// short e=200;// char f=&#x27;a&#x27;; // printf(&quot;a=%d\\n&quot;,a); // printf(&quot;b=%f\\n&quot;,b);// printf(&quot;c=%f\\n&quot;,c);// printf(&quot;d=%d\\n&quot;,d);// printf(&quot;e=%d\\n&quot;,e);// printf(&quot;f=%c\\n&quot;,f);// system(&quot;pause&quot;);// return 0;// //输出结果：// // a=100// // b=100.100000// // c=100.199997 // d=200 // e=200 // f=a// &#125;//03变量地址 &amp;代表取变量的地址// int main()&#123;// int a=100;// printf(&quot;a=%d\\n&quot;,a);//值// printf(&quot;a=%p\\n&quot;,&amp;a);//地址:a=000000000061FE1C// system(&quot;pause&quot;);// return 0;// &#125;// 04 指针变量和获取地址的值// int main()&#123;// int a=100;// int* p =&amp;a;// printf(&quot;p的值是：%d\\n&quot;, *p);//获取值// printf(&quot;p的值是：%d\\n&quot;, p);//获取地址// printf(&quot;p的值是：%d\\n&quot;, *(&amp;p));//获取地址// system(&quot;pause&quot;);// return 0;// &#125;// 05 通过指针修改值 // int main()&#123;// int a=100;// int* p=&amp;a;// printf(&quot;a=%d\\n&quot;,a);// printf(&quot;*p=%d\\n&quot;,*p);// *p=200;// printf(&quot;a1=%d\\n&quot;,a); //a1=200// printf(&quot;p1=%d\\n&quot;,*p);//p1=200// system(&quot;pause&quot;);// return 0;// &#125;// 06 方法修改值和指针修改值// void change(int i)&#123;// 通过方法修改值// printf(&quot;change1 中i的地址是：%p\\n&quot;,&amp;i);// i = 200;// &#125;// void changePoint(int* p)&#123;// 通过地址来修改// printf(&quot;change2中i的地址是：%p\\n&quot;,p);// *p = 300;// &#125;// int main()&#123;// int i = 100;// printf(&quot;i的地址是：%p\\n&quot;, &amp;i);// printf(&quot;i的值是：%d\\n&quot;, i);// change(i);//方法内值改变不影响传入的变量本身// changePoint(&amp;i);//指针方式方法内值改变改变的就是值本身，地址一致// system(&quot;pause&quot;);// &#125;// 07 题目：写个方法对两个值进行交换 // void change(int* a,int* b)&#123; // int temp = *a;// *a = *b;// a的值 = b 的值 // *b = temp;// &#125;// int main()&#123;// int a = 100;// int b = 200;// // 1 两个值进行交换 // // change(&amp;a,&amp;b);// // printf(&quot;就交换后ab的值分别是：%d,%d&quot;,a,b);// // 2 面试题：对 a,b 两个值进行交换，但是不开辟额外的内存（不能用中间变量） // a = a + b;// a = 300 // b = a - b;// b = 100 // a = a - b;// a = 200 // printf(&quot;就交换后ab的值分别是：%d,%d&quot;,a,b);// system(&quot;pause&quot;);// &#125;//08 指针地址改变// int main()&#123;// int a = 100;// int b = 200;// // a = b 把b变量的值复制给a// printf(&quot;a,b的地址分别是：%p,%p\\n&quot;,&amp;a,&amp;b);// //p1=a的地址,p2=b的地址// int* p1 = &amp;a;// int* p2 = &amp;b;// printf(&quot;p1,p2的地址分别是：%p,%p\\n&quot;, p1, p2);//打印指针不能加&amp;号不然变成int **了// p1 = p2;// 只是p1 的地址改了，并没有改动 a 的地址// printf(&quot;a,b的值分别是：%d,%d\\n&quot;, a, b);// printf(&quot;p1,p2的值分别是：%d,%d\\n&quot;, *p1, *p2);//打印指针的值// system(&quot;pause&quot;);// &#125;// 09 二级指针和多级指针// int main()&#123;// int num = 12;// // int* 指针 &amp; 取地址// int* p = &amp;num;// int** s_p = &amp;p;// 对一级指针取地址// printf(&quot;num 的地址是：%p\\n&quot;,&amp;num);//0023fe40// printf(&quot;p 的地址是：%p\\n&quot;,p);//0023fe40// printf(&quot;s_p 的地址是：%p\\n&quot;,s_p);//0061FE08// printf(&quot;s_p 的地址是：%p\\n&quot;,*s_p);//0023fe40,二级指针取地址// printf(&quot;s_p 的地址是：%p\\n&quot;,**s_p);//0000000C// printf(&quot;获取最终的值是：%d&quot;, **s_p);//12，二级指针取值// system(&quot;pause&quot;);// &#125; // 10 数组与数组指针 // int main()&#123;// int arr[] = &#123;1,2,3,4&#125;;// // 遍历数组, linux 就有问题// for (int i = 0; i &lt; 4;i++)&#123;// printf(&quot;%d\\n&quot;,arr[i]);// &#125;// // for循环在 c 和 C++ 中的正确写法// int i = 0;// for (; i &lt; 4; i++)&#123;// printf(&quot;%d\\n&quot;, arr[i]);// &#125;// // 看一种现象: arr 地址的值 = arr[0]的地址的值（首地址）// printf(&quot;arr&amp; = %p\\n&quot;, &amp;arr);//000000000061FE00// printf(&quot;arr[0]&amp; = %p\\n&quot;, &amp;arr[0]);//000000000061FE00// printf(&quot;arr[1]&amp; = %p\\n&quot;, &amp;arr[1]);//000000000061FE04 // int* arr_p = arr;// 数组指针指向的是数组的首地址// // 做一系列的操作// printf(&quot;%d\\n&quot;,*arr_p);//1// // 对指针进行 ++ // arr_p++;// printf(&quot;%d\\n&quot;, *arr_p);//2// // 指针再往后逻动两位// arr_p += 2;// printf(&quot;%d\\n&quot;, *arr_p);//4// system(&quot;pause&quot;);// &#125;//11 采用指针遍历数组循环赋值// int main()&#123;// int arr[] = &#123;1,2,3,4&#125;;// int* arr_p = arr;// int i = 0;// for (; i &lt; 4;i++)&#123;// printf(&quot;位置%d的值是：%d\\n&quot;, i, *(arr_p+i));// &#125;// system(&quot;pause&quot;);// &#125;// int main()&#123;// int arr[4];// 指定数组[4]// int* arr_p = arr;// int i = 0;// for (; i &lt; 4; i++)&#123;// *(arr_p + i) = i;// &#125;// i = 0;// for (; i &lt; 4; i++)&#123;// printf(&quot;位置%d的值是：%d\\n&quot;, i, arr[i]);// &#125;// system(&quot;pause&quot;);// &#125;// 12 指针为什么要有类型? 指针其实就是一块地址而且他的值都差不多// int main()&#123;// //原因是取值的时候我要知道怎么取，按4字节取，还是8字节或16字节去取，不同字节取出的值不一样；// int num = 12;// int* num_p = &amp;num;// printf(&quot;num_p=%d\\n&quot;,*num_p);//12// double* num_p_d = num_p;// printf(&quot;num_p=%d\\n&quot;,*num_p);//12// system(&quot;pause&quot;);// &#125;// 13函数指针// void add(int num1,int num2)&#123;// printf(&quot;num1 + num2 = %d\\n&quot;,(num1+num2));// &#125;// void mins(int num1, int num2)&#123;// printf(&quot;num1 - num2 = %d\\n&quot;, (num1 - num2));// &#125;// // 方法指针，传两个数 // void opreate(void(method)(int,int),int num1,int num2)&#123;// method(num1, num2);// &#125;// int main()&#123;// // add(1,2);// // 方法指针怎么定义？方法的返回(*方法的名称)(方法的参数)// opreate(add, 1, 2);// opreate(mins, 1, 2);// system(&quot;pause&quot;);// &#125;// 14 监听数据压缩回调// void call_back(int current,int total)&#123;// printf(&quot;压缩的进度是：%d/%d&quot;,current,total);// &#125;// void compress(char* file_name,void(*callback)(int,int))&#123;// callback(12,24);// &#125;// int main()&#123;// void(*call)(int, int);// 声明了一个函数// call = call_back;// 给函数指针赋值// // call(1,2);// 通过函数指针间接的调用call_back// compress(&quot;1.png&quot;, call);// system(&quot;pause&quot;);// &#125;// day08 // 15 生成随机数// int main()&#123;// // 可以随机但是每次运行，随机数都一致，解决的方式就是初始化发生器// // 初始化随机发生器, 每次发生器都是当前时间，啰嗦，实用场景，在 C 层生成秘钥（安全）// srand((unsigned)time(NULL));//初始化发生器// int i;// for (i = 0; i&lt;10; i++)// printf(&quot;%d\\n&quot;, rand() % 100);// system(&quot;pause&quot;);// &#125; //16 静态内存开辟// void staticlloc()&#123;// int arr[5];// 静态开辟，静态开辟内存内存大小无法更改，使用后自动回收// int i = 0;// for (; i &lt; 5; i++)// &#123;// arr[i] = i;// printf(&quot;%d, %p\\n&quot;, *(arr + i), arr + i);// &#125;// &#125;// int main()&#123;// // Stack overflow 栈溢出 如何判断一块内存中有没有写入数据，判 NULL？，判越界// // int arr[10*1024*1024];// 占用内存是多少？ 大小？10M数组大小， int占用4字节，40M空间// // c 有分区，四驱模型，栈，堆// // 栈：占用内存空间最大值 2M ，开辟内存的方式是静态内存开辟 int arr[10*1024*1024]，方法结束会自动回收// // 堆：占用内存空间最大值 80% ，开辟内存的方式是动态内存开辟 ，不会自动回收必须手动回收（内存不再使用的时候一定要手动回收）// while (true)// &#123;// Sleep(500);// staticlloc();// &#125;// system(&quot;pause&quot;);// &#125;//17 动态内存开辟// void dynamiclloc()&#123;//malloc动态开辟内存// int* arr = (int*)malloc(1 * 1024 * 1024 * sizeof(int)); // 40M// // 第二个重要的方法，手动释放 free , 释放arr这一块内存// free(arr);// &#125;// int main()&#123;// // int arr[10 * 1024 * 1024];// // 操作// while (true)// &#123;// Sleep(100);// dynamiclloc();// &#125;// system(&quot;pause&quot;);// &#125;// 18 改变内存空间大小，新开辟的内存地址会复制旧的内存地址内的东西并释放旧的内存地址；// int main()&#123;// int num;// printf(&quot;请输入数的个数：&quot;);// // 获取用户输入的值// scanf(&quot;%d&quot;, &amp;num);// // 5 个值// int* arr = (int*)malloc(sizeof(int)*num);// int i = 0;// int print_num;// for (; i &lt; num; i++)&#123;// arr[i] = i;// arr[i] = *(arr+i)// &#125;// printf(&quot;开辟内存的指针：%p\\n&quot;,arr);// // 再加点内存// printf(&quot;请输入新增的个数：&quot;);// // 获取用户输入的值// int new_num;// scanf(&quot;%d&quot;, &amp;new_num);// 5 // // 原来那块内存的指针，总的大小（原来的大小+新的大小）// int* new_arr = (int*)realloc(arr, sizeof(int)*(num+new_num));// if (new_arr)&#123;// = if(new_arr != NULL)// i = new_num;// for (; i &lt; (num + new_num); i++)&#123;// arr[i] = i;// arr[i] = *(arr+i)// &#125;// printf(&quot;新开辟内存的指针：%p\\n&quot;, new_arr);// // 打印数组// i = 0;// for (; i &lt; num + new_num; i++)&#123;// printf(&quot;%d, %p\\n&quot;, *(arr + i), arr + i);// &#125;// &#125;// if (new_arr)&#123;// // 如果成功了，只要释放新的地址就行// free(new_arr);// new_arr = NULL;// &#125;// else&#123;// // 如果没有成功，释放原来的内存// free(arr);// &#125;// // 不要反复去释放,那块地址一旦被释放，就有可能会被新的应用占用，不要去再次释放// // free(new_arr);// system(&quot;pause&quot;);// &#125;//day09// 19 字符串定义// int main()&#123;// // 第一种 字符串数组// char str[] = &#123;&#x27;D&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;\\0&#x27;&#125;;// str[2] = &#x27;y&#x27;;// printf(&quot;%s\\n&quot;,str);// 字符串结尾是 &#x27;\\0&#x27;// // 第二种// char *str1 = (char*)&quot;Darren&quot;;// str1[2] = &#x27;y&#x27;;//不能修改会报错// printf(&quot;%s&quot;, str1);// // 区别，一个能修改一个不能修改// system(&quot;pause&quot;);// &#125;// 20字符串长度获取// int strlen_(char *str)&#123;// // 怎么获取字符串的长度？ 不断读取字符，判断末尾 &#x27;\\0&#x27;// int len = 0;// while (*str != &#x27;\\0&#x27;)// &#123;// len++;// str++;// &#125;// return len;// &#125;// int main()&#123;// char *name = &quot;Darren is&quot;;// char str[] = &#123; &#x27;D&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;r&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;\\0&#x27;,&#x27;i&#x27;,&#x27;s&#x27; &#125;;// // 怎么获取长度？有一种方式计算（不好使）// // printf(&quot;length is %d&quot;,sizeof(str)/sizeof(char));// printf(&quot;name length is %d\\n&quot;, strlen(str));// // 自己来写一个方法读取字符串的长度// // strlen_(name);// printf(&quot;name length is %d&quot;, strlen_(str));// system(&quot;pause&quot;);// &#125;//21 字符串的转换// int main()&#123;// // char * num = &quot;1&quot;; -&gt; int float double// char *num_str = &quot;12.0xxx&quot;;// int number0 = atoi(num_str);// 如果不能转换就是 0 ，后面如果有其他不是数字的就会被剔除 12xxx-&gt;12 , xx12-&gt;0// printf(&quot;number0 is %d\\n&quot;,number0);//12// char *num_str1 =&quot;12.5f&quot;;// float number1 = atof(num_str1);// 如果不能转换返回的是默认值 0.000000 // printf(&quot;number1 is %lf\\n&quot;,number1);//12.500000// char *num_str2 = &quot;12.5xx&quot;;// double number2 = strtod(num_str2, NULL);// printf(&quot;number2 is %lf&quot;,number2);//12.500000// system(&quot;pause&quot;);// &#125;// 22字符串的比较// int main()&#123;// char* str1 = &quot;Darren&quot;;// char* str2 = &quot;darren&quot;;// // 大于小于等于 // int rc = strcmp(str1, str2);// 区分大小写比较// printf(&quot;rc=%d\\n&quot;,rc);//-1，=0相等// int rc1 = _strcmpi(str1, str2);//不区分大小写比较// printf(&quot;rc1=%d\\n&quot;,rc1);//0// // 比较前几个// char* str3 = &quot;Darren&quot;;// char* str4 = &quot;Darren is&quot;;// int rc2 = strncmp(str3, str4,7);// count 代表的是比较字符串前几个是否相等// int rc3 = _strnicmp(str3, str4, 6);// printf(&quot;rc2=%d\\n&quot;,rc2);//0// printf(&quot;rc3=%d\\n&quot;,rc3);//0// // if (rc == 0)&#123;// // printf(&quot;相等&quot;);// // &#125;// // else&#123;// // printf(&quot;不相等&quot;);// // &#125;// system(&quot;pause&quot;);// &#125;// 23 字符串查找，包含// int main()&#123;// char* str = &quot;name is Darren&quot;;// char *substr = &quot;is&quot;;// char* pos = strstr(str, substr);// 返回的是字符串第一次出现的位置（位置指针）, 如果没有找到返回的是空// // 求一下位置 int 怎么办？ strstr // int postion = pos - str;// printf(&quot;第一次出现的位置是：%d\\n&quot;,postion);// // 包含？pos 是不是空就可以了// if (pos)&#123;// printf(&quot;%s&quot;, &quot;包含&quot;);// &#125;// else&#123;// printf(&quot;%s\\n&quot;, &quot;不包含&quot;);// &#125;// system(&quot;pause&quot;);// &#125;// 24拼接，截取，大小写转换// int main()&#123;// // strcpy(); copy进来// char* str = &quot;darren&quot;;// char *str1 = &quot; is&quot;;// int len = strlen(str);// cpy[len] android studio 是可以的// printf(&quot;len:%d\\n&quot;,len);//6// char cpy[len];// // str 会 copy 到 cpy 里面// strcpy(cpy, str);// printf(&quot;%s\\n&quot;,cpy);//darren// // 拼接// strcat(cpy,str1);// printf(&quot;%s&quot;, cpy);//darren is// system(&quot;pause&quot;);// &#125;// 25字符串的截取// char * substr(char * str,int start,int end)&#123;// // 开辟一个字符串去存储我们的数据，开辟多大计算// // char sub[end-start];// int len = end - start;// char* sub = (char*)malloc(len*sizeof(char)+1);// 记得加上1 ，在 NDK 一般会采用静态的数组存储 char sub[len]// // malloc 一定要 free // // 遍历赋值// str += start;// for (int i = 0; i &lt; len; i++)// &#123;// sub[i] = *str;// str++;// 指针往后逻一位 // &#125;// // 标记字符串结尾，否则 print 无法判断结尾// sub[len] = &#x27;\\0&#x27;;// printf(&quot;%p\\n&quot;,sub);// // free(sub);// return sub;// &#125;// int main()&#123;// char *str = &quot;Darren is&quot;;// // 截取第三个位置到第五个位置 3，5// char *sub = substr(str,0,5);// printf(&quot;%p\\n&quot;, sub);// printf(&quot;%s\\n&quot;,sub);// // 一定要 free ，因为你的 substr 有动态开辟内存，但是真正开发过程中并不会这么做，自己的方法尽量要自己处理好内存// free(sub);// system(&quot;pause&quot;);// &#125;//26大小写转换// dest 用来存放结果，大小自己指定,source 需要转换的字符串// void lower(char* dest,char* source)&#123;// while (*source != &#x27;\\0&#x27;)&#123;// // 拿当前字符// char ch = *source;// // 转完赋值给 dest// *dest = tolower(ch);// a -&gt; a A -&gt; a// // 接着指针 ++ ，遍历下一个// source++;// dest++;// &#125;// // 标记字符串结尾// *dest = &#x27;\\0&#x27;;// &#125;// int main()&#123;// char* name = &quot;daRRen&quot;;// char dest[20];// lower(dest,name);// printf(&quot;%s&quot;,dest);// system(&quot;pause&quot;);// &#125;//day10// 27.结构体的定义和使用//第一种方式// struct Worker&#123;// 定义一个结构体，相当于 java 的 class// char name[10];// int age;// double salary;// &#125;;// 第二种方式，可以直接取名字// struct Worker&#123;// 定义一个结构体，相当于 java 的 class// char name[10];// int age;// double salary;// &#125;darren = &#123;&quot;Darren&quot;,23,1000&#125;, jack;// 第三种方式，结构体嵌套// struct Work&#123;// char name[10];// char grade[10];// &#125;;// struct Worker&#123;// 定义一个结构体，相当于 java 的 class// char name[10];// int age;// double salary;// // 工作， name grade// Work work;// &#125;;// 第四种方式，结构体嵌套struct Worker&#123;// 定义一个结构体，相当于 java 的 class char name[10]; int age; double salary; struct Work&#123; char name[10]; char grade[10]; &#125;work; // 工作， name grade // Work work;&#125;;// int main()&#123; //第一种方式 // struct Worker worker;// 初始化 , 没有初始化的情况下，那么里面所有的属性都是没有初始值的 // 赋值 // worker.age = 24; // worker.name = &quot;Darren&quot;;////没有初始化不能直接修改 // strcpy_s(worker.name,&quot;Jack&quot;); // worker.salary=1.1; // printf(&quot;name = %s, age = %d, salary = %lf&quot;, worker.name, worker.age, worker.salary);//name = Jack, age = 24, salary = 1.100000请 // 第二种方式 // printf(&quot;name = %s, age = %d, salary = %lf&quot;, darren.name, darren.age, darren.salary);//name = Darren, age = 23, salary = 1000.000000 // jack.name = &quot;Jack&quot;;//没有初始化不能直接修改 // strcpy_s(jack.name, &quot;Jack&quot;); // jack.age = 24; // jack.salary=2.2; // printf(&quot;name = %s, age = %d, salary = %lf&quot;, jack.name, jack.age, jack.salary);//name = Jack, age = 24, salary = 2.200000 // 第三种方式 // struct Worker worker = &#123; &quot;Darren&quot;, 23, 1000, &#123;&quot;Android&quot;,&quot;中级&quot;&#125; &#125;;// 嵌套的初始 // printf(&quot;name = %s, grade = %s&quot;, worker.work.name, worker.work.grade);//name = Android, grade = 中级 // 第四种方式 // struct Worker worker = &#123; &quot;jeck&quot;, 20, 100, &#123;&quot;JAVA&quot;,&quot;中级&quot;&#125; &#125;;// 嵌套的初始 // printf(&quot;name = %s, grade = %s&quot;, worker.work.name, worker.work.grade);//name = JAVA, grade = 中级// system(&quot;pause&quot;);// &#125;// 28 结构体指针// int main()&#123;// struct Worker worker = &#123;&quot;Darren&quot;,23&#125;;// Worker* worker_p = &amp;worker;// // 通过结构体指针去操作数据// // worker.age = 24;// worker_p-&gt;age = 24;// 结构体操作的另外一种方式，一般这种比较常用// strcpy_s(worker_p-&gt;name,&quot;Jack&quot;);// printf(&quot;name = %s, age = %d&quot;, worker_p-&gt;name, worker_p-&gt;age);// system(&quot;pause&quot;);// &#125;// 29 动态内存开辟// struct Worker&#123;// 定义一个结构体，相当于 java 的 class// char name[10];// int age;// double salary;// &#125;;// int main()&#123;// // Worker* worker;// 创建了一个结构体指针 , 不能直接使用,因为没有初始化// Worker* worker = (Worker*)malloc(sizeof(Worker));// worker-&gt;age = 24;// strcpy_s(worker-&gt;name, &quot;Jack&quot;);// printf(&quot;name = %s, age = %d&quot;, worker-&gt;name, worker-&gt;age);// // 释放// if (worker)&#123;// free(worker);// worker = NULL;// &#125;// system(&quot;pause&quot;);// &#125;// 30 结构体的数组// struct Worker&#123;// 定义一个结构体，相当于 java 的 class// char name[10];// int age;// double salary;// &#125;;// int main()&#123;// // 动态内存开辟// // Worker worker[10] = &#123; &#123;&quot;Darren&quot;,23,1000&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125; &#125;;// 创建了 10 个 ，静态开辟// // worker[9] = &#123;&quot;Darren9&quot;,24,200&#125;;// // printf(&quot;name = %s, age = %d\\n&quot;, worker[9].name, worker[9].age);// // 动态内存开辟 Worker* 结构体的指针// Worker* worker = (Worker*)malloc(sizeof(Worker)*10);// strcpy_s(worker-&gt;name,&quot;Darren0&quot;);// worker-&gt;age = 10;// // 对第十个数据进行操作？// worker += 9;// strcpy_s(worker-&gt;name, &quot;Darren9&quot;);// worker-&gt;age = 9;// printf(&quot;name = %s, age = %d&quot;, worker-&gt;name, worker-&gt;age);// system(&quot;pause&quot;);// &#125;// 31 结构体大小计算（字节对齐）// struct Worker&#123;// 定义一个结构体，相当于 java 的 class// char name[18]; // 10 // int age; // 4// double salary;// 8// &#125;;// int main()&#123;// int size = sizeof(Worker);// 16 字节// // 计算的规则：// // 1. 按照最大的字节去计算 // // 2. 算得时候只会按照基本数据类型去算// // 3. 首先会把所有字节数加起来，是否能够整除最大属性的字节数，如果不够为网上累加，一直加到能整除位置// printf(&quot;size = %d&quot;, size);// system(&quot;pause&quot;);// &#125;// 32结构体大小计算（字节对齐）// struct date&#123; // 12// int year;// int month;// int day;// &#125;;// struct student&#123;// int number;// 4// char sex;// 1// int age;// 4// char name[10];// 10 // struct date birthday;// 12// // 31%4 // &#125;;// int main()&#123;// int size = sizeof(student);// 36 字节// // 计算的规则：// // 1. 按照最大的字节去计算 // // 2. 算得时候只会按照基本数据类型去算// // 3. 首先会把所有字节数加起来，是否能够整除最大属性的字节数，如果不够为网上累加，一直加到能整除位置// // 4. 进阶，留一个思考// printf(&quot;size = %d&quot;, size);// system(&quot;pause&quot;);// &#125;//33 结构体和结构体指针取别名// struct Worker_&#123;// 定义一个结构体，相当于 java 的 class// char name[10];// int age;// double salary;// &#125;;// typedef Worker_ Worker_;// // 对结构体的指针取别名// typedef Worker_* Worker;// int main()&#123;// Worker worker = (Worker_*)malloc(sizeof(Worker_));// printf(&quot;%s,%d,%lf&quot;,worker-&gt;name,worker-&gt;age,worker-&gt;salary);// system(&quot;pause&quot;);// &#125;//34 联合体// union Person&#123;// // 最能出现一个 ，不用累加，找最大值 10，12字节// //联合体大小计算 （不用累加，取的最大值，最终是否够基本数据类型整除）// char name[10]; // 10 // int age; // 4 // double salary;// 8// &#125;;// // 联合体的定义和使用，联合体只能存在一个，要么是 age ，要么是 name // int main()&#123;// Person person = &#123;&quot;Darren&quot;&#125;;// // Person person;// // strcpy_s(person.name,&quot;Darren&quot;);// // person.age = 24;// // printf(&quot;name = %s,age = %d&quot;,person.name,person.age);// printf(&quot;%d&quot;, sizeof(Person));// system(&quot;pause&quot;);// &#125;// 35 枚举的定义和使用 枚举有点类似于 int// enum CommentType// &#123;// TEXT = 10,TEXT_IMAGE,IMAGE// &#125;;// int main()&#123;// CommentType commentType = TEXT;// CommentType commentType1 = TEXT_IMAGE;// CommentType commentType2 = IMAGE;// printf(&quot;%d,%d,%d&quot;, commentType, commentType1, commentType2);// system(&quot;pause&quot;);// &#125;//day11 // 36文件读取// int main()&#123;// // 打开文件 （文件名，模式）mode r(读) w(写) rb(作为二进制读) wb(作为二进制写)// // FILE *fopen( const char *filename, const char *mode );// char* fileName = &quot;C:\\\\Users\\\\11046\\\\OneDrive\\\\桌面\\\\test.txt&quot;;// FILE *file = fopen(fileName, &quot;r&quot;);// if (!file)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// char buffer[10];// // 缓冲区buffer，长度10 ，文件指针// while (fgets(buffer, 10, file))&#123;// printf(&quot;%s&quot;,buffer);// &#125;// // 关闭文件// fclose(file);// system(&quot;pause&quot;);// &#125;// 37文件写入// int main()&#123;// char* fileName = &quot;C:\\\\Users\\\\11046\\\\OneDrive\\\\桌面\\\\test.txt&quot;;// FILE *file = fopen(fileName, &quot;w&quot;);// if (!file)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// fputs(&quot;I am tyl&quot;,file);// // 关闭文件// fclose(file);// system(&quot;pause&quot;);// &#125;//38 文件复制，当做二进制文件来操作// int main()&#123;// char* fileName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image.jpg&quot;;// char* fileCopyName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_copy.jpg&quot;;// FILE *file = fopen(fileName, &quot;rb&quot;);// 流指针// FILE *file_copy = fopen(fileCopyName, &quot;wb&quot;);// 新建一个文件 0kb // if (!file || !file_copy)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// // size_t fread(void *buffer, size_t size, size_t count, FILE *stream);// int buffer[512];// 2048 = 4*514// int len;// printf(&quot;%d&quot;,sizeof buffer);// while ((len = fread(buffer, sizeof(int), 512, file))!=0)&#123;// fwrite(buffer, sizeof(int), len, file_copy);// &#125;// fclose(file);// fclose(file_copy);// system(&quot;pause&quot;);// &#125;//39 获取文件的大小// int main()&#123;// char* fileName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image.jpg&quot;;// FILE *file = fopen(fileName, &quot;rb&quot;);// 流指针// if (!file)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// // 没有一个函数是可以直接拿文件大小// // 思路：将文件的指针移动到最后，然后再去计算偏移量// // 三个参数 SEEK_SET（开头）, SEEK_CUR（当前）, SEEK_END（移动到最后）// fseek(file, 0, SEEK_END);// // 计算偏移的位置,ftell 从 0 开始统计到当前（SEEK_END）// long file_size = ftell(file);// printf(&quot;文件大小：%ld&quot;,file_size);// fclose(file);// system(&quot;pause&quot;);// &#125;// 40文件加密// 图片服务器（使用第三方的），为了防止图片泄密，图片进行加密// int main()&#123;// char* fileName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image.jpg&quot;;// char* fileEncrpyName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_en.jpg&quot;;// FILE *file = fopen(fileName, &quot;rb&quot;);// 流指针// FILE *file_encrpy = fopen(fileEncrpyName, &quot;wb&quot;);// 新建一个文件 0kb // if (!file || !file_encrpy)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// // 破坏文件，还原// // 思路：把每一个字节都拿出来，对每一个字节都处理，把某部分字节拿出来，进行处理// // 10^5 异或 加密过程 // // 1010 // // ^0101// // 1111 加密// // 解密 同样的去异或 5 // // 1111// // ^0101// // 1010 解密后 10// int c;// EOF end of file// while ((c = fgetc(file))!=EOF)&#123;// fputc(c ^ 5, file_encrpy);// &#125;// system(&quot;pause&quot;);// &#125;// 41文件的解密// int main()&#123;// char* fileEnName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_en.jpg&quot;;// char* fileDeName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_de.jpg&quot;;// FILE *file = fopen(fileEnName, &quot;rb&quot;);// 流指针// FILE *file_decrpy = fopen(fileDeName, &quot;wb&quot;);// 新建一个文件 0kb // if (!file || !file_decrpy)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// // 思路：把每一个字节都拿出来，对每一个字节都处理，把某部分字节拿出来，进行处理// // 10^5 异或 加密过程// // 1010 // // ^0101// // 1111 加密// // 解密 同样的去异或 5 // // 1111// // ^0101// // 1010 解密后 10// int c;// EOF end of file// while ((c = fgetc(file)) != EOF)&#123;// fputc(c ^ 5, file_decrpy);// &#125;// system(&quot;pause&quot;);// &#125;// 42 就改一个字节, 过不去// int main()&#123;// char* fileEnName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image.jpg&quot;;// // rwb // FILE *file = fopen(fileEnName, &quot;wb&quot;); // 流指针，创建文件? 有没有其他办法 支付宝人脸识别 Mat 矩阵// // file 流的头指针// fputc(5, file);// fclose(file);// system(&quot;pause&quot;);// &#125;//43字符串密码进行加密// int main()&#123;// char* fileName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image.jpg&quot;;// char* fileEncrpyName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_en.jpg&quot;;// char* passWord = &quot;123456&quot;;// 轮流进行^操作// FILE *file = fopen(fileName, &quot;rb&quot;);// 流指针// FILE *file_encrpy = fopen(fileEncrpyName, &quot;wb&quot;);// 新建一个文件 0kb // if (!file || !file_encrpy)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// int c;// EOF end of file// int index = 0;// int pass_len = strlen(passWord);// while ((c = fgetc(file)) != EOF)&#123;// fputc(c ^ passWord[index%pass_len], file_encrpy);// index++;// &#125;// system(&quot;pause&quot;);// &#125;// 44字符串密码解密// int main()&#123;// char* fileName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_en.jpg&quot;;// char* fileDeName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_de.jpg&quot;;// char* passWord = &quot;123456&quot;;// 轮流进行^操作// FILE *file = fopen(fileName, &quot;rb&quot;);// 流指针// FILE *file_decrpty = fopen(fileDeName, &quot;wb&quot;);// 新建一个文件 0kb // if (!file || !file_decrpty)&#123;// printf(&quot;文件打开失败&quot;);// exit(0);// 退出程序// &#125;// int c;// EOF end of file// int index = 0;// int pass_len = strlen(passWord);// while ((c = fgetc(file)) != EOF)&#123;// fputc(c ^ passWord[index%pass_len], file_decrpty);// index++;// &#125;// fclose(file);// fclose(file_decrpty);// system(&quot;pause&quot;);// &#125;// 45 文件的切割，思路类似于断点下载// int getFileSize(char* fileName)&#123;// FILE* file = fopen(fileName,&quot;rb&quot;);// if (!file)&#123;// return 0;// &#125;// fseek(file,0,SEEK_END);// int file_size = ftell(file);// fclose(file);// return file_size;// &#125;// int main()&#123;// // 百度云 不大于4G的文件？ 8G 文件，扔进去// // 大文件（断点续传）// // 文件切割，把文件合作为一个思考// // 计算每个文件需要写入多少？// char* fileName = &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image.jpg&quot;;// FILE* file = fopen(fileName,&quot;rb&quot;);// int file_size = getFileSize(fileName);// // 定义 切多少，计算大小，指定文件名// int file_number = 3;// // 二维数组，char[] char*// // image_0.jpg// // image_1.jpg// // image_2.jpg// // char* file_name// // char* // char** file_names = (char**)malloc(sizeof(char*)*file_number);// int preFileSize = file_size / file_number;// // 进行复制// int i = 0;// for (; i &lt; 3; i++)// &#123;// file_names[i] = (char*)malloc(sizeof(char)*100);// &#x27;\\0&#x27;// sprintf(file_names[i], &quot;C:\\\\Users\\\\hcDarren\\\\Desktop\\\\android\\\\NDK\\\\image_%d.jpg&quot;, i);// printf(&quot;%s\\n&quot;, file_names[i]);// &#125;// i = 0;// for (; i &lt; file_number; i++)// &#123;// // 从源文件中往切割文件写入数据// FILE* cur_file = fopen(file_names[i],&quot;wb&quot;);// // 写多少？// int start = i*preFileSize;// int end = (i + 1)*preFileSize;// if (i == file_number - 1)&#123;// end = file_size;// &#125;// // 第一个循环 file 读，第二个循环还是从 file 里面// for (int j = start; j &lt; end; j++)// &#123;// // 从file 里面读，写如到 cur_file// fputc(fgetc(file),cur_file);// &#125;// fclose(cur_file);// free(file_names[i]);// &#125;// fclose(file);// free(file_names);// system(&quot;pause&quot;);// &#125;//day12// p45-p53课开始jni的开发流程，没看懂，用的工具和自己用的不一样//46 常量指针/指针常量// 常量变量:被常量修饰的变量，不能再次被赋值 (Java )// 常量指针:const 在*之前，指针的地址是可以被再次赋值的( 可以修改的)，指针地址上面的值(变量)是不能被修改，常量指针的常量是不能被改变的,// 指针常量:const 在*之后，指针的地址是不可以被再次赋值的(不可以修改的)，指针地址上面的值(变量)能被修改的，指针常量的指针地址是不能被改变的。//const在谁前面谁就不能修改；//int main()&#123;// // 常量，不能去修改// const int number = 100;// // number = 200;// int number1 = 100;// int number2 = 200;// // 常量指针// // int const * n_p = &amp;number2;// // n_p = &amp;number1;// // printf(&quot;n_p = %p&quot;,n_p); // 地址是可以重新被赋值的// // *n_p = 300; 值是不能改的//// // 指针常量// int * const n_p = &amp;number2;// // n_p = &amp;number1; 地址是不能被重新赋值// *n_p = 300;// printf(&quot;number2 = %d&quot;, number2);// system(&quot;pause&quot;);//&#125;//p54-p57面试题没看懂，太啰嗦//day14","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/2_jni基础/","text":"title：2_jni基础JNI的一般开发流程：（java访问native） 123451.1定义好本地的 native 方法1.2javah 命令生成h 头文件1.3 拷贝 xxx.h、jni_md.h、jih 到 VS 的工程目录并添加依赖进来1.4实现我们头文件中的 native 方法1.5 生成 dll 动态，java 引 dl 动态库运行即可 流程细节： &#x2F;&#x2F; ecplise 1.定义好本地的 native 方法（NdkSimple.java） 123456789package com.tyl.myStudy;public class NdkSimple &#123; public static void main(String[] args) &#123; NdkSimple ndkSimple = new NdkSimple(); String signaturePassword = ndkSimple.getSingnaturePassword(); System.out.println(&quot;秘钥 = &quot;+signaturePassword); &#125; public static native String getSingnaturePassword();&#125; 2.cmd中cd到本文件的路径下执行javah，查看支持的命令； 123456错误：&#x27;javah&#x27; 不是内部或外部命令原因：jdk版本太新了，在jdk10及以上的版本中，已经删除了javah，使用&quot;javac -h&quot;命令替代&quot;javah&quot;解决方案：javac -h ./ NdkSimple.java（错误: 编码 GBK 的不可映射字符 (0x9B) 原因：不能有中文哪怕是注释，添加-encoding UTF-8解决方案：javac -h ./ NdkSimple.java -encoding UTF-8 3.本地路径上出现新生成的文件：com_tyl_myStudy_NdkSimple.h &#x2F;&#x2F; visualStudio 4.将com_tyl_myStudy_NdkSimple.h复制到visualStudio的项目根目录中（如：D:\\C++Projects\\C++Study\\Project1） 5.本地java的安装目录中搜索jni,然后将jni.h及jni_md.h文件复制到visualStudio的项目根目录中（如：D:\\C++Projects\\C++Study\\Project1） 6.vs中点击头文件-&gt;添加-&gt;现有项-&gt;将com_tyl_myStudy_NdkSimple.h和jni.h及jni_md.h文件添加进来; 7.生成dll动态库 7-1：调试–&gt;调试属性-&gt;常规-&gt;配置类型-&gt;动态库（.dll）-&gt;应用-&gt;确定 7-2：生成-&gt;配置管理器-&gt;平台处新建-&gt;x64或其他根据本地环境-&gt;确定 7-3：生成-&gt;生成解决方案；提示：生成: 1 成功，0 失败，0 最新，0则成功，文件在项目根目录-x86-debug下的dll文件就是 &#x2F;&#x2F;ecplise NdkSimple.java 8.引入加载我们的本地库 12345static&#123; //System.loadlibrary:android加载apk中的libs目录下.so库 // System.load:更载一个具体路径上的.so 库，可以去服务器上下载后下载 System.load(&quot;D:\\\\C++Projects\\\\C++Study\\\\Project1\\\\x64\\\\Debug\\\\Project1.dll&quot;); &#125; 9.执行调用 10.com_tyl_myStudy_NdkSimple.h头文件字段说明： 1234567891011121314151617181920212223/* DO NOT EDIT THIS FILE - it is machine generated */#include &quot;jni.h&quot; // &quot;&quot; 引入自己工程的头文件 &lt;&gt; 引入系统的头文件/* Header for class com_tyl_myStudy_NdkSimple */// 用来打一个标记，c在编译的时候会把头文件 copy 到你引入的地方，不管是重复引用还是相互引用都只会 copy 一次#ifndef _Included_com_tyl_myStudy_NdkSimple#define _Included_com_tyl_myStudy_NdkSimple#ifdef __cplusplus// 相当于 if 语句 c++（如果是c++执行下列的方法，使用c的编译方式） // 不管是 c 还是 c++ 统一都是采用 c 的编译方式，因为在c里面是不允许函数重载的,但是在 c++ 里面可以extern &quot;C&quot; &#123;#endif/* * Class: com_tyl_myStudy_NdkSimple * Method: getSingnaturePassword * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_tyl_myStudy_NdkSimple_getSingnaturePassword (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 11.jni.c的字段说明： 1234567891011121314//1.实现我们的 native 方法#include &quot;com_tyl_myStudy_NdkSimple.h&quot;//2.将.h中的方法复制过来修改为实现方法// JNIEXPORT JNI 一个关键字，不能少（编译能通过），标记为该方法可以被外部调用// jstring : 代表 java 中的 String // JNICALL: 也是一个关键字，可以少的 jni call// JNIEnv: 这个是 c 和 java 相互调用的桥梁，所有 function 搞清// jobject: java传递下来的对象，就是本项目中 JniSimple java 对象// jclass: java传递下来的 class 对象，就是本项目中的 JniSimple.class JNIEXPORT jstring JNICALL Java_com_tyl_myStudy_NdkSimple_getSingnaturePassword(JNIEnv* env, jclass jobj) &#123;//JNIEnv*, jclass // JNIEnv * 其实已经是一个二级指针了，所以 -&gt; 调用的情况下必须是一级指针 *取值 return (*env)-&gt;NewStringUTF(env,&quot;5555&quot;);&#125; 12.native修改java参数： 123456789101112131415161718JNIEXPORT void JNICALL Java_com_darren_ndk12_NdkSimple1_changeName(JNIEnv *env, jobject jobj)&#123; // 获取 name 属性然后修改为 Jack // 3.获取 jclass jclass j_clz = (*env)-&gt;GetObjectClass(env, jobj); // 获取 jfieldId (JNIEnv *env, jclass clazz, const char *name, const char *sig) // name 获取哪个属性的属性名 // 2.sig 属性的签名 jfieldID j_fid = (*env)-&gt;GetFieldID(env, j_clz, &quot;name&quot;, &quot;Ljava/lang/String;&quot;); // 1.获取 name 属性的值 jstring j_str = (*env)-&gt;GetObjectField(env, jobj, j_fid); // 打印字符串 jstring -&gt; c_str char* c_str = (*env)-&gt;GetStringUTFChars(env,j_str,NULL); printf(&quot;name is %s&quot;,c_str); // 修改成 jack jstring jackName = (*env)-&gt;NewStringUTF(env,&quot;Jack&quot;); (*env)-&gt;SetObjectField(env, jobj, j_fid, jackName);&#125; 13.native调用java方法： 123456789101112131415//java：public int add(int numberl,int number2)&#123; return numberl+number2; &#125; //native: JNIEXPORT void JNICALL Java_com_darren_ndk12_NdkSimple1_callAddMathod(JNIEnv *env, jobject jobj)&#123; jclass j_clz = (*env)-&gt;GetObjectClass(env,jobj); // 获取 methodid jmethodID j_mid = (*env)-&gt;GetMethodID(env, j_clz, &quot;add&quot;, &quot;(II)I&quot;); // 去调用 java 的方法 jint sum = (*env)-&gt;CallIntMethod(env, jobj, j_mid,2,3); printf(&quot;sum = %d&quot;,sum);&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/3_jni_native层构建java对象/","text":"Point.java 1234567891011121314151617181920212223242526272829package com.darren.ndk.day13;import java.io.PrintWriter;public class Point &#123; private int x; private int y; public Point(int x,int y)&#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public int getY() &#123; return y; &#125;&#125; Simple1.java 123456789101112131415161718192021222324252627282930313233package com.darren.ndk.day13;import java.util.UUID;public class Simple1 &#123; public static void main(String[] args) &#123; // callStaticMethod(); Point point = createPoint(); System.out.println(&quot;point: x = &quot;+point.getX()+&quot; , y = &quot;+point.getY()); // android 用反射 ，jni 设置属性值，反射的原理？ &#125; private native static Point createPoint(); private native static void callStaticMethod(); // 小的思考：静态获取 uuid 的方法，然后再 c 调用这个方法获取uuid public static String getUUID() &#123; return UUID.randomUUID().toString(); &#125; public static Point test(int x,float y)&#123; return null; &#125; static&#123; System.load(&quot;C:/Users/hcDarren/Desktop/android/NDK/NDK_Day13/x64/Debug/NDK_Day13.dll&quot;); &#125;&#125; com_darren_ndk_day13_Simple1.h 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_darren_ndk_day13_Simple1 */#ifndef _Included_com_darren_ndk_day13_Simple1#define _Included_com_darren_ndk_day13_Simple1#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: com_darren_ndk_day13_Simple1 * Method: callStaticMethod * Signature: ()V */JNIEXPORT void JNICALL Java_com_darren_ndk_day13_Simple1_callStaticMethod (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif Simple.c 123456789101112131415161718192021222324252627282930#include &quot;com_darren_ndk_day13_Simple1.h&quot;JNIEXPORT jobject JNICALL Java_com_darren_ndk_day13_Simple1_createPoint(JNIEnv *env, jclass jclz)&#123; // jclz -&gt; Simple1 // 获取 Point 的 class ,name = &quot;全类名&quot; jclass point_clz = (*env)-&gt;FindClass(env,&quot;com/darren/ndk/day13/Point&quot;); // 构建 java 层的 Point 对象，构造函数的id , 构造方法（百度） &lt;init&gt; jmethodID j_mid = (*env)-&gt;GetMethodID(env,point_clz,&quot;&lt;init&gt;&quot;,&quot;(II)V&quot;); jobject point = (*env)-&gt;NewObject(env, point_clz, j_mid,11,22); // 练习一下 y 重新付个值 ？调用 set 方法 j_mid = (*env)-&gt;GetMethodID(env, point_clz,&quot;setY&quot;,&quot;(I)V&quot;); /* va_list 集合 void (JNICALL *CallVoidMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args); // jvalue void (JNICALL *CallVoidMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args); */ (*env)-&gt;CallVoidMethod(env, point,j_mid,33); // 作业：直接给属性赋值 return point;&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/4_jni_数组的细节处理/","text":"p58-p61 com_darren_day15_Simple1.h 12345678910111213141516171819202122/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_darren_day15_Simple1 */#ifndef _Included_com_darren_day15_Simple1#define _Included_com_darren_day15_Simple1#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: com_darren_day15_Simple1 * Method: sort * Signature: ([I)V */JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_sort (JNIEnv *, jclass, jintArray);#ifdef __cplusplus&#125;#endif#endif Simple1.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.darren.day15;import java.util.Collections;import javax.naming.ldap.SortControl;public class Simple1 &#123; private static String name;// 一大堆变量 private static String name1;// 一大堆变量 private static String name3;// 一大堆变量 static &#123; System.load(&quot;C:/Users/hcDarren/Desktop/android/NDK/NDK_Day15_VS/x64/Debug/NDK_Day15_VS.dll&quot;); &#125; public Simple1() &#123; &#125; public static void main(String[] args) &#123; // 1. 数组处理的一些细节 /* * int[] arr = &#123;11,22,-3,2,4,6,-15&#125;; * * * sort(arr); * * for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+&quot;\\t&quot;); * &#125; * * // 2. 局部引用和全局引用 // localRef(); * * // saveGlobalRef(&quot;Darren&quot;); * * // System.out.println(getGlobalRef()); * * // 合适的时机去释放 // delteGlobalRef(); * * // 再次获取 // System.out.println(getGlobalRef()); * * // 3.缓存策略 static，native层有一大堆方法要去获取 name 属性 // 初始化全局静态缓存 * initStaticCache(); * * staticLocalCache(&quot;Darren&quot;); * * System.out.println(&quot;name = &quot;+name); * * staticLocalCache(&quot;Jack&quot;);// not null * * System.out.println(&quot;name = &quot;+name); * * staticLocalCache(&quot;Rose&quot;); // not null System.out.println(&quot;name = &quot; * +name); */ // 异常处理（简单讲，C++异常） try &#123; exception(); &#125; catch (NoSuchFieldException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;name3 = &quot; + name3); &#125; private static final native void exception() throws NoSuchFieldException; private static final native void initStaticCache(); private static final native void staticLocalCache(String name); private static final native void delteGlobalRef(); private static final native String getGlobalRef(); private static final native void saveGlobalRef(String str); private static final native void localRef(); private static final native void sort(int[] arr);&#125; com_darren_day15_Simple1.h 123456789101112131415161718192021222324252627282930313233343536373839404142/* DO NOT EDIT THIS FILE - it is machine generated */#include &quot;jni.h&quot;/* Header for class com_darren_day15_Simple1 */#ifndef _Included_com_darren_day15_Simple1#define _Included_com_darren_day15_Simple1#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: com_darren_day15_Simple1 * Method: sort * Signature: ([I)V */JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_sort (JNIEnv *, jclass, jintArray);JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_localRef(JNIEnv *, jclass);JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_saveGlobalRef(JNIEnv *, jclass,jstring);JNIEXPORT jstring JNICALL Java_com_darren_day15_Simple1_getGlobalRef(JNIEnv *, jclass);JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_delteGlobalRef(JNIEnv *, jclass);JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_staticLocalCache(JNIEnv *, jclass, jstring);JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_initStaticCache(JNIEnv *, jclass);JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_exception(JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif Simple.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &quot;com_darren_day15_Simple1.h&quot;#include &lt;stdlib.h&gt;int compare(const jint *number1, const jint *number2)&#123; return *number1 - *number2;&#125;// 全局变量jstring globalStr;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_sort(JNIEnv * env, jclass jclz, jintArray jarray)&#123; // 对 jarray 进行排序 （sort） jint* intArray = (*env)-&gt;GetIntArrayElements(env,jarray,NULL); int length = (*env)-&gt;GetArrayLength(env,jarray); // 第一个参数：void* 数组的首地址 // 第二个参数：数组的大小长度 // 第三个参数：数组元素数据类型的大小 // 第四个参数：数组的一个比较方法指针（Comparable） qsort(intArray, length, sizeof(int), compare); // 同步数组的数据给 java 数组 intArray 并不是 jarray ，可以简单的理解为 copy // 0 : 既要同步数据给 jarray ,又要释放 intArray // JNI_COMMIT: 会同步数据给 jarray ，但是不会释放 intArray // JNI_ABORT: 不同步数据给 jarray ，但是会释放 intArray (*env)-&gt;ReleaseIntArrayElements(env,jarray,intArray,JNI_ABORT);&#125;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_localRef(JNIEnv *env, jclass jclz)&#123; // 在 native 层构建的 Java 对象，你不用了该怎么管理？ // native 层开辟的内存由谁管理，你能开辟多大 // 字符串截取，String 对象 jclass str_clz = (*env)-&gt;FindClass(env,&quot;java/lang/String&quot;); jmethodID init_mid = (*env)-&gt;GetMethodID(env,str_clz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;); jobject j_str = (*env)-&gt;NewObject(env, str_clz, init_mid); // 还有 100 行代码 // jobject 不要再使用了，要回收 javaGC 的源码 (*env)-&gt;DeleteLocalRef(env,j_str); // 删除了就不能再使用了，C 和 C++ 都需要自己释放内存（静态开辟的不需要，动态开辟的需要）&#125;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_saveGlobalRef(JNIEnv *env, jclass jclz, jstring str)&#123; // 保存全局变量，其他方法需要用到 globalStr = (*env)-&gt;NewGlobalRef(env, str); // NewWeakGlobalRef (java 中的软引用很像) 无法保证对象不为空&#125;JNIEXPORT jstring JNICALL Java_com_darren_day15_Simple1_getGlobalRef(JNIEnv *env, jclass jclz)&#123; return globalStr;&#125;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_delteGlobalRef(JNIEnv *env, jclass jclz)&#123; (*env)-&gt;DeleteGlobalRef(env,globalStr);&#125;/*JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_staticLocalCache(JNIEnv *env, jclass jclz, jstring name)&#123; // name属性 赋值操作 // static jfieldID f_id = NULL;// 局部缓存，这个方法会被多次调用，不需要反复的去获取 jfieldID OpenCV WebRtc if (f_id == NULL)&#123; f_id = (*env)-&gt;GetStaticFieldID(env, jclz, &quot;name&quot;, &quot;Ljava/lang/String;&quot;); &#125;else&#123; printf(&quot;fieldID is not null\\n&quot;); &#125; (*env)-&gt;SetStaticObjectField(env, jclz, f_id, name);&#125;*/// 全局静态缓存，在构造函数中初始化的时候会去缓存static jfieldID f_name_id = NULL;static jfieldID f_name1_id = NULL;static jfieldID f_name2_id = NULL;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_staticLocalCache(JNIEnv *env, jclass jclz, jstring name)&#123; // 如果这个方法会反复的被调用，那么不会反复的去获取 jfieldID (*env)-&gt;SetStaticObjectField(env, jclz, f_name_id, name);&#125;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_initStaticCache(JNIEnv *env, jclass jclz)&#123; // 初始化全局静态缓存 f_name_id = (*env)-&gt;GetStaticFieldID(env, jclz, &quot;name&quot;, &quot;Ljava/lang/String;&quot;); f_name1_id = (*env)-&gt;GetStaticFieldID(env, jclz, &quot;name1&quot;, &quot;Ljava/lang/String;&quot;); f_name2_id = (*env)-&gt;GetStaticFieldID(env, jclz, &quot;name2&quot;, &quot;Ljava/lang/String;&quot;);&#125;JNIEXPORT void JNICALL Java_com_darren_day15_Simple1_exception(JNIEnv *env, jclass jclz)&#123; // 假设现在想给 ，name 赋值 name3 jfieldID f_id = (*env)-&gt;GetStaticFieldID(env, jclz, &quot;name3&quot;, &quot;Ljava/lang/String;&quot;); // 好几种方式 // 1. 补救措施 ，name3 我拿 name // 1.1 有没有异常 jthrowable throwable = (*env)-&gt;ExceptionOccurred(env); /*if (throwable)&#123; // 补救措施，先把异常清除 printf(&quot;有异常&quot;); // 清除异常 (*env)-&gt;ExceptionClear(env); // 重新获取 name 属性 f_id = (*env)-&gt;GetStaticFieldID(env, jclz, &quot;name&quot;, &quot;Ljava/lang/String;&quot;); &#125;*/ // 2. 想给 java 层抛一个异常 if (throwable)&#123; // 清除异常 (*env)-&gt;ExceptionClear(env); // Throw 抛一个 java 的 Throwable 对象 jclass no_such_clz = (*env)-&gt;FindClass(env,&quot;java/lang/NoSuchFieldException&quot;); (*env)-&gt;ThrowNew(env, no_such_clz,&quot;NoSuchFieldException name3&quot;); return;// 记得 return &#125; jstring name = (*env)-&gt;NewStringUTF(env, &quot;Darren&quot;); (*env)-&gt;SetStaticObjectField(env, jclz, f_id, name);&#125;","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/15_Android.mk和Android.bp对应关系/","text":"Android.bp文件是Android系统的一种编译配置文件，是用来代替原来的Android.mk文件的。 【1】字符串表示1234mk： chips_dir := ../../../frameworks/opt/chips/resbp： chips_dir = [&quot;../../../frameworks/opt/chips/res&quot;] 1234mk： res_dirs := $(chips_dir) $(color_picker_dir) $(timezonepicker_dir) resbp： res_dirs = chips_dir + color_picker_dir + timezonepicker_dir + [&quot;res&quot;] 1234mk： src_dirs := srcbp： src_dirs = [&quot;src&quot;] 【2】mk和bp模块对应表12345678910111213141516171819202122232425262728293031323334353637383940414243include $(BUILD_SHARED_LIBRARY) -&gt; cc_library_shared &#123;&#125;include $(BUILD_STATIC_LIBRARY) -&gt; cc_library_static&#123;&#125;include $(BUILD_HOST_SHARED_LIBRARY) -&gt; cc_library_host_shared&#123;&#125;include $(BUILD_HOST_STATIC_LIBRARY) -&gt; cc_library_host_static&#123;&#125;include $(BUILD_HEADER_LIBRARY) -&gt; cc_library_headers&#123;&#125;include $(BUILD_EXECUTABLE) -&gt; cc_binary&#123;&#125;include $(BUILD_HOST_EXECUTABLE) -&gt; cc_binary_host&#123;&#125;include $(BUILD_NATIVE_TEST) -&gt; cc_test&#123;&#125;include $(BUILD_HOST_NATIVE_TEST) -&gt; cc_test_host&#123;&#125;include $(BUILD_NATIVE_BENCHMARK) -&gt; cc_benchmark&#123;&#125;include $(BUILD_HOST_NATIVE_BENCHMARK) -&gt; cc_benchmark_host&#123;&#125;include $(BUILD_JAVA_LIBRARY) -&gt; java_library_installable&#123;&#125;include $(BUILD_STATIC_JAVA_LIBRARY) -&gt; java_library&#123;&#125;include $(BUILD_HOST_JAVA_LIBRARY) -&gt; java_library_host&#123;&#125;include $(BUILD_HOST_DALVIK_JAVA_LIBRARY) -&gt; java_library_host_dalvik&#123;&#125;include $(BUILD_PACKAGE) -&gt; android_app&#123;&#125;include $(BUILD_RRO_PACKAGE) -&gt; runtime_resource_overlay&#123;&#125;include $(BUILD_CTS_EXECUTABLE) -&gt; cc_binary&#123;&#125; include $(BUILD_CTS_SUPPORT_PACKAGE) -&gt; cts_support_package&#123;&#125; include $(BUILD_CTS_PACKAGE) -&gt; cts_package&#123;&#125; include $(BUILD_CTS_TARGET_JAVA_LIBRARY) -&gt; cts_target_java_library &#123;&#125;include $(BUILD_CTS_HOST_JAVA_LIBRARY) -&gt; cts_host_java_library&#123;&#125; 【3】mk和bp prebuilt 对应表123456&quot;SHARED_LIBRARIES&quot;: &quot;cc_prebuilt_library_shared&quot;,&quot;STATIC_LIBRARIES&quot;: &quot;cc_prebuilt_library_static&quot;,&quot;EXECUTABLES&quot;: &quot;cc_prebuilt_binary&quot;,&quot;JAVA_LIBRARIES&quot;: &quot;java_import&quot;,&quot;APPS&quot;: &quot;android_app_import&quot;,&quot;ETC&quot;: &quot;prebuilt_etc&quot;, 【4】mk和bp属性对应表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231LOCAL_PACKAGE_NAME := Calendar -&gt; name: &quot;Calendar&quot;==================================================LOCAL_JACK_COVERAGE_INCLUDE_FILTER := com.android.calendar.* -&gt; jacoco: &#123; include_filter: [&quot;com.android.calendar.*&quot;],&#125;==================================================mk: LOCAL_SRC_FILES := $(call all-java-files-under, src)bp: srcs: [&quot;src/**/*.java&quot;],==================================================mk:LOCAL_STATIC_JAVA_LIBRARIES := \\ android-common \\ libchips \\ colorpicker \\ android-opt-timezonepicker \\ androidx.legacy_legacy-support-v4 \\ calendar-commonbp:static_libs: [ &quot;android-common&quot;, &quot;libchips&quot;, &quot;colorpicker&quot;, &quot;android-opt-timezonepicker&quot;, &quot;androidx.legacy_legacy-support-v4&quot;, &quot;calendar-common&quot;,],==================================================LOCAL_SDK_VERSION := current -&gt; sdk_version: &quot;current&quot;,==================================================mk:LOCAL_NOTICE_FILE := $(LOCAL_PATH)/NOTICEdp:notice: LOCAL_PATH + &quot;/NOTICE&quot;,==================================================mk:# 混淆规则配置文件LOCAL_PROGUARD_FLAG_FILES := proguard.flagsbp:optimize: &#123; proguard_flags_files: [&quot;proguard.flags&quot;],&#125;,==================================================# true:将apk安装到priv-app下LOCAL_PRODUCT_MODULE := true -&gt; product_specific: true,==================================================mk:LOCAL_AAPT_FLAGS := --auto-add-overlayLOCAL_AAPT_FLAGS += --extra-packages com.android.ex.chipsLOCAL_AAPT_FLAGS += --extra-packages com.android.colorpickerLOCAL_AAPT_FLAGS += --extra-packages com.android.timezonepickerbp:aaptflags: [&quot;--auto-add-overlay&quot;] + [ &quot;--extra-packages&quot;, &quot;com.android.ex.chips&quot;,] + [ &quot;--extra-packages&quot;, &quot;com.android.colorpicker&quot;,] + [ &quot;--extra-packages&quot;, &quot;com.android.timezonepicker&quot;,],==================================================mk:LOCAL_STATIC_ANDROID_LIBRARIES := \\ androidx.legacy_legacy-support-v13 \\ androidx.legacy_legacy-support-v4 \\ androidx.core_corebp:static_libs: [ &quot;androidx.legacy_legacy-support-v13&quot;, &quot;androidx.legacy_legacy-support-v4&quot;, &quot;androidx.core_core&quot;,],==================================================mk:LOCAL_STATIC_JAVA_LIBRARIES := android-ex-camera2-portabilityLOCAL_STATIC_JAVA_LIBRARIES += xmp_toolkitLOCAL_STATIC_JAVA_LIBRARIES += glideLOCAL_STATIC_JAVA_LIBRARIES += guavaLOCAL_STATIC_JAVA_LIBRARIES += jsr305bp:static_libs: [&quot;android-ex-camera2-portability&quot;] + [&quot;xmp_toolkit&quot;] + [&quot;glide&quot;] + [&quot;guava&quot;] + [&quot;jsr305&quot;],==================================================mk:LOCAL_SRC_FILES := $(call all-java-files-under, src)LOCAL_SRC_FILES += $(call all-java-files-under, src_pd)LOCAL_SRC_FILES += $(call all-java-files-under, src_pd_gcam)bp:srcs: [&quot;src/**/*.java&quot;] + [&quot;src_pd/**/*.java&quot;] + [&quot;src_pd_gcam/**/*.java&quot;],==================================================mk:LOCAL_RESOURCE_DIR += \\ $(LOCAL_PATH)/res \\ $(LOCAL_PATH)/res_pbp:resource_dirs: [ &quot;res&quot;, &quot;res_p&quot;,],==================================================mk:LOCAL_AAPT_FLAGS := \\ --auto-add-overlay \\ --version-name &quot;$(version_name_package)&quot; \\ --version-code $(version_code_package) \\bp:aaptflags: [ &quot;--auto-add-overlay&quot;, &quot;--version-name&quot;, &quot;\\&quot;&quot; + version_name_package + &quot;\\&quot;&quot;, &quot;--version-code&quot;,] + version_code_package,==================================================# 使用SDK的hide的apiLOCAL_PRIVATE_PLATFORM_APIS := true -&gt; platform_apis: true,==================================================LOCAL_CERTIFICATE := platform -&gt; certificate: &quot;platform&quot;,==================================================LOCAL_JAVA_LIBRARIES += org.apache.http.legacy -&gt; libs: [&quot;org.apache.http.legacy&quot;],==================================================mk:LOCAL_JNI_SHARED_LIBRARIES := libjni_tinyplanet libjni_jpegutil dp:jni_libs: [ &quot;libjni_tinyplanet&quot;, &quot;libjni_jpegutil&quot;,],==================================================mk: # 声明用到的注解LOCAL_ANNOTATION_PROCESSORS := \\ auto_value_plugin \\ javapoet-prebuilt-jar \\ dialer-dagger2 \\ dialer-dagger2-compiler \\ dialer-dagger2-producers \\ dialer-glide-annotation \\ dialer-glide-compiler \\ dialer-guava \\ dialer-javax-annotation-api \\ dialer-javax-inject \\ dialer-rootcomponentprocessorbp: plugins: [ &quot;auto_value_plugin&quot;, &quot;javapoet-prebuilt-jar&quot;, &quot;dialer-dagger2&quot;, &quot;dialer-dagger2-compiler&quot;, &quot;dialer-dagger2-producers&quot;, &quot;dialer-glide-annotation&quot;, &quot;dialer-glide-compiler&quot;, &quot;dialer-guava&quot;, &quot;dialer-javax-annotation-api&quot;, &quot;dialer-javax-inject&quot;, &quot;dialer-rootcomponentprocessor&quot;,],==================================================LOCAL_OVERRIDES_PACKAGES := Calculator -&gt; overrides: [&quot;Calculator&quot;],==================================================LOCAL_MIN_SDK_VERSION := 26 -&gt; min_sdk_version: &quot;26&quot;,==================================================LOCAL_PRIVILEGED_MODULE := true -&gt; privileged: true,==================================================LOCAL_SYSTEM_EXT_MODULE := true -&gt; system_ext_specific: true,==================================================mk:LOCAL_OVERRIDES_PACKAGES := Home Launcher2 Launcher3 Launcher3QuickStepbp:overrides: [ &quot;Home&quot;, &quot;Launcher2&quot;, &quot;Launcher3&quot;, &quot;Launcher3QuickStep&quot;,],==================================================LOCAL_REQUIRED_MODULES := privapp_whitelist_com.android.launcher3 -&gt; required: [&quot;privapp_whitelist_com.android.launcher3&quot;],==================================================mk:LOCAL_FULL_LIBS_MANIFEST_FILES := \\ $(LOCAL_PATH)/AndroidManifest.xml \\ $(LOCAL_PATH)/AndroidManifest-common.xmlbp:additional_manifests: [ LOCAL_PATH + &quot;/AndroidManifest.xml&quot;, LOCAL_PATH + &quot;/AndroidManifest-common.xml&quot;,],==================================================LOCAL_MANIFEST_FILE := go/AndroidManifest.xml -&gt; manifest: &quot;go/AndroidManifest.xml&quot;,==================================================mk:# 混淆配置，默认为full obfuscation，全代码混淆，disabled不开启LOCAL_PROGUARD_ENABLED := disabledLOCAL_PROGUARD_ENABLED := full obfuscationdp:optimize: &#123; enabled: false,&#125;,==================================================mk:LOCAL_MODULE_PATH := $(TARGET_OUT_PRODUCT_APPS)bp:local_module_path: &#123; var: &quot;TARGET_OUT_PRODUCT_APPS&quot;,&#125;,==================================================LOCAL_COMPATIBILITY_SUITE := general-tests -&gt; test_suites: [&quot;general-tests&quot;],==================================================mk:include $(CLEAR_VARS)LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := \\ contextualcards:libs/contextualcards.aarinclude $(BUILD_MULTI_PREBUILT)bp:android_library_import &#123; name: &quot;contextualcards&quot;, aars: [&quot;libs/contextualcards.aar&quot;],&#125; 【5】函数宏1234567LOCAL_PATH := $(call my-dir)：返回Android.mk 的目录include $(call all-java-files-under,&lt;name&gt;)：返回位于&lt;name&gt;目录下的所有java文件。 如果不指定&lt;name&gt;，怎么返回my-dir目录下所有的java文件。include $(call all-makefiles-under,&lt;name&gt;)：返回位于当前 &lt;name&gt; 路径下所有目录中的 Android.mk 文件列表。 利用此函数，可以为构建系统提供深度嵌套的源目录层次结构。 默认情况下，系统只在 Android.mk 文件所在的目录中查找文件。LOCAL_SRC_FILES := $(call all-logtags-files-under, src)：返回 src 路径下所有 logtags 格式的文件。 【6】未找到对应关系123456789101112131415161718192021222324252627LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0LOCAL_LICENSE_CONDITIONS := notice===========================================# 开启AAPT2打包APK，AAPT是Android Asset Packaging Tool的缩写，AAPT2在AAPT的基础做了优化。LOCAL_USE_AAPT2 := true===========================================# 在什么类型的版本下编译# user/debug/eng: 指定该模块只在 user 版本下才编译（makePRODUCT-XXX-user）# optional: 在所有版本下都会编译LOCAL_MODULE_TAGS := optional===========================================引入aar：LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := contextualcards:libs/contextualcards.aarinclude $(BUILD_MULTI_PREBUILT)===========================================# 声明 mk 要使用到的共享 JNI 库的名称LOCAL_JNI_SHARED_LIBRARIES := libbluetooth_jni===========================================mk:# 声明用到的注解器LOCAL_ANNOTATION_PROCESSOR_CLASSES := \\ androidx.room.RoomProcessor===========================================# protocol 相关配置LOCAL_PROTOC_OPTIMIZE_TYPE===========================================Android.mk 最后一句：include $(call all-makefiles-under, $(LOCAL_PATH)) 原文链接：https://www.jianshu.com/p/22cfdb1ad7b5","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/14_Application.mk/","text":"Application.mk中定义一些全局(整个项目)的配置，配置相对较少，比较简单。 下面是基本配置： 1234567891011121314151617181920212223242526272829# 确定CPU架构APP_ABI := armeabi-v7a# 支持所有CPU架构：armeabi-v7a arm64-v8a x86_64 等等# APP_ABI := all# 一般对应Android SDK的最低版本APP_PLATFORM := android-21# c++_static 静态链接# c++_shared 动态链接# system 系统默认# 如果生成的so库包含静态.a文件，这个属性要写成c++_static，否则可以不用写APP_STL := c++_shared# 用来指定C++功能APP_CPP_FEATURES += exceptions rttiifdef APP_DEBUG ifeq ($(APP_DEBUG),true) CFLAGS+= -O0 -g LOCAL_CFLAGS+= -D_DEBUG APP_OPTIM := debug else CFLAGS+= -O2 -g LOCAL_CFLAGS+= -DNDEBUG APP_OPTIM := release endifendif 【1】APP_OPTIM 123将此可选变量定义为 `release` 或 `debug`。在构建应用的模块时可使用它来更改优化级别。发行模式是默认模式，可生成高度优化的二进制文件。调试模式会生成未优化的二进制文件，更容易调试。 【2】APP_DEBUG 可以在AS中手动设置 Build Variants 改变的值。 12如果选择 debug，APP_DEBUG等于true；如果选择 release，APP_DEBUG等于false； 【2】APP_CFLAGS 1为任何模块编译任何 C 或 C++ 源代码时传递到编译器的一组 C 编译器标志 【3】APP_CPPFLAGS 1构建 C++ 源文件时传递到编译器的一组 C++ 编译器标志。 【4】APP_ABI 123456789101112需要生成的cpu架构。现在手机主要是armeabi-v7a。查看手机cpu架构的方法是：adb shell cat /proc/cpuinfoadb shell getprop ro.product.cpu.abiapk在安装的时候，如果手机是armeabi-v7a的，则会首先查看apk中是否存在armeabi-v7a目录，如果没有就会查找armeabi。如果目标是armeabi-v7a，但是拥有一个armeabi的，也可以把它放到armeabi-v7a目录下。但是反过来不行。 ABI(横 so)&#x2F;CPU(竖 手机) armeabi armeabi-v7a arm64-v8a x86 x86_64 ARMV5 支持 ARMV7 支持 支持 ARMV8 支持 支持 支持 X86 支持 X86_64 支持 支持 【5】APP_PLATFORM 1与app最小SDK版本对应即可。 【6】APP_STL 12默认情况下，NDK 构建系统为 Android 系统提供的最小 C++ 运行时库 (`system/lib/libstdc++.so`) 提供 C++ 功能。 名称 说明&gt; 功能 libstdc++（默认） 默认最小系统 C++ 运行时库。 不适用 gabi++_static GAbi++ 运行时（静态）。 C++ 异常和 RTTI gabi++_shared GAbi++ 运行时（共享）。 C++ 异常和 RTTI stlport_static STLport 运行时（静态）。 C++ 异常和 RTTI；标准库 stlport_shared STLport 运行时（共享）。 C++ 异常和 RTTI；标准库 gnustl_static GNU STL（静态）。 C++ 异常和 RTTI；标准库 gnustl_shared GNU STL（共享）。 C++ 异常和 RTTI；标准库 c++_static LLVM libc++ 运行时（静态）。 C++ 异常和 RTTI；标准库 c++_shared LLVM libc++ 运行时（共享）。 C++ 异常和 RTTI；标准库 一般情况下，如果设置的配置不符合当前版本，会有明显的错误提示： 【7】在 build.gradle 中配置全局参数 全局参数不仅可以在Application.mk中配置，还可以在 build.gradle 中配置。 123456externalNativeBuild &#123; ndkBuild &#123; arguments &quot;APP_STL=c++_static&quot;, &quot;APP_PLATFORM := android-21&quot; abiFilters &#x27;armeabi-v7a&#x27; &#125;&#125; 多个配置以逗号隔开。 原文链接：https://www.jianshu.com/p/4de7f04bc01c","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/17_Shell脚本/","text":"shell 是一种脚本语言。 脚本：本质是一个文件，文件里面存放的是 特定格式的指令，系统可以使用脚本解析器 翻译或解析 指令 并执行（它不需要编译） shell 既是应用程序 又是一种脚本语言（应用程序 解析 脚本语言） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415#!/bin/bash# 第一行主要用于指定解释器（包括：bin/sh、bin/bash、usr/bin/sh、usr/bin/bash）# 我是单行注释# 执行脚本的方式有三种：sh test.sh、. test.sh、source test.sh# 决定路径执行：./test.sh，这种执行方式需要可执行权限，给脚本添加可执行权限：chmod 777 test.sh# ./test.sh 方式执行需要指定解释器# 三种变量：局部变量、环境变量、shell变量# 变量：name=&quot;hello&quot; # 等号两边不能有空格echo $&#123;name&#125; # 输出普通变量function test() &#123; local name=&quot;test hello&quot; # 局部变量用local关键字修饰，local必须在函数中使用 echo $&#123;name&#125;&#125;name=&quot;only_read&quot;readonly name # readonly修饰符，修饰只读变量echo $name # 或者 $&#123;name&#125;name1=&quot;name1&quot;unset name1 # 删除变量，不能删除只读变量，删除后的变量无法被访问# 单引号和双引号字符串的区别name2=&#x27;name2&#x27; # 单引号字符串，字符串内不能转义，不能包含变量name3=&quot;name3\\&quot;$&#123;name2&#125;&quot; # 双引号字符串，字符串内可以有转义，也可以包含变量echo $&#123;name3&#125;# 字符串拼接str1=&quot;1&quot;&quot;2&quot;&quot;3&quot;&#x27;4&#x27;&#x27;5&#x27; # 字符串字面量拼接str2=&#x27;6&#x27;str3=$&#123;str1&#125;$&#123;str2&#125; # 字符串变量拼接echo $str3str4=`date`&#x27;===&#x27;$str3 # 命令拼接echo $str4# 获取字符串长度的5种方式echo &quot;hello&quot; | wc -L # 1、wc -L 获取当前行的长度expr length $&#123;str3&#125; # 2、使用expr length可以获取string的长度echo &quot;abc&quot; |awk -F &quot;&quot; &#x27;&#123;print NF&#125;&#x27; # 3、awk获取域的个数echo &quot;Alex&quot; |awk &#x27;&#123;print length($0)&#125;&#x27; # 4、通过awk+length的方式获取字符串长度str5=Alexecho $&#123;#str5&#125; # 通5、过 $&#123;#str5&#125; 的方式获取字符串长度# 提取字符串str6=123456789.jpgecho $&#123;str6##*56&#125; # 从左向右截取最后一个string后的字符串 ，输出：789.jpgecho $&#123;str6#*56&#125; # 左向右截取第一个string后的字符串，输出：789.jpgecho $&#123;str6%%56*&#125; # 从右向左截取最后一个string后的字符串，输出：1234echo $&#123;str6%56*&#125; # 从右向左截取第一个string后的字符串，输出：1234echo $&#123;str6:1:3&#125; # 截取字符串，输出：234# 数组echo &quot;====数组==== 数组越界不会报错&quot;array=(1 2 3 4 5 6)echo $&#123;array&#125; # 输出数组，默认输出角标为0的数据echo $&#123;array[5]&#125; # 输出数组角标为5的数据array[0]=7 # 数组赋值echo $&#123;array&#125; # 输出数组array=([0]=0 [1]=1 [2]=2 [3]=3 [4]=4 [5]=5 [6]=6) # 数组初始化或赋值echo $&#123;array[6]&#125; # 输出数组角标为6的数据for((i=0;i&lt;7;i++)) # for循环遍历数组do echo &quot;array[$i]=$&#123;array[$i]&#125;&quot;doneecho $&#123;array[*]&#125; # 输出整个数组echo &quot;a len: $&#123;#array[*]&#125;&quot; # 输出数组的长度a=(1 2 3 4 5 6)b=(&quot;hello&quot; &quot;zhaixue.cc&quot;)c=($&#123;a[*]&#125; $&#123;b[*]&#125;) # 数组拼接echo $&#123;c[*]&#125; # 输出整个数组echo &quot;c length: $&#123;#c[*]&#125;&quot; # 输出：c length: 8unset c[6] # 删除数组中的元素echo &quot;c length: $&#123;#c[*]&#125;&quot; # 输出：c length: 7# 参数传递# $0 代表执行的文件名# $1 代表传入的第1个参数# $n 代表传入的第n个参数# $# 参数个数# $* 以一个单字符串显示所有向脚本传递的参数。# $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数# $$ 脚本运行的当前进程号# $！ 后台运行的最后一个进程的ID# $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。# 运算符 需注意：条件表法式需要放在方括号之间，并且要有空格。使用expr进行计算时需要使用反引号。# 加法 expr $a + $b# 减法 expr $a - $b# 乘法 expr $a \\* $b# 除法 expr $b / $a# 取余 expr $b % $a# 赋值 a=$b# 相等 [ $a == $b ]# 不相等 [ $a != $b ]a=10b=20c=`expr $a + $b` # 加法运算echo &quot;a + b : $c&quot;# 关系运算符# 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。# 关系用 [] 来表示，echo &quot;====关系运算符====&quot;a=1b=2# 检测两个数是否相等 [ $a -eq $b ] -eqif [ $a == $b ]then echo &quot;a和b相等&quot;else echo &quot;a和b不相等&quot;fi# 或者if [ $a -eq $b ]then echo &quot;a和b相等&quot;else echo &quot;a和b不相等&quot;fi# 检测两个数是否不相等 [ $a -ne $b ] -neif [ $a != $b ]then echo &quot;a和b不相等&quot;else echo &quot;a和b相等&quot;fi# 或者if [ $a -ne $b ]then echo &quot;a和b不相等&quot;else echo &quot;a和b相等&quot;fi# 检测左边的数是否大于右边的 [ $a -gt $b ] -gtif [ $a -gt $b ]then echo &quot;a大于b&quot;else echo &quot;a等于b或a小于b&quot;fi# 检测左边的数是否小于右边的 [ $a -lt $b ] -ltif [ $a -lt $b ]then echo &quot;a小于b&quot;else echo &quot;a等于b或a大于b&quot;fi# 检测左边的数是否大于等于右边的 [ $a -ge $b ] -geif [ $a -ge $b ]then echo &quot;a大于等于b&quot;else echo &quot;a小于b&quot;fi# 检测左边的数是否小于等于右边的 [ $a -le $b ] -leif [ $a -le $b ]then echo &quot;a小于等于b&quot;else echo &quot;a大于b&quot;fi# 布尔运算符# 非运算 [ ! false ] !# 或运算 [ $a -lt 20 -o $b -gt 100 ] -o# 与运算 [ $a -lt 20 -a $b -gt 100 ] -a# 逻辑运算符# 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] &amp;&amp;# 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] ||# 布尔运算符和逻辑运算符的区别：# 语法上，逻辑运算需要双括弧，布尔运算只需要单大括弧功能上，逻辑运算具有特殊的短路功能，# 即是在AND运算中第一个表达式为false时则不执行第二个表达式，# 在OR运算中第一个表达式为true时不执行第二个表达式。# 字符串运算符# 检测两个字符串是否相等 [ $a = $b ] =# 检测两个字符串是否不相等 [ $a != $b ] !=# 检测字符串长度是否为0 [ -z $a ] -z# 检测字符串长度是否不为 0 [ -n “$a” ] -n# 检测字符串是否为空 [ $a ] $# 文件测试运算符# 检测文件是否是块设备文件 [ -b $file ] -b file# 检测文件是否是字符设备文件 [ -c $file ] -c file# 检测文件是否是目录 [ -d $file ] -d file# 检测文件是否是普通文件（既不是目录，也不是设备文件） [ -f $file ] 返回 true -f file# 检测文件是否设置了 SGID 位 [ -g $file ] -g file# 检测文件是否设置了粘着位(Sticky Bit) [ -k $file ] -k file# 检测文件是否是有名管道 [ -p $file ] -p file# 检测文件是否设置了 SUID 位 [ -u $file ] -u file# 检测文件是否可读 [ -r $file ] -r file# 检测文件是否可写 [ -w $file ] -w file# 检测文件是否可执行 [ -x $file ] -x file# 检测文件是否为空（文件大小是否大于0） [ -s $file ] -s file# 检测文件（包括目录）是否存在 [ -e $file ] -e filefile=&quot;/home/westos/Desktop/textcpp/test.sh&quot;if [ -e $file ]then echo &quot;文件存在&quot;else echo &quot;文件不存在&quot;fi# 运算指令# (( )) 可以直接使用双圆括弧计算其中的内容，如((var=a+b))# let 在计算表达式的时候我们可以直接使用let，如let var=a+b。# expr var=`expr a+b`echo $var# bc计算器 :bc计算器支持shell中的小数进行运算，并且可以交互式或者非交互式的使用var=$(echo &quot;(1.1+2.1)&quot;|bc)echo $var# $[]: 计算中括弧中的内容，如echo $[1+2]# 控制语句a=1b=1# if-fiif [ $a -eq $b ]then echo &quot;a等于b&quot;fi# if-else-fiif [ $a -eq $b ]then echo &quot;a等于b&quot;else echo &quot;a不等于b&quot;fi# if else-if elseif [ $a -gt $b ]then echo &quot;a大于b&quot;elif [ $a -lt $b ]then echo &quot;a小于b&quot;else echo &quot;a等于b&quot;fi# for循环for a in 1 5 3 4do echo $&#123;a&#125; # 一次输出 1 5 3 4donearray=(1 2 3 4 5 6 7 8)for((i=0;i&lt;8;i++)) # for循环遍历数组do echo &quot;array[$i]=$&#123;array[$i]&#125;&quot;donefor loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done# while循环a=1b=4while [ $a -lt $b ]do echo &quot;$&#123;a&#125;&quot; let a++done# 无限循环# for (( ; ; ))# do# echo 111# done# while true# do# echo 222# done# until循环# until 循环执行一系列命令直至条件为 true 时停止a=1until [ $a -gt 3 ]do echo &quot;until循环：$a&quot; let a++done# 跳出循环var=1while(( $var &lt; 5 ))do if(( $var&gt;3 )) then echo &quot;break跳出循环&quot; break fi echo &quot;$var&quot; var=`expr $var + 1`donevar=1while(( $var &lt; 5 ))do echo &quot;$var&quot; var=`expr $var + 1` if [ $var -gt 2 ] &amp;&amp; [ $var -lt 4 ] then echo &quot;continue跳出循环：$var&quot; continue elif [ $var -eq 4 ] then echo &quot;break跳出循环&quot; break fidone# case-esac多选择语句echo &quot;====case-esac多选择语句====&quot;var=100case $var in # 分支语句开始10) echo &quot;输出10&quot; ;; # 相当于break100) echo &quot;输出100&quot; ;; # 相当于breakesac # 分支语句结束# select-in语句# select in是shell中独有的一种循环，非常适合终端的交互场景，它可以显示出带编号的菜单，# 用户输入不同编号就可以选择不同的菜单，并执行不同的功能echo &quot;What is your favourite OS?&quot;select var in &quot;Linux&quot; &quot;Gnu Hurd&quot; &quot;Free BSD&quot; &quot;Other&quot;; do echo &quot;You have selected $var&quot; break;done# 函数function funName() &#123; # function可以省略 echo &quot;执行了funName函数&quot;&#125;funName # 执行函数funWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 # 执行函数并传递参数# 重定向#一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：# 1、标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。# 2、标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。# 3、标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。# &gt; 标准输出覆盖重定向：将命令的输出重定向输出到其他文件中# &gt;&gt; 标准输出追加重定向：将命令的输出重定向输出到其他文件中# &gt;&amp; 标识输出重定向：将一个标识的输出重定向到另一个标识的输入# &lt; 标准输入重定向：命令将从指定文件中读取输入而不是从键盘输入# | 管道符，从一个命令中读取输出并作为另一个命令的输入# 输入重定向# 可以让命令从文件中获取，这样本来的命令需要从标准输入stdin中获取，# 转换为从我们的指定文件中获取。这样本来需要从键盘输入的命令就会转移到文件读取内容# command1 &lt; file # 0&lt;1.txt cat # 重定向输入流# 输出重定向# 输出重定向也是将本来需要输出标准输出文件stdout中转化为我们的指定文件中# cat 1.txt &gt; 2.txt # 将1.txt的内容覆盖到2.txt# cat 1.txt 1&gt; 2.txt # 将1.txt的内容覆盖到2.txt# cat 1.txt &gt;&gt; 2.txt # 将1.txt的内容追加到2.txt# cat 1.txt 1&gt;&gt; 2.txt # 将1.txt的内容追加到2.txt# 标准错误文件重定向# 借助标准错误文件的文件描述符来重定向stderr# command 2&gt;file# 将stdout标准输出文件和stderr标准错误文件合并重定向到一个指定文件中# command &gt; file 2&gt;&amp;1# /dev/null 文件# 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null中，# /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；# 如果尝试从该文件读取内容，那么什么也读不到。# 但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。# command &gt; /dev/null 原文链接：https://www.jianshu.com/p/4599ef826895","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/18_NDK环境配置/","text":"一、Linux环境 1.NDK下载链接：https://github.com/android/ndk/wiki/Unsupported-Downloads（尽量选择R17版本） 2.解压压缩包：unzip xxx.zip 3.配置环境变量：sudo gedit &#x2F;etc&#x2F;profile （在最底部配置环境） 12NDKRO0T=/root/ndk/android-ndk-r17c //(设置一个ndk变量，解压的目录)export PATH=SNDKROOT:SPATH //（配置变量，保存后退出） 4.立即生效：source &#x2F;etc&#x2F;profile 5.验证是否成功：ndk-build 1234//出现以下内容说明配置成功Android NDK: Could not find application project directory !Android NDK: Please define the NDK PROJECT PATH variable to point to it/root/ndk/android-ndk-r17c/build/core/build-local,mk:151: *** Android NDK: Aborting","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/11_编译流程详解静态库与动态库原理/","text":"一、动态库和静态库【1】生成动态库 动态库在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库。Linux中后缀名为“.so”。动态库节省空间:如果一个动态库被两个程序调用,那么这个动态库只需要在内存中。 12345678910【1】分步骤生成动态库 g++ -fPIC -c Hello.cpp -o Hello.o g++ -shared -o libHello.so Hello.o【2】一步生成动态库 g++ -fPIC -shared -o libHello.so Hello.o 或 g++ -fPIC -shared -o libHello.so Hello.cpp 【2】生成静态库 静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。Linux中后缀名为”.a”。 静态库节省时间:不需要再进行动态链接，需要调用的代码直接就在代码内部。 123ar -crv libHello.a Hello.o或ar -crv libHello.a Hello.cpp 【3】链接静态库（生成可执行文件） 123g++ Hello.cpp -o Hello -static -L. -l Hello-L指定库目录，.表示当前目录。-l Hello 指定libHello.a静态库。 【4】-I 添加搜索头文件的路径(大写i) 系统默认头文件搜索路径大致为 1234当前目录(如果是双引号包含的话） --&gt; /usr/include --&gt; /usr/local/include// 添加/home/include 到搜索路径g++ test.cpp -I/home/include 【5】-L 指定要链接的库所在目录,-l 指定路径寻找库文件 123456链接时库搜索路径 /lib --&gt; /usr/lib --&gt;/usr/local/lib运行时库搜索路径 /lib --&gt; /usr/lib // -L 将/lib 添加到库搜索目录,// -l 将 libmt.so 库文件链接到项目 g++ test.cpp -L/usr/local/lib -lfmt 【6】查看可执行文件符号 1nm main 【7】默认优先使用动态库 1gcc main.c -L. -lTest -o main 【8】强制使用静态库 123#-Wl 表示传递给 ld 链接器的参数#最后的 -Bdynamic 表示 默认仍然使用动态库 gcc main.c -L. -Wl,-Bstatic -lTest -Wl,-Bdynamic -o main 【9】打包 .a 到so 1234#打包 .a 到so#--whole-archive: 将未使用的静态库符号(函数实现)也链接进动态库 #--no-whole-archive : 默认，未使用不链接进入动态库gcc -shared -o libMain.so -Wl,--whole-archive libMain.a -Wl,--no-whole-archive 【10】其它命令 –sysroot&#x3D;XX 使用XX作为这一次编译的头文件与库文件的查找目录，查找下面的 usr&#x2F;include usr&#x2F;lib 目录。 1g++ --sysroot=C:\\Users\\94317\\AppData\\Local\\Android\\ndk\\android-ndk-r20b\\sysroot Hello.cpp -isysroot XX 头文件查找目录,覆盖–sysroot ，查找 XX&#x2F;usr&#x2F;include -isystem XX 指定头文件查找路径（直接查找根目录） -IXX 头文件查找目录 优先级： -I -&gt; -isystem -&gt; sysroot 二、gcc和g++的使用GCC编译过程： 12345678910111213141516171)预处理，C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩 展、条件编译的选择等，后缀是 .i文件。test.c是c代码，预处理参数：-E ；另起名称：-ogcc -E test.c –o test.i #得到 .i文件2）编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标 程序，得到机器语言的汇编文件，后缀是 .s文件。编译参数：-Sgcc -S test.i #得到 .s文件3）汇编，将汇编代码翻译成了机器码，但是还不可以运行，后缀是 .o文件。编译参数：-cgcc -c test.s #得到 .o文件4）链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中 的合适信息，通常是虚拟地址，后缀是 .out 文件或者可执行文件gcc test.c #在gcc命令紧跟test源文件名，会有一个 .out 文件gcc test.c -o test01.out #通过 -o 选项来自定义文件名test01.out文件gcc test.c -o #/home/user/local/test.out # 在路径/home/user/local/下生成.out文件./test.out #运行 【1】预处理 123456789不输出文件： gcc -E Hello.cpp（同样适用于c文件） 或 g++ -E Hello.cpp（同样适用于c文件）输出文件：（将预处理信息输出到Hello.i） gcc -E Hello.cpp -o Hello.i（同样适用于c文件） 或 g++ -E Hello.cpp -o Hello.i（同样适用于c文件） 【2】转换为汇编文件 12345678910111213不指定预处理文件： gcc -S Hello.cpp // 生成Hello.s文件（同样适用于c文件） gcc -S Hello.cpp -o Hello.s // 生成Hello.s文件（同样适用于c文件） 或 g++ -S Hello.cpp // 生成Hello.s文件（同样适用于c文件） g++ -S Hello.cpp -o Hello.s // 生成Hello.s文件（同样适用于c文件）指定预处理文件： gcc -S Hello.i // 生成Hello.s文件（同样适用于c文件） gcc -S Hello.i -o Hello.s // 生成Hello.s文件（在windows上测试失败，并没有生成Hello.s，c文件也同样如此） 或 g++ -S Hello.i // 生成Hello.s文件（同样适用于c文件） g++ -S Hello.i -o Hello.s // 生成Hello.s文件（同样适用于c文件） 【3】编译（生成目标文件） 12345678910111213不指定汇编文件： gcc -c Hello.cpp // 生成目标文件Hello.o（同样适用于c文件） gcc -c Hello.cpp -o Hello.o // 生成目标文件Hello.o（同样适用于c文件） 或 g++ -c Hello.cpp // 生成目标文件Hello.o（同样适用于c文件） g++ -c Hello.cpp -o Hello.o // 生成目标文件Hello.o（同样适用于c文件）指定汇编文件： gcc -c Hello.s // 生成目标文件Hello.o（同样适用于c文件） gcc -c Hello.s -o Hello.o // 生成目标文件Hello.o（同样适用于c文件） 或 g++ -c Hello.s // 生成目标文件Hello.o（同样适用于c文件） g++ -c Hello.s -o Hello.o // 生成目标文件Hello.o（同样适用于c文件） 【4】链接（生成可执行文件） 1234567891011121314151617181920不指定目标文件： gcc Hello.cpp // 链接失败，不能生成可执行文件（适用于c文件，生成a.exe） gcc Hello.cpp -o Hello // 链接失败，不能生成可执行文件（适用于c文件，生成Hello.exe） gcc Hello.cpp -o Hello.exe // 链接失败，不能生成可执行文件（适用于c文件，生成Hello.exe） gcc -o Hello Hello.cpp // 链接失败，不能生成可执行文件（适用于c文件，生成Hello.exe） 或 g++ Hello.cpp // 生成a.exe文件（适用于c文件，生成a.exe） g++ Hello.cpp -o Hello // 生成Hello.exe文件（适用于c文件，生成Hello.exe） g++ Hello.cpp -o Hello.exe // 生成Hello.exe文件（适用于c文件，生成Hello.exe） g++ -o Hello Hello.cpp // 生成Hello.exe文件（适用于c文件，生成Hello.exe） g++ -o Hello.exe Hello.cpp // 生成Hello.exe文件（适用于c文件，生成Hello.exe）指定目标文件： gcc Hello.o // 链接失败，不能生成可执行文件（适用于c文件，生成a.exe） gcc Hello.o -o Hello // 链接失败，不能生成可执行文件（适用于c文件，生成Hello.exe） gcc Hello.o -o Hello.exe // 链接失败，不能生成可执行文件（适用于c文件，生成Hello.exe） 或 g++ Hello.o // 生成a.exe文件（适用于c文件，生成a.exe） g++ Hello.o -o Hello // 生成Hello.exe文件（适用于c文件，生成Hello.exe） g++ Hello.o -o Hello.exe // 生成Hello.exe文件（适用于c文件，生成Hello.exe） 【5】执行可执行文件 123.\\Hello或.\\Hello.exe 3、gcc&#x2F;g++多文件多目录同目录多文件的情况下： 123456gcc Hello.c A.c B.c -o Hello或使用通配符：gcc *.c -o Hello如果将头文件放入单独的文件夹中（header文件夹）：gcc -I header *.c -o Hello 4、gcc&#x2F;g++常用编译选项12345678910111213141516171819【1】-o FILE: 指定输出文件名，在编译为目标代码时，这一选项不是必须的。 如果FILE没有指定，缺省文件名是a.out；【2】-c: 只编译生成目标文件，不链接；【3】-Wall: 允许发出gcc能提供的所有有用的警告，也可以用-W(warning)来标记指定的警告； g++ -W Hello.o -o Hello g++ -Wall Hello.o -o Hello【4】-Werror: 把所有警告转换为错误,以在警告发生时中止编译过程； g++ -Werror Hello.o -o Hello【5】-v: 显示在编译过程的每一步中用到的命令； g++ -v Hello.o -o Hello【6】-static: 链接静态库，即执行静态链接,g++默认是链接动态库，如果需要链接静态库需要使用本选项进行指定；【7】-g: 在可执行程序中包含标准调试信息, 使用该选项生成的可执行文件可以用gdb工具进行调试；【8】-w: 关闭所有警告，建议不要使用该选项【9】-shared: 生成共享目标文件。通常用在建立共享库时；【10】-On: 这是一个优化选项，如果在编译时指定该选项，则编译器会根据n的值（n取0到3之间）对代码进行不同程度的优化，其中-O0 表示不优化，n的值越大，优化程度越高；【11】-L: 库文件依赖选项，该选项用于指定编译的源程序依赖的库文件路径，库文件可以是静态链接库，也可以是动态链接库，linux系统默认的库路径是/usr/lib，如果需要的库文件不在这个路径下就要用-L指定 g++ foo.cpp -L/home/lib -lfoo -o foo【12】-I: 该选项用于指定编译程序时依赖的头文件路径，linux平台默认头文件路径在/usr/include下，如果不在该目录下，则编译时需要使用该选项指定头文件所在路径 gcc foo.cpp -I/home/include -o foo","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/13_android.mk/","text":"【1】ndkBuild配置 12345678910111213141516171819202122android &#123; compileSdk 32 defaultConfig &#123; // ... externalNativeBuild &#123; ndkBuild &#123; abiFilters &#x27;armeabi-v7a&#x27; &#125; &#125; ndk &#123; // &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot; abiFilters &#x27;armeabi-v7a&#x27; &#125; &#125; // ... externalNativeBuild &#123; ndkBuild&#123; path file(&#x27;src/main/cpp/Android.mk&#x27;) &#125;&#125; 在模块下的 build.gradle 中配置 ndkBuild，确认CPU架构以及Android.mk路径。 【2】将源码编译成动态库 123456789101112131415161718# 每个Android.mk文件必须以定义LOCAL_PATH为开始# 宏my-dir则由Build System提供，返回包含Android.mk的目录路径LOCAL_PATH := $(call my-dir)# 清除所有LOCAL_开头的变量，除了LOCAL_PATHinclude $(CLEAR_VARS)# 模块名称，需要保证模块名称的唯一性LOCAL_MODULE := native-lib# 指定将要打包的源码，多个文件用空格隔开，如果需要换行，在换行处添加“\\”LOCAL_SRC_FILES := native-lib.cpp# 负责收集自从上次调用 include $(CLEAR_VARS) 后的所有LOCAL_XXX信息，并决定编译成什么# BUILD_STATIC_LIBRARY：编译为静态库# BUILD_SHARED_LIBRARY：编译为动态库# BUILD_EXECUTABLE：编译为可执行程序include $(BUILD_SHARED_LIBRARY) 编译之后，动态库libnative-lib.so会在模块下的 build/intermediates/ndkBuild/ 目录下生成。 【3】Android.mk 编译时日志 1234#输出字符串的方式有如下三种，程度越来越高，有点像Android里面的Log等级$(info string) #一般打印信息，仅仅是显示调试信息$(warning string) #警告级别打印信息，不会停止脚本运行，一般用于严重警告$(error string) #错误级别，会停止编译直接退出来 【4】c&#x2F;c++代码日志在AS控制台上现实 1234567# 加载NDK的日志库LOCAL_LDLIBS := -llog# 负责收集自从上次调用 include $(CLEAR_VARS) 后的所有LOCAL_XXX信息，并决定编译成什么# BUILD_STATIC_LIBRARY：编译为静态库# BUILD_SHARED_LIBRARY：编译为动态库# BUILD_EXECUTABLE：编译为可执行程序include $(BUILD_SHARED_LIBRARY) 需要在 include $(BUILD_SHARED_LIBRARY) 前面添加 LOCAL_LDLIBS := -llog，加载NDK中自带的日志库。 在源代码中定义宏： 123456#define LOG_TAG &quot;native-lib&quot;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__) 在源代码中，打印日志到AS控制台： 1LOGI(&quot;start thread task&quot;); 【5】Android.mk 生成动态库 123456789101112LOCAL_PATH := $(call my-dir)# 清除所有LOCAL_开头的变量，除了LOCAL_PATHinclude $(CLEAR_VARS)# 模块名称，需要保证模块名称的唯一性LOCAL_MODULE := Test# 指定将要打包的源码，多个文件用空格隔开，如果需要换行，在换行处添加“\\”LOCAL_SRC_FILES := Test.cpp# 负责收集自从上次调用 include $(CLEAR_VARS) 后的所有LOCAL_XXX信息，并决定编译成什么# BUILD_STATIC_LIBRARY：编译为静态库# BUILD_SHARED_LIBRARY：编译为动态库# BUILD_EXECUTABLE：编译为可执行程序include $(BUILD_SHARED_LIBRARY) 编译之后， 自动生成动态库，可以在build的以下目录中找到。 【6】使用预先编译好的动态库 编写mk： 1234567891011121314151617181920212223242526272829# 每个Android.mk文件必须以定义LOCAL_PATH为开始# 宏my-dir则由Build System提供，返回包含Android.mk的目录路径LOCAL_PATH := $(call my-dir)# 清除所有LOCAL_开头的变量，除了LOCAL_PATHinclude $(CLEAR_VARS)# 模块名称，需要保证模块名称的唯一性LOCAL_MODULE := Test# 指定将要打包的动态库LOCAL_SRC_FILES := libTest.so# PREBUILT_SHARED_LIBRARY：动态库# PREBUILT_STATIC_LIBRARY：静态库include $(PREBUILT_SHARED_LIBRARY)# 清除所有LOCAL_开头的变量，除了LOCAL_PATHinclude $(CLEAR_VARS)# 模块名称，需要保证模块名称的唯一性LOCAL_MODULE := native-lib# 指定将要打包的源码，多个文件用空格隔开，如果需要换行，在换行处添加“\\”LOCAL_SRC_FILES := native-lib.cpp# 加载Test库LOCAL_SHARED_LIBRARIES := Test# 加载NDK的日志库LOCAL_LDLIBS := -llog# 负责收集自从上次调用 include $(CLEAR_VARS) 后的所有LOCAL_XXX信息，并决定编译成什么# BUILD_STATIC_LIBRARY：编译为静态库# BUILD_SHARED_LIBRARY：编译为动态库# BUILD_EXECUTABLE：编译为可执行程序include $(BUILD_SHARED_LIBRARY) include $(PREBUILT_SHARED_LIBRARY) 预编译动态库，LOCAL_SHARED_LIBRARIES := Test 加载动态库到apk中： 在c++源码中声明libTest.so中的函数 12// 如果是C，需要添加 extern &quot;C&quot;&#123;&#125;extern int test(); 如果调用的是C代码，需要更改为： 123extern &quot;C&quot;&#123; extern int test();&#125; 【7】变量和宏 定义自己的任意变量。在定义变量时请注意，NDK 构建系统会预留以下变量名称： 以 LOCAL_ 开头的名称，例如 LOCAL_MODULE。 以 PRIVATE_、NDK_ 或 APP 开头的名称。构建系统在内部使用这些变量。 小写名称，例如 my-dir。构建系统也是在内部使用这些变量。 如果为了方便而需要在 Android.mk 文件中定义自己的变量，建议在名称前附加 MY_。 【8】其它语法详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621、`LOCAL_MODULE` 可以设置模块名称： LOCAL_MODULE := Test2、使用 `LOCAL_MODULE_FILENAME` 可以覆盖 `LOCAL_MODULE` 设置的模块名称。 LOCAL_MODULE_FILENAME := libTest3、LOCAL_ARM_MODE缺省模式下，ARM目标代码被编译为thumb模式。每个指令16位。如果指定此变量为&#x27;arm&#x27;，则指令为32位。 LOCAL_ARM_MODE := arm 4、TARGET_ARCH目标CPU架构名，如果为“arm” 则声称ARM兼容的指令，与CPU架构版本无关。 ifeq ($(TARGET_ARCH),arm) ... endif5、TARGET_PLATFORM目标平台的名字，对应android版本号，取值包括：android-8、android-9...android-21。 ifeq ($(TARGET_PLATFORM),android-8) ... endif6、TARGET_ARCH_ABI：cpu架构取值包括：32位：armeabi、armeabi-v7a、x86、mips；64位：arm64-v8a、x86_64、mips64；ifeq ($(TARGET_ARCH_ABI),armeabi-v7a) $(warning armeabi-v7a)endififeq ($(TARGET_ARCH_ABI),armeabi) $(warning armeabi)endififeq ($(TARGET_ARCH_ABI),mips) $(warning mips)endififeq ($(TARGET_ARCH_ABI),x86) $(warning x86)endif7、NDK_MODULE_PATHNDK_MODULE_PATH 是一个环境变量，不是Android.mk中设置的变量，可以在 Android.mk中设置NDK_MODULE_PATH：$(call import-add-path,$(LOCAL_PATH))$(call import-add-path,$(LOCAL_PATH)/../external)环境变量可以设置多个，以上配置只设置了两个。$(call import-module,android/cpufeatures)$(call import-module,freetype2/prebuilt/android)$(call import-module,platform/android)$(call import-module,png/prebuilt/android)以上配置的意思是：在环境变量的目录下： 寻找android目录，在android目录下寻找cpufeatures目录； 寻找freetype2目录，在freetype2目录下寻找prebuilt目录，在prebuilt目录下寻找android目录； 寻找platform目录，在platform目录下寻找android目录； 寻找png目录，在png目录下寻找prebuilt目录，在prebuilt目录下寻找android目录。8、LOCAL_CPP_EXTENSION（可选）指出C++扩展名。 LOCAL_CPP_EXTENSION := .cxx从NDK R7后，可以写多个： LOCAL_CPP_EXTENSION := .cxx .cpp .cc 9、LOCAL_CPP_FEATURES（可选）用来指定C++ features。 LOCAL_CPP_FEATURES := rtti LOCAL_CPP_FEATURES := exceptions10、LOCAL_C_INCLUDES一个可选的path列表，相对于NDK ROOT目录，编译时将会把这些目录附上，主要为了头文件的引用。 LOCAL_C_INCLUDES := sources/foo LOCAL_C_INCLUDES := $(LOCAL_PATH)/../foo11、LOCAL_CFLAGS（可选）在编译C/C++ source 时添加如Flags，用来附加编译选项。注意：不要尝试在此处修改编译的优化选项和Debug等级，它会通过您Application.mk中的信息自动指定。-Wall：是打开警告开关。-O：代表默认优化，可选：-O0不优化，-O1低级优化，-O2中级优化，-O3高级优化，-Os代码空间优化。-g：是生成调试信息，生成的可执行文件具有和源代码关联的可调试的信息。-fopenmp：OpenMp是由OpenMP Architecture Review Board牵头提出的，并已被广泛接受的， 用于共享内存并行系统的多处理器程序设计的一套指导性的编译处理方案(Compiler Directive)。 OpenMP支持的编程语言包括C语言、C++和Fortran；而支持OpenMp的编译器包括Sun Compiler，GNU Compiler和Intel Compiler等。 OpenMp提供了对并行算法的高层的抽象描述，程序员通过在源代码中加入专用的pragma来指明自己的意图， 由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。 当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为串行)， 代码仍然可以正常运作，只是不能利用多线程来加速程序执行。-D：增加全局宏定义-ffast-math：浮点优化选项，极大地提高浮点运算速度。-mfloat-abi=softfp 浮点运算12、LOCAL_CPPFLAGS C++ Source 编译时添加的C Flags，这些Flags将出现在LOCAL_CFLAGS flags 的后面。13、LOCAL_WHOLE_STATIC_LIBRARIES 静态库全链接，不同于LOCAL_STATIC_LIBRARIES，类似于使用--whole-archive， LOCAL_WHOLE_STATIC_LIBRARIES在连接静态连接库的时候不会移除&quot;daed code&quot;， 何谓dead code呢，就是调用者模块永远都不会用到的代码段和变量。14、LOCAL_LDLIBS链接flags，链接的库不产生依赖关系，一般用于不需要重新编译的库，可以用它来添加系统库。 LOCAL_LDLIBS += -lm –lz –lc -lcutils –lutils –llog …15、LOCAL_ALLOW_UNDEFINED_SYMBOLS默认情况下，在试图编译一个共享库时，任何未定义的引用将导致一个“未定义的符号”错误。然而，如果你因为某些原因，需要不启动这项检查，把这个变量设为&#x27;true&#x27;。注意相应的共享库可能在运行时加载失败。（这个一般尽量不要去设为true）16、LOCAL_ARM_NEON设置为true时，会将浮点编译成neon指令。这会极大地加快浮点运算（前提是硬件支持），只有targeting为&#x27;armeabi-v7a&#x27;时才可以。17、LOCAL_DISABLE_NO_EXECUTEAndroid NDK r4版本开始支持这种&quot;NX bit&quot;的安全功能。默认是启用的，你也可以设置该变量的值为true来禁用它。但不推荐这么做。该功能不会修改ABI，只在ARMv6+CPU的设备内核上启用。18、LOCAL_EXPORT_CFLAGS定义这个变量用来记录C/C++编译器标志集合，并且会被添加到其他任何以LOCAL_STATIC_LIBRARIES和LOCAL_SHARED_LIBRARIES的模块的LOCAL_CFLAGS定义中。注意：此处NDK版本为NDK R7C。（不同NDK版本，ndk-build所产生的Makefile并不完全相同）19、LOCAL_LDFLAGS # 指定动态库的路径以及ffmpeg库LOCAL_LDFLAGS := -L$(LOCAL_PATH)/src/main/jniLibs/$(TARGET_ARCH_ABI) -lffmpeg 原文链接：https://www.jianshu.com/p/4dbb47a9e044","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android FrameWork/Eclipse安装教程/","text":"一、Eclipse安装 1.官网地址：https://www.eclipse.org/ 2.点击【Download】 ，进入eclispe下载页面，点击【Download x86_64】这个按钮直接下载eclipse软件; 3.下载后安装时选择：Eclipse IDE for Java Developers 4.选择安装路径及jre版本号； 5.Eclipse运行后会弹出一个对话框，提示选择工作空间（Workspace）; 二、使用Eclipse进行程序开发 1、创建Java项目，点击“File”→“New”→“Project…”。 2、选择“Java Project”，点击【Next】下一步。 3、在Project name（项目名字）框里取个名字叫”Chapter01”（第一章的意思），其余选项保持默认，然后点击【Finsh】完成。 4、在项目下创建包，找到刚刚创建的Chapter01项目展开找到src文件夹右键打开找到“New”→“Package”。 5、打开“Package”后，在“name”框里取名叫“haha”，“Source folder”意思是项目所在的目录，Chapter01&#x2F;src就是指这个包在Chapter01项目下的src文件里，然后单击【Finish】完成创建。 6、 在包下面创建类，找到刚刚创建的“haha”包，然后右键打开“New”→“Class”。 7、打开Class后，在Name框里取名叫“HelloWorld”，然后点击【Finsh】。 8、在编写区编写如下代码： 123public static void main (String[] args) &#123;System.out.println(&quot;这是我写的第一个java代码&quot;);&#125; 9、运行程序，右键点击【Run As】→【Java Application】运行;","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/Windows和Ubuntu双系统安装/","text":"Windows和Ubuntu双系统安装1、c盘压缩出300M的未分配空间，用于ubuntu系统的efi引导区 2、其它盘符压缩出足够的空间（500G&#x2F;2T）未分配空间，用于ubuntu系统和存储区 3、下载rufus,下载ubuntu系统镜像iso,制作ubuntu系统u盘 4、插入U盘，bios设置U盘启动（还有个efi啥选项设置为enable还是ture,忘记了） 5、u盘启动，开始安装ubuntu系统 6、安装 1、语言，默认english 2、网络，选择暂时不链接 3、是否安装第三方软件，不安装，选择了安装速度会慢 4、installation type-&gt;选择something else(自定义安装，手动分区) 5、选中300M区域，primary&#x2F;Beginning of this space&#x2F;EFI System partition 6、再对（500G&#x2F;2T）空间进行分区， ​ A：swap交换区,内存大小空间，Logical&#x2F;Beginning of this space&#x2F;swap area ​ B：根目录分区，剩下的全部空间 Logical&#x2F;Beginning of this space&#x2F;Ext4 journaling file system&#x2F;加载点选择根目录（&#x2F;） ​ C：最后选择挂载点（Device for boot loader installation），一定要选择上面分的那个300M的EFI分区 7、设置密码等操作即可安装完成 8、设置Windows和Ubuntu双系统切换，预防开机黑屏或花屏 在ubuntu系统，Ctrl + Alt + T打开终端；在终端输入sudo gedit &#x2F;etc&#x2F;default&#x2F;grub，回车输入用户密码（输入的密码是看不到）然后回车打开grub引导文件；将grub文件中的GRUB_DEFAULT&#x3D;0修改为GRUB_DEFAULT&#x3D;saved；在下面添加GRUB_SAVEDEFAULT&#x3D;true，保存文件并退出一个具有注脚的文本5。修改下图第10行中的参数为”quiet splash nomodeset”。（预防可能出现的花屏黑屏问题）终端输入 sudo update-grub，回车更新grub文件。终端输入sudo reboot，回车重启。在启动界面就可以切换想要打开的系统了。不操作默认打开上次打开的系统。 9、同步双系统的时间 双系统的时间不同步是由于，ubuntu会设置主机中的COMS时间为UTC时间，然后加上ip时区计算出本地时间，而windows则是使用CMOS中的时间为本地时间。 终端执行 timedatectl set-local-rtc 1","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/ADB和Monkey测试/","text":"android手机怎么连接adb: 12341.通过usb线将手机连接到电脑2.打开开发者选项中usb调3.adb connect 设备ip4.adb devices android手机wifi远程调试: 12341.通过usb线将手机连接到电脑2.adb device能够检测到对应的设备3.adb tcpip 5555确定手机端和电脑端的wifi通讯端口4.拔掉usb线，再通过adb connect 自己手机IP地址 adb常用命令： 1234567891011121314adb --hep查看帮助手册检测连接到电脑的安卓设备，这个是我们会经常用到的adb pull &lt;手机路径&gt; &lt;本机路径&gt; 从手机中拉取信息放到本地电脑adb push &lt;本机路径&gt; &lt;手机路径&gt;从本地推送信息到手机上去adb devices检测命令。adb shell----登录设备shell (命令行的人机界面)，ll ls命令都可以用，进入到 linux命令环境了，相当于执行远程命令!adb logcat--打印日志adb install xxxapkrierew-为了获取apk的安装包所在地址，可以直接把apk拖到cmd的窗口获取，返回success就说明安装成功了!!adb install-r xxx.apk -----保留数据和缓存文件，重新安装APKadb uninstall com.tencent.mobilegg ---卸载应用adb uninstall -k com,tencent,mobileqg ---卸载应用但保留数据和缓存文件adb shell dumpsys activity | find &quot;mFocusedActivity&quot;---查看前台应用activity名adb connect/disconnect 通过wifi进行远程连接手机进行调试 adb logcat日志： 123456789101112命令格式:adb logcat [选项] [过滤项]选项解析:1.&quot;-s&quot;选项 : 只显示指定标签的日志; ------&gt;adb logcat -s SWVDEC 显示SWVDEC标签的日志2.&quot;-v&quot;选项 : 设置日志的输出格式;-----&gt;adb logcat -v time 查看日志输出时间和线程信息3.&quot;-c&quot;选项 : 清空所有的日志缓存信息;----&gt;adb logcat -c4.&quot;-d&quot;选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;-------&gt;adb logcat -d5.&quot;-t&quot;选项 : 输出最近的几行日志, 输出完退出, 不阻塞;------&gt;adb logcat -t 5 输出日志缓冲区的最近5行6.&quot;-g&quot;选项 : 查看日志缓冲区信息; ------&gt;adb logcat -g7.&quot;-B&quot;选项 : 以二进制形式输出日志; ----&gt; adb logcat -B8.&quot;-b&quot;选项 : 加载一个可使用的日志缓冲区供查看，比如event和radio。默认值是main9.&quot;-c&quot;选项 : 清除缓冲区中的全部日志并退出（清除完后可以使用-g查看缓冲区） 错误日志查看： 12341.崩溃日志查看关键字：FATAL EXCEPTION: main或cratch关键字2.ANR问题查看关键字：ANR in/ 有提示anr堆栈信息在xx文件内如：Wrote stack traces to &#x27;/data/anr/traces.txt&#x27;3.(/data/system/dropbox该目录需要root权限，系统自动存储最近崩溃的日志文件)退出adb shell后直接拉去系统dropbox中的错误信息文件夹：adb pull /data/system/dropbox C:\\Users\\11046\\OneDrive\\桌面\\dropbox monkey简略: 12monkey是android下自动化测试比较重要的的一个工具，该工具可以运行在host端或者设备（模拟器或真实设备）。它会向系统发送随机事件流（即随机模拟用户各种操作：点击、滑动、AP切换等），对单个程序或者整个系统进行压力测试。 monkey脚本: 123456脚本优势:简单、快捷、不需要借助任何工具，可以做简单的性能测试脚本缺点:只能简单实现坐标、按键等基本操作(根据像素点来进行操作)#头文件、控制monkey发送消息的参数type = raw eventscount = 10speed = 1.0 Api 说明 LaunchActivity(pkg_name,activity) 启动应用的Activity Tap(x,y,tapDuration) 模拟单击事件.tapDuration为点击的持续时间，此参数可冒略 RotateScreen(rotationDegree,persist) 旋转屏幕,rotationDegree为旋转角度，1代表90度:persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变 DispatchPress(keyName) 按键 DispatchFlip(true&#x2F;false) 打开或者关闭软键盘 RunCmd(cmd) 在设备上运行 shell 命令 PressAndHold(x,y,pressDuration) 模拟长按事件 DispatchString(input) 输入字符串 DeviceWakeUp() 唤醒屏幕 UserWait(sleepTime) 让脚本中断一段时间 adb获取系统已安装的apk文件： 121.第三方app:adb shell /data/app/目录下apk pull出来2.系统app:adb shell /system/app/目录下apk pull出来 monkey脚本编写步骤： 123456789101:确定步骤，如下:获取包名和activityname通过SDK自带的aapt工具一步一步的在手机上操作，并获取像素点利用工具(SDK自带uiautomatorviewbat或者开发者选项中的坐标位置要仔细的检查下，是否脚本上的每一步都跟你的手动操作都对应检查脚本，跑一下脚本。2:运行脚本将文件放到手机中:adb push 本地monkey脚本文件 /data/local/tmp运行文件:adb shell monkey -f 手机文件地址/文件名称 数量 脚本示例： 12345678910111213141516171819//myMonkey.txt文件内容：#头文件、控制monkey发送消息的参数type = raw eventscount = 10speed=1.0#以下monkey命令start data &gt;&gt;#打开测试应用程序LaunchActivity(com.android.browser,com,android.browser.BrowserActivity)#让浏览器将页面加载出来，所以我们的脚本需要等待一段时间UserWait(3000)#点击浏览器网址Tap(367，109)#输入www.ningmengban.comDispatchString(www.ningmengban.com)#输入enter键DispatchPress(KEYCODE ENTER)#输入Home键返回到桌面DispatchPress(KEYCODE HOME) 获取手机当前显示的界面的包名：adb shell dumpsys activity | find “mFocusedActivity” 命令帮助：adb shell monkey –help monke常见参数： -p: 12345用于约束限制，用此参数指定一个或多个包( Package，即App名字)。指定指定包之后Monkey将只允许系统启动指定的APP。如果不指定包，Monkey将允许系统启动设备中的所有APP命令 :adb shell monkey -p com.lemon.lemonban 1000说明 :com.emon.lemonban 为包名，1000是事件计数(即让Monkey程序模拟1000次随机用户事件) -s: 123456用于指定伪随机数生反工seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同命令 :Monkey测试1 : adb shell monkey -p com.lemon.lemonban -s 101 100 提前指定Monkey测试2 : adb shell monkey -p com.lemon.lemonban -s 101 100说明 :两次测试的效果是相同的，因为模拟的用户操作序列( 每次操作按照一定的先后顺序所组成的一系列操作，即一个序列)是一样的。操作序列虽然是随机生成的，但是只要我们指定了相同的Seed值就可以保证两次测试产生的随机操作序列是完全相同的，所以这个操作序列伪随机的， -v 12345678总共分3个级别日志级别(正常使用3个-v)-v 用于指定反馈信息级别( 信息级别就是日志的详细程度) Level0说明:缺省值，仅提供启动提示、测试完成和最终结果等少量信息-v -v 日志级别 Level 1说明 :提供较为详细的日志，包括每个发送到Activity的事件信息-v -v -v日志级别 Level 2说明:最详细的日志，包括了测试中选中/未选中的Activity信息命令 : adb shell monkey -p com.lemon.lemonban -v 100说明: com.emon.lemonban 为包名，100是事件计数(即让Monkey程序模拟100次随机用户事件) –throttle 12用于指定用户操作( 即事件)间的时延，单位是毫秒命令 : adb shell monkey -p com.lemon.lemonban --throttle 3000 100 –randomize-throttle 123在事件之间插入随机延迟，随机延迟范围为0到throttle设置的时间，单位为毫秒命令 : adb shell monkey -p com.lemon.lemonban --throttle 5000 --randomize-throttle说明: 执行一百次monkey随机事件，每次事件的间隔在0到5000毫秒之间不固定 –pkg-whitelist-file 12345白名单，后面接txt文件(要执行测试的多个包名，多个包名换行保存即可)1)第一步把你设置的白名单的包名写到一个txt文档里面，记得路径和文档名字都是英文!D:whitelist.txt2)把这个文件拉到我们的安卓机中去，放到/data/local/tmp下面adb push D:\\whitelist.txt /data/local/tmp 注意这两个反斜杠命令 : adb shell monkey --pkg-whitelist-file /data/local/tmp/whitelist.txt 100 –pkg-blacklist-file 12黑名单，后面接txt文件命令 : adb shell monkey --pkg-blacklist-file /data/local/tmp/blacklist.txt 100 日志输出到指定路径 12&gt; 后面加输出的路径即可；命令：adb shell monkey -p com.lemon.lemonban 1000 &gt; D:/monkey_log.txt monkey其他常见参数 名称 说明 –pct-touch 调整点击事件的百分比，down-up，编号为0（100为百分之百） -pct-motion 调整移动事件的百分比，直线滑动，编号为1 -pct-pinchzoom 调整两指缩放压缩手势的百分比，比如放大缩小手势操作，编号为2 -pct-trackball 调整轨迹球时间百分比，不常用，编号为3 现在手机几乎没有滚动球，但滚动球事件中包含曲线滑动事件，在被测程序需要曲线滑动时可以选用此参数 -pct-rotation 调整旋转事件的百分比，横屏竖屏，编号为4 -pct-nav 调整导航事件的百分比，编号为5，包括上下左右，如方向输入设备的输入 )老手机的上下左右键，智能机上没有 -pct-majornav 调整主要导航事件的百分比，编号为6，例如中间键、回退键、菜单键 -pct-syskeys 调整”系统”按键事件的百分比，编号为7，这些按钮一般专供系统使用，如Home, Back,Start Call, End Call,音量控制 -pct-appswitch 调整app切换事件的百分比，编号为8 -pct-flip 调整键盘唤出隐藏的百分比，编号为9 -pct-anyevent 跳转除上面事件外，其它事件的百分比，编号为10，如按键、其他在设备上不常用的按钮等","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/AOSP常用命令/","text":"Logcat 查看日志可选参数 12345678910111213141516171819可选的参数主要有：1、all：查看所有缓冲区日志2、default：查看 main、system、crash 三个类型日志信息3、main：查看 main 类型日志4、radio：查看 radio 类型日志5、events：查看 events 类型日志6、system：查看 system 类型日志7、crash：查看 crash 类型日志查看系统运行日志:adb shell logcat //开始抓取或者-s logcat -c//清空日志logcat -s tag//开始抓取日志 并筛选指定的tag日志使用示例：logcat -b main #查看 main 类型日志logcat -b main，system #用来查看 main 和 system 类型日志logcat -b all #查看所有日志 aosp中查看c++版本 12345678910//文件路径：build/soong/cc/config/global.go//文件路径：build/soong/cc/config/clang.go CStdVersion = &quot;gnu99&quot; //编译 C 语言代码的标准，c99：表示使用 C99 标准进行编译，gnu99：表示与 GNU 编译器兼容的 C99 标准（GNU C99） CppStdVersion = &quot;gnu++17&quot; //编译C++ 标准的版本设置为 GNU C++ 17，C++ 标准版本设置为 C++17，其中的 gnu 表示与 GNU 编译器兼容的意思 ExperimentalCStdVersion = &quot;gnu11&quot; //表示启用了实验性的 C 语言标准版本，并将其设置为 GNU C11 ExperimentalCppStdVersion = &quot;gnu++2a&quot; //启用了实验性的 C++ 标准版本，并将其设置为 GNU C++2a java代码跳转natice查找方式 1全局查找：_加java类名 搜索&#x2F;查找文件 12345cd到framework/system或其他目录,以getevent文件为例find -name getevent*或者ls -l | grep geteventgrep getevent ./ -rn 查看所有进程的pid 12ps -A (查看指定进程的pid：ps -A | grep &quot; packageName&quot;)//生死指定进程：kill pid adb执行截屏或其他手势 1adb shell input keyevent 120 调用截屏命令 打印日志调试（这种方法只能查找java层，无法查找到native调用java层的方法,native调用java使用grep搜索） 12345//查找某个地方从底层调用了哪些，加入下面代码，这种方式不会引起程序崩溃，可以获取到堆栈的调用顺序；// 低版本，具体多少没做验证，如果打印不出来，用下面的方式 Log.i(&quot;tyl&quot;,&quot;oncreate:&quot;,new Exception()); // 高版本，通过异常直接打印堆栈 new Exception().printStackTrace(); native端打印堆栈 1234567891011121314C++ 中使用android::CallStack将所在线程的调用堆栈打印出来基本用法：1. 进入对应的cpp文件中，放开 #define LOG_NDEBUG 0 注释，且变成#define LOG_NDEBUG 12. 声明头文件#include &lt;utils/CallStack.h&gt;#include &lt;utils/Log.h&gt;3. 调用方法android::CallStack stack;stack.update();stack.log(debug); // 输出到logcat4. mk或者bp文件中需要链接以下so库libutilslibcutils 查看当前view对应的具体的是谁 12345//加上 | grep ResumedActivity 是筛选出当前最top的Activityadb shell dumpsys activity activities | grep ResumedActivity//结果： 当前包名com.example.test/.MainActivity mResumedActivity: ActivityRecord&#123;6eb3073 u0 com.example.test/.MainActivity t5&#125; ResumedActivity: ActivityRecord&#123;6eb3073 u0 com.example.test/.MainActivity t5&#125; 查找系统应用(launcher2)在哪些地方编译的 123456//cd到~/android-8.1.0_r1/build目录，grep &quot;Launcher2&quot; ./ -rn查找在哪里有用到，注意大小写tyl@ubuntu:~/android-8.1.0_r1/build$ grep &quot;Launcher2&quot; ./ -rn./make/target/product/core.mk:45: Launcher2 \\ 如果查出有多个文件，则都需要打开对应路径添加应用名//vim打开显示vi ./make/target/product/core.mk//打开后如下图，说明PRODUCT_PACKAGES 在这个里面也需要添加内置应用的文件夹名 input dumpsys,打印触摸事件日志到本地文件 12# 给触摸事件保存到一个txt中adb shell dumpsys input &gt; input.txt (input.txt本地文件名) adb shell am stack list查看设备上当前运行的应用程序和任务的信息以及点击坐标，它们之间的关系和顺序等； AOSP常用编译和查找命令 command describe m 等同于 make ，进行一次完整编译。 mm 在当前目录下编译所有模块，但不包括依赖项。 mmm [目录] 编译指定目录下的所有模块，但不包括依赖项。只编译指定模块：mmm [dir&#x2F;:target1,target2] mma 在当前目录下编译所有模块，包括依赖项。 mmma [目录] 编译指定目录下的所有模块，包括依赖项。 make clean 删除整个 out&#x2F; 目录。 make clobber 用于清除编译缓存。 make snod 当重新编译部分模块完成后，快速生成img文件。 cgrep 对C&#x2F;C++文件执行 grep (只搜寻C&#x2F;C++文件类型，也包括.h类型)。 jgrep 只对Java文件执行 grep (只搜寻Java文件类型)。 resgrep 只匹配 &#x2F;res 目录下的 xml 文件。 sepgrep 只查找sepolicy文件。 adb shell dumpsys命令 123456789命令用于获取Android设备上正在运行的系统服务信息。通过该命令，可以获取到各种设备状态、应用程序信息以及系统服务信息。以下是一些常见的用法：adb shell dumpsys：列出所有可用的服务名称。adb shell dumpsys &lt;service&gt;：打印指定服务的信息，例如adb shell dumpsys window打印窗口管理服务的信息。adb shell dumpsys activity：打印活动管理器服务的信息，包括活动栈、任务栈、任务信息等。adb shell dumpsys battery：打印电池信息。adb shell dumpsys wifi：打印Wi-Fi服务的信息。adb shell dumpsys bluetooth：打印蓝牙服务的信息。这只是一小部分常见的用法，adb shell dumpsys命令提供了许多其他服务的信息； vscode搜索跳转行号：搜索栏 ：加行数； vscode搜索查询方法：搜索栏 @ 加方法名","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android进阶/Jetpack/Jetpack架构组件从入门到精通/","text":"","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"}]},{"path":"wiki/C++/Linux系统_vscode中配置 c++环境/","text":"Linux中分析相关代码比较多的话就还是需要找一个比较好的工具进行，其实普遍比较主流的有2种：1、sourceinsight –这个基本做linux kernel相关使用比较多，基本分析跳转和写代码都还是比较方便，缺点就是只要windows版本，还需要付费2、VSCode这个是微软的轻量级IDE工具，这个开源，而且可以跨平台windows，mac，linux都可以，对c、c++等语言支持非常好，所以是个比较好的选择，缺点就是对java等支持相比没有as好，导致我们可能主要把它用于native代码阅读编写 因为我们是ubuntu开发，所以这里当然就选vscode进行native源码环境搭建，并且是Ubuntu上面：步骤1、下载vscode，这个其实官网有，但是因为实在是网络太卡，建议可以https://code.visualstudio.com/下载 2、安装下载deb文件，命令如下： 1sudo dpkg -i xxxx.deb 3、启动vscode，直接取Ubuntu应用列表中打开VSCode,刚开始进入建议先安装vscode的插件,c&#x2F;c++,c++ intelligent 4、然后在file –&gt;open folder打开我们的代码文件夹，我这里是仅仅打开的aosp&#x2F;frameworks文件夹，没有打开整个aosp源码目录，因为整个aosp代码量太大，运行太卡，基本做完这几个就可以愉快的看到漂亮的native代码了 习惯了eclipse的快捷命令，肯定会不知道怎么操作VSCode类似的场景，这里总结一些快捷键：1、查找当前工程中某个文件：ctl+p2、查找当前cpp文件中某个方法展示出方法列表 ：ctl+shift+o3、返回上一个操作：在Linux中可以使用快捷键Ctrl+Alt + - ps:存在问题写代码时候一些对象等无法有提示，debug进程时候发现无法打断点;","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"}]},{"path":"wiki/C++/彻底搞定C指针/","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"}]},{"path":"wiki/C++/轻松搞定C语言(提高篇)/","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"}]},{"path":"wiki/C++/轻松搞定C++语言/","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"}]},{"path":"wiki/Android FrameWork/AOSP Repo命令参考资料/","text":"Repo简介Repo是Google开发的用于管理Android版本库的一个工具，repo是使用Python对git进行了一定的封装，并不是用于取代git，它简化了对多个Git版本库的管理。用repo管理的版本库都需要使用git命令来进行操作。 Repo 可以在必要时整合多个 Git 代码库，将相关内容上传到 Gerrit 修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。 Repo 启动器会提供一个 Python 脚本，该脚本可以初始化检出，并可以下载第二部分，即完整的 Repo 工具。完整的 Repo 工具包含在 Android 源代码检出中。该工具默认位于 $SRCDIR&#x2F;.repo&#x2F;repo&#x2F;… 中，它可以从下载的 Repo 启动器接收转发的命令。Repo 使用清单文件将 Git 项目汇总到 Android 超级项目中。 Repo命令 1234567891011121314151617181920212223242526272829server@dev: $ repo helpusage: repo COMMAND [ARGS]The most commonly used repo commands are: abandon Permanently abandon a development branch branch View current topic branches branches View current topic branches checkout Checkout a branch for development cherry-pick Cherry-pick a change. diff Show changes between commit and working tree diffmanifests Manifest diff utility download Download and checkout a change gitc-delete Delete a GITC Client. gitc-init Initialize a GITC Client. grep Print lines matching a pattern info Get info on the manifest branch, current branch or unmerged branches init Initialize a repo client checkout in the current directory list List projects and their associated directories overview Display overview of unmerged project branches prune Prune (delete) already merged topics rebase Rebase local branches on upstream branch smartsync Update working tree to the latest known good revision stage Stage file(s) for commit start Start a new branch for development status Show the working tree status sync Update working tree to the latest revision upload Upload changes for code reviewSee &#x27;repo help &lt;command&gt;&#x27; for more information on a specific command.See &#x27;repo help --all&#x27; for a complete list of recognized commands.Bug reports: https://bugs.chromium.org/p/gerrit/issues/entry?template=Repo+tool+issue 12345678910111213141516171819202122232425262728293031323334初始化一个新客户端repo init -u：指定从中检索清单代码库的网址。-m：选择代码库中的清单文件。-b：指定修订版本，即特定的 manifest-branch。eg:repo init -u https://android.googlesource.com/platform/manifest将客户端同步到代码库repo sync # 新建一个分支repo start # 删除不用的本地分支repo abandon# 删除已经合并分支repo prune# 切换分支repo checkout# 显示当前分支的状态repo status # 查看修改repo diff # 将更改上传到审核服务器repo upload # 显示manifest文件内容repo manifest repo init在当前目录中安装 Repo，这会创建一个 .repo&#x2F; 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo&#x2F; 目录中还包含 manifest.xml，这是一个指向 .repo&#x2F;manifests&#x2F; 目录中所选清单的符号链接。 清单文件是以xml的格式组织的，一个清单库可以包含多个清单文件和多个分支，每个清单文件和分支都有对应的版本。 remote元素：定义了名为korg的远程版本库，库的基址为git:&#x2F;&#x2F;172.16.1.31 project元素：用于定义一个项目，path属性表示在工作区clone的位置，name属性表示该项目的远程版本库的相对路径。 default元素：设置各个项目默认远程版本库为Korg，默认的分支为gingerbread-exdroid-stable。各个项目还可以定义自己的remote revision覆盖默认的配置。 project元素下的子元素copyfile：定义了项目clone后的一个附件动作，从src拷贝文件到dest repo目录下有manifest、project、repo文件夹等信息 manifest：看某个模块当前是在哪个分支 project： repo：查看Python封装的脚本","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/dumpsys命令用法/","text":"dumpsys 是一个用于在 Android 系统中获取各种信息的命令。它提供了系统状态、应用程序、服务、进程、内存使用情况、网络连接等方面的详细信息。 dumpsys命令的语法结构如下： 1234dumpsys [options] [service | name]其中：options 是可选的命令选项，用于指定不同的输出参数。service | name 是可选的服务或名称，用于指定你想要获取信息的特定服务或应用程序名称。 dumpsys命令用法 可通过dumpsys命令查询系统服务的运行状态(对象的成员变量属性值)，命令格式：dumpsys 服务名， 例如： 123456dumpsys activity //查询AMS服务相关信息dumpsys window //查询WMS服务相关信息dumpsys cpuinfo //查询CPU情况dumpsys meminfo //查询内存情况dumpsys activity &gt; text.txt//将查询到的信息写到执行文件dumpsys activity | grep xx //查询结果中再进行指定筛选条件 可查询的服务有很多，可通过下面任一命令查看当前系统所支持的dump服务： 12adb shell dumpsys -ladb shell service list 系统服务 表一： 服务名 类名 功能 activity ActivityManagerService AMS相关信息 package PackageManagerService PMS相关信息 window WindowManagerService WMS相关信息 input InputManagerService IMS相关信息 power PowerManagerService PMS相关信息 batterystats BatterystatsService 电池统计信息 battery BatteryService 电池信息 alarm AlarmManagerService 闹钟信息 dropbox DropboxManagerService 调试相关 procstats ProcessStatsService 进程统计 cpuinfo CpuBinder CPU meminfo MemBinder 内存 gfxinfo GraphicsBinder 图像 dbinfo DbBinder 数据库 表二： 服务名 功能 SurfaceFlinger 图像相关 appops app使用情况 permission 权限 processinfo 进程服务 batteryproperties 电池相关 audio 查看声音信息 netstats 查看网络统计信息 diskstats 查看空间free状态 jobscheduler 查看任务计划 wifi wifi信息 diskstats 磁盘情况 usagestats 用户使用情况 devicestoragemonitor 设备信息 … …","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/使用 git add -p 整理 patch/","text":"获取2次代码改动的对应代码及行数信息 patch介绍 123-p, --patch交互地在索引和工作树之间选择补丁块并将它们添加到索引中。这让用户有机会在将修改后的内容添加到索引之前查看差异。这可以有效地运行 add --interactive，但是会绕过初始命令菜单，而直接跳转到 patch 子命令。有关详细信息。 使用： 1234567891011121314git add -pcommit b329f455f522487133975df6bcaad461d6963d3aAuthor: Your Name &lt;you@example.com&gt;Date: Tue Apr 25 16:33:09 2023 +0800 simple doublescreen move task to otherdiff --git a/services/core/java/com/android/server/wm/DisplayContent.java b/services/core/java/com/android/server/wm/DisplayContent.javaindex a03dce364209..695c300b51fd 100644--- a/services/core/java/com/android/server/wm/DisplayContent.java+++ b/services/core/java/com/android/server/wm/DisplayContent.java+ import com.android.server.DoubleScreenMovePointerEventListener;...(1/1) Stage this hunk [y,n,q,a,d,e,?]? 输入 git add -p 进入 patch mode , 此时 git 会自动将改动切分成多个片段，并展示第一个片段，提示你进行选择。 提示语句是 Stage this hunk [y,n,q,a,d,/,s,e,?]? 这些字母都是什么意思呢? 输入?回车，可以查看详细的帮助信息: 1234567891011121314y - 暂存此区块n - 不暂存此区块q - 退出；不暂存包括此块在内的剩余的区块a - 暂存此块与此文件后面所有的区块d - 不暂存此块与此文件后面所有的 区块g - 选择并跳转至一个区块/ - 搜索与给定正则表达示匹配的区块j - 暂不决定，转至下一个未决定的区块J - 暂不决定，转至一个区块k - 暂不决定，转至上一个未决定的区块K - 暂不决定，转至上一个区块s - 将当前的区块分割成多个较小的区块e - 手动编辑当前的区块? - 输出帮助","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/自定义服务/","text":"常见的AMS、PWS、WMS等等都是系统服务，运行于system_server进程，并且向servicemanager进程注册其Binder以便其他进程获取binder与对应的服务进行通信。为了新增自定义系统服务，我们可以参考AMS等原生系统服务编写如下文件： 1、AIDL文件：生成Binder类，其中Stub即为Binder的服务端； 2、XXManagerService：系统服务类，继承自Stub； 3、XXManager：封装了AIDL接口方法的类，相当于Binder客户端（Proxy），其他进程通过此类完成与系统服务的通信。 增加系统服务1、AIDL在frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;enjoy&#x2F;service中编写IEnjoyManager.aidl 12345678// IEnjoyManager.aidlpackage com.enjoy.service;// Declare any non-default types here with import statementsinterface IEnjoyManager &#123; void sendMessage(String msg);&#125; 在frameworks&#x2F;base&#x2F;Android.mk中声明AIDL文件： 1234LOCAL_SRC_FILES += .... core/java/android/app/IActivityManager.aidl \\ core/java/com/enjoy/service/IEnjoyManager.aidl \\ .... 2、系统服务在frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;enjoy&#x2F;service中编写EnjoyManagerService.java 123456789101112131415package com.enjoy.service;import android.os.RemoteException;import android.util.Log;public class EnjoyManagerService extends IEnjoyManager.Stub &#123; private static final String TAG = &quot;Enjoy&quot;; @Override public void sendMessage(String msg) throws RemoteException &#123; Log.i(TAG, &quot;sendMessage: &quot; + msg); &#125;&#125; 3、客户端代理在frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;enjoy&#x2F;service下编写EnjoyManager.java 1234567891011121314151617181920212223package com.enjoy.service;import android.os.RemoteException;import android.util.Log;public class EnjoyManager &#123; private static final String TAG = &quot;Enjoy&quot;; private IEnjoyManager service; public EnjoyManager(IEnjoyManager service) &#123; this.service = service; &#125; public void sendMessage(String msg) &#123; try &#123; service.sendMessage(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; framework&#x2F;base&#x2F;Android.mk: 123456packages_to_document := \\ android \\ javax/microedition/khronos \\ org/apache/http/conn \\ org/apache/http/params \\ com/enjoy/service 4、修改Context在frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;Context.java中加入常量： 1public static final String ENJOY_SERVICE=&quot;enjoy&quot;; 5、注册系统服务在frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java中 注册系统服务 123456import com.enjoy.service.EnjoyManagerService;private void startOtherServices()&#123; //...... ServiceManager.addService(Context.ENJOY_SERVICE,new EnjoyManagerService()); //......&#125; 6、注册应用系统服务获取器在frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;SystemServiceRegistry.java注册服务获取器： 12345678910111213import com.enjoy.service.IEnjoyManager;import com.enjoy.service.EnjoyManager;static&#123; registerService(Context.ENJOY_SERVICE, EnjoyManager.class, new CachedServiceFetcher&lt;EnjoyManager&gt;() &#123; @Override public EnjoyManager createService(ContextImpl ctx) throws ServiceNotFoundException &#123; // 获取服务 IBinder b = ServiceManager.getServiceOrThrow(Context.ENJOY_SERVICE); IEnjoyManager service = IEnjoyManager.Stub.asInterface(b); return new EnjoyManager(service); &#125;&#125;);&#125; 7、配置SELinux权限system&#x2F;sepolicy&#x2F;private&#x2F;service_contexts 12activity u:object_r:activity_service:s0 enjoy u:object_r:enjoy_service:s0 system&#x2F;sepolicy&#x2F;public&#x2F;service.te: 12type activity_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;type enjoy_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type; system&#x2F;sepolicy&#x2F;private&#x2F;untrusted_app_all.te : 1allow untrusted_app enjoy_service:service_manager find; *8、配置白名单如果以当前案例的方式新增自定义系统服务，因为SystemServiceRegistry 中需要使用到com.enjoy下的类，为了让其获取此包下类的引用，需要配置：build&#x2F;core&#x2F;tasks&#x2F;check_boot_jars&#x2F;package_whitelist.txt ，加入：com\\.enjoy\\..* 。否则会因为无法获取类引用而编译报错！ 12345dalvik\\..*libcore\\..*android\\..*com\\.android\\..*com\\.enjoy\\..* 若新增的服务像AMS等原有系统服务的IActivityManager.aidl与ActivityManager一样放在android.app包下即可不用进行此步处理！ 9、编译并刷机123456#编译make update-apimake –j4 #刷机adb reboot bootloaderreboot flashall -w 10、使用自定义服务10.1 利用双亲委托机制在需要使用自定义服务的app中编写EnjoyManager（包名与framework中一致）： 1234567891011package com.enjoy.service;import android.os.RemoteException;import android.util.Log;public class EnjoyManager &#123; public void sendMessage(String msg) &#123; &#125;&#125; 此时由于类加载的双亲委托机制，app在运行时实际使用的是framework中的EnjoyManager。app中的EnjoyManager仅仅只是为了编译成功编写的空壳。 10.2 修改SDK修改app使用的sdk，可以通过make sdk 将SDK完成编译出来。也可以直接在out&#x2F;target&#x2F;common&#x2F;obj&#x2F;JAVA_LIBRARIES&#x2F;framework_intermediates中找到EnjoyManager类将其加入原生SDK中的android.jar SystemService系统服务需要通过ServiceManager.addService(&quot;xx&quot;, new XXManagerService);将自己（Binder Stub）注册进入SM才能够让其他进程利用Binder与之通信。而自定义系统服务如果需要根据系统启动的不同阶段进行不同的处理则需要注册生命周期回调。以AMS为例： &#x2F;frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemService中启动AMS： 12345678910111213private void startBootstrapServices() &#123; //... // Activity manager runs the show. traceBeginAndSlog(&quot;StartActivityManager&quot;); mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); traceEnd(); //... mActivityManagerService.setSystemProcess(); //...&#125; AMS中的setSystemProcess方法的实现为： 12345678public void setSystemProcess() &#123; //... ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO); //...&#125; setSystemProcess中会完成向SM注册AMS的实现。而在setSystemProcess之前有一段代码： 12mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); 则为注册生命周期监听，ActivityManagerService.Lifecycle就相当于生命周期的回调接口对象，它继承自： &#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemService。这个SystemService中主要需要实现两个方法： onStart() ：mSystemServiceManager.startService第一时间回调该函数。 onBootPhase(int phase) ： 系统启动的各个阶段会回调该函数 SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY:这是一个依赖项，只有DisplayManagerService中进行了对应处理； SystemService.PHASE_LOCK_SETTINGS_READY:经过这个引导阶段后，服务才可以接收到wakelock相关设置数据； SystemService.PHASE_SYSTEM_SERVICES_READY:经过这个引导阶段 后，服务才可以安全地使用核心系统服务 SystemService.PHASE_ACTIVITY_MANAGER_READY:经过这个引导阶 段后，服务可以发送广播 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START:经过这个引导阶段后，服务可以启动第三方应用，第三方应用也可以通过Binder来调用服务。 SystemService.PHASE_BOOT_COMPLETED:经过这个引导阶段后，说明服务启动完成，这时用户就可以和设备进行交互。 比如AMS中的Lifecycle： 123456789101112131415public static final class Lifecycle extends SystemService &#123; @Override public void onBootPhase(int phase) &#123; mService.mBootPhase = phase; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; mService.mBatteryStatsService.systemServicesReady(); mService.mServices.systemServicesReady(); &#125; else if (phase == PHASE_ACTIVITY_MANAGER_READY) &#123; // 准备广播处理 mService.startBroadcastObservers(); &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123; mService.mPackageWatchdog.onPackagesReady(); &#125; &#125;&#125; 在AMS中会处理PHASE_ACTIVITY_MANAGER_READY ，经过这个阶段后，也就是需要在下一个阶段PHASE_THIRD_PARTY_APPS_CAN_START才可以发送广播。 同步问题在修改了SDK之后，可能出现同步错误: 此时我们需要去修改AGP插件中的一个类：MockableJarGenerator 在我的工程当中当前使用的AGP版本为：7.2.1，从C:\\Users\\Administrator\\.gradle\\caches\\modules-2\\files-2.1\\com.android.tools.build\\builder\\7.2.1 目录下找到builder-7.2.1-sources.jar 并将其解压，找到com.android.builder.testing 中的MockableJarGenerator。 将此类放入Android Studio工程app模块的单元测试中，并在app的gradle中加入： 1234567dependencies &#123; testImplementation &#x27;org.ow2.asm:asm:7.1&#x27; testImplementation &#x27;org.ow2.asm:asm-commons:7.1&#x27; // testImplementation &#x27;com.google.guava:guava:23.6-jre&#x27; testImplementation group:&#x27;com.google.guava&#x27;, name:&#x27;guava&#x27;, version:&#x27;23.6-jre&#x27;&#125; 操作步骤为： 最后将C:\\Users\\Administrator\\.gradle\\caches\\modules-2\\files-2.1\\com.android.tools.build\\builder\\7.2.1中builder-7.2.1.jar的MockableJarGenerator.class替换成刚刚编译的class文件。","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android Application/Android工具类/无障碍升级/","text":"MyAccessibilityService： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.withub.android.cloudsharingcourt.util;import android.accessibilityservice.AccessibilityService;import android.text.TextUtils;import android.view.accessibility.AccessibilityEvent;import android.view.accessibility.AccessibilityNodeInfo;import java.util.HashMap;import java.util.Map;public class MyAccessibilityService extends AccessibilityService &#123; Map&lt;Integer, Boolean&gt; handledMap = new HashMap&lt;&gt;(); public MyAccessibilityService() &#123; &#125; @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; AccessibilityNodeInfo nodeInfo = event.getSource(); if (nodeInfo != null) &#123; int eventType = event.getEventType(); if (eventType== AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED || eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) &#123; if (handledMap.get(event.getWindowId()) == null) &#123; boolean handled = iterateNodesAndHandle(nodeInfo); if (handled) &#123; handledMap.put(event.getWindowId(), true); &#125; &#125; &#125; &#125; &#125; private boolean iterateNodesAndHandle(AccessibilityNodeInfo nodeInfo) &#123; if (nodeInfo != null&amp;&amp;nodeInfo.getClassName()!=null&amp;&amp;!TextUtils.isEmpty(nodeInfo.getText())) &#123; int childCount = nodeInfo.getChildCount(); if (&quot;android.widget.Button&quot;.equals(nodeInfo.getClassName())||&quot;android.widget.TextView&quot;.equals(nodeInfo.getClassName())) &#123; String nodeContent = nodeInfo.getText().toString(); if (&quot;安装&quot;.equals(nodeContent) ||&quot;打开&quot;.equals(nodeContent) ||&quot;完成&quot;.equals(nodeContent) || &quot;确定&quot;.equals(nodeContent) || &quot;下一步&quot;.equals(nodeContent) || &quot;确认&quot;.equals(nodeContent) || &quot;继续安装&quot;.equals(nodeContent)) &#123; nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK); return true; &#125; &#125; else if (&quot;android.widget.ScrollView&quot;.equals(nodeInfo.getClassName())) &#123; nodeInfo.performAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD); &#125; for (int i = 0; i &lt; childCount; i++) &#123; AccessibilityNodeInfo childNodeInfo = nodeInfo.getChild(i); if (iterateNodesAndHandle(childNodeInfo)) &#123; return true; &#125; &#125; &#125; return false; &#125; @Override public void onInterrupt() &#123; &#125;&#125; 12345678910111213//清单文件中注册&lt;service android:name=&quot;.util.MyAccessibilityService&quot; android:label=&quot;自动智能安装&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessibility_service_config&quot; /&gt; &lt;/service&gt; 1234567891011121314//检查是否已开启无障碍自动安装权限//用法：boolean enabled = isAccessibilityServiceEnabled(mContent, MyAccessibilityService.class);public boolean isAccessibilityServiceEnabled(Context context, Class&lt;? extends AccessibilityService&gt; service) &#123; AccessibilityManager am = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE); List&lt;AccessibilityServiceInfo&gt; enabledServices = am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_ALL_MASK); for (AccessibilityServiceInfo enabledService : enabledServices) &#123; ServiceInfo enabledServiceInfo = enabledService.getResolveInfo().serviceInfo; if (enabledServiceInfo.packageName.equals(context.getPackageName()) &amp;&amp; enabledServiceInfo.name.equals(service.getName())) return true; &#125; return false;&#125; 123//跳转到设置开启无障碍模式页面；Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);mContent.startActivity(intent);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/19_NDK面试题/","text":"一、谈谈你对 JNI 和 NDK 的理解 JNI： 123JNI 是 `Java Native Interface` 的缩写，即 Java 的本地接口。目的是使得 Java 与本地其他语言（如 C/C++）进行交互。JNI 是属于 Java 的，与 Android 无直接关系。 NDK： 123NDK 是 `Native Development Kit` 的缩写，是 Android 的工具开发包。作用是更方便和快速开发 C/C++ 的动态库，并自动将动态库与应用一起打包到 apk。NDK 是属于 Android 的，与 Java 无直接关系。 总结： JNI 是实现的目的，NDK 是 Android 中实现 JNI 的手段。 二、谈谈你对 JNIEnv 和 JavaVM 理解 JavaVM 123JavaVM 是虚拟机在 JNI 层的代表。一个进程只有一个 JavaVM。（重要！）所有的线程共用一个 JavaVM。（重要！） JNIEnv 12JNIEnv 表示Java调用native语言的环境，封装了几乎全部 JNI 方法的指针。JNIEnv 只在创建它的线程生效，不能跨线程传递，不同线程的 JNIEnv 彼此独立。（重要！） 注意： 12在 native 环境下创建的线程，要想和 java 通信，即需要获取一个 JNIEnv 对象。我们通过 `AttachCurrentThread` 和 `DetachCurrentThread` 方法将 native 的线程与 JavaVM 关联和解除关联。 三、解释一下 JNI 中全局引用和局部引用的区别和使用 全局引用 12通过 `NewGlobalRef` 和 `DeleteGlobalRef` 方法创建和释放一个全局引用。全局引用能在多个线程中被使用，且不会被 GC 回收，只能手动释放。 局部引用 1234通过 `NewLocalRef` 和 `DeleteLocalRef` 方法创建和释放一个局部引用。局部引用只在创建它的 native 方法中有效，包括其调用的其它函数中有效。因此我们不能寄望于将一个局部引用直接保存在全局变量中下次 使用（请使用全局引用实现该需求）。我们可以不用删除局部引用，它们会在 native 方法返回时全部自动释放，但是建议对于不再使用的局部引用手动释放，避免内存过度使用。 扩展：弱全局引用 123通过 `NewWeakGlobalRef` 和 `DeleteWeakGlobalRef` 创建和释放一个弱全局引用。弱全局引用类似于全局引用，唯一的区别是它不会阻止被 GC 回收。 四、JNI 线程间数据怎么互相访问 1考察点和上体类似，线程本来就是共享内存区域的，因此我们需要使用 `全局引用`。 五、怎么定位 NDK 中的问题和错误 1234567一般在开发阶段的话，我们可以通过 log 来定位和分析问题。如果是上线状态（即关闭了基本的 log），我们可以借助 NDK 提供的 `addr2line` 工具和 `objdump` 工具来定位错误。详情：[so 动态库崩溃问题定位（addr2line与objdump）](https://blog.csdn.net/afei__/article/details/81181827)其它还可以使用 C/C++ 的一些分析工具。 六、静态注册和动态注册 静态注册： 1通过 `JNIEXPORT` 和 `JNICALL` 两个宏定义声明，`Java + 包名 + 类名 + 方法名` 形式的函数名。不好的地方就是方法名太长了。 动态注册： 12通常在 `JNI_OnLoad` 方法中通过 `RegisterNatives` 方法注册，可以不再遵从固定的命名写法（当然为了代码容易理解，名称还是尽量和 Java 中保持一致）。 七、API 有的变态题目还是会考验你一些 API 的运用，比如怎么在 JNI 里面调用 Java 的方法，怎么在 JNI 里面抛异常等等。所以一些 API 还是要熟悉一下的，大致都是什么功能，名字大致是啥呀，这个太多了，看链接介绍吧： JNI 方法大全及使用示例","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/16_2_Cmake项目常用/","text":"#framework学友提供 一. cmake 版本号声明12# 声明一个我们使用的最小版本cmake_minimum_required(VERSION 3.10.2) 二. 设置项目名称12# 这个项目名称一般和生成的库名称相同project(test) 三. 添加头文件搜索目录1include_directories(../../../include) 四. 添加源文件1234# 使用变量添加set(SOURCES test.cpp xxx.cpp)# 添加所有FILE(GLOB SRCS &quot;*.CPP&quot; &quot;*.h&quot;) 五. 生成一个库12345678add_library( # Sets the name of the library. srt-lib # 库的名字 # Sets the library as a shared library. SHARED # 动态库 # Provides a relative path to your source file(s). srt-lib.cpp srt1-lib.cpp) # 源文件列表 六. 搜索一个库(预构建库)1234567find_library( # Sets the name of the path variable. log-lib # 可以理解别名 # Specifies the name of the NDK library that # you want CMake to locate. log # 这个是liblog.so 在ndk目录中自带的一个库 ) 七. 设置一个变量12# 设置LIBDIR为 $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;set(LIBDIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;) 八. 导入预构建库123456# 导入静态库add_library(ssl STATIC IMPORTED)set_target_properties(srt PROPERTIES IMPORTED_LOCATION $&#123;LIBDIR&#125;/libssl.a)# 导入动态库add_library(ssl SHARED IMPORTED)set_target_properties(srt PROPERTIES IMPORTED_LOCATION $&#123;LIBDIR&#125;/libssl.so) 九. 链接库123456target_link_libraries( # Specifies the target library. test # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;) 十. 设置库的输出目录12set_target_properties(test PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_LIBRARY_OUTPUT_DIRECTORY_$&#123;ARCH&#125;&#125;)","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/16_1_Cmake语法/","text":"1.CMake基础： 1234567891011121314151617181920212223242526272829303132 1.1 CMake 是什么： (1).CMake是一个支持生成跨平台建构文件的工具 (2).CMake并不直接建构最终的软件，而是描述项目文件被编译的过程，生成标准的建构档（如 Unix 的 Makefile 或 VS 的 projects/workspaces），然后再以对应平台的建构方式使用。 1.2 CMake源文件： (1).CMake编写的源⽂件以CMakeLists.txt 命名或以.cmake为扩展名 (2).CMake的源⽂件包括 命令和注释 (3).CMake源文件中所有有效的语句都是命令 可以是内置命令或者自定义的函数(function) 或 宏命令(macro） (4).可以通过add_subdirectory()命令把子录的CMake源文件添加进来 1.3 CMake编译C/C++原理： (1).CMake比Unix的make更为高级，使用起来要方便得多。 (2).终端cmake命令将CMakeLists.txt文件建构为make所需要的makefile文件， 最后用make命令编译源码生成可执行程序或共享库(so(shared object)) 因此CMake在Linux终端执行步骤总的来说就两个： 1.cmake 2.make (3).终端执行cmake后会生成很多编译中间文件以及makefile文件， 一般会新建一个build目录专门用来编译： 1.mkdir build 2.cd build 3.cmake .. 4.make build的创建也可以在CMakeLists.txt中使用命令创建。 cmake指向CMakeLists.txt所在的目录， cmake .. 表示当前CMakeLists.txt目录的上一级目录对于一个庞大的工程，编写Makefile相当复杂，有了CMake工具之后就可以读入所有源文件，自动生成Makefile等构建文件。2.CMake注释： 12345(1).单行注释：#注释内容(2).多行注释：可以使用括号来实现多行注释： #[[多行注释 多行注释 多行注释]] 3.CMake变量： 1234567891011 (1).CMake中所有的变量都是string类型。 (2).set()/unset()：声明/移除一个变量 (3).声明变量：set(变量名 变量值) set(var 123) (4).引用变量：$&#123;变量名&#125; $&#123;var&#125; (5).打印变量：message(&quot;变量名 = $&#123;变量名&#125;&quot;) message(&quot;var = $&#123;var&#125;&quot;)示例：set(var 123)message(&quot;var=$&#123;var&#125;&quot;) 4.CMake列表(LISTS) 1234567891011 (1).列表也是字符串，可以把列表看做是一个特殊的变量，这个变量有多个值。 (2).语法格式：set(列表名 值1 值2 ... 值n) 或 set(列表名 “值1;值2;...值n”) (3).声明列表：set(列表名 值1 值2 ... 值n) 或 set(列表名 “值1;值2;...值n”) set(list_var 1 2 3 4 5) 或 set(list_var &quot;1;2;3;4;5&quot;) (4).引用列表：$&#123;列表名&#125; (5).打印列表：message(&quot;列表名 = $&#123;列表名&#125;&quot;) message(&quot;list_var = $&#123;list_var&#125;&quot;) 示例：set(list_aa 1 2 3 4 5)message(&quot;list=$&#123;list_aa&#125;&quot;) 5.CMake中变量的作用域 12345(1).全局层：cache变量，在整个项目范围可见， 一般在set定义变量式，指定CACHE参数就能定义cache变量(2).目录层：在当前⽬录CMakeLists.txt中定义， 以及在该文件包含的其他CMake源文件中定义的变量(3).函数层：在命令函数中定义的变量，属于函数作用域内的变量 6.CMake流程控制 (1).操作符： 优先级： () &gt; 一元 &gt; 二元 &gt; 逻辑 一元： 123EXIST:如果指定的文件或目录存在，则为trueCOMMAND:如果给定的name是可以调用的命令、宏或函数，则为trueDEFINED:如果定义了给定&lt;name&gt;的变量、缓存变量或环境变量，则为true.(变量的值无关紧要) 二元： 1234567891011121314151617EQUAL:相等（如果给定的字符串或变量的值是有效数字且等于右侧的数字，则为true）LESS：小于(如果给定的字符串或变量的值是有效数字且小于右侧的数字，则为true)LESS_EQUAL:小于或等于(如果给定的字符串或变量的值是有效数字且小于或等于右侧的数字，则为true)GREATER:大于(如果给定的字符串或变量的值是有效数字且大于右侧的数字，则为true)GREATER_EQUAL:大于或等于（如果给定的字符串或变量的值是有效数字且大于或等于右侧的数字，则为true）STREQUAL:字符等于（如果给定的字符串或变量的值按字典顺序(lexicographically)等于右侧的字符串或变量，则为true）STRLESS:字符小于(如果给定的字符串或变量的值按字典顺序(lexicographically)小于右侧的字符串或变量，则为true）STRLESS_EQUAL:小于或等于(如果给定的字符串或变量的值按字典顺序(lexicographically)小于或等于右侧的字符串或变量，则为true)STRGREATER:字符大于(如果给定的字符串或变量的值按字典顺序(lexicographically)大于右侧的字符串或变量，则为true)STRGREATER_EQUAL:字符大于或等于（如果给定的字符串或变量的值按字典顺序(lexicographically)等于右侧的字符串或变量，则为true）#VERSION_EQUAL也就是取整比较（任何非整数版本组件或版本组件的非整数结尾部分都会在该点有效截断字符串)VERSION_EQUAL:等于(如果给定的字符串或变量的值等于右侧的值，则为true)VERSION_LESS:小于（如果给定的字符串或变量的值等于右侧的值，则为true）VERSION_LESS_EQUAL:小于或等于(如果给定的字符串或变量的值小于或等于右侧的值，则为true) VERSION_GREATER:大于(如果给定的字符串或变量的值大于右侧的值，则为true)VERSION_GRATER_EQUAL:大于或等于(如果给定的字符串或变量的值大于或等于右侧的值，则为true)MATCHES:正则表达式匹配(如果给定的字符串或变量的值与给定的正则表达式匹配(matches)，则为true) 逻辑： 123NOT: ！ 如果条件不为ture,，则为trueAND: &amp;&amp; 如果这两个条件都被单独被认为是true，则为trueOR: || 如果任一条件单独被认为是true,则为true 变量值参考网址：http://t.csdn.cn/IfYPc (2).布尔常量值： (3).条件命令 if(): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 语法格式： if (表达式) COMMAND(ARGS...) elseif(表达式) COMMAND(ARGS...) else(表达式) COMMAND(ARGS...) endif(表达式) 示例： set(if_tap OFF) set(elseif_tap ON) if($&#123;if_tap&#125;) message(&quot;if&quot;) elseif($&#123;elseif_tap&#125;) message(&quot;elseif&quot;) else($&#123;if_tap&#125;) message(&quot;else&quot;) endif($&#123;if_tap&#125;) elseif和else部分是可选的， 也可以使⽤多个elseif部分 缩进和空格对语句的解析没有影响(4).循环命令 while(): 语法格式： while(表达式) COMMAND(ARGS...) endwhile(表达式) 示例： set(a &quot;&quot;) while(NOT a STREQUAL &quot;xxx&quot;) set(a &quot;$&#123;a&#125;x&quot;) message(&quot;a = $&#123;a&#125;&quot;) endwhile() break() 可以跳出整个循环 continue() 可以跳出当前循环(5).循环遍历 foreach(): 语法格式： foreach(循环变量 参数1 参数2... 参数N) COMMAND(ARGS...) endforeach(循环变量) 遍历RANGE: #循环范围从start到stop，循环增量为step foreach(循环变量 RANGE start stop step) COMMAND(ARGS...) endforeach(循环变量) 遍历LISTS： foreach(循环遍历 IN LISTS 列表) COMMAND(ARGS...) endforeach(循环变量) 示例： foreach(item 1 2 3) message(&quot;item = $&#123;item&#125;&quot;) endforeach(item) #RANGE：RANGE 4 表示从0到4 foreach(item RANGE 4) message(&quot;item = $&#123;item&#125;&quot;) endforeach(item) #RANGE：打印 1 3 5 foreach(item RANGE 1 5 2) message(&quot;item = $&#123;item&#125;&quot;) endforeach(item) #LISTS： set(list_var 1 2 3) foreach(item IN LISTS list_var) message(&quot;item = $&#123;item&#125;&quot;) endforeach(item) foreach也支持 break() 和 continue() 命令跳出循环7.CMake自定义函数命令 12345678910111213141516171819202122232425语法格式：function(&lt;name&gt;[arg1 [arg3 [arg3...]]]) COMMAND(ARGS...)endfunction(&lt;name&gt;)调用格式：name(参数列表)示例：function(func x y z) message(&quot;call function func&quot;) message(&quot;x = $&#123;x&#125;&quot;) message(&quot;y = $&#123;y&#125;&quot;) message(&quot;z = $&#123;z&#125;&quot;) # ARGC 内置变量 参数个数 message(&quot;ARGC = $&#123;ARGC&#125;&quot;) # ARGVn 内置变量 第 n 个参数，从0开始 message(&quot;arg1 = $&#123;ARGV0&#125;&quot;) message(&quot;arg2 = $&#123;ARGV1&#125;&quot;) message(&quot;arg3 = $&#123;ARGV2&#125;&quot;) # ARGV 内置变量 参数列表 message(&quot;all args = $&#123;ARGV&#125;&quot;)endfunction(func)调用：fun(1 2 3) 8.CMake自定义宏命令 123456789101112131415161718192021222324语法格式：macro(&lt;name&gt;[arg1 [arg3 [arg3...]]]) COMMAND(ARGS...)endmacro(&lt;name&gt;)调用格式：name(实参列表)示例：marco(ma x y z) message(&quot;call macro ma&quot;) message(&quot;x = $&#123;x&#125;&quot;) message(&quot;y = $&#123;y&#125;&quot;) message(&quot;z = $&#123;z&#125;&quot;)endmacro(ma) 调用：ma(1 2 3)函数命令有自己的作用域宏的作用域和调用者的作用域是一样的作用域：全局层:cache变量，在整个项目范围可见，一般在set定义变量时，指定CACHE参数就能定义为cache变量。目录层:在当前目录CMakeLists.txt中定义，以及在该文件包含的其他cmake源文件中定义的变量。函数层:在命令函数中定义的变量，属于函数作用域内的变量。 9.CMake常用变量 12345678910111213141516171819CMake预设了一些常用变量，这些变量通常会在编写CMakeLists.txt文件时使用到：CMAKE_MAJOR_VERSION：cmake 主版本号CMAKE_MINOR_VERSION：cmake 次版本号CMAKE_C_FLAGS：设置 C 编译选项CMAKE_CXX_FLAGS：设置 C++ 编译选项PROJECT_SOURCE_DIR：工程的根目录PROJECT_BINARY_DIR：运行 cmake 命令的目录CMAKE_CURRENT_SOURCE_DIR：当前CMakeLists.txt 所在路径CMAKE_CURRENT_BINARY_DIR：目标文件编译目录EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置UNIX：如果为真，表示为UNIX-like的系统，包括AppleOSX和CygWinWIN32：如果为真，表示为 Windows 系统，包括 CygWinAPPLE：如果为真，表示为 Apple 系统CMAKE_SIZEOF_VOID_P：表示void*的大小（例如为4或者8），可以使用其来判断当前构建为32位还是64位CMAKE_CURRENT_LIST_DIR：表示正在处理的CMakeLists.txt文件所在目录的绝对路径CMAKE_ARCHIVE_OUTPUT_DIRECTORY：用于设置ARCHIVE目标的输出路径CMAKE_LIBRARY_OUTPUT_DIRECTORY：用于设置LIBRARY目标的输出路径CMAKE_RUNTIME_OUTPUT_DIRECTORY：用于设置RUNTIME目标的输出路径 10.CMake常用命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192(1) project命令：命令语法:project(&lt;projectname&gt; [languageName1 languageName2 ...])命令简述:用于指定项目的名称使用范例:project(Main)(2) cmake_minimum_required命令:命令语法:cmake_minimum_requried(VERSION major[.minor[.patch)命令简述:用于指定需要的CMake的最低版本使用范例:cmake_minimum_requried(VERSION 2.8.3)(3) aux_source_directory命令:命令语法:aux_source_directory(&lt;dir&gt; &lt;variable&gt;)命令简述:用于包含源文件目录，dir目录下的所有源文件的名字保存在变量variable中使用范例：aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src DIR_SRCS)(4) add_executable命令:命令语法：add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE][EXCLUDE_FROM_ALL] source1 source2 … sourceN)命令简述:用于指定从一组源文件source1 source2 ... sourceN 编译出一个可执行文件且命名为name使用范例:add_executable(Main $(DIR_SRCS))(5) add_library命令:命令语法：add_library([STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1source2 … sourceN)命令简述：用于指定从一组源文件 source1 source2 ... sourceN编译出一个库文件且命名为name使用范例：add_library(Lib $(DIR_SRCS))(6) add_dependencies命令:命令语法：add_dependencies(target-name depend-target1 depend-target2 …)命令简述：用于指定某个目标（可执行文件或者库文件）依赖于其他的目标。 这里的目标必须是add_executable、add_library、add_custom_target命令创建的目标 (7) add_subdirectory命令:命令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])命令简述:用于添加一个需要进行构建的子目录使用范例:add_subdirectory(Lib)(8) target_link_libraries命令:命令语法：target_link_libraries(&lt;target&gt; [item1 [item2 […]]][[debug|optimized|general] ] …)命令简述:用于指定target需要链接item1 item2 ...。这里target必须已经被创建，链接的item可以是已经存在的target（依赖关系会自动添加）使用范例:target_link_libraries(Main Lib)(9) set命令：命令简述：用于设定变量 variable 的值为 value。如果指定了 CACHE 变量将被放入 Cache（缓存）中。命令语法：set(&lt;variable&gt; &lt;value&gt; [[CACHE &lt;type&gt;&lt;docstring&gt; [FORCE]] | PARENT_SCOPE])使用范例：set(ProjectName Main)(10) unset命令：命令语法：unset(&lt;variable&gt; [CACHE])命令简述：用于移除变量 variable。如果指定了 CACHE 变量将被从 Cache 中移除。使用范例：unset(VAR CACHE)(11) message命令：命令语法：message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] “message todisplay”…)命令简述:用于输出信息使用范例:message(“Hello World”)(12) include_directories命令：命令语法：include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)命令简述：用于设定目录，这些设定的目录将被编译器用来查找 include 文件使用范例：include_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)(13) find_path命令：命令语法：find_path(&lt;VAR&gt; name1 [path1 path2 …])命令简述：用于查找包含文件name1的路径，如果找到则将路径保存在VAR中（此路径为一个绝对路径），如果没有找到则结果为&lt;VAR&gt;-NOTFOUND.默认情况下，VAR会被保存在Cache中，这时候我们需要清除VAR才可以进行下一次查询（使用unset命令）find_path(LUA_INCLUDE_PATH lua.h $&#123;LUA_INCLUDE_FIND_PATH&#125;)if(NOT LUA_INCLUDE_PATH) message(SEND_ERROR &quot;Header file lua.h not found&quot;)endif()(14) find_library命令：命令语法：find_library(&lt;VAR&gt; name1 [path1 path2 …])命令简述：用于查找库文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径）， 如果没有找到则结果为 &lt;VAR&gt;-NOTFOUND。 一个类似的命令 link_directories 已经不太建议使用了 (15) add_definitions命令：命令语法：add_definitions(-DFOO -DBAR …)命令简述：用于添加编译器命令行标志（选项），通常的情况下我们使用其来添加预处理器定义使用范例：add_definitions(-D_UNICODE -DUNICODE)(16) file命令：命令简述：此命令提供了丰富的文件和目录的相关操作（这里仅说一下比较常用的）使用范例：# 目录的遍历# GLOB 用于产生一个文件（目录）路径列表并保存在variable 中# 文件路径列表中的每个文件的文件名都能匹配globbing expressions（非正则表达式，但是类似）# 如果指定了 RELATIVE 路径，那么返回的文件路径列表中的路径为相对于 RELATIVE 的路径file(GLOB variable [RELATIVE path][globbing expressions]...)# 获取当前目录下的所有的文件（目录）的路径并保存到 ALL_FILE_PATH 变量中file(GLOB ALL_FILE_PATH ./*)# 获取当前目录下的 .h 文件的文件名并保存到ALL_H_FILE 变量中# 这里的变量CMAKE_CURRENT_LIST_DIR 表示正在处理的 CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持） NDK（Native Development Kit）是一个用于在Android平台上开发C&#x2F;C++原生代码的工具集。在NDK中，静态库（Static Library）和动态库（Dynamic Library）是两种不同的库文件形式。 静态库(SHARED)是将代码和依赖的库函数编译链接成一个可执行文件时静态地被调用的库。它的特点是将所有代码和依赖性都包含在文件内部，使得可执行文件独立性强，不依赖于其他外部库。静态库在编译时会将所有函数和数据都复制到可执行文件中，因此可执行文件的大小会增加。每次更新或修改静态库中的代码时，都需要重新编译和链接可执行文件。 动态库(STATIC)是独立于可执行文件的共享库，它在程序运行时被动态加载和链接到内存中。动态库可以被多个可执行文件共享，从而提供了代码的重用性和节省了可执行文件的大小。当应用程序需要使用动态库时，操作系统会在运行时加载它们，以提供所需的函数和资源。这样可以在不重新编译和链接可执行文件的情况下更新和修改动态库。 总结： 12341. 静态库在编译时将代码和依赖性复制到可执行文件中，使得可执行文件独立性强，但会增加可执行文件的大小。2. 动态库在程序运行时被动态加载和链接到内存中，可以被多个可执行文件共享，提供了代码的重用性和节省了可执行文件的大小。3. 静态库需要重新编译和链接可执行文件才能更新和修改，而动态库可以在不重新编译和链接可执行文件的情况下更新和修改。4. 静态库适合于对独立性要求较高的场景，而动态库适合于代码重用和共享的场景。 后缀或格式在NDK中，静态库和动态库的文件后缀或格式通常使用以下常见的命名约定： 123456789101112131. 静态库的文件后缀或格式可以是： - Linux系统上：.a - Windows系统上：.lib - macOS系统上：.a 此外，静态库还可以被压缩或归档成.tar.gz或.zip等文件格式。2. 动态库的文件后缀或格式可以是： - Linux系统上：.so (Shared Object) - Windows系统上：.dll (Dynamic Link Library) - macOS系统上：.dylib (Dynamic Library) 这些是常见的命名约定，但并不是绝对的规定，具体的后缀或格式可能会因编译器、操作系统或项目设置的不同而有所变化。在使用NDK开发时，可以根据具体需求和平台要求选择适当的文件后缀或格式来命名静态库和动态库。 CMakeLists.txt 文件详解 【1】 设置cmake最小版本 12# 设置cmake最小版本cmake_minimum_required(VERSION 3.18.1) 【2】指定项目 12# 指定项目project(&quot;jniproject&quot;) 【3】导入库目录 12# 导入头文件目录include_directories(&quot;C:/Program Files/Java/jdk-18.0.1.1/include&quot;) 相当于 -I，如果C&#x2F;C++中没有指定头文件的具体路径，在cmake中用include_directories指定头文件的目录也是可以的。 【4】生成一个动态库 123# 生成一个动态库（windows：dll，android：so）# 可以引入多个文件，多个文件用空格或者换行隔开add_library(jniproject SHARED src/main/cpp/native-lib.cpp src/main/cpp/Test.cpp) add_library可以指定多个源码文件，但是如果文件比较多的话也是一件麻烦的事情。 这里有两种方法可以指定目录中所有的文件： 1234# 指定一个或多个目录中所有对应的文件，并将名称保存到 DIR_SRCS 变量（可以指定多个目录）file(GLOB DIR_SRCS src/main/cpp/*.cpp)message(&quot;DIR_SRCS:=============$&#123;DIR_SRCS&#125;&quot;)add_library(jniproject SHARED $&#123;DIR_SRCS&#125;) 或者 12345# 查找目录所有源文件 并将名称保存到 DIR_SRCS 变量# 不能查找子目录aux_source_directory(src/main/cpp/ DIR_SRCS)#src/main/cpp源文件路径message(&quot;DIR_SRCS:=============$&#123;DIR_SRCS&#125;&quot;)add_library(jniproject SHARED $&#123;DIR_SRCS&#125;) 【5】引入其它cmakelist 12# 添加 child 子目录下的cmakelistadd_subdirectory(child) 【6】指定动态库或静态库路径，或预处理 有两种方法： 12345# 设置一个变量# CMAKE_CXX_FLAGS c++参数# CMAKE_C_FLAGS c参数# CMAKE_C_FLAGS = --sysroot=XXset(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/$&#123;ANDROID_ABI&#125;&quot;) 或者 123456# 引入静态库或者动态库# 第一个参数：库名称# 第二个参数：SHARED：动态库 STATIC：静态库# IMPORTED 表示以导入的方式添加进来（预编译静态/动态库）add_library(Test STATIC IMPORTED)set_target_properties(Test PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/$&#123;ANDROID_ABI&#125;/libTest.a) 【7】生成可执行文件，在Android上不适用 12# 生成可执行文件(生成exe文件， 在VS工具上可用)add_executable (jniproject1 native-lib.cpp) 【8】查找一个ndk自带库 12# log-lib 是变量名称 log是动态库名称 将liblog.so或liblog.a的路径赋值给log-libfind_library(log-lib log) 将日志库log的路径赋值到变量log-lib中。 【9】链接ndk自带的库 12345# 链接ndk自带的库target_link_libraries( jniproject # 链接 libjniproject.so Test # 链接 libTest.so $&#123;log-lib&#125;) # 链接 liblog.so 【10】Cmake基本配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 设置cmake最小版本cmake_minimum_required(VERSION 3.18.1)# 指定项目project(&quot;jniproject&quot;)# 导入头文件目录# include_directories(&quot;C:/Program Files/Java/jdk-18.0.1.1/include&quot;)# 生成一个动态库（windows：dll，android：so）# 可以引入多个文件，多个文件用空格或者换行隔开# add_library(jniproject SHARED src/main/cpp/native-lib.cpp src/main/cpp/Test.cpp)# 指定一个或多个目录中所有对应的文件，并将名称保存到 DIR_SRCS 变量（可以指定多个目录）# file(GLOB DIR_SRCS src/main/cpp/*.cpp)# message(&quot;DIR_SRCS:=============$&#123;DIR_SRCS&#125;&quot;)# add_library(jniproject SHARED $&#123;DIR_SRCS&#125;)# 查找目录所有源文件 并将名称保存到 DIR_SRCS 变量# 不能查找子目录aux_source_directory(src/main/cpp/ DIR_SRCS)message(&quot;DIR_SRCS:=============$&#123;DIR_SRCS&#125;&quot;)add_library(jniproject SHARED $&#123;DIR_SRCS&#125;)# 添加 child 子目录下的cmakelist# add_subdirectory(child)# 设置一个变量# CMAKE_CXX_FLAGS c++参数# CMAKE_C_FLAGS c参数# CMAKE_C_FLAGS = --sysroot=XX# set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/$&#123;ANDROID_ABI&#125;&quot;)# 引入静态库或者动态库# 第一个参数：库名称# 第二个参数：SHARED：动态库 STATIC：静态库# IMPORTED 表示以导入的方式添加进来（预编译静态/动态库）add_library(Test STATIC IMPORTED)set_target_properties(Test PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/$&#123;ANDROID_ABI&#125;/libTest.a)# 输出 Android_ABI 的值message(&quot;ANDROID_ABI =================: $&#123;ANDROID_ABI&#125;&quot;)# 生成可执行文件(生成exe文件， 在VS工具上可用)# add_executable (jniproject1 native-lib.cpp)# log-lib 是变量名称 log是动态库名称 将liblog.so或liblog.a的路径赋值给log-libfind_library(log-lib log)# 链接ndk自带的库target_link_libraries( jniproject # 链接 libjniproject.so Test # 链接 libTest.so $&#123;log-lib&#125;) # 链接 liblog.so 原文链接：https://www.jianshu.com/p/f65dec960e8e","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/Android进阶/NDK/Android进阶之旅/12_makefile/","text":"一、Makefile命令规则12Makefile的命令规则如下：目标:依赖 假设有一个Test.cpp文件，代码如下： 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; count &lt;&lt; &quot;===Test===&quot; &lt;&lt; endl; return 0;&#125; 我们可以使用gcc或g++来 预处理、汇编、编译、链接，也可以利用Makefile来执行这些命令。 在Makefile中填入配置： 123# 生成预处理文件Test.i:Test.cpp g++ -E Test.cpp -o Test.i Test.i 是目标，Test.cpp 是依赖，整体的意思是：Test.i是依赖于Test.cpp生成的。 左右两边用冒号隔开，也就是Makefile命令规范： 1目标:依赖 下一行是 g++ 命令，Test.i的生成是根据这条 g++ 命令生成的。g++前面必须含有分割符，而且必须是tab分割，不能是空格，否则在执行Makefile时不被识别。 执行该Makefile文件： Makefile中可能由多个目标组成，make命令会找到Makefile中第一个目标执行。也可以指定一个目标执行： 1make 目标 现在Makefile中只有一个目标，所以可以执行： 1make Test.i 二、Makefile实现 预处理、汇编、编译、链接123456789101112131415# 生成预处理文件Test.i:Test.cpp g++ -E Test.cpp -o Test.i# 生成汇编文件Test.s:Test.i g++ -S Test.i -o Test.s # 生成目标文件Test.o:Test.s g++ -c Test.s -o Test.o # 生成链接文件（可执行文件）Test:Test.o g++ Test.o -o Test。 定义四个目标，分别是：Test.i、Test.s、Test.o、Test。 分别执行这四个目标： 1234make Test.imake Test.smake Test.omake Test 可以完成 预处理、汇编、编译、链接。 但是，完成这写指令，还可以一步完成，我们的目标是执行 make 命令完成所有的步骤。 只需要改变一下Makefile中的目标顺序即可。 123456789101112131415# 生成链接文件（可执行文件）Test:Test.o g++ Test.o -o Test # 生成目标文件Test.o:Test.s g++ -c Test.s -o Test.o # 生成汇编文件Test.s:Test.i g++ -S Test.i -o Test.s# 生成预处理文件Test.i:Test.cpp g++ -E Test.cpp -o Test.i 输入make命令一次性执行完所有的目标： 注意：顺序要正确，必须形成逐步依赖关系。 三、makefile编译多个文件Student.h 123456789101112131415161718192021#ifndef _STUDENT_H_#define _STUDENT_H_#include &lt;string&gt;using namespace std;class Student &#123;private: string name; int age;public: void setName(string name); string getName(); void setAge(int age); int getAge();&#125;;#endif Student.cpp 1234567891011121314#include &quot;Student.h&quot;void Student::setName(string name) &#123; this-&gt;name = name;&#125;string Student::getName() &#123; return name;&#125;void Student::setAge(int age) &#123; this-&gt;age = age;&#125;int Student::getAge() &#123; return age;&#125; Test.cpp 12345678910111213#include &lt;iostream&gt;#include &quot;Student.h&quot;using namespace std;int main() &#123; Student* stu = new Student(); stu-&gt;setName(&quot;zhangsan&quot;); stu-&gt;setAge(13); cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;getName() &lt;&lt; &quot;, 年龄：&quot; &lt;&lt; stu-&gt;getAge() &lt;&lt; endl; return 0;&#125; Makefile： 123456789101112131415161718192021222324252627# 生成链接文件（可执行文件）Test:Test.o Student.o g++ Test.o Student.o -o Test # 生成目标文件Test.oTest.o:Test.s g++ -c Test.s -o Test.o# 生成目标文件Student.oStudent.o:Student.s g++ -c Student.s -o Student.o # 生成汇编文件Test.sTest.s:Test.i g++ -S Test.i -o Test.s# 生成汇编文件Test.sStudent.s:Student.i g++ -S Student.i -o Student.s # 生成预处理文件Test.iTest.i:Test.cpp g++ -E Test.cpp -o Test.i# 生成预处理文件Student.iStudent.i:Student.cpp g++ -E Student.cpp -o Student.i 执行make命令之后，生成 预处理文件、汇编文件、目标文件、可执行文件。 四、makefile多文件管理在编译期间，在同一个目录下生成多个文件，文件多了有点乱，这时，就需要分类管理，将不同格式的文件放入不同的文件夹。 修改Makefile配置： 123456789101112131415161718192021222324252627282930313233343536373839404142# 定义变量INFO_DIR，指定预处理文件和汇编文件的存放目录INFO_DIR = ./info# 定义变量INC_DIR，指定头文件的存放目录INC_DIR = ./include# 定义变量SRC_DIR，指定c/c++文件的存放目录SRC_DIR = ./src# 定义变量BIN_DIR，指定可执行文件的存放目录BIN_DIR = ./bin# 定义变量OBJ_DIR，指定可执行文件的存放目录OBJ_DIR = ./obj# 生成链接文件（可执行文件）Test:$&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o g++ $&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o -o $&#123;BIN_DIR&#125;/Test # 生成目标文件Test.o$&#123;OBJ_DIR&#125;/Test.o:$&#123;INFO_DIR&#125;/Test.s g++ -c $&#123;INFO_DIR&#125;/Test.s -o $&#123;OBJ_DIR&#125;/Test.o# 生成目标文件Student.o$&#123;OBJ_DIR&#125;/Student.o:$&#123;INFO_DIR&#125;/Student.s g++ -c $&#123;INFO_DIR&#125;/Student.s -o $&#123;OBJ_DIR&#125;/Student.o # 生成汇编文件Test.s$&#123;INFO_DIR&#125;/Test.s:$&#123;INFO_DIR&#125;/Test.i g++ -S $&#123;INFO_DIR&#125;/Test.i -o $&#123;INFO_DIR&#125;/Test.s# 生成汇编文件Test.s$&#123;INFO_DIR&#125;/Student.s:$&#123;INFO_DIR&#125;/Student.i g++ -S $&#123;INFO_DIR&#125;/Student.i -o $&#123;INFO_DIR&#125;/Student.s # 生成预处理文件Test.i$&#123;INFO_DIR&#125;/Test.i:$&#123;SRC_DIR&#125;/Test.cpp g++ -E $&#123;SRC_DIR&#125;/Test.cpp -o $&#123;INFO_DIR&#125;/Test.i# 生成预处理文件Student.i$&#123;INFO_DIR&#125;/Student.i:$&#123;SRC_DIR&#125;/Student.cpp g++ -E $&#123;SRC_DIR&#125;/Student.cpp -o $&#123;INFO_DIR&#125;/Student.i 目录结构如下： 123456bin、include、info、obj、src文件夹需要手动创建；bin文件夹存放可执行文件；include文件夹存放头文件；info文件夹存放预处理文件和汇编文件；obj文件夹存放目标文件；src文件夹存放c或cpp文件； 五、clean命令在Makefile中添加： 12clean: del bin obj info 执行clean命令，可以删除 bin、obj、info文件夹中所有的文件。 1make clean 六、Makefile通配符1234567%.o：表示一个xx.o文件$@：表示目标文件$&lt;：表示第一个依赖文件$^：所有不重复的依赖文件，以空格分开$*：不包含扩展名的target文件名称$+：所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件$?：所有时间戳比target文件晚的依赖文件，并以空格分开 由于 -o 后面输出的必然是目标文件，所以 -o 后面的输出文件可以替换为 $@： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 定义变量INFO_DIR，指定预处理文件和汇编文件的存放目录INFO_DIR = ./info# 定义变量INC_DIR，指定头文件的存放目录INC_DIR = ./include# 定义变量SRC_DIR，指定c/c++文件的存放目录SRC_DIR = ./src# 定义变量BIN_DIR，指定可执行文件的存放目录BIN_DIR = ./bin# 定义变量OBJ_DIR，指定可执行文件的存放目录OBJ_DIR = ./obj# 生成链接文件（可执行文件）$&#123;BIN_DIR&#125;/Test:$&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o g++ $&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o -o $@ # 生成目标文件Test.o$&#123;OBJ_DIR&#125;/Test.o:$&#123;INFO_DIR&#125;/Test.s g++ -c $&#123;INFO_DIR&#125;/Test.s -o $@# 生成目标文件Student.o$&#123;OBJ_DIR&#125;/Student.o:$&#123;INFO_DIR&#125;/Student.s g++ -c $&#123;INFO_DIR&#125;/Student.s -o $@ # 生成汇编文件Test.s$&#123;INFO_DIR&#125;/Test.s:$&#123;INFO_DIR&#125;/Test.i g++ -S $&#123;INFO_DIR&#125;/Test.i -o $@# 生成汇编文件Test.s$&#123;INFO_DIR&#125;/Student.s:$&#123;INFO_DIR&#125;/Student.i g++ -S $&#123;INFO_DIR&#125;/Student.i -o $@ # 生成预处理文件Test.i$&#123;INFO_DIR&#125;/Test.i:$&#123;SRC_DIR&#125;/Test.cpp g++ -E $&#123;SRC_DIR&#125;/Test.cpp -o $@# 生成预处理文件Student.i$&#123;INFO_DIR&#125;/Student.i:$&#123;SRC_DIR&#125;/Student.cpp g++ -E $&#123;SRC_DIR&#125;/Student.cpp -o $@ clean: del bin obj info 12345678910111213141516171819202122232425262728293031323334#$&lt;、$^ 和 % 结合使用，可以最大程度上简化配置：# 定义变量INFO_DIR，指定预处理文件和汇编文件的存放目录INFO_DIR = ./info# 定义变量INC_DIR，指定头文件的存放目录INC_DIR = ./include# 定义变量SRC_DIR，指定c/c++文件的存放目录SRC_DIR = ./src# 定义变量BIN_DIR，指定可执行文件的存放目录BIN_DIR = ./bin# 定义变量OBJ_DIR，指定可执行文件的存放目录OBJ_DIR = ./obj# 生成链接文件（可执行文件）$&#123;BIN_DIR&#125;/Test:$&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o g++ $^ -o $@# 生成所有目标文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;OBJ_DIR&#125;/%.o:$&#123;INFO_DIR&#125;/%.s g++ -c $&lt; -o $@ # 生成所有汇编文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.s:$&#123;INFO_DIR&#125;/%.i g++ -S $&lt; -o $@# 生成所有预处理文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.i:$&#123;SRC_DIR&#125;/%.cpp g++ -E $&lt; -o $@ clean: del bin obj info 以上配置显然已经简单了很多。 另外，头文件已经放在include目录，cpp文件已经放在了src目录，所以需要指定头文件位置，由两种方法可以指定： 【方法一】在cpp中修改头文件位置 将 1#include &quot;Student.h&quot; 改成 1#include &quot;../include/Student.h&quot; 【方法二】g++命令后面指定头文件路径 加入 -I $(INC_DIR) 导入头文件 12345678910111213141516171819202122232425262728293031323334353637# 定义变量INFO_DIR，指定预处理文件和汇编文件的存放目录INFO_DIR = ./info# 定义变量INC_DIR，指定头文件的存放目录INC_DIR = ./include# 定义变量SRC_DIR，指定c/c++文件的存放目录SRC_DIR = ./src# 定义变量BIN_DIR，指定可执行文件的存放目录BIN_DIR = ./bin# 定义变量OBJ_DIR，指定可执行文件的存放目录OBJ_DIR = ./obj# -I 指定头文件 CXXFLAGS=-I $(INC_DIR)# 生成链接文件（可执行文件）$&#123;BIN_DIR&#125;/Test:$&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o g++ $(CXXFLAGS) $^ -o $@# 生成所有目标文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;OBJ_DIR&#125;/%.o:$&#123;INFO_DIR&#125;/%.s g++ $(CXXFLAGS) -c $&lt; -o $@ # 生成所有汇编文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.s:$&#123;INFO_DIR&#125;/%.i g++ $(CXXFLAGS) -S $&lt; -o $@# 生成所有预处理文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.i:$&#123;SRC_DIR&#125;/%.cpp g++ $(CXXFLAGS) -E $&lt; -o $@ clean: del bin obj info g++出现了多次，也可以使用变量代替，并且新增TAGERT和OBJS变量： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 定义变量INFO_DIR，指定预处理文件和汇编文件的存放目录INFO_DIR = ./info# 定义变量INC_DIR，指定头文件的存放目录INC_DIR = ./include# 定义变量SRC_DIR，指定c/c++文件的存放目录SRC_DIR = ./src# 定义变量BIN_DIR，指定可执行文件的存放目录BIN_DIR = ./bin# 定义变量OBJ_DIR，指定可执行文件的存放目录OBJ_DIR = ./obj# -I 指定头文件 CXXFLAGS=-I $(INC_DIR)# CC 指定编译器 gcc 、 g++CC=g++#最终生成的目标，TAGERT=Test# 目标文件OBJS=$&#123;OBJ_DIR&#125;/Test.o $&#123;OBJ_DIR&#125;/Student.o# 生成链接文件（可执行文件）$&#123;BIN_DIR&#125;/$&#123;TAGERT&#125;:$&#123;OBJS&#125; $&#123;CC&#125; $(CXXFLAGS) $^ -o $@# 生成所有目标文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;OBJ_DIR&#125;/%.o:$&#123;INFO_DIR&#125;/%.s $&#123;CC&#125; $(CXXFLAGS) -c $&lt; -o $@ # 生成所有汇编文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.s:$&#123;INFO_DIR&#125;/%.i $&#123;CC&#125; $(CXXFLAGS) -S $&lt; -o $@# 生成所有预处理文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.i:$&#123;SRC_DIR&#125;/%.cpp $&#123;CC&#125; $(CXXFLAGS) -E $&lt; -o $@ clean: del bin obj info 以上配置还存在一定的弊端，OBJS变量指定了目标文件，此时的目标文件是需要指定具体目标文件的。 七、wildcard函数查找$(wildcard pattern)：pattern定义了文件名的格式，wildcard取出其中存在的文件。 12# wildcard查找当前目录下所有cpp文件SRCS=$(wildcard $(SRC_DIR)/*.cpp) 此时 SRCS 就是 src目录下所有cpp格式的文件。 八、patsubst函数替换$(patsubst pattern,replacement,$(var))：从var中将符合patern格式的内容，替换为replacement。 123456# wildcard查找当前目录下所有cpp文件SRCS=$(wildcard $(SRC_DIR)/*.cpp)# notdir 去除掉绝对路径，只保留名字# patsubst 把字串 $(notdir $(SRCS)) 符合模式[%.cpp]的单词替换成[%.o]OBJS=$(patsubst %.cpp,$(OBJ_DIR)/%.o,$(notdir $(SRCS))) patsubst 可以解决指定明确目标文件的弊端，改进弊端之后的配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 定义变量INFO_DIR，指定预处理文件和汇编文件的存放目录INFO_DIR = ./info# 定义变量INC_DIR，指定头文件的存放目录INC_DIR = ./include# 定义变量SRC_DIR，指定c/c++文件的存放目录SRC_DIR = ./src# 定义变量BIN_DIR，指定可执行文件的存放目录BIN_DIR = ./bin# 定义变量OBJ_DIR，指定可执行文件的存放目录OBJ_DIR = ./obj# -I 指定头文件 CXXFLAGS=-I $(INC_DIR)# CC 指定编译器 gcc 、 g++CC=g++#最终生成的目标，TAGERT=Test# wildcard查找当前目录下所有cpp文件SRCS=$(wildcard $(SRC_DIR)/*.cpp)# notdir 去除掉绝对路径，只保留名字# patsubst 把字串 $(notdir $(SRCS)) 符合模式[%.cpp]的单词替换成[%.o]OBJS=$(patsubst %.cpp,$(OBJ_DIR)/%.o,$(notdir $(SRCS))) # wildcard *.cpp 当前目录下所有c文件SRCS=$(wildcard $(SRC_DIR)/*.cpp)# 生成链接文件（可执行文件）$&#123;BIN_DIR&#125;/$&#123;TAGERT&#125;:$&#123;OBJS&#125; $&#123;CC&#125; $(CXXFLAGS) $^ -o $@# 生成所有目标文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;OBJ_DIR&#125;/%.o:$&#123;INFO_DIR&#125;/%.s $&#123;CC&#125; $(CXXFLAGS) -c $&lt; -o $@ # 生成所有汇编文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.s:$&#123;INFO_DIR&#125;/%.i $&#123;CC&#125; $(CXXFLAGS) -S $&lt; -o $@# 生成所有预处理文件 %：任意字符通配符 $&lt;：表示第一个依赖文件$&#123;INFO_DIR&#125;/%.i:$&#123;SRC_DIR&#125;/%.cpp $&#123;CC&#125; $(CXXFLAGS) -E $&lt; -o $@ clean: del bin obj info 九、Makefile的变量Makefile的变量分为两种：及时变量、延时变量 1234【1】 `:=`：即时变量，该变量的值即刻确定，在定义时就被确定了;【2】`=`：延时变量，该变量的值，在使用时才确定；【3】`?=`：延时变量，第一次定义才起效，如果前面被定义过了就忽略这句；【4】`+=`：附加，它是即时变量还是延时变量取决于前面的定义； 十、函数遍历$(foreach val,list,text)：对于list（通常用空格隔开）里的每一个变量执行text操作 123456789# 定义一个listLIST=a b c# 用f代表A中的各个变量，执行第三个参数的操作。# foreach 遍历关键字，f：LIST中的每个变量，RESULT=$(foreach f,$(LIST),$(f).result)all: @echo RESULT=$(RESULT) 输出结果： 1RESULT=a.result b.result c.result 十一、filter函数过滤$(filter pattern...,text)：在text里面取出符合pattern格式的值 $(filter-out pattern...,text)：在text里面取出不符合pattern格式的值 123456789101112# 定义变量C C= a b c d/# 在变量C中取出符合%/的值D=$(filter %/,$(C))# 在变量C中取出不符合%/的值E=$(filter-out %/,$(C))all: @echo D=$(D) @echo E=$(E) 输出结果： 12D=d/E=a b c 十二、CXXFLAGS补充上面已经定义了 CXXFLAGS 变量： 1CXXFLAGS=-I $(INC_DIR) 我们还可以对它进行补充，比如： 12# -I 指定头文件 CXXFLAGS=-I $(INC_DIR) -Wall -O2 -std=c++11 -frtti -fexceptions 可以指定的FLAG有： 123456789【1】-Werror：会把所有警告当成错误【2】-I: 该选项用于指定编译程序时依赖的头文件路径【3】-On: 这是一个优化选项，如果在编译时指定该选项，则编译器会根据n的值（n取0到3之间） 对代码进行不同程度的优化，其中-O0 表示不优化，n的值越大，优化程度越高【4】-L: 库文件依赖选项，该选项用于指定编译的源程序依赖的库文件路径，库文件可以是静态链接库，也可以是动态链接库【5】-Wall: 允许发出gcc能提供的所有有用的警告，也可以用-W(warning)来标记指定的警告【6】-std=c++11：C++11标准【7】-frtti 和 -fexceptions：关闭 exceptions、rtti 可以减小程序的占用的空间和提升程序的运行效率， 关闭后可能带来一些不兼容问题，使用 typeid 运算符必须开启 RTTI 原文：NDK&lt;第五篇&gt;：Makefile（windows环境） - 简书 (jianshu.com)","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"}]},{"path":"wiki/C++/window系统_vscode中配置 c++环境/","text":"1. 下载编辑器VScode 官网：https://code.visualstudio.com/ 安装VScode（建议附加任务全部勾选） 2. 下载编译器MinGW并解压 官网页面：https://www.mingw-w64.org/ 下载页面：https://sourceforge.net/projects/mingw-w64/files/ 你可以进入官网自行寻找 你也可以直接点击为你找好的下载页面 下载页面中选择 x86_64-win32-seh 下载 如果你因为网络环境限制无法下载 不限速下载，请笑纳^-^：https://wwn.lanzouh.com/iLOip031ku6b 密码:1234 在C盘中解压文件 理论上你可以在任何地方解压，但注意路径不能包含中文，至于特殊字符请自行测试 3. 将MinGW添加至环境变量 进入mingw64下的bin文件夹，复制当前路径，Win + i唤起系统设置，输入高级系统设置并进入，点击环境变量，选择path，编辑，新建，粘贴路径，按下三个确定 4. 配置VScode插件 打开VScode安装插件 Chinese 和 C/C++ ，等待安装完毕后重启VScode 切换C&#x2F;C++插件至 1.8.4 版本 因最新版本不会自动生成launch.json文件，给后续优化带来不便，故退回旧版本。 5. 运行代码 新建文件夹，修改为英文名称并进入，右键 通过Code打开 若在安装时未勾选相关选项，可能没有这个选项，请自行在VScode内操作打开文件夹 新建一个文件，英文命名且扩展名为 .c 编写相关代码 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf(&quot;Hello World!\\n&quot;); printf(&quot;你好世界！\\n&quot;); system(&quot;pause&quot;); // 防止运行后自动退出，需头文件stdlib.h return 0;&#125; VScode菜单栏，点击运行，启动调试，稍等程序运行，输出结果在下方终端，上方调试面板，点击最右边的 橙色方框 停止程序运行 6. 调整和优化 请根据自己的需要进行优化 代码运行后 .vscode 文件夹会自动生成在你的源文件目录下 .vscode 文件夹下的 task.json 和 launch.json 用来控制程序的运行和调试 将程序运行在外部控制台【推荐】 ​ 打开.vscode 文件夹下的 launch.json 文件，找到 &quot;externalConsole&quot;: false, 将 false 改为 true 并保存 解决中文乱码问题【推荐】 ​ 打开.vscode 文件夹下的 task.json 文件，找到 &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; 在后面加上英文 逗号 然后回车到下一行，粘贴下面文本 &quot;-fexec-charset=GBK&quot; 并保存 收纳生成的 exe 可执行文件【可选】 ​ 1.打开.vscode 文件夹下的 task.json 文件，找到 &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ​ 2.修改成 &quot;$&#123;fileDirname&#125;\\\\coin\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; 并保存，同理，launch.json 下也有相同的字段，需要你修改 ​ 3.在源文件同目录下新建 coin 文件夹，程序运行后，可执行文件将会生成在里面（其中 coin 可修改成你喜欢的英文名字） 这样 .c 文件一多起来的时候，就不会出现 .exe 和 .c 相互穿插在目录中^-^ 7. 提示 若源代码文件夹含有中文路径，将会无法编译程序。 若你的Windows用户名使用了中文，可能无法运行。","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"}]},{"path":"wiki/C++/C++教程从0到1入门编程/3.C++核心/","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"},{"name":"C++教程从0到1入门编程","slug":"C/C-教程从0到1入门编程","permalink":"https://cq_tyl.gitee.io/categories/C/C-%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/"}]},{"path":"wiki/C++/C++教程从0到1入门编程/2.C++提高/","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"},{"name":"C++教程从0到1入门编程","slug":"C/C-教程从0到1入门编程","permalink":"https://cq_tyl.gitee.io/categories/C/C-%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/"}]},{"path":"wiki/C++/C++教程从0到1入门编程/1.C++基础/","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"},{"name":"C++教程从0到1入门编程","slug":"C/C-教程从0到1入门编程","permalink":"https://cq_tyl.gitee.io/categories/C/C-%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/"}]},{"path":"wiki/Android进阶/java 反射及代理模式初步学习/","text":"什么是反射？Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。[摘自百度百科] 反射的用途反射通常由需要检查或修改Java虚拟机中运行的应用程序的运行时行为的程序使用。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。考虑到这一警告，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。 反射的优缺点优点：a. 可扩展性应用程序可以通过使用其完全限定的名称创建可扩展性对象的实例来使用外部用户定义的类。b. 类浏览器和可视化开发环境类浏览器需要能够枚举类的成员。可视化开发环境可以受益于利用反射中可用的类型信息来帮助开发人员编写正确的代码。c. 调试器和测试工具调试器需要能够检查类的私有成员。测试工具可以利用反射来系统地调用在类上定义的可发现的集合API，以确保测试套件中的代码覆盖率很高。缺点：反射功能强大，但不应随意使用。如果可以在不使用反射的情况下执行操作，那么最好避免使用它。通过反射访问代码时，应牢记以下注意事项。a. 性能开销由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此应避免在对性能敏感的应用程序中经常调用的代码段中。b. 安全限制反射需要运行时许可，而在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。c. 暴露内部细节由于反射允许代码执行在非反射代码中是非法的操作，例如访问私有字段和方法，因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射性代码破坏了抽象，因此可能会随着平台的升级而改变行为。以上内容引用百度百科或翻译自java官方文档，使大家对于Java反射有一个基本的认识，接下来我们开始学习java反射的基本使用。 Java反射基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186 1. 首先我们创建一个类，然后分别使用正常手段和反射方式获取类的实例 public class Person &#123; String name; private int age; // 无参构造 public Person () &#123; &#125; // 有参构造 public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; // public 方法 public void printName() &#123; System.out.println(&quot;printName = &quot; + name); &#125; // private 方法 private void printAge() &#123; System.out.println(&quot;printAge = &quot; + age); &#125;&#125;这个类共有两个属性，两个构造方法，set，get方法以及一个公共的printName方法，一个私有的printAge方法，下面我们就分别使用正常方法和反射方法获取该类的对象一. 正常的方式 Person person = new Person(); // 这种方式就不多说了，大家都会的二. 反射方式 // 使用反射获取类对象的步骤如下 // 1. 获取类 // 2. 调用newInstance方法实例化对象 // 获取类的方式有三种 // 1. 类名.class // 2. 对象名.getClass(); // 3. Class.forName(&quot;类的全路径名&quot;); // 以下例子讲解了反射的各种用法，其中包括： // 1. 获取类 // 2. 获取类加载器(这个后面再说，先了解) // 3. 获取方法列表(public、private) // 4. 获取属性列表(public、private) // 5. 获取构造器列表 // 6. 获取指定的方法，属性 具体请看以下代码：public class main &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123; // 1. 正常的手段 Person person = new Person(); // 2. 反射 // 第一种拿到类的方式 Class cls = Person.class; // 第二种拿到类的方式 Class cls1 = person.getClass(); // 第三种拿到类的方式 Class cls2 = Class.forName(&quot;Person&quot;); // 获取实例, 使用Class.newInstance方法来实例化对象 Person person1 = (Person) cls.newInstance(); person1.setName(&quot;jiangc&quot;); person1.printName(); // 类加载器，获取类加载器的方式,Class.getClassLoader ClassLoader classLoader = person1.getClass().getClassLoader(); System.out.println(classLoader); System.out.println(&quot;------------------------获取公共方法，包括从父类继承 通过getMethods方法-----------------------------------------------------&quot;); // 获取公共方法，包括从父类继承 通过getMethods方法 Method[] methods = cls.getMethods(); // 打印一下 for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(methods[i].getName() + &quot;()&quot;); &#125; System.out.println(&quot;------------------------获取类的所有方法，包括私有方法，只能是本类的 通过getDeclareMethods方法----------------------------------------------------&quot;); // 获取类的所有方法，包括私有方法，只能是本类的 通过getDeclareMethods方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod.getName() + &quot;()&quot;); &#125; System.out.println(&quot;------------------------获取指定方法 通过getMethod方法, 第一个参数是方法名，后面是可变参数，是参数的类型-----------------------------------------------------&quot;); // 获取指定方法 通过getMethod方法, 第一个参数是方法名，后面是可变参数，是参数的类型 Method setName = cls.getMethod(&quot;setName&quot;, String.class); // 执行方法 通过invoke 第一个是对象，后面是方法的参数 setName.invoke(person1, &quot;lalala&quot;); person1.printName(); // 其中注意的一个点，类似于int类型的在传入类型的时候使用int.class 这种方式，如下所示 Method setAge = cls.getMethod(&quot;setAge&quot;, int.class); setAge.invoke(person1, 18); System.out.println(&quot;age = &quot; + person1.getAge()); // 访问私有方法有一些不同, 如果直接invoke会报错，因为没有访问权限，在调用私有方法的时候需要先调用setAccessible方法，打开访问权限 Method printAge = cls.getDeclaredMethod(&quot;printAge&quot;); printAge.setAccessible(true); printAge.invoke(person1); System.out.println(&quot;-------------------获取字段 使用getFields 方法----------------------------------------------------------&quot;); // 获取字段 使用getFields 方法 Field[] fields = cls.getFields(); for (Field field : fields) &#123; System.out.println(field.getName()); &#125; System.out.println(&quot;-------------------这里只有一个public修饰的字段,使用getDeclareFields方法可以获取私有的字段----------------------------------------------------------&quot;); // 这里只有一个public修饰的字段,使用getDeclareFields方法可以获取私有的字段 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField.getName()); &#125; System.out.println(&quot;--------------------获取指定字段，和方法类似，这里使用的是getField方法, 传入字段名---------------------------------------------------------&quot;); // 获取指定字段，和方法类似，这里使用的是getField方法, 传入字段名 Field name = cls.getField(&quot;name&quot;); System.out.println(&quot;打印:&quot;); System.out.println(&quot;字段的名字 :&quot; + name.getName()); // 打印字段的值 System.out.println(&quot;字段的值：&quot; + name.get(person1)); // 修改public字段的值 // 修改字段的值 name.set(person1, &quot;yayaya&quot;); System.out.println(name.get(person1)); Object o = name.get(person1); // 修改私有字段的值 System.out.println(&quot;修改私有字段的值, 和私有方法一样，无论访问还是修改，都需要调用setAccessible方法来打开权限&quot;); // 获取私有字段 Field age = cls.getDeclaredField(&quot;age&quot;); age.setAccessible(true); System.out.println(&quot;age原本的值：&quot; + age.get(person1)); // 修改age age.set(person1, 27); System.out.println(&quot;修改之后的值：&quot; + age.get(person1)); // 大家看到，前面通过反射拿到的对象都是调用的newInstance方法， //这个方法我们没有传参数，Person有一个有参构造，那么我们怎么通过有参构造来实例化对象呢 // 使用Constructors()方法获取所有的构造方法 System.out.println(&quot;-----------------------------------------------------------------------------&quot;); System.out.println(&quot;通过getConstructors方法获取构造方法的列表&quot;); Constructor&lt;Person&gt;[] constructors = (Constructor&lt;Person&gt;[]) cls.getConstructors(); for (Constructor&lt;Person&gt; constructor : constructors) &#123; System.out.println(constructor); &#125; // 获取指定名称的构造方法 System.out.println(&quot;获取指定构造器实例化对象&quot;); Constructor&lt;Person&gt; constructor = (Constructor&lt;Person&gt;) cls.getConstructor(String.class, int.class); Person xixixi = (Person) constructor.newInstance(&quot;xixixi&quot;, 23); xixixi.printName(); // 其他获取私有的啊什么的大家自己去尝试 // 以上讲解了如何使用反射获取类的public和private的方法、属性，列表，获取public和private的指定方法，属性，以及调用方法，还有获取指定构造器实例化的使用方式。反射的知识就讲到这里。 &#125;&#125; 反射在代理模式中的使用 首先我们先看一下代理模式，什么是代理模式，举个例子：代购的公司，房产中介公司，都可以看作代理，例如说你要买海外的东西，有两种方式：1. 自己直接联系海外商家，直接买，2. 找代购，把自己的需求告诉代购，代购全权代理，你不需要和商家打交道，这就是代理 我们先来看一下代理模式的类的关系图: 说一下这个类的关系，Subject类主要定义了一些公共方法，然后真实类和代理类去实现这个类，同时代理类拥有真实类的引用，从而调用真实类的方法。 代理模式有两种：1. 静态代理 2. 动态代理我们先看静态代理 首先，想象一个场景，有一个房产中介aProxy，他可以为客户提供租房服务，客户aClient找他租房，中介aProxy找房东，中介为客户提供全套服务，包括合同，打扫等服务，下面我们根据代理模式的类图来实现一下 1.公共类，提供接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 公寓类，定义公共方法(对应抽象类:Subject) */public interface Apartment &#123; // 租房接口,提供一个参数：租房面积 public void renting(int area);&#125; 3. 房东提供租房/** * 房产中介(对应上面类图中的真实类:Goodscompanies) */public class Intermediary implements Apartment&#123; @Override public void renting(int area) &#123; System.out.println(&quot;房屋出租面积为：&quot; + area + &quot;的房屋&quot;); &#125;&#125;4. 中介代理房东/** * 代理人（对应上面的Proxy） */public class ProxyPeople implements Apartment&#123; // 真实对象的引用 private Intermediary intermediary; /** * 代理自己的方法(增强方法) */ private void conclude_contract() &#123; System.out.println(&quot;代理签合同&quot;); &#125; /** * 代理自己的方法(增强方法) */ private void sweep() &#123; System.out.println(&quot;代理打扫房间&quot;); &#125; @Override public void renting(int area) &#123; conclude_contract(); // 调用真实的对象的方法 intermediary.renting(area); sweep(); &#125;&#125; 这时候，客户想买一个新房子，而这个租房子的代理人没有能力提供买房子的服务(大家这里不要抠细节，我们假设这个中介就只能处理租房的事情)，而另外一个中介可以提供买房的信息，所以，客户买房子就只能换一个代理这里记为：ProxyRealty，提供新房的实体其实是房地产开发商，所以关系是，买房的代理通过开放商向客户提供买房服务，请看下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 房产类接口 */public interface Brealty &#123; public void renting(int area);&#125;/** * 开发商 */public class realty implements Brealty&#123; @Override public void renting(int area) &#123; System.out.println(&quot;客户买了：&quot; + area + &quot;面积的房子&quot;); &#125;&#125;/** * 提供买房服务代理类 */public class ProxyRealty implements Brealty&#123; // 提供房子的实体类 private realty re; public ProxyRealty(realty re) &#123; this.re = re; &#125; private void see_apartment() &#123; System.out.println(&quot;带着顾客看房子...&quot;); &#125; private void sign_contract () &#123; System.out.println(&quot;和客户签合同&quot;); &#125; private void pay() &#123; System.out.println(&quot;交首付&quot;); &#125; private void handing_room() &#123; System.out.println(&quot;交房&quot;); &#125; @Override public void renting(int area) &#123; see_apartment(); re.renting(200); sign_contract(); pay(); handing_room(); &#125;&#125; 大家想一下，假如这时候客户买完房子了，想装修，这时候通过网络又找到另外一个代理人，全权交给这个人帮自己装修，代码和上面类似，这里就不写了，大家有感觉了吗？这就是静态代理，大家可以对照类图和代码例子理解一下。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"}]},{"path":"wiki/Android FrameWork/Framework相关/ANR的产生机制/","text":"","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework相关","slug":"Android-FrameWork/Framework相关","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E7%9B%B8%E5%85%B3/"}]},{"path":"wiki/Android FrameWork/Framework相关/2.Binder原理解析/","text":"","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework相关","slug":"Android-FrameWork/Framework相关","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E7%9B%B8%E5%85%B3/"}]},{"path":"wiki/Android FrameWork/Framework相关/1.Handler消息机制原理解析/","text":"一个线程有几个handler? 答：作为应用层的类时，一个线程允许同时存在多个handler，但是都属于一个Looper; hander作为通信机制时，仅有一套统信机制looper,安卓与主线程通信的跨线程通信底层都是通过looper; 一个线程对应一个Looper，一个Looper一个MessageQueue; 线程间统信的原理是怎样的？ handler发送msg流程：handler.sendMessage()-&gt;handler.enquenueMessage-&gt;MessageQueue.enqueueMessage; 主线程取消息&#x2F;处理消息流程：Activity,main()-&gt;Looper.loop()-&gt;MessageQueue.next()-&gt;handler.dispatchMessage-&gt;handler.hanleMessage(); 线程间的通信原理是内存共享(MessageQueue共享）; Handler内存泄漏的原因？为什么其他内部类没有过这种问题？ 12345678//MainActivity.classprivate Handler mHandler=new Handler()&#123; @Override public void handleMessage(@NonNull Message msg) &#123; super.handleMessage(msg); click(); //调用这个方法时默认为MainActivity.this.click();会持有MainActivity.this的对象； &#125; &#125; handler在activity中使用时的持有链： statuc sThreadLocal-&gt;Looper-&gt;MessageQueue Message-&gt;Handler-MainActivity.this； 当handler执行delay消息时，jvm无法回收上面的持有链，导致内存泄漏； 123解决方案：1.handler加static关键字，然后外部方法才有弱引用，软引用；2.activity销毁时释放所有handler的消息，如 mHandler.removeCallbacksAndMessages(null); 子线程多并发安全的使用handler： 1234HandlerThread handlerThread = new HandlerThread(&quot;threadName&quot;);handlerThread.start();//HandlerThread中处理了looper同步和线程锁等问题；Handler handler1 = new Handler(handlerThread.getLooper());Handler handler2 = new Handler(handlerThread.getLooper()); message消息复用： 1mHandler.obtainMessage();//清空消息后复用message对象，大量new Message会存在内存抖动；","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework相关","slug":"Android-FrameWork/Framework相关","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E7%9B%B8%E5%85%B3/"}]},{"path":"wiki/Android Application/Android工具类/EditText弹出键盘时滚动到界面指定位置/","text":"方法1：使用KeyWordUtils使用方法： ScrollView中包含LinearLayout，改LinearLayout中可放置多个edittext activity在配置文件中记得添加 android:windowSoftInputMode&#x3D;”adjustResize|stateHidden” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//源码：import android.annotation.SuppressLint;import android.app.Activity;import android.content.Context;import android.graphics.Rect;import android.view.View;import android.view.ViewGroup;import android.view.WindowManager;import android.widget.ScrollView;public class KeyWordUtils &#123; /** \\* 弹出键盘时滚动到界面指定位置 \\* Created 2015-1-30 上午11:19:23 \\* @param activity \\* 当前Activity \\* @param lyRootID \\* 所在根布局ID \\* @param vID \\* 要滚动到的控件ID \\* @param svID \\* 控件所在ScrollView ID \\* @author gpy */ @SuppressLint(&quot;NewApi&quot;) public static void pullKeywordTop(final Activity activity,final int lyRootID,final int vID,final int svID,final int needHideId)&#123; ViewGroup ly = (ViewGroup) activity.findViewById(lyRootID); //获取屏幕高度，根据经验，输入法弹出高度一般在屏幕1/3到1/2之间 final int defaultHeight = ((WindowManager)activity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getHeight(); final int mKeyHeight = defaultHeight/4; ly.addOnLayoutChangeListener(new View.OnLayoutChangeListener() &#123; @Override public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; //获取根布局前后高度差 int height = oldBottom-bottom; ScrollView sv = (ScrollView)activity.findViewById(svID); if(height&gt;mKeyHeight) &#123;//当高度差大于屏幕1/4，认为是输入法弹出变动，可能会有特殊机型会失败 activity.findViewById(needHideId).setVisibility(View.GONE); final int lybottom = bottom; sv.post(new Runnable() &#123;//用post防止有时输入法会自动滚动覆盖我们手动滚动 @Override public void run() &#123; ScrollView runSv = (ScrollView)activity.findViewById(svID); //获取要滚动至的控件到屏幕顶部高度 View v = (View)activity.findViewById(vID); int[] loca = new int[2]; ////获取在整个屏幕内的绝对坐标，注意这个值是要从屏幕顶端算起，也就是包括了通知栏的高度。loca[0] x,loca[1] y v.getLocationOnScreen(loca); //这种通知栏高度获取方法必须在布局构建完毕后才能生效，否则获取为0 Rect frame = new Rect(); //getWindowVisibleDisplayFrame方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame); //获取状态栏高度 int statusBarHeight = frame.top; // 要滚动的距离=控件距屏幕顶部距离+控件高度-输入法弹出后的activity高度-通知栏高度 int scrollHeight = loca[1] + v.getHeight() - lybottom - statusBarHeight; if(scrollHeight&gt;0)&#123; runSv.scrollBy(0, scrollHeight); &#125; &#125; &#125;); &#125;else if(-height&gt;mKeyHeight)&#123;//当输入法收起，回滚回顶部 sv.scrollTo(0,0); activity.findViewById(needHideId).setVisibility(View.VISIBLE); &#125; &#125; &#125;); &#125;&#125; 方法2：在activity的底部加一个占位的View，当页面能测量控件高度时，每次键盘弹出后，增加占位View的高度。 findViewById(R.id.ly_login).getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { Rect r &#x3D; new Rect();&#x2F;&#x2F;获取当前界面可视部分 OpenCunGuanActivity.this.getWindow().getDecorView().getWindowVisibleDisplayFrame(r);&#x2F;&#x2F;获取屏幕的高度 int screenHeight &#x3D; OpenCunGuanActivity.this.getWindow().getDecorView().getRootView().getHeight();&#x2F;&#x2F;此处就是用来获取键盘的高度的， 在键盘没有弹出的时候 此高度为0键盘弹出的时候为一个正数 int heightDifference &#x3D; screenHeight - r.bottom;CMLog.i(“info”,”软键盘高度:”+ heightDifference +” 屏幕高度”+ screenHeight +” 可视区域高度：”+ r.bottom+” marginTop”+ marginTop);&#x2F;&#x2F; 在xml中设置hiddenView的高度，会导致部分界面超过一些低像素高度小的手机，已进入界面就可以滑动 if (r.bottom&lt; screenHeight) { originalParams.height&#x3D; heightDifference + marginTop *3&#x2F;5;hiddenView.setLayoutParams(originalParams);} else { originalParams.height&#x3D;0;hiddenView.setLayoutParams(originalParams);mSvContent.scrollTo(0, marginTop);} } }); 转自：http://m.blog.csdn.net/u012764110/article/details/52223804","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/DeBug调试/","text":"android调试debug快捷键 \\1. 【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。 \\2. 【F11】：调试最后一次执行的程序。 \\3. 【Ctrl+F11】：运行最后一次执行的程序。 \\4. 【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。 \\5. 【F6】：单步执行程序。 \\6. 【F7】：执行完方法，返回到调用此方法的后一条语句。 \\7. 【F8】：继续执行，到下一个断点或程序结束。 android studio大体为我们提供了6个功能区：1、单步调试区 2、断点管理区 3、求值表达式 4、线程帧栈区 5、对象变量区 6、变量观察区 下面我们分别对这6个区域进行介绍 一、单步调试区 该区提供了调试的主要操作，主要有：Step over、step into、force step into、step out、drop frame。 1、Show Execution Point 点击该按钮,光标将定位到当前正在调试的位置. 2、Stem Over （进入下一行，不会进入方法内部） 单步跳过，点击该按钮将导致程序向下执行一行。如果当前行是一个方法调用，此行调用的方法被执行完毕后再到下一行。（注意不会进入方法内部） 3、Step Into （进入下一行，进入方法内部或者进入底层源码） 单步跳入，执行该操作将导致程序向下执行一行。如果该行有自定义的方法，则进入该方法内部继续执行，需要注意如果是类库中的方法，则不会进入方法内部。 4、Force Step Into （手动进入方法内部，或者源码内部） 强制单步跳入，和step into功能类似，主要区别在于：如果当前行有任何方法，则不管该方法是我们自行定义还是类库提供的，都能跳入到方法内部继续执行 5、Drop Frame 中断执行,并返回到方法执行的初始点,在这个过程中该方法对应的栈帧会从栈中移除.换言之,如果该方法是被调用的,则返回到当前方法被调用处，并且所有上下文变量的值也恢复到该方法未执行时的状态。 6、Force Run to Cursor 很好用的一个功能，可以忽略所有的断点，跳转到当前光标所在的位置调试；假如我们现在在第8行有断点，第10行有断点，目前程序停留在第8行断点上，我们将光标定位到第9行，单击该按钮，程序将跑到第9行； 7、Evaluate expression 点击该按钮会在当前调试的语句处嵌入一个交互式解释器，在该解释器中，你可以执行任何你想要执行的表达式进行求值操作。假如我们当前断点处有一个result的返回值；我们单击该按钮会弹出一个对话框，在该对话框中我们可以对该result进行各种表达式操作； 二、断点管理区 1、Return 点击该按钮会停止目前的应用,并且重新启动.换言之,就是你想要重新调试时,可以使用该操作,嗯,就是重新来过的意思. 2、Resume Program 跳转到下一个断点处，可以理解为下一个断点；如果没有断点，则运行结束； 3、Stop 停止调试；结束运行； 4、View BreakPoints 单击该按钮将会进入断点管理页面，在这里你可以查看所有断点,管理或者配置断点的行为,如:删除，修改属性信息等； 5、Mute BreakPoints 该按钮用来禁用&#x2F;启动所有断点，假如我们在某个断点处得到了我们想要的结果，并不想看其他后续断点可以点击该按钮禁用所有断点，然后程序会正常执行结束； 三、变量观察区 我们在调试的时候，希望看某个变量的值，所以我们只需要简单设置一下就可以在变量观察区看到该变量的值，如下所示 这里有一个技巧，如果我们在调试过程中，突然想要看看这个变量换一个值后的运行结果；可以在调试的过程中修改该变量的值，具体操作如下： 如上图所示，右击变量num2选择set value可以弹出对话框重新设置num2的值，如下所示 可以看出num2的值原先为10，我们修改为50，回车即可生效； 运行结果发生变化； 上面已经介绍了单点调试、变量管理和变量观察三个区域，接下来我们根据断点的分类来介绍其他区域； 断点的分类 断点是调试器的功能之一，可以让程序暂停在需要的地方，帮助我们进行分析程序的运行过程。 在Android Studio中，断点又被以下五类： 条件断点 日志断点 异常断点 方法断点 属性断点 1、条件断点所谓的条件断点就是在特定条件发生的断点，也就是，我们可将某个断点设置为只对某种事件感兴趣，最典型的应用就是在列表循环中，我们希望在某特定的元素出现时暂停程序运行。假如我们有一个数组里面有1、2、3、4、5五个值，我们想在值等于3的时候停下来，可以设置条件断点； 右击断点，在弹出的对话框中设置相应的条件即可，我们运行一下看下效果 可以看到在num&#x3D;&#x3D;3的时候，程序停了下来； 2、日志断点很多时候我们调试的时候更多的是打印日志定位异常代码，缩小范围之后再使用断点解决问题；所以经常做的事情就是在代码里面添加日志信息，输出函数参数，返回信息，输出我们感兴趣的变量信息等。但是这样做的问题在于我们需要重新编译运行程序，并且添加了很多无谓的代码且不好管理，这个时候我们可以使用日志断点；该类型的断点不会使程序停下来，而是在输出我们要它输出的日志信息，然后继续执行。 举例说明： 同样是右击断点，在上图的对话框中进行设置我们来看一下运行效果： 是不是比你在代码中添加输出语句方便多了。 3、异常断点在有些情况下，我们只对某些特定的异常感兴趣，或者我们只对异常感兴趣；我们希望只要程序发生异常程序就能断下来；这好像保存现场一样，这样就会留下的线索比较多，可以使我们快速的找到问题得根源； 举例说明，首先我们添加一个异常断点，单击 然后在弹出的对话框中进行如下设置 假如我们只关心空指针异常可以进行如下设置 选中空指针异常即可，我们人为设置一个空指针异常来看下运行效果： 图中的bt_ride是一个空值的Button，可以看到，当程序发生空指针异常后会将光标直接定位的发生异常的位置； 4、方法断点传统的调试方式是以行为单位的，所谓单步调试；但是很多时候我们关心的是某个函数的参数，返回值；（回想一下我们使用日志的时候打印的最多的信息难道不是函数的参数和返回值吗？）使用方法断点，我们可以在函数级别进行调试；如果经常跳进跳出函数或者只对某个函数的参数感兴趣，这种类型的断点非常实用。具体使用方法有两种方式；最简单的是在你感兴趣的方法头那一行打上断点，这时候你会发现断点图标有点不一样，这就是方法断点了，如下图： 5、Field WatchPoint 有没有这样一种场景：你发现某个值莫名其妙滴不知道什么时候被谁给修改了，罪魁祸首是谁？那么我们怎么揪出这个修改我们值的捣蛋鬼呢？那就是这个 Field WatchPoint的功能了；使用它我们可以在某个Field被访问或者修改的时候让程序断下来；完美解决这个问题。我们可以直接在这个变量旁边单击就可以添加Field WatchPoint 我们可以右击从弹出的菜单中设置默认该变量被修改的时候断下来，也可以设置每次访问该值都断下来； 转自链接：https://www.jianshu.com/p/9fbf316582e3","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android图片手势控件/","text":"效果图： Github链接：https://github.com/boycy815/PinchImageView使用： 1：自定义控件通过java代码：PinchImageView imageView &#x3D;new PinchImageView(this);获得image对象， 2：直接在xml中调用下面的类，自定义控件的用法； 工具类：package com.lzyi.tpm.utils; import android.animation.ValueAnimator; import android.content.Context; import android.graphics.Canvas; import android.graphics.Matrix; import android.graphics.PointF; import android.graphics.RectF; import android.util.AttributeSet; import android.view.GestureDetector; import android.view.MotionEvent; import android.widget.ImageView; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; &#x2F;** * 手势图片控件 * @author clifford *&#x2F; public class PinchImageViewextends ImageView { &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;配置参数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 图片缩放动画时间 *&#x2F; public static final int SCALE_ANIMATOR_DURATION &#x3D;200; &#x2F;** * 惯性动画衰减参数 *&#x2F; public static final float FLING_DAMPING_FACTOR &#x3D;0.9f; &#x2F;** * 图片最大放大比例 *&#x2F; private static final float MAX_SCALE &#x3D;4f; &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;监听器&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 外界点击事件 * @see #setOnClickListener(OnClickListener) *&#x2F; private OnClickListenermOnClickListener; &#x2F;** * 外界长按事件 * @see #setOnLongClickListener(OnLongClickListener) *&#x2F; private OnLongClickListenermOnLongClickListener; @Override public void setOnClickListener(OnClickListener l) { &#x2F;&#x2F;默认的click会在任何点击情况下都会触发，所以搞成自己的 ​ mOnClickListener &#x3D; l; } @Override public void setOnLongClickListener(OnLongClickListener l) { &#x2F;&#x2F;默认的long click会在任何长按情况下都会触发，所以搞成自己的 ​ mOnLongClickListener &#x3D; l; } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;公共状态获取&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 手势状态：自由状态 * @see #getPinchMode() *&#x2F; public static final int PINCH_MODE_FREE &#x3D;0; &#x2F;** * 手势状态：单指滚动状态 * @see #getPinchMode() *&#x2F; public static final int PINCH_MODE_SCROLL &#x3D;1; &#x2F;** * 手势状态：双指缩放状态 * @see #getPinchMode() *&#x2F; public static final int PINCH_MODE_SCALE &#x3D;2; &#x2F;** * 外层变换矩阵，如果是单位矩阵，那么图片是fit center状态 * @see #getOuterMatrix(Matrix) * @see #outerMatrixTo(Matrix, long) *&#x2F; private MatrixmOuterMatrix &#x3D;new Matrix(); &#x2F;** * 矩形遮罩 * @see #getMask() * @see #zoomMaskTo(RectF, long) *&#x2F; private RectFmMask; &#x2F;** * 当前手势状态 * @see #getPinchMode() * @see #PINCH_MODE_FREE * @see #PINCH_MODE_SCROLL * @see #PINCH_MODE_SCALE *&#x2F; private int mPinchMode &#x3D;PINCH_MODE_FREE; &#x2F;** * 获取外部变换矩阵. * 外部变换矩阵记录了图片手势操作的最终结果,是相对于图片fit center状态的变换. * 默认值为单位矩阵,此时图片为fit center状态. * @param matrix 用于填充结果的对象 * @return 如果传了matrix参数则将matrix填充后返回,否则new一个填充返回 *&#x2F; public MatrixgetOuterMatrix(Matrix matrix) { if (matrix &#x3D;&#x3D;null) { matrix &#x3D;new Matrix(mOuterMatrix); ​ }else { matrix.set(mOuterMatrix); ​ } return matrix; } &#x2F;** * 获取内部变换矩阵. * 内部变换矩阵是原图到fit center状态的变换,当原图尺寸变化或者控件大小变化都会发生改变 * 当尚未布局或者原图不存在时,其值无意义.所以在调用前需要确保前置条件有效,否则将影响计算结果. * @param matrix 用于填充结果的对象 * @return 如果传了matrix参数则将matrix填充后返回,否则new一个填充返回 *&#x2F; public MatrixgetInnerMatrix(Matrix matrix) { if (matrix &#x3D;&#x3D;null) { matrix &#x3D;new Matrix(); ​ }else { matrix.reset(); ​ } if (isReady()) { &#x2F;&#x2F;原图大小 ​ RectF tempSrc &#x3D; MathUtils.rectFTake(0, 0, getDrawable().getIntrinsicWidth(), getDrawable().getIntrinsicHeight()); ​ &#x2F;&#x2F;控件大小 ​ RectF tempDst &#x3D; MathUtils.rectFTake(0, 0, getWidth(), getHeight()); ​ &#x2F;&#x2F;计算fit center矩阵 ​ matrix.setRectToRect(tempSrc, tempDst, Matrix.ScaleToFit.CENTER); ​ &#x2F;&#x2F;释放临时对象 ​ MathUtils.rectFGiven(tempDst); ​ MathUtils.rectFGiven(tempSrc); ​ } return matrix; } &#x2F;** * 获取图片总变换矩阵. * 总变换矩阵为内部变换矩阵x外部变换矩阵,决定了原图到所见最终状态的变换 * 当尚未布局或者原图不存在时,其值无意义.所以在调用前需要确保前置条件有效,否则将影响计算结果. * @param matrix 用于填充结果的对象 * @return 如果传了matrix参数则将matrix填充后返回,否则new一个填充返回 * @see #getOuterMatrix(Matrix) * @see #getInnerMatrix(Matrix) *&#x2F; public MatrixgetCurrentImageMatrix(Matrix matrix) { &#x2F;&#x2F;获取内部变换矩阵 ​ matrix &#x3D; getInnerMatrix(matrix); ​ &#x2F;&#x2F;乘上外部变换矩阵 ​ matrix.postConcat(mOuterMatrix); ​ return matrix; } &#x2F;** * 获取当前变换后的图片位置和尺寸 * 当尚未布局或者原图不存在时,其值无意义.所以在调用前需要确保前置条件有效,否则将影响计算结果. * @param rectF 用于填充结果的对象 * @return 如果传了rectF参数则将rectF填充后返回,否则new一个填充返回 * @see #getCurrentImageMatrix(Matrix) *&#x2F; public RectFgetImageBound(RectF rectF) { if (rectF &#x3D;&#x3D;null) { rectF &#x3D;new RectF(); ​ }else { rectF.setEmpty(); ​ } if (!isReady()) { return rectF; ​ }else { &#x2F;&#x2F;申请一个空matrix ​ Matrix matrix &#x3D; MathUtils.matrixTake(); ​ &#x2F;&#x2F;获取当前总变换矩阵 ​ getCurrentImageMatrix(matrix); ​ &#x2F;&#x2F;对原图矩形进行变换得到当前显示矩形 ​ rectF.set(0, 0, getDrawable().getIntrinsicWidth(), getDrawable().getIntrinsicHeight()); ​ matrix.mapRect(rectF); ​ &#x2F;&#x2F;释放临时matrix ​ MathUtils.matrixGiven(matrix); ​ return rectF; ​ } } &#x2F;** * 获取当前设置的mask * @return 返回当前的mask对象副本,如果当前没有设置mask则返回null *&#x2F; public RectFgetMask() { if (mMask !&#x3D;null) { return new RectF(mMask); ​ }else { return null; ​ } } &#x2F;** * 获取当前手势状态 * @see #PINCH_MODE_FREE * @see #PINCH_MODE_SCROLL * @see #PINCH_MODE_SCALE *&#x2F; public int getPinchMode() { return mPinchMode; } &#x2F;** * 与ViewPager结合的时候使用 * @param direction * @return *&#x2F; @Override public boolean canScrollHorizontally(int direction) { if (mPinchMode &#x3D;&#x3D; PinchImageView.PINCH_MODE_SCALE) { return true; ​ } RectF bound &#x3D; getImageBound(null); ​ if (bound &#x3D;&#x3D;null) { return false; ​ } if (bound.isEmpty()) { return false; ​ } if (direction &gt;0) { return bound.right &gt; getWidth(); ​ }else { return bound.left &lt;0; ​ } } &#x2F;** * 与ViewPager结合的时候使用 * @param direction * @return *&#x2F; @Override public boolean canScrollVertically(int direction) { if (mPinchMode &#x3D;&#x3D; PinchImageView.PINCH_MODE_SCALE) { return true; ​ } RectF bound &#x3D; getImageBound(null); ​ if (bound &#x3D;&#x3D;null) { return false; ​ } if (bound.isEmpty()) { return false; ​ } if (direction &gt;0) { return bound.bottom &gt; getHeight(); ​ }else { return bound.top &lt;0; ​ } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;公共状态设置&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 执行当前outerMatrix到指定outerMatrix渐变的动画 * 调用此方法会停止正在进行中的手势以及手势动画. * 当duration为0时,outerMatrix值会被立即设置而不会启动动画. * @param endMatrix 动画目标矩阵 * @param duration 动画持续时间 * @see #getOuterMatrix(Matrix) *&#x2F; public void outerMatrixTo(Matrix endMatrix, long duration) { if (endMatrix &#x3D;&#x3D;null) { return; ​ } &#x2F;&#x2F;将手势设置为PINCH_MODE_FREE将停止后续手势的触发 ​ mPinchMode &#x3D;PINCH_MODE_FREE; ​ &#x2F;&#x2F;停止所有正在进行的动画 ​ cancelAllAnimator(); ​ &#x2F;&#x2F;如果时间不合法立即执行结果 ​ if (duration &lt;&#x3D;0) { mOuterMatrix.set(endMatrix); ​ dispatchOuterMatrixChanged(); ​ invalidate(); ​ }else { &#x2F;&#x2F;创建矩阵变化动画 ​ mScaleAnimator &#x3D;new ScaleAnimator(mOuterMatrix, endMatrix, duration); ​ mScaleAnimator.start(); ​ } } &#x2F;** * 执行当前mask到指定mask的变化动画 * 调用此方法不会停止手势以及手势相关动画,但会停止正在进行的mask动画. * 当前mask为null时,则不执行动画立即设置为目标mask. * 当duration为0时,立即将当前mask设置为目标mask,不会执行动画. * @param mask 动画目标mask * @param duration 动画持续时间 * @see #getMask() *&#x2F; public void zoomMaskTo(RectF mask, long duration) { if (mask &#x3D;&#x3D;null) { return; ​ } &#x2F;&#x2F;停止mask动画 ​ if (mMaskAnimator !&#x3D;null) { mMaskAnimator.cancel(); ​ mMaskAnimator &#x3D;null; ​ } &#x2F;&#x2F;如果duration为0或者之前没有设置过mask,不执行动画,立即设置 ​ if (duration &lt;&#x3D;0 ||mMask &#x3D;&#x3D;null) { if (mMask &#x3D;&#x3D;null) { mMask &#x3D;new RectF(); ​ } mMask.set(mask); ​ invalidate(); ​ }else { &#x2F;&#x2F;执行mask动画 ​ mMaskAnimator &#x3D;new MaskAnimator(mMask, mask, duration); ​ mMaskAnimator.start(); ​ } } &#x2F;** * 重置所有状态 * 重置位置到fit center状态,清空mask,停止所有手势,停止所有动画. * 但不清空drawable,以及事件绑定相关数据. *&#x2F; public void reset() { &#x2F;&#x2F;重置位置到fit ​ mOuterMatrix.reset(); ​ dispatchOuterMatrixChanged(); ​ &#x2F;&#x2F;清空mask ​ mMask &#x3D;null; ​ &#x2F;&#x2F;停止所有手势 ​ mPinchMode &#x3D;PINCH_MODE_FREE; ​ mLastMovePoint.set(0, 0); ​ mScaleCenter.set(0, 0); ​ mScaleBase &#x3D;0; ​ &#x2F;&#x2F;停止所有动画 ​ if (mMaskAnimator !&#x3D;null) { mMaskAnimator.cancel(); ​ mMaskAnimator &#x3D;null; ​ } cancelAllAnimator(); ​ &#x2F;&#x2F;重绘 ​ invalidate(); } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;对外广播事件&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 外部矩阵变化事件通知监听器 *&#x2F; public interface OuterMatrixChangedListener { &#x2F;** ​ * 外部矩阵变化回调 ​ * ​ * 外部矩阵的任何变化后都收到此回调. ​ * 外部矩阵变化后,总变化矩阵,图片的展示位置都将发生变化. ​ * @param pinchImageView ​ * ​ * @see #getOuterMatrix(Matrix) ​ * @see #getCurrentImageMatrix(Matrix) ​ * @see #getImageBound(RectF) *&#x2F; ​ void onOuterMatrixChanged(PinchImageView pinchImageView); } &#x2F;** * 所有OuterMatrixChangedListener监听列表 * @see #addOuterMatrixChangedListener(OuterMatrixChangedListener) * @see #removeOuterMatrixChangedListener(OuterMatrixChangedListener) *&#x2F; private ListmOuterMatrixChangedListeners; &#x2F;** * 当mOuterMatrixChangedListeners被锁定不允许修改时,临时将修改写到这个副本中 * @see #mOuterMatrixChangedListeners *&#x2F; private ListmOuterMatrixChangedListenersCopy; &#x2F;** * mOuterMatrixChangedListeners的修改锁定 * 当进入dispatchOuterMatrixChanged方法时,被加1,退出前被减1 * @see #dispatchOuterMatrixChanged() * @see #addOuterMatrixChangedListener(OuterMatrixChangedListener) * @see #removeOuterMatrixChangedListener(OuterMatrixChangedListener) *&#x2F; private int mDispatchOuterMatrixChangedLock; &#x2F;** * 添加外部矩阵变化监听 * @param listener *&#x2F; public void addOuterMatrixChangedListener(OuterMatrixChangedListener listener) { if (listener &#x3D;&#x3D;null) { return; ​ } &#x2F;&#x2F;如果监听列表没有被修改锁定直接将监听添加到监听列表 ​ if (mDispatchOuterMatrixChangedLock &#x3D;&#x3D;0) { if (mOuterMatrixChangedListeners &#x3D;&#x3D;null) { mOuterMatrixChangedListeners &#x3D;new ArrayList(); ​ } mOuterMatrixChangedListeners.add(listener); ​ }else { &#x2F;&#x2F;如果监听列表修改被锁定,那么尝试在监听列表副本上添加 ​ &#x2F;&#x2F;监听列表副本将会在锁定被解除时替换到监听列表里 ​ if (mOuterMatrixChangedListenersCopy &#x3D;&#x3D;null) { if (mOuterMatrixChangedListeners !&#x3D;null) { mOuterMatrixChangedListenersCopy &#x3D;new ArrayList(mOuterMatrixChangedListeners); ​ }else { mOuterMatrixChangedListenersCopy &#x3D;new ArrayList(); ​ } } mOuterMatrixChangedListenersCopy.add(listener); ​ } } &#x2F;** * 删除外部矩阵变化监听 * @param listener *&#x2F; public void removeOuterMatrixChangedListener(OuterMatrixChangedListener listener) { if (listener &#x3D;&#x3D;null) { return; ​ } &#x2F;&#x2F;如果监听列表没有被修改锁定直接在监听列表数据结构上修改 ​ if (mDispatchOuterMatrixChangedLock &#x3D;&#x3D;0) { if (mOuterMatrixChangedListeners !&#x3D;null) { mOuterMatrixChangedListeners.remove(listener); ​ } }else { &#x2F;&#x2F;如果监听列表被修改锁定,那么就在其副本上修改 ​ &#x2F;&#x2F;其副本将会在锁定解除时替换回监听列表 ​ if (mOuterMatrixChangedListenersCopy &#x3D;&#x3D;null) { if (mOuterMatrixChangedListeners !&#x3D;null) { mOuterMatrixChangedListenersCopy &#x3D;new ArrayList(mOuterMatrixChangedListeners); ​ } } if (mOuterMatrixChangedListenersCopy !&#x3D;null) { mOuterMatrixChangedListenersCopy.remove(listener); ​ } } } &#x2F;** * 触发外部矩阵修改事件 * 需要在每次给外部矩阵设置值时都调用此方法. * @see #mOuterMatrix *&#x2F; private void dispatchOuterMatrixChanged() { if (mOuterMatrixChangedListeners &#x3D;&#x3D;null) { return; ​ } &#x2F;&#x2F;增加锁 ​ &#x2F;&#x2F;这里之所以用计数器做锁定是因为可能在锁定期间又间接调用了此方法产生递归 ​ &#x2F;&#x2F;使用boolean无法判断递归结束 ​ mDispatchOuterMatrixChangedLock++; ​ &#x2F;&#x2F;在列表循环过程中不允许修改列表,否则将引发崩溃 ​ for (OuterMatrixChangedListener listener :mOuterMatrixChangedListeners) { listener.onOuterMatrixChanged(this); ​ } &#x2F;&#x2F;减锁 ​ mDispatchOuterMatrixChangedLock–; ​ &#x2F;&#x2F;如果是递归的情况,mDispatchOuterMatrixChangedLock可能大于1,只有减到0才能算列表的锁定解除 ​ if (mDispatchOuterMatrixChangedLock &#x3D;&#x3D;0) { &#x2F;&#x2F;如果期间有修改列表,那么副本将不为null ​ if (mOuterMatrixChangedListenersCopy !&#x3D;null) { &#x2F;&#x2F;将副本替换掉正式的列表 ​ mOuterMatrixChangedListeners &#x3D;mOuterMatrixChangedListenersCopy; ​ &#x2F;&#x2F;清空副本 ​ mOuterMatrixChangedListenersCopy &#x3D;null; ​ } } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;用于重载定制&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 获取图片最大可放大的比例 * 如果放大大于这个比例则不被允许. * 在双手缩放过程中如果图片放大比例大于这个值,手指释放将回弹到这个比例. * 在双击放大过程中不允许放大比例大于这个值. * 覆盖此方法可以定制不同情况使用不同的最大可放大比例. * @return 缩放比例 * @see #scaleEnd() * @see #doubleTap(float, float) *&#x2F; protected float getMaxScale() { return MAX_SCALE; } &#x2F;** * 计算双击之后图片接下来应该被缩放的比例 * 如果值大于getMaxScale或者小于fit center尺寸，则实际使用取边界值. * 通过覆盖此方法可以定制不同的图片被双击时使用不同的放大策略. * @param innerScale 当前内部矩阵的缩放值 * @param outerScale 当前外部矩阵的缩放值 * @return 接下来的缩放比例 * @see #doubleTap(float, float) * @see #getMaxScale() *&#x2F; protected float calculateNextScale(float innerScale, float outerScale) { float currentScale &#x3D; innerScale * outerScale; ​ if (currentScale return MAX_SCALE; ​ }else { return innerScale; ​ } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;初始化&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; public PinchImageView(Context context) { super(context); ​ initView(); } public PinchImageView(Context context, AttributeSet attrs) { super(context, attrs); ​ initView(); } public PinchImageView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); ​ initView(); } private void initView() { &#x2F;&#x2F;强制设置图片scaleType为matrix ​ super.setScaleType(ScaleType.MATRIX); } &#x2F;&#x2F;不允许设置scaleType，只能用内部设置的matrix @Override public void setScaleType(ScaleType scaleType) {} &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;绘制&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; @Override protected void onDraw(Canvas canvas) { &#x2F;&#x2F;在绘制前设置变换矩阵 ​ if (isReady()) { Matrix matrix &#x3D; MathUtils.matrixTake(); ​ setImageMatrix(getCurrentImageMatrix(matrix)); ​ MathUtils.matrixGiven(matrix); ​ } &#x2F;&#x2F;对图像做遮罩处理 ​ if (mMask !&#x3D;null) { canvas.save(); ​ canvas.clipRect(mMask); ​ super.onDraw(canvas); ​ canvas.restore(); ​ }else { super.onDraw(canvas); ​ } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;有效性判断&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 判断当前情况是否能执行手势相关计算 * 包括:是否有图片,图片是否有尺寸,控件是否有尺寸. * @return 是否能执行手势相关计算 *&#x2F; private boolean isReady() { return getDrawable() !&#x3D;null &amp;&amp; getDrawable().getIntrinsicWidth() &gt;0 &amp;&amp; getDrawable().getIntrinsicHeight() &gt;0 ​ &amp;&amp; getWidth() &gt;0 &amp;&amp; getHeight() &gt;0; } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;mask动画处理&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * mask修改的动画 * 和图片的动画相互独立. * @see #zoomMaskTo(RectF, long) *&#x2F; private MaskAnimatormMaskAnimator; &#x2F;** * mask变换动画 * 将mask从一个rect动画到另外一个rect *&#x2F; private class MaskAnimatorextends ValueAnimatorimplements ValueAnimator.AnimatorUpdateListener { &#x2F;** ​ * 开始mask *&#x2F; ​ private float[]mStart &#x3D;new float[4]; ​ &#x2F;** ​ * 结束mask *&#x2F; ​ private float[]mEnd &#x3D;new float[4]; ​ &#x2F;** ​ * 中间结果mask *&#x2F; ​ private float[]mResult &#x3D;new float[4]; ​ &#x2F;** ​ * 创建mask变换动画 ​ * ​ * @param start 动画起始状态 ​ * @param end 动画终点状态 ​ * @param duration 动画持续时间 ​ *&#x2F; ​ public MaskAnimator(RectF start, RectF end, long duration) { super(); ​ setFloatValues(0, 1f); ​ setDuration(duration); ​ addUpdateListener(this); ​ &#x2F;&#x2F;将起点终点拷贝到数组方便计算 ​ mStart[0] &#x3D; start.left; ​ mStart[1] &#x3D; start.top; ​ mStart[2] &#x3D; start.right; ​ mStart[3] &#x3D; start.bottom; ​ mEnd[0] &#x3D; end.left; ​ mEnd[1] &#x3D; end.top; ​ mEnd[2] &#x3D; end.right; ​ mEnd[3] &#x3D; end.bottom; ​ } @Override ​ public void onAnimationUpdate(ValueAnimator animation) { &#x2F;&#x2F;获取动画进度,0-1范围 ​ float value &#x3D; (Float) animation.getAnimatedValue(); ​ &#x2F;&#x2F;根据进度对起点终点之间做插值 ​ for (int i &#x3D;0; i &lt;4; i++) { mResult[i] &#x3D;mStart[i] + (mEnd[i] -mStart[i]) * value; ​ } &#x2F;&#x2F;期间mask有可能被置空了,所以判断一下 ​ if (mMask &#x3D;&#x3D;null) { mMask &#x3D;new RectF(); ​ } &#x2F;&#x2F;设置新的mask并绘制 ​ mMask.set(mResult[0], mResult[1], mResult[2], mResult[3]); ​ invalidate(); ​ } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;手势动画处理&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 在单指模式下: * 记录上一次手指的位置,用于计算新的位置和上一次位置的差值. * 双指模式下: * 记录两个手指的中点,作为和mScaleCenter绑定的点. * 这个绑定可以保证mScaleCenter无论如何都会跟随这个中点. * @see #mScaleCenter * @see #scale(PointF, float, float, PointF) * @see #scaleEnd() *&#x2F; private PointFmLastMovePoint &#x3D;new PointF(); &#x2F;** * 缩放模式下图片的缩放中点. * 为其指代的点经过innerMatrix变换之后的值. * 其指代的点在手势过程中始终跟随mLastMovePoint. * 通过双指缩放时,其为缩放中心点. * @see #saveScaleContext(float, float, float, float) * @see #mLastMovePoint * @see #scale(PointF, float, float, PointF) *&#x2F; private PointFmScaleCenter &#x3D;new PointF(); &#x2F;** * 缩放模式下的基础缩放比例 * 为外层缩放值除以开始缩放时两指距离. * 其值乘上最新的两指之间距离为最新的图片缩放比例. * @see #saveScaleContext(float, float, float, float) * @see #scale(PointF, float, float, PointF) *&#x2F; private float mScaleBase &#x3D;0; &#x2F;** * 图片缩放动画 * 缩放模式把图片的位置大小超出限制之后触发. * 双击图片放大或缩小时触发. * 手动调用outerMatrixTo触发. * @see #scaleEnd() * @see #doubleTap(float, float) * @see #outerMatrixTo(Matrix, long) *&#x2F; private ScaleAnimatormScaleAnimator; &#x2F;** * 滑动产生的惯性动画 * @see #fling(float, float) *&#x2F; private FlingAnimatormFlingAnimator; &#x2F;** * 常用手势处理 * 在onTouchEvent末尾被执行. *&#x2F; private GestureDetectormGestureDetector &#x3D;new GestureDetector(PinchImageView.this.getContext(), new GestureDetector.SimpleOnGestureListener() { public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { &#x2F;&#x2F;只有在单指模式结束之后才允许执行fling ​ if (mPinchMode &#x3D;&#x3D;PINCH_MODE_FREE &amp;&amp; !(mScaleAnimator !&#x3D;null &amp;&amp;mScaleAnimator.isRunning())) { fling(velocityX, velocityY); ​ } return true; ​ } public void onLongPress(MotionEvent e) { &#x2F;&#x2F;触发长按 ​ if (mOnLongClickListener !&#x3D;null) { mOnLongClickListener.onLongClick(PinchImageView.this); ​ } } public boolean onDoubleTap(MotionEvent e) { &#x2F;&#x2F;当手指快速第二次按下触发,此时必须是单指模式才允许执行doubleTap ​ if (mPinchMode &#x3D;&#x3D;PINCH_MODE_SCROLL &amp;&amp; !(mScaleAnimator !&#x3D;null &amp;&amp;mScaleAnimator.isRunning())) { doubleTap(e.getX(), e.getY()); ​ } return true; ​ } public boolean onSingleTapConfirmed(MotionEvent e) { &#x2F;&#x2F;触发点击 ​ if (mOnClickListener !&#x3D;null) { mOnClickListener.onClick(PinchImageView.this); ​ } return true; ​ } }); @Override public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); ​ int action &#x3D; event.getAction() &amp; MotionEvent.ACTION_MASK; ​ &#x2F;&#x2F;最后一个点抬起或者取消，结束所有模式 ​ if(action &#x3D;&#x3D; MotionEvent.ACTION_UP || action &#x3D;&#x3D; MotionEvent.ACTION_CANCEL) { &#x2F;&#x2F;如果之前是缩放模式,还需要触发一下缩放结束动画 ​ if (mPinchMode &#x3D;&#x3D;PINCH_MODE_SCALE) { scaleEnd(); ​ } mPinchMode &#x3D;PINCH_MODE_FREE; ​ }else if (action &#x3D;&#x3D; MotionEvent.ACTION_POINTER_UP) { &#x2F;&#x2F;多个手指情况下抬起一个手指,此时需要是缩放模式才触发 ​ if (mPinchMode &#x3D;&#x3D;PINCH_MODE_SCALE) { &#x2F;&#x2F;抬起的点如果大于2，那么缩放模式还有效，但是有可能初始点变了，重新测量初始点 ​ if (event.getPointerCount() &gt;2) { &#x2F;&#x2F;如果还没结束缩放模式，但是第一个点抬起了，那么让第二个点和第三个点作为缩放控制点 ​ if (event.getAction() &gt;&gt;8 &#x3D;&#x3D;0) { saveScaleContext(event.getX(1), event.getY(1), event.getX(2), event.getY(2)); ​ &#x2F;&#x2F;如果还没结束缩放模式，但是第二个点抬起了，那么让第一个点和第三个点作为缩放控制点 ​ }else if (event.getAction() &gt;&gt;8 &#x3D;&#x3D;1) { saveScaleContext(event.getX(0), event.getY(0), event.getX(2), event.getY(2)); ​ } } &#x2F;&#x2F;如果抬起的点等于2,那么此时只剩下一个点,也不允许进入单指模式,因为此时可能图片没有在正确的位置上 ​ } &#x2F;&#x2F;第一个点按下，开启滚动模式，记录开始滚动的点 ​ }else if (action &#x3D;&#x3D; MotionEvent.ACTION_DOWN) { &#x2F;&#x2F;在矩阵动画过程中不允许启动滚动模式 ​ if (!(mScaleAnimator !&#x3D;null &amp;&amp;mScaleAnimator.isRunning())) { &#x2F;&#x2F;停止所有动画 ​ cancelAllAnimator(); ​ &#x2F;&#x2F;切换到滚动模式 ​ mPinchMode &#x3D;PINCH_MODE_SCROLL; ​ &#x2F;&#x2F;保存触发点用于move计算差值 ​ mLastMovePoint.set(event.getX(), event.getY()); ​ } &#x2F;&#x2F;非第一个点按下，关闭滚动模式，开启缩放模式，记录缩放模式的一些初始数据 ​ }else if (action &#x3D;&#x3D; MotionEvent.ACTION_POINTER_DOWN) { &#x2F;&#x2F;停止所有动画 ​ cancelAllAnimator(); ​ &#x2F;&#x2F;切换到缩放模式 ​ mPinchMode &#x3D;PINCH_MODE_SCALE; ​ &#x2F;&#x2F;保存缩放的两个手指 ​ saveScaleContext(event.getX(0), event.getY(0), event.getX(1), event.getY(1)); ​ }else if (action &#x3D;&#x3D; MotionEvent.ACTION_MOVE) { if (!(mScaleAnimator !&#x3D;null &amp;&amp;mScaleAnimator.isRunning())) { &#x2F;&#x2F;在滚动模式下移动 ​ if (mPinchMode &#x3D;&#x3D;PINCH_MODE_SCROLL) { &#x2F;&#x2F;每次移动产生一个差值累积到图片位置上 ​ scrollBy(event.getX() -mLastMovePoint.x, event.getY() -mLastMovePoint.y); ​ &#x2F;&#x2F;记录新的移动点 ​ mLastMovePoint.set(event.getX(), event.getY()); ​ &#x2F;&#x2F;在缩放模式下移动 ​ }else if (mPinchMode &#x3D;&#x3D;PINCH_MODE_SCALE &amp;&amp; event.getPointerCount() &gt;1) { &#x2F;&#x2F;两个缩放点间的距离 ​ float distance &#x3D; MathUtils.getDistance(event.getX(0), event.getY(0), event.getX(1), event.getY(1)); ​ &#x2F;&#x2F;保存缩放点中点 ​ float[] lineCenter &#x3D; MathUtils.getCenterPoint(event.getX(0), event.getY(0), event.getX(1), event.getY(1)); ​ mLastMovePoint.set(lineCenter[0], lineCenter[1]); ​ &#x2F;&#x2F;处理缩放 ​ scale(mScaleCenter, mScaleBase, distance, mLastMovePoint); ​ } } } &#x2F;&#x2F;无论如何都处理各种外部手势 ​ mGestureDetector.onTouchEvent(event); return true; } &#x2F;** * 让图片移动一段距离 * 不能移动超过可移动范围,超过了就到可移动范围边界为止. * @param xDiff 移动距离 * @param yDiff 移动距离 * @return 是否改变了位置 *&#x2F; private boolean scrollBy(float xDiff, float yDiff) { if (!isReady()) { return false; ​ } &#x2F;&#x2F;原图方框 ​ RectF bound &#x3D; MathUtils.rectFTake(); ​ getImageBound(bound); ​ &#x2F;&#x2F;控件大小 ​ float displayWidth &#x3D; getWidth(); ​ float displayHeight &#x3D; getHeight(); ​ &#x2F;&#x2F;如果当前图片宽度小于控件宽度，则不能移动 ​ if (bound.right - bound.left &lt; displayWidth) { xDiff &#x3D;0; ​ &#x2F;&#x2F;如果图片左边在移动后超出控件左边 ​ }else if (bound.left + xDiff &gt;0) { &#x2F;&#x2F;如果在移动之前是没超出的，计算应该移动的距离 ​ if (bound.left &lt;0) { xDiff &#x3D; -bound.left; ​ &#x2F;&#x2F;否则无法移动 ​ }else { xDiff &#x3D;0; ​ } &#x2F;&#x2F;如果图片右边在移动后超出控件右边 ​ }else if (bound.right + xDiff &lt; displayWidth) { &#x2F;&#x2F;如果在移动之前是没超出的，计算应该移动的距离 ​ if (bound.right &gt; displayWidth) { xDiff &#x3D; displayWidth - bound.right; ​ &#x2F;&#x2F;否则无法移动 ​ }else { xDiff &#x3D;0; ​ } } &#x2F;&#x2F;以下同理 ​ if (bound.bottom - bound.top &lt; displayHeight) { yDiff &#x3D;0; ​ }else if (bound.top + yDiff &gt;0) { if (bound.top &lt;0) { yDiff &#x3D; -bound.top; ​ }else { yDiff &#x3D;0; ​ } }else if (bound.bottom + yDiff &lt; displayHeight) { if (bound.bottom &gt; displayHeight) { yDiff &#x3D; displayHeight - bound.bottom; ​ }else { yDiff &#x3D;0; ​ } } MathUtils.rectFGiven(bound); ​ &#x2F;&#x2F;应用移动变换 ​ mOuterMatrix.postTranslate(xDiff, yDiff); ​ dispatchOuterMatrixChanged(); ​ &#x2F;&#x2F;触发重绘 ​ invalidate(); ​ &#x2F;&#x2F;检查是否有变化 ​ if (xDiff !&#x3D;0 || yDiff !&#x3D;0) { return true; ​ }else { return false; ​ } } &#x2F;** * 记录缩放前的一些信息 * 保存基础缩放值. * 保存图片缩放中点. * @param x1 缩放第一个手指 * @param y1 缩放第一个手指 * @param x2 缩放第二个手指 * @param y2 缩放第二个手指 *&#x2F; private void saveScaleContext(float x1, float y1, float x2, float y2) { &#x2F;&#x2F;记录基础缩放值,其中图片缩放比例按照x方向来计算 ​ &#x2F;&#x2F;理论上图片应该是等比的,x和y方向比例相同 ​ &#x2F;&#x2F;但是有可能外部设定了不规范的值. ​ &#x2F;&#x2F;但是后续的scale操作会将xy不等的缩放值纠正,改成和x方向相同 ​ mScaleBase &#x3D; MathUtils.getMatrixScale(mOuterMatrix)[0] &#x2F; MathUtils.getDistance(x1, y1, x2, y2); ​ &#x2F;&#x2F;两手指的中点在屏幕上落在了图片的某个点上,图片上的这个点在经过总矩阵变换后和手指中点相同 ​ &#x2F;&#x2F;现在我们需要得到图片上这个点在图片是fit center状态下在屏幕上的位置 ​ &#x2F;&#x2F;因为后续的计算都是基于图片是fit center状态下进行变换 ​ &#x2F;&#x2F;所以需要把两手指中点除以外层变换矩阵得到mScaleCenter ​ float[] center &#x3D; MathUtils.inverseMatrixPoint(MathUtils.getCenterPoint(x1, y1, x2, y2), mOuterMatrix); ​ mScaleCenter.set(center[0], center[1]); } &#x2F;** * 对图片按照一些手势信息进行缩放 * @param scaleCenter mScaleCenter * @param scaleBase mScaleBase * @param distance 手指两点之间距离 * @param lineCenter 手指两点之间中点 * @see #mScaleCenter * @see #mScaleBase *&#x2F; private void scale(PointF scaleCenter, float scaleBase, float distance, PointF lineCenter) { if (!isReady()) { return; ​ } &#x2F;&#x2F;计算图片从fit center状态到目标状态的缩放比例 ​ float scale &#x3D; scaleBase * distance; ​ Matrix matrix &#x3D; MathUtils.matrixTake(); ​ &#x2F;&#x2F;按照图片缩放中心缩放，并且让缩放中心在缩放点中点上 ​ matrix.postScale(scale, scale, scaleCenter.x, scaleCenter.y); ​ &#x2F;&#x2F;让图片的缩放中点跟随手指缩放中点 ​ matrix.postTranslate(lineCenter.x - scaleCenter.x, lineCenter.y - scaleCenter.y); ​ &#x2F;&#x2F;应用变换 ​ mOuterMatrix.set(matrix); ​ MathUtils.matrixGiven(matrix); ​ dispatchOuterMatrixChanged(); ​ &#x2F;&#x2F;重绘 ​ invalidate(); } &#x2F;** * 双击后放大或者缩小 * 将图片缩放比例缩放到nextScale指定的值. * 但nextScale值不能大于最大缩放值不能小于fit center情况下的缩放值. * 将双击的点尽量移动到控件中心. * @param x 双击的点 * @param y 双击的点 * @see #calculateNextScale(float, float) * @see #getMaxScale() *&#x2F; private void doubleTap(float x, float y) { if (!isReady()) { return; ​ } &#x2F;&#x2F;获取第一层变换矩阵 ​ Matrix innerMatrix &#x3D; MathUtils.matrixTake(); ​ getInnerMatrix(innerMatrix); ​ &#x2F;&#x2F;当前总的缩放比例 ​ float innerScale &#x3D; MathUtils.getMatrixScale(innerMatrix)[0]; ​ float outerScale &#x3D; MathUtils.getMatrixScale(mOuterMatrix)[0]; ​ float currentScale &#x3D; innerScale * outerScale; ​ &#x2F;&#x2F;控件大小 ​ float displayWidth &#x3D; getWidth(); ​ float displayHeight &#x3D; getHeight(); ​ &#x2F;&#x2F;最大放大大小 ​ float maxScale &#x3D; getMaxScale(); ​ &#x2F;&#x2F;接下来要放大的大小 ​ float nextScale &#x3D; calculateNextScale(innerScale, outerScale); ​ &#x2F;&#x2F;如果接下来放大大于最大值或者小于fit center值，则取边界 ​ if (nextScale &gt; maxScale) { nextScale &#x3D; maxScale; ​ } if (nextScale &lt; innerScale) { nextScale &#x3D; innerScale; ​ } &#x2F;&#x2F;开始计算缩放动画的结果矩阵 ​ Matrix animEnd &#x3D; MathUtils.matrixTake(mOuterMatrix); ​ &#x2F;&#x2F;计算还需缩放的倍数 ​ animEnd.postScale(nextScale &#x2F; currentScale, nextScale &#x2F; currentScale, x, y); ​ &#x2F;&#x2F;将放大点移动到控件中心 ​ animEnd.postTranslate(displayWidth &#x2F;2f - x, displayHeight &#x2F;2f - y); ​ &#x2F;&#x2F;得到放大之后的图片方框 ​ Matrix testMatrix &#x3D; MathUtils.matrixTake(innerMatrix); ​ testMatrix.postConcat(animEnd); ​ RectF testBound &#x3D; MathUtils.rectFTake(0, 0, getDrawable().getIntrinsicWidth(), getDrawable().getIntrinsicHeight()); ​ testMatrix.mapRect(testBound); ​ &#x2F;&#x2F;修正位置 ​ float postX &#x3D;0; ​ float postY &#x3D;0; ​ if (testBound.right - testBound.left &lt; displayWidth) { postX &#x3D; displayWidth &#x2F;2f - (testBound.right + testBound.left) &#x2F;2f; ​ }else if (testBound.left &gt;0) { postX &#x3D; -testBound.left; ​ }else if (testBound.right &lt; displayWidth) { postX &#x3D; displayWidth - testBound.right; ​ } if (testBound.bottom - testBound.top &lt; displayHeight) { postY &#x3D; displayHeight &#x2F;2f - (testBound.bottom + testBound.top) &#x2F;2f; ​ }else if (testBound.top &gt;0) { postY &#x3D; -testBound.top; ​ }else if (testBound.bottom &lt; displayHeight) { postY &#x3D; displayHeight - testBound.bottom; ​ } &#x2F;&#x2F;应用修正位置 ​ animEnd.postTranslate(postX, postY); ​ &#x2F;&#x2F;清理当前可能正在执行的动画 ​ cancelAllAnimator(); ​ &#x2F;&#x2F;启动矩阵动画 ​ mScaleAnimator &#x3D;new ScaleAnimator(mOuterMatrix, animEnd); ​ mScaleAnimator.start(); ​ &#x2F;&#x2F;清理临时变量 ​ MathUtils.rectFGiven(testBound); ​ MathUtils.matrixGiven(testMatrix); ​ MathUtils.matrixGiven(animEnd); ​ MathUtils.matrixGiven(innerMatrix); } &#x2F;** * 当缩放操作结束动画 * 如果图片超过边界,找到最近的位置动画恢复. * 如果图片缩放尺寸超过最大值或者最小值,找到最近的值动画恢复. *&#x2F; private void scaleEnd() { if (!isReady()) { return; ​ } &#x2F;&#x2F;是否修正了位置 ​ boolean change &#x3D;false; ​ &#x2F;&#x2F;获取图片整体的变换矩阵 ​ Matrix currentMatrix &#x3D; MathUtils.matrixTake(); ​ getCurrentImageMatrix(currentMatrix); ​ &#x2F;&#x2F;整体缩放比例 ​ float currentScale &#x3D; MathUtils.getMatrixScale(currentMatrix)[0]; ​ &#x2F;&#x2F;第二层缩放比例 ​ float outerScale &#x3D; MathUtils.getMatrixScale(mOuterMatrix)[0]; ​ &#x2F;&#x2F;控件大小 ​ float displayWidth &#x3D; getWidth(); ​ float displayHeight &#x3D; getHeight(); ​ &#x2F;&#x2F;最大缩放比例 ​ float maxScale &#x3D; getMaxScale(); ​ &#x2F;&#x2F;比例修正 ​ float scalePost &#x3D;1f; ​ &#x2F;&#x2F;位置修正 ​ float postX &#x3D;0; ​ float postY &#x3D;0; ​ &#x2F;&#x2F;如果整体缩放比例大于最大比例，进行缩放修正 ​ if (currentScale &gt; maxScale) { scalePost &#x3D; maxScale &#x2F; currentScale; ​ } &#x2F;&#x2F;如果缩放修正后整体导致第二层缩放小于1（就是图片比fit center状态还小），重新修正缩放 ​ if (outerScale * scalePost &lt;1f) { scalePost &#x3D;1f &#x2F; outerScale; ​ } &#x2F;&#x2F;如果缩放修正不为1，说明进行了修正 ​ if (scalePost !&#x3D;1f) { change &#x3D;true; ​ } &#x2F;&#x2F;尝试根据缩放点进行缩放修正 ​ Matrix testMatrix &#x3D; MathUtils.matrixTake(currentMatrix); ​ testMatrix.postScale(scalePost, scalePost, mLastMovePoint.x, mLastMovePoint.y); ​ RectF testBound &#x3D; MathUtils.rectFTake(0, 0, getDrawable().getIntrinsicWidth(), getDrawable().getIntrinsicHeight()); ​ &#x2F;&#x2F;获取缩放修正后的图片方框 ​ testMatrix.mapRect(testBound); ​ &#x2F;&#x2F;检测缩放修正后位置有无超出，如果超出进行位置修正 ​ if (testBound.right - testBound.left &lt; displayWidth) { postX &#x3D; displayWidth &#x2F;2f - (testBound.right + testBound.left) &#x2F;2f; ​ }else if (testBound.left &gt;0) { postX &#x3D; -testBound.left; ​ }else if (testBound.right &lt; displayWidth) { postX &#x3D; displayWidth - testBound.right; ​ } if (testBound.bottom - testBound.top &lt; displayHeight) { postY &#x3D; displayHeight &#x2F;2f - (testBound.bottom + testBound.top) &#x2F;2f; ​ }else if (testBound.top &gt;0) { postY &#x3D; -testBound.top; ​ }else if (testBound.bottom &lt; displayHeight) { postY &#x3D; displayHeight - testBound.bottom; ​ } &#x2F;&#x2F;如果位置修正不为0，说明进行了修正 ​ if (postX !&#x3D;0 || postY !&#x3D;0) { change &#x3D;true; ​ } &#x2F;&#x2F;只有有执行修正才执行动画 ​ if (change) { &#x2F;&#x2F;计算结束矩阵 ​ Matrix animEnd &#x3D; MathUtils.matrixTake(mOuterMatrix); ​ animEnd.postScale(scalePost, scalePost, mLastMovePoint.x, mLastMovePoint.y); ​ animEnd.postTranslate(postX, postY); ​ &#x2F;&#x2F;清理当前可能正在执行的动画 ​ cancelAllAnimator(); ​ &#x2F;&#x2F;启动矩阵动画 ​ mScaleAnimator &#x3D;new ScaleAnimator(mOuterMatrix, animEnd); ​ mScaleAnimator.start(); ​ &#x2F;&#x2F;清理临时变量 ​ MathUtils.matrixGiven(animEnd); ​ } &#x2F;&#x2F;清理临时变量 ​ MathUtils.rectFGiven(testBound); ​ MathUtils.matrixGiven(testMatrix); ​ MathUtils.matrixGiven(currentMatrix); } &#x2F;** * 执行惯性动画 * 动画在遇到不能移动就停止. * 动画速度衰减到很小就停止. * 其中参数速度单位为 像素&#x2F;秒 * @param vx x方向速度 * @param vy y方向速度 *&#x2F; private void fling(float vx, float vy) { if (!isReady()) { return; ​ } &#x2F;&#x2F;清理当前可能正在执行的动画 ​ cancelAllAnimator(); ​ &#x2F;&#x2F;创建惯性动画 ​ &#x2F;&#x2F;FlingAnimator单位为 像素&#x2F;帧,一秒60帧 ​ mFlingAnimator &#x3D;new FlingAnimator(vx &#x2F;60f, vy &#x2F;60f); ​ mFlingAnimator.start(); } &#x2F;** * 停止所有手势动画 *&#x2F; private void cancelAllAnimator() { if (mScaleAnimator !&#x3D;null) { mScaleAnimator.cancel(); ​ mScaleAnimator &#x3D;null; ​ } if (mFlingAnimator !&#x3D;null) { mFlingAnimator.cancel(); ​ mFlingAnimator &#x3D;null; ​ } } &#x2F;** * 惯性动画 * 速度逐渐衰减,每帧速度衰减为原来的FLING_DAMPING_FACTOR,当速度衰减到小于1时停止. * 当图片不能移动时,动画停止. *&#x2F; private class FlingAnimatorextends ValueAnimatorimplements ValueAnimator.AnimatorUpdateListener { &#x2F;** ​ * 速度向量 ​ *&#x2F; ​ private float[]mVector; ​ &#x2F;** ​ * 创建惯性动画 ​ * ​ * 参数单位为 像素&#x2F;帧 ​ * ​ * @param vectorX 速度向量 ​ * @param vectorY 速度向量 ​ *&#x2F; ​ public FlingAnimator(float vectorX, float vectorY) { super(); ​ setFloatValues(0, 1f); ​ setDuration(1000000); ​ addUpdateListener(this); ​ mVector &#x3D;new float[]{vectorX, vectorY}; ​ } @Override ​ public void onAnimationUpdate(ValueAnimator animation) { &#x2F;&#x2F;移动图像并给出结果 ​ boolean result &#x3D; scrollBy(mVector[0], mVector[1]); ​ &#x2F;&#x2F;衰减速度 ​ mVector[0] *&#x3D;FLING_DAMPING_FACTOR; ​ mVector[1] *&#x3D;FLING_DAMPING_FACTOR; ​ &#x2F;&#x2F;速度太小或者不能移动了就结束 ​ if (!result || MathUtils.getDistance(0, 0, mVector[0], mVector[1]) &lt;1f) { animation.cancel(); ​ } } } &#x2F;** * 缩放动画 * 在给定时间内从一个矩阵的变化逐渐动画到另一个矩阵的变化 *&#x2F; private class ScaleAnimatorextends ValueAnimatorimplements ValueAnimator.AnimatorUpdateListener { &#x2F;** ​ * 开始矩阵 ​ *&#x2F; ​ private float[]mStart &#x3D;new float[9]; ​ &#x2F;** ​ * 结束矩阵 ​ *&#x2F; ​ private float[]mEnd &#x3D;new float[9]; ​ &#x2F;** ​ * 中间结果矩阵 ​ *&#x2F; ​ private float[]mResult &#x3D;new float[9]; ​ &#x2F;** ​ * 构建一个缩放动画 ​ * ​ * 从一个矩阵变换到另外一个矩阵 ​ * ​ * @param start 开始矩阵 ​ * @param end 结束矩阵 ​ *&#x2F; ​ public ScaleAnimator(Matrix start, Matrix end) { this(start, end, SCALE_ANIMATOR_DURATION); ​ } &#x2F;** ​ * 构建一个缩放动画 ​ * ​ * 从一个矩阵变换到另外一个矩阵 ​ * ​ * @param start 开始矩阵 ​ * @param end 结束矩阵 ​ * @param duration 动画时间 ​ *&#x2F; ​ public ScaleAnimator(Matrix start, Matrix end, long duration) { super(); ​ setFloatValues(0, 1f); ​ setDuration(duration); ​ addUpdateListener(this); ​ start.getValues(mStart); ​ end.getValues(mEnd); ​ } @Override ​ public void onAnimationUpdate(ValueAnimator animation) { &#x2F;&#x2F;获取动画进度 ​ float value &#x3D; (Float) animation.getAnimatedValue(); ​ &#x2F;&#x2F;根据动画进度计算矩阵中间插值 ​ for (int i &#x3D;0; i &lt;9; i++) { mResult[i] &#x3D;mStart[i] + (mEnd[i] -mStart[i]) * value; ​ } &#x2F;&#x2F;设置矩阵并重绘 ​ mOuterMatrix.setValues(mResult); ​ dispatchOuterMatrixChanged(); ​ invalidate(); ​ } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;防止内存抖动复用对象&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 对象池 * 防止频繁new对象产生内存抖动. * 由于对象池最大长度限制,如果吞度量超过对象池容量,仍然会发生抖动. * 此时需要增大对象池容量,但是会占用更多内存. * @param 对象池容纳的对象类型 *&#x2F; private static abstract class ObjectsPool { &#x2F;** ​ * 对象池的最大容量 ​ *&#x2F; ​ private int mSize; ​ &#x2F;** ​ * 对象池队列 ​ *&#x2F; ​ private QueuemQueue; ​ &#x2F;** ​ * 创建一个对象池 ​ * ​ * @param size 对象池最大容量 ​ *&#x2F; ​ public ObjectsPool(int size) { mSize &#x3D; size; ​ mQueue &#x3D;new LinkedList(); ​ } &#x2F;** ​ * 获取一个空闲的对象 ​ * ​ * 如果对象池为空,则对象池自己会new一个返回. ​ * 如果对象池内有对象,则取一个已存在的返回. ​ * take出来的对象用完要记得调用given归还. ​ * 如果不归还,让然会发生内存抖动,但不会引起泄漏. ​ * @return 可用的对象 ​ * ​ * @see #given(Object) *&#x2F; ​ public T take() { &#x2F;&#x2F;如果池内为空就创建一个 ​ if (mQueue.size() &#x3D;&#x3D;0) { return newInstance(); ​ }else { &#x2F;&#x2F;对象池里有就从顶端拿出来一个返回 ​ return resetInstance(mQueue.poll()); ​ } } &#x2F;** ​ * 归还对象池内申请的对象 ​ * ​ * 如果归还的对象数量超过对象池容量,那么归还的对象就会被丢弃. ​ * @param obj 归还的对象 ​ * ​ * @see #take() *&#x2F; ​ public void given(T obj) { &#x2F;&#x2F;如果对象池还有空位子就归还对象 ​ if (obj !&#x3D;null &amp;&amp;mQueue.size() mQueue.offer(obj); ​ } } &#x2F;** ​ * 实例化对象 ​ * ​ * @return 创建的对象 ​ *&#x2F; ​ abstract protected T newInstance(); ​ &#x2F;** ​ * 重置对象 ​ * ​ * 把对象数据清空到就像刚创建的一样. ​ * @param obj 需要被重置的对象 ​ * @return 被重置之后的对象 ​ *&#x2F; ​ abstract protected T resetInstance(T obj); } &#x2F;** * 矩阵对象池 *&#x2F; private static class MatrixPoolextends ObjectsPool { public MatrixPool(int size) { super(size); ​ } @Override ​ protected MatrixnewInstance() { return new Matrix(); ​ } @Override ​ protected MatrixresetInstance(Matrix obj) { obj.reset(); ​ return obj; ​ } } &#x2F;** * 矩形对象池 *&#x2F; private static class RectFPoolextends ObjectsPool { public RectFPool(int size) { super(size); ​ } @Override ​ protected RectFnewInstance() { return new RectF(); ​ } @Override ​ protected RectFresetInstance(RectF obj) { obj.setEmpty(); ​ return obj; ​ } } &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;数学计算工具类&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; &#x2F;** * 数学计算工具类 *&#x2F; public static class MathUtils { &#x2F;** ​ * 矩阵对象池 ​ *&#x2F; ​ private static MatrixPoolmMatrixPool &#x3D;new MatrixPool(16); ​ &#x2F;** ​ * 获取矩阵对象 ​ *&#x2F; ​ public static MatrixmatrixTake() { return mMatrixPool.take(); ​ } &#x2F;** ​ * 获取某个矩阵的copy *&#x2F; ​ public static MatrixmatrixTake(Matrix matrix) { Matrix result &#x3D;mMatrixPool.take(); ​ if (matrix !&#x3D;null) { result.set(matrix); ​ } return result; ​ } &#x2F;** ​ * 归还矩阵对象 ​ *&#x2F; ​ public static void matrixGiven(Matrix matrix) { mMatrixPool.given(matrix); ​ } &#x2F;** ​ * 矩形对象池 ​ *&#x2F; ​ private static RectFPoolmRectFPool &#x3D;new RectFPool(16); ​ &#x2F;** ​ * 获取矩形对象 ​ *&#x2F; ​ public static RectFrectFTake() { return mRectFPool.take(); ​ } &#x2F;** ​ * 按照指定值获取矩形对象 ​ *&#x2F; ​ public static RectFrectFTake(float left, float top, float right, float bottom) { RectF result &#x3D;mRectFPool.take(); ​ result.set(left, top, right, bottom); ​ return result; ​ } &#x2F;** ​ * 获取某个矩形的副本 ​ *&#x2F; ​ public static RectFrectFTake(RectF rectF) { RectF result &#x3D;mRectFPool.take(); ​ if (rectF !&#x3D;null) { result.set(rectF); ​ } return result; ​ } &#x2F;** ​ * 归还矩形对象 ​ *&#x2F; ​ public static void rectFGiven(RectF rectF) { mRectFPool.given(rectF); ​ } &#x2F;** ​ * 获取两点之间距离 ​ * ​ * @param x1 点1 ​ * @param y1 点1 ​ * @param x2 点2 ​ * @param y2 点2 ​ * @return 距离 ​ *&#x2F; ​ public static float getDistance(float x1, float y1, float x2, float y2) { float x &#x3D; x1 - x2; ​ float y &#x3D; y1 - y2; ​ return (float) Math.sqrt(x * x + y * y); ​ } &#x2F;** ​ * 获取两点的中点 ​ * ​ * @param x1 点1 ​ * @param y1 点1 ​ * @param x2 点2 ​ * @param y2 点2 ​ * @return float[]{x, y} *&#x2F; ​ public static float[]getCenterPoint(float x1, float y1, float x2, float y2) { return new float[]{(x1 + x2) &#x2F;2f, (y1 + y2) &#x2F;2f}; ​ } &#x2F;** ​ * 获取矩阵的缩放值 ​ * ​ * @param matrix 要计算的矩阵 ​ * @return float[]{scaleX, scaleY} *&#x2F; ​ public static float[]getMatrixScale(Matrix matrix) { if (matrix !&#x3D;null) { float[] value &#x3D;new float[9]; ​ matrix.getValues(value); ​ return new float[]{value[0], value[4]}; ​ }else { return new float[2]; ​ } } &#x2F;** ​ * 计算点除以矩阵的值 ​ * * matrix.mapPoints(unknownPoint) -&gt; point ​ * 已知point和matrix,求unknownPoint的值. ​ * @param point ​ * @param matrix ​ * @return unknownPoint *&#x2F; ​ public static float[]inverseMatrixPoint(float[] point, Matrix matrix) { if (point !&#x3D;null &amp;&amp; matrix !&#x3D;null) { float[] dst &#x3D;new float[2]; ​ &#x2F;&#x2F;计算matrix的逆矩阵 ​ Matrix inverse &#x3D;matrixTake(); ​ matrix.invert(inverse); ​ &#x2F;&#x2F;用逆矩阵变换point到dst,dst就是结果 ​ inverse.mapPoints(dst, point); ​ &#x2F;&#x2F;清除临时变量 ​ matrixGiven(inverse); ​ return dst; ​ }else { return new float[2]; ​ } } &#x2F;** ​ * 计算两个矩形之间的变换矩阵 ​ * * unknownMatrix.mapRect(to, from) ​ * 已知from矩形和to矩形,求unknownMatrix ​ * @param from ​ * @param to ​ * @param result unknownMatrix *&#x2F; ​ public static void calculateRectTranslateMatrix(RectF from, RectF to, Matrix result) { if (from &#x3D;&#x3D;null || to &#x3D;&#x3D;null || result &#x3D;&#x3D;null) { return; ​ } if (from.width() &#x3D;&#x3D;0 || from.height() &#x3D;&#x3D;0) { return; ​ } result.reset(); ​ result.postTranslate(-from.left, -from.top); ​ result.postScale(to.width() &#x2F; from.width(), to.height() &#x2F; from.height()); ​ result.postTranslate(to.left, to.top); ​ } &#x2F;** ​ * 计算图片在某个ImageView中的显示矩形 ​ * ​ * @param container ImageView的Rect ​ * @param srcWidth 图片的宽度 ​ * @param srcHeight 图片的高度 ​ * @param scaleType 图片在ImageView中的ScaleType ​ * @param result 图片应该在ImageView中展示的矩形 ​ *&#x2F; ​ public static void calculateScaledRectInContainer(RectF container, float srcWidth, float srcHeight, ScaleType scaleType, RectF result) { if (container &#x3D;&#x3D;null || result &#x3D;&#x3D;null) { return; ​ } if (srcWidth &#x3D;&#x3D;0 || srcHeight &#x3D;&#x3D;0) { return; ​ } &#x2F;&#x2F;默认scaleType为fit center ​ if (scaleType &#x3D;&#x3D;null) { scaleType &#x3D; ScaleType.FIT_CENTER; ​ } result.setEmpty(); ​ if (ScaleType.FIT_XY.equals(scaleType)) { result.set(container); ​ }else if (ScaleType.CENTER.equals(scaleType)) { Matrix matrix &#x3D;matrixTake(); ​ RectF rect &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ matrix.setTranslate((container.width() - srcWidth) *0.5f, (container.height() - srcHeight) *0.5f); ​ matrix.mapRect(result, rect); ​ rectFGiven(rect); ​ matrixGiven(matrix); ​ result.left +&#x3D; container.left; ​ result.right +&#x3D; container.left; ​ result.top +&#x3D; container.top; ​ result.bottom +&#x3D; container.top; ​ }else if (ScaleType.CENTER_CROP.equals(scaleType)) { Matrix matrix &#x3D;matrixTake(); ​ RectF rect &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ float scale; ​ float dx &#x3D;0; ​ float dy &#x3D;0; ​ if (srcWidth * container.height() &gt; container.width() * srcHeight) { scale &#x3D; container.height() &#x2F; srcHeight; ​ dx &#x3D; (container.width() - srcWidth * scale) *0.5f; ​ }else { scale &#x3D; container.width() &#x2F; srcWidth; ​ dy &#x3D; (container.height() - srcHeight * scale) *0.5f; ​ } matrix.setScale(scale, scale); ​ matrix.postTranslate(dx, dy); ​ matrix.mapRect(result, rect); ​ rectFGiven(rect); ​ matrixGiven(matrix); ​ result.left +&#x3D; container.left; ​ result.right +&#x3D; container.left; ​ result.top +&#x3D; container.top; ​ result.bottom +&#x3D; container.top; ​ }else if (ScaleType.CENTER_INSIDE.equals(scaleType)) { Matrix matrix &#x3D;matrixTake(); ​ RectF rect &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ float scale; ​ float dx; ​ float dy; ​ if (srcWidth &lt;&#x3D; container.width() &amp;&amp; srcHeight &lt;&#x3D; container.height()) { scale &#x3D;1f; ​ }else { scale &#x3D; Math.min(container.width() &#x2F; srcWidth, container.height() &#x2F; srcHeight); ​ } dx &#x3D; (container.width() - srcWidth * scale) *0.5f; ​ dy &#x3D; (container.height() - srcHeight * scale) *0.5f; ​ matrix.setScale(scale, scale); ​ matrix.postTranslate(dx, dy); ​ matrix.mapRect(result, rect); ​ rectFGiven(rect); ​ matrixGiven(matrix); ​ result.left +&#x3D; container.left; ​ result.right +&#x3D; container.left; ​ result.top +&#x3D; container.top; ​ result.bottom +&#x3D; container.top; ​ }else if (ScaleType.FIT_CENTER.equals(scaleType)) { Matrix matrix &#x3D;matrixTake(); ​ RectF rect &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ RectF tempSrc &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ RectF tempDst &#x3D;rectFTake(0, 0, container.width(), container.height()); ​ matrix.setRectToRect(tempSrc, tempDst, Matrix.ScaleToFit.CENTER); ​ matrix.mapRect(result, rect); ​ rectFGiven(tempDst); ​ rectFGiven(tempSrc); ​ rectFGiven(rect); ​ matrixGiven(matrix); ​ result.left +&#x3D; container.left; ​ result.right +&#x3D; container.left; ​ result.top +&#x3D; container.top; ​ result.bottom +&#x3D; container.top; ​ }else if (ScaleType.FIT_START.equals(scaleType)) { Matrix matrix &#x3D;matrixTake(); ​ RectF rect &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ RectF tempSrc &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ RectF tempDst &#x3D;rectFTake(0, 0, container.width(), container.height()); ​ matrix.setRectToRect(tempSrc, tempDst, Matrix.ScaleToFit.START); ​ matrix.mapRect(result, rect); ​ rectFGiven(tempDst); ​ rectFGiven(tempSrc); ​ rectFGiven(rect); ​ matrixGiven(matrix); ​ result.left +&#x3D; container.left; ​ result.right +&#x3D; container.left; ​ result.top +&#x3D; container.top; ​ result.bottom +&#x3D; container.top; ​ }else if (ScaleType.FIT_END.equals(scaleType)) { Matrix matrix &#x3D;matrixTake(); ​ RectF rect &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ RectF tempSrc &#x3D;rectFTake(0, 0, srcWidth, srcHeight); ​ RectF tempDst &#x3D;rectFTake(0, 0, container.width(), container.height()); ​ matrix.setRectToRect(tempSrc, tempDst, Matrix.ScaleToFit.END); ​ matrix.mapRect(result, rect); ​ rectFGiven(tempDst); ​ rectFGiven(tempSrc); ​ rectFGiven(rect); ​ matrixGiven(matrix); ​ result.left +&#x3D; container.left; ​ result.right +&#x3D; container.left; ​ result.top +&#x3D; container.top; ​ result.bottom +&#x3D; container.top; ​ }else { result.set(container); ​ } } } }","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android SildingMenu（侧滑菜单）常用属性/","text":"转：http://my.eoe.cn/1169143/archive/21892.html SlidingMenu简介: SlidingMenu的是一种比较新的设置界面或配置界面效果，在主界面左滑或者右滑出现设置界面，能方便的进行各种操作.目前有大量的应用都在使用这一效果。如Evernote、Google+、Foursquare等，国内的豌豆夹，人人，360手机助手等都使用SlidingMenu的界面方案。 项目下载地址:https://github.com/jfeinstein10/SlidingMenu(直接import moudle)包内的library SlidingMenu 常用属性介绍: menu.setMode(SlidingMenu.LEFT);&#x2F;&#x2F;设置左滑菜单 menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);&#x2F;&#x2F;设置滑动的屏幕范围，该设置为全屏区域都可以滑动 menu.setShadowDrawable(R.drawable.shadow);&#x2F;&#x2F;设置阴影图片 menu.setShadowWidthRes(R.dimen.shadow_width);&#x2F;&#x2F;设置阴影图片的宽度 menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);&#x2F;&#x2F;SlidingMenu划出时主页面显示的剩余宽度 menu.setBehindWidth(400);&#x2F;&#x2F;设置SlidingMenu菜单的宽度 menu.setFadeDegree(0.35f);&#x2F;&#x2F;SlidingMenu滑动时的渐变程度 menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);&#x2F;&#x2F;使SlidingMenu附加在Activity上 menu.setMenu(R.layout.menu_layout);&#x2F;&#x2F;设置menu的布局文件 menu.toggle();&#x2F;&#x2F;动态判断自动关闭或开启SlidingMenu menu.showMenu();&#x2F;&#x2F;显示SlidingMenu menu.showContent();&#x2F;&#x2F;显示内容 menu.setOnOpenListener(onOpenListener);&#x2F;&#x2F;监听slidingmenu打开 关于关闭menu有两个监听，简单的来说，对于menu close事件，一个是when,一个是after menu.OnClosedListener(OnClosedListener);&#x2F;&#x2F;监听slidingmenu关闭时事件 menu.OnClosedListener(OnClosedListener);&#x2F;&#x2F;监听slidingmenu关闭后事件 左右都可以划出SlidingMenu菜单只需要设置 menu.setMode(SlidingMenu.LEFT_RIGHT);属性，然后设置右侧菜单的布局文件 menu.setSecondaryShadowDrawable(R.drawable.shadowright);&#x2F;&#x2F;右侧菜单的阴影图片 设置SlidingMenu属性 sm &#x3D; getSlidingMenu(); &#x2F;&#x2F;如果只显示左侧菜单就是用LEFT,右侧就RIGHT，左右都支持就LEFT_RIGHT sm.setMode(SlidingMenu.LEFT_RIGHT);&#x2F;&#x2F;设置菜单滑动模式，菜单是出现在左侧还是右侧，还是左右两侧都有 sm.setShadowDrawable(R.drawable.shadow);&#x2F;&#x2F;设置阴影的图片资源 sm.setShadowWidthRes(R.dimen.shadow_width);&#x2F;&#x2F;设置阴影图片的宽度 &#x2F;&#x2F;sm.setBehindWidth(200);&#x2F;&#x2F;设置菜单的宽 sm.setBehindOffsetRes(R.dimen.slidingmenu_offset);&#x2F;&#x2F;SlidingMenu划出时主页面显示的剩余宽度 sm.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);&#x2F;&#x2F;设置滑动的区域 支持右侧划出菜单: &#x2F;&#x2F;SlidingMenu可以同时支持划出左右两侧的菜单，互不冲突，而且动画优美，体验良好。 sm.setSecondaryMenu(R.layout.menu_frame2);&#x2F;&#x2F;设置右侧菜单 sm.setSecondaryShadowDrawable(R.drawable.shadowright);&#x2F;&#x2F;设置右侧菜单阴影的图片资源 &#x2F;&#x2F;右侧SlidingMenu的Fragment getSupportFragmentManager().beginTransaction().replace(R.id.menu_frame2, new SampleListFragment()).commit(); slidingMenu &#x3D; getSlidingMenu(); &#x2F;&#x2F;设置是左滑还是右滑，还是左右都可以滑 slidingMenu.setMode(SlidingMenu.LEFT_RIGHT); &#x2F;&#x2F;设置阴影宽度 slidingMenu.setShadowWidth(getWindowManager().getDefaultDisplay().getWidth() &#x2F; 40); &#x2F;&#x2F;设置左菜单阴影图片 slidingMenu.setShadowDrawable(R.drawable.shadow); &#x2F;&#x2F;设置右菜单阴影图片 slidingMenu.setSecondaryShadowDrawable(R.drawable.right_shadow); &#x2F;&#x2F;设置菜单占屏幕的比例 slidingMenu.setBehindOffset(getWindowManager().getDefaultDisplay().getWidth() &#x2F; 5); &#x2F;&#x2F;设置滑动时菜单的是否淡入淡出 slidingMenu.setFadeEnabled(true); &#x2F;&#x2F;设置淡入淡出的比例 slidingMenu.setFadeDegree(0.4f); &#x2F;&#x2F;设置滑动时拖拽效果 slidingMenu.setBehindScrollScale(0); &#x2F;&#x2F;设置要使菜单滑动，触碰屏幕的范围 slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/adb配置/","text":"####找到本地platform-tools文件路径：android Studio-Tools-SDKManager将platform-tools路径配置到环境变量的path中cmd 输入adb运行显示版本信息等既成功","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/adb常用命令/","text":"adb devices (列出当前连接的设备列表) adb -s 设备 shell (指定手机设备) adb shell （进入手机管理） adb install 文件 （安装文件） adb push 电脑端文件 手机端文件路径(从电脑端发送文件到手机端) adb pull 手机端文件路径 电脑端文件路径（从手机端复制文件到电脑端） adb chmod 777 文件&#x2F;文件夹路径(指定要给权限的文件或文件夹) adb cd 路径（进入目录） adb cat (查看文件内容) adb id(获取当前用户信息) adb ps(查看当前系统所有进程) adb kill 进程id(杀进程) adb ls (列出当前文件夹下的文件) adb mkdir（创建文件夹) adb touch(c创建一个空文件) adb rm（移除文件） adb rm -r (移除文件夹) adb cp(复制文件) adb mv 要移动的文件，重命名文件（移动文件）","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/其他笔记/svn配置及使用/svn下载远程仓库/","text":"","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"svn配置及使用","slug":"其他笔记/svn配置及使用","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"}]},{"path":"wiki/其他笔记/svn配置及使用/svn服务端安装和配置/","text":"服务端（VisualSvn）https://www.visualsvn.com/server/download/","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"svn配置及使用","slug":"其他笔记/svn配置及使用","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"}]},{"path":"wiki/其他笔记/svn配置及使用/svn的基本操作/","text":"###增删改查本地文件到远程仓库###同步远程仓库到本地每次commit前最好都同步一下远程仓库后再commit","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"svn配置及使用","slug":"其他笔记/svn配置及使用","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"}]},{"path":"wiki/其他笔记/svn配置及使用/svn客户端安装和配置/","text":"客户端（TortoiseSVN）https://tortoisesvn.net/downloads.html","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"svn配置及使用","slug":"其他笔记/svn配置及使用","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"}]},{"path":"wiki/Android Application/Android日常问题/studio插件下载慢解决方法/","text":"在配置文件build.gradle(project:xxx)中将代码修改为 1234567891011121314151617181920212223242526272829303132333435buildscript &#123; repositories &#123;//添加以下4行代码 maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/gradle-plugin&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125; mavenCentral() google() jcenter() &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:7.0.0&#125;allprojects &#123; repositories &#123; maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/gradle-plugin&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125; mavenCentral() mavenLocal() jcenter() maven &#123; url &quot;https://maven.google.com&quot; &#125; maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Material-Design新控件/AppbarLayout/","text":"AppbarLayout继承自LinearLayout,它就是一个垂直方向的LinearLayout,在LinearLayout的基础上添加了一些材料设计的概念和特性，即滑动手势。它可以让你定制在某个可滑动的View（如：ScrollView ,ListView ,RecyclerView 等）滑动手势发生改变时，内部的子View 该做什么动作。子View应该提供滑动时他们期望的响应的动作Behavior,通过setScrollFlags(int)，或者xml 中使用属性： 1app:layout_scrollFlags 注意：AppbarLayout 严重依赖于CoordinatorLayout，必须用于CoordinatorLayout 的直接子View，如果你将AppbarLayout 放在其他的ViewGroup 里面，那么它的这些功能是无效的。 #####AppbarLayout 子View 的几种动作上面说了 AppbarLayout 可以定制当某个可滑动的View滑动手势改变时内部子View的动作，通过app:layout_scrollFlags来指定，那么现在我们就看一下layout_scrollFlags有哪几种动作。layout_scrollFlags有5种动作，分别是 1scroll,enterAlways,enterAlwaysCollapsed,exitUntilCollapsed,snap 我们来分别看一下这五种动作的含义。#####1. scroll :子View 添加layout_scrollFlags属性 的值scroll 时，这个View将会随着可滚动View（如：ScrollView,以下都会用ScrollView 来代替可滚动的View ）一起滚动，就好像子View 是属于ScrollView的一部分一样。（子view指的不一定是Toolbar） 12345678&lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:title=&quot;AppbarLayout&quot; app:titleTextColor=&quot;@color/white&quot; app:layout_scrollFlags=&quot;scroll&quot; &gt; &lt;/android.support.v7.widget.Toolbar&gt; #####2. enterAlways子View 添加layout_scrollFlags属性 的值有enterAlways 时, 当ScrollView 向下滑动时，子View 将直接向下滑动，而不管ScrollView 是否在滑动。注意：要与scroll 搭配使用，否者是不能滑动的。代码如下： 1234567&lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:title=&quot;AppbarLayout&quot; app:titleTextColor=&quot;@color/white&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; /&gt; #####3. enterAlwaysCollapsedenterAlwaysCollapsed 是对enterAlways 的补充，当ScrollView 向下滑动的时候，滑动View（也就是设置了enterAlwaysCollapsed 的View）下滑至折叠的高度，当ScrollView 到达滑动范围的结束值的时候，滑动View剩下的部分开始滑动。这个折叠的高度是通过View的minimum height （最小高度）指定的。补充说明：要配合scroll｜enterAlways 一起使用 12345678910&lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:title=&quot;AppbarLayout&quot; android:gravity=&quot;bottom&quot; android:layout_marginBottom=&quot;25dp&quot; app:titleTextColor=&quot;@color/white&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot; /&gt; #####4. exitUntilCollapsed 当ScrollView 滑出屏幕时（也就时向上滑动时），滑动View先响应滑动事件，滑动至折叠高度，也就是通过minimum height 设置的最小高度后，就固定不动了，再把滑动事件交给 scrollview 继续滑动。 123456789&lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:title=&quot;AppbarLayout&quot; android:gravity=&quot;bottom&quot; app:titleTextColor=&quot;@color/white&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; /&gt; #####5. snap意思是：在滚动结束后，如果view只是部分可见，它将滑动到最近的边界。比如，如果view的底部只有25%可见，它将滚动离开屏幕，而如果底部有75%可见，它将滚动到完全显示。 解释：可能这段话有点难懂，解释一下，就是说，比如在屏幕的顶部有个View ，高度200dp,我向上滑动40％后停止，也就 40% 滑出了屏幕，剩下的60%留在屏幕，那么这个属性就会自动将屏幕外的40% 滑回屏幕，结果的整个View都留在屏幕上，相反，如果我向上将60%的部分滑出屏幕，然后停止滑动，那么这个属性会将剩下的40% 也自动滑出屏幕，结果是整个View都在屏幕之外。这就是上面所说的滑动到最近的边界。 123456789&lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:title=&quot;AppbarLayout&quot; android:gravity=&quot;bottom&quot; app:titleTextColor=&quot;@color/white&quot; app:layout_scrollFlags=&quot;scroll|snap&quot; /&gt; ####AppbarLayout 的几个重要方法介绍一下AppbarLayout几个常用且重要的方法 addOnOffsetChangedListener 当AppbarLayout 的偏移发生改变的时候回调，也就是子View滑动。 getTotalScrollRange 返回AppbarLayout 所有子View的滑动范围 removeOnOffsetChangedListener移除监听器 setExpanded (boolean expanded, boolean animate)**设置AppbarLayout 是展开状态还是折叠状态，animate 参数控制切换到新的状态时是否需要动画 setExpanded (boolean expanded)** 设置AppbarLayout 是展开状态还是折叠状态,默认有动画 ####完整代码： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;!--app:layout_scrollFlags 1、scroll: 所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。 例如，TabLayout 没有设置这个值，将会停留在屏幕顶部。 2、enterAlways: 设置这个flag时，向下的滚动都会导致该view变为可见，启用快速“返回模式”。 3、enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入， 只有当滚动视图到达顶部时才扩大到完整高度。 4、exitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:popupTheme=&quot;@style/Theme.AppCompat.Light&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 转自：https://www.jianshu.com/p/ac56f11e7ce1","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/Material-Design新控件/Chronometer计时器/","text":"（这不算是Materual Design中的新控件，只是第一次用到特此记录一下）安卓提供了一个计时器组件：Chronometer，该组件extends TextView，因此都会显示一段文本，但是它显示的时间是从某个起始时间开始过去了多少时间，它只提供了android:format一个属性用于指定计时器的计数格式。 ####Chronometer的用法很简单，它支持如下用法： getBase()：返回时间。 setBase(long base)：设置计时器的起始时间。 start()：开始计时。 stop()：停止计时。 setFormat(String format)：设置显示时间的格式。 setOnChronometerTickListener(Chronometer.OnChronometerTickListener listener)：为计时器绑定监听事件。 ####示例：一个一分钟的计时器: 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Chronometer android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/chronometer&quot; android:textColor=&quot;#ff0303&quot; android:textSize=&quot;12pt&quot; android:layout_gravity=&quot;center_horizontal&quot; android:focusable=&quot;true&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;启动&quot; android:id=&quot;@+id/button&quot; android:layout_gravity=&quot;center_horizontal&quot; /&gt; &lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; Chronometer ch ; Button start ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.test);// 获取计时器组件 ch=(Chronometer)findViewById(R.id.chronometer);// 获取开始组件 start = (Button)findViewById(R.id.button); start.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //设置开始计时时间 ch.setBase(SystemClock.elapsedRealtime()-timeDifference*1000);//timeDifference真正想要显示的时间 单位秒 //启动计时器 ch.start(); &#125; &#125;); //为计时器绑定监听事件 ch.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() &#123; @Override public void onChronometerTick(Chronometer ch) &#123; // 如果从开始计时到现在超过了60s if (SystemClock.elapsedRealtime() - ch.getBase() &gt; 60 * 1000 &#123; ch.stop(); start.setEnabled(true); &#125; &#125; &#125;); &#125;&#125; ####效果图：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/Material-Design新控件/FloatingActionButton(悬浮按钮)/","text":"####FloatingActionButton简称FAB。一. 对于App或某个页面中是否要使用FloatingActionButton必要性： FAB代表一个App或一个页面中最主要的操作，如果一个App的每个页面都有FAB,则通常表示该App最主要的功能是通过该FAB操作的。 为了突出FAB的重要性，一个页面最好只有一个FAB。二. FloatingActionButton大小 通常有两种尺寸 1. 56 * 56dp ：默认的大小，最常用的尺寸。 2. 40 * 40 dp ：Mini版。 当然也可以改它的大小。 FAB中间的图标，google推荐的大小是：24 * 24dp 三. 哪些操作推荐使用FloatingActionButton 如： 添加，收藏，编辑，分享，导航等，如下图： 而如：删除，警告，错误，剪切等操作，则不推荐使用FloatingActionButton。 四. FAB的使用 Android 5.0 中引入Material Design，FAB为Android Design Support Library支持包中的中Material Design控件，要使用FAB，先要引入Design Support Library包，如在build.gradle中加入： compile &#39;com.android.support:design:26.0.0&#39; FAB的继承关系： FAB常用属性 app:elevation&#x3D;”8dp”：阴影的高度，elevation是Android 5.0中引入的新属性，设置该属性使控件有一个阴影，感觉该 控件像是“浮”起来一样，这样达到3D效果。对应的方法：setCompatElevation(float) app:fabSize&#x3D;”normal”：FAB的大小，为normal时，大小为：56 * 56dp ，为mini时，大小为： 40 * 40 dp。 app:backgroundTint&#x3D;”#31bfcf”：FAB的背景颜色。 app:rippleColor&#x3D;”#e7d16b”：点击FAB时，形成的波纹颜色。 app:borderWidth&#x3D;”0dp”：边框宽度，通常设置为0 ，用于解决Android 5.X设备上阴影无法正常显示的问题 app:pressedTranslationZ&#x3D;”16dp”:点击按钮时，按钮边缘阴影的宽度，通常设置比elevation的数值大!注意：引用上面属性的时候需要在根节点添加 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;示例：1234567891011121314&lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/fload_add&quot; app:backgroundTint=&quot;@color/deepskyblue&quot; app:elevation=&quot;5dp&quot; app:pressedTranslationZ=&quot;12dp&quot; app:fabSize=&quot;normal&quot; app:borderWidth=&quot;0dp&quot; app:rippleColor=&quot;#cccccc&quot; /&gt; 另外我们希望点击按钮一个颜色，正常状态一个颜色 以提高用户体验，那么就是drawable文件夹中创建文件 floatbutton.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@color/colorNormal&quot;&gt;&lt;/item&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@color/colorPressed&quot;&gt;&lt;/item&gt;&lt;/selector&gt; 然后我们设置FloatActionButton的backgroud为这个drawable文件即可，同时app:backgroundTint&#x3D;””属性也可以不再设置 效果图：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/Material-Design新控件/Snackbar/","text":"Snackbar是Android支持库中用于显示简单消息并且提供和用户的一个简单操作的一种弹出式提醒。当使用Snackbar时，提示会出现在消息最底部，通常含有一段信息和一个可点击的按钮。下图是Gmail中删除一封邮件时弹出的Snackbar：在上图中，最下方的黑色区域，包含左边文字和右边”撤销”字样的就是Snackbar。Snackbar在显示一段时间后就会自动消失。同样作为消息提示，Snackbar相比于Toast而言，增加了一个用户操作，并且在同时弹出多个消息时，Snackbar会停止前一个，直接显示后一个，也就是说同一时刻只会有一个Snackbar在显示；而Toast则不然，如果不做特殊处理，那么同时可以有多个Toast出现；Snackbar相比于Dialog，操作更少，因为只有一个用户操作的接口，而Dialog最多可以设置三个，另外Snackbar的出现并不影响用户的继续操作，而Dialog则必须需要用户做出响应，所以相比Dialog，Snackbar更轻量。经过上面的比较，可以看出Snackbar可以用于显示用户信息并且该信息不需要用户立即做出反馈的时候。 #####一、如何使用Snackbar？Snackbar没有公有的构造方法，但是提供了静态方法make方法： 12static Snackbar make(View view, CharSequence text, int duration)static Snackbar make(View view, int resId, int duration) 其中view参数是用于查找合适父布局的一个起点，下面分析源码的时候会解释到。如果父布局是一个CoordinatorLayout，那么Snackbar还会有别的一些特性：可以滑动消除；并且如果有FloatingActionButton时，会将FloatingActionButton上移，而不会挡住Snackbar的显示。父布局不是CoordinatorLayout在创建了一个Snackbar对象后，可以调用一些set**方法进行设置，其中setAction()方法用于设置右侧的文字显示以及点击事件，setCallback()方法用于设置一个状态回调，在Snackbar显示和消失的时候会触发方法。下面是一段创建Snackbar的代码： 123456789Snackbar.make(view, &quot;已删除一个会话&quot;, Snackbar.LENGTH_SHORT) .setAction(&quot;撤销&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(Main2Activity.this, &quot;撤销了删除&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); 以上代码在一个按钮的点击事件中创建一个Snackbar并显示，内容模仿上面的Gmail例子，并且给“撤销”一个点击事件，只是简单的显示一个Toast。Activity的根布局是一个RelativeLayout，并且下部有一个FloatingActionButton，在Snackbar出现后，可以看到Snackbar遮挡了FlaotingActionButton的一部分父布局是CoordinatorLayout在父布局不是CoordinatorLayout的情况下，如果有FloaingActionButton，那么弹出的Snackbar会遮挡FloatingActionButton，为了解决这个问题，可以将父布局改成CoordinatorLayout，并且这会带来一个新特性，就是Snackbar可以通过右滑消失。代码一样，只是布局不同。直接看效果图：可以看到当Snackbar出现时，FloatingActionButton会上移并且支持右滑消失。Snackbar消失的几种方式Snackbar显示只有一种方式，那就是调用show()方法，但是消失有几种方式：时间到了自动消失、点击了右侧按钮消失、新的Snackbar出现导致旧的Snackbar消失、滑动消失或者通过调用dismiss()消失。这些方式分别对应于Snackbar.Callback中的几个常量值。 DISMISS_EVENT_ACTION：点击了右侧按钮导致消失 DISMISS_EVENT_CONSECUTIVE：新的Snackbar出现导致旧的消失 DISMISS_EVENT_MANUAL：调用了dismiss方法导致消失 DISMISS_EVENT_SWIPE：滑动导致消失 DISMISS_EVENT_TIMEOUT：设置的显示时间到了导致消失Callback有两个方法：12void onDismissed(Snackbar snackbar, int event)void onShown(Snackbar snackbar) 其中onShown在Snackbar可见时调用，onDismissed在Snackbar准备消失时调用。一般我们可以在onDismissed方法中正在处理我们所需要的操作，比如删除一封邮件，那么如果是点击了“撤销”按钮，那就应该不再删除邮件直接消失就可以了，但是对于其他的几种情况，就需要真正地删除邮件了（发送数据到后台等等…）。下面是模拟这样一段过程：1234567891011121314151617181920212223242526Snackbar.make(view, &quot;已删除一个会话&quot;, Snackbar.LENGTH_SHORT).setAction(&quot;撤销&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;).setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; switch (event) &#123; case Snackbar.Callback.DISMISS_EVENT_CONSECUTIVE: case Snackbar.Callback.DISMISS_EVENT_MANUAL: case Snackbar.Callback.DISMISS_EVENT_SWIPE: case Snackbar.Callback.DISMISS_EVENT_TIMEOUT: //TODO 网络操作 Toast.makeText(MainActivity.this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); break; case Snackbar.Callback.DISMISS_EVENT_ACTION: Toast.makeText(MainActivity.this, &quot;撤销了删除操作&quot;, Toast.LENGTH_SHORT).show(); break; &#125; &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Log.i(TAG, &quot;onShown&quot;); &#125; &#125;).show();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/Material-Design新控件/SwitchCompat/","text":"SwitchCompat是符合谷歌Material design的Selection control组件，与传统的Switch以及ToggleButton不同，v7包中的这个组件兼容了绝大多数低版本手机，令组件的兼容性得到了极大的提升。 好，首先来看看组件的效果相当漂亮，然后我们看看谷歌的官方文档（请自带梯子）https://developer.android.com/reference/android/widget/Switch.html没法看也没关系，看其它大神的翻译 属性 bird showText：true&#x2F;false 决定是否显示开关按钮上的文字 splitTrack： true&#x2F;false 开关的样式 switchMinWidth 开关的最小宽度 switchPadding 文字和开关的最小距离 switchTextAppearance 开关文字样式 thumbTextPadding 文字距两侧的距离 thumbTint 开关上按钮的颜色 thumbTintMode 按钮样式 track 轨道，类似音乐进度条可滑动 trackTint 轨道颜色 trackTintMode 轨道样式 textOff 设置按钮关闭状态显示的文字 textOn 设置按钮打开状态显示的文字 thumb 引用主题颜色 #####No，如果你按照上面的属性去修改此控件的各种颜色，你就浪费它了！ 如果你的Activity继承自android.support.v7.app.AppCompatActivity 那就去res&#x2F;values&#x2F;styles.xml文件中去修改 1&lt;item name=&quot;colorAccent&quot;&gt;#666666&lt;/item&gt; 这个主题颜色吧～～瞬间switchCompat按钮和后面的滑动条就获得了主题颜色，特效全开 记得AndroidManifest.xml里需要设定我们的Theme.AppCompat主题的子类 1android:theme=&quot;@style/AppTheme&quot;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/Material-Design新控件/TabLayout/","text":"####一、简述TabLayout是Android Support Design库的新控件，可以用来实现开源框架ViewPageIndicator的效果（在MaterialDesign没出来之前基本都用这玩意儿吧~），TabLayout相比它使用上更加简单，且不一定要跟ViewPager一起使用，毕竟谷歌做出来的，稳定性更是不用说啦，此外，本文还会仔细列出本人对该控件的探索过程，从而实现一些控件本身没法实现的自定义效果，下面来看看它都有哪些操作吧。####二、使用1、创建Tab及Tab的点击事件要使用TabLayout，一般会先在布局文件中放好，如： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; 然后在Activity中找到它，对它进行设置，如果不跟ViewPager一起使用的话，可以对TabLayout手动添加多个tab，并设置其点击事件，如： 12345678910111213141516171819202122232425262728293031@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tab_layout); mTabLayout = (TabLayout) findViewById(R.id.tabLayout); // 添加多个tab for (int i = 0; i &lt; title.length; i++) &#123; TabLayout.Tab tab = mTabLayout.newTab(); tab.setText(title[i]); // tab.setIcon(R.mipmap.ic_launcher);//icon会显示在文字上面 mTabLayout.addTab(tab); &#125; // 给tab设置点击事件 mTabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; Toast.makeText(getApplicationContext(), title[tab.getPosition()], Toast.LENGTH_SHORT).show(); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;);&#125; 这里比较有意思的是Tab的创建需要调用TabLayout对象的newTab()方法，而不是直接new出一个Tab。Tab除了可以设置文字外，还能设置Icon，甚至可以自定义View，分别调用的是setIcon()和setCustomView()，有兴趣的可以试试看，上面代码效果如下：####2、自定义TabLayout样式这个TabLayout还是挺好看的，但开发中难免会要定制TabLayout的样式，如设置默认或选中文字的颜色和大小等，还好，TabLayout尽可能多的提供了这些自定义属性，可以让开发者很方便的修改样式，下面来看看都有哪些控件属性可以设置： 123456789101112131415161718&lt;!--设置Tab指示器--&gt;app:tabIndicatorColor=&quot;&quot;app:tabIndicatorHeight=&quot;&quot;&lt;!--设置Tab位置及显示模式--&gt;app:tabGravity=&quot;&quot;app:tabMode=&quot;&quot;&lt;!--设置Tab文字样式--&gt;app:tabSelectedTextColor=&quot;&quot;app:tabTextAppearance=&quot;&quot;app:tabTextColor=&quot;&quot;&lt;!--设置Tab的宽度、背景、内间距--&gt;app:tabMaxWidth=&quot;&quot;app:tabMinWidth=&quot;&quot;app:tabBackground=&quot;&quot;app:tabPadding=&quot;&quot; 设置Tab指示器TabLayout的指示器默认颜色是color.xml中的colorAccent，通过TabLayout提供的自定义属性，可以设置指示器的高度和颜色，如果不想显示指示器（Indicator），可以将其高度设置为0dp或设置其颜色为透明，这里为演示，我就把显示指示器（Indicator）的高度提高，颜色改为刺眼的红眼，如下：123456&lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabIndicatorColor=&quot;@color/red&quot; app:tabIndicatorHeight=&quot;8dp&quot;/&gt; 设置Tab指示器样式 ####2. 设置Tab位置及显示模式TabLayout的显示模式（tabMode）默认是固定不可滚动（fixed），位置（tabGravity）默认填满（fill）整个TabLayout，我们先保持app:tabMode&#x3D;”fixed”，把tabGravity的值换成fill和center对比下，为了方便对比，我把背景也设置了。 1234567&lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabBackground=&quot;@color/colorPrimaryDark&quot; app:tabGravity=&quot;fill&quot; // 再换成center app:tabMode=&quot;fixed&quot;/&gt; 当tab比较多的时候，一个屏幕宽度容纳不下，这时候就需要让TabLayout可以横向滚动了，只需要修改app:tabMode&#x3D;”scrollable”即可。注意，当app:tabMode&#x3D;”scrollable”时，app:tabGravity&#x3D;””不管取什么值都不会生效。 1234567&lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabBackground=&quot;@color/colorPrimaryDark&quot; app:tabGravity=&quot;center&quot; app:tabMode=&quot;scrollable&quot;/&gt; ####3. 设置Tab文字样式上面的效果不好看，我想让它默认文字颜色为灰色，选中时文字为白色，文字大小为16sp，但TabLayout没有提供直接设置文字大小的属性，这时候就需要用到app:tabTextAppearance&#x3D;””了。操作如下：######在Style.xml中声明文字样式 1234&lt;style name=&quot;TabLayout.TabText&quot; parent=&quot;TextAppearance.Design.Tab&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;16sp&lt;/item&gt; &lt;item name=&quot;textAllCaps&quot;&gt;false&lt;/item&gt;&lt;/style&gt; 其中除了可以设置字体大小外，还可以设置英文是否都全部大写显示。textAllCaps的默认值为true，即英文全部大写。#####在布局文件中设置TabLayout的文字相关属性 123456789101112&lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabBackground=&quot;@color/colorPrimaryDark&quot; app:tabGravity=&quot;center&quot; app:tabMode=&quot;scrollable&quot; ... app:tabSelectedTextColor=&quot;@android:color/white&quot; app:tabTextAppearance=&quot;@style/TabLayout.TabText&quot; app:tabTextColor=&quot;@android:color/darker_gray&quot;/&gt; 好了，看看效果如何：好了，关于Tab的宽度、内间距等设置比较简单，自己需要的时候试试吧，这里就不演示了。####3、与ViewPager结合上面通过对TabLayout的单独使用学习了TabLayout的样式自定义、创建Tab及设置Tab的点击事件等，可以说常用的也就那些了，下面来看看TabLayout如何与ViewPager的结合使用。这种需求也是很常见的，界面顶部有一个标签栏，中下部是与标签对应的内容，可以左右滑动，同时标签也跟随其切换，相反的，在切换标签时，内容部分也会跟着变化，不太明白的可以参考下“今日头条”APP的首页界面。这样的效果就可以用TabLayout+ViewPager+Fragment来实现。#####1. 先在布局文件中放好TabLayout和ViewPager： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabBackground=&quot;@color/colorPrimaryDark&quot; app:tabMode=&quot;scrollable&quot; app:tabSelectedTextColor=&quot;@android:color/white&quot; app:tabTextColor=&quot;@android:color/darker_gray&quot;/&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; #####2. 在代码中设置TabLayout与ViewPager相互关联： 12345678910111213141516@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tab_layout); mTabLayout = (TabLayout) findViewById(R.id.tabLayout); mViewPager = (ViewPager) findViewById(R.id.viewPager); MyViewPagerAdapter adapter = new MyViewPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(adapter); // 适配器必须重写getPageTitle()方法 mTabLayout.setTabsFromPagerAdapter(adapter); // 监听TabLayout的标签选择，当标签选中时ViewPager切换 mTabLayout.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(mViewPager)); // 监听ViewPager的页面切换，当页面切换时TabLayout的标签跟着切换 mViewPager.setOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout));&#125; 这三句代码不难理解，就字面上的意思，但是这三句代码都已经过时，因为要关联TabLayout与ViewPager就得写三句代码似乎是麻烦了一点点（其实我觉得还好吧），所以TabLayout提供了可以通过一句代码搞定两者关联的方法：setupWithViewPager()，因此，上面的代码可以简化如下： 123456789101112@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tab_layout); mTabLayout = (TabLayout) findViewById(R.id.tabLayout); mViewPager = (ViewPager) findViewById(R.id.viewPager); MyViewPagerAdapter adapter = new MyViewPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(adapter); // 关联TabLayout与ViewPager，且适配器必须重写getPageTitle()方法 mTabLayout.setupWithViewPager(mViewPager);&#125; 来看下效果：关联TabLayout与ViewPager相当简单，只要注意ViewPager适配器需重写getPageTitle()方法，这里顺便贴出Demo中适配器的代码： 12345678910111213141516171819202122232425262728293031class MyViewPagerAdapter extends FragmentPagerAdapter &#123; private final String[] title = new String[]&#123; &quot;推荐&quot;, &quot;热点&quot;, &quot;视频&quot;, &quot;深圳&quot;, &quot;通信&quot;, &quot;互联网&quot;, &quot;问答&quot;, &quot;图片&quot;, &quot;电影&quot;, &quot;网络安全&quot;, &quot;软件&quot;&#125;; public MyViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int i) &#123; Fragment fragment = new TextFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;title&quot;, title[i]); fragment.setArguments(bundle); return fragment; &#125; @Override public int getCount() &#123; return title.length; &#125; @Override public CharSequence getPageTitle(int position) &#123; return title[position]; &#125;&#125; ####拓展上面部分是TabLayout的正规使用说明，而这部分是对TabLayout的进一步探索，同时将列出本人在这个过程中的探索思路，可以说是对TabLayout的进一步自定义吧。废话不多说，下面就直接开车了。假如，你手中的APP设计稿中有如下的三个需求那该怎么办： 为TabLayout添加分割线，且分割线距离上下存在间距。 选中时tab字体变大，未选中时tab字体变小。 指示器（Indicator）不要充满整个标签（Tab） 简单的说就是为TabLayout添加分割线、设置不同状态下的字体大小和指示器的“长度”，这些在TabLayout中并没有提供直接的修改方法，你可能会想，那我们对TabLayout进行源码分析，然后通过反射等手段拿到其中的控件来设置？不！有时候解决问题不要循规蹈矩，应该适当转变下思路，或许解决问题的方法并不需要去看源码那么困难（如果你是大神，就当我没说），下面看我操作： 从结构上我们可以知道TabLayout（就是HorizontalScrollView）并不是直接就包裹这些Tab的，而是包裹了一个LinearLayout，然后这些Tab放在这个LinearLayout中，此外，可以发现Tab里包含了一个TextView，到这里对前面2个需求是不是有点想法了呢？######为TabLayout添加分割线LinearLayout自带就有设置分割线的方法，我们可以通过它来添加分割线，也没什么好说的，直接上代码： 1234567mLinearLayout = (LinearLayout) mTabLayout.getChildAt(0);// 在所有子控件的中间显示分割线（还可能只显示顶部、尾部和不显示分割线）mLinearLayout.setShowDividers(LinearLayout.SHOW_DIVIDER_MIDDLE);// 设置分割线的距离本身（LinearLayout）的内间距mLinearLayout.setDividerPadding(20);// 设置分割线的样式mLinearLayout.setDividerDrawable(ContextCompat.getDrawable(this, R.drawable.divider_vertical)); divider_vertical.xml： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;#ccc&quot;/&gt; &lt;size android:width=&quot;1dp&quot; /&gt;&lt;/shape&gt; 这样，分割线就有了。看起来有点怪是吧，这是因为我们前面设置的app:tabBackground&#x3D;”@color&#x2F;colorPrimaryDark”只是给Tab设置了背景色，而不是给Tab的父级控件LinearLayout设置，这个LinearLayout默认的背景色是白色，所以才会是这个样子，解决方法自然就是给LinearLayout设置跟Tab一样的背景色就好了。 123mLinearLayout = (LinearLayout) mTabLayout.getChildAt(0);...mLinearLayout.setBackgroundColor(getResources().getColor(R.color.colorPrimaryDark)); 这样就完美的为TabLayout设置分割线了。####为TabLayout设置不同状态下的字体大小（并不能成功）用同样的方式拿到Tab中的文本控件，判断当前是否被选中，再对该文本控件进行字体大小设置就欧了。借助上面拿到的用来包裹Tab的LinearLayout（mLinearLayout），遍历LinearLayout中的子控件，拿到一个个的子view（即Tab），再从Tab中拿到文本控件设置文字大小。 123456789101112131415161718192021222324252627// 默认让所有没有选中的Tab的文字设置为小字体for (int i = 0; i &lt; mTabLayout.getTabCount(); i++) &#123; ((TextView) ((LinearLayout) mLinearLayout.getChildAt(i)).getChildAt(1)).setTextSize(10); // 也可以这么写，一样的 // ((TextView) ((LinearLayout) ((LinearLayout) mTabLayout.getChildAt(0)).getChildAt(i)).getChildAt(0)).setTextSize(12);&#125;// 再把当前被选中的Tab文字设置为大字体((TextView) ((LinearLayout) mLinearLayout.getChildAt(mTabLayout.getSelectedTabPosition())).getChildAt(1)).setTextSize(30);// 当选中的Tab切换时，再调整Tab的字体大小mTabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; ((TextView) ((LinearLayout) mLinearLayout.getChildAt(tab.getPosition())).getChildAt(1)).setTextSize(30); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; ((TextView) ((LinearLayout) mLinearLayout.getChildAt(tab.getPosition())).getChildAt(1)).setTextSize(12); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125;&#125;); 上面代码中把得到的Tab强转成LinearLayout，这是因为Tab实际上是TabView，而TabView继承自LinearLayout，所以可以这样转换，我们可以看下TabLayout的newTab()方法：然而事实并不如意，完全没有效果，去看了下源码，也不是很确定，我的猜想是这样的，当我们对Tab中的文本控件设置字体大小后，TabView的onMeasuer()方法会被重新调用，而这个方法里就对文字大小重新进行赋值，导致文字大小没法按上面的方式进行修改。所以，文字的大小只能通过Style的方法去修改，且只能统一设置选中和未选中的文字大小，故，这个需求没法完成。####自定义指示器长度其实这有点标题党的意思了，TabLayout的指示器长度没法指定，它原本多长就是多长，但可以通过设置Tab外间距的方式，让指示器看起来像是与Tab保持一定距离，这里我在网上找到了方法，方法如下： 1234567891011121314151617181920212223242526272829303132333435// 设置TabLayout的“长度”setIndicator(mTabLayout,10,10);// 具体方法（通过反射的方式）public void setIndicator(TabLayout tabs, int leftDip, int rightDip) &#123; Class&lt;?&gt; tabLayout = tabs.getClass(); Field tabStrip = null; try &#123; tabStrip = tabLayout.getDeclaredField(&quot;mTabStrip&quot;); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; tabStrip.setAccessible(true); LinearLayout llTab = null; try &#123; llTab = (LinearLayout) tabStrip.get(tabs); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; int left = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, leftDip, Resources.getSystem().getDisplayMetrics()); int right = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, rightDip, Resources.getSystem().getDisplayMetrics()); for (int i = 0; i &lt; llTab.getChildCount(); i++) &#123; View child = llTab.getChildAt(i); child.setPadding(0, 0, 0, 0); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT, 1); params.leftMargin = left; params.rightMargin = right; child.setLayoutParams(params); child.invalidate(); &#125;&#125; 这个setIndicator()方法主要是通过反射的方式，先拿到mTabStrip（其实就是TabLayout直接包裹的LinearLayout），再遍历出mTabStrip中的子控件Tab，再设置Tab的外间距，为了证明就是设置了Tab的外间距，这里我分别对mTabStrip设置了背景色和不设置其背景色，来看看对比：设置了背景色看起来效果还马马虎虎吧，但这样的方式没办法让指示器的长度比文字长度短（无奈~）。好了，不管这个了，既然我前面说了mTabStrip其实就是TabLayout直接包裹的LinearLayout，那通过这个LinearLayout来设置也是可以的，证明一下： 1234567891011121314// 得到TabLayout包裹的LinearLayout并设置背景色mLinearLayout = (LinearLayout) mTabLayout.getChildAt(0);mLinearLayout.setBackgroundColor(getResources().getColor(R.color.colorPrimaryDark));...// 设置LinearLayout中子View(Tab)的外间距int left = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, Resources.getSystem().getDisplayMetrics());int right = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, Resources.getSystem().getDisplayMetrics());for (int i = 0; i &lt; mLinearLayout.getChildCount(); i++) &#123; View tabView = mLinearLayout.getChildAt(0); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT, 1); params.leftMargin = left; params.rightMargin = right; tabView.setLayoutParams(params);&#125; 最后附上Demo链接https://github.com/GitLqr/MaterialDesignDemo 作者：CSDN_LQR链接：https://www.jianshu.com/p/bbefb97cccdd","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/Material-Design新控件/TextInputLayout/","text":"#####介绍：首先来看一下TextInputLayout，TextInputLayout 是EditText(或者EditText子类)的一个包装类，它主要用于在用户输入文本的时候显示一个浮动标签，也支持显示错误信息和字符计数等功能。同样它也支持密码可见切换按钮，通过setPasswordVisibilityToggleEnabled(boolean)API 或者 xml 中的属性，如果设置该属性为可用（enable）,那么当EditText 显示设置的密码时，会显示一个切换密码可见和隐藏的按钮。#####TextInputLayout 重要方法和属性: app:counterEnabled 字符计数是否可用代码中对应的方法为：setCounterEnabled（boolean） app:counterMaxLength 计数最大的长度代码中对应的方法为：setCounterMaxLength（int ） app:counterOverflowTextAppearance 计数超过最大长度时显示的文本样式 app:counterTextAppearance 显示的计数的文本样式。 app:errorEnabled 显示错误信息是否可用 app:errorTextAppearance 显示错误信息的文本样式 android:hint 浮动标签代码对应方法：setHint(CharSequence) app:hintAnimationEnabled 控制是否需要浮动标签的动画代码对应方法：setHintAnimationEnabled(boolean) app:hintEnabled 控制是否显示浮动标签代码对应方法：setHintEnabled(boolean) app:hintTextAppearance 浮动标签的文本样式代码对应方法：setHintTextAppearance(int) app:passwordToggleDrawable 密码可见切换图标代码对应方法：setPasswordVisibilityToggleDrawable(int)或者setPasswordVisibilityToggleDrawable(Drawable) app:passwordToggleEnabled 控制是否显示密码可见切换图标代码对应方法：setPasswordVisibilityToggleEnabled(boolean) app:counterOverflowTextAppearance 设置超出字符数后提示文字的颜色，如果不设置默认为@color&#x2F;colorAccent的颜色 #####基础用法: 123456789101112131415161718&lt;android.support.design.widget.TextInputLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:hint=&quot;账号&quot; android:paddingLeft=&quot;16dp&quot; android:scrollbarAlwaysDrawHorizontalTrack=&quot;true&quot; app:counterMaxLength=&quot;8&quot; app:counterOverflowTextAppearance=&quot;@style/TextOverCount&quot;&gt; &lt;android.support.design.widget.TextInputEditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:textColor=&quot;@color/black&quot; android:textColorHint=&quot;@color/gray&quot; android:textSize=&quot;14dp&quot;/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; ######修改默认样式：改变TextInputLayout默认下划线颜色和点击时颜色，默认hint颜色，在TextInputLayout控件设置textColorHint设置默认hint颜色 在EditText控件中设置android:theme属性设置 style 12345678910111213141516171819202122232425&lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/login_textinput_id&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textColorHint=&quot;@color/mintcream&quot;&gt; &lt;!--android:textColorHint&quot; 默认hint字体及下划线颜色--&gt; &lt;EditText android:id=&quot;@+id/login_userId&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;请输入账号&quot; android:inputType=&quot;number&quot; android:maxLines=&quot;1&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;@color/darkorange&quot; android:theme=&quot;@style/TextAppTheme&quot; /&gt; &lt;!--textColor设置输入时字体颜色--&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;!--改变TextInputLayout 里面的EditText默认下划线和点击时下划线的颜色--&gt; &lt;style name=&quot;TextAppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;colorControlNormal&quot;&gt;@color/gray&lt;/item&gt;&lt;!--默认显示下划线的颜色--&gt; &lt;item name=&quot;colorControlActivated&quot;&gt;@color/gray&lt;/item&gt;&lt;!--点击后下划线的颜色--&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/qmui_config_color_red&lt;/item&gt; &lt;/style&gt; ######超出字符数后的提示样式： 123&lt;style name=&quot;TextOverCount&quot; parent=&quot;Base.TextAppearance.AppCompat.Light.Widget.PopupMenu.Small&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;@android:color/holo_red_light&lt;/item&gt; &lt;/style&gt; #####设置错误提示文字 12345678910111213141516171819202122232425262728293031323334353637&lt;android.support.design.widget.TextInputLayout android:layout_width=&quot;match_parent&quot; android:layout_marginTop=&quot;20dp&quot; app:errorEnabled=&quot;true&quot; //设置为true android:id=&quot;@+id/textinputlayout_email&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:hint=&quot;请输入邮箱&quot; android:id=&quot;@+id/et_email&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.design.widget.TextInputLayout&gt;editText_email=findViewById(R.id.et_email); textInputLayout =findViewById(R.id.textinputlayout_email); editText_email.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; if(!RegexUtils.isEmail(charSequence))&#123; textInputLayout.setError(&quot;邮箱格式错误&quot;); textInputLayout.setErrorEnabled(true); &#125;else &#123; textInputLayout.setErrorEnabled(false); &#125; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125; &#125;); ######设置密码是否可见 1234567891011121314&lt;android.support.design.widget.TextInputLayout android:layout_width=&quot;match_parent&quot; android:layout_marginTop=&quot;20dp&quot; app:errorEnabled=&quot;true&quot; app:passwordToggleEnabled=&quot;true&quot; //设置为true android:id=&quot;@+id/textinputlayout_password&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:hint=&quot;请输入密码&quot; android:id=&quot;@+id/et_password&quot; android:inputType=&quot;textPassword&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"}]},{"path":"wiki/Android Application/rxjava2/Rxjava2的基本使用/","text":"在Rxjava使用之前记得在Gradle中添加依赖引入 12implementation &quot;io.reactivex.rxjava2:rxjava:2.1.12&quot;implementation &quot;io.reactivex.rxjava2:rxandroid:2.0.2&quot; ###观察者的回调方法： onSubscribe() 当观察者被订阅时回调 onNext() 当观察者受到onNext事件时回调 onComplete() 当观察者收到onNext事件时回调 onError()当观察者受到onError事件时回调","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"rxjava2","slug":"Android-Application/rxjava2","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/rxjava2/"}]},{"path":"wiki/Android Application/rxjava2/rxjava2基本概念/","text":"###Rxjava简述 rxjava是一个在java虚拟机上，使用可观察的序列构成基于事件的，异步的程序库白话：类似于Google提供 给我我们使用的AsyncTask，它能在异步线程处理后传递到UI线程中处理，现在基本上已经由Rxjava替换了AsyncTask来使用 ###RxAndroid简述 RxAndroid是基于RxJava开发出的一套适用于Android开发的辅助库白话：RxJava通过RxAndroid的辅助，使得原本RxJava只在Java上运行的程序也能在Android上开发 ###设计模式中的观察者模式 观察者模式就是RxJava使用的核心点，掌握这个模式，可以理解RxJava更简单，观察者模式简单的说就是：订阅-发布；的模式，举一个例子说，当你订阅某家牛奶店的早餐奶（订阅过程），只要牛奶店生成牛奶，便会给你送过去（发布过程）。这里的牛奶店只有一家，但是订阅的人可以很多。这是一种一对多的关系，只要牛奶店发布牛奶，那么订阅的人就会收到牛奶。换成RxJava里面的话，牛奶店就是被观察者（ObServable）,订阅的人就是观察者（ObServer），根据这个例子，我们通过带啊来实现这逻辑#####1. 创建观察者和被观察者 1234567891011121314//被观察者 public interface ObServable&#123; //订阅 public subscribe(ObServer obServer); //取消订阅 void cancel(ObServer obServer); //发布 void onNext(); &#125; //观察者 public interface ObServer&#123; //接收通知 void onNotify(); &#125; #####2.实现观察者和被观察者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 //牛奶店 public class MilkFactory implements ObServable&#123; private List&lt;ObServer&gt; ObServers; public MilkFactory()&#123; this.ObServers=new ArrayList&lt;&gt;(); &#125; @Override public void subscribe(ObServer obServer)&#123; ObServers.add(obServer); &#125; @Override public void cancel(ObServer obServer) &#123; ObServers.remove(obServer); &#125; @Override public void onNext() &#123; for (ObServer obServer:obServables) &#123; obServer.onNotify(); &#125; &#125; &#125; //顾客 public class MilkConsumer implements Observer&#123; private String name; public MilkConsumer(String name)&#123; this.name=name; &#125; @Override public void onNotify()&#123; System.out.println(this.name+&quot;收到牛奶&quot;); &#125; &#125;//观察者订阅被观察者 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ObServable milkFactory=new MilkFactory(); ObServer milkConsumer1=new MilkConsumer(&quot;顾客1&quot;); ObServer milkConsumer2=new MilkConsumer(&quot;顾客2&quot;); //订阅过程 milkFactory.subscribe(milkConsumer1); milkFactory.subscribe(milkConsumer2); //发布过程 System.out.println(&quot;此时，牛奶店已经产出早餐奶，通知并发送给各位顾客&quot;); milkFactory.onNext(); &#125; //查看程序输出的结果 //此时，牛奶店已经产出早餐奶，通知并发送给各位顾客 //顾客1 收到牛奶 //顾客2 收到牛奶 ###Rxjava中的观察者模式 RxJava中的观察者模式也是跟例子中的大同小异,也是通过创建出观察者和被观察者,然后进行订阅事件，只不过这里的观察者和被观察者已经不在是我们自定义的两个接口类，而是通过RxJava提供好的观察者和被观察者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //拿到被观察者 ObServable&lt;String&gt; obServable=getObServable(); //拿到观察者 ObServer&lt;String&gt; obServer=getObServer(); //订阅 obServable.subscribe(obServer); &#125; public static Observable&lt;String&gt; getObServable()&#123; return Observable.create(new ObServableOnSubscribe&lt;String&gt;()&#123; @Override public void subscribe(@NonNull ObServableEmitter&lt;String&gt; e) throws Exception&#123; e.onNext(&quot;事件1&quot;); e.onNext(&quot;事件2&quot;);//onNext()类似于下一步 e.onComplete();//onComplete()完成 &#125; &#125;); &#125;public static Observer&lt;String&gt; getObServer()&#123; return new ObServer&lt;String&gt;()&#123; Disposable disposable=null; @Override public void onSubscribe(Disposable d)&#123; disposable=d; &#125; @Override public void onNext(String s)&#123; System.out.println(&quot;onNext=&quot;+s); if (s.equals(&quot;取消关注&quot;))&#123; //断开订阅 disposable.dispose(); &#125; &#125; @Override public void onError()&#123; &#125; @Override public void onComplete()&#123; System.out.println(&quot;onComplete&quot;); &#125; &#125;; &#125; //执行结果： //onNext=事件1 //onNext=事件2 //onComplete","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"rxjava2","slug":"Android-Application/rxjava2","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/rxjava2/"}]},{"path":"wiki/其他笔记/Flutter/Flutter(Android-混合开发)/","text":"Flutter 支持作为 android Moudle 出现在项目中.这样就可以在 已有的项目中 使用.虽然现在Flutter 比较受关注,但是和weex 一样 ,大部分都只是在观望 不是真正的进行使用.所以 如果用还是混合开发 原生+Flutter 方式比较合适(自我感觉).写一个demo 进行Android及Flutter 交互.(IOS 方法基本一致).Flutter 调用 android 硬件的插件还比较匮乏 比如 各种传感器, 自定义相机 所以就会用到 Flutter 调用android 及android 原生调用 Flutter的方法. #####本例子中会实现. 原有的android 应用程序嵌入 FlutterView Flutter 代码调用Android 原生方法进行页面跳转及传值 Android原生 调用 Flutter 方法 进行传值 #####android引入flutter moudle在当前project下 运行命令flutter create -t module my_flutter（my_flutter为生成的flutter module名称） 在工程的settings.gradle增加以下配置 123456include &#x27;:app&#x27;setBinding(new Binding([gradle: this])) // newevaluate(new File( // new settingsDir.parentFile, // new &#x27;ToyamaFinance/my_flutter/.android/include_flutter.groovy&#x27; //ToyamaFinance项目名称 my_flutter FlutterMoudle名称)) 2.在app （假如你的Android应用名称为app）的build.gradle文件下dependencies增加如下依赖implementation project(&#39;:flutter&#39;)其中flutter工程为创建Flutter module过程自动生成的,注意就是flutter注意 其中 minSdkVersion 需要至少为16，否则会报错 ######生成的工程结构如下：#####android端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.guoshikeji.toyamafinance.flutter_activitys;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.Window;import android.widget.RelativeLayout;import com.guoshikeji.toyamafinance.R;import com.guoshikeji.toyamafinance.activity.launch.LoginActivity;import com.guoshikeji.toyamafinance.activity.user.ShareDialogActivity;import com.guoshikeji.toyamafinance.application.MyApplication;import com.guoshikeji.toyamafinance.control.utils.SerializeUtils;import com.guoshikeji.toyamafinance.mode.bean.UserBean;import com.guoshikeji.toyamafinance.mode.constants.Constants;import com.qmuiteam.qmui.util.QMUIStatusBarHelper;import io.flutter.facade.Flutter;import io.flutter.plugin.common.EventChannel;import io.flutter.plugin.common.MethodCall;import io.flutter.plugin.common.MethodChannel;import io.flutter.view.FlutterView;public class FlutterProjectsDetails extends AppCompatActivity &#123; //发送与接收的key,需保证唯一，不一定是包名,并且android和flutter的key需一致 不然会报错 public static final String FlutterToAndroidCHANNEL = &quot;com.guoshikeji.toandroid/project_details&quot;; public static final String AndroidToFlutterCHANNEL= &quot;com.guoshikeji.toflutter/project_details&quot;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //requestWindowFeature(Window.FEATURE_NO_TITLE); //MyApplication.getInstance().addActivity(this); //QMUIStatusBarHelper.translucent(this, Color.WHITE); //MyApplication.getInstance().addActivity(this); setContentView(R.layout.activity_flutter_default); RelativeLayout rl_flutter_defalut = findViewById(R.id.rl_flutter_defalut); Intent intent = getIntent(); int project_id = intent.getIntExtra(&quot;project_id&quot;, 0); Log.e(&quot;tyl&quot;,&quot;project_id1=&quot;+project_id); //加载flutter界面 getLifecycle方法需要activity继承至AppCompatActivity FlutterView flutterView = Flutter.createView(this, getLifecycle(), &quot;route1&quot;); //将view添加到原生界面中 rl_flutter_defalut.addView(flutterView); //android向flutter发送消息 new EventChannel(flutterView, AndroidToFlutterCHANNEL) .setStreamHandler(new EventChannel.StreamHandler() &#123; @Override public void onListen(Object o, EventChannel.EventSink eventSink) &#123; String androidParmas = project_id+&quot;&quot;; eventSink.success(androidParmas); &#125; @Override public void onCancel(Object o) &#123; &#125; &#125;); //接收flutter发送过来的消息 new MethodChannel(flutterView, FlutterToAndroidCHANNEL).setMethodCallHandler(new MethodChannel.MethodCallHandler() &#123; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; Log.e(&quot;tyl&quot;,&quot;flutter_back=&quot;+methodCall.method); //接收来自flutter的指令oneAct if (methodCall.method.equals(&quot;finish&quot;)) &#123; MyApplication.getInstance().removeActivity(FlutterProjectsDetails.this); result.success(&quot;success&quot;); &#125; else if (methodCall.method.equals(&quot;share&quot;)) &#123; Object object = SerializeUtils.readServiceListFromFile(Constants.USER_INFO); if (object != null) &#123; Intent intent = new Intent(FlutterProjectsDetails.this, ShareDialogActivity.class); intent.putExtra(ShareDialogActivity.MODE_ORIENTATION, 1); startActivity(intent); &#125; else &#123; startActivity(new Intent(FlutterProjectsDetails.this, LoginActivity.class)); &#125; result.success(&quot;success&quot;); &#125; else &#123; result.notImplemented(); &#125; &#125; &#125;); &#125;&#125; #####Flutter端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import &#x27;dart:ui&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter/services.dart&#x27;;import &#x27;dart:async&#x27;;void main() =&gt; runApp(new MyApp());Widget _widgetForRoute(String route) &#123; switch (route) &#123; case &#x27;route1&#x27;: return MyHomePage(title: &#x27;Flutter Demo Home Page1&#x27;); case &#x27;route2&#x27;: return MyHomePage(title: &#x27;Flutter Demo Home Page2&#x27;); default: return MyHomePage(title: &#x27;Flutter Demo Home Page2&#x27;); &#125;&#125;class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Flutter Demo&#x27;, theme: ThemeData( primarySwatch: Colors.blue, ), home: _widgetForRoute(window.defaultRouteName), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; //获取到插件与原生的交互通道 需要和android的key一致 static const toAndroidPlugin = const MethodChannel(&#x27;com.guoshikeji.toandroid/project_details&#x27;); static const fromAndroiPlugin = const EventChannel(&#x27;com.guoshikeji.toflutter/project_details&#x27;); StreamSubscription _fromAndroiSub; var _nativeParams; @override void initState() &#123; // TODO: implement initState super.initState(); _startfromAndroiPlugin();//在initState中初始化 &#125; //注册从android获取消息的监听 void _startfromAndroiPlugin()&#123; if(_fromAndroiSub == null)&#123; _fromAndroiSub = fromAndroiPlugin.receiveBroadcastStream() .listen(_onfromAndroiEvent,onError: _onfromAndroiError); &#125; &#125; //获取成功的方法 void _onfromAndroiEvent(Object event) &#123; setState(() &#123; _nativeParams = event; &#125;); &#125; //获取失败的方法 void _onfromAndroiError(Object error) &#123; setState(() &#123; _nativeParams = &quot;error&quot;; print(error); &#125;); &#125; //发送消息 Future&lt;Null&gt; _jumpToNative() async &#123; String result = await toAndroidPlugin.invokeMethod(&#x27;withoutParams&#x27;); print(result); &#125; //发送带参数的消息 Future&lt;Null&gt; _jumpToNativeWithParams() async &#123; Map&lt;String, String&gt; map = &#123; &quot;flutter&quot;: &quot;这是一条来自flutter的参数&quot; &#125;; String result = await toAndroidPlugin.invokeMethod(&#x27;withParams&#x27;, map); print(result); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( // Here we take the value from the MyHomePage object that was created by // the App.build method, and use it to set our appbar title. title: Text(widget.title), ), body: Center( child: new ListView( children: &lt;Widget&gt;[ new Padding( padding: const EdgeInsets.only(left: 10.0, top: 10.0, right: 10.0), child: new RaisedButton( textColor: Colors.black, child: new Text(&#x27;跳转到原生界面&#x27;), onPressed: () &#123; _jumpToNative(); &#125;), ), new Padding( padding: const EdgeInsets.only( left: 10.0, top: 10.0, right: 10.0), child: new RaisedButton( textColor: Colors.black, child: new Text(&#x27;跳转到原生界面(带参数)&#x27;), onPressed: () &#123; _jumpToNativeWithParams(); &#125;), ), new Padding( padding: const EdgeInsets.only( left: 10.0, top: 10.0, right: 10.0), child: new Text(&#x27;这是一个从原生获取的参数：$_nativeParams&#x27;), ) , new Padding( padding: const EdgeInsets.only( left: 10.0, top: 10.0, right: 10.0), child: new Text(&#x27;Flutter floatingActionButton 点击次数$_counter&#x27;), ) ], ) ), ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Android-Studio配置Flutter/","text":"#####1 下载flutter开发包 windows下载地址官方文档 ######安装注意： 安装AndroidStudio3.0版本或更新版本 操作系统：Windows 7 SP1或更高版本（64位） 磁盘空间：400 MB（不包括IDE &#x2F;工具的磁盘空间） 解压缩zip文件并将其包含flutter在Flutter SDK的所需安装位置（例如C:\\src\\flutter;不要将Flutter安装在C:\\Program Files\\需要提升权限的目录中）。 flutter_console.bat在flutter目录中找到该文件。双击启动它。 #####2 配置环境变量在系统环境变量path中添加刚刚下载的flutter的路径。将bin文件路径添加至path中win10添加效果：#####3 flutter 文件目录中双击flutter_console.bat输入flutter doctor命令flutter doctor 会自动检测当前开发环境配置。&#x2F;&#x2F;这时还会报几个错误，暂时不予理会 还需在studio中配置dart和flutter插件#####4 Android Studio安装Dart插件打开Android Studio -&gt; File -&gt; Settings -&gt; Plugins搜索Dart插件 在右侧点击Install即可。同样的步骤搜索Flutter插件安装即可 安装flutter时，因网络延迟可能会导致下载失败，我是多次下载后才成功的！ #####注意：对于国内开发者创建项目可能会卡在Create flutter .. 底部显示 building Symbols…状态。查看Console会提示Got socket error trying to find package at http://pub.dartlang.org######解决办法：在系统环境变量中新建名为PUB_HOSTED_URL 值为https://pub.flutter-io.cn 的环境变量和新建名为FLUTTER_STORAGE_BASE_URL值为https://storage.flutter-io.cn的环境变量。然后重新打开项目即可#####5 studio中配置dart和flutter的路径#####6 创建Flutter项目插件安装完成后，重启Android Studio新建项目会发现增加了创建Flutter项目的选项。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Flutter-控件之-MaterialApp/","text":"MaterialApp 代表使用纸墨设计（Material Design）风格的应用。里面包含了纸墨设计风格应用所需要的基本控件。 MaterialApp 主要属性如下： title ： 在任务管理窗口中所显示的应用名字 theme ： 应用各种 UI 所使用的主题颜色 color ： 应用的主要颜色值（primary color），也就是安卓任务管理窗口中所显示的应用颜色 home ： 应用默认所显示的界面 Widget routes ： 应用的顶级导航表格，这个是多页面应用用来控制页面跳转的，类似于网页的网址 initialRoute ：第一个显示的路由名字，默认值为 Window.defaultRouteName onGenerateRoute ： 生成路由的回调函数，当导航的命名路由的时候，会使用这个来生成界面 onLocaleChanged ： 当系统修改语言的时候，会触发å这个回调 navigatorObservers ： 应用 Navigator 的监听器 debugShowMaterialGrid ： 是否显示 纸墨设计 基础布局网格，用来调试 UI 的工具 showPerformanceOverlay ： 显示性能标签，https://flutter.io/debugging/#performanceoverlay checkerboardRasterCacheImages 、showSemanticsDebugger、debugShowCheckedModeBanner 各种调试开关 下面将介绍重要的几个属性。 title这个和启动图标名字是不一样的，和当前 Activity 的名字也是不一样的。 这个 Title 是用来定义任务管理窗口界面所看到应用名字的。在原生 Android 系统中点击圆圈 Home 按钮右边的方块按钮就会打开多任务切换窗口。 theme定义应用所使用的主题颜色，在纸墨设计中定义了 primaryColor、accentColor、hintColor 等颜色值。可以通过这个来指定一个 ThemeData 定义应用中每个控件的颜色。 home这个是一个 Widget 对象，用来定义当前应用打开的时候，所显示的界面。 color定义系统中该应用的主要颜色 routes定义应用中页面跳转规则。 该对象是一个 Map&lt;String, WidgetBuilder&gt;。当使用 Navigator.pushNamed 来路由的时候，会在 routes 查找路由名字，然后使用 对应的 WidgetBuilder 来构造一个带有页面切换动画的 MaterialPageRoute。如果应用只有一个界面，则不用设置这个属性，使用 home 设置这个界面即可。 如果 home 不为 null，当 routes 中包含 Navigator.defaultRouteName（&#39;/&#39;） 的时候会出错，两个都是 home 冲突了。 如果所查找的路由在 routes 中不存在，则会通过 onGenerateRoute 来查找。 initialRoute指定默认显示的路由名字，默认值为 Window.defaultRouteName onGenerateRoute路由回调函数","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）/","text":"#####1 继续关系： BoxDecoration:实现边框、圆角、阴影、形状、渐变、背景图像 ShapeDecoration:实现四个边分别指定颜色和宽度、底部线、矩形边色、圆形边色、体育场（竖向椭圆）、 角形（八边角）边色 FlutterLogoDecoration:实现Flutter图片 UnderlineTabindicator:下划线 #####2 介绍：一个背景装饰对象，相当于Android中的shape.xml，定制各种各样的背景（边框、圆角、阴影、形状、渐变、背景图像）。#####3 BoxDecoration例子： 1234567891011//构造方法： const BoxDecoration(&#123; this.color, // 底色 this.image, // 图片 this.border, 边色 this.borderRadius, // 圆角度 this.boxShadow, // 阴影 this.gradient, // 渐变 this.backgroundBlendMode, // 混合Mode this.shape = BoxShape.rectangle, // 形状 &#125;) ######1.边框+圆角: 123456decoration: new BoxDecoration( border: new Border.all(color: Color(0xFFFF0000), width: 0.5), // 边色与边宽度 color: Color(0xFF9E9E9E), // 底色 // borderRadius: new BorderRadius.circular((20.0)), // 圆角度 borderRadius: new BorderRadius.vertical(top: Radius.elliptical(20, 50)), // 也可控件一边圆角大小), ######2.阴影： 12345decoration: new BoxDecoration( border: new Border.all(color: Color(0xFFFF0000), width: 0.5), // 边色与边宽度// 生成俩层阴影，一层绿，一层黄， 阴影位置由offset决定,阴影模糊层度由blurRadius大小决定（大就更透明更扩散），阴影模糊大小由spreadRadius决定 boxShadow: [BoxShadow(color: Color(0x99FFFF00), offset: Offset(5.0, 5.0), blurRadius: 10.0, spreadRadius: 2.0), BoxShadow(color: Color(0x9900FF00), offset: Offset(1.0, 1.0)), BoxShadow(color: Color(0xFF0000FF))],), ######3.渐变（环形、扫描式、线性）： 123456789decoration: new BoxDecoration( border: new Border.all(color: Color(0xFFFFFF00), width: 0.5), // 边色与边宽度// 环形渲染 gradient: RadialGradient(colors: [Color(0xFFFFFF00), Color(0xFF00FF00), Color(0xFF00FFFF)],radius: 1, tileMode: TileMode.mirror)//扫描式渐变// gradient: SweepGradient(colors: [Color(0xFFFFFF00), Color(0xFF00FF00), Color(0xFF00FFFF)], startAngle: 0.0, endAngle: 1*3.14)// 线性渐变// gradient: LinearGradient(colors: [Color(0xFFFFFF00), Color(0xFF00FF00), Color(0xFF00FFFF)], begin: FractionalOffset(1, 0), end: FractionalOffset(0, 1))), ######4.背景图像： 123456789decoration: new BoxDecoration( border: new Border.all(color: Color(0xFFFFFF00), width: 0.5), // 边色与边宽度 image: new DecorationImage( image: new NetworkImage(&#x27;https://avatar.csdn.net/8/9/A/3_chenlove1.jpg&#x27;), // 网络图片 // image: new AssetImage(&#x27;graphics/background.png&#x27;), 本地图片 fit: BoxFit.fill // 填满 // centerSlice: new Rect.fromLTRB(270.0, 180.0, 1360.0, 730.0),// 固定大小 ),), ######5.ShapeDecoration例子： 12345678//构造方法：const ShapeDecoration(&#123; this.color, this.image, this.gradient, this.shadows, @required this.shape,&#125;) 除了shape，其他与BoxDecoration一致，shape研究： 1234567891011121314151617decoration: new ShapeDecoration( color: Color(0xFFFF00FF), // 底色 // 统一四边颜色和宽度 shape: Border.all(color: Color(0xFF00FFFF),style: BorderStyle.solid,width: 2)// 四个边分别指定颜色和宽度， 当只给bottom时与UnderlineInputBorder一致效果// shape: Border(top: b, bottom: b, right: b, left: b)// 底部线// shape: UnderlineInputBorder( borderSide:BorderSide(color: Color(0xFFFFFFFF), style: BorderStyle.solid, width: 2))// 矩形边色// shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10)), side: BorderSide(color: Color(0xFFFFFFFF), style: BorderStyle.solid, width: 2))// 圆形边色// shape: CircleBorder(side: BorderSide(color: Color(0xFFFFFF00), style: BorderStyle.solid, width: 2))// 体育场（竖向椭圆）// shape: StadiumBorder(side: BorderSide(width: 2, style: BorderStyle.solid, color: Color(0xFF00FFFF))// 角形（八边角）边色// shape: BeveledRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10)), side: BorderSide(color: Color(0xFFFFFFFF), style: BorderStyle.solid, width: 2))), ######6.FlutterLogoDecoration例子： 12345678//构造方法const FlutterLogoDecoration(&#123; this.lightColor = const Color(0xFF42A5F5), // Colors.blue[400] this.darkColor = const Color(0xFF0D47A1), // Colors.blue[900] this.textColor = const Color(0xFF616161), this.style = FlutterLogoStyle.markOnly, this.margin = EdgeInsets.zero,&#125;) ######7. UnderlineTabindicator例子： 12345//构造方法：const UnderlineTabIndicator(&#123; this.borderSide = const BorderSide(width: 2.0, color: Colors.white), this.insets = EdgeInsets.zero,&#125;) 这个比较简单就是加下划线，可以设置Insets值（控制下划高底，左右边距） 1234decoration: new UnderlineTabIndicator( borderSide: BorderSide(width: 2.0, color: Colors.white), insets: EdgeInsets.fromLTRB(0,0,0,10)),","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Flutter-目录结构和项目资源/","text":"#####目录结构 当使用flutter create myapp 创建项目后，会自动生成初始化代码。 下面介绍一下代码的目录。 1234567891011myapp ┬ ├ android - 包含 Android 特定的文件。 ├ build - 存储 iOS 和 Android 构建文件。 ├ ios - 包含 iOS 特定的文件。 ├ lib - 应用源文件。 ┬ └ src - 包含额外的源文件。 └ main.dart - 程序运行入口文件。 ├ test - 测试文件。 └ pubspec.yaml - 包含 Flutter 应用程序的包数据。 新建Flutter项目的结构和原生android的工程结构不一样，我们不能用android那种多module 多lib的结构去创建module和lib，因为我们的代码都是在lib目录里面完成的，除非要用到原生交互的代码，你可以在android目录里面去写，然后在lib目录里面去引用这些交互的代码。######android目录这里存放的是Flutter与android原生交互的一些代码，这个路径的文件和创建单独的Android项目的基本一样的。不过里面的代码配置跟单独创建Android项目有些不一样。######ios目录这里存放的是Flutter与ios原生交互的一些代码。######lib目录这里存放的是Dart语言编写的代码，这里是核心代码。不管是Android平台，还是ios平台，安装配置好环境，可以把dart代码运行到对应的设备或模拟器上面。刚才的示例中，就是运行的lib目录下的main.dart这个文件。我们可以在这个lib目录下面创建不同的文件夹，里面存放不同的文件，使用Dart语言写我们的自己的代码。######pubspec.yaml文件 这个是配置依赖项的文件，比如配置远程pub仓库的依赖库，或者指定本地资源（图片、字体、音频、视频等）。例如刚才创建的项目的pubspec.yaml里面的：cupertino_icons: ^0.1.2，表示项目要依赖cupertino_icons这个库，版本号为0.1.2。#####资源像图片、视频、文字等这些资源文件，在 Flutter 里是可以直接引用的，不过需要对资源进行声明式说明。在 pubspec.yaml 里进行声明。 1234flutter: assets: - assets/my_icon.png - assets/background.png 在代码里这样进行引用。 1new Image(image: new AssetImage(&#x27;assets/background.png&#x27;)); 如果资源是来至网络的而不是本地的，则需要使用 image.network。 1new Image.network(&#x27;https://flutter.io/images/owl.jpg&#x27;);","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Flutter之Scaffold/","text":"Scaffold 实现了基本的纸墨设计布局结构。在示例应用中，MyHomePage 所返回的就是一个 Scaffold。也就是说， MaterialApp 的 child 是 Scaffold Widget。 在纸墨设计中定义的单个界面上的各种布局元素，在 Scaffold 中都有支持，比如 左边栏（Drawers）、snack bars、以及 bottom sheets。 Scaffold 有下面几个主要属性： appBar：显示在界面顶部的一个 AppBar，也就是 Android 中的 ActionBar 、Toolbar body：当前界面所显示的主要内容 Widget floatingActionButton：纸墨设计中所定义的 FAB，界面的主要功能按钮 persistentFooterButtons：固定在下方显示的按钮，比如对话框下方的确定、取消按钮 drawer：侧边栏控件 backgroundColor： 内容的背景颜色，默认使用的是 ThemeData.scaffoldBackgroundColor 的值 bottomNavigationBar： 显示在页面底部的导航栏 resizeToAvoidBottomPadding：类似于 Android 中的 android:windowSoftInputMode&#x3D;”adjustResize”，控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。 显示 snackbar 或者 bottom sheet 的时候，需要使用当前的 BuildContext 参数调用 Scaffold.of 函数来获取 ScaffoldState 对象，然后使用 ScaffoldState.showSnackBar 和 ScaffoldState.showBottomSheet 函数来显示。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Flutter中的手势处理/","text":"移动应用的一个必不可少的环节就是与用户的交互，在Android中提供了手势检测，并为手势检测提供了相应的监听。本文将介绍Flutter中手势检测GestureDetector。Flutter中的手势系统分为两层，第一层是触摸原事件（指针），有相应的四种事件类型。 PointerDownEvent ：用户与屏幕接触产生了联系。 PointerMoveEvent ：手指已从屏幕上的一个位置移动到另一个位置。 PointerUpEvent ：用户已停止接触屏幕。 PointerCancelEvent ：此指针的输入不再指向此应用程序。第二层就是我们可以检测到的手势，主要分为三大类，包括轻击，拖动和缩放，下面是具体的手势监听方法。 #####点击（一次）： onTapDown ：点击屏幕立即触发此方法。 onTapUp ：手指离开屏幕。 onTap ：点击屏幕。 onTapCancel：此次点击事件结束，onTapDown不会在产生点击事件。 #####双击：onDoubleTap ：用户快速连续两次在同一位置点击屏幕。#####长按：onLongPress ：长时间保持与相同位置的屏幕接触#####垂直拖动： onVerticalDragStart： 与接触屏幕，可能会开始垂直移动。 onVerticalDragUpdate：与屏幕接触并垂直移动的指针在垂直方向上移动 onVerticalDragEnd ：之前与屏幕接触并垂直移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动 #####水平拖动： onHorizontalDragStart ：与接触屏幕，可能开始水平移动 onVerticalDragUpdate：与屏幕接触并水平移动的指针在水平方向上移动 onVerticalDragEnd ：先前与屏幕接触并且水平移动的指针不再与屏幕接触，并且当它停止接触屏幕时以特定速度移动上面介绍的就是Flutter的GestureDetector提供的三种手势检测相应的监听方法。来看个Demo。12345678910111213141516171819202122232425262728293031323334353637383940414243import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(new MaterialApp( home: new MyApp() ));class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new GestureDetector( /*点击*/ onTap: () &#123; print(&quot;文本点击了&quot;); &#125;, /*长按*/ onLongPress: () &#123; print(&quot;长按文本&quot;); &#125;, /*横向拖动的开始状态*/ onHorizontalDragStart: (startDetails) &#123; print(startDetails.globalPosition); &#125;, /*横向拖动的结束状态*/ onHorizontalDragEnd: (endDetails) &#123; print(endDetails); &#125;, /*缩放开始状态*/ onScaleStart: (startScaleDetails) &#123; print(startScaleDetails); &#125;, /*缩放结束状态*/ onScaleEnd: (endScaleDetails) &#123; print(endScaleDetails); &#125;, child: new Container( color: Color.fromARGB(255, 220, 220, 220), child: new Center( child: new Text(&quot;Flutter手势&quot;), ) ), ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/StatelessWidget和StatefulWidget的区别/","text":"StatelessWidget和StatefulWidget是flutter的基础组件，日常开发中自定义Widget都是选择继承这两者之一。 两者的区别在于状态的改变，StatelessWidget面向那些始终不变的UI控件，比如标题栏中的标题；而StatefulWidget则是面向可能会改变UI状态的控件，比如有点击反馈的按钮。 StatelessWidget就没什么好研究的了，StatefulWidget的创建需要指定一个State，在需要更新UI的时候调用setState(VoidCallback fn)，并在VoidCallback中改变一些变量数值等，组件会重新build以达到刷新状态也就是刷新UI的效果。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-BottomNavigationBar类/","text":"显示在应用程序底部的材料窗口小部件，用于在少量视图中进行选择，通常在三到五之间。 底部导航栏由文本标签，图标或两者形式的多个项目组成，布置在一块材料的顶部。它提供应用程序顶级视图之间的快速导航。对于较大的屏幕，侧面导航可能更适合。 底部导航栏通常与Scaffold结合使用，它作为Scaffold.bottomNavigationBar参数提供。#####代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title: &quot;title&quot;, theme: ThemeData.light(), home: _home(), ); &#125;&#125;class _home extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt;&#123; final selectionColor=Colors.blue;//选中的颜色 final unSelectionColor=Colors.grey;//未选中的颜色 List&lt;Widget&gt; widgetList=List();//一个装切换页面的集合 int _curIndex=0;//默认选中的页下标 @override void initState() &#123;//重写initState 添加b布局 widgetList..add(HomeScreen()) ..add(EmailScreen())//.. 返回调用者本身 ..add(BlankScreen()); super.initState(); &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( bottomNavigationBar: BottomNavigationBar(//创建BottomNavigationBar type: BottomNavigationBarType.fixed,//fixed点击时不移动,默认样式，shifting点击时动画和标签会淡入 currentIndex: _curIndex,//默认页下标 onTap: (int index)&#123;//点击时切换下标 setState(() &#123; _curIndex=index; &#125;); &#125;, items: [//装入BottomNavigationBarItem 并设置样式 BottomNavigationBarItem( icon: Icon(Icons.home,color:_curIndex==0?selectionColor:unSelectionColor,), title: Text(&quot;home&quot;,style: TextStyle(color: _curIndex==0?selectionColor:unSelectionColor),) ), BottomNavigationBarItem( icon: Icon(Icons.account_balance,color: _curIndex==1?selectionColor:unSelectionColor,), title: Text(&quot;blank&quot;,style: TextStyle(color: _curIndex==1?selectionColor:unSelectionColor),) ), BottomNavigationBarItem( icon: Icon(Icons.email,color: _curIndex==2?selectionColor:unSelectionColor,), title: Text(&quot;email&quot;,style: TextStyle(color: _curIndex==2?selectionColor:unSelectionColor),) ), ] ), body: widgetList[_curIndex],//主页面 ); &#125;&#125;//随便生成的3个页面class HomeScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar:AppBar( title: Text(&#x27;HOME&#x27;), ), body:Center( child: Text(&#x27;HOME&#x27;), ) ); &#125;&#125;class EmailScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar:AppBar( title: Text(&#x27;EmailScreen&#x27;), ), body:Center( child: Text(&#x27;EmailScreen&#x27;), ) ); &#125;&#125;class BlankScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar:AppBar( title: Text(&#x27;BlankScreen&#x27;), ), body:Center( child: Text(&#x27;BlankScreen&#x27;), ) ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/Flutter代码开发规范/","text":"代码风格标识符三种类型大驼峰类、枚举、typedef和类型参数 12345class SliderMenu &#123; ... &#125;class HttpRequest &#123; ... &#125;typedef Predicate = bool Function&lt;T&gt;(T value); 包括用于元数据注释的类 123456789class Foo &#123; const Foo([arg]);&#125;@Foo(anArg)class A &#123; ... &#125;@Foo()class B &#123; ... &#125; 使用小写加下划线来命名库和源文件1234library peg_parser.source_scanner;import &#x27;file_system.dart&#x27;;import &#x27;slider_menu.dart&#x27;; 不推荐如下写法： 1234library pegparser.SourceScanner;import &#x27;file-system.dart&#x27;;import &#x27;SliderMenu.dart&#x27;; 使用小写加下划线来命名导入前缀1234import &#x27;dart:math&#x27; as math;import &#x27;package:angular_components/angular_components&#x27; as angular_components;import &#x27;package:js/js.dart&#x27; as js; 不推荐如下写法： 1234import &#x27;dart:math&#x27; as Math;import &#x27;package:angular_components/angular_components&#x27; as angularComponents;import &#x27;package:js/js.dart&#x27; as JS; 使用小驼峰法命名其他标识符1234567var item;HttpRequest httpRequest;void align(bool clearItems) &#123; // ...&#125; 优先使用小驼峰法作为常量命名1234567const pi = 3.14;const defaultTimeout = 1000;final urlScheme = RegExp(&#x27;^([a-z]+):&#x27;);class Dice &#123; static final numberGenerator = Random();&#125; 不推荐如下写法： 1234567const PI = 3.14;const DefaultTimeout = 1000;final URL_SCHEME = RegExp(&#x27;^([a-z]+):&#x27;);class Dice &#123; static final NUMBER_GENERATOR = Random();&#125; 不使用前缀字母因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。 1defaultTimeout 不推荐如下写法： 1kDefaultTimeout 排序为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。 在其他引入之前引入所需的dart库12345import &#x27;dart:async&#x27;;import &#x27;dart:html&#x27;;import &#x27;package:bar/bar.dart&#x27;;import &#x27;package:foo/foo.dart&#x27;; 在相对引入之前先引入在包中的库1234import &#x27;package:bar/bar.dart&#x27;;import &#x27;package:foo/foo.dart&#x27;;import &#x27;util.dart&#x27;; 第三方包的导入先于其他包1234import &#x27;package:bar/bar.dart&#x27;;import &#x27;package:foo/foo.dart&#x27;;import &#x27;package:my_package/util.dart&#x27;; 在所有导入之后，在单独的部分中指定导出1234import &#x27;src/error.dart&#x27;;import &#x27;src/foo_bar.dart&#x27;;export &#x27;src/error.dart&#x27;; 不推荐如下写法： 123import &#x27;src/error.dart&#x27;;export &#x27;src/error.dart&#x27;;import &#x27;src/foo_bar.dart&#x27;; 所有流控制结构，请使用大括号这样做可以避免悬浮的else问题 12345if (isWeekDay) &#123; print(&#x27;Bike to work!&#x27;);&#125; else &#123; print(&#x27;Go dancing or read a book!&#x27;);&#125; 例外一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号 1if (arg == null) return defaultValue; 如果流程体超出了一行需要分划请使用大括号： 123if (overflowChars != other.overflowChars) &#123; return overflowChars &lt; other.overflowChars;&#125; 不推荐如下写法： 12if (overflowChars != other.overflowChars) return overflowChars &lt; other.overflowChars; 注释要像句子一样格式化除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。 1234greet(name) &#123; // Assume we have a valid name. print(&#x27;Hi, $name!&#x27;);&#125; 不推荐如下写法： 1234greet(name) &#123; /* Assume we have a valid name. */ print(&#x27;Hi, $name!&#x27;);&#125; 可以使用块注释(&#x2F;…&#x2F;)临时注释掉一段代码，但是所有其他注释都应该使用&#x2F;&#x2F; Doc注释使用&#x2F;&#x2F;&#x2F;文档注释来记录成员和类型。 使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。 12/// The number of characters in this chunk when unsplit.int get length =&gt; ... 由于历史原因，达特茅斯学院支持道格评论的两种语法:&#x2F;&#x2F;&#x2F;(“C#风格”)和&#x2F;*… &#x2F;(“JavaDoc风格”)。我们更喜欢&#x2F;&#x2F;&#x2F; 因为它更紧凑。&#x2F;*和&#x2F;在多行文档注释中添加两个无内容的行。在某些情况下，&#x2F;&#x2F;&#x2F;语法也更容易阅读，例如文档注释包含使用*标记列表项的项目符号列表。 考虑为私有api编写文档注释Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员 用一句话总结开始doc注释以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。 1234/// Deletes the file at [path] from the file system.void delete(String path) &#123; ...&#125; 不推荐如下写法： 1234567/// Depending on the state of the file system and the user&#x27;s permissions,/// certain operations may or may not be possible. If there is no file at/// [path] or it can&#x27;t be accessed, this function throws either [IOError]/// or [PermissionError], respectively. Otherwise, this deletes the file.void delete(String path) &#123; ...&#125; “doc注释”的第一句话分隔成自己的段落在第一个句子之后添加一个空行，把它分成自己的段落 1234567/// Deletes the file at [path].////// Throws an [IOError] if the file could not be found. Throws a/// [PermissionError] if the file is present but could not be deleted.void delete(String path) &#123; ...&#125; Flutter_Go 使用参考库的引用flutter go 中，导入lib下文件库，统一指定报名，避免过多的../../ 1package:flutter_go/ 字符串的使用使用相邻字符串连接字符串文字如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。 123raiseAlarm( &#x27;ERROR: Parts of the spaceship are on fire. Other &#x27; &#x27;parts are overrun by martians. Unclear which are which.&#x27;); 不推荐如下写法: 12raiseAlarm(&#x27;ERROR: Parts of the spaceship are on fire. Other &#x27; + &#x27;parts are overrun by martians. Unclear which are which.&#x27;); 优先使用模板字符串1&#x27;Hello, $name! You are $&#123;year - birth&#125; years old.&#x27;; 在不需要的时候，避免使用花括号12&#x27;Hi, $name!&#x27;&quot;Wear your wildest $decade&#x27;s outfit.&quot; 不推荐如下写法： 1&#x27;Hello, &#x27; + name + &#x27;! You are &#x27; + (year - birth).toString() + &#x27; y...&#x27;; 不推荐如下写法： 12&#x27;Hi, $&#123;name&#125;!&#x27;&quot;Wear your wildest $&#123;decade&#125;&#x27;s outfit.&quot; 集合尽可能使用集合字面量如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。 123var points = [];var addresses = &#123;&#125;;var lines = &lt;Lines&gt;[]; 不推荐如下写法： 12var points = List();var addresses = Map(); 不要使用.length查看集合是否为空12if (lunchBox.isEmpty) return &#x27;so hungry...&#x27;;if (words.isNotEmpty) return words.join(&#x27; &#x27;); 不推荐如下写法： 12if (lunchBox.length == 0) return &#x27;so hungry...&#x27;;if (!words.isEmpty) return words.join(&#x27; &#x27;); 考虑使用高阶方法转换序列如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性 123var aquaticNames = animals .where((animal) =&gt; animal.isAquatic) .map((animal) =&gt; animal.name); 避免使用带有函数字面量的Iterable.forEach()在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。 123for (var person in people) &#123; ...&#125; 不推荐如下写法： 123people.forEach((person) &#123; ...&#125;); 不要使用List.from()，除非打算更改结果的类型给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表 12var copy1 = iterable.toList();var copy2 = List.from(iterable); 明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数 12345// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints &quot;List&lt;int&gt;&quot;:print(iterable.toList().runtimeType); 12345// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints &quot;List&lt;dynamic&gt;&quot;:print(List.from(iterable).runtimeType); 参数的使用使用&#x3D;将命名参数与其默认值分割开由于遗留原因，Dart均允许“:”和“&#x3D;”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“&#x3D;”。 1void insert(Object item, &#123;int at = 0&#125;) &#123; ... &#125; 不推荐如下写法： 1void insert(Object item, &#123;int at: 0&#125;) &#123; ... &#125; 不要使用显式默认值null如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它 123void error([String message]) &#123; stderr.write(message ?? &#x27;\\n&#x27;);&#125; 不推荐如下写法: 123void error([String message = null]) &#123; stderr.write(message ?? &#x27;\\n&#x27;);&#125; 变量不要显式地将变量初始化为空在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null 123456789101112int _nextId;class LazyId &#123; int _id; int get id &#123; if (_nextId == null) _nextId = 0; if (_id == null) _id = _nextId++; return _id; &#125;&#125; 不推荐如下写法： 123456789101112int _nextId = null;class LazyId &#123; int _id = null; int get id &#123; if (_nextId == null) _nextId = 0; if (_id == null) _id = _nextId++; return _id; &#125;&#125; 避免储存你能计算的东西在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们: 应该避免的写法： 12345678910class Circle &#123; num radius; num area; num circumference; Circle(num radius) : radius = radius, area = pi * radius * radius, circumference = pi * 2.0 * radius;&#125; 如上代码问题： 浪费内存 缓存的问题是无效——如何知道何时缓存过期需要重新计算？ 推荐的写法如下： 12345678class Circle &#123; num radius; Circle(this.radius); num get area =&gt; pi * radius * radius; num get circumference =&gt; pi * 2.0 * radius;&#125; 类成员不要把不必要地将字段包装在getter和setter中不推荐如下写法： 1234567class Box &#123; var _contents; get contents =&gt; _contents; set contents(value) &#123; _contents = value; &#125;&#125; 优先使用final字段来创建只读属性尤其对于 StatelessWidget 在不需要的时候不要用this不推荐如下写法： 1234567891011class Box &#123; var value; void clear() &#123; this.update(null); &#125; void update(value) &#123; this.value = value; &#125;&#125; 推荐如下写法： 1234567891011class Box &#123; var value; void clear() &#123; update(null); &#125; void update(value) &#123; this.value = value; &#125;&#125; 构造函数尽可能使用初始化的形式不推荐如下写法： 1234567class Point &#123; num x, y; Point(num x, num y) &#123; this.x = x; this.y = y; &#125;&#125; 推荐如下写法： 1234class Point &#123; num x, y; Point(this.x, this.y);&#125; 不要使用newDart2使new 关键字可选 推荐写法： 12345678910Widget build(BuildContext context) &#123; return Row( children: [ RaisedButton( child: Text(&#x27;Increment&#x27;), ), Text(&#x27;Click!&#x27;), ], );&#125; 不推荐如下写法： 12345678910Widget build(BuildContext context) &#123; return new Row( children: [ new RaisedButton( child: new Text(&#x27;Increment&#x27;), ), new Text(&#x27;Click!&#x27;), ], );&#125; 异步优先使用async&#x2F;await代替原始的futuresasync&#x2F;await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。 123456789101112Future&lt;int&gt; countActivePlayers(String teamName) async &#123; try &#123; var team = await downloadTeam(teamName); if (team == null) return 0; var players = await team.roster; return players.where((player) =&gt; player.isActive).length; &#125; catch (e) &#123; log.error(e); return 0; &#125;&#125; 当异步没有任何用处时，不要使用它如果可以在不改变函数行为的情况下省略异步，那么就这样做。、 123Future afterTwoThings(Future first, Future second) &#123; return Future.wait([first, second]);&#125; 不推荐写法： 123Future afterTwoThings(Future first, Future second) async &#123; return Future.wait([first, second]);&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-BottomAppBar-（不规则底部工具栏）/","text":"BottomAppBar 是 底部工具栏的意思，这个要比BottomNavigationBar widget灵活很多，可以放置文字和图标，当然也可以放置容器。#####BottomAppBar的常用属性: color:这个不用多说，底部工具栏的颜色。 shape：设置底栏的形状，一般使用这个都是为了和floatingActionButton融合，所以使用的值都是CircularNotchedRectangle(),有缺口的圆形矩形。 child ： 里边可以放置大部分Widget，让我们随心所欲的设计底栏。 #####代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title: &quot;flutter demo&quot;, theme: ThemeData( primarySwatch: Colors.lightBlue //primarySwatch ：现在支持18种主题样本。 ), home: _home(), ); &#125;&#125;class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; List&lt;Widget&gt; _viewList; //创建视图数组 int _index = 0; //数组索引，通过改变索引值改变视图 @override void initState() &#123; super.initState(); _viewList = List(); _viewList..add(EachView(&quot;HOME&quot;))..add(EachView(&quot;CLOCK&quot;)); &#125; _openNewPage() &#123; Navigator.of(context) .push(MaterialPageRoute(builder: (BuildContext context) &#123; return EachView(&quot;new Pager&quot;); &#125;)); &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( floatingActionButton: FloatingActionButton( onPressed: _openNewPage, child: Icon( Icons.add, color: Colors.white, )), floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, //和底栏进行融合 bottomNavigationBar: BottomAppBar( color: Colors.lightBlue, //底部工具栏的颜色。 shape: CircularNotchedRectangle(), //设置底栏的形状，一般使用这个都是为了和floatingActionButton融合， // 所以使用的值都是CircularNotchedRectangle(),有缺口的圆形矩形。 child: Row( //里边可以放置大部分Widget，让我们随心所欲的设计底栏 mainAxisAlignment: MainAxisAlignment.spaceAround, mainAxisSize: MainAxisSize.max, children: &lt;Widget&gt;[ IconButton( icon: Icon( Icons.home, color: Colors.white, ), color: Colors.white, onPressed: () &#123; setState(() &#123; _index = 0; &#125;); &#125;, ), IconButton( icon: Icon(Icons.access_alarms, color: Colors.white), color: Colors.white, onPressed: () &#123; setState(() &#123; _index = 1; &#125;); &#125;, ), ], ), ), body: _viewList[_index], ); &#125;&#125;//子页面//代码中设置了一个内部的_title变量，这个变量是从主页面传递过来的，然后根据传递过来的具体值显示在APP的标题栏和屏幕中间。class EachView extends StatefulWidget &#123; String _title; EachView(this._title); @override _EachViewState createState() =&gt; _EachViewState();&#125;class _EachViewState extends State&lt;EachView&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text(widget._title)), body: Center(child: Text(widget._title)), ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-Chip/","text":"######Chip中文翻译为碎片的意思，一般也是用作商品或者一些东西的标签。 好吧，还是看看怎么使用吧 #####构造方法： 12345678910111213141516Chip(&#123; Key key, this.avatar,//标签左侧Widget，一般为小图标 @required this.label,//标签 this.labelStyle, this.labelPadding,//padding this.deleteIcon//删除图标, this.onDeleted//删除回调，为空时不显示删除图标, this.deleteIconColor//删除图标的颜色, this.deleteButtonTooltipMessage//删除按钮的tip文字, this.shape//形状, this.clipBehavior = Clip.none, this.backgroundColor//背景颜色, this.padding, this.materialTapTargetSize//删除图标material点击区域大小, &#125;) #####代码： 1234567891011121314151617181920212223import &#x27;package:flutter/material.dart&#x27;;void main() &#123; runApp(MaterialApp( home: MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;Chip&quot;), ), body: Center( child: Chip( label: Text(&quot;flyou&quot;), ), ), ); &#125;&#125; 纳尼，这是什么鬼这跟前面讲的ToolTip显示效果也好像啊，像吗？确实很像，确实也不是很像，接着往下看吧。 好吧，刚才构造方法中有那么多的属性，我们来看下怎么使用吧。 我们给我们的Chip加上一个 avatar再来看下效果avatar: Icon(Icons.add_location, color: Colors.lightBlue)那么再来看下这几个与delete相关的属性吧 我们先仅仅给Chip添加 onDeleted属性onDeleted: ()&#123;&#125;可以看到，我们仅仅给Chip添加了一个onDeleted属性它便给我们多出了一个删除的按钮和长按的Tooltip提示（没错，就是我们上篇文章讲到的Tooltip，感兴趣的童鞋可以去看下源码哈）。 那么，我们尝试修改与delete相关的其他属性再来看下效果#####代码： 123deleteIcon: Icon(Icons.delete_forever),deleteIconColor: Colors.red,deleteButtonTooltipMessage: &quot;删除该条&quot;, 修改背景颜色shape:RoundedRectangleBorder(borderRadius: BorderRadius.circular(3.0))当然，你还可以修改labelStyle来修改文字显示效果，修改padding来控制chip的大小。 当然，与Chip相关的还有InputChip、ChoiceChip、ActionChip和FilterChip，用法和Chip类似，只不过会稍微多几个属性而已，大家感兴趣的可以尝试下。#####小结 Chip是一个很常见的标签组件 使用Chip的一些属性可以很方便的完成对Chip效果的自定义 Chip自带删除按钮和删除监听，可以方便做其他操作","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-ExpansionTile(闭合列表)/","text":"ExpansionTile Widget就是一个可以展开闭合的组件，常用的属性有如下几个。 title:闭合时显示的标题，这个部分经常使用Text Widget。 leading:标题左侧图标，多是用来修饰，让界面显得美观。 backgroundColor: 展开时的背景颜色，当然也是有过度动画的，效果非常好。 children: 子元素，是一个数组，可以放入多个元素。 trailing ： 右侧的箭头，你可以自行替换但是我觉的很少替换，因为谷歌已经表现的很完美了。 initiallyExpanded: 初始状态是否展开，为true时，是展开，默认为false，是不展开。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title: &quot;flutter demo&quot;, theme: new ThemeData.dark(), home: _home(), ); &#125;&#125;class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: new Text(&quot;title&quot;), ), body: new Center( child: ExpansionTile( title: Text(&quot;title&quot;), leading: Icon(Icons.favorite,color: Colors.white,), backgroundColor: Colors.lightBlue, initiallyExpanded: false,//默认是否展开 children: &lt;Widget&gt;[ ListTile( title: Text(&quot;ListTile&quot;), leading: Icon(Icons.favorite_border,color: Colors.white,), ), ], ), ), ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-Flexible和-Expanded/","text":"#####Flexible和 Expanded的区别是：Flexible是一个控制Row、Column、Flex等子组件如何布局的组件。Flexible组件可以使Row、Column、Flex等子组件在主轴方向有填充可用空间的能力(例如，Row在水平方向，Column在垂直方向)，但是它与Expanded组件不同，它不强制子组件填充可用空间。Flexible组件必须是Row、Column、Flex等组件的后裔，并且从Flexible到它封装的Row、Column、Flex的路径必须只包括StatelessWidgets或StatefulWidgets组件(不能是其他类型的组件，像RenderObjectWidgets)。Row、Column、Flex会被Expanded撑开，充满主轴可用空间。使用方式： 12345678910Row( children: &lt;Widget&gt;[ Container( /// 此组件在主轴方向占据48.0逻辑像素 width: 48.0 ), Expanded( child: Container() /// 此组件会填满Row在主轴方向的剩余空间，撑开Row ) ]) Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。 Expanded组件必须用在Row、Column、Flex内，并且从Expanded到封装它的Row、Column、Flex的路径必须只包括StatelessWidgets或StatefulWidgets组件(不能是其他类型的组件，像RenderObjectWidget，它是渲染对象，不再改变尺寸了，因此Expanded不能放进RenderObjectWidget)。 下面一个例子展示Flexible和Expanded之间的区别Expanded的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#x27;package:flutter/material.dart&#x27;;class LayoutDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&#x27;水平方向布局&#x27;), ), body: new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123; print(&#x27;点击红色按钮事件&#x27;); &#125;, color: const Color(0xffcc0000), child: new Text(&#x27;红色按钮&#x27;), ), new Expanded( flex: 1, child: new RaisedButton( onPressed: () &#123; print(&#x27;点击黄色按钮事件&#x27;); &#125;, color: const Color(0xfff1c232), child: new Text(&#x27;黄色按钮&#x27;), ), ), new RaisedButton( onPressed: () &#123; print(&#x27;点击粉色按钮事件&#x27;); &#125;, color: const Color(0xffea9999), child: new Text(&#x27;粉色按钮&#x27;), ), ] ), ); &#125;&#125;void main() &#123; runApp( new MaterialApp( title: &#x27;Flutter教程&#x27;, home: new LayoutDemo(), ), );&#125; Flexible的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#x27;package:flutter/material.dart&#x27;;class LayoutDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&#x27;水平方向布局&#x27;), ), body: new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123; print(&#x27;点击红色按钮事件&#x27;); &#125;, color: const Color(0xffcc0000), child: new Text(&#x27;红色按钮&#x27;), ), new Flexible( flex: 1, child: new RaisedButton( onPressed: () &#123; print(&#x27;点击黄色按钮事件&#x27;); &#125;, color: const Color(0xfff1c232), child: new Text(&#x27;黄色按钮&#x27;), ), ), new RaisedButton( onPressed: () &#123; print(&#x27;点击粉色按钮事件&#x27;); &#125;, color: const Color(0xffea9999), child: new Text(&#x27;粉色按钮&#x27;), ), ] ), ); &#125;&#125;void main() &#123; runApp( new MaterialApp( title: &#x27;Flutter教程&#x27;, home: new LayoutDemo(), ), );&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-Padding/","text":"#####PaddingPadding可以给其子节点添加补白（填充），我们在前面很多示例中都已经使用过它了，现在来看看它的定义： 12345Padding(&#123; ... EdgeInsetsGeometry padding, Widget child,&#125;) EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets，它是EdgeInsetsGeometry的一个子类，定义了一些设置补白的便捷方法。 #####EdgeInsets我们看看EdgeInsets提供的便捷方法： fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的补白。 all(double value) : 所有方向均使用相同数值的补白。 only({left, top, right ,bottom })：可以设置具体某个方向的补白(可以同时指定多个方向)。 symmetric({ vertical, horizontal })：用于设置对称方向的补白，vertical指top和bottom，horizontal指left和right。 #####示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: new Text(&quot;title&quot;), centerTitle: true, ), body: //通过ConstrainedBox来确保Stack占满屏幕 Padding( //上下左右各添加16像素补白 padding: EdgeInsets.all(16.0), child: Column( //显式指定对齐方式为左对齐，排除对齐干扰 crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Padding( //左边添加8像素补白 padding: const EdgeInsets.only(left: 8.0), child: Text(&quot;Hello world&quot;), ), Padding( //上下各添加8像素补白 padding: const EdgeInsets.symmetric(vertical: 8.0), child: Text(&quot;I am Jack&quot;), ), Padding( // 分别指定四个方向的补白 padding: const EdgeInsets.fromLTRB(20.0, .0, 20.0, 20.0), child: Text(&quot;Your friend&quot;), ) ], ), )); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-ListTile(06)/","text":"一个固定高度的行，通常包含一些文本，以及一个行前或行尾图标。构造方法: 1234567891011121314const ListTile(&#123; Key key, this.leading,//左侧widget this.title,//标题 this.subtitle,//副标题 this.trailing,//右侧widget this.isThreeLine = false,//是否默认3行高度，subtitle不为空时才能使用 this.dense,//设置为true后字体变小 this.contentPadding,//内边距 this.enabled = true,//能否被点击 this.onTap,//点击事件 this.onLongPress,//长按事件 this.selected = false,//展开是否默认显示选中 &#125;)","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-Stack(层叠控件)/","text":"Stack即层叠布局控件，能够将子控件层叠排列。 Stack控件的每一个子控件都是定位或不定位，定位的子控件是被Positioned控件包裹的。Stack控件本身包含所有不定位的子控件，其根据alignment定位（默认为左上角）。然后根据定位的子控件的top、right、bottom和left属性将它们放置在Stack控件上。 1234567891011121314151617181920212223242526272829303132class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new Center( child: new Stack( children: &lt;Widget&gt;[ Image.network( &quot;http://a.hiphotos.baidu.com/image/h%3D300/sign=ca66f12cffd3572c79e29adcba116352/3b87e950352ac65cd08fc0b6f6f2b21192138a69.jpg&quot;), new Positioned( top: 20.0, left: 10.0, right: 0.0, bottom: 30.0, child: new Text(&quot;Positioned&quot;,style:TextStyle(fontSize:18.0,color: Colors.white),)), ], ), )); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-Text(02)/","text":"#####简单样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title: &#x27;flutter demo&#x27;, home: _home(), ); &#125;&#125;class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new Column( //垂直布局 children: &lt;Widget&gt;[ //控件组 Text( &quot;Hello world&quot;, textAlign: TextAlign.center, //可以选择左对齐、右对齐还是居中。注意，对齐的参考系是Text widget本身。本例中虽然是指定了居中对齐， // 但因为Text文本内容宽度不足一行，Text的宽度和文本内容长度相等，那么这时指定对齐方式是没有意义的， // 只有Text宽度大于文本内容长度时指定此属性才有意义。 ), Text( &quot;Hello world! I&#x27;m Jack. &quot; * 4,//文字重复4次 maxLines: 1,//最大行数 overflow: TextOverflow.ellipsis,//超出显示省略号 ), Text( &quot;Hello world&quot;, textScaleFactor: 1.5,//代表文本相对于当前字体大小的缩放因子，相对于去设置文本的样式style属性的fontSize，它是调整字体大小的一个快捷方式。 // 该属性的默认值可以通过MediaQueryData.textScaleFactor获得，如果没有MediaQuery，那么会默认值将为1.0。 ), ], )); &#125;&#125; #####TextStyle 1234567891011121314151617new Text( &#x27;center&#x27;, style: TextStyle( color: Colors.white,//字体颜色 fontSize: 18.0, //fontSize：该属性和Text的textScaleFactor都用于控制字体大小。但是有两给主要区别： //fontSize可以精确指定字体大小，而textScaleFactor只能通过缩放比例来控制。 //textScaleFactor主要是用于系统字体大小设置改变时对Flutter应用字体进行全局调整，而fontSize通常用于单个文本。 height: 1.2, //指定行高，但它并不是一个绝对值，而是一个因子，具体的行高等于fontSize*height fontFamily: &quot;Courier&quot;, //由于不同平台默认支持的字体集不同，所以在手动指定字体时一定要先在不同平台测试一下 background: new Paint()..color = Colors.lightBlue, decoration: TextDecoration.underline,//下划线 decorationStyle: TextDecorationStyle.dashed),//下划线样式 // decorationColor: Colors.white,下划线颜色 ), #####softWrap是否自动换行，若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理#####overflow当文字超出屏幕的时候，如何处理: TextOverflow.clip(裁剪) TextOverflow.fade(渐隐) TextOverflow.ellipsis(省略号)","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-card（卡片布局）/","text":"Card 摘要: 实现了一个 Material Design card 接受单个孩子，但该孩子可以是Row，Column或其他包含子级列表的widget 显示圆角和阴影 Card内容不能滚动 Material Components 库的一个widget12345678910111213141516171819202122232425262728class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new Card( elevation: 4.0,//阴影 color: Colors.grey,//背景色 child: new Container( color: Colors.lightBlue, width: 200.0, height: 200.0, ), ) ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-listview(07)/","text":"#####固定的垂直布局 123456789101112131415161718192021222324252627class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new ListView( children: &lt;Widget&gt;[ new Image.network( &quot;https://cdn2.jianshu.io/assets/web/banner-s-3-7123fd94750759acf7eca05b871e9d17.png&quot;), new Image.network( &quot;https://cdn2.jianshu.io/assets/web/banner-s-4-b70da70d679593510ac93a172dfbaeaa.png&quot;), new Image.network( &quot;https://cdn2.jianshu.io/assets/web/banner-s-7-1a0222c91694a1f38e610be4bf9669be.png&quot;), ], ), ); &#125; #####横向滑动的listview 123456789101112131415161718192021222324252627282930313233343536373839404142434445class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new Container( height: 200.0, child: new ListView( scrollDirection: Axis.horizontal,//ListView滑动方向horizontal水平vertical垂直 children: &lt;Widget&gt;[ new Container( width: 180.0, color: Colors.greenAccent, ), new Container( width: 180.0, color: Colors.lightBlue, ), new Container( width: 180.0, color: Colors.red, ), new Container( width: 180.0, color: Colors.black12, ), new Container( width: 180.0, color: Colors.amberAccent, ) ], ), ) ); &#125; #####简单demo无限滚动的listview 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//pubspec.yaml 中添加包 english_words: ^3.1.0import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:english_words/english_words.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title: &#x27;flutter demo&#x27;, home: _home(), ); &#125;&#125;class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; final data = &lt;WordPair&gt;[];//一个随机英文单词的数据源 @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new ListView.builder( padding: EdgeInsets.all(8.0),//内边距 itemBuilder: (conText, i) &#123; if(i.isOdd)&#123;//isOdd判断是否是奇数 return new Divider();//返回下划线 &#125; final index=i~/2; if(data.length&lt;=i)&#123; data.addAll(generateWordPairs().take(10));//数据源添加10条随机英文单词 &#125; return _row(data[index]); &#125;)); &#125; Widget _row (WordPair pair)&#123; return new ListTile( title: new Text(pair.asPascalCase,style: TextStyle(fontSize: 15.0),), ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-gridView/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new GridView.count(// padding: EdgeInsets.fromLTRB(8.0,0,8.0,0),//上下左右内边距 mainAxisSpacing: 4.0,//x轴间距 childAspectRatio: 1.5,//宽高比 crossAxisSpacing: 4.0,//y轴间距 crossAxisCount: 3,//行个数 children: &lt;Widget&gt;[ new Container( color: Colors.deepPurpleAccent, ), new Container( color: Colors.yellow, ), new Container( color: Colors.lightBlue, ), new Container( color: Colors.grey, ), new Container( color: Colors.red, ), new Container( color: Colors.blueGrey, ), ], ) ); &#125;&#125; ######另一种写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( mainAxisSpacing: 4.0, //x轴间距 childAspectRatio: 1.5, //宽高比 crossAxisSpacing: 4.0, //y轴间距 crossAxisCount: 3, //行个数 ), children: &lt;Widget&gt;[ new Container( color: Colors.deepPurpleAccent, ), new Container( color: Colors.yellow, ), new Container( color: Colors.lightBlue, ), new Container( color: Colors.grey, ), new Container( color: Colors.red, ), new Container( color: Colors.blueGrey, ), ], ) ); &#125; ######效果一样","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-mainAxisAlignment和crossAxisAlignment/","text":"垂直布局时：y轴为主轴，x轴为副轴!水平不就是：x轴为主轴，y轴为副轴!","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-单选框和复选框(05)/","text":"Material widgets库中提供了Material风格的单选开关Switch和复选框Checkbox，它们都是继承自StatelessWidget，所以它们本身不会保存当前选择状态，所以一般都是在父widget中管理选中状态。当用户点击Switch或Checkbox时，它们会触发onChanged回调，我们可以在此回调中处理选中状态改变逻辑。我们看一个简单的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; bool _switchSelected=true; //维护单选开关状态 bool _checkboxSelected=true;//维护复选框状态 @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body:new Column( children: &lt;Widget&gt;[ Switch(//传入value和onChanged,传入value按钮初始化状态,onChanged状态改变回调 value: _switchSelected, activeColor: Colors.red, onChanged: (value)&#123; setState(() &#123;//setState动态更新 _switchSelected=value; &#125;); &#125;, ), Checkbox( value: _checkboxSelected, activeColor: Colors.greenAccent, onChanged: (value)&#123; setState(() &#123; _checkboxSelected=value; &#125;); &#125;, ) ], ) ); &#125;&#125; 上面代码中，由于要维护Switch和Checkbox状态，所以SwitchAndCheckBoxTestRoute继承自StatefulWidget 。在其build方法中分别构建了一个Switch和Checkbox，初始状态都为选中状态，当用户点击时，会将状态置反，然后回调用setState()通知framework重新构建UI。它们都有一个activeColor属性，用于设置激活态的颜色。至于大小，到目前为止，Checkbox的大小是固定的，无法自定义，而Switch只能定义宽度，高度也是固定的。值得一提的是Checkbox有一个属性tristate ，表示是否为三态，其默认值为false ，这时Checkbox有两种状态即“选中”和“不选中”，对应的value值为true和false ；如果其值为true时，value的值会增加一个状态null，读者可以自行了解。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-图片(04)/","text":"#####图片Flutter中，我们可以通过Image来加载并显示图片，Image的数据源可以是asset、文件、内存以及网络。#####ImageProviderImageProvider 是一个抽象类，主要定义了图片数据获取的接口load()，从不同的数据源获取图片需要实现不同的ImageProvider ，如AssetImage是实现了从Asset中加载图片的ImageProvider，而NetworkImage实现了从网络加载图片的ImageProvider。#####ImageImage widget有一个必选的image参数，它对应一个ImageProvider。下面我们分别演示一下如何从asset和网络加载图片。#####从asset中加载图片 在工程根目录下创建一个assets目录再在assets中创建images目录，并将图片拷贝到该目录。 在pubspec.yml中的flutter部分添加如下内容： 12assets: - assets/images/dubai.jpg 加载该图片 1Image.asset(&quot;assets/images/dubai.jpg&quot;,width: 300,),//width宽度 可以不设置 #####从网络加载图片 1Image.network(&quot;https://www.baidu.com/img/bd_logo1.png&quot;), &#x2F;&#x2F;参数 12345678910Image.asset( &quot;assets/images/dubai.jpg&quot;,//图片路径 width: 200.0,////图片的宽 height: 200.0,//图片高度 color: Colors.amber,//图片的混合色值 alignment: Alignment.center,//对齐方式 repeat: ImageRepeat.noRepeat,//重复方式 fit: BoxFit.fill,//fit缩放模式 colorBlendMode: BlendMode.difference,//colorBlendMode混合模式 ), width、height：用于设置图片的宽、高，当不指定宽高时，图片会根据当前父容器的限制，尽可能的显示其原始大小，如果只设置width、height的其中一个，那么另一个属性默认会按比例缩放，但可以通过下面介绍的fit属性来指定适应规则。fit：该属性用于在图片的显示空间和图片本身大小不同时指定图片的适应模式。适应模式是在BoxFit中定义，它是一个枚举类型，有如下值： fill：会拉伸填充满显示空间，图片本身长宽比会发生变化，图片会变形。 cover：会按图片的长宽比放大后居中填满显示空间，图片不会变形，超出显示空间部分会被剪裁。 contain：这是图片的默认适应规则，图片会在保证图片本身长宽比不变的情况下缩放以适应当前显示空间，图片不会变形。 fitWidth：图片的宽度会缩放到显示空间的宽度，高度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁。 fitHeight：图片的高度会缩放到显示空间的高度，宽度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁。 none：图片没有适应策略，会在显示空间内显示图片，如果图片比显示空间大，则显示空间只会显示图片中间部分。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-层叠布局Stack、Positioned/","text":"#####层叠布局 层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。#####Stack 1234567Stack(&#123; this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, this.overflow = Overflow.clip, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。 textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。 fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。 overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。 #####Positioned 12345678910const Positioned(&#123; Key key, this.left, this.top, this.right, this.bottom, this.width, this.height, @required Widget child,&#125;) left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。#####示例 123456789101112131415161718192021222324252627282930313233343536373839class _home extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt;&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: new Text(&quot;title&quot;), centerTitle: true, ), body: //通过ConstrainedBox来确保Stack占满屏幕 ConstrainedBox( constraints: BoxConstraints.expand(), child: Stack( alignment:Alignment.center , //指定未定位或部分定位widget的对齐方式 children: &lt;Widget&gt;[ Container(child: Text(&quot;Hello world&quot;,style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( left: 18.0, child: Text(&quot;I am Jack&quot;), ), Positioned( top: 18.0, child: Text(&quot;Your friend&quot;), ) ], ), ) ); &#125;&#125; 由于第一个子widget Text(“Hello world”)没有指定定位，并且alignment值为Alignment.center，所以，它会居中显示。第二个子widget Text(“I am Jack”)只指定了水平方向的定位(left)，所以属于部分定位，即垂直方向上没有定位，那么它在垂直方向对齐方式则会按照alignment指定的对齐方式对齐，即垂直方向居中。对于第三个子widget Text(“Your friend”)，和第二个Text原理一样，只不过是水平方向没有定位，则水平方向居中。我们给上例中的Stack指定一个fit属性，然后将三个子widget的顺序调整一下： 12345678910111213141516171819202122232425262728293031323334353637class _home extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt;&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: new Text(&quot;title&quot;), centerTitle: true, ), body: //通过ConstrainedBox来确保Stack占满屏幕 Stack( alignment:Alignment.center , fit: StackFit.expand, //未定位widget占满Stack整个空间 children: &lt;Widget&gt;[ Positioned( left: 18.0, child: Text(&quot;I am Jack&quot;), ), Container(child: Text(&quot;Hello world&quot;,style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( top: 18.0, child: Text(&quot;Your friend&quot;), ) ], ), ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-导航返回拦截WillPopScope(防误触)/","text":"#####导航返回拦截WillPopScope 为了避免用户误触返回按钮而导致APP退出，在很多APP中都拦截了用户点击返回键的按钮，当用户在某一个时间段内点击两次时，才会认为用户是要退出（而非误触）。Flutter中可以通过WillPopScope来实现返回按钮拦截，我们看看WillPopScope的默认构造函数： 12345const WillPopScope(&#123; ... @required WillPopCallback onWillPop, @required Widget child&#125;) onWillPop是一个回调函数，当用户点击返回按钮时调用（包括导航返回按钮及Android物理返回按钮），该回调需要返回一个Future对象，如果返回的Future最终值为false时，则当前路由不出栈(不会返回)，最终值为true时，当前路由出栈退出。我们需要提供这个回调来决定是否退出。 #####示例为了防止用户误触返回键退出，我们拦截返回事件，当用户在1秒内点击两次返回按钮时，则退出，如果间隔超过1秒则不退出，并重新记时。代码如下： 12345678910111213141516171819202122232425262728293031import &#x27;package:flutter/material.dart&#x27;;class WillPopScopeTestRoute extends StatefulWidget &#123; @override WillPopScopeTestRouteState createState() &#123; return new WillPopScopeTestRouteState(); &#125;&#125;class WillPopScopeTestRouteState extends State&lt;WillPopScopeTestRoute&gt; &#123; DateTime _lastPressedAt; //上次点击时间 @override Widget build(BuildContext context) &#123; return new WillPopScope( onWillPop: () async &#123; if (_lastPressedAt == null || DateTime.now().difference(_lastPressedAt) &gt; Duration(seconds: 1)) &#123; //两次点击间隔超过1秒则重新计时 _lastPressedAt = DateTime.now(); return false; &#125; return true; &#125;, child: Container( alignment: Alignment.center, child: Text(&quot;1秒内连续按两次返回键退出&quot;), ) ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-弹性布局Flex/","text":"#####弹性布局 弹性布局允许子widget按照一定比例来分配父容器空间，弹性布局的概念在其UI系统中也都存在，如H5中的弹性盒子布局，Android中的FlexboxLayout。Flutter中的弹性布局主要通过Flex和Expanded来配合实现。 #####FlexFlex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。 12345Flex(&#123; ... @required this.direction, //弹性布局的方向, Row默认为水平方向，Column默认为垂直方向 List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) Flex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。 #####Expanded可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。 1234const Expanded(&#123; int flex = 1, @required Widget child,&#125;) flex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间。下面我们看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class _home extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt;&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: new Text(&quot;title&quot;), centerTitle: true, ), body: _body(), ); &#125;&#125;Widget _body()&#123; return Column( children: &lt;Widget&gt;[ //Flex的两个子widget按1：2来占据水平空间 Flex( direction: Axis.horizontal, children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( height: 80.0, color: Colors.red, ), ), Expanded( flex: 2, child: Container( height: 80.0, color: Colors.green, ), ), ], ), Padding( padding: const EdgeInsets.only(top: 20.0), child: SizedBox( height: 100.0, //Flex的三个子widget，在垂直方向按2：1：1来占用100像素的空间 child: Flex( direction: Axis.vertical, children: &lt;Widget&gt;[ Expanded( flex: 2, child: Container( color: Colors.red, ), ), Spacer(//Spacer的功能是占用指定比例的空间，实际上它只是Expanded的一个包装 flex: 1, ), Expanded( flex: 1, child: Container( color: Colors.green, ), ), ], ), ), ), ], );&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-流式布局Wrap、Flow/","text":"#####流式布局 #####Wrap在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如： 12345Row( children: &lt;Widget&gt;[ Text(&quot;xxx&quot;*100) ],); 可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行。下面是Wrap的定义: 123456789101112Wrap(&#123; ... this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) 我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如direction、crossAxisAlignment、textDirection、verticalDirection等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性： spacing：主轴方向子widget的间距 runSpacing：纵轴方向的间距 runAlignment：纵轴方向的对齐方式下面看一个示例子：12345678910111213141516171819202122232425Widget _body()&#123; return Wrap( spacing: 8.0, // 主轴(水平)方向间距 runSpacing: 4.0, // 纵轴（垂直）方向间距 alignment: WrapAlignment.center, //沿主轴方向居中 children: &lt;Widget&gt;[ new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text(&#x27;A&#x27;)), label: new Text(&#x27;Hamilton&#x27;), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text(&#x27;M&#x27;)), label: new Text(&#x27;Lafayette&#x27;), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text(&#x27;H&#x27;)), label: new Text(&#x27;Mulligan&#x27;), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text(&#x27;J&#x27;)), label: new Text(&#x27;Laurens&#x27;), ), ], );&#125; #####Flow我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。######Flow有如下优点： 性能好；Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。 灵活；由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。 ######缺点： 使用复杂. 不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。示例：我们对六个色块进行自定义流式布局并实现TestFlowDelegate:：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class _home extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt;&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: new Text(&quot;title&quot;), centerTitle: true, ), body: Flow( delegate: TestFlowDelegate(margin: EdgeInsets.all(10.0)), children: &lt;Widget&gt;[ new Container(width: 80.0, height:80.0, color: Colors.red,), new Container(width: 80.0, height:80.0, color: Colors.green,), new Container(width: 80.0, height:80.0, color: Colors.blue,), new Container(width: 80.0, height:80.0, color: Colors.yellow,), new Container(width: 80.0, height:80.0, color: Colors.brown,), new Container(width: 80.0, height:80.0, color: Colors.purple,), ], ), ); &#125;&#125;class TestFlowDelegate extends FlowDelegate &#123; EdgeInsets margin = EdgeInsets.zero; TestFlowDelegate(&#123;this.margin&#125;); @override void paintChildren(FlowPaintingContext context) &#123; var x = margin.left; var y = margin.top; //计算每一个子widget的位置 for (int i = 0; i &lt; context.childCount; i++) &#123; var w = context.getChildSize(i).width + x + margin.right; if (w &lt; context.size.width) &#123; context.paintChild(i, transform: new Matrix4.translationValues( x, y, 0.0)); x = w + margin.left; &#125; else &#123; x = margin.left; y += context.getChildSize(i).height + margin.top + margin.bottom; //绘制子widget(有优化) context.paintChild(i, transform: new Matrix4.translationValues( x, y, 0.0)); x += context.getChildSize(i).width + margin.left + margin.right; &#125; &#125; &#125; getSize(BoxConstraints constraints)&#123; //指定Flow的大小 return Size(double.infinity,200.0); &#125; @override bool shouldRepaint(FlowDelegate oldDelegate) &#123; return oldDelegate != this; &#125;&#125; 可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-按钮(03)/","text":"Material widget库中提供了多种按钮Widget如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton的包装定制，所以他们大多数属性都和RawMaterialButton一样。在介绍各个按钮时我们先介绍其默认外观，而按钮的外观大都可以通过属性来自定义，我们在后面统一介绍这些属性。另外，所有Material 库中的按钮都有如下相同点： 按下时都会有“水波动画”。 有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title: &#x27;flutter demo&#x27;, home: _home(), ); &#125;&#125;class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new Column( children: &lt;Widget&gt;[ RaisedButton( child: Text(&quot;RaisedButton&quot;), onPressed: _pressed,//onPressed点击回调 这里设置的是一个空的方法 默认是null，为null时会禁用点击事件 elevation: 2.0, //正常状态下的阴影 highlightElevation: 4.0, //按下时的阴影 disabledElevation: 0.0, // 禁用时的阴影 ), FlatButton( child: Text(&quot;FlatButton&quot;), onPressed: _pressed, ), OutlineButton( child: Text(&quot;OutlineButton&quot;), onPressed: _pressed, ), IconButton( icon: Icon(Icons.thumb_up), onPressed: _pressed, ), FlatButton( child: Text(&quot;自定义样式&quot;), //child按钮中的内容 textColor: Colors.white, //文字颜色 disabledTextColor: Colors.red, //按钮禁用时的文字颜色 color: Colors.lightBlue, //背景颜色 disabledColor: Colors.grey, //按钮禁用时的背景颜色 highlightColor: Colors.amber, //按钮按下时的背景颜色 splashColor: Colors.black12, //点击时，水波动画中水波的颜色 padding: EdgeInsets.all(2.0), //内边距 colorBrightness: Brightness.dark, ////按钮主题，默认是浅色主题 shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(4.0)), //外形 onPressed: _pressed, ), ], ), ); &#125; void _pressed() &#123;&#125;&#125; #####监听文本变化1.设置onChange回调 123456789101112TextField( autofocus: false, keyboardType: TextInputType.number, decoration: InputDecoration( hintText: &quot;用户密码&quot;, prefixIcon: Icon(Icons.lock), ), obscureText: true, onChanged: (value)&#123;//输入内容改变的回调监听 print(value); &#125;, ), 2.通过controller监听 123 controller: textEditingController,//点击提交时的回调 TextEditingController textEditingController=new TextEditingController();//在用户点击提交或其他情况下通过textEditingController.text获取输入的值","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-线性布局Row和Column-1/","text":"#####线性布局Row和Column所谓线性布局，即指沿水平或垂直方向排布子Widget。Flutter中通过Row和Column来实现线性布局，类似于Android中的LinearLayout控件。Row和Column都继承自Flex，我们将在弹性布局一节中详细介绍Flex。 #####主轴和纵轴对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就指是水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类MainAxisAlignment和CrossAxisAlignment，分别代表主轴对齐和纵轴对齐。 #####RowRow可以在水平方向排列其子widget。定义如下： 123456789Row(&#123; ... TextDirection textDirection, MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, VerticalDirection verticalDirection = VerticalDirection.down, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。 mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子widgets没有占满水平剩余空间，则Row的实际宽度等于所有子widgets占用的的水平空间； mainAxisAlignment：表示子Widgets在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子widgets的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义 MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。 verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。 crossAxisAlignment：表示子Widgets在纵轴方向的对齐方式，Row的高度等于子Widgets中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反； children ：子Widgets数组。示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Widget _body()&#123; return Column( //测试Row对齐方式，排除Column默认居中对齐的干扰 crossAxisAlignment: CrossAxisAlignment.start,//垂直方向 向左靠齐 children: &lt;Widget&gt;[ Row( mainAxisAlignment: MainAxisAlignment.center,//主轴居中 children: &lt;Widget&gt;[ Text(&quot; hello world &quot;), Text(&quot; I am Jack &quot;), ], ), Row( mainAxisSize: MainAxisSize.min, mainAxisAlignment: MainAxisAlignment.center, //，由于mainAxisSize值为MainAxisSize.min，Row的宽度等于两个Text的宽度和， // 所以对齐是无意义的，所以会从左往右显示 children: &lt;Widget&gt;[ Text(&quot; hello world &quot;), Text(&quot; I am Jack &quot;), ], ), Row( mainAxisAlignment: MainAxisAlignment.end, textDirection: TextDirection.rtl, //Row设置textDirection值为TextDirection.rtl， // 所以子widget会从右向左的顺序排列，而此时MainAxisAlignment.end表示左对齐 children: &lt;Widget&gt;[ Text(&quot; hello world &quot;), Text(&quot; I am Jack &quot;), ], ), Row( crossAxisAlignment: CrossAxisAlignment.start, verticalDirection: VerticalDirection.up, //由于两个子Text字体不一样，所以其高度也不同，我们指定了verticalDirection值为VerticalDirection.up， // 即从低向顶排列，而此时crossAxisAlignment值为CrossAxisAlignment.start表示底对齐 children: &lt;Widget&gt;[ Text(&quot; hello world &quot;, style: TextStyle(fontSize: 30.0),), Text(&quot; I am Jack &quot;), ], ), ], );&#125; 解释：第一个Row很简单，默认为居中对齐；第二个Row，由于mainAxisSize值为MainAxisSize.min，Row的宽度等于两个Text的宽度和，所以对齐是无意义的，所以会从左往右显示；第三个Row设置textDirection值为TextDirection.rtl，所以子widget会从右向左的顺序排列，而此时MainAxisAlignment.end表示左对齐，所以最终显示结果就是图中第三行的样子；第四个Row测试的是纵轴的对齐方式，由于两个子Text字体不一样，所以其高度也不同，我们指定了verticalDirection值为VerticalDirection.up，即从低向顶排列，而此时crossAxisAlignment值为CrossAxisAlignment.start表示底对齐。ColumnColumn可以在垂直方向排列其子widget。参数和Row一样，不同的是布局方向为垂直，主轴纵轴正好相反，读者可类比Row来理解，在此不再赘述。 #####特殊情况如果Row里面嵌套Row，或者Column里面再嵌套Column，那么只有对最外面的Row或Column会占用尽可能大的空间，里面Row或Column所占用的空间为实际大小，下面以Column为例说明： 123456789101112131415161718192021222324Widget _body()&#123; return Container( color: Colors.green, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.max, //有效，外层Colum高度为整个屏幕 children: &lt;Widget&gt;[ Container( color: Colors.red, child: Column( mainAxisSize: MainAxisSize.max,//无效，内层Colum高度为实际高度 children: &lt;Widget&gt;[ Text(&quot;hello world &quot;), Text(&quot;I am Jack &quot;), ], ), ) ], ), ), );&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-线性布局Row和Column/","text":"所谓线性布局，即指沿水平或垂直方向排布子Widget。Flutter中通过Row和Column来实现线性布局，类似于Android中的LinearLayout控件。Row和Column都继承自Flex，我们将在弹性布局一节中详细介绍Flex#####主轴和纵轴对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就指是水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类MainAxisAlignment和CrossAxisAlignment，分别代表主轴对齐和纵轴对齐。","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-输入框和标点/","text":"#####简单的应用： 1234567891011121314151617181920212223242526272829303132333435363738class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body:new Column( children: &lt;Widget&gt;[ TextField(//输入框Widget autofocus: true,//是否自动获取焦点 decoration: InputDecoration(//InputDecoration：用于控制TextField的外观显示，如提示文本、背景颜色、边框等。 hintText: &quot;用户名昵称&quot;, prefixIcon: Icon(Icons.person), ), ), TextField( autofocus: false, keyboardType: TextInputType.number, decoration: InputDecoration( hintText: &quot;用户密码&quot;, prefixIcon: Icon(Icons.lock), ), obscureText: true,//是否隐藏输入内容 ) ], ) ); &#125;&#125; #####常用属性： controller：编辑框的控制器，通过它可以设置&#x2F;获取编辑框的内容、选择编辑内容、监听编辑文本改变事件。大多数情况下我们都需要显式提供一个controller来与文本框交互。如果没有提供controller，则TextField内部会自动创建一个 focusNode：用于控制TextField是否占有当前键盘的输入焦点。它是我们和键盘交互的一个handle。 InputDecoration：用于控制TextField的外观显示，如提示文本、背景颜色、边框等。 prefixIcon：输入框内侧左面的控件 suffixIcon: 输入框内侧右面的图标. keyboardType：用于设置该输入框默认的键盘输入类型，取值如下：1.TextInputType.text（普通完整键盘）2.TextInputType.number（数字键盘）3.TextInputType.emailAddress（带有“@”的普通键盘）4.TextInputType.datetime（带有“&#x2F;”和“：”的数字键盘）5.TextInputType.multiline（带有选项以启用有符号和十进制模式的数字键盘） style：正在编辑的文本样式。 textAlign: 输入框内编辑文本在水平方向的对齐方式。 autofocus: 是否自动获取焦点。 obscureText：是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。 maxLines：输入框的最大行数，默认为1；如果为null，则无行数限制。 maxLength和maxLengthEnforced ：maxLength代表输入框文本的最大长度，设置后输入框右下角会显示输入的文本计数 maxLengthEnforced决定当输入文本长度超过maxLength时是否阻止输入，为true时会阻止输入，为false时不会阻止输入但输入框会变红。 onChange：输入框内容改变时的回调函数；注：内容改变事件也可以通过controller来监听。 onEditingComplete和onSubmitted：这两个回调都是在输入框输入完成时触发，比如按了键盘的完成键（对号图标）或搜索键（🔍图标）。不同的是两个回调签名不同，onSubmitted回调是ValueChanged类型，它接收当前输入内容做为参数，而onEditingComplete不接收参数。inputFormatters：用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验。enable：如果为false，则输入框会被禁用，禁用状态不接收输入和事件，同时显示禁用态样式（在其decoration中定义）。cursorWidth、cursorRadius和cursorColor：这三个属性是用于自定义输入框光标宽度、圆角和颜色的。 #####未完待续…","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter-颜色渐变/","text":"12345678910111213141516171819202122232425262728class _home extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( appBar: new AppBar( title: Text(&quot;title&quot;), centerTitle: true, ), body: new Center( child: new Container( height: 200.0, decoration: new BoxDecoration( gradient: const LinearGradient( colors: [Colors.amberAccent, Colors.lightBlue, Colors.red]), border: Border.all(width: 5.0,color: Colors.green) ), ), ) ); &#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/Flutter/flutter简介/","text":"######快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。######富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。######原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。######统一的应用开发体验Flutter拥有丰富的工具和库，可以帮助您轻松地同时在iOS和Android系统中实现您的想法和创意。 如果您没有任何移动端开发体验，Flutter是一种轻松快捷的方式来构建漂亮的移动应用程序。 如果您是一位经验丰富的iOS或Android开发人员，则可以使用Flutter作为视图(View)层， 并可以使用已经用Java &#x2F; ObjC &#x2F; Swift完成的部分（Flutter支持混合开发）。官方文档：https://flutterchina.club/ &#96;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/其他笔记/QT/QT-Creator安装/","text":"下载连接：Download Qt: Get Qt Online Installer安装手册：How to install Qt - Overview #####安装时选择组件注意勾选插件msvc插件，最后该版本下的所有插件一并勾选；","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"QT","slug":"其他笔记/QT","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/"}]},{"path":"wiki/其他笔记/Flutter/flutter基础使用(01)/","text":"123456789101112131415161718192021222324252627282930313233343536373839import &#x27;package:flutter/material.dart&#x27;;//引入包//main.dart 程序第一个类 类似于android的MyApplication 系统默认入口 可通过studio自定义配置//void main 当前页面的主入口类似于android中的onStartvoid main() =&gt; runApp(MyApp());//Stateless widgets 是不可变的, 这意味着它们的属性不能改变 - 所有的值都是最终的,适用于方法内部不会动态改变的时候使用.//Stateful widgets 持有的状态可能在widget生命周期中发生变化,适用于方法内部需要动态改变的时候使用.class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( title:&#x27;flutter demo&#x27;,//程序切换到后台时显示的标题 home: _home(),//程序主体 ); &#125;&#125;class _home extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _homeState(); &#125;&#125;class _homeState extends State&lt;_home&gt;&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Scaffold( //Scaffold 实现了基本的纸墨设计布局结构。可参考：https://www.jianshu.com/p/a08f43173b72 appBar: new AppBar(//标题栏 title: Text(&quot;title&quot;),//标题 centerTitle: true,//标题居中 ), body: new Center(//body 页面布局 Center内的内容页面居中 child: new Text(&quot;hello word&quot;),//child 子控件 ) ); &#125;&#125;","categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"}]},{"path":"wiki/Android Application/Android兼容适配/多个fragment重叠时，点击事件穿透解决方法（viewpager+fragment）/","text":"叠在一起的fragment上层会响应下层的按钮点击事件，而且还会响应activity中的点击事件。在每个fragment布局的根节点加一条android:clickable&#x3D;”true”可破。这在个别手机上会出现这种情况，需要适配","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android兼容适配","slug":"Android-Application/Android兼容适配","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/"}]},{"path":"wiki/Android Application/Android兼容适配/虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏/","text":"在需要隐藏虚拟键Navigation Bar的Activity的onCreate方法中添加如下代码：第一种：始终隐藏navigation，即使点击屏幕也不会出现： WindowManager.LayoutParams params &#x3D; getWindow().getAttributes(); params.systemUiVisibility &#x3D; View.SYSTEM_UI_FLAG_HIDE_NAVIGATION|View.SYSTEM_UI_FLAG_IMMERSIVE; getWindow().setAttributes(params);第二种：初始化时隐藏，点击屏幕后Navigation重新出现：WindowManager.LayoutParams params &#x3D;getWindow().getAttributes();params.systemUiVisibility &#x3D; View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;getWindow().setAttributes(params);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android兼容适配","slug":"Android-Application/Android兼容适配","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/"}]},{"path":"wiki/Android Application/Android兼容适配/适配华为等有虚拟按键的屏幕的解决方案/","text":"一、概述 在项目中,测试发现在一些华为手机的屏幕适配上出现了问题,主要是因为华为Mate等一些系列的手机有一个虚拟按键的设计.当这些虚拟按键由用户手势滑出,或默认显示的话,就会遮挡我们本身的应用布局.比如欢迎界面过后是四个Fragment,那么底部的四个tab就会被虚拟的导航栏遮住,非常难看. 当然,欢迎页的图片适配也同样会出现问题. Google后得出第一个问题的解决方案.第二个图片的问题则用自己摸索的方式解决,当然也非常简单. 二、布局由于虚拟按键导致导航栏顶上去的解决方法 在我们的项目中加载Fragment的MainActivity,以及其他一般的Activity继承的BaseActivity中的onCreate方法中添加如下代码: if (AndroidWorkaround.checkDeviceHasNavigationBar(this)) { AndroidWorkaround.assistActivity(findViewById(android.R.id.content)); } 其中AndroidWorkaround使我们为了解决该问题而封装的类,也可以看作是一个特定的工具类: &#x2F;** * 解决底部屏幕按键适配 * Created by Mercury on 2016&#x2F;10&#x2F;25. *&#x2F; public class AndroidWorkaround { public static void assistActivity(View content) { ​ new AndroidWorkaround(content); } private View mChildOfContent; private int usableHeightPrevious; private ViewGroup.LayoutParams frameLayoutParams; private AndroidWorkaround(View content) { ​ mChildOfContent &#x3D; content; ​ mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { ​ public void onGlobalLayout() { ​ possiblyResizeChildOfContent(); ​ } ​ }); ​ frameLayoutParams &#x3D; mChildOfContent.getLayoutParams(); } private void possiblyResizeChildOfContent() { ​ int usableHeightNow &#x3D; computeUsableHeight(); ​ if (usableHeightNow !&#x3D; usableHeightPrevious) { ​ frameLayoutParams.height &#x3D; usableHeightNow; ​ mChildOfContent.requestLayout(); ​ usableHeightPrevious &#x3D; usableHeightNow; ​ } } private int computeUsableHeight() { ​ Rect r &#x3D; new Rect(); ​ mChildOfContent.getWindowVisibleDisplayFrame(r); ​ return (r.bottom); } public static boolean checkDeviceHasNavigationBar(Context context) { ​ boolean hasNavigationBar &#x3D; false; ​ Resources rs &#x3D; context.getResources(); ​ int id &#x3D; rs.getIdentifier(“config_showNavigationBar”, “bool”, “android”); ​ if (id &gt; 0) { ​ hasNavigationBar &#x3D; rs.getBoolean(id); ​ } ​ try { ​ Class systemPropertiesClass &#x3D; Class.forName(“android.os.SystemProperties”); ​ Method m &#x3D; systemPropertiesClass.getMethod(“get”, String.class); ​ String navBarOverride &#x3D; (String) m.invoke(systemPropertiesClass, “qemu.hw.mainkeys”); ​ if (“1”.equals(navBarOverride)) { ​ hasNavigationBar &#x3D; false; ​ } else if (“0”.equals(navBarOverride)) { ​ hasNavigationBar &#x3D; true; ​ } ​ } catch (Exception e) { ​ } ​ return hasNavigationBar; } } 重新测试，发现无论是否弹出虚拟按键，都不会再次遮挡tab按钮。 三、原理 上面的代码需要在setContentView后面执行。其最初的解决方案是stackoverflow上有人为了适配软键盘在全屏下的布局问题。 开始先判断该设备上是否存在导航栏。为什么用findViewById(android.R.id.content)呢？因为android.R.id.content这个id代表的就是所在页面的根布局，而并不需要特别指定一个id给该布局。可以通过调用系统API返回的结果，也可以通过判断该手机是否为华为手机，操作系统属于哪种类型来来判断。 一旦确定该设备存在导航栏，将对该布局进行重新测量。首先mChildOfContent得到其视图树，对全局高度实现监听。 OnGlobalLayoutListener 是ViewTreeObserver的内部类，当一个视图树的布局发生改变时，可以被ViewTreeObserver监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。ViewTreeObserver不能直接实例化，而是通过getViewTreeObserver()获得。 接着得到视图目前可用的总高度，将其赋值给mChildOfContent的布局高度。调用requestLayout，让mChildOfContent要求自己的parent view对自己重新设置位置。 四、全屏图片的适配 解决了布局的问题，再来看欢迎页启动时候全屏图片的适配问题。发现该方法对于图片不适用。如下图，当虚拟按键弹出时，图片照样被遮挡了底部的一小部分。 如果隐藏虚拟按键，图片大小恢复正常 仔细想想，对于一个ImageView直接占据一个layout的情况，是没有必要再去写一些代码进行适配的。到布局里一看，发现ImageView的属性 android:scaleType&#x3D;”centerCrop” 将其改为 android:scaleType&#x3D;”fitXY”就可以解决了。这样图片可能高度会随着虚拟键的弹出而压缩，但是很好的适配了布局高度的变化而不会被遮挡。 转自：http://blog.csdn.net/wzhseu/article/details/58117424","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android兼容适配","slug":"Android-Application/Android兼容适配","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/"}]},{"path":"wiki/Android Application/Android兼容适配/设置ImageView图片时,宽度为match时需要设置scaleType为fitXY/","text":"123456&lt;ImageView android:src=&quot;@mipmap/icon_my_top_bg&quot; android:layout_width=&quot;match_parent&quot; android:scaleType=&quot;fitXY&quot; android:layout_height=&quot;match_parent&quot;/&gt; 如果是像上面那样设置时，记得加上android:scaleType&#x3D;”fitXY”，不然高清手机或者宽屏手机上无法铺满","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android兼容适配","slug":"Android-Application/Android兼容适配","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/"}]},{"path":"wiki/Android Application/Android日常问题/Android-9-0-P-http-网络请求的问题/","text":"Google表示，为保证用户数据和设备的安全，针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P 系统的安卓设备无论是接收或者发送流量，未来都不能明码传输，需要使用下一代(Transport Layer Security)传输层安全协议，而 Android Nougat 和 Oreo 则不受影响。 因此在Android P 使用HttpUrlConnection进行http请求会出现以下异常： 1&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 12px !important; background: rgb(238, 238, 238); border: 0px; overflow: auto; border-radius: 2px;&quot;&gt;W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted&lt;/pre&gt; 使用OKHttp请求则出现： 1&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 12px !important; background: rgb(238, 238, 238); border: 0px; overflow: auto; border-radius: 2px;&quot;&gt;java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy&lt;/pre&gt; 在Android P系统的设备上，如果应用使用的是非加密的明文流量的http网络请求，则会导致该应用无法进行网络请求，https则不会受影响，同样地，如果应用嵌套了webview，webview也只能使用https请求。 有人认为 Android P 上所有的 App 都需要使用 TLS 加密会降低上网体验，事实上这是一种误解，至于 App 对于少数旧服务器的连接如果非要使用明码传输，开发者需要更改 App 的网络安全配置以允许此类连接。 有以下三种解决方案 APP改用https请求 targetSdkVersion 降到27以下 在 res 下新增一个 xml 目录，然后创建一个名为：network_security_config.xml 文件（名字自定） ，内容如下，大概意思就是允许开启http请求1234&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 12px !important; background: rgb(238, 238, 238); border: 0px; overflow: auto; border-radius: 2px;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt;&lt;/pre&gt; 然后在APP的AndroidManifest.xml文件下的application标签增加以下属性12&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 12px !important; background: rgb(238, 238, 238); border: 0px; overflow: auto; border-radius: 2px;&quot;&gt;&lt;application ... android:networkSecurityConfig=&quot;@xml/network_security_config&quot; ... /&gt;&lt;/pre&gt; 参考资料：https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html https://android-developers.googleblog.com/2018/04/dns-over-tls-support-in-android-p.html","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常问题/Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法/","text":"#####代码执行获取密钥散列： 123456789101112131415161718try &#123; int i = 0; PackageInfo info = getPackageManager().getPackageInfo( getPackageName(), PackageManager.GET_SIGNATURES); for (Signature signature : info.signatures) &#123; i++; MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;); md.update(signature.toByteArray()); String KeyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT); //KeyHash 就是你要的，不用改任何代码 复制粘贴 ; Log.e(&quot;tyl&quot;,&quot;KeyHash=&quot;+KeyHash); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; catch (NoSuchAlgorithmException e) &#123; &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常问题/Android-studio-点击运行总是进入Debug模式/","text":"解决办法:解决方案：把手机的开发者模式关闭后，重新打开","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常问题/Android进程保活-息屏后后台保持定位、网络运行/","text":"####Android 设备在黑屏的分钟后可能会发生多种情况：应用程序切后台后进程资源被系统回收，导致不能持续定位。####解决办法：####长连接定时唤醒cpu（解决黑屏定位、黑屏断网问题） 对于原生Android系统可采用google给出的提升后台应用进程优先级的解决方案来解决，可参考google Android 开发者官网。 对于国内厂商提供的Android系统需要联系到对应的厂商进行系统底层应用白名单授权，才可以保证App进程在后台处于活跃状态。 CPU会处于休眠状态（不同厂商生产的设备CPU休眠时间不尽相同）（包含AP［Application Processor，ARM架构的处理器，用于支撑Android系统运行］和BP［Baseband Processor，运行实时操作系统，通讯协议栈等］）。一旦当CPU处于休眠状态，设备将无法正常链接网络，APP的定位请求也将无法正常发送。解决办法： 通过创建Timer来保持CPU唤醒状态：Android 的 Timer 类可以用来计划需要执行的任务。但 Timer 的问题是比较消耗手机电量（实现是用 WakeLock 让 CPU 保持唤醒状态）；另外一点是：部分厂商将WakeLock也设置了休眠时间，就是说 Timer 很可能和CPU一起处于休眠状态。Timer 类只能解决一小部分问题。 通过AlarmManager保持CPU处于唤醒状态：AlarmManager 是 Android 系统封装的用于管理 RTC 的模块，RTC (Real Time Clock) 是一个独立的硬件时钟，可以在 CPU 休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。用 AlarmManager 来定时执行任务，CPU 可以正常的休眠，需要运行定位时醒来即可。但部分厂商为了使设备更加省电，将AlarmManager也做出了修改，例如5s一次的响应更改为50s或者是几分钟，有些干脆在CPU休眠后彻底停掉了。 通过心跳长链接保持client端CPU处于唤醒状态：（推荐）最佳唤醒CPU的方法是通过server端与client端的长链接通信。例如每次长链接保持5分钟时间，每30s通信一次，这样可以有效确保CPU处于唤醒状态。 ####开启前台server（进程保活）思路：模仿一个音乐类软件，开启一个前台server并循环播放无声音乐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.guoshikeji.xiaoxiangDriver.services;import android.annotation.SuppressLint;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.IBinder;import com.guoshikeji.xiaoxiangDriver.MainActivity;import com.guoshikeji.xiaoxiangDriver.R;import static android.app.Notification.PRIORITY_MAX;/** * Created by tyl * 2019/11/12/012 * Describe: */public class BackGroundService extends Service &#123; Notification notification; private Context mContext; private static Thread uploadGpsThread; private MediaPlayer bgmediaPlayer; private boolean isrun = true; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; mContext = this; Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT); //1.通知栏占用，不清楚的看官网或者音乐类APP的效果 notification = new Notification.Builder(mContext) .setSmallIcon(R.mipmap.ic_launcher) .setWhen(System.currentTimeMillis()) .setTicker(getResources().getString(R.string.app_name)) .setContentTitle(getResources().getString(R.string.app_name)) .setContentText(&quot;正在后台运行&quot;) .setOngoing(true) .setPriority(PRIORITY_MAX) .setContentIntent(pendingIntent) .setAutoCancel(false) .build(); /*使用startForeground,如果id为0，那么notification将不会显示*/ startForeground(2479, buildNotification()); ////2.开启线程（或者需要定时操作的事情） //if(uploadGpsThread == null)&#123; // uploadGpsThread = new Thread(new Runnable() &#123; // @Override // public void run() &#123; // //这里用死循环就是模拟一直执行的操作 // while (isrun)&#123; // // //你需要执行的任务 // //doSomething(); // // try &#123; // Thread.sleep(10000L); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125; // &#125; // &#125;); //&#125; //3.最关键的神来之笔，也是最投机的动作，没办法要骗过CPU //这就是播放音乐类APP不被杀的做法，自己找个无声MP3放进来循环播放 //slient自己百度找一个无声的mp3即可 if(bgmediaPlayer == null)&#123; bgmediaPlayer = MediaPlayer.create(this,R.raw.slient); bgmediaPlayer.setLooping(true); bgmediaPlayer.start(); &#125; return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125; @Override public void onDestroy() &#123; isrun = false; stopForeground(true); bgmediaPlayer.release(); stopSelf(); super.onDestroy(); &#125; private NotificationManager notificationManager; private boolean isCreateChannel = false; @SuppressLint(&quot;NewApi&quot;) private Notification buildNotification() &#123; Notification.Builder builder = null; Notification notification = null; if (android.os.Build.VERSION.SDK_INT &gt;= 26) &#123; if (null == notificationManager) &#123; notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); &#125; String channelId = getPackageName(); if (!isCreateChannel) &#123; NotificationChannel notificationChannel = new NotificationChannel(channelId, &quot;BackgroundLocation&quot;, NotificationManager.IMPORTANCE_DEFAULT); notificationChannel.enableLights(false);//是否在桌面icon右上角展示小圆点 notificationChannel.setShowBadge(true); //是否在久按桌面图标时显示此渠道的通知 notificationManager.createNotificationChannel(notificationChannel); isCreateChannel = true; &#125; builder = new Notification.Builder(getApplicationContext(), channelId); &#125; else &#123; builder = new Notification.Builder(getApplicationContext()); &#125; builder.setSmallIcon(R.mipmap.icon_notifacation_log) .setColor(getResources().getColor(R.color.main_color)) .setContentTitle(getResources().getString(R.string.app_name)) .setContentText(&quot;正在后台运行&quot;) .setWhen(System.currentTimeMillis()); if (android.os.Build.VERSION.SDK_INT &gt;= 16) &#123; notification = builder.build(); &#125; else &#123; return builder.getNotification(); &#125; return notification; &#125;&#125; 清单文件注册： 1234&lt;service android:name=&quot;.services.BackGroundService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;/&gt; 启动server: 12Intent forgroundService = new Intent(this,BackGroundService.class); startService(forgroundService);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常问题/DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）/","text":"####出现错误的效果图：####解决方法： 123datePickerDialog.setTitle(&quot;&quot;);datePickerDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);datePickerDialog.show();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常问题/recyclerview-smoothScrollToPosition()平滑失效-未起效果/","text":"在项目中，想使RecyclerView慢慢的平缓滑动指定位置，于是使用： 1RecyclerView.smoothScrollToPosition(int); 发现效果并不理想，滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth（流畅的，平滑的），也就是说smoothScrollToPosition没有滑动效果?这里接不说底层原理了，网上一大把！ #####解决办法 重写LinearLayoutManager自定义滑动速度： 12345678910111213141516171819202122232425262728293031323334353637import android.content.Context;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.LinearSmoothScroller;import android.support.v7.widget.RecyclerView;import android.util.DisplayMetrics;/** * Created by tyl * 2018/12/19/019 * Describe:解决 RecyclerView调用smoothScrollToPosition时没有起到平滑的作用 * 设置LinerLayoutManager：recyclerview.setLayoutManager(new SmoothScrollLayoutManager(this)); *recyclerview.smoothScrollToPosition(i); */public class SmoothScrollLayoutManager extends LinearLayoutManager &#123; public SmoothScrollLayoutManager(Context context) &#123; super(context); &#125; @Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, final int position) &#123; LinearSmoothScroller smoothScroller = new LinearSmoothScroller(recyclerView.getContext()) &#123; // 返回：滑过1px时经历的时间(ms)。 @Override protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123; return 150f / displayMetrics.densityDpi; &#125; &#125;; smoothScroller.setTargetPosition(position); startSmoothScroll(smoothScroller); &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常问题/软键盘弹出后布局上移/","text":"AndroidManifest属性设置： 键盘直接覆盖，不让屏幕上移：&lt;activity android:name&#x3D;”.activity.HomeActivity” Android:windowSoftInputMode&#x3D;”adjustPan|stateHidden”&#x2F;&gt; 这样会让屏幕整体上移: Android:windowSoftInputMode&#x3D;”stateVisible|adjustResize” 这样键盘就会覆盖屏幕： Android:windowSoftInputMode&#x3D;”adjustPan” 方法一：在项目的AndroidManifest.xml文件中界面对应的里加入android:windowSoftInputMode&#x3D;”adjustPan”这样键盘就会覆盖屏幕。通过实践发现方法一并没有起作用，查询资料得知我的布局是RelativeLayout，底部菜单用了android:layout_alignParentBottom&#x3D;”true”,因此方法一不起作用，故采用方法二。 方法二：在代码setContentView()之前加入：getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN|WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); 亲测有效，另外还有一种通用的方法： 方法三：把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"path":"wiki/Android Application/Android日常记录/Activity的四种启动模式/","text":"在一个项目中会包括着多个Activity，系统中使用任务栈来存储创建的Activity实例，任务栈是一种“后进先出”的栈结构。举个栗子，若我们多次启动同一个Activity。系统会创建多个实例依次放入任务栈中。当按back键返回时，每按一次，一个Activity出栈，直到栈空为止。当栈中无不论什么Activity。系统就会回收此任务栈。 上面这个样例中的Activity并没有设置启动模式，你会发现多次启动同一个Activity。而系统却创建了多个实例，白白浪费内存，这样的情况Android早就替我们考虑好了。Android为Activity 的创建提供了4种启动模式，而依据实际应用场景的不同。为Activity 选择不同的启动模式，最大化降低了每次都须要在栈中创建一个新的Activity的压力，降低内存使用。 启动模式的具体说明和使用场景？以下依据这篇博文来一一解惑。 standard 模式这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop 模式如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。 singleTask 模式如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。 一. Android启动模式具体解释 1. Standard 标准模式 说明： Android创建Activity时的默认模式，假设没有为Activity设置启动模式的话，默觉得标准模式。每次启动一个Activity都会又一次创建一个新的实例入栈，无论这个实例是否存在。 生命周期：如上所看到的，每次被创建的实例Activity 的生命周期符合典型情况，它的onCreate、onStart、onResume都会被调用。 举例：此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为Standard 模式。 若在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是还有一个C Activity进入栈中，成为栈顶。 2. SingleTop 栈顶复用模式 说明：分两种处理情况：须要创建的Activity已经处于栈顶时，此时会直接复用栈顶的Activity。不会再创建新的Activity；若须要创建的Activity不处于栈顶，此时会又一次创建一个新的Activity入栈，同Standard模式一样。 生命周期：若情况一中栈顶的Activity被直接复用时，它的onCreate、onStart不会被系统调用，由于它并没有发生改变。可是一个新的方法 onNewIntent会被回调（Activity被正常创建时不会回调此方法）。 举例：此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为SingleTop 模式。情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。 结果是直接复用栈顶的C Activity。 情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。结果是创建一个新的Activity入栈。成为栈顶。 3. SingleTask 栈内复用模式 说明：若须要创建的Activity已经处于栈中时，此时不会创建新的Activity，而是将存在栈中的Activity上面的其他Activity所有销毁，使它成为栈顶。 生命周期：同SingleTop 模式中的情况一同样。仅仅会又一次回调Activity中的 onNewIntent方法 举例：此时Activity 栈中以此有A、B、C三个Activity。此时C处于栈顶，启动模式为SingleTask 模式。 情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是直接用栈顶的C Activity。情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。 结果是将A Activity上面的B、C所有销毁，使A Activity成为栈顶。 4. SingleInstance 单实例模式 说明： SingleInstance比較特殊，是全局单例模式，是一种加强的SingleTask模式。它除了具有它所有特性外，还加强了一点：具有此模式的Activity仅仅能单独位于一个任务栈中。 这个经常使用于系统中的应用，比如Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。 举例：比方 A Activity是该模式，启动A后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁。 二.启动模式的使用方式 1. 在 Manifest.xml中指定Activity启动模式 一种静态的指定方法，在Manifest.xml文件里声明Activity的同一时候指定它的启动模式，这样在代码中跳转时会依照指定的模式来创建Activity。样例例如以下： 2. 启动Activity时。在Intent中指定启动模式去创建Activity 一种动态的启动模式，在new 一个Intent后，通过Intent的addFlags方法去动态指定一个启动模式。样例例如以下： Intent intent &#x3D; new Intent();intent.setClass(context, MainActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);context.startActivity(intent); 注意：以上两种方式都能够为Activity指定启动模式，可是二者还是有差别的。 （1）优先级：动态指定方式即另外一种比第一种优先级要高，若两者同一时候存在，以另外一种方式为准。 （2）限定范围：第一种方式无法为Activity直接指定 FLAG_ACTIVITY_CLEAR_TOP 标识，另外一种方式无法为Activity指定 singleInstance 模式。 三. Activity 的 Flags 标记位既能够设定Activity的启动模式，如同上面介绍的，在动态指定启动模式，比方 FLAG_ACTIVITY_NEW_TASK 和FLAG_ACTIVITY_SINGLE_TOP 等。它还能够影响Activity 的运行状态 ，比方 FLAG_ACTIVITY_CLEAN_TOP 和 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 等。 以下介绍几个基本的标记位，切勿死记，理解几个就可以，须要时再查官方文档。 1. FLAG_ACTIVITY_NEW_TASK 作用是为Activity指定 “SingleTask”启动模式。跟在AndroidMainfest.xml指定效果同样。 2. FLAG_ACTIVITY_SINGLE_TOP 作用是为Activity指定 “SingleTop”启动模式，跟在AndroidMainfest.xml指定效果同样。 3. FLAG_ACTIVITY_CLEAN_TOP 具有此标记位的Activity，启动时会将与该Activity在同一任务栈的其他Activity出栈。一般与SingleTask启动模式一起出现。它会完毕SingleTask的作用。但事实上SingleTask启动模式默认具有此标记位的作用 4.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有此标记位的Activity不会出如今历史Activity的列表中，使用场景：当某些情况下我们不希望用户通过历史列表回到Activity时，此标记位便体现了它的效果。它等同于在xml中指定Activity的属性： android:excludeFromRecents&#x3D;”trure” 四. 启动模式的实际应用场景 这四种模式中的Standard模式是最普通的一种，没有什么特别注意。而SingleInstance模式是整个系统的单例模式，在我们的应用中一般不会应用到。所以，这里就具体解说 SingleTop 和 SingleTask模式的运用场景： 1. SingleTask模式的运用场景 最常见的应用场景就是保持我们应用开启后仅仅有一个Activity的实例。最典型的样例就是应用中展示的主页（Home页）。 假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用SingleTask模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。 2. SingleTop模式的运用场景 假设你在当前的Activity中又要启动同类型的Activity，此时建议将此类型Activity的启动模式指定为SingleTop，能够降低Activity的创建，节省内存！ 3. 注意：复用Activity时的生命周期回调 这里还须要考虑一个Activity跳转时携带页面參数的问题。 由于当一个Activity设置了SingleTop或者SingleTask模式后，跳转此Activity出现复用原有Activity的情况时，此Activity的onCreate方法将不会再次运行。onCreate方法仅仅会在第一次创建Activity时被运行。 而一般onCreate方法中会进行该页面的数据初始化、UI初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题，若页面展示的数据就是通过getInten() 方法来获取，那么问题就会出现：getInten()获取的一直都是老数据，根本无法接收跳转时传送的新数据！ 以下，通过一个样例来具体解释： Manifest.xml publicclassCourseDetailActivityextendsBaseActivity{......@OverrideprotectedvoidonCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState); setContentView(R.layout.activity_course_detail_layout); initData(); initView(); }&#x2F;&#x2F;初始化数据privatevoidinitData() { Intent intent &#x3D; getIntent(); mCourseID &#x3D; intent.getStringExtra(COURSE_ID); }&#x2F;&#x2F;初始化UIprivatevoidinitView() { …… } ……} 以上代码中的CourseDetailActivity在配置文件里设置了启动模式是SingleTop模式，依据上面启动模式的介绍可得知，当CourseDetailActivity处于栈顶时。再次跳转页面到CourseDetailActivity时会直接复用原有的Activity，并且此页面须要展示的数据是从getIntent(）方法得来，可是initData()方法不会再次被调用，此时页面就无法显示新的数据。 当然这样的情况系统早就为我们想过了，这时我们须要另外一个回调 onNewIntent（Intent intent）方法。此方法会传入最新的intent，这样我们就能够解决上述问题。这里建议的方法是又一次去setIntent。然后又一次去初始化数据和UI。代码例如以下所看到的： &#x2F;* * 复用Activity时的生命周期回调 *&#x2F;@OverrideprotectedvoidonNewIntent(Intent intent) {super.onNewIntent(intent); setIntent(intent); initData(); initView(); } 这样，在一个页面中能够反复跳转并显示不同的内容。 转自：https://www.cnblogs.com/claireyuancy/p/7387696.html","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Android-Elevation/","text":"#####简介：在Android API21，新添加了一个属性：android:elevation，用以在xml定义View的深度(高度)，也即z方向的值。除了elevation之外，类似于已有的translationX、translationY，也相对应地新增了一个translationZ，用以在属性动画中动态改变Z值（使用View.setTranslationZ()） 1Z = elevation + translationZ #####在引入了这个属性之后，主要影响有两个：影响View的阴影影响View相互阻挡顺序#####1. 影响View的阴影Z值会对View的阴影外观造成影响，但是不是对View大小造成影响。拥有更大Z值的View会有一个更大但是更柔和的阴影——这跟我们生活的实际体验是一致的，官方给的效果图：#####2. 影响View相互阻挡顺序拥有更大Z值的View会挡住Z值比较小的View——即更大Z值的View会在最上层。譬如，在正常的FrameLayout中，子View的绘制顺序是从上到下，也就是说，最后一个子View会显示到最上面，如果位置跟前面的View有重合，则会盖住前面的View。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/viewA&quot; android:background=&quot;#f00&quot; android:text=&quot;A&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/viewB&quot; android:background=&quot;#0f0&quot; android:text=&quot;B&quot; android:gravity=&quot;center&quot; android:layout_marginLeft=&quot;60dp&quot; android:layout_marginTop=&quot;60dp&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; /&gt; &lt;!--ViewC有了一个elevation属性 --&gt; &lt;TextView android:id=&quot;@+id/viewC&quot; android:layout_marginLeft=&quot;180dp&quot; android:background=&quot;#f00&quot; android:text=&quot;C&quot; android:gravity=&quot;center&quot; android:elevation=&quot;1dp&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/viewD&quot; android:background=&quot;#0f0&quot; android:text=&quot;D&quot; android:gravity=&quot;center&quot; android:layout_marginLeft=&quot;240dp&quot; android:layout_marginTop=&quot;60dp&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; /&gt;&lt;/FrameLayout&gt; 比如，上面的xml代码，效果如下图所示： 先看ViewA、ViewB，因为ViewB是第二个子View，ViewA是第一个，所以B会覆盖在A的上面。 然后ViewC、D，跟AB相比较，区别就在于ViewC多了一个elevation属性，有了一个比ViewD更大的Z值，所以，即使它在ViewD的前面，但是依然能够盖住D~ #####注意 设置Elevation 属性失效的情况： 123456789101. 控件必须设置背景色，且不能为透明。2. 阴影是绘制于父控件上的，所以控件与父控件的边界之间需有足够空间绘制出阴影才行。3. 有网友提出图片尽量使用.png, 防止图片过大导致oom或者elevation失效4. 经过本人测试，除了上述原因外，还有：background是图片时、background直接设置具体颜色值时容易无效如：#ffaacc，background是shape时效果最好5.设置elevation的View最好是ViewGroup子类","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Android常用设计模式/","text":"####设计模式分类 创建型模式 工厂方式模式 建造者模式 抽象工程模式 原型模式 单例模式 结构型模式 桥接模式 代理模式 享元模式 外观模式 装饰器模式 组合模式 适配器模式 行为型模式 备忘录模式 解释器模式 命令模式 中介者模式 观察者模式 策略模式 状态模式 模板方法模式 访问者模式 迭代子模式 责任链模式","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Android-根据逗号分隔String/","text":"1234567String str=&quot;112,123,123,123&quot;;//根据逗号分隔到List数组中 String str2=str.replace(&quot; &quot;, &quot;&quot;)//去掉所用空格List&lt;String&gt; list= Arrays.asList(str2.split(&quot;,&quot;))//list的结果就是[113,123,123,123]","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Android内存管理/","text":"一个APP通常就是一个进程对应一个虚拟机获取内存大小： GC只在Heap剩余空间不足的时候才触发垃圾回收GC触发时，所有的线程都是会被暂停的每个App分配的内存限制，随不同设备而不同吃内存大户：图片App内存优化方法：1:数据结构优化 2：对象复用数据结构优化：频繁字符串拼接用StringBuillder(字符串通过+的方式拼接，会产生中间字符串内存块，这些都是没用的并且更耗时更低效)！ ArrayMap,SparseArray替换HashMap(ArrayMap,SparseArray效率更高，内存更小，使用方法和HashMap一样的,HashMap一个entry需要额外占用的32B) 内存抖动（突然间生成很多对象，变量或内存空间后用了没多久又不用了，如此反复就是内存抖动，内存像波浪形一会高一会低） 再小的class耗费0.5KB（尽量复用class） 对象复用：复用系统自带的资源 ListView&#x2F;GridView的ConvertView复用 避免在OnDraw方法里面执行对象的创建（在OnDraw中对象的变更会重绘View） 避免内存泄漏：内存泄漏会导致剩余可用的Heao越来越少，频繁触发GC 尤其Activity泄漏（如果有耗时操作为执行完，则GC无法回收还在被引用的资源） 用Application Context而不是Activity Context 注意Cursor对象是否及时关闭（数据库操作时） 强引用和软引用的意义： 优化OOM问题的方法：注意临时BitMap对象的及时回收 避免BitMap的浪费 Try catch某些大内存分配的操作 加载BitMap:缩放比例，解码格式，局部加载 **OOM绝大部分发生在图片**","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Android自定义View/","text":"转自：https://www.jianshu.com/p/e9d8420b1b9c自定义View是Android开发者必须了解的基础 今天，我将手把手教你写一个自定义View，并理清自定义View所有应该的注意点 阅读本文前，请先阅读我写的一系列自定义View文章 （1）自定义View基础 - 最易懂的自定义View原理系列 （2）自定义View Measure过程 - 最易懂的自定义View原理系列 （3）自定义View Layout过程 - 最易懂的自定义View原理系列 （4）自定义View Draw过程- 最易懂的自定义View原理系列 Android事件分发机制详解：史上最全面、最易懂 1. 自定义View的分类自定义View一共分为两大类，具体如下图： 分类 2. 具体介绍 &amp; 使用场景对于自定义View的类型介绍及使用场景如下图： 具体介绍 &amp; 使用场景 3. 使用注意点在使用自定义View时有很多注意点（坑），希望大家要非常留意： 使用注意点 3.1 支持特殊属性 支持wrap_content 如果不在onMeasure（）中对wrap_content作特殊处理，那么wrap_content属性将失效 具体原因请看文章：为什么你的自定义View wrap_content不起作用？ 支持padding &amp; margin 如果不支持，那么padding和margin（ViewGroup情况）的属性将失效 对于继承View的控件，padding是在draw()中处理 对于继承ViewGroup的控件，padding和margin会直接影响measure和layout过程 3.2 多线程应直接使用post方式 View的内部本身提供了post系列的方法，完全可以替代Handler的作用，使用起来更加方便、直接。 3.3 避免内存泄露 主要针对View中含有线程或动画的情况：当View退出或不可见时，记得及时停止该View包含的线程和动画，否则会造成内存泄露问题。 启动或停止线程&#x2F; 动画的方式： 启动线程&#x2F; 动画：使用view.onAttachedToWindow（），因为该方法调用的时机是当包含View的Activity启动的时刻 停止线程&#x2F; 动画：使用view.onDetachedFromWindow（），因为该方法调用的时机是当包含View的Activity退出或当前View被remove的时刻 3.4 处理好滑动冲突 当View带有滑动嵌套情况时，必须要处理好滑动冲突，否则会严重影响View的显示效果。 \\4. 具体实例 接下来，我将用自定义View中最常用的继承View来说明自定义View的具体应用和需要注意的点 4.1 继承VIew的介绍 Paste_Image.png 在下面的例子中，我将讲解： 如何实现一个基本的自定义View（继承VIew） 如何自身支持wrap_content &amp; padding属性 如何为自定义View提供自定义属性（如颜色等等） 实例说明：画一个实心圆 4.2 具体步骤创建自定义View类（继承View类） 布局文件添加自定义View组件 注意点设置（支持wrap_content &amp; padding属性自定义属性等等） 下面我将逐个步骤进行说明： 步骤1：创建自定义View类（继承View类） CircleView.java &#x2F;&#x2F; 用于绘制自定义View的具体内容&#x2F;&#x2F; 具体绘制是在复写的onDraw（）内实现publicclassCircleViewextendsView{&#x2F;&#x2F; 设置画笔变量Paint mPaint1;&#x2F;&#x2F; 自定义View有四个构造函数&#x2F;&#x2F; 如果View是在Java代码里面new的，则调用第一个构造函数publicCircleView(Context context){super(context);&#x2F;&#x2F; 在构造函数里初始化画笔的操作init(); }&#x2F;&#x2F; 如果View是在.xml里声明的，则调用第二个构造函数&#x2F;&#x2F; 自定义属性是从AttributeSet参数传进来的publicCircleView(Context context,AttributeSet attrs){super(context, attrs); init(); }&#x2F;&#x2F; 不会自动调用&#x2F;&#x2F; 一般是在第二个构造函数里主动调用&#x2F;&#x2F; 如View有style属性时publicCircleView(Context context,AttributeSet attrs,intdefStyleAttr ){super(context, attrs,defStyleAttr); init(); }&#x2F;&#x2F;API21之后才使用&#x2F;&#x2F; 不会自动调用&#x2F;&#x2F; 一般是在第二个构造函数里主动调用&#x2F;&#x2F; 如View有style属性时publicCircleView(Context context, AttributeSet attrs,intdefStyleAttr,intdefStyleRes){super(context, attrs, defStyleAttr, defStyleRes); }&#x2F;&#x2F; 画笔初始化privatevoidinit(){&#x2F;&#x2F; 创建画笔mPaint1 &#x3D;newPaint ();&#x2F;&#x2F; 设置画笔颜色为蓝色mPaint1.setColor(Color.BLUE);&#x2F;&#x2F; 设置画笔宽度为10pxmPaint1.setStrokeWidth(5f);&#x2F;&#x2F;设置画笔模式为填充mPaint1.setStyle(Paint.Style.FILL); }&#x2F;&#x2F; 复写onDraw()进行绘制 @OverrideprotectedvoidonDraw(Canvas canvas){super.onDraw(canvas);&#x2F;&#x2F; 获取控件的高度和宽度intwidth &#x3D; getWidth();intheight &#x3D; getHeight();&#x2F;&#x2F; 设置圆的半径 &#x3D; 宽,高最小值的2分之1intr &#x3D; Math.min(width, height)&#x2F;2;&#x2F;&#x2F; 画出圆（蓝色）&#x2F;&#x2F; 圆心 &#x3D; 控件的中央,半径 &#x3D; 宽,高最小值的2分之1canvas.drawCircle(width&#x2F;2,height&#x2F;2,r,mPaint1); }} 特别注意：View的构造函数一共有4个，具体使用请看：深入理解View的构造函数和 理解View的构造函数 对于绘制内容为何在复写onDraw()里实现，具体请看我写的文章：自定义View Draw过程- 最易懂的自定义View原理系列（4） 步骤2：在布局文件中添加自定义View类的组件 activity_main.xml 步骤3：在MainActivity类设置显示 MainActivity.java publicclassMainActivityextendsAppCompatActivity{@OverrideprotectedvoidonCreate(Bundle savedInstanceState){super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); }} 效果图 好了，至此，一个基本的自定义View已经实现了。接下来继续看自定义View所有应该注意的点： 如何手动支持wrap_content属性 如何手动支持padding属性 如何为自定义View提供自定义属性（如颜色等等） a. 手动支持wrap_content属性 先来看wrap_content &amp; match_parent属性的区别 &#x2F;&#x2F; 视图的宽和高被设定成刚好适应视图内容的最小尺寸android:layout_width&#x3D;”wrap_content”&#x2F;&#x2F; 视图的宽和高延伸至充满整个父布局android:layout_width&#x3D;”match_parent”&#x2F;&#x2F; 在Android API 8之前叫作”fill_parent” 如果不手动设置支持wrap_content属性，那么wrap_content属性是不会生效（显示效果同match_parent） 具体原因 &amp; 解决方案请看我写的文章：为什么你的自定义View wrap_content不起作用？ b. 支持padding属性 padding属性：用于设置控件内容相对控件边缘的边距； 区别与margin属性（同样称为：边距）：控件边缘相对父控件的边距（父控件控制），具体区别如下： Paste_Image.png 如果不手动设置支持padding属性，那么padding属性在自定义View中是不会生效的。 解决方案绘制时考虑传入的padding属性值（四个方向）。 在自定义View类的复写onDraw（）进行设置 CircleView.java &#x2F;&#x2F; 仅看复写的onDraw（）@OverrideprotectedvoidonDraw(Canvas canvas){super.onDraw(canvas);&#x2F;&#x2F; 获取传入的padding值finalintpaddingLeft &#x3D; getPaddingLeft();finalintpaddingRight &#x3D; getPaddingRight();finalintpaddingTop &#x3D; getPaddingTop();finalintpaddingBottom &#x3D; getPaddingBottom();&#x2F;&#x2F; 获取绘制内容的高度和宽度（考虑了四个方向的padding值）intwidth &#x3D; getWidth() - paddingLeft - paddingRight ;intheight &#x3D; getHeight() - paddingTop - paddingBottom ;&#x2F;&#x2F; 设置圆的半径 &#x3D; 宽,高最小值的2分之1intr &#x3D; Math.min(width, height)&#x2F;2;&#x2F;&#x2F; 画出圆(蓝色)&#x2F;&#x2F; 圆心 &#x3D; 控件的中央,半径 &#x3D; 宽,高最小值的2分之1canvas.drawCircle(paddingLeft+width&#x2F;2,paddingTop+height&#x2F;2,r,mPaint1); } 效果图 c. 提供自定义属性 系统自带属性，如 &#x2F;&#x2F; 基本是以android开头android:layout_width&#x3D;”match_parent”android:layout_height&#x3D;”match_parent”android:background&#x3D;”#000000”android:padding&#x3D;”30dp” 但有些时候需要一些系统所没有的属性，称为自定义属性 使用步骤有如下： 在values目录下创建自定义属性的xml文件 在自定义View的构造方法中解析自定义属性的值 在布局文件中使用自定义属性 下面我将对每个步骤进行具体介绍 步骤1：在values目录下创建自定义属性的xml文件attrs_circle_view.xml 对于自定义属性类型 &amp; 格式如下： &lt;–1.reference：使用某一资源ID–&gt;&#x2F;&#x2F; 使用格式 &#x2F;&#x2F; 1. Java代码 private int ResID; private Drawable ResDraw; ResID &#x3D; typedArray.getResourceId(R.styleable.SuperEditText_background, R.drawable.background); &#x2F;&#x2F; 获得资源ID ResDraw &#x3D; getResources().getDrawable(ResID); &#x2F;&#x2F; 获得Drawble对象 &#x2F;&#x2F; 2. xml代码&lt;–2.color：颜色值–&gt;&#x2F;&#x2F; 格式使用&lt;–3.boolean：布尔值–&gt;&#x2F;&#x2F; 格式使用&lt;–4.dimension：尺寸值–&gt;&#x2F;&#x2F; 格式使用：&lt;–5.float：浮点值–&gt;&#x2F;&#x2F; 格式使用&lt;–6.integer：整型值–&gt;&#x2F;&#x2F; 格式使用&lt;–7.string：字符串–&gt;&#x2F;&#x2F; 格式使用&lt;–8.fraction：百分数–&gt;&#x2F;&#x2F; 格式使用&lt;–9.enum：枚举值–&gt;&#x2F;&#x2F; 格式使用&lt;–10.flag：位或运算–&gt;、&#x2F;&#x2F; 使用&lt;–特别注意：属性定义时可以指定多种类型值–&gt;&#x2F;&#x2F; 使用 步骤2：在自定义View的构造方法中解析自定义属性的值此处是需要解析circle_color属性的值 &#x2F;&#x2F; 该构造函数需要重写publicCircleView(Context context, AttributeSet attrs){this(context, attrs,0);&#x2F;&#x2F; 原来是：super(context,attrs);init();publicCircleView(Context context, AttributeSet attrs,intdefStyleAttr){super(context, attrs, defStyleAttr);&#x2F;&#x2F; 加载自定义属性集合CircleViewTypedArray a &#x3D; context.obtainStyledAttributes(attrs,R.styleable.CircleView);&#x2F;&#x2F; 解析集合中的属性circle_color属性&#x2F;&#x2F; 该属性的id为:R.styleable.CircleView_circle_color&#x2F;&#x2F; 将解析的属性传入到画圆的画笔颜色变量当中（本质上是自定义画圆画笔的颜色）&#x2F;&#x2F; 第二个参数是默认设置颜色（即无指定circle_color情况下使用）mColor &#x3D; a.getColor(R.styleable.CircleView_circle_color,Color.RED);&#x2F;&#x2F; 解析后释放资源a.recycle(); init(); 步骤3：在布局文件中使用自定义属性activity_main.xml xmlns:app&#x3D;”http://schemas.android.com/apk/res-auto“ xmlns:tools&#x3D;”http://schemas.android.com/tools“ android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”match_parent” tools:context&#x3D;”scut.carson_ho.diy_view.MainActivity” &gt;app:circle_color&#x3D;”#FF4081” &#x2F;&gt; Paste_Image.png 至此，一个较为规范的自定义View已经完成了。 完整代码下载 Carson_Ho的github：自定义View的具体应用 5. 总结本文对自定义View的具体应用和注意点进行了全面分析 如果希望继续了解自定义View的原理，请参考我写的文章： （1）自定义View基础 - 最易懂的自定义View原理系列 （2）自定义View Measure过程 - 最易懂的自定义View原理系列 （3）自定义View Layout过程 - 最易懂的自定义View原理系列 （4）自定义View Draw过程- 最易懂的自定义View原理系列 Android事件分发机制详解：史上最全面、最易懂 Canvas类的最全面详解 - 自定义View应用系列 Path类的最全面详解 - 自定义View应用系列 作者：Carson_Ho 链接：https://www.jianshu.com/p/e9d8420b1b9c","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Anroid-自定义字体样式/","text":"Android系统中，默认提供三种字体:”sans”, “serif”, “monospace”使用： 自定义字体样式:我们先把要使用的字体文件放入到工具中，操作如下： 新建一个名叫assets的文件夹，然后把字体文件复制到里面 设置单个TextView的字体： 或者创建一个自定义TextView控件，我们新建一个类，名叫FontCustom，写入代码： 新建一个类名叫MyTextView继承TextView，重写2个参数的构造方法 使用：复制MyTextView的路径到activity_main中，替换原有的TextView，我这里的路径是 com.example.fengjun.fontdiy.MyTextView 常用字体文件下载地址:字体量版，找字网","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/EditText不自动获取焦点/","text":"12345//解决之道：在EditText的父级控件中找一个，设置成 android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot;//这样，就把EditText默认的行为截断了！","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/GlidePalette获取图片背景色/","text":"github地址：https://github.com/florent37/GlidePalette 使用准备：compile’com.github.florent37:glidepalette:2.1.2’ compile’com.github.bumptech.glide:glide:4.6.1’ demo: 自己写的demo 提取出的颜色Palette默认会解析出图像的16种特征颜色种类，但是这六种颜色是你最经常用到的： vibrant(鲜艳色) dark vibrant(鲜艳色中的暗色) light vibrant(鲜艳色中的亮色) muted(柔和色) dark muted(柔和色中的暗色) light muted(柔和色中的亮色) 获取提取的颜色你获取Palette对象之后，可以通过以下这些内置getter函数直接获取这六个颜色。你需要传入默认颜色防止Palette无法解析到指定颜色种类，返回的类型是24位RGB颜色数值。 获取Swatch你也可以选择先获取Swatch对象，然后再通过Swatch提供的方法获取颜色的相关信息： 注意：getwatch()可能会返回一个null值，所以在使用前检查一下是必须的。if (swatch !&#x3D; null) {}swatch对象对应的颜色方法：getPopulation(): 像素的数量 getRgb(): RGB颜色 getHsl(): HSL颜色 getBodyTextColor(): 用于内容正文文本的颜色 getTitleTextColor(): 标题文本的颜色","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/android-根据三点坐标求三角形面积/","text":"12345private int getArea(int x1, int y1, int x2, int y2, int x3, int y3) &#123; int Area = 0; Area = abs((x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / 2); return Area; &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Java多线程编程安全退出线程方法/","text":"线程停止 Thread提供了一个stop()方法，但是stop()方法是一个被废弃的方法。为什么stop()方法被废弃而不被使用呢？原因是stop()方法太过于暴力，会强行把执行一半的线程终止。这样会就不会保证线程的资源正确释放，通常是没有给与线程完成资源释放工作的机会，因此会导致程序工作在不确定的状态下 那我们该使用什么来停止线程呢 Thread.interrupt(),我们可以用他来停止线程，他是安全的，可是使用他的时候并不会真的停止了线程，只是会给线程打上了一个记号，至于这个记号有什么用呢我们可以这样来用。 publicclassMythread extendsThread{ publicvoidrun(){ super.run(); for(inti &#x3D;0;i&lt;50000;i++){ if(this.interrupted()){ System.out.println(“停止”); break; } } System.out.println(“i&#x3D;”+(i+1)); } } publicclassRun{ try{ MyThread thread &#x3D; newMyThread(); thread.start(); thread.sleep(1000); thread.interrupt(); &#x2F;&#x2F;打上标记 }catch(Exception e){ System.out.println(“main”); e.printStackTrace(); } System.out.println(“end!”) } 虽然这样就会停止下来 ，可是For后面的语句还是会执行。 异常法 退出线程 publicclassMythread extendsThread{ publicvoidrun(){ super.run(); try{ for(inti &#x3D;0;i&lt;50000;i++){ if(this.interrupted()){ System.out.println(“停止”); thrownewException(); } } System.out.println(“i&#x3D;”+(i+1)); }catch(Exception e){ System.out.println(“抛出异常了”); e.printStackTrace(); } } } 解释 如果当我们打上了一个标记我们就可以检测到已经打上的时候就返回个true，进入if里面返回了一个异常 这样就终止了。这样做使的线程可以在我们可控的范围里停止 用什么方法去看什么状态呢 this.interrupted():看看当前线程是否是中断状态，执行后讲状态表示改为false this.isInterrupeted():看看线程对象是否已经是中断状态，但是不清除中断状态标记。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/Handler/","text":"Handler是什么：Handler是Android提供给我们的用来更新UI的一套机制，也是一套消息处理机制，我们可以通过它发送消息，也可以通过它处理消息！ Handler的用法： post(Runable)： handler.postDelayed(Runnable,long)这是一种可以创建多线程消息的函数 使用方法： 1，首先创建一个Handler对象 Handler handler&#x3D;new Handler(); 2，然后创建一个Runnable对象 Runnable runnable&#x3D;new Runnable(){ @Override public void run() { &#x2F;&#x2F; TODO Auto-generated method stub &#x2F;&#x2F;要做的事情，这里再次调用此Runnable对象，以实现每两秒实现一次的定时器操作 handler.postDelayed(this, 2000); } }; 3，使用PostDelayed方法，两秒后调用此Runnable对象 handler.postDelayed(runnable, 2000); 实际上也就实现了一个2s的一个定时器 4，如果想要关闭此定时器，可以这样操作 handler.removeCallbacks(runnable); 当然，你也可以做一个闹钟提醒延时的函数试试，比如，先用MediaPlayer播放闹钟声音， 如果不想起，被停止播放之后，下次就5分钟后再播放，再被停止的话，下次就4分钟后播放， 只要更改延时的时间就可以实现了，用一个static对象的话会比较容易操作。 是可以异步效果，但Runnable的执行是在Handler对象所在的线程 如果其所在的线程是UI线程的话，Runnable中还是不能执行耗时操作，不然会ANR 前几天我们自己的设备很卡，卡到跳转界面都需要不到1秒的时间，我就把跳转的动作放在Runnable里边，外边加上弹出进度提示框 注：举例说明 传递Message:sendMessage(RunnAble)；sendMessagePostDeayed(RunnAble,lone)； Handler.Callback()拦截消息回调： Android为什么要设计只能通过Handlerde 方式跟新UI： Handler的原理： HandlerThread:HandlerThread能够新建拥有Looper的线程。这个Looper能够用来新建其他的Handler。（线程中的Looper）需要注意的是，新建的时候需要被回调。 HandlerThread的特点：HandlerThread将loop转到子线程中处理，说白了就是将分担MainLooper的工作量，降低了主线程的压力，使主界面更流畅。 开启一个线程起到多个线程的作用。处理任务是串行执行，按消息发送顺序进行处理。HandlerThread本质是一个线程，在线程内部，代码是串行处理的。 但是由于每一个任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。 HandlerThread拥有自己的消息队列，它不会干扰或阻塞UI线程。 对于网络IO操作，HandlerThread并不适合，因为它只有一个线程，还得排队一个一个等着。 Handler的用法：public class MainActivityextends Activity { private HandlerThreadmyHandlerThread ; private Handlerhandler ; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ​ setContentView(R.layout.activity_main); ​ &#x2F;&#x2F;创建一个线程,线程名字：handler-thread ​ myHandlerThread &#x3D;new HandlerThread(“handler-thread”); ​ &#x2F;&#x2F;开启一个线程 ​ myHandlerThread.start(); ​ &#x2F;&#x2F;在这个线程中创建一个handler对象 ​ handler &#x3D;new Handler(myHandlerThread.getLooper() ){ @Override ​ public void handleMessage(Message msg) { super.handleMessage(msg); ​ &#x2F;&#x2F;这个方法是运行在 handler-thread 线程中的 ，可以执行耗时操作 ​ Log.d(“handler “ , “消息： “ + msg.what +” 线程： “ + Thread.currentThread().getName() ); ​ } }; ​ &#x2F;&#x2F;在主线程给handler发送消息 ​ handler.sendEmptyMessage(1 ); ​ new Thread(new Runnable() { @Override ​ public void run() { &#x2F;&#x2F;在子线程给handler发送数据 ​ handler.sendEmptyMessage(2 ); ​ } }).start(); } @Override protected void onDestroy() { super.onDestroy(); ​ &#x2F;&#x2F;释放资源 ​ myHandlerThread.quit(); } } handler引起的内存泄漏以及解决办法原因：静态内部类持有外部类的匿名引用，导致外部activity无法释放 解决办法：handler内部持有外部activity得到弱引用，并把handler改为静态内部类，mHandler.removeCallback()；","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/android-textview动态修改指定文字颜色/","text":"#####动态修改指定文字颜色 12345String text = &quot;获得银宝箱!&quot;; SpannableStringBuilder style=new SpannableStringBuilder(text); style.setSpan(new BackgroundColorSpan(Color.RED),2,5,Spannable.SPAN_EXCLUSIVE_INCLUSIVE); //设置指定位置textview的背景颜色 style.setSpan(new ForegroundColorSpan(Color.RED),0,2,Spannable.SPAN_EXCLUSIVE_INCLUSIVE); //设置指定位置文字的颜色 textView.setText(style); #####动态修改指定文字颜色 并添加下划线 1234567891011121314151617SpannableString clickString = new SpannableString(exChangeValue);//exChangeValue TextViwe的内容 clickString.setSpan(new ClickableSpan() &#123; @Override public void onClick(View widget) &#123; Intent intent = new Intent(ExchangeActivity.this, WebActivity.class); intent.putExtra(WebActivity.WEB_URL_PARA, flow.getAgreement().getUrl()); startActivity(intent); &#125; @Override public void updateDrawState(TextPaint ds) &#123; super.updateDrawState(ds); ds.setColor(Color.parseColor(&quot;#FF7012&quot;));//设置颜色 &#125; &#125;, i, i1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);//i变色的开始位置 i1变色的结束位置 tv_exchange_rule_value.append(clickString); tv_exchange_rule_value.setMovementMethod(LinkMovementMethod.getInstance());//开始响应点击事件","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/android-英文单词升序排序（Collections-sort()）/","text":"######如果只是单纯的字符串比较把SignBean类对象换成String对象道理都是一样的； 123456789101112131415161718192021222324252627282930313233343536373839404142//定义数据源 List&lt;SignBean&gt; list = new ArrayList&lt;&gt;(); SignBean signBean = new SignBean(); signBean.setName(&quot;abc&quot;); signBean.setValue(&quot;1&quot;); list.add(signBean); SignBean signBean1 = new SignBean(); signBean1.setName(&quot;abb&quot;); signBean1.setValue(&quot;2&quot;); list.add(signBean1); SignBean signBean2 = new SignBean(); signBean2.setName(&quot;cb&quot;); signBean2.setValue(&quot;3&quot;); list.add(signBean2);//排序 Collections.sort(list, new Comparator&lt;SignBean&gt;() &#123; @Override public int compare(SignBean o1, SignBean o2) &#123;//拿到2个bean类中的name字符串进行比较，android中字符串比较是比较的ASCLL码//compareTo（） 字符串比较 int i = o1.getName().compareTo(o2.getName()); if (i &gt; 0) &#123; return 1; &#125; else &#123; return -1; &#125; &#125; &#125;);for (int i = 0; i &lt;list.size() ; i++) &#123; Log.e(&quot;tyl&quot;,&quot;name=&quot;+list.get(i).getName()); Log.e(&quot;tyl&quot;,&quot;value=&quot;+list.get(i).getValue()); &#125;//排序完成 打印数据结果： name=abb value=2 name=abc value=1 name=cb value=3 #####SignBean 类代码： 1234567891011121314151617public class SignBean &#123; private String name; private String value; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/android-MultiDex分包/","text":"#####相信你肯定在项目中遇到过下面的问题👇 Conversion to Dalvik format failed:Unable to execute dex: methodID not in [0, 0xffff]: 65536或者这样👇 trouble writing output:Too many field references: 131000; max is65536.You may try using –multi-dex option.这两种问题出现的原因都是因为你的项目中的方法数超过65536。前者出现在低版本的手机中，后者出现在较高的版本之中。这里的版本以5.0来区分。 #####如何解决如果你的minSdkVersion设置成21及更高，你只需要在build.gradle设置multiDexEnabled为true就可以了： 123456789android &#123;defaultConfig &#123;...minSdkVersion 21targetSdkVersion 25multiDexEnabled true &#125;...&#125; 如果你的minSdkVersion设置成20及以下，除了上述步骤外你还需要添加依赖库并进行相关配置： 123456789101112android &#123;defaultConfig &#123;...minSdkVersion 15targetSdkVersion 25multiDexEnabled true &#125;...&#125;dependencies &#123;compile &#x27;com.android.support:multidex:1.0.1&#x27;&#125; 在MyApplication中加入下面的代码进行配置： 1234@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this);&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/android中更新UI的几种方式/","text":"1、Activity的 runOnUiThreadtextView &#x3D; (TextView) findViewById( R.id.tv ); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ runOnUiThread(new Runnable() { ​ @Override ​ public void run() { ​ textView.setText( “更新UI了”); ​ } ​ }); ​ } ​ }).start(); android Activity runOnUiThread() 方法使用 2、Handler sendEmptyMessage()package lib.com.myapplication; import android.os.Handler; import android.os.Message; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private TextView textView ; Handler handler &#x3D; new Handler( ) { ​ @Override ​ public void handleMessage(Message msg) { ​ super.handleMessage(msg); ​ textView.setText( “Ui更新了”); ​ } }; @Override protected void onCreate(Bundle savedInstanceState) { ​ super.onCreate(savedInstanceState); ​ setContentView(R.layout.activity_main); ​ textView &#x3D; (TextView) findViewById( R.id.tv ); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ try { ​ Thread.sleep( 2000 ); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ handler.sendEmptyMessage( 2 ) ; ​ } ​ }).start(); } } 3、Handler post()package lib.com.myapplication; import android.os.Bundle; import android.os.Handler; import android.support.v7.app.AppCompatActivity; import android.widget.TextView; public class MainActivity extends AppCompatActivity { private TextView textView ; Handler handler &#x3D; new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { ​ super.onCreate(savedInstanceState); ​ setContentView(R.layout.activity_main); ​ textView &#x3D; (TextView) findViewById( R.id.tv ); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ try { ​ Thread.sleep( 2000 ); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ handler.post(new Runnable() { ​ @Override ​ public void run() { ​ textView.setText( “Ui更新了”); ​ } ​ }) ; ​ } ​ }).start(); } } 在子线程中切换到主线程 new Thread(new Runnable() { @Override public void run() { ​ LogUtil.d( “ttt 11111111111” + Thread.currentThread().getName() ); ​ new Handler(Looper.getMainLooper()).post(new Runnable() { ​ @Override ​ public void run() { ​ LogUtil.d( “ttt 55555555” + Thread.currentThread().getName() ); ​ } ​ }); ​ LogUtil.d( “ttt 22222222222” + Thread.currentThread().getName() ); ​ LogUtil.d( “ttt 33333333333” + Thread.currentThread().getName() ); ​ LogUtil.d( “ttt 44444444444” + Thread.currentThread().getName() ); } }).start(); 结果 ttt 11111111111Thread-155 ttt 22222222222Thread-155 ttt 33333333333Thread-155 ttt 44444444444Thread-155 ttt 55555555main 可见这种方式可以快速切换线程，从log日志来看，切换到主线程不会阻塞子线程。 4、view Post()textView &#x3D; (TextView) findViewById( R.id.tv ); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ try { ​ Thread.sleep( 2000 ); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ textView.post(new Runnable() { ​ @Override ​ public void run() { ​ textView.setText( “Ui更新了”); ​ } ​ }) ; ​ } ​ }).start(); 总结： 1、其实上面的四种方式都可归结于一种方式：handler 用于Android线程之间的通信。 2、为什么android要求只能在UI线程进行UI操作？ 主要还是为了避免多线程造成的并发的问题。在单线程操作UI是安全的。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/viewpager自定义滑动速度/","text":"android原生的viewpager默认不支持自定义滑动速度,直接复制FixedSpeedScroller 类使用即可：#####使用： 12345678910111213141516 controlViewPagerSpeed(this,splash_viewpager,400);//毫秒 速度// 自定义viewpager滑动速度 private void controlViewPagerSpeed(Context context, ViewPager viewpager, int DurationSwitch) &#123; try &#123; Field mField; mField = ViewPager.class.getDeclaredField(&quot;mScroller&quot;); mField.setAccessible(true); FixedSpeedScroller mScroller = new FixedSpeedScroller(context, new AccelerateInterpolator()); mScroller.setmDuration(DurationSwitch); mField.set(viewpager, mScroller); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import android.content.Context;import android.view.animation.Interpolator;import android.widget.Scroller;/** * Created by tyl * 2018/9/30/030 * Describe: */public class FixedSpeedScroller extends Scroller &#123; private int mDuration = 1500; // 默认滑动速度 1500ms public FixedSpeedScroller(Context context) &#123; super(context); &#125; public FixedSpeedScroller(Context context, Interpolator interpolator) &#123; super(context, interpolator); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; // Ignore received duration, use fixed one instead super.startScroll(startX, startY, dx, dy, mDuration); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy) &#123; // Ignore received duration, use fixed one instead super.startScroll(startX, startY, dx, dy, mDuration); &#125; /** * set animation time * * @param time */ public void setmDuration(int time) &#123; mDuration = time; &#125; /** * get current animation time * * @return */ public int getmDuration() &#123; return mDuration; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/数据序列化方案/","text":"一、引言 数据的序列化在Android开发中占据着重要的地位，无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。 从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。 这样来说，数据序列化相当于是将我们原先的对象序列化概念做出了扩展，在对象序列化和反序列化中，我们熟知的有两种方法，其一是Java语言中提供的Serializable接口，其二是Android提供的Parcelable接口。而在这里，因为我们对这个概念做出了扩展，因此也需要考虑几种专门针对数据结构进行序列化的方法，如现在那些个开放API一般返回的数据都是JSON格式的，又或者是我们Android原生的SQLite数据库来实现数据的本地存储，从广义上来说，这些都可以算做是数据的序列化。 二、Serializable接口 正如前面提到的，Serializable接口是Java语言的特性，是最简单也是使用最广泛的序列化方案之一，这边需要注意的一点是Serializable接口是一个标识接口，无需实现方法，Java便会对这个对象进行序列化操作。 在这里实现了Serializable接口的对象才可以序列化，将Java对象转换成字节序列，而对应的反序列化则是将字节序列恢复成Java对象的过程。 在需要序列化的类中会用到serialVersionUID去标识这个序列化对象，即仅当序列化后的数据中的SerialVersionUID与当前类的serialVersionUID相同时才能被正常的反序列化。import java.io.*;public class User implements Serializable{ private static final long serialVersionUID&#x3D; 123456; public int userId; public String userName; public boolean isMale; public User(int userId,String userName,boolean isMale){ this.userId&#x3D;userId; this.userName&#x3D;userName; this.isMale &#x3D; isMale; } public boolean toSerial(User user) throws IOException{ ObjectOutputStream out&#x3D;null; boolean status&#x3D;false; try{ out &#x3D; new ObjectOutputStream(new FileOutputStream(“cache.txt”)); out.writeObject(user); status&#x3D;true; }catch(FileNotFoundException e){ System.out.println(“NO FILE”); }finally{ if(out!&#x3D;null) out.close(); } return status; } public User toObject(String filename) throws IOException{ ObjectInputStream in&#x3D;null; boolean status&#x3D;false; User user&#x3D;null; try{ in &#x3D; new ObjectInputStream(new FileInputStream(filename)); user&#x3D;(User) in.readObject(); }catch(ClassNotFoundException e){ System.out.println(“No file”); }finally{ if(in!&#x3D;null) in.close(); } return user; } public static void main(String[] args) throws IOException{ User user &#x3D; new User(0,”jake”,true); System.out.println(user.toSerial(user)); System.out.println(user.toObject(“cache.txt”).getClass()); }}此外，需要注意的：静态成员变量是属于类而不属于对象的，所以显然它不会参与到对象的序列化过程中。其次用transient关键字标记的成员变量不参与到序列化过程中。最后，这种序列化方式是基于磁盘或者网络的。 三、Parcelable接口 Parcelable接口是Android API提供的接口，从某种程度上来说，它更适用于Android平台上。不同于Serializable，它是基于内存的，由于内存中读写速度高于磁盘，所以Parcelable接口被广泛用于跨进程对象的传递。 下面贴上一个简单的Parcelable接口的序列化过程： import android.os.Parcel;import android.os.Parcelable;public class User implements Parcelable { public int userId; public String userName; public boolean isMale; public User(int userId,String userName,boolean isMale) { this.userId&#x3D;userId; this.userName&#x3D;userName; this.isMale&#x3D;isMale; } public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; public User(Parcel in) &#123; userId=in.readInt(); userName = in.readString(); isMale=in.readInt()==1; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(userId); out.writeString(userName); out.writeInt(isMale?1:0); &#125; }从上面可以看出，实现一个Parcelable接口，需要实现以下几个方法： 1.构造函数：从序列化后的对象中创建原始对象 2.describeContents :接口内容的描述，一般默认返回0即可 3.writeToParcel:序列化的方法，将类的数据写到parcel容器中 4.静态的parcelable.Creator接口，这个接口包含两个方法 1）createFormParcel：反序列化的方法，将Parcel还原成Java对象 2）newArray：提供给外部类反序列化这个数组使用。 四、两种对象序列化方法的对比 Serializable是Java中的序列化接口，其使用起来简单但开销较大（因为Serializable在序列化过程中使用了反射机制，故而会产生大量的临时变量，从而导致频繁的GC），并且在读写数据过程中，它是通过IO流的形式将数据写入到硬盘或者传输到网络上。 而Parcelable则是以IBinder作为信息载体，在内存上开销比较小，因此在内存之间进行数据传递时，推荐使用Parcelable,而Parcelable对数据进行持久化或者网络传输时操作复杂，一般这个时候推荐使用Serializable。 另外Serializable在使用时比较简单，而Parcelable在使用时需要手动去实现接口中的方法，为了规避使用Parcelable接口时的麻烦，我们下面介绍一个插件，从而自动生成对应的代码。 五、Parcelable插件 为了避免写大量的模板代码，这边介绍一个在Android Strudio中的插件，Android Parcelable code generator。在Pulgins中下载并按照该插件，接下来当我们需要用到Parcelable接口时，该插件就能自动帮我们将类对象转换成实现Parcelable接口的形式。 具体示例如下， &#x2F;** Created by DB on 2017&#x2F;6&#x2F;24. *&#x2F; public class BookItem { public String mName; public long mLastTime; public String mTitle; public String mPath;}然后类似与生成getter和setter代码那样，我们就可以直接自动生成Parcelable形式的代码，结果如下所示： import android.os.Parcel;import android.os.Parcelable; &#x2F;** Created by DB on 2017&#x2F;6&#x2F;24. *&#x2F; public class BookItem implements Parcelable { public String mName; public long mLastTime; public String mTitle; public String mPath; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.mName); dest.writeLong(this.mLastTime); dest.writeString(this.mTitle); dest.writeString(this.mPath); &#125; public BookItem() &#123; &#125; protected BookItem(Parcel in) &#123; this.mName = in.readString(); this.mLastTime = in.readLong(); this.mTitle = in.readString(); this.mPath = in.readString(); &#125; public static final Parcelable.Creator&lt;BookItem&gt; CREATOR = new Parcelable.Creator&lt;BookItem&gt;() &#123; @Override public BookItem createFromParcel(Parcel source) &#123; return new BookItem(source); &#125; @Override public BookItem[] newArray(int size) &#123; return new BookItem[size]; &#125; &#125;; }有了这个插件，使用Parcelable接口显然方便了许多（可以偷好多懒） 六、数据的序列化方案 下面讲到的是广义上的序列化方案，不同于前面两种狭义或者说是对象序列化方案，接下来的几种方案针对于数据的传输和存储过程中的序列化方案 1.SQLite SQLite主要用于存储复杂的关系型数据，Android支持原生支持SQLite数据库相关操作（SQLiteOpenHelper）,不过由于原生API接口并不友好，所以产生了不少封装了SQLite的ORM框架。 2.SharedPreferences SharedPreferences是Android平台上提供的一个轻量级存储API，一般用于存储常用的配置信息，其本质是一个键值对存储，支持常用的数据类型如boolean、float、int、long以及String的存储和读取。 使用SharedPreferences读取和存储操作如下： 读取： 1） 获取Sharedpreferences对象 SharedPreferences mPreferences &#x3D; context.getCSharedPreferences（PREFERENCES_NAME，Context.MODE_PRIVATE)； 2.通过SharedPReferences对象读取存储在SharedPreferences中的数据 mPreferences.getBoolean(key,defValue); 存储： 1）获取SharedPreferences.Editor对象 SharedPreferences.Editor editor &#x3D; mPreferences.edit(); 2)通过SharedPreferences.Editor对象写入数据到SharedPreferences中。 mEditor.putBoolean(key,b); 3)调用commit函数将写入的数据提交，从而完成数据存储操作。 mEditor.commit(); 3.JSON JSON是一种轻量级的数据交互格式，由于其相对于XML，体积更小，在网络上传输时更加介绍浏览，被广泛用于移动端。大部分APP与服务端的通信都是使用JSON格式进行交互。 转自：http://blog.csdn.net/wangchunlei123/article/details/51345130","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/程序员必知的6点编程秘诀/","text":"程序员必知的6点编程秘诀，编程三板斧将解决90%问题！新手程序员刚入门编程，要经常加班。有些还经常被bug虐杀。 作为一名新手程序员，在编程职业初期应当建立起正确的编程观念。 打开网易新闻 查看更多精彩图片 下面w3cschool就给程序员小伙伴们分享6点编程秘诀： 0、造轮子? 有些新手程序员万般嫌弃别人的轮子不够圆，以现成的类库坑多为由不用，一定要自己造个轮子。 结果，发现等于是给自己挖了个坑，再跳进去。 1、看官方文档 大多数编程老手会告诉你编程的一条真理：看官方文档是最快的学习方式。 你对于一些问题认识不够清晰吗?那你就去看官方文档，看完之后，你会发现一切都豁然开朗了。 2、不靠谱需求最后做 把觉得不靠谱的需求放到最后做。为什么呢? 因为很可能到时候需求就变了。不急的需求不要急着做，可能之后需求就没有了。——引用编程大神的一句话。 3、工作日志能提升脑容量 程序员一般都会写工作日志，不过这是因项目的需要。 做为一名新手程序员，如果你养成记录技术博客的习惯，它将提升你的脑容量。 在自我总结的同时，让自己受益，同时别人可能会遇到同样的问题，也会受益颇多。 4、解决问题三板斧 你碰到问题苦思冥想，却毫无办法。 不妨使用编程问题解决的三板斧：Google + StackOverflow + Github，它可以解决日常开发中90%的问题。 5、制定计划 程序员的工作比较琐碎，一定要给自己定个学习计划，这个季度要学什么，下个季度要学什么，这一点非常重要。 时间是学习的成果的衡量标尺。就拿每次的跳槽为例，一些平时有定学习计划的程序员，总能找到薪水更高的工作。 而没有学习计划的程序员，换来换去工作都差不多。如果你能把目光放到一年之后，甚至5年之后，你就会有更多的时间去准备，成为一个更厉害的程序员! 转自：网易新闻","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/Android日常记录/系统日历-插入重复事件规则-(android-java)/","text":"####Recurrence Rule重复规则 rrule（Recurrence Rule） 属于 icalendar 属性中的一个，配合 dtstart 可以完整描述一个事件的重复行为并计算出重复事件的具体发生 （Occurence）。 重复规则包含多个属性， 每个属性以 NAME &#x3D; VALUE 对的形式存在， 属性与属性之间用分号区分， 属性之间没有特定的顺序要求，在同一个重复规则中每个属性最多只能出现一次。 ####FREQFREQ 属性表示重复规则的类型, 是重复规则中必须定义的一条属性。 可选的 VALUE 有： SECONDLY， 表示以秒为间隔单位进行重复。MINUTELY， 表示以分钟为间隔单位进行重复。HOURLY， 表示以小时为间隔单位进行重复。DAILY， 表示以天为间隔单位进行重复。WEEKLY， 表示以周为间隔单位进行重复。MONTHLY， 表示以月为间隔单位进行重复。YEARLY， 表示以年为间隔单位进行重复。####INTERVALINTERVAL 属性表示重复规则的间隔， 必须为正整数。 默认值为1， 对应上述不同的 FREQ 值分别表示每一秒，每一分钟， 每一小时， 每一天， 每一周， 每一月， 每一年。####UNTILUNTIL 属性定义了一个日期-时间值，用以限制重复规则。 这个日期-时间值表示这个重复规则的最后一次事件的发生时间。 如果重复规则中未包含 UNTIL 和 COUNT 属性， 则表示该重复规则无限重复。####COUNTCOUNT 属性通过定义重复事件的发生次数来限制重复规则。 正整数。####BYSECOND, BYMINUTE, BYHOURBYSECOND 取值范围 0 - 59， 可以理解为 “…… 的 n 秒”。BYMINUTE 取值范围 0 - 59， 可以理解为 “…… 的 n 分”。BYHOUR 取值范围 0 - 23， 可以理解为 “…… 的 n 时”。####BYDAYBYDAY 取值范围： MO（周一）， TU（周二）， WE（周三）， TU（周四）， FR（周五）， SA（周六）， SU（周日）。可以有多个值，用逗号分隔。 每个值可以在前面加上一个正整数（+n）或者负整数（-n），用以在 MONTHLY 或者 YEARLY 的重复类型中表示第 n 个周几。 例如，在一个 MONTHLY 类型的重复规则中， +1MO（或者1MO）表示这个月的第1个周一，如果是 -1MO 则表示这个月的最后1个周一。 如果前面没有数字，则表示在这个重复类型中的所有的周几， 比如在一个 MONTHLY 的重复类型中， MO 表示这个月里所有的周一。####BYMONTHDAYBYMONTHDAY 取值范围 1 - 31 或者 -31 - -1，表示一个月的第几天。 比如， -10 表示一个月的倒数第10天。可以有多个值，用逗号分隔。####BYYEARDAYBYYEARDAY 取值范围 1 - 366 或者 -366 - -1， 表示一年的第几天。 比如， -1 表示一年的最后一天， 306 表示一年的第306天。可以有多个值，用逗号分隔。####BYWEEKNOBYWEEKNO 取值范围 1 - 53 或者 -53 - -1， 表示一年的第几周， 只在 YEARLY 类型的重复规则中有效。 比如， 3 表示一年的第 3 周。可以有多个值，用逗号分隔。（注：一年的第一周是指第一个至少包含该年4天时间的那一周）####BYMONTYBYMONTH 取值范围 1 - 12， 表示一年的第几个月。可以有多个值，用逗号分隔。####WKSTWKST 取值范围 MO, TU, WE, TH, FR, SA, SU。 默认值为 MO。 当一个 WEEKLY 类型的重复规则， INTERVAL 大于 1， 且带有 BYDAY 属性时， 则必须带有 WKST 属性。 当一个 YEARLY 类型的重复规则带有 BYWEEKNO 属性时， 也必须带有 WKST 属性。####BYSETPOSBYSETPOS 取值范围 1 - 366 或者 -366 - -1， 表示规则指定的事件集合中的第n个事件， 必须与另外的 BYxxx 属性共同使用。 比如，每月的最后一组工作日可以表示为： RRULE:FREQ&#x3D;MONTHLY;BYDAY&#x3D;MO,TU,WE,TH,FR;BYSETPOS&#x3D;-1 如果一个 BYxxx 属性的值超过了它对应的范围，则该属性会被忽略。 当有多个 BYxxx 属性存在的时候， 在代入了 FREQ 和 INTEVAL 属性后，按照以下顺序代入到已有规则上：BYMONTH, BYWEEKNO, BYYEARDAY, BYMONTHDAY, BYDAY, BYHOUR, BYMINUTE, BYSECOND，BYSETPOS 例如： RRULE:FREQ&#x3D;YEARLY;INTERVAL&#x3D;2;BYMONTH&#x3D;1;BYDAY&#x3D;SU;BYHOUR&#x3D;8,9; BYMINUTE&#x3D;30 首先，将 INTERVAL&#x3D;2 代入到 FREQ&#x3D;YEARLY 上，得到“每2年”， 然后在这基础上代入 BYMONTH&#x3D;1 得到“每2年的1月”， 再代入 BYDAY&#x3D;SU， 得到“每2年的1月的所有周日”， 再代入 BYHOUR&#x3D;8,9， 得到“每2年的1月的所有周日的8点和9点”（注意是8点和9点，不是8点到9点）， 最后代入 BYMINUTE&#x3D;30， 得到“每2年的1月的所有周日的8点30分和9点30分”。规则中未注明的时间信息，以开始时间（dtstart）为准。####Examples每天发生一次，重复10次：RRULE:FREQ&#x3D;DAILY;COUNT&#x3D;10 每天发生一次，直到1997年12月24日：RRULE:FREQ&#x3D;DAILY;UNTIL&#x3D;19971224T000000Z 每2天发生一次，直到永远：RRULE:FREQ&#x3D;DAILY;INTERVAL&#x3D;2 每10天发生一次，重复5次：RRULE:FREQ&#x3D;DAILY;INTERVAL&#x3D;10;COUNT&#x3D;5 当前日期为1998年1月1日9点0分0秒，之后的3年里每年的1月每天发生一次：RRULE:FREQ&#x3D;YEARLY;UNTIL&#x3D;20000131T090000Z;BYMONTH&#x3D;1;BYDAY&#x3D;SU,MO,TU,WE,TH,FR,SA或者：RRULE:FREQ&#x3D;DAILY;UNTIL&#x3D;20000131T090000Z;BYMONTH&#x3D;1 每周一次，共发生10次：RRULE:FREQ&#x3D;WEEKLY;COUNT&#x3D;10 每周一次，直到1997年12月24日：RRULE:FREQ&#x3D;WEEKLY;UNTIL&#x3D;19971224T000000Z 每2周一次， 直到永远：RRULE:FREQ&#x3D;WEEKLY;INTERVAL&#x3D;2;WKST&#x3D;SU 当前时间为1997年9月2日9点0分0秒，每周二和周四各发生一次，持续5周：RRULE:FREQ&#x3D;WEEKLY;UNTIL&#x3D;19971007T000000Z;WKST&#x3D;SU;BYDAY&#x3D;TU,TH或者：RRULE:FREQ&#x3D;WEEKLY;COUNT&#x3D;10;WKST&#x3D;SU;BYDAY&#x3D;TU,TH 每周一， 周三， 周五各一次，直到1997年12月24日：RRULE:FREQ&#x3D;WEEKLY;INTERVAL&#x3D;2;UNTIL&#x3D;19971224T000000Z;WKST&#x3D;SU;BYDAY&#x3D;MO,WE,FR 每2周的周二和周四各发生一次，共发生8次： RRULE:FREQ&#x3D;WEEKLY;INTERVAL&#x3D;2;COUNT&#x3D;8;WKST&#x3D;SU;BYDAY&#x3D;TU,TH 每月的第一个周五发生一次，共发生10次：RRULE:FREQ&#x3D;MONTHLY;COUNT&#x3D;10;BYDAY&#x3D;1FR 每月的第一个周五发生一次，直到1997年12月24日：RRULE:FREQ&#x3D;MONTHLY;UNTIL&#x3D;19971224T000000Z;BYDAY&#x3D;1FR 每2个月的第一个周日和最后一个周日个发生一次，共发生10次： RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;2;COUNT&#x3D;10;BYDAY&#x3D;1SU,-1SU 每月的倒数第二个周一发生一次，共发生6次：RRULE:FREQ&#x3D;MONTHLY;COUNT&#x3D;6;BYDAY&#x3D;-2MO 每月的倒数第三天发生一次，直到永远：RRULE:FREQ&#x3D;MONTHLY;BYMONTHDAY&#x3D;-3 每月的第2天和第15天各发生一次，共发生10次：RRULE:FREQ&#x3D;MONTHLY;COUNT&#x3D;10;BYMONTHDAY&#x3D;2,15 每月的第1天和最后1天各发生一次，共发生10次：RRULE:FREQ&#x3D;MONTHLY;COUNT&#x3D;10;BYMONTHDAY&#x3D;1,-1 每个18个月的1号至15号每天发生一次，共发生10次：RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;18;COUNT&#x3D;10;BYMONTHDAY&#x3D;10,11,12,13,14,15 每2个月的所有周二每天发生一次：RRULE:FREQ&#x3D;MONTHLY;INTERVAL&#x3D;2;BYDAY&#x3D;TU 每年6月和7月各发生一次，共发生10次：RRULE:FREQ&#x3D;YEARLY;COUNT&#x3D;10;BYMONTH&#x3D;6,7 每2年的一月，二月，三月各发生一次，共10次：RRULE:FREQ&#x3D;YEARLY;INTERVAL&#x3D;2;COUNT&#x3D;10;BYMONTH&#x3D;1,2,3 每3年的第一天，第100天和第200天各发生一次，共10次：RRULE:FREQ&#x3D;YEARLY;INTERVAL&#x3D;3;COUNT&#x3D;10;BYYEARDAY&#x3D;1,100,200 每年的第20个周一发生一次，直到永远：RRULE:FREQ&#x3D;YEARLY;BYDAY&#x3D;20MO 每年的第20周的周一（以周一为一周起始日）发生一次，直到永远：RRULE:FREQ&#x3D;YEARLY;BYWEEKNO&#x3D;20;BYDAY&#x3D;MO 每年3月的所有周四，直到永远：RRULE:FREQ&#x3D;YEARLY;BYMONTH&#x3D;3;BYDAY&#x3D;TH 每年6月，7月，8月的所有周四，直到永远：RRULE:FREQ&#x3D;YEARLY;BYDAY&#x3D;TH;BYMONTH&#x3D;6,7,8 每一个黑色星期五（13号那天为周五）发生一次，直到永远:RRULE:FREQ&#x3D;MONTHLY;BYDAY&#x3D;FR;BYMONTHDAY&#x3D;13 每月第一个周日之后那一周的周六发生一次，直到永远：RRULE:FREQ&#x3D;MONTHLY;BYDAY&#x3D;SA;BYMONTHDAY&#x3D;7,8,9,10,11,12,13 每4年的11月的第一个周一之后的那个周二发生一次，直到永远RRULE:FREQ&#x3D;YEARLY;INTERVAL&#x3D;4;BYMONTH&#x3D;11;BYDAY&#x3D;TU;BYMONTHDAY&#x3D;2,3,4,5,6,7,8 The 3rd instance into the month of one of Tuesday, Wednesday or Thursday, for the next 3 months（没法翻译，自己理解）:RRULE:FREQ&#x3D;MONTHLY;COUNT&#x3D;3;BYDAY&#x3D;TU,WE,TH;BYSETPOS&#x3D;3 每月的倒数第2个工作日，直到永远：RRULE:FREQ&#x3D;MONTHLY;BYDAY&#x3D;MO,TU,WE,TH,FR;BYSETPOS&#x3D;-2","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]},{"path":"wiki/Android Application/android-加密-解密-数据压缩/10进制转20进制（任意进制-自定义字符）/","text":"123456789101112131415161718192021222324252627 /** * 10进制转20进制 * data 传入的10进制 * */ private static String to20Jinzhi(int data) &#123; String str = &quot;abcdefgh234lmntuwxyz&quot;;//自定义字符 多少字符为多少进制 int scale = str.length(); //转化目标进制 String s = &quot;&quot;; if (data == 0) &#123; return str.charAt(0) + &quot;&quot;; &#125; while (data &gt; 0) &#123; if (data &lt; scale) &#123; s = str.charAt(data) + s; data = 0; &#125; else &#123; int r = data % scale; s = str.charAt(r) + s; data = (data - r) / scale; &#125; &#125;// 字符不足3位前面补—线 自己定义// if (s.length() &lt; 3) &#123;// s = &quot;_&quot; + s;// &#125; return s; &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-加密-解密-数据压缩","slug":"Android-Application/android-加密-解密-数据压缩","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"}]},{"path":"wiki/Android Application/android-加密-解密-数据压缩/压缩算法进行字符串压缩/","text":"####1.使用Deflater压缩json，Inflater解压jsonDeflater 是同时使用了LZ77算法与哈夫曼编码的一个无损数据压缩算法。我们可以使用 java 提供的 Deflater 和 Inflater 类对 json 进行压缩和解压缩，下面是工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.guoshikeji.driver95128.utils;import android.support.annotation.Nullable;import android.util.Base64;import java.io.ByteArrayOutputStream;import java.util.zip.DataFormatException;import java.util.zip.Deflater;import java.util.zip.Inflater;/** * DeflaterUtils 压缩字符串 */public class DeflaterUtils &#123; /** * 压缩 */ public static String zipString(String unzipString) &#123; /** * https://www.yiibai.com/javazip/javazip_deflater.html#article-start * 0 ~ 9 压缩等级 低到高 * public static final int BEST_COMPRESSION = 9; 最佳压缩的压缩级别。 * public static final int BEST_SPEED = 1; 压缩级别最快的压缩。 * public static final int DEFAULT_COMPRESSION = -1; 默认压缩级别。 * public static final int DEFAULT_STRATEGY = 0; 默认压缩策略。 * public static final int DEFLATED = 8; 压缩算法的压缩方法(目前唯一支持的压缩方法)。 * public static final int FILTERED = 1; 压缩策略最适用于大部分数值较小且数据分布随机分布的数据。 * public static final int FULL_FLUSH = 3; 压缩刷新模式，用于清除所有待处理的输出并重置拆卸器。 * public static final int HUFFMAN_ONLY = 2; 仅用于霍夫曼编码的压缩策略。 * public static final int NO_COMPRESSION = 0; 不压缩的压缩级别。 * public static final int NO_FLUSH = 0; 用于实现最佳压缩结果的压缩刷新模式。 * public static final int SYNC_FLUSH = 2; 用于清除所有未决输出的压缩刷新模式; 可能会降低某些压缩算法的压缩率。 */ //使用指定的压缩级别创建一个新的压缩器。 Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); //设置压缩输入数据。 deflater.setInput(unzipString.getBytes()); //当被调用时，表示压缩应该以输入缓冲区的当前内容结束。 deflater.finish(); final byte[] bytes = new byte[256]; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(256); while (!deflater.finished()) &#123; //压缩输入数据并用压缩数据填充指定的缓冲区。 int length = deflater.deflate(bytes); outputStream.write(bytes, 0, length); &#125; //关闭压缩器并丢弃任何未处理的输入。 deflater.end(); return Base64.encodeToString(outputStream.toByteArray(), Base64.NO_PADDING); &#125; /** * 解压缩 */ @Nullable public static String unzipString(String zipString) &#123; byte[] decode = Base64.decode(zipString, Base64.NO_PADDING); //创建一个新的解压缩器 https://www.yiibai.com/javazip/javazip_inflater.html Inflater inflater = new Inflater(); //设置解压缩的输入数据。 inflater.setInput(decode); final byte[] bytes = new byte[256]; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(256); try &#123; //finished() 如果已到达压缩数据流的末尾，则返回true。 while (!inflater.finished()) &#123; //将字节解压缩到指定的缓冲区中。 int length = inflater.inflate(bytes); outputStream.write(bytes, 0, length); &#125; &#125; catch (DataFormatException e) &#123; e.printStackTrace(); return null; &#125; finally &#123; //关闭解压缩器并丢弃任何未处理的输入。 inflater.end(); &#125; return outputStream.toString(); &#125;&#125; ####总结：压缩前的字节长度为：1825压缩后的字节长度为：284压缩率为63.73%，压缩后体积为原来的36.27%####2.Gzip压缩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 package com.guoshikeji.driver95128.utils;import android.text.TextUtils;import android.util.Base64;import android.util.Log;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.nio.charset.Charset;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * GZip工具类 * zip压缩解压并使用Base64进行编码工具类 * 调用： * 压缩 * GZipUtil.compress(str) * 解压 * GZipUtil.uncompressToString(bytes) */public class GzipUtil &#123; private static final String TAG = &quot;GzipUtil&quot;; /** * 将字符串进行gzip压缩 * * @param data * @return */ public static String compress(String data) &#123; if (data == null || data.length() == 0) &#123; return null; &#125; ByteArrayOutputStream out = new ByteArrayOutputStream(); GZIPOutputStream gzip; try &#123; gzip = new GZIPOutputStream(out); gzip.write(data.getBytes(&quot;utf-8&quot;)); gzip.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeToString(out.toByteArray(), Base64.NO_PADDING); &#125; public static String uncompress(String data) &#123; if (TextUtils.isEmpty(data)) &#123; return null; &#125; byte[] decode = Base64.decode(data, Base64.NO_PADDING); ByteArrayOutputStream out = new ByteArrayOutputStream(); ByteArrayInputStream in = new ByteArrayInputStream(decode); GZIPInputStream gzipStream = null; try &#123; gzipStream = new GZIPInputStream(in); byte[] buffer = new byte[256]; int n; while ((n = gzipStream.read(buffer)) &gt;= 0) &#123; out.write(buffer, 0, n); &#125; &#125; catch (IOException e) &#123; Log.e(TAG, &quot;e = &quot; + Log.getStackTraceString(e)); &#125; finally &#123; try &#123; out.close(); if (gzipStream != null) &#123; gzipStream.close(); &#125; &#125; catch (IOException e) &#123; Log.e(TAG, &quot;e = &quot; + Log.getStackTraceString(e)); &#125; &#125; return new String(out.toByteArray(), Charset.forName(&quot;utf-8&quot;)); &#125;&#125; ####总结：压缩前的字节长度为：1825压缩后的字节长度为：307压缩率为62.04%，压缩后体积为原来的37.95%，也是不错的！","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-加密-解密-数据压缩","slug":"Android-Application/android-加密-解密-数据压缩","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"}]},{"path":"wiki/Android Application/Android基础/Activity向Fragment传值/","text":"#####发送数据 12345678910111213141516//Activity传值，通过BundleBundle bundle = new Bundle();bundle.putString(&quot;MainActivity&quot;, &quot;Hello,Fragment&quot;);//首先有一个Fragment对象 调用这个对象的setArguments(bundle)传递数据myFragment.setArguments(bundle);//点击按钮接受Fragment传回来的值btn_send.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle bundle = myFragment.getArguments(); String result = bundle.getString(&quot;MyFragment&quot;); Toast.makeText(MainActivity.this, result, Toast.LENGTH_LONG).show(); &#125;&#125;); #####接收数据 12345678910111213//点击按钮接收Activity传过来的值btn_fragment.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle bundle = getArguments(); String result = bundle.getString(&quot;MainActivity&quot;); Toast.makeText(getActivity(), result, Toast.LENGTH_LONG).show(); &#125;&#125;);//Fragment回传值给ActivitygetArguments().putString(&quot;MyFragment&quot;, &quot;Hello,Activity&quot;);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/android字间距和行间距/","text":"字间距: 1android:letterSpacing = &quot;0.2&quot; 行间距: 1android:lineSpacingExtra = &quot;4dp&quot; 行间距的倍数: 1android:lineSpacingMultiplier = &quot;1.2&quot; 动态设置行间距： 12void setLineSpacing (float add, float mult)第一个参数设置间距的距离，第二个参数设置间距的倍数","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/android-加密-解密-数据压缩/android-原生base64/","text":"Android有自己的base64类 12345678import android.util.Base64String str = &quot;Hello!&quot;; //base64 加密 //String strBase64 = new String(Base64.encode(str.getBytes(), Base64.DEFAULT)); String strBase64 = Base64.encodeToString(str.getBytes(), Base64.DEFAULT); //base64 解密String str2 = new String(Base64.decode(strBase64.getBytes(), Base64.DEFAULT));","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-加密-解密-数据压缩","slug":"Android-Application/android-加密-解密-数据压缩","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"}]},{"path":"wiki/Android Application/Android基础/BroadCastReceiver(广播)/","text":"Broadcast(广播)是一种广泛运用在应用程序之间传输信息的机制； BroadcastReceiver(广播接收者)是对发送处理的广播进行过滤接收并响应的一类组件，它是用来接收来自系统和应用中的广播； 用途当开机完成后系统会产生一条广播； 当网络状态改变是系统会产生一条广播； 当电池电量改变时，系统会产生一条广播； 等等； Android为什么要这么设计：大大减少开发者的工作量和开发周期； 降低开发者的工作难度； 使用方法：发送:把信息装入一个Intent对象（如Action，Category） 通过调用对应的方法将Intent对象以广播的方式发送出去 sendBroadcast(） sengOrderBroadcast() sendStickyBroadcast() 接收：当Intent发送以后，所以已经注册的BroadcastReceiver会检测注册时的IntentFilter是否与发送的Intent相匹配，若匹配则会调用BroadCasrReceiver的OnReceive()方法。 所以当我们定义一个BroadcastReceiver的时候都需要实现onReceive()方法 注意：BroadcastReceover需要注册：静态注册，动态注册（代码注册） BroadcastReceiver生命周期只有十秒左右 在BroadcastReceiver里不能做一些比较耗时的操作 不能使用子线程（因为生命周期跟随宿主，所以同样不能执行耗时操作，开线程没有意义） 应该通过发送Intent给Service，由Service来完成； 广播的种类：普通广播(normal broadcasts)：所有监听该广播的广播接收者都可以监听到该广播； 同级别接收先后是随机的（无序） 级别低的后收到广播 接收器不能截断广播的继续传播也不能处理广播 同级别动态注册高于静态注册的 有序广播（Ordered broadcasts）：按照接收者的优先级顺序接收广播，优先级别在intent-filter中的priority中声明，-1000到1000之间，值越大，优先级越高。可以终止关闭意图的继续传播。接收者可以修改内容。 同级别接收顺序是随机的。 能截断广播的继续传播，高级别的广播接收器收到该广播后，可以决定把该广播是否截断。 接收器能截断广播的继续传播，也能处理广播。 同级别动态注册高于静态注册。 异步关闭(粘滞性滞留广播)：不能将处理结果传给下一个接收者，无法终止广播。 普通广播的使用代码：发送： 接收： 有序广播的使用代码：发送： 接收： 注册：静态注册(有序广播和普通广播的注册方式都一样)： 动态注册(有序广播和普通广播的注册方式都一样)： 注销：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Iterator迭代器/","text":"迭代器的概述A:迭代器概述: a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。 我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。 b:Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素， 如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 c:每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素 以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法 迭代器的实现原理A:迭代器的实现原理 &#x2F; * 集合中的迭代器: * 获取集合中元素方式 * 接口 Iterator : 两个抽象方法 * boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true * next() 取出集合中的下一个元素 * * Iterator接口,找实现类. * Collection接口定义方法 * Iterator iterator() * ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象 * 使用ArrayList集合的对象 * Iterator it &#x3D;array.iterator(),运行结果就是Iterator接口的实现类的对象 * it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代 *&#x2F; 迭代器的代码实现*A:迭代器的代码实现 public class IteratorDemo { public static void main(String[] args) { Collection coll &#x3D; new ArrayList(); coll.add(“abc1”); coll.add(“abc2”); coll.add(“abc3”); coll.add(“abc4”); &#x2F;&#x2F;迭代器,对集合ArrayList中的元素进行取出 迭代器的执行过程A:迭代器的执行过程 a:迭代器的原理: while(it.hasNext()) { System.out.println(it.next()); } &#x2F;&#x2F;cursor记录的索引值不等于集合的长度返回true,否则返回false public boolean hasNext() { return cursor !&#x3D; size; &#x2F;&#x2F;cursor初值为0 } &#x2F;&#x2F;next()方法作用: &#x2F;&#x2F;①返回cursor指向的当前元素 &#x2F;&#x2F;②cursor++ public Object next() { ​ int i &#x3D; cursor; ​ cursor &#x3D; i + 1; ​ return elementData[lastRet &#x3D; i]; ​ } b:for循环迭代写法: for (Iterator it2 &#x3D; coll.iterator(); it2.hasNext(); ) { System.out.println(it2.next()); } 集合迭代中的转型A:集合迭代中的转型 a:在使用集合时，我们需要注意以下几点：  集合中存储其实都是对象的地址。  集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。 因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象。 b:存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。 Collection coll &#x3D; new ArrayList(); coll.add(“abc”); coll.add(“aabbcc”); coll.add(“shitcast”); Iterator it &#x3D; coll.iterator(); while (it.hasNext()) { &#x2F;&#x2F;由于元素被存放进集合后全部被提升为Object类型 &#x2F;&#x2F;当需要使用子类对象特有方法时，需要向下转型 String str &#x3D; (String) it.next(); System.out.println(str.length()); } 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。 c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下： Collection coll &#x3D; new ArrayList(); coll.add(“abc”); coll.add(“aabbcc”); coll.add(“shitcast”); Iterator it &#x3D; coll.iterator(); while (it.hasNext()) { String str &#x3D; it.next(); &#x2F;&#x2F;当使用Iterator控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); }","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/UDP协议/","text":"UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。 示例()：发送端:package cn.itcast.demo1; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; &#x2F;* * 实现UDP协议的发送端: * 实现封装数据的类 java.net.DatagramPacket 将你的数据包装 * 实现数据传输的类 java.net.DatagramSocket 将数据包发出去* * 实现步骤: * 1. 创建DatagramPacket对象,封装数据, 接收的地址和端口 * 2. 创建DatagramSocket * 3. 调用DatagramSocket类方法send,发送数据包 * 4. 关闭资源* * DatagramPacket构造方法: * DatagramPacket(byte[] buf, int length, InetAddress address, int port) * DatagramSocket构造方法: * DatagramSocket()空参数 * 方法: send(DatagramPacket d) *&#x2F; public class UDPSend { public static void main(String[] args)throws IOException{ &#x2F;&#x2F;创建数据包对象,封装要发送的数据,接收端IP,端口 byte[] date &#x3D;”你好UDP”.getBytes(); &#x2F;&#x2F;创建InetAddress对象,封装自己的IP地址 InetAddress inet &#x3D; InetAddress.getByName(“127.0.0.1”); DatagramPacket dp &#x3D;new DatagramPacket(date, date.length, inet,6000); &#x2F;&#x2F;创建DatagramSocket对象,数据包的发送和接收对象 DatagramSocket ds &#x3D;new DatagramSocket(); &#x2F;&#x2F;调用ds对象的方法send,发送数据包 ds.send(dp); &#x2F;&#x2F;关闭资源 ds.close(); } } 接收端：package com.example.mbenben.newstudy; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; &#x2F;* * 实现UDP接收端 * 实现封装数据包 java.net.DatagramPacket 将数据接收 * 实现输出传输 java.net.DatagramSocket 接收数据包* * 实现步骤: * 1. 创建DatagramSocket对象,绑定端口号 * 要和发送端端口号一致 * 2. 创建字节数组,接收发来的数据 * 3. 创建数据包对象DatagramPacket * 4. 调用DatagramSocket对象方法 * receive(DatagramPacket dp)接收数据,数据放在数据包中 * 5. 拆包 * 发送的IP地址 * 数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象 * 返回值是InetAddress对象 * 接收到的字节个数 * 数据包对象DatagramPacket方法getLength() * 发送方的端口号 * 数据包对象DatagramPacket方法 getPort()发送端口 * 6. 关闭资源*&#x2F; public class UDPReceive { public static void main(String[] args)throws IOException { &#x2F;&#x2F;创建数据包传输对象DatagramSocket 绑定端口号 DatagramSocket ds &#x3D;new DatagramSocket(6000); &#x2F;&#x2F;创建字节数组 byte[] data &#x3D;new byte[1024]; &#x2F;&#x2F;创建数据包对象,传递字节数组 DatagramPacket dp &#x3D;new DatagramPacket(data, data.length); &#x2F;&#x2F;调用ds对象的方法receive传递数据包 ds.receive(dp); &#x2F;&#x2F;获取发送端的IP地址对象 String ip&#x3D;dp.getAddress().getHostAddress(); &#x2F;&#x2F;获取发送的端口号 int port &#x3D; dp.getPort(); &#x2F;&#x2F;获取接收到的字节个数 int length &#x3D; dp.getLength(); System.out.println(new String(data,0,length)+”…”+ip+”:”+port); ds.close(); } }","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/AndroidManifest-xml/","text":"#####一：结构图 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;manifest&gt; &lt;uses-sdk/&gt; &lt;uses-configuration/&gt; &lt;uses-feature/&gt; &lt;uses-permission/&gt; &lt;permission/&gt; &lt;permission-tree/&gt; &lt;permission-group/&gt; &lt;instrumentation/&gt; &lt;supports-screens/&gt; &lt;application&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action/&gt; &lt;category/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/receiver&gt; &lt;provider&gt; &lt;grant-uri-permission/&gt; &lt;meta-data/&gt; &lt;/provider&gt; &lt;uses-library/&gt; &lt;/application&gt; &lt;/manifest&gt; #####二：Application:属性 123456789101112131415161718192021&lt;application android:allowClearUserData = [&quot;true&quot; | &quot;false&quot;] android:allowTaskReparenting = [&quot;true&quot; | &quot;false&quot;] android:backupAgent = &quot;string&quot; android:debuggable = [&quot;true&quot; | &quot;false&quot;] android:description = &quot;string resource&quot; android:enabled = [&quot;true&quot; | &quot;false&quot;] android:hasCode = [&quot;true&quot; | &quot;false&quot;] android:icon = &quot;drawable resource&quot; android:killAfterRestore = [&quot;true&quot; | &quot;false&quot;] android:label = &quot;string resource&quot; android:manageSpaceActivity = &quot;string&quot; android:name = &quot;string&quot; android:permission = &quot;string&quot; android:persistent = [&quot;true&quot; | &quot;false&quot;] android:process = &quot;string&quot; android:restoreAnyVersion = [&quot;true&quot; | &quot;false&quot;] android:taskAffinity = &quot;string&quot; android:theme = &quot;resource or theme&quot; &gt; . . . &lt;/application&gt; Android:allowClearUserData 是否给以用户删除用户数据的权限. 如果为true应用管理者就拥有清除数据的权限；false没有。默认为true。 android:allowTaskReparenting 应用定义的activities是否可以被从启动的任务转移到和他有相同并且将被带到前台的任务。 true他们可以被转移，如果为false，他们必须和启动他们的任务保持在一起。 默认为false。 android:backupAgent 实现应用的备份代理的类名，BackupAgent的子类。 这个属性的名称因该是全限定类名(如，”com.example.project.MyBackupAgent”)。 但是，如果名称的首字母被设置为点号，也可以为类名(如，”.MyBackupAgent”)， 他将被追加到在&lt; manifest &#x2F;&gt;元素中定义的包名后。 没有默认值。 android:debuggable 应用是否可以使用debug，甚至运行在用户模式下。 true可以，false不能。默认为false。 android:description 用户可读的，比应用标签更长、更多的应用描述。 此值必须是一个引用字符串。不像标签，他不能被设置为硬编码字符串。没有默认值。 android:enabled Android系统是否可以实例化应用的组件。 如果为true可以，如果为false不可以。 如果为true，每个组件的enabled属性决定了此组件。 如果为false，他重写了组件指定值，所有的组件将不还用。 默认为true。 android:hasCode 应用是否包含代码。 true表示包含，false表示不包含。 当值为false时，在启动组件是系统不会试着加载应用的任何代码。 默认为true。 android:icon 整个应用的图标，还是每个组件的默认图标。 这个属性值 必须 被设置为drawable资源的引用。 没有默认值。 android:killAfterRestore 在整型系统重置操作中，当他的设置被重置后，应用是否应该被终止。 单个包的重置操作不会引起应用被关闭。 整个系统的恢复操作仅代表性的发生一次，当电话第一次被设置时。 第三方应用将不会经常使用此属性。 默认值为true，意思是，当整个系统被恢复时，应用运行完他的数据后，将会终止。 android:label 一个易读的应用标签，并且还是应用的每个组件的默认标签。 这个标签应该被设置为引用字符串资源，当然他也可以像其他字符串一样在用户接口中指定。 但是为了方便，在应用开发时，可以被设置未定义字符串。 android:manageSpaceActivity 一个Activity子类的全限定名称，这个Activity可以被系统启动让用户管理此应用占有的存储空间。 这个Activity也应该用&lt; activity &#x2F;&gt;元素声明。 android:name 为这个应用实现的Application子类的全限定名称。 当应用启动时，这个类将在应用的其他组件之前被实例化。 这个子类是可选的；大多数应用不需要。 在缺省时，Android使用基本Application类的实例。 android:permission 客户为了和应用交互必须设置的许可的名称。 这个属性是一个便利的途径为应用的组件设置许可。 他可以被组件的permission属性重写。 android:persistent 应用是否在所有时间下都保持运行。 true是，false不是。 默认为false。 通常情况下应用不应该设置此标识。 持久模式仅仅被几个系统应用指定。 android:process 为应用下的组件定一个运行进程名称。 每个组件可以定义自己的进程名称通过设置自己的process属性。 在默认情况下，Android为应用创建一个进程，当应用的第一个组件需要运行时。 所有的组件在同一个进程下运行。这个进程的名称和在&lt; manifest &#x2F;&gt;元素设置的backage属性名相同。 通过设置这个属性在可以在其他应用中共享，你可以协调应用的组件在同一个进程中运行，但是只有两应用也共享用户ID和签订相同的证书。 如果这个属性的名称一个冒号(“:”)开始，一个新的私有的进程将被创建。 如果一个进程的名称以小写字母开头，一个公共的进程将被创建。 一个公共的进程可以被其他应用共享，来减少资源的使用。 android:restoreAnyVersion 表明这个应用准备尝试恢复所有的备份数据集合，甚至如果备份数据是比当前安装的应用高的编号存储的。 设置为true将允许备份管理者去尝试恢复当版本不匹配，意思是数据冲突。 要小心使用。默认为false。 android:taskAffinity 提供给应用下所有组件的类同名称，除了设置了自己的taskAffinity属性的组件。 默认情况下所有的组件使用相同的affinity。 Affinity的名称和在&lt; manifest &#x2F;&gt;元素中设置的包名相同。 android:theme 为应用下的组件定义一个引用自样式资源的主题。 个别的activities可以设置自己的主题，通过设置自己的theme属性。 android:allowBackup 它表示是否允许应用程序参与备份。 如果将该属性设置为false,则即使备份整个系统,也不会执行这个应用程序的备份操作。 而整个系统备份能导致所有应用程序数据通过ADB来保存。 该属性必须是一个布尔值，或为true，或为false。 默认值为true。 android:largeHeap 应用程序是否使用一个比较大的堆创建。 它是一个布尔值，在没有配置的情况下，它的默认值是false。 #####三： activity 标签属性 android:allowTaskReparenting android:allowTaskReparenting是一个任务调整属性。 它表明当这个任务重新被送到前台时，该应用程序所定义的Activity是否可以从被启动的任务中转移到有相同亲和力的任务中。 为什么在这里还要在提一次呢？因为它与&lt; application &#x2F;&gt;的 android:allowTaskReparenting 属性重叠，因此当为正在配置的Activity提供该属性的时候，它的默认值首先来自&lt; application &#x2F;&gt;节点。如果&lt; application&#x2F;&gt;节点上没有配置该属性的时候，则false就是它的默认值。 通常，当一个Activity启动的时候，Activity管理服务就会为这个Activity生成一个任务并将此Activity与之相关联。在一个任务中可能存在多个Activity，它按照一定顺序排列在这个任务中，我们可以使用这个属性来强制它重新成为此任务的顶层Activity。在当前的任务不再显示时，也就是说，与此Activity相关联任务不在前台显示的时候，可以使用这个特性来强制Activity转移到与之有相同亲和力的任务（taskAffinity属性定义的任务）中。典型的用法是把一个应用程序的Activity移到另一个应用程序的主任务中。 例如，如果我们收到的一条短信（MMS应用程序）中包含一个电话号码文本，此时可以单击电话号码来启动拨号的快捷界面。但是，这个拨号界面是联系人应用程序的一个Activity，在这个场景下，它可能成为MMS应用程序启动的任务中的一个Activity，并位于该任务的顶层。如果它重新定位到联系人的任务中，则我们重新启动短信任务的时候就看不到这个拨号界面了。 Activity的亲和力是由taskAffinity属性定义的，Task的亲和力是通过读取当前任务根Activity的亲和力决定的。因此，根据定义，根Activity总是位于相同亲和力的任务里。由于在某些需求的要求下，一些Activity的启动模式（由launchModel属性定义）为singleTask和singleInstance，此类Activity只能位于任务的底部，因此，想要使用allowTaskReparenting属性来调整Activity所属任务，则启动默认只能限于”standard”和”singleTop”这两个模式。 android:alwaysRetainTaskState 该属性表明该Activity所在任务的状态是否由系统保存。 如果是，则其值为true，如果配置为false，则表示在一定情况下Android将以初始状态启动该任务。 默认值是false。 注意，该属性仅对任务的根Activity起作用，其他的所有Activity都会被忽略。 当用户重新选择显示该任务的时候，系统在通常情况下将会清理掉任务中除了根Activity外的其他Activity。这种情况通常是指用户在一定时间限制内未对该任务进行操作，例如30分钟内。反之如果该属性配置为true时，系统总会以任务的最后状态来显示该任务，而不管用户是如何返回的。 android:clearTaskOnLaunch 该属性表明，除了任务中的根Activity，其他所有Activity是否都将从任务中移出。 如果想要在启动时只保留根Activity，则设置这个属性的值为true，否则为false。 默认值是false。 该属性仅对启动一个新任务的根Activity有意义。 当配置为true时，每当用户再次启动任务时，则总是由任务的根Activity来处理请求。 如果该属性和allowTaskReparenting都是true，则可重新成为父任务的任何Activity就要被移动到具有相同亲和力的任务上，接着保留的Activity就被销毁。 android:configChanges 在某些设备配置（比如屏幕方向，字体大小，网络类型等）发生变化的时候，Activity将会被重新启动以适配新的配置，这是系统行为。而Android同样为应用程序提供了一个阻止这种行为发生的手段，如果你不想因为某种配置变化而发生Activity重启，则可以通过配置这个属性并选择你想要阻止的配置。如果你配置完毕并选择了你关注的配置，则当这些配置发生改变的时候Activity不会重启，而是通过onConfigurationChanged()回调方法通知应用程序这些配置发生了变化。 注意：如非必要，应该避免使用该属性 所有这些配置的改变都能影响到应用程序对资源文件的选择。所以，当onConfigurationChanged（）被调用时，通常需要重新获取所有的资源（包括视图布局和图片等），以便正确地处理这些改变。 注意，如果我们没有实现onConfigurationChanged（）回调，那么该Activity就会被销毁并重新创建。 android:enabled 该属性表示Activity是否能被实例化。 一般来说，每个Activity由Activity框架负责实例化，但你可以通过配置该属性来限制系统的这种行为。 为true表示由系统实例化，否则为false。 默认值是true。 对于每一个Activity的子类，在它首次运行之前总要进行实例化，这个步骤是必须的。 我们可以使用这个属性来控制Android框架实例化Activity的行为，但这样做是有风险的，所以不建议你这样做。 android:excludeFromRecents Android框架为我们维护了一个名叫“最近运行”的应用程序列表，以方便进行应用程序切换。 该属性表示应用程序是否应该将Activity从最近运行的应用程序列表排除。 如果排除，则为true，否则为false。 默认值为false。 这个属性的前提是该Activity是某个任务的根Activity。 android:exported 该属性表示Activity是否可以由其他应用程序中的组件来启动。 如果可以，则为true，否则为false。 如果为false，则该Activity只能由同一应用程序的组件或者有同样用户ID的应用程序来启动。 注意，如果你试图从你的应用程序中启动其他应用程序组件，在没有使用该属性的情况下，你必须以新任务（newTask）的方式启动。 android:finishOnTaskLaunch 该属性是指不管何时，当用户再次启动Activity的任务时（在主页屏幕上选择该任务）， 是否应销毁（或者终止）这个Activity的实例， 如果应销毁，则为true，否则为false. 默认值是false。 android:hardwareAccelerated 该属性是指是否应为该Activity启动硬件加速。 如果应启动，则为true，否则为false。 默认值是false。 注意：不是所有的OpenGL 2D操作都会被加速。 如果启用硬件加速渲染器，则要测试你的应用程序以便确保它能使用渲染器而不会产生错误。 android:icon 它代表Activity和图标。 在Activity被显示的时候，就用该图标显示给用户。 例如，用于示例任务的Activity的图标，或者桌面上的图标。 该属性 必须 设置为图片资源引用，如果没有设置，就使用&lt; application &#x2F;&gt;节点上的icon属性。 android:label 该属性用于描述该Activity的一个标签，通常是随着Activity图标一起显示出来的。 如果没有设置该属性，则使用&lt; application &#x2F;&gt;节点上的label属性设置的值。 android:launchMode 这个属性描述了该Activity应该如何被启动。 在Intent对象中，与Activity标志一起工作的模式有4种， 分别是：standard , singleTop , singleTask 和 singleInstance。 默认模式是standard。 * 模式有两类， * 一类是 `standard` 和 `singleTop` ，另一类是 `singleTask` 和 `singleInstance` 。 * 有 `standard` 和 `singleTop` 启动模式的Activity可多次被实例化。 * standard 是默认。系统总是在目标任务中创建Activity的一个新实例并且将intent按顺序放入到实例中。 * singleTop 有条件的 。如果Activity的实例已经存在于目标任务的顶部， 则系统通过调用onNewIntent()方法将intent发送到该实例上，而不是创建Activity的一个新实例。 * singleTask 系统在新任务的根上创建该Activity。 如果已经存在实例，则系统通过调用onNewIntent()方法来将intent发送到该Activity上，它允许在这个Activity为根的任务中创建新的Activity。 * singleInstance 和 singleTask 一样，除了系统不启动任何其他Activity到持有实例的任务上，Activity总是单个的，而且是其任务的唯一成员。 * 相反，singleTask和singleInstance这两种模式下的Activity只能启动一个任务它们一直待在Activity栈的根上。此外，设备一次只保存Activity的一个实例。 * standard和singleTop模式只在一个方面上是不同的。在satndard模式下，每次都会实例化一个Activity新实例来响应这个Intent，每个实例处理一个intent。与此相似的是，singleTop模式下的Activity的新实例也可被创建来处理新的intent。但是，如果目标任务在其栈的顶部已经有Activity的一个实例，则会使用这个已经存在的Activity的实例来处理这个intent（回调onNewintent()方法），而不会创建一个新实例。在其他情况下，如果singleTop模式下的Activity的一个已存在实例在目标任务中而非栈的顶部，或者如果它在栈的顶部而非目标任务中，就会创建一个新实例并将它压倒Activity栈顶上。 * singleTask和singleInstance模式也同样存在不同的启动特性。singleTask模式下的Activity允许其他Activity成为它的任务的一部分，它总是在自身任务的根上，但是其他Activity可以被启动到该任务中。另一方面，singleInstance模式下的Activity不允许其他Activity成为其任务的一部分，它是任务中唯一的Activity。如果它启动了另一个Activity，则该Activity就被分配到不同的任务上，好比FLAG_ACTIVITY_NEW_TASK在intent中一样。 android:multiprocess 该属性表示Activity的实例是否可以运行在启动它的组件所在的应用程序进程中。 如果可以，则为true，否则为false。 默认值是false。 android:name 该属性表示Activity的类名，它是Activity的子类。 其属性值应该是一个标准的Java类名（如com.example.liyuanjing.ManiActivity）。 我们也可以将其标识为类的缩写，比如名称的首字母是一个点（例如.ManiActivity）， 那么它就被追加&lt; manifest &#x2F;&gt;元素指定的包名， 从而变成com.example.liyuanjing.ManiActivity（假设包名为com.example.liyuanjing）。 这点完全由系统完成，我们不需要关心这个过程的细节，但这个属性是必须配置的，并且不提供默认值。 android:noHistory 这个属性用于设置在用户离开该Activity，并且它在屏幕上不再可见的时候，是否应该从Activity的堆栈中删除。 如果应该删除，则为true，否则为false，默认值是false。 true意味着Activity将不会留下历史痕迹，它将不会为任务而在Activity栈中保留数据， 所以用户将不能返回到Activity上。 android:permission 表示的是权限名称。 如果startActivity()或者startActivityForResult()的调用者还没有被授予指定的权限，则启动失败。 如果该属性没有设置，则&lt; application &#x2F;&gt;元素的 permission 属性设置的权限就应该应用到Activity中。 如果这两个属性都没有设置，则Activity就不会被权限保护。 android:process 该属性表示该Activity运行的进程名称。 通常，应用程序的所有组件在为应用程序而创建的默认进程中运行。 &lt; application &#x2F;&gt;元素的process属性可以为所有组件设置一个不同的进程， 但是每个组件可以覆盖这个属性的值，这样就实现了将应用程序部署在多个进程间。 如果分配该属性的名称是以冒号（：）开头，则在需要新进程并且Activity在该进程中运行的时候， 就会创建一个对于应用程序私有的新进程。 android:screenOrientation 该属性表示Activity显示的方向（比如纵向，横向），它是值可以是下表中的任意一个字符。 取值 说明 * unspecified 默认值，根据重力感应选择方向 * user 用户当前偏好的方向 * behind 和Activity相同的方向 * landscape 横向 * portrait 纵向 * reverseLandscape 与正常横向相反方向 的横向 * reversePortrait 与正常纵向相反方向的纵向 * sensorLandscape 只能是横向，但是可以根据重力感应来决定是正常的还是反转的横向 * sensorPortrait 中能是纵向，但是可以根据重力感应来决定是正常的或者反转的纵向 * sensor 方向由设备方向感应器来决定。显示的方向取决于用户是如何持有设备的；在用户翻转设备时，方向发生改变。有些设备在默认情况下不会翻转到所有4个可能的方向。要允许可翻转到所有4个方向，可以使用fullSensor。 * fullSensor 方向由设备方向感应为4个方向中的任意一个而确定 * nosensor 无感应模式 android:stateNotNeeded 该属性表明Activity是否能被终止以及是否能在还没有保存其状态的情况下成功重启。 如果Activity可以在不需要引用到之前状态的情况下就能被重启，则该属性为true； 如果需要引用到之前的状态才能被重启，则为false。默认值是false。 * 通常，在暂时关闭Activity之前，我们要调用onSaveInstanceState()方法来保存当前的Activity的状态。该方法在Bundle对象中存储Activity的当前状态，该对象在重启Activity时将会以参数的方式传给onCreate()方法。 * 如果该属性被设置为true，则onSaveInstanceState()就不会被调用，并且onCreate()会被传递null，这和Activity首次启动时所做的一样。 android:taskAffinity 该属性指明对该Activity有亲和力的任务。 有同样亲和力的Activity在概念上属于同一任务（默认情况下是应用程序所定义的任务）。 任务的亲和力是由其根Activity的亲和力所决定的。 android:theme 该属性是指为Activity定义一个整体主题风格资源的引用。 所谓的风格包括字体种类，整体样式等。使用该属性可以使得我们的Activity在整体上更为统一，美观。 * 如果没有设置该属性，则Activity继承将应用程序作为一个整体而设置的主题，具体可见元素的theme属性。如果theme属性也没有设置，则使用默认系统主题。 android:windowSoftInputMode 该属性表示Activity的主窗口如何与包含屏幕软键盘的窗口交互。 设置该属性将影响两件事。 * 软键盘的状态。当Activity获取输入焦点时，是否隐藏软键盘。 * 对Activity主窗口的调整。 该窗口是否被调整得更小一些来为软键盘腾出空间，或者它的内容是否被移动以便在部分窗口被软键盘覆盖时，使得当前焦点可见。该属性或者是下表的一个值，或者是state…值和adjust…值的组合。如果是多个值的组合，则使用（|）将其隔开。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Java-Character-类（单个字符串类型-字母-数字-大小写判断）/","text":"Character 类用于对单个字符进行操作。#####转义序列前面有反斜杠（\\）的字符代表转义字符，它对编译器来说是有特殊含义的。 下面列表展示了Java的转义序列： 转义序列 描述 \\t 在文中该处插入一个tab键 \\b 在文中该处插入一个后退键 \\n 在文中该处换行 \\r 在文中该处插入回车 \\f 在文中该处插入换页符 &#39; 在文中该处插入单引号 &quot; 在文中该处插入双引号 \\ 在文中该处插入反斜杠 #####实例 当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。 以下实例转义双引号并输出： 12345678public class Test &#123; public static void main(String args[]) &#123; System.out.println(&quot;访问\\&quot;菜鸟教程!\\&quot;&quot;); &#125;&#125;//以上实例编译运行结果如下：//访问&quot;菜鸟教程!&quot; #####Character 方法下面是Character类的方法： 放法 描述 isLetter() 是否是一个字母 isDigit() 是否是一个数字字符 isWhitespace() 是否是一个空白字符 isUpperCase() 是否是大写字母 isLowerCase() 是否是小写字母 toUpperCase() 指定字母的大写形式 toLowerCase 指定字母的小写形式 toString() 返回字符的字符串形式，字符串的长度仅为1","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Android-M-最简单的权限请求/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void requestPermission() &#123; //1. 检查是否已经有该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.SET_ALARM) != PackageManager.PERMISSION_GRANTED) &#123; //2. 权限没有开启，请求权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.SET_ALARM&#125;, Location_Permission); &#125;else&#123; isAgreePermission=true; //权限已经开启，做相应事情 &#125; &#125; //3. 接收申请成功或者失败回调 @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == Location_Permission) &#123; if (grantResults.length&gt;0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限被用户同意,做相应的事情 isAgreePermission=true; &#125; else &#123; //权限被用户拒绝，做相应的事情 isAgreePermission=false; &#125; &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Toast（自定义Toast）/","text":"默认的Toast:123Toast.makeText(ProjectList.this,&quot;数据请求失败&quot;,Toast.LENGTH_LONG).show(); 自定义Toast(自定义图标样式\\显示时间\\位置):效果图： 代码： 1234567MyUtils.showToast(TestActivity.this,&quot;自定义的Toast&quot;);或者 传入自定义显示时间MyUtils.showToast(TestActivity.this,&quot;自定义的Toast&quot;,3000); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class MyUtils &#123;private static Toasttoast;private static Handlermhandler =new Handler();private static Runnable r =new Runnable() &#123;public void run() &#123;isShowing=false; toast.cancel(); &#125;&#125;;private static BooleanisShowing=false;public static void showToast(final Context context, final String msg)&#123;if (!isShowing)&#123;if (toast ==null)toast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); toast.setGravity(Gravity.CENTER, 0, 0); Activity context1 = (Activity) context; LayoutInflater layoutInflater = context1.getLayoutInflater(); View inflate = layoutInflater.inflate(R.layout.toast_layout, null); TextView toast_msg = inflate.findViewById(R.id.toast_msg); toast_msg.setText(msg); toast.setView(inflate); toast.show(); isShowing=true; mhandler.postDelayed(r, 2000); &#125;&#125;public static void showToast(final Context context, final String msg,int time)&#123;if (!isShowing)&#123;if (toast ==null)toast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); toast.setGravity(Gravity.CENTER, 0, 0); Activity context1 = (Activity) context; LayoutInflater layoutInflater = context1.getLayoutInflater(); View inflate = layoutInflater.inflate(R.layout.toast_layout, null); TextView toast_msg = inflate.findViewById(R.id.toast_msg); toast_msg.setText(msg); toast.setView(inflate); toast.show(); isShowing=true; mhandler.postDelayed(r, time); &#125;&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; android:padding=&quot;8dp&quot; android:orientation=&quot;vertical&quot; android:layout_centerInParent=&quot;true&quot; android:background=&quot;@drawable/toast_shape&quot; android:layout_width=&quot;wrap_content&quot; android:minWidth=&quot;80dp&quot; android:layout_height=&quot;wrap_content&quot;&gt; android:layout_marginTop=&quot;4dp&quot; android:layout_gravity=&quot;center&quot; android:src=&quot;@mipmap/tishi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; android:id=&quot;@+id/toast_msg&quot; android:layout_marginTop=&quot;6dp&quot; android:textSize=&quot;14dp&quot; android:textColor=&quot;@color/white&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/RelativeLayout&gt;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/android-6-0新特性/","text":"android6.0:全称是Marshmallow(棉花糖)goole在2015年I&#x2F;O大会上正式公布#####主要更新模块： 电源管理：App Standby(应用待机状态，以前只有硬件待机)；检测：当设备部充电，且在这时间呢用户没有直接或间接的启动该应用；退出：当应用被激活时，或者设备充电时，系统将应用移除此状态； Doze:检测：当设备不充电，且当设备静止且灭屏一段时间；周期：平台尝试让系统处于休眠状态，周期性的进入在一个维持窗口恢复正常操作，然后进入更惨的休眠状态； App Link:全称为应用程序链接;技术点：就是我们的隐示启动Intent；android更加孤立应用程序见的关联而不再试单一的应用同浏览器的交互； 指纹识别：6.0以前一直由各手机制造厂商去研发，导致指纹识别不同的手机差异巨大；6.0以后由android系统提供API，硬件厂商只需提供相应的硬件支持即可； 应用权限管理（最重要）：5.0以前，只需要在manifest.xml中注册声明即可；5.0以后，用户可以在安装的时候关闭某些权限；6.0以后，对于一些用户隐私权限总数会在第一次提示用户是否授予权限（和IPONE类似） 运行时权限的优点：新的权限机制更好的保护了用户的隐私；给了程序向用户说明权限的作用；可以防止一些而已程序盗取用户或者手机信息，增强了android系统的安全性；","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/异步任务-AsyncTask/","text":"###为什么要使用异步任务 android单线程模型 耗时操作放在非主线程执行 ###AsyncTask为何而生 子线程中更新ui 封装、简化异步操作 ###构建AsyncTask子类的参数 AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类。通常用于被继承，继承AsyncTask需要指定如下三个泛型参数： Params:启动任务时输入参数的类型。 Progress:后台任务执行中返回进度值的类型。 Result: 后台执行任务完成后返回结果的类型。 ###构建AsyncTask子类的回调方法 doInBackground:必须重写，异步执行后台线程将要完成的任务 onPreExecute:执行后台耗时操作前被调用，通常用户完成一些初始化操作 onPostExcute:当doInBackground()完成后，系统会自动调用 onPostExcute()，并将doInBackground方法返回的值传给该方法 onProgressUpdate: 在doInBackground方法中调用publishProgress()方法更新任务的执行进度后，就会调用该方法。 ###AsyncTask注意事项 必须在ui线程中创建AsyncTask的实例 必须在ui线程中调用AsyncTask的execute()方法。 重写的四个方法是系统自带调用的，不应受到调用 每个AsyncTsk只能被执行一次，多次调用将会引发异常 ###AsyncTask模拟网络图片加载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.tyl.mystudy.asynctask;import android.app.Activity;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.ImageView;import android.widget.ProgressBar;import androidx.annotation.Nullable;import com.tyl.mystudy.R;import java.io.BufferedInputStream;import java.io.InputStream;import java.net.URL;import java.net.URLConnection;/** * Author tyl * Created on 2020/2/6 12:52 * Describe:模拟网络图片加载 */public class AsyncTaskActivity extends Activity &#123; private ImageView iv_image; private ProgressBar pro_progress; private String imgUrl=&quot;https://www.imooc.com/static/img/index/logo.png&quot;; private MyAsyncTask myAsyncTask; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_asynctask); iv_image=findViewById(R.id.iv_image); pro_progress=findViewById(R.id.pro_progress); myAsyncTask = new MyAsyncTask(); myAsyncTask.execute(imgUrl);//将url作为参数传入 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (myAsyncTask!=null&amp;&amp;myAsyncTask.getStatus()== AsyncTask.Status.RUNNING)&#123; //asyncTask还在运行 //cancel方法只是将对应的asyncTask标记为cancel状态并不是真正的取消线程的执行 // 可以在doInBackground方法中通过isCancelled()方法判断是否已处于cancel如果true则手动结束后台任务 myAsyncTask.cancel(true); &#125; &#125; public class MyAsyncTask extends AsyncTask&lt;String,Integer, Bitmap&gt; &#123; /** * AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类 * Params:启动任务时输入参数的类型。 * Progress:后台任务执行中返回进度值的类型 * Result: 后台执行任务完成后返回结果的类型。 * * 调用该AsyncTask方法： * MyAsyncTask myAsyncTask = new MyAsyncTask(); * myAsyncTask.execute(); * 调用后的代码执行顺序： *onPreExecute()-doInBackground()-onPostExecute() * onProgressUpdate()需要在doInBackground方法中调用publishProgress()方法更新任务的执行进度后，才会调用该方法。 * */ @Override protected Bitmap doInBackground(String... params) &#123; //可以在这里执行一些异步任务 这里的所以执行都在子线程中// publishProgress();//可以传入值，并调用onProgressUpdate() if (!isCancelled())&#123; String url=params[0]; Bitmap bitmap=null; URLConnection connection; InputStream inputStream; try &#123; connection=new URL(url).openConnection();//获取网络连接对象 inputStream=connection.getInputStream();//获取到输入流 BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); bitmap = BitmapFactory.decodeStream(bufferedInputStream);//将输入流解析成bitMap inputStream.close();//关闭输入流 bufferedInputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //将bitmap作为返回值返回 return bitmap; &#125; return null; &#125; @Override protected void onPreExecute() &#123; super.onPreExecute(); //可以在这里执行一些代码初始化的工作 iv_image.setVisibility(View.GONE); pro_progress.setVisibility(View.VISIBLE); &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; super.onPostExecute(bitmap); //在这里与ui线程通信 这个方法运行在主线程 if (bitmap!=null)&#123; iv_image.setImageBitmap(bitmap); iv_image.setVisibility(View.VISIBLE); pro_progress.setVisibility(View.GONE); &#125; &#125; @Override protected void onProgressUpdate(Integer... integers) &#123; super.onProgressUpdate(integers); //在这里执行进度更新// pro_progress.setProgress(integers[0]); &#125; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Android-倒计时/","text":"####CountDownTimer：官方文档。CountDownTimer是一个倒计时的类，还可以指定时间间隔定期通知，举个栗子，比如说你倒计时是100秒的，可以指定每20秒通知一次，这样开始的时候会回调一次，20秒时会回调一次，40秒时会回调一次…，200秒时的回调和时间间隔的回调不同方法的。常用方法： cancel() 取消倒计时 onFinish() 时间到了，就会触发回调。 onTick 定期间隔触发回调 start() 开始倒计时 #####示例： 12345678910111213//new CountDownTimer(倒计时多久, 倒计时速度) 毫秒为单位CountDownTimer timer = new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; mTimer2.setEnabled(false); mTimer2.setText(&quot;已发送(&quot; + millisUntilFinished / 1000 + &quot;)&quot;); &#125; @Override public void onFinish() &#123; mTimer2.setEnabled(true); mTimer2.setText(&quot;重新获取验证码&quot;); &#125; &#125;.start();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Android中接口回调-方法回调/","text":"在android开发中我们很多地方都用到了方法的回调，回调就是把方法的定义和功能导入实现分开的一种机制，目的是为了解耦他的本质是基于观察者设计模式，即观察者设计模式的的简化版，例如：在下载时候的进度回调，在adapter与activity之间的回调，在javabean和fragment以及fragment之间的回调等等，回调的目的主要有两个：其一是传递数据，其二是保持数据的同步更新。常用的有两种形式，一是使用内部类的形式，得到接口的子类对象，另一种是直接实现定义的接口。 ####一、内部类的形式 1、在需要传递数据的一端定义一个接口，接口里面些需要监听的方法以及参数。 2、定义一个的接口类型的变量存储数据。 3、创建一个公共的方法，让外部调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化。 12345678910111213141516/** * 定义一个接口 */ public interface onListener&#123; void OnListener(String code,String msg); &#125; /** *定义一个变量储存数据 */ private onListener listener; /** *提供公共的方法,并且初始化接口类型的数据 */ public void setListener( onListener listener)&#123; this.listener = listener; &#125; 4、在合适的位置调用接口里面的方法，传递数据。 123456/** * 在合适的位置给其调用接口，给其赋值 */ if (listener != null) &#123; listener.OnListener(rtncode, rtnmsg); &#125; 5、在需要获取数据的地方，创建对象调方法 1234567Print print = new Print(); print.setListener(new PrintTicket.onListener() &#123; @Override public void OnListener(String code, String msg) &#123; //在这里获取数据进行处理 &#125; &#125;); 二、实现接口的形式1、定义一个接口，可以另起包名，或者定义在类里面。 123456/** * 定义一个接口 */public interface onListener&#123; void OnListener(String code,String msg);&#125; 2、在需要传递数据的一端的构造方法对接口进行初始化。 123public Print(OnListener listener) &#123; this.listener = listener; &#125; 3、在合适的位置调用接口里面的方法，传递数据。 123456/** * 在合适的位置给其调用接口，给其赋值 */if (listener!=null) &#123; listener.OnListener(rtncode,rtnmsg);&#125; 4、在需要获取数据的地方创建对象传递参数。 1Print print = new Print(this); 这里面的this代指的是当前页面的activity，如果是fragment的话，需要重写onAttach方法对其进行初始化，强制类型转换后获取接口对象。此时在构造方法里面传递接口得数据listener，如下二选一。 1234567891011@Overridepublic void onAttach(Activity activity) &#123; super.onAttach(activity); OnListener listener = (OnListener) activity;&#125;@Overridepublic void onAttach(Context context) &#123; OnListener listener = (OnListener) activity;&#125; 注意：直接在fragment里面进行获取当前fragment所在的activity，调用getActivity进行强转或者直接传递会报错。报的错误为类型转换错误。5、让activity实现此接口，重写其抽象方法，在抽象法里面处理任务。 1234@Override public void OnListener(String rtncode, String rtnmsg) &#123; //在这里获取数据进行处理 &#125; 以上两个回调方法适用于两个类之间的数据传递，现在来看看三个类之间的数据传递，javabean——&gt;activity——&gt;fragment之间的数据传递。需求：在javabean中获取数据，当点击fragment按钮时候，要求显示获取的数据进行相关业务处理。步骤如下：1、新建一个包，定义一个接口，定义相关方法。 2、在javabean的构造方法中对接口进行初始化，并在适当的位置调用一下接口中的方法。 3、在fragment中重写onAttach，对接口进行初始化，强转为接口类型。 4、创建对象，传递参数为3中强转的接口类型。 5、让acitivity实现接口，重写抽象方法，在方法中进行数据的处理。 具体代码就省略了……具体应用见：http://blog.csdn.net/yoonerloop/article/details/52127143","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/android-6-0动态权限/","text":"ContextCompact.checkSelfPermission 检查是否已有某个权限 ActivityCompat.requestPermissions() 权限请求 onRequestPermissionResult() 权限请求后的回调 ActivityCompat.shouldShowRequestPermissionRationale 可以给用户展示的一个权限请求来的作用，在权限被用户拒绝的情况才会出现 #####危险权限： CALENDAR CAMERA CONTACTS LOCATION MICROPHONE PHONE SENSORS SMS STORAGE #####详情：#####简单的权限请求demo 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.bn_main).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; callPhone();//模拟打电话 &#125; &#125;); &#125; private void callPhone()&#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE)!= PackageManager.PERMISSION_GRANTED)&#123; //权限请求未被同意 ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1); &#125;else &#123; //权限请求被同意 &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1://请求的权限码 if (grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; //权限被同意 &#125;else &#123; //权限被拒绝 提示用戶沒有權限 &#125; break; &#125; &#125;&#125; #####封装： 123456789101112131415161718192021222324252627/** * 檢查是否由權限 * */private Boolean hasPermission(String ... permissions)&#123; for(String permission:permissions)&#123; if (ContextCompat.checkSelfPermission(this,permission)!= PackageManager.PERMISSION_GRANTED)&#123; return false; &#125; &#125; return true; &#125; /** * 權限請求 * */ private void requestPermissions(int code,String ... permissions)&#123; ActivityCompat.requestPermissions(this,permissions,code); &#125;@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case Constants.CALL_CODE: break; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/ANR/","text":"什么是ANR：Application Not Responding;应用程序无响应弹出的对话框;应用程序的响应是由Activity Manager和Window Manager监视的；一般activity5秒无响应或者notifcation10秒没反应或者没有响应结束就会弹出ANR； 造成ANR的主要原因：主线程被阻塞（4.0以后不允许在主线程中执行网络IO操作）；主线程中存在耗时操作； 如何避免ANR：使用AsyncTask处理耗时操作；使用Thread和HandlerThread提高优先级；使用Handler来处理工作线程的耗时操作；Activity的onCreate和onReseme回调中尽量避免耗时代码；","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/android-ImageView-scaleType的属性理解/","text":"######android:scaleType&#x3D;“center” 保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size时，多出来的部分被截掉。 ######android:scaleType&#x3D;“center_inside” 以原图正常显示为目的，如果原图大小大于ImageView的size，就按照比例缩小原图的宽高，居中显示在ImageView中。如 果原图size小于 ImageView的size，则不做处理居中显示图片。 ######android:scaleType&#x3D;“center_crop” 以原图填满ImageView为目的，如果原图size大于ImageView的size，则与center_inside一样，按比例缩小，居中显示在ImageView上。如果原图size小于ImageView的size，则按比例拉升原图的宽和高，填充ImageView居中显示。 android:scaleType&#x3D;“matrix” 不改变原图的大小，从ImageView的左上角开始绘制，超出部分做剪切处理。 ######androd:scaleType&#x3D;“fit_xy” 把图片按照指定的大小在ImageView中显示，拉伸显示图片，不保持原比例，填满ImageView. ######android:scaleType&#x3D;“fit_start” 把原图按照比例放大缩小到ImageView的高度，显示在ImageView的start（前部&#x2F;上部）。 ######android:sacleType&#x3D;“fit_center” 把原图按照比例放大缩小到ImageView的高度，显示在ImageView的center（中部&#x2F;居中显示）。 ######android:scaleType&#x3D;“fit_end” 把原图按照比例放大缩小到ImageView的高度，显示在ImageVIew的end（后部&#x2F;尾部&#x2F;底部）","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/逻辑运算符/","text":"","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Android-ConstraintLayout-使用详解/","text":"ConstraintLayout（约束布局）已经推出有一段时间了，在 Android Studio 中也作为了默认布局，能够减少布局的层级并改善布局性能，因此很有必要来研究下其功能与使用方法ConstraintLayout 能够灵活地定位和调整子View的大小，子 View 依靠约束关系来确定位置。在一个约束关系中，需要有一个 Source（源）以及一个 Target（目标），Source 的位置依赖于 Target，可以理解为“通过约束关系，Source 与 Target链接在了一起，Source 相对于 Target 的位置便是固定的了#####一、基本属性ConstraintLayout 最基本的属性控制有以下几个，即 layout_constraintXXX_toYYYOf 格式的属性，即将“View A”的方向 XXX 置于 “View B”的方向 YYY 。当中，View B 可以是父容器即 ConstraintLayout ，用“parent”来表示 layout_constraintBaseline_toBaselineOf （View A 内部文字与 View B 内部文字对齐） layout_constraintLeft_toLeftOf （View A 与 View B 左对齐） layout_constraintLeft_toRightOf （View A 的左边置于 View B 的右边） layout_constraintRight_toLeftOf （View A 的右边置于 View B 的左边） layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf各个方位的参照图可以看以下图片ConstraintLayout 的这些属性是为控件添加了某个方向的约束力，根据某个方向约束力的“有无”或“强弱”，控件会位于不同的位置例如，看以下代码，根据某个方向的约束的不同，控件会居中或者不会1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;150dp&quot; android:layout_margin=&quot;20dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;20dp&quot; android:background=&quot;#68b0f9&quot; android:gravity=&quot;center&quot; android:text=&quot;没有设置底部约束，所以不会居于中间&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv1&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/tv1&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;20dp&quot; android:background=&quot;#984ff7&quot; android:gravity=&quot;center&quot; android:text=&quot;上下均设置了约束，所以会居于中间&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/tv1&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv1&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv2&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 可以看到，蓝色方块由于只设置了顶部约束而没有设置底部约束，所有蓝色方块只会与黄色方块顶部对齐，而紫色方块由于上下均设置了约束，且约束力的“强度”相同，所以紫色方块会呈现居中效果 #####二、约束力的强度那么，约束力的“强度”该如何设定呢？可以依靠 layout_constraintHorizontal_bias 和 layout_constraintVertical_bias 两个属性，即用来设置控件在水平和垂直方向的偏移量例如，以下布局中， TextView 应该是处于水平和垂直两个方向居中的 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 而在以下代码中，黄色方块左侧所占的剩余空间从50%变成了100%，上侧所占的剩余空间从50%变成了10% 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.1&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; #####三、Visibility 属性在以前的布局中，如果 View 的 visibility 属性设置为 gone，那么其他原本依赖该 View 来参照定位的属性都会失效，而在 ConstraintLayout 布局中会有所不同例如，在以下布局中，红色方块位于屏幕右上角与黄色方块左下角形成的矩形的中间位置 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#fa6e61&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/tv1&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/tv1&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 如果将黄色方块的 visibility 属性设置为 gone，那么，红色方块的位置会发生变化。可以理解为黄色方块缩小为一个不可见的小点，位于其原先位置的中间，而红色方块则改为依照该点来进行定位此时，红色方块可以依靠 layout_goneMarginBottom 、layout_goneMarginStart等属性来设置与黄色方块之间的边距，这类属性只有在黄色方块的 visibility 属性设置为gone时才会生效#####四、宽高比在其他布局中，如果想根据屏幕的宽度来为 View 设置固定的宽高比的话是比较麻烦的，但在 ConstraintLayout 中可以直接设置例如，如果想实现一个固定宽高比的顶部标题栏的话，可以将宽和高设置为 0dp，然后为其设置 app:layout_constraintDimensionRatio 属性，设定宽高比为16：7 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintDimensionRatio=&quot;h,16:7&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;#5476fd&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintDimensionRatio=&quot;W,15:25&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv1&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 要使用 layout_constraintDimensionRatio 属性，需要至少设置宽度或者高度为 0dp，宽高的尺寸比例可以通过“float值”或者“宽度：高度”的形式来设置如果宽度和高度都是 0dp ，系统会使用满足所有约束条件和宽高比率值的最大尺寸如果要根据其中一个尺寸来约束另外一个尺寸，则可以在比率值的前面添加 W 或者 H 来指明约束宽度或者高度#####五、设置控件之间的宽高占比ConstraintLayout 也可以像 LinearLayout 一样为子控件设置 layout_weight 属性，从而控件子控件之间的宽高占比 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot; app:layout_constraintHorizontal_weight=&quot;1.5&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#55e4f4&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv3&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#f186ad&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv2&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; #####六、锚向指示线当需要一个任意位置的锚点时，可以使用指示线（Guideline）来帮助定位，指示线实际上是 View 的子类，使用方式和普通的 View 相同，但指示线有着如下的特殊属性： 宽度和高度均为0 可见性为 View.GONE 即指示线只是为了帮助其他 View 定位而存在，实际上并不会出现在实际界面中例如，如下代码加入了两条指示线，可以选择使用百分比或实际距离来设置指示线的位置，此外也可以通过 orientation 属性来设置指示线的方向 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_begin=&quot;100dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/guideline1&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/guideline2&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 设置横向指示线距离顶部 100dp竖向指示线设置其距离百分比为 0.5，所以是位于屏幕的中间位置#####七、Chains链Chain 链比较难描述，它是一种特殊的约束，可以为多个通过 chain 链连接的 View 来分发剩余空间位置，类似于 LinearLayout 中的权重比 weight 属性，但 Chains 链要强大得多如果几个View之间通过双向连接而互相约束对方的位置，那么将其视为链条例如，以下布局代码所呈现出来的效果，就可以称为一条链条，在这条链的最左侧的元素成为链头，可以在其身上设置一些属性以决定这个链的展示效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;50dp&quot; android:layout_marginTop=&quot;0dp&quot; android:background=&quot;#ff538c&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv3&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#41c0ff&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv2&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 链条分为水平链条和竖直链条两种，分别用 layout_constraintHorizontal_chainStyle 和 layout_constraintVertical_chainStyle 两个属性来设置属性值有以下三种： spread spread_inside packed 默认值为 spread可以通过下图来理解各个参数值的含义当参数值为 spread 以及控件宽度非 0 时 12android:layout_width=&quot;wrap_content&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread&quot; 当参数值为 spread 以及控件宽度为 0 时 12android:layout_width=&quot;0dp&quot;app:layout_constraintHorizontal_chainStyle=&quot;spread&quot; 当参数值为 spread_inside 以及控件宽度非0时 12android:layout_width=&quot;wrap_content&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot; 转自：https://www.jianshu.com/p/b884b8c46584","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/StringBuffer和StringBuilder/","text":"StringBuffer、StringBuilder和String一样，也用来代表字符串。String类是不可变类，任何对String的改变都 会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。既然可变和不可变都有了，为何还有一个StringBuilder呢？相信初期的你，在进行append时，一般都会选择StringBuffer吧！ 先说一下集合的故事，HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 接下来，我直接贴上测试过程和结果的代码，一目了然： [java] view plain copy public class StringTest { public static String BASEINFO &#x3D; “Mr.Y”; public static final int COUNT &#x3D; 2000000; &#x2F;** * 执行一项String赋值测试 *&#x2F; public static void doStringTest() { String str &#x3D;new String(BASEINFO); long starttime &#x3D; System.currentTimeMillis(); for (int i &#x3D; 0; i &lt; COUNT &#x2F; 100; i++) { str &#x3D; str +”miss”; ​ } long endtime &#x3D; System.currentTimeMillis(); ​ System.out.println((endtime - starttime) +” millis has costed when used String.”); } &#x2F;** * 执行一项StringBuffer赋值测试 *&#x2F; public static void doStringBufferTest() { StringBuffer sb &#x3D;new StringBuffer(BASEINFO); long starttime &#x3D; System.currentTimeMillis(); for (int i &#x3D; 0; i &lt; COUNT; i++) { sb &#x3D; sb.append(“miss”); ​ } long endtime &#x3D; System.currentTimeMillis(); ​ System.out.println((endtime - starttime) +” millis has costed when used StringBuffer.”); } &#x2F;** * 执行一项StringBuilder赋值测试 *&#x2F; public static void doStringBuilderTest() { StringBuilder sb &#x3D;new StringBuilder(BASEINFO); long starttime &#x3D; System.currentTimeMillis(); for (int i &#x3D; 0; i &lt; COUNT; i++) { sb &#x3D; sb.append(“miss”); ​ } long endtime &#x3D; System.currentTimeMillis(); ​ System.out.println((endtime - starttime) +” millis has costed when used StringBuilder.”); } &#x2F;** * 测试StringBuffer遍历赋值结果 * * @param mlist *&#x2F; public static void doStringBufferListTest(List mlist) { StringBuffer sb &#x3D;new StringBuffer(); long starttime &#x3D; System.currentTimeMillis(); for (String string : mlist) { ​ sb.append(string); ​ } long endtime &#x3D; System.currentTimeMillis(); System.out.println(sb.toString() +”buffer cost:” + (endtime - starttime) +” millis”); } &#x2F;** * 测试StringBuilder迭代赋值结果 * * @param mlist *&#x2F; public static void doStringBuilderListTest(List mlist) { StringBuilder sb &#x3D;new StringBuilder(); long starttime &#x3D; System.currentTimeMillis(); for (Iterator iterator &#x3D; mlist.iterator(); iterator.hasNext();) { ​ sb.append(iterator.next()); ​ } long endtime &#x3D; System.currentTimeMillis(); System.out.println(sb.toString() +”builder cost:” + (endtime - starttime) +” millis”); } public static void main(String[] args) { ​ doStringTest(); ​ doStringBufferTest(); ​ doStringBuilderTest(); List list &#x3D;new ArrayList(); list.add(“ I “); list.add(“ like “); list.add(“ BeiJing “); list.add(“ tian “); list.add(“ an “); list.add(“ men “); list.add(“ . “); ​ doStringBufferListTest(list); ​ doStringBuilderListTest(list); } } 看一下执行结果： 2711 millis has costed when used String. 211 millis has costed when used StringBuffer. 141 millis has costed when used StringBuilder. I like BeiJing tian an men . buffer cost:1 millis I like BeiJing tian an men . builder cost:0 millis 从上面的结果可以看出，不考虑多线程，采用String对象时（我把Count&#x2F;100），执行时间比其他两个都要高，而采用StringBuffer对象和采用StringBuilder对象的差别也比较明显。由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。 从后面List的测试结果可以看出，除了对多线程的支持不一样外，这两个类的使用方式和结果几乎没有任何差别","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/EditText焦点动态控制/","text":"设置焦点（需要同时设置以下3个属性）： edit.setFocusable(true); edit.setFocusableInTouchMode(true); edit.requestFocus(); 取消焦点：edit.setFocusable(false);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/SharedPreferences数据存储/","text":"SharedPreferences是Android平台上一个轻量级的存储类，用来保存应用的一些常用配置，比如Activity状态，Activity暂停时，将此activity的状态保存到SharedPereferences中；当Activity重载，系统回调方法onSaveInstanceState时，再从SharedPreferences中将值取出。#####操作模式:SharedPreferences数据的四种操作模式 Context.MODE_PRIVATE Context.MODE_APPEND Context.MODE_WORLD_READABLE Context.MODE_WORLD_WRITEABLE Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容 Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件. Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件. MODE_WORLD_READABLE：表示当前文件可以被其他应用读取. MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入特别注意：出于安全性的考虑，MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 在Android 4.2版本中已经被弃用 #####存储数据： 1234567SharedPreferences sp = mContext.getSharedPreferences(&quot;name&quot;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putString(&quot;username&quot;, username); editor.putString(&quot;passwd&quot;, passwd); editor.commit();//更改数据方法一样，直接提交新的值给KEY就ok #####读取数据： 123SharedPreferences sp = mContext.getSharedPreferences(&quot;name&quot;, Context.MODE_PRIVATE); string name=sp.getString(&quot;username&quot;, &quot;默认值&quot;)); string password=sp.getString(&quot;passwd&quot;, &quot;&quot;)); ####清空指定数据： 1234SharedPreferences sp = mContext.getSharedPreferences(&quot;name&quot;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.remove(&quot;username&quot;);//key名称 editor.commit(); ####清空所有数据： 1234SharedPreferences sp = mContext.getSharedPreferences(&quot;name&quot;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.clear(); editor.commit();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/android-popwind/","text":"12345678910111213141516171819202122232425262728293031private void MorePopShow() &#123; View view = LayoutInflater.from(this).inflate(R.layout.layout_target_more, null, false); TextView tv_note_delete = (TextView) view.findViewById(R.id.tv_note_delete); //1.构造一个PopupWindow，参数依次是加载的View，宽高 PopupWindow popWindow = new PopupWindow(view, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true); popWindow.setAnimationStyle(R.anim.note_pop_anim); //设置加载动画 //这些为了点击非PopupWindow区域，PopupWindow会消失的，如果没有下面的 //代码的话，你会发现，当你把PopupWindow显示出来了，无论你按多少次后退键 //PopupWindow并不会关闭，而且退不出程序，加上下述代码可以解决这个问题 popWindow.setTouchable(true); //popWindow.setTouchInterceptor(new View.OnTouchListener() &#123; // @Override // public boolean onTouch(View v, MotionEvent event) &#123; // return false; // // 这里如果返回true的话，touch事件将被拦截 // // 拦截后 PopupWindow的onTouchEvent不被调用，这样点击外部区域无法dismiss // &#125; //&#125;); popWindow.setBackgroundDrawable(new ColorDrawable(0x00000000)); //要为popWindow设置一个背景才有效 //设置popupWindow显示的位置，参数依次是参照View，x轴的偏移量，y轴的偏移量 popWindow.showAsDropDown(iv_more, 50, 0); tv_note_delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; popWindow.dismiss(); &#125; &#125;); &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/同步锁Synchronized和Lock/","text":"Java多线程Java中，可运行的程序都是有一个或多个进程组成。进程则是由多个线程组成的。 最简单的一个进程，会包括mian线程以及GC线程。 线程的状态线程状态由以下一张网上图片来说明： 在图中，红框标识的部分方法，可以认为已过时，不再使用。 （1）wait、notify、notifyAll是线程中通信可以使用的方法。线程中调用了wait方法，则进入阻塞状态，只有等另一个线程调用与wait同一个对象的notify方法。这里有个特殊的地方，调用wait或者notify，前提是需要获取锁，也就是说，需要在同步块中做以上操作。 （2）join方法。该方法主要作用是在该线程中的run方法结束后，才往下执行。如以下代码： package com.thread.simple; public class ThreadJoin { public static void main(String[] args) { Threadthread&#x3D; new Thread(new Runnable() { ​ @Override ​ public void run() { ​ System.err.println(“线程”+Thread.currentThread().getId()+” 打印信息”); ​ } ​ }); ​ thread.start(); ​ try { ​ thread.join(); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ System.err.println(“主线程打印信息”); } } 该方法显示的信息是： 线程8 打印信息 主线程打印信息 如果去掉其中的join方法，则显示如下： 主线程打印信息 线程8 打印信息 （3）yield方法。这个是线程本身的调度方法，使用时你可以在run方法执行完毕时，调用该方法，告知你已可以出让内存资源。 其他的线程方法，基本都会在日常中用到，如start、run、sleep，这里就不再介绍。 Synchronized（同步锁） 在Java中使用多线程，你就不能绕过同步锁这个概念。这在多线程中是十分重要的。 在Java多线程的使用中，你必然会遇到一个问题：多个线程共享一个或者一组资源，这资源包括内存、文件等。 很常见的一个例子是，张三在银行账户存有9999元，经过多次的取100，存100后，账户还有多少钱？ 看代码： 以下表示账户信息： package com.thread.simple; import java.sql.Time; import java.util.concurrent.TimeUnit; public class Account { private String name; private float amt; public Account(String name,float amt) { this.name&#x3D;name; this.amt&#x3D;amt; } public void increaseAmt(float increaseAmt){ ​ try { ​ TimeUnit.SECONDS.sleep(1); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ amt+&#x3D;increaseAmt; } public void decreaseAmt(float decreaseAmt){ ​ try { ​ TimeUnit.SECONDS.sleep(1); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } amt-&#x3D;decreaseAmt; } public void printMsg(){ ​ System.out.println(name+”账户现有金额为：”+amt); } } 以下是我们操作账户的方法： ​ final int NUM&#x3D;100; Thread[]threads&#x3D;new Thread[NUM]; for(inti&#x3D;0;i ​ if(threads[i]&#x3D;&#x3D;null){ ​ threads[i]&#x3D;new Thread(new Runnable() { ​ @Override ​ public void run() { ​ account.increaseAmt(100f); ​ account.decreaseAmt(100f); ​ } ​ }); ​ threads[i].start(); ​ } ​ } for(inti&#x3D;0;i ​ try { ​ threads[i].join(); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ } ​ account.printMsg(); 你会发现，每次打印出来的账户余额都不一定是一样的。这就是同步锁的必要性。 java中，提供了多种使用同步锁的方式。 （1）对动态方法的修饰。 作用的是调用该方法的对象（或者说对象引用）。 public synchronized void doSomething(){} ( 2) 对代码块的修饰。 作用的是调用该方法的对象（或者说对象引用）。 public void increaseAmt(float increaseAmt){ ​ try { ​ TimeUnit.SECONDS.sleep(1); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ synchronized (this) { ​ System.out.println(this); ​ amt+&#x3D;increaseAmt; ​ } } （3）对静态方法的修饰。 作用的是静态方法所在类的所有对象（或者说对象引用）。 public synchronized static void increaseAmt(float increaseAmt){ ​ try { ​ TimeUnit.SECONDS.sleep(1); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ amt+&#x3D;increaseAmt; } （4）对类的修饰。 作用的是静态方法所在类的所有对象（或者说对象引用）。 synchronized (AccountSynchronizedClass.class) { amt-&#x3D;decreaseAmt; } 以修饰代码块的方式为例，我们重新运行以上代码后，得到了正确的结果。代码如下： package com.thread.simple; import java.util.concurrent.TimeUnit; &#x2F;** * Synchronized 代码块 * @author 战国 * *&#x2F; public class AccountSynchronizedBlock { private String name; private float amt; public AccountSynchronizedBlock(String name,float amt) { this.name&#x3D;name; this.amt&#x3D;amt; } public void increaseAmt(float increaseAmt){ ​ try { ​ TimeUnit.SECONDS.sleep(1); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ synchronized (this) { ​ System.out.println(this); ​ amt+&#x3D;increaseAmt; ​ } } public void decreaseAmt(float decreaseAmt){ ​ try { ​ TimeUnit.SECONDS.sleep(1); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ synchronized (this) { ​ System.out.println(this); amt-&#x3D;decreaseAmt; ​ } } public void printMsg(){ ​ System.out.println(name+”账户现有金额为：”+amt); } } &#x2F;&#x2F;多线程synchronized修饰代码块 ,每次计算的值都一样 final AccountSynchronizedBlockaccount&#x3D;new AccountSynchronizedBlock(“张三”, 9999.0f); final intNUM&#x3D;50; Thread[]threads&#x3D;new Thread[NUM]; for(inti&#x3D;0;i ​ if(threads[i]&#x3D;&#x3D;null){ ​ threads[i]&#x3D;new Thread(new Runnable() { ​ @Override ​ public void run() { ​ account.increaseAmt(100f); ​ account.decreaseAmt(100f); ​ } ​ }); ​ threads[i].start(); ​ } ​ } for(inti&#x3D;0;i ​ try { ​ threads[i].join(); ​ } catch (InterruptedException e) { ​ &#x2F;&#x2F; TODO Auto-generated catch block ​ e.printStackTrace(); ​ } ​ } ​ account.printMsg(); 以上是同步锁的简单说明。 在JDK5中，Java又引入了一个相似的概念Lock，也就是锁。功能与synchronized是类似的。 Lock Lock对比synchronized有高手总结的差异如下： 总结来说，Lock和synchronized有以下几点不同： 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 （参考http://www.cnblogs.com/dolphin0520/p/3923167.html）。 Lock的操作与synchronized相比，灵活性更高，而且Lock提供多种方式获取锁，有Lock、ReadWriteLock接口，以及实现这两个接口的ReentrantLock类、ReentrantReadWriteLock类。 对Lock的简单操作代码如下： package com.thread.simple; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class LockImp { private Locklock&#x3D;new ReentrantLock(); private ReadWriteLockrwLock&#x3D;new ReentrantReadWriteLock(); private List list&#x3D;new ArrayList(); public void doReentrantLock(Thread thread){ ​ lock.lock(); ​ System.out.println(thread.getName()+”获取锁”); ​ try { for(inti&#x3D;0;i&lt;10;i++){ ​ list.add(i); ​ } ​ } catch (Exception e) { ​ }finally{ ​ lock.unlock(); ​ System.out.println(thread.getName()+”释放锁”); ​ } } public void doReentrantReadLock(Thread thread){ ​ rwLock.readLock().lock(); ​ System.out.println(thread.getName()+”获取读锁”); ​ try { for(inti&#x3D;0;i&lt;10;i++){ ​ list.add(i); ​ } ​ } catch (Exception e) { ​ }finally{ ​ rwLock.readLock().unlock(); ​ System.out.println(thread.getName()+”释放读锁”); ​ } } public void doReentrantWriteLock(Thread thread){ ​ rwLock.writeLock().lock(); ​ System.out.println(thread.getName()+”获取写锁”); ​ try { for(inti&#x3D;0;i&lt;10;i++){ ​ list.add(i); ​ } ​ } catch (Exception e) { ​ }finally{ ​ rwLock.writeLock().unlock(); ​ System.out.println(thread.getName()+”释放写锁”); ​ } } &#x2F;** * @param args *&#x2F; public static void main(String[] args) { final LockImplockImp&#x3D;new LockImp(); final Threadthread1&#x3D;new Thread(); final Threadthread2&#x3D;new Thread(); final Threadthread3&#x3D;new Thread(); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ lockImp.doReentrantLock(thread1); ​ } ​ }).start(); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ lockImp.doReentrantLock(thread2); ​ } ​ }).start(); ​ new Thread(new Runnable() { ​ @Override ​ public void run() { ​ lockImp.doReentrantLock(thread3); ​ } ​ }).start(); ​ lockImp.doReentrantReadLock(thread1); ​ lockImp.doReentrantReadLock(thread2); ​ lockImp.doReentrantReadLock(thread3); ​ lockImp.doReentrantWriteLock(thread1); ​ lockImp.doReentrantWriteLock(thread2); ​ lockImp.doReentrantWriteLock(thread3); } } Lock的使用中，务必需要lock、unlock同时使用，避免死锁。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/new-Random()--生成随机数/","text":"","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/正则表达式/","text":"1.1正则表达式的概念 正则表达式（英语：Regular Expression，在代码中常简写为regex）。 正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。 1.2 正则表达式的匹配规则 参照帮助文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。我们来学习语法规则。 正则表达式的语法规则： 字符：x 含义：代表的是字符x 例如：匹配规则为**”a”**，那么需要匹配的字符串内容就是”a” 字符：****\\ 含义：代表的是反斜线字符’&#39; 例如：匹配规则为**”\\“，**那么需要匹配的字符串内容就是”\\” 字符：****\\t 含义：制表符 例如：匹配规则为**”\\t**”，那么对应的效果就是产生一个制表符的空间 字符：****\\n 含义：换行符 例如：匹配规则为**”\\n”**，那么对应的效果就是换行,光标在原有位置的下一行 字符：****\\r 含义：回车符 例如：匹配规则为**”\\r”** ，那么对应的效果就是回车后的效果,光标来到下一行行首 字符类：[abc] 含义：代表的是字符a、b 或 c 例如：匹配规则为**”[abc]”** ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个 字符类：[^abc] 含义：代表的是除了a、b 或 c以外的任何字符 例如：匹配规则为**”[^abc]”**，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符 字符类：[a-zA-Z] 含义：代表的是a到 z 或 A 到 Z，两头的字母包括在内 例如：匹配规则为**”[a-zA-Z]”**，那么需要匹配的是一个大写或者小写字母 字符类：[0-9] 含义：代表的是0到9数字，两头的数字包括在内 例如：匹配规则为**”[0-9]”**，那么需要匹配的是一个数字 字符类：[a-zA-Z_0-9] 含义：代表的字母或者数字或者下划线(即单词字符) 例如：匹配规则为**” [a-zA-Z_0-9] “**，那么需要匹配的是一个字母或者是一个数字或一个下滑线 预定义字符类：. 含义：代表的是任何字符 例如：匹配规则为**” . “**，那么需要匹配的是一个任意字符。如果，就想使用.的话，使用匹配规则”\\.”来实现 预定义字符类：****\\d 含义：代表的是0到9数字，两头的数字包括在内，相当于[0-9] 例如：匹配规则为**”\\d “**，那么需要匹配的是一个数字 预定义字符类：****w 含义：代表的字母或者数字或者下划线(即单词字符)，相当于**[a-zA-Z_0-9]** 例如：匹配规则为**”\\w “**，，那么需要匹配的是一个字母或者是一个数字或一个下滑线 边界匹配器：****^ 含义：代表的是行的开头 例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号 边界匹配器：$ 含义：代表的是行的结尾 例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号 边界匹配器：****\\b 含义：代表的是单词边界 例如：匹配规则为**”\\b[abc]\\b”** ，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9]) 数量词：****X? 含义：代表的是X出现一次或一次也没有 例如：匹配规则为**”a?”**，那么需要匹配的内容是一个字符a，或者一个a都没有 数量词：****X* 含义：代表的是X出现零次或多次 例如：匹配规则为**”a*“** ，那么需要匹配的内容是多个字符a，或者一个a都没有 数量词：****X+ 含义：代表的是X出现一次或多次 例如：匹配规则为**”a+”**，那么需要匹配的内容是多个字符a，或者一个a 数量词：****X{n} 含义：代表的是X出现恰好 n 次 例如：匹配规则为**”a{5}”**，那么需要匹配的内容是5个字符a 数量词：****X{n,} 含义：代表的是X出现至少 n 次 例如：匹配规则为**”a{5, }”**，那么需要匹配的内容是最少有5个字符a 数量词：****X{n,m} 含义：代表的是X出现至少 n 次，但是不超过 m 次 例如：匹配规则为**”a{5,8}”**，那么需要匹配的内容是有5个字符a 到 8个字符a之间 1.3 正则表达式规则匹配练习 请写出满足如下匹配规则的字符串: 规则：”[0-9]{6,12}” 该规则需要匹配的内容是：长度为****6位到12位的数字。 如：使用数据”123456789”进行匹配结果为true； 使用数据”12345”进行匹配结果为false。 规则：”1[34578][0-9]{9}” 该规则需要匹配的内容是：11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。 如：使用数据”12345678901”进行匹配结果为false； 使用数据”13312345678”进行匹配结果为true。 规则：”a*b” 该规则需要匹配的内容是：在多个a或零个a后面有个b；b必须为最后一个字符。 如：使用数据”aaaaab”进行匹配结果为true； 使用数据”abc”进行匹配结果为false。 1.4 字符串类中涉及正则表达式的常用方法 public boolean matches(String regex) &#x2F;&#x2F;判断字符串是否匹配给定的规则 举例：校验qq号码. 举例：校验qq号码. 1: 要求必须是5-15位数字 2: 0不能开头 代码演示： String qq &#x3D; “604154942”; String regex &#x3D; “[1-9][0-9]{4,14}”; boolean flag2 &#x3D; qq.matches(regex); 举例：校验手机号码 1：要求为11位数字 2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。 代码演示： String phone &#x3D; “18800022116”; String regex &#x3D; “1[34578][0-9]{9}”; boolean flag &#x3D; phone.matches(regex); public String[] split(String regex) &#x2F;&#x2F;根据给定正则表达式的匹配规则，拆分此字符串 举例：分割出字符串中的的数字 代码演示： String s &#x3D; “18-22-40-65”; String regex &#x3D; “-“; String[] result &#x3D; s.split(regex); 代码演示： String s &#x3D; “18 22 40 65”; String regex &#x3D; “ “; String[] result &#x3D; s.split(regex); public String replaceAll(String regex,String replacement) &#x2F;&#x2F;将符合规则的字符串内容，全部替换为新字符串 举例：把文字中的数字替换成* 代码演示： String s &#x3D; “Hello12345World6789012”; String regex &#x3D; “[0-9]”; String result &#x3D; s.replaceAll(regex, “*”); 1.5 正则表达式练习 匹配正确的数字 匹配规则： 匹配正整数：”\\d+” 匹配正小数：”\\d+\\.\\d+” 匹配负整数：”-\\d+” 匹配负小数：”-\\d+\\.\\d+” 匹配保留两位小数的正数：”\\d+\\.\\d{2}” 匹配保留1-3位小数的正数：”\\d+\\.\\d{1,3}” 匹配合法的邮箱 匹配规则： ”[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\\.[a-zA-Z_0-9]+)+” ”\\w+@\\w+(\\.\\w+)+” 获取IP地址(192.168.1.100)中的每段数字 匹配规则： ”\\.”","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/JAVA多线程之间的通信/","text":"多线程之间的通信线程通信概念：线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体，线程间的通信就成为整体的必用方式之一。当线程存在通信指挥，系统间的交互性会更强大，在提高CPU利用率的同时还会使开发人员对线程任务在处理过程中进行有效的把控与监督。 使用wait&#x2F;notify 方法实现线程间的通信。（注意这两个方法都是Object类的方法，换句话说Java为所有的对象都提供了这两个方法） wait 和 notify 必须配合synchronized 关键字使用。 wait 方法释放锁，notify 方法不释放锁 使用轮询的方式通信publicstaticvoidmain(String[] args){finalListAddTest1 list &#x3D;newListAddTest1(); Thread thread_1 &#x3D;newThread(newRunnable() {@Overridepublicvoidrun(){for(inti &#x3D;0; i &lt;10; i++) {try{ list.add(); System.out.println(“当前线程：”+ Thread.currentThread().getName() +” 添加一个元素！”); Thread.sleep(500); }catch(InterruptedException e) { e.printStackTrace(); } } } },”Thread-1”); Thread thread_2 &#x3D;newThread(newRunnable() {@Overridepublicvoidrun(){while(true) {if(list.size() &#x3D;&#x3D;5) { System.out.println(“当前线程收到通知：”+ Thread.currentThread().getName() +” list size &#x3D; 5 线程停止..”);thrownewRuntimeException(); } } } },”Thread-2”); thread_1.start(); thread_2.start();} 使用notify 和 wait 方法通信 如上述的代码，thread-2 线程一种处于一种轮询的方式，我们可以修改Java中多线程通信的方式来改造， 使用notify 和 wait. 注意必须配合 synchronized 关键字来使用，否则会报 java.lang.IllegalMonitorStateException 非法监控异常 必须先启动 wait 方法的线程，因为notify 方法不会释放锁，先启动notify 方法的线程，执行到 notify 方法的时候，并没有线程在 wait. publicstaticvoidmain(String[] args){finalListAddUseNotifyAndWait list &#x3D;newListAddUseNotifyAndWait();finalObject lock &#x3D;newObject(); Thread thread_1 &#x3D;newThread(newRunnable() {@Overridepublicvoidrun(){&#x2F;&#x2F; synchronized (lock) {try{for(inti &#x3D;0; i &lt;10; i++) { list.add(); System.out.println(“当前线程：”+ Thread.currentThread().getName() +” 添加一个元素！”); Thread.sleep(500);if(list.size() &#x3D;&#x3D;5) { System.out.println(“已经发出通知！”); lock.notify();&#x2F;&#x2F; notify 方法不会释放锁} } }catch(InterruptedException e) { e.printStackTrace(); }&#x2F;&#x2F; }} },”Thread-1”); Thread thread_2 &#x3D;newThread(newRunnable() {@Overridepublicvoidrun(){try{&#x2F;&#x2F; synchronized (lock) {if(list.size() !&#x3D;5) { System.out.println(“Thread-2进入…”); lock.wait();&#x2F;&#x2F; wait 方法会释放锁} System.out.println(“当前线程收到通知：”+ Thread.currentThread().getName() +” list size &#x3D; 5 线程停止..”);thrownewRuntimeException();&#x2F;&#x2F; }}catch(InterruptedException e) { e.printStackTrace(); } } },”Thread-2”);&#x2F;&#x2F; 需要先启动 thread_2 , 因为如果先启动 thread_1， 那么 notify 方法不会释放锁，&#x2F;&#x2F; t1线程完全执行完才会释放锁, 当t1到notify 方法的时候，并没有 其他线程在 waitthread_2.start(); thread_1.start();} 使用CountDownLatch 闭锁来进行通信 在使用notify 和 wait 来进行通信的时候还有一个问题，在程序中我们必须等 thread-1 执行完成，才会释放锁来通知 thread-2，这会造成不实时的问题。如果需要程序在 list.size 为5 的时候，就立马执行 thread-2 中的线程的话，我们就可以使用 CountDownLatch 的方式来进行通信 finalCountDownLatch countDownLatch &#x3D;newCountDownLatch(1);Thread thread_1 &#x3D;newThread(newRunnable() {@Overridepublicvoidrun(){try{for(inti &#x3D;0; i &lt;10; i++) { list.add(); System.out.println(“当前线程：”+ Thread.currentThread().getName() +” 添加一个元素！”); Thread.sleep(500);if(list.size() &#x3D;&#x3D;5) { System.out.println(“已经发出通知！”); countDownLatch.countDown(); } } }catch(InterruptedException e) { e.printStackTrace(); } }},”Thread-1”);Thread thread_2 &#x3D;newThread(newRunnable() {@Overridepublicvoidrun(){try{if(list.size() !&#x3D;5) { System.out.println(“Thread-2进入…”); countDownLatch.await(); } System.out.println(“当前线程收到通知：”+ Thread.currentThread().getName() +” list size &#x3D; 5 线程停止..”);thrownewRuntimeException(); }catch(InterruptedException e) { e.printStackTrace(); } }},”Thread-2”);thread_1.start();thread_2.start();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/JSON数据解析/","text":"###1.Json概念以及与XML的比较 Json是什么？ 答：JavaScript Object Natation, 一种轻量级的数据交换格式, 与XML一样, 广泛被采用的客户端和服务端交互的解决方案！具有良好的可读和便于快速编写的特性。 Json与XML的比较： JSON和XML的数据可读性基本相同; JSON和XML同样拥有丰富的解析手段 JSON相对于XML来讲，数据的体积小 JSON与JavaScript的交互更加方便 JSON对数据的描述性比XML较差 JSON的速度要远远快于XML PS:上述来自于百度~简单点说Json的优点：体积小，节省流量，只是不如XML直观，可读性 稍微差一点而已！ Json的格式规范： 就像协议一样，肯定是有一套规范的，毕竟双方都是通过Json字符串来传递数据，语法规则如下： 数据在名称&#x2F;值对中；数据由逗号分隔；花括号保存对象；方括号保存数组； 而Json数据的书写格式：名称&#x2F;值对 比如： “person”：”coder-pig” 比如一个简单的Json字符串: 12345[ &#123; &quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;基神&quot;,&quot;age&quot;:&quot;18&quot; &#125;, &#123; &quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;B神&quot;,&quot;age&quot;:&quot;18&quot; &#125;, &#123; &quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;曹神&quot;,&quot;age&quot;:&quot;18&quot; &#125;] ###2.Android给我们提供的Json解析类##这些API都存在于org.json包下，而我们用到的类有下面这些： JSONObject： Json对象，可以完成Json字符串与Java对象的相互转换 JSONArray： Json数组，可以完成Json字符串与Java集合或对象的相互转换 JSONStringer： Json文本构建类，这个类可以帮助快速和便捷的创建JSON text， 每个JSONStringer实体只能对应创建一个JSON text JSONTokener：Json解析类 JSONException：Json异常 ###3.代码示例：解析Json字符串： 简单的Json字符串解析示例： 我们解析的是上面这个简单的Json，首先我们来写一个POJO类： Person.java：123456789101112131415161718192021222324252627public class Person &#123; private String id; private String name; private String age; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return this.id; &#125; public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; public void setAge(String age)&#123; this.age = age; &#125; public String getAge()&#123; return this.age; &#125; @Override public String toString() &#123; return this.name + &quot;~年方：&quot; + this.age; &#125;&#125; 写一个解析上述Json字符串的方法：1234567891011121314private void parseEasyJson(String json)&#123; persons = new ArrayList&lt;Person&gt;(); try&#123; JSONArray jsonArray = new JSONArray(json); for(int i = 0;i &lt; jsonArray.length();i++)&#123; JSONObject jsonObject = (JSONObject) jsonArray.get(i); Person person = new Person(); person.setId(i+&quot;&quot;); person.setName(jsonObject.getString(&quot;name&quot;)); person.setAge(jsonObject.getString(&quot;age&quot;)); persons.add(person); &#125; &#125;catch (Exception e)&#123;e.printStackTrace();&#125;&#125; ##运行效果图：2. 复杂的Json字符串解析示例：如果是这样的Json字符串呢？ 解析代码如下： 1234567891011121314151617181920private void parseDiffJson(String json) &#123; try &#123; JSONObject jsonObject1 = new JSONObject(json); Log.e(&quot;Json&quot;, json); JSONArray jsonArray = jsonObject1.getJSONArray(&quot;ch&quot;); for (int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject = (JSONObject) jsonArray.get(i); //取出name String sname = jsonObject.getString(&quot;names&quot;); JSONArray jarray1 = jsonObject.getJSONArray(&quot;data&quot;); JSONArray jarray2 = jsonObject.getJSONArray(&quot;times&quot;); Log.e(&quot;Json&quot;, sname); Log.e(&quot;Json&quot;, jarray1.toString()); Log.e(&quot;Json&quot;, jarray2.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 看下打印的Log:","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Sevice（服务）/","text":"特点：后台运行，不可见，没有界面； 优先级高于Activity; 用途：播放音乐，记录地理信息位置的告白，监听某种动作… 注意：运行在主线程，不能用它来做耗时的请求或者动作 可以在服务中开一个线程，在线程中作耗时操作 类型：本地服务（Local Service）： 应用程序内部： startService stopService stopSelf stopSelfResult bindService unbindService 远程服务：(Remote Service): Android系统内部的应用程序之间（同设备） 定义IBinder接口 生命周期：左边是start方式启动的生命周期，右边是bind方式启动的生命周期： Start方式特点：服务跟启动源没有任何联系； 无法得到服务对象； Bind方式特点：通过Ibinder接口实例，返回一个ServiceConnection对象给启动源 通过ServiceConnetion对象的相关方法可以得到Service对象 start方式启动： start方式销毁： 自定义Service类： bind方式启动： bind方式销毁： 自定义Service类:`&#96;&#96; public class MyBindService extends Service { @Override public void onCreate() { ​ super.onCreate(); } public IBinder onBind(Intent intent) { &#x2F;&#x2F; IBinder这里无法直接使用，需要自己重写一个类去继承Binder ​ return new MyBinder(); } public class MyBinder extends Binder{ ​ public MyBindService getService(){ ​ return MyBindService.this; ​ } } @Override public boolean onUnbind(Intent intent) { ​ return super.onUnbind(intent); } &#x2F;&#x2F;定义4个方法模拟播放器 @Override public void onDestroy() { ​ super.onDestroy(); } public void play(){ ​ Log.e(“tyl”,”播放”); } public void pause(){ ​ Log.e(“tyl”,”暂停”); } public void next(){ ​ Log.e(“tyl”,”下一首”); } public void pervious(){ ​ Log.e(“tyl”,”上一首”); } } `&#96;&#96; 注册（两种方式一样）：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/类加载器（基础）/","text":"1. 什么是类加载器 类加载器就是用来加载类的东西！类加载器也是一个类：ClassLoader 类加载器可以被加载到内存，是通过类加载器完成的！Java虚拟机中可以安装多个类加载器，系统默认三个主要类加载器，每个类负责加载特定位置的类： BootStrap：引导类加载器，加载rt.jar中的类 ExtClassLoader：扩展类加载器，加载lib&#x2F;ext目录下的类 AppClassLoader：系统类加载器，加载CLASSPATH下的类，即我们写的类，以及第三方提供的类 类加载器之间存在上下级关系，系统类加载器的上级是扩展类加载器，而扩展类加载器的上级是引导类加载器 类加载器也是Java类，因为其它java类的类加载器本身也要被类加载器加载，显然必须有第一个类加载器不是java类，这正是BootStrap。 Java虚拟机中的所有类装载器采用具有父子关系的树形结构进行组织，在实例化每个类装载器对象时，需要为其指定一个父级类装载器对象或者默认采用系统类装载器为其父级类加载 2. 类的加载 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 2.1 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 2.2 连接 验证：是否有正确的内部结构，并和其他类协调一致 准备：负责为类的静态成员分配内存，并设置默认初始化值 解析：将类的二进制数据中的符号引用替换为直接引用 2.3 初始化 类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值。在Java代码中，一个正确的初始值是通过类变量初始化语句或者静态初始化块给出的。 初始化一个类包括两个步骤： 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类 如果类存在一个初始化方法，就执行此方法 注：初始化接口并不需要初始化它的父接口。 3. 类初始化时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 4. 类加载器 负责将.class文件加载到内在中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 4.1 类加载器的组成 BootstrapClassLoader 根类加载器 ExtensionClassLoader 扩展类加载器 SysetmClassLoader 系统类加载器 4.2类加载器的作用 1、Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载，比如System，String等。在JDK中JRE的lib目录下rt.jar文件中。 2、Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录 3、Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。通过这些描述我们就可以知道我们常用的东西的加载都是由谁来完成的。到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?这就是我们反射要研究的内容。 5. JVM眼中的相同的类 在JVM中，不可能存在一个类被加载两次的事情！一个类如果已经被加载了，当再次试图加载这个类时，类加载器会先去查找这个类是否已经被加载过了，如果已经被加载过了，就不会再去加载了。 但是，如果一个类使用不同的类加载器去加载是可以出现多次加载的情况的！也就是说，在JVM眼中，相同的类需要有相同的class文件，以及相同的类加载器。当一个class文件，被不同的类加载器加载了，JVM会认识这是两个不同的类，这会在JVM中出现两个相同的Class对象！甚至会出现类型转换异常！ 6. 类加载器的委托机制 首先委托类加载器的父类去加载，如果父类无法加载则自己加载 当系统类加载器去加载一个类时，它首先会让上级去加载，即让扩展类加载器去加载类，扩展类加载器也会让它的上级引导类加载器去加载类。如果上级没有加载成功，那么再由自己去加载！ 例如我们自己写的Person类，一定是存放到CLASSPATH中，那么一定是由系统类加载器来加载。当系统类加载器来加载类时，它首先把加载的任务交给扩展类加载去，如果扩展类加载器加载成功了，那么系统类加载器就不会再去加载。这就是代理模式了！ 相同的道理，扩展类加载器也会把加载类的任务交给它的“上级”，即引导类加载器，引导类加载器加载成功，那么扩展类加载器也就不会再去加载了。引导类加载器是用C语言写的，是JVM的一部分，它是最上层的类加载器了，所以它就没有“上级了”。它只负责去加载“内部人”，即JDK中的类，但我们知道Person类不是我们自己写的类，所以它加载失败。 当扩展类加载器发现“上级”不能加载类，它就开始加载工作了，它加载的是lib\\ext目录下的jar文件，当然，它也会加载失败，所以最终还是由系统类加载器在CLASSPATH中去加载Person，最终由系统类加载器加载到了Person类。 代理模式保证了JDK中的类一定是由引导类加载加载的！这就不会出现多个版本的类，这也是代理模式的好处。 6.1 类加载器之间的父子关系和管辖范围图 类加载器 7. 自定义类加载器 我们也可以通过继承ClassLoader类来完成自定义类加载器，自定义类加载器的目的一般是为了加载网络上的类，因为这会让class在网络中传输，为了安全，那么class一定是需要加密的，所以需要自定义的类加载器来加载（自定义的类加载器需要做解密工作）。 ClassLoader加载类都是通过loadClass()方法来完成的，loadClass()方法的工作流程如下： 调用findLoadedClass()方法查看该类是否已经被加载过了，如果该没有加载过，那么这个方法返回null 判断findLoadedClass()方法返回的是否为null，如果不是null那么直接返回，这可以避免同一个类被加载两次 如果findLoadedClass()返回的是null，那么就启动代理模式（委托机制），即调用上级的loadClass()方法，获取上级的方法是getParent()，当然上级可能还有上级，这个动作就一直向上走 如果getParent().loadClass()返回的不是null，这说明上级加载成功了，那么就加载结果 如果上级返回的是null，这说明需要自己出手了，这时loadClass()方法会调用本类的findClass()方法来加载类 这说明我们只需要重写ClassLoader的findClass()方法，这就可以了！如果重写了loadClass()方法覆盖了代理模式！ OK，通过上面的分析，我们知道要自定义一个类加载器，只需要继承ClassLoader类，然后重写它的findClass()方法即可。那么在findClass()方法中我们要完成哪些工作呢？ 找到class文件，把它加载到一个byte[]中； 调用defineClass()方法，把byte[]传递给这个方法即可。 loadClass()方法的实现代码 protectedClass loadClass(String className,booleanresolve)throwsClassNotFoundException { Class clazz &#x3D; findLoadedClass(className);if(clazz &#x3D;&#x3D;null) { ClassNotFoundException suppressed &#x3D;null;try{ clazz &#x3D; parent.loadClass(className,false); }catch(ClassNotFoundException e) { suppressed &#x3D; e; }if(clazz &#x3D;&#x3D;null) {try{ clazz &#x3D; findClass(className); }catch(ClassNotFoundException e) { e.addSuppressed(suppressed);throwe; } } }returnclazz;} 自定义类加载器FileSystemClassLoader publicclassFileSystemClassLoaderextendsClassLoader{privateString classpath;publicFileSystemClassLoader(){}publicFileSystemClassLoader(String classpath){this.classpath &#x3D; classpath; }@OverridepublicClass findClass(String name)throwsClassNotFoundException {try{byte[] datas &#x3D; getClassData(name);if(datas &#x3D;&#x3D;null) {thrownewClassNotFoundException(“类没有找到：”+ name); }returnthis.defineClass(name, datas,0, datas.length); }catch(IOException e) { e.printStackTrace();thrownewClassNotFoundException(“类找不到：”+ name); } }privatebyte[] getClassData(String name)throwsIOException { name &#x3D; name.replace(“.”,”\\“) +”.class”; File classFile &#x3D;newFile(classpath, name);returnFileUtils.readFileToByteArray(classFile); }} ClassLoader loader &#x3D;newFileSystemClassLoader(“F:\\classpath”);Class clazz &#x3D; loader.loadClass(“cn.itcast.utils.CommonUtils”);Method method &#x3D; clazz.getMethod(“md5”, String.class);String result &#x3D; (String) method.invoke(null,”qdmmy6”);System.out.println(result); 8. ClassLoader 方法说明 getParent()获取上级类加载器 loadClass()实现了类加载的加载流程，也就是算法框架 findLoadedClass()查看该类是否被加载过 findClass()真正去加载类，自定义类加载器需要重写的方法 defineClass()把Class的字节数组byte[]转成Class","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/JAVA集合/","text":"集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet等,除此之外你也可以通过这些接口实现自己的集合。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个Map接口和类。Map里存储的是键&#x2F;值对。尽管Map不是collections，但是它们完全整合在集合中。 集合框架体系如图所示 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。 集合接口 集合框架定义了一些接口。本节提供了每个接口的概述： 序号接口描述 1Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。 2List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。 3Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。 4SortedSet 继承于Set保存有序的集合。 5Map 将唯一的键映射到值。 6Map.Entry 描述在一个Map中的一个元素（键&#x2F;值对）。是一个Map的内部类。 7SortedMap 继承于Map，使Key保持在升序排列。 8Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 Set和List的区别 \\1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 \\2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。 \\3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 集合实现类（集合类） Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。 标准集合类汇总于下表： 序号类描述 1AbstractCollection 实现了大部分的集合接口。 2AbstractList 继承于AbstractCollection 并且实现了大部分List接口。 3AbstractSequentialList 继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。 4LinkedList 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如： Listlist&#x3D;Collections.synchronizedList(newLinkedList(…)); LinkedList 查找效率低。 5ArrayList 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。 6AbstractSet 继承于AbstractCollection 并且实现了大部分Set接口。 7HashSet 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。 8LinkedHashSet 具有可预知迭代顺序的Set接口的哈希表和链接列表实现。 9TreeSet 该类实现了Set接口，可以实现排序等功能。 10AbstractMap 实现了大部分的Map接口。 11HashMap HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 12TreeMap 继承了AbstractMap，并且使用一颗树。 13WeakHashMap 继承AbstractMap类，使用弱密钥的哈希表。 14LinkedHashMap 继承于HashMap，使用元素的自然顺序对元素进行排序. 15IdentityHashMap 继承AbstractMap类，比较文档时使用引用相等。 在前面的教程中已经讨论通过java.util包中定义的类，如下所示： 序号类描述 1Vector 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。 2Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。 3Dictionary Dictionary 类是一个抽象类，用来存储键&#x2F;值对，作用和Map类相似。 4Hashtable Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。 5Properties Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。 6BitSet 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。 集合算法 集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。 在尝试比较不兼容的类型时，一些方法能够抛出 ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。 集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变。 序号算法描述 1Collection Algorithms 这里是一个列表中的所有算法实现。 如何使用迭代器 通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。 一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。 迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。 序号迭代器方法描述 1使用 Java Iterator 这里通过实例列出Iterator和listIterator接口提供的所有方法。 遍历 ArrayList 实例 import java.util.*; public class Test{ public static void main(String[] args) { List list&#x3D;new ArrayList(); list.add(“Hello”); list.add(“World”); list.add(“HAHAHAHA”); &#x2F;&#x2F;第一种遍历方法使用foreach遍历List for (String str : list) { &#x2F;&#x2F;也可以改写for(int i&#x3D;0;i } &#x2F;&#x2F;第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray&#x3D;new String[list.size()]; list.toArray(strArray); for(int i&#x3D;0;i } &#x2F;&#x2F;第三种遍历 使用迭代器进行相关遍历 Iterator ite&#x3D;list.iterator(); while(ite.hasNext())&#x2F;&#x2F;判断下一个元素之后有值 { System.out.println(ite.next()); } }} 解析： 三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。 遍历 Map 实例 import java.util.*; public class Test{ public static void main(String[] args) { Map map &#x3D; new HashMap(); map.put(“1”, “value1”); map.put(“2”, “value2”); map.put(“3”, “value3”); &#x2F;&#x2F;第一种：普遍使用，二次取值 System.out.println(“通过Map.keySet遍历key和value：”); for (String key : map.keySet()) { System.out.println(“key&#x3D; “+ key + “ and value&#x3D; “ + map.get(key)); } &#x2F;&#x2F;第二种 System.out.println(“通过Map.entrySet使用iterator遍历key和value：”); Iterator&gt; it &#x3D; map.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry &#x3D; it.next(); System.out.println(“key&#x3D; “ + entry.getKey() + “ and value&#x3D; “ + entry.getValue()); } &#x2F;&#x2F;第三种：推荐，尤其是容量大时 System.out.println(“通过Map.entrySet遍历key和value”); for (Map.Entry entry : map.entrySet()) { System.out.println(“key&#x3D; “ + entry.getKey() + “ and value&#x3D; “ + entry.getValue()); } &#x2F;&#x2F;第四种 System.out.println(“通过Map.values()遍历所有的value，但不能遍历key”); for (String v : map.values()) { System.out.println(“value&#x3D; “ + v); } }} 如何使用比较器 TreeSet和TreeMap的按照排序顺序来存储元素. 然而，这是通过比较器来精确定义按照什么样的排序顺序。 这个接口可以让我们以不同的方式来排序一个集合。 序号比较器方法描述 1使用 Java Comparator 这里通过实例列出Comparator接口提供的所有方法 总结 Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/android-计时器（Handle+Runable-可重置时间可暂停）/","text":"12345678910111213141516171819 // mhandle.postDelayed(timeRunable , 1000);调用 切勿重复调用 //currentSecond =0；重置时间/*****************计时器*******************/private Runnable timeRunable = new Runnable() &#123; @Override public void run() &#123; currentSecond = currentSecond + 1000; timerText.setText(TimeUtil.getFormatHMS(currentSecond)); if (!isPause) &#123; //递归调用本runable对象，实现每隔一秒一次执行任务 mhandle.postDelayed(this, 1000); &#125; &#125;&#125;;//计时器private Handler mhandle = new Handler();private boolean isPause = false;//是否暂停private long currentSecond = 0;//当前毫秒数","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/Notifaction/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.mbenben.newstudy; import android.app.Activity; import android.app.Notification; import android.app.NotificationManager; import android.app.PendingIntent; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.support.v4.app.NotificationCompat; import android.view.View;public class MainActivityextends Activity &#123; private NotificationManagernotificationManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.click).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showNotifaction(); &#125; &#125;); findViewById(R.id.cancel).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; cancelNotifacation(); &#125; &#125;); &#125; private void showNotifaction()&#123; NotificationCompat.Builder builder =new NotificationCompat.Builder(this); builder.setTicker(&quot;通知栏提示&quot;); builder.setSmallIcon(R.mipmap.ic_launcher);//设置通知 栏小图标 builder.setContentTitle(&quot;通知栏标题&quot;);//标题 builder.setContentText(&quot;通知栏内容&quot;);//内容 builder.setWhen(System.currentTimeMillis());//设置时间 这里设置的系统默认时间// 设置以下三个需要对应权限// builder.setDefaults(Notification.DEFAULT_SOUND);//设置提示音// builder.setDefaults(Notification.DEFAULT_LIGHTS);//设置指示灯// builder.setDefaults(Notification.DEFAULT_VIBRATE);//设置震动 builder.setDefaults(Notification.DEFAULT_ALL);//提示音，指示灯，震动同样需要3种对应权限// 设置通知点击事件PendingIntent Intent intent =new Intent();// PendingIntent.getActivity(上下文对象, 请求码, intent, 0)// 第一个参数连接上下文的context// 第二个参数是对PendingIntent的描述，请求值不同Intent就不同// 第三个参数是一个Intent对象，包含跳转目标// 第四个参数有4种状态// FLAG_CANCEL_CURRENT:如果当前系统中已经存在一个相同的PendingIntent对象，那么就将先将已有的PendingIntent取消，然后重新生成一个PendingIntent对象。// FLAG_NO_CREATE:如果当前系统中不存在相同的PendingIntent对象，系统将不会创建该PendingIntent对象而是直接返回null。// FLAG_ONE_SHOT:该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。// FLAG_UPDATE_CURRENT:如果系统中有一个和你描述的PendingIntent对等的PendingInent，那么系统将使用该PendingIntent对象，但是会使用新的Intent来更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras。 PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT); builder.setContentIntent(pendingIntent); Notification build = builder.build();//4.1以上// 拿到通知控制类 notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// 发送通知 notificationManager.notify(自定义一个ID，Notification); notificationManager.notify(1,build); &#125; private void cancelNotifacation()&#123;// 停止通知 通知的ID notificationManager.cancel(1); &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android工具类/android-多语言切换/","text":"#####添加多语言资源文件######第一步：######第二步：######第三步：######第四步：######第五步：以上步骤仅仅是添加values-zh-rCN文件夹，并没有strings.xml文件，将系统默认的strings.xml文件复制进去再修改里面的内容为对应语言的文字内容即可！#####多国语言的value文件夹命名方式 区域 文件名 中文（中國）（简体） values-zh-rCN 中文（台灣）（繁体） values-zh-rTW 中文（香港） values-zh-rHK 英語（美國） values-en-rUS 英語（英國） values-en-rGB 英文（澳大利亞） values-en-rAU 英文（加拿大） values-en-rCA 英文（愛爾蘭） values-en-rIE 英文（印度） values-en-rIN 英文（新西蘭） values-en-rNZ 英文（新加坡） values-en-rSG 英文（南非） values-en-rZA 阿拉伯文（埃及） values-ar-rEG 阿拉伯文（以色列） values-ar-rIL 保加利亞文 values-bg-rBG 加泰羅尼亞文 values-ca-rES 捷克文 values-cs-rCZ 丹麥文 values-da-rDK 德文（奧地利） values-de-rAT 德文（瑞士） values-de-rCH 德文（德國） values-de-rDE 德文（列支敦士登） values-de-rLI 希臘文 values-el-rGR 西班牙文（西班牙） values-es-rES 西班牙文（美國） values-es-rUS 芬蘭文（芬蘭） values-fi-rFI 法文（比利時） values-fr-rBE 法文（加拿大） values-fr-rCA 法文（瑞士） values-fr-rCH 法文（法國） values-fr-rFR 希伯來文 values-iw-rIL 印地文 values-hi-rIN 克羅里亞文 values-hr-rHR 匈牙利文 values-hu-rHU 印度尼西亞文 values-in-rID 意大利文（瑞士） values-it-rCH 意大利文（意大利） values-it-rIT 日文 values-ja-rJP 韓文 values-ko-rKR 立陶宛文 valueslt-rLT 拉脫維亞文 values-lv-rLV 挪威博克馬爾文 values-nb-rNO 荷蘭文(比利時) values-nl-BE 荷蘭文（荷蘭） values-nl-rNL 波蘭文 values-pl-rPL 葡萄牙文（巴西） values-pt-rBR 葡萄牙文（葡萄牙） values-pt-rPT 羅馬尼亞文 values-ro-rRO 俄文 values-ru-rRU 斯洛伐克文 values-sk-rSK 斯洛文尼亞文 values-sl-rSI 塞爾維亞文 values-sr-rRS 瑞典文 values-sv-rSE 泰文 values-th-rTH 塔加洛語 values-tl-rPH 土耳其文 values–r-rTR 烏克蘭文 values-uk-rUA 越南文 values-vi-rVN 要使用多语言，首先肯定要有为不同语言准备的资源。 只需要按照Android提供的规范，对不同语言下的资源文件夹进行对应的命名即可。 比如我们知道&#x2F;valus是Android的默认简单资源（字符串、数值、颜色等）的文件夹，那么对不同语言下提供的values文件夹命名方式就形如： &#x2F;values-zh &#x2F;values-zh-rCN &#x2F;values-zh-rTW其中values保持不变；后缀的zh表示语言；后缀的rCN、rTW其中‘r’是一个标记，表示后面跟着的CN、TW是国家或地区标志。所以以上三个资源文件夹表示所对应的语言环境分别为：中文中文-中国 （即中文简体）中文-台湾 （即中文繁体）默认情况下，Android会根据系统的语言地区设置，自动选择对应的资源。会首先尝试语言地区全匹配，如果没有权匹配的资源包，则会尝试匹配语言，最后则会取默认的。比如如果Android系统的语言地区是中文简体，则首先会尝试从&#x2F;values-zh-rCN中获取资源，如果没有此文件夹或者文件夹中没有响应的资源，则会尝试&#x2F;values-zh，都获取不到的情况下即从&#x2F;values中获取。（&#x2F;values是必须存在的，否则不能通过编译）当然，也可以在代码中手动进行控制，指定所选择的语言：Configuration config &#x3D; getResources().getConfiguration();&#x2F;&#x2F;获取系统的配置12config.locale = Locale.TRADITIONAL_CHINESE;//将语言更改为繁体中文 getResources().updateConfiguration(config, getResources().getDisplayMetrics());//更新配置 #####切换语言切换语言后需重启当前activity，给用户的感知不好，我实现的逻辑都是记录用户想要切换的语言，然后提示用户重启APP生效，再在启动的第一个activity进行语言切换功能实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243//详细代码：public class StartActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Object o = SerializeUtils.readServiceListFromFile(Constants.APP_INFO); if (o!=null)&#123; AppInfoBean appInfo= (AppInfoBean) o; int app_language = appInfo.getAPP_Language(); MyApplication.getInstance().appLanguage=app_language; if (app_language==0)&#123;//简体中文 setLanguage(Locale.SIMPLIFIED_CHINESE); &#125;else if (app_language==1)&#123;//繁体中文 setLanguage(Locale.TRADITIONAL_CHINESE); &#125;else if (app_language==2)&#123;//英文 setLanguage(Locale.ENGLISH); &#125; &#125; startActivity(new Intent(this,SplashActivity.class)); finish(); &#125; private void setLanguage(Locale locale)&#123;// Locale.setDefault(locale); //设置语言类型 Resources resources = getResources(); Configuration configuration = resources.getConfiguration(); // 应用用户选择语言 if(Build.VERSION.SDK_INT&gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; configuration.setLocale(locale); &#125;else&#123; configuration.locale = locale; &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; configuration.setLocales(new LocaleList(locale)); createConfigurationContext(configuration); &#125;else&#123; resources.updateConfiguration(configuration, resources.getDisplayMetrics()); &#125; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android基础/JAV线程池/","text":"为什么要使用线程池呢？我们知道线程的创建和销毁是非常耗费资源的，有时候创建线程消耗的资源比执行任务所要耗费的资源都要大，为了防止资源不足，程序需要一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务，这就是Java线程池产生的原因，也是它要解决的问题。 下面来讲解Java线程池 Java通过Executors提供了四类线程池： newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待，如果线程池中的某个线程由于异常而结束，线程池则会再补充一条新线程。 For example: &#x2F;&#x2F;创建线程数为5的线程池varmyPool&#x3D;Executors.newFixedThreadPool(5)for(iin0until10){ myPool.execute(Runnable { Thread.sleep(500) println(“&lt;&lt;&lt;&lt; Log: image.png 结论：任务在1-5个线程执行 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 延迟2秒后执行线程 varmyPool&#x3D;Executors.newScheduledThreadPool(5) myPool.schedule(Runnable { println(“&lt;&lt;&lt;&lt; 延迟1秒后执行线程，之后美俩秒执行一次 varmyPool&#x3D;Executors.newScheduledThreadPool(5) myPool.scheduleAtFixedRate(Runnable { println(“&lt;&lt;&lt;&lt; Log： image.png newSingleThreadExecutor：创建一个单线程的线程池，即这个线程池永远只有一个线程在运行，这样能保证所有任务按指定顺序来执行。如果这个线程异常结束，那么会有一个新的线程来替代它。 varmyPool&#x3D;Executors.newSingleThreadExecutor()for(iin0until10){ myPool.execute(Runnable { Thread.sleep(500) println(“&lt;&lt;&lt;&lt; Log: newCachedThreadPool:创建一个可缓存线程池，当线程池中有之前创建的可用线程就重用之前的线程，否则就新建一条线程，。如果线程池中的线程在60秒未被使用，就会把它从线程池中移除，可灵活回收空闲线程。 varmyPool&#x3D;Executors.newCachedThreadPool()for(iin0until10){ myPool.execute(Runnable { Thread.sleep(500) println(“&lt;&lt;&lt;&lt; Log:","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android基础/TCP协议（Socket）/","text":"StringBuffer、StringBuilder和String一样，也用来代表字符串。String类是不可变类，任何对String的改变都 会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。既然可变和不可变都有了，为何还有一个StringBuilder呢？相信初期的你，在进行append时，一般都会选择StringBuffer吧！ 先说一下集合的故事，HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 接下来，我直接贴上测试过程和结果的代码，一目了然： [java] view plain copy public class StringTest { public static String BASEINFO &#x3D; “Mr.Y”; public static final int COUNT &#x3D; 2000000; &#x2F;** * 执行一项String赋值测试 *&#x2F; public static void doStringTest() { String str &#x3D;new String(BASEINFO); long starttime &#x3D; System.currentTimeMillis(); for (int i &#x3D; 0; i &lt; COUNT &#x2F; 100; i++) { str &#x3D; str +”miss”; ​ } long endtime &#x3D; System.currentTimeMillis(); ​ System.out.println((endtime - starttime) +” millis has costed when used String.”); } &#x2F;** * 执行一项StringBuffer赋值测试 *&#x2F; public static void doStringBufferTest() { StringBuffer sb &#x3D;new StringBuffer(BASEINFO); long starttime &#x3D; System.currentTimeMillis(); for (int i &#x3D; 0; i &lt; COUNT; i++) { sb &#x3D; sb.append(“miss”); ​ } long endtime &#x3D; System.currentTimeMillis(); ​ System.out.println((endtime - starttime) +” millis has costed when used StringBuffer.”); } &#x2F;** * 执行一项StringBuilder赋值测试 *&#x2F; public static void doStringBuilderTest() { StringBuilder sb &#x3D;new StringBuilder(BASEINFO); long starttime &#x3D; System.currentTimeMillis(); for (int i &#x3D; 0; i &lt; COUNT; i++) { sb &#x3D; sb.append(“miss”); ​ } long endtime &#x3D; System.currentTimeMillis(); ​ System.out.println((endtime - starttime) +” millis has costed when used StringBuilder.”); } &#x2F;** * 测试StringBuffer遍历赋值结果 * * @param mlist *&#x2F; public static void doStringBufferListTest(List mlist) { StringBuffer sb &#x3D;new StringBuffer(); long starttime &#x3D; System.currentTimeMillis(); for (String string : mlist) { ​ sb.append(string); ​ } long endtime &#x3D; System.currentTimeMillis(); System.out.println(sb.toString() +”buffer cost:” + (endtime - starttime) +” millis”); } &#x2F;** * 测试StringBuilder迭代赋值结果 * * @param mlist *&#x2F; public static void doStringBuilderListTest(List mlist) { StringBuilder sb &#x3D;new StringBuilder(); long starttime &#x3D; System.currentTimeMillis(); for (Iterator iterator &#x3D; mlist.iterator(); iterator.hasNext();) { ​ sb.append(iterator.next()); ​ } long endtime &#x3D; System.currentTimeMillis(); System.out.println(sb.toString() +”builder cost:” + (endtime - starttime) +” millis”); } public static void main(String[] args) { ​ doStringTest(); ​ doStringBufferTest(); ​ doStringBuilderTest(); List list &#x3D;new ArrayList(); list.add(“ I “); list.add(“ like “); list.add(“ BeiJing “); list.add(“ tian “); list.add(“ an “); list.add(“ men “); list.add(“ . “); ​ doStringBufferListTest(list); ​ doStringBuilderListTest(list); } } 看一下执行结果： 2711 millis has costed when used String. 211 millis has costed when used StringBuffer. 141 millis has costed when used StringBuilder. I like BeiJing tian an men . buffer cost:1 millis I like BeiJing tian an men . builder cost:0 millis 从上面的结果可以看出，不考虑多线程，采用String对象时（我把Count&#x2F;100），执行时间比其他两个都要高，而采用StringBuffer对象和采用StringBuilder对象的差别也比较明显。由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。 从后面List的测试结果可以看出，除了对多线程的支持不一样外，这两个类的使用方式和结果几乎没有任何差别","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"}]},{"path":"wiki/Android Application/Android工具类/Android-pcm转码wav/","text":"百度语音识别后生成的语音文件为pcm文件，pcm可以使用ffmpeg进行转码，我自己尝试过使用其他工具转码均失败，其他播放软件直接播放pcm也均是失败！ffmpeg下载地址：（window64）https://ffmpeg.zeranoe.com/builds/win64/static/转换命令： 12//将pcm文件复制到bin目录，然后命令行直接输入下面命令即可转换后使用常用的音频播放软件播放ffmpeg -y -f s16le -ac 1 -ar 16000 -i &quot;outfile(2).pcm&quot; -ac 1 -ar 16000 outfile(2).wav 下面直接上android pcm转wav代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.shiyoukeji.book.activity.SpeechRecongnition;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * Created by tyl * 2019/12/5/005 * Describe:音频pcm转码wav */public class convertPcmToWav &#123; /** * PCM文件转WAV文件 * @param inPcmFilePath 输入PCM文件路径 * @param outWavFilePath 输出WAV文件路径 * @param sampleRate 采样率，例如15000 * @param channels 声道数 单声道：1或双声道：2 * @param bitNum 采样位数，8或16 */ public static void convertPcmToWav(String inPcmFilePath, String outWavFilePath, int sampleRate, int channels, int bitNum) &#123; FileInputStream in = null; FileOutputStream out = null; byte[] data = new byte[1024]; try &#123; //采样字节byte率 long byteRate = sampleRate * channels * bitNum / 8; in = new FileInputStream(inPcmFilePath); out = new FileOutputStream(outWavFilePath); //PCM文件大小 long totalAudioLen = in.getChannel().size(); //总大小，由于不包括RIFF和WAV，所以是44 - 8 = 36，在加上PCM文件大小 long totalDataLen = totalAudioLen + 36; writeWaveFileHeader(out, totalAudioLen, totalDataLen, sampleRate, channels, byteRate); int length = 0; while ((length = in.read(data)) &gt; 0) &#123; out.write(data, 0, length); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 输出WAV文件 * @param out WAV输出文件流 * @param totalAudioLen 整个音频PCM数据大小 * @param totalDataLen 整个数据大小 * @param sampleRate 采样率 * @param channels 声道数 * @param byteRate 采样字节byte率 * @throws IOException */ private static void writeWaveFileHeader(FileOutputStream out, long totalAudioLen, long totalDataLen, int sampleRate, int channels, long byteRate) throws IOException &#123; byte[] header = new byte[44]; header[0] = &#x27;R&#x27;; // RIFF header[1] = &#x27;I&#x27;; header[2] = &#x27;F&#x27;; header[3] = &#x27;F&#x27;; header[4] = (byte) (totalDataLen &amp; 0xff);//数据大小 header[5] = (byte) ((totalDataLen &gt;&gt; 8) &amp; 0xff); header[6] = (byte) ((totalDataLen &gt;&gt; 16) &amp; 0xff); header[7] = (byte) ((totalDataLen &gt;&gt; 24) &amp; 0xff); header[8] = &#x27;W&#x27;;//WAVE header[9] = &#x27;A&#x27;; header[10] = &#x27;V&#x27;; header[11] = &#x27;E&#x27;; //FMT Chunk header[12] = &#x27;f&#x27;; // &#x27;fmt &#x27; header[13] = &#x27;m&#x27;; header[14] = &#x27;t&#x27;; header[15] = &#x27; &#x27;;//过渡字节 //数据大小 header[16] = 16; // 4 bytes: size of &#x27;fmt &#x27; chunk header[17] = 0; header[18] = 0; header[19] = 0; //编码方式 10H为PCM编码格式 header[20] = 1; // format = 1 header[21] = 0; //通道数 header[22] = (byte) channels; header[23] = 0; //采样率，每个通道的播放速度 header[24] = (byte) (sampleRate &amp; 0xff); header[25] = (byte) ((sampleRate &gt;&gt; 8) &amp; 0xff); header[26] = (byte) ((sampleRate &gt;&gt; 16) &amp; 0xff); header[27] = (byte) ((sampleRate &gt;&gt; 24) &amp; 0xff); //音频数据传送速率,采样率*通道数*采样深度/8 header[28] = (byte) (byteRate &amp; 0xff); header[29] = (byte) ((byteRate &gt;&gt; 8) &amp; 0xff); header[30] = (byte) ((byteRate &gt;&gt; 16) &amp; 0xff); header[31] = (byte) ((byteRate &gt;&gt; 24) &amp; 0xff); // 确定系统一次要处理多少个这样字节的数据，确定缓冲区，通道数*采样位数 header[32] = (byte) (channels * 16 / 8); header[33] = 0; //每个样本的数据位数 header[34] = 16; header[35] = 0; //Data chunk header[36] = &#x27;d&#x27;;//data header[37] = &#x27;a&#x27;; header[38] = &#x27;t&#x27;; header[39] = &#x27;a&#x27;; header[40] = (byte) (totalAudioLen &amp; 0xff); header[41] = (byte) ((totalAudioLen &gt;&gt; 8) &amp; 0xff); header[42] = (byte) ((totalAudioLen &gt;&gt; 16) &amp; 0xff); header[43] = (byte) ((totalAudioLen &gt;&gt; 24) &amp; 0xff); out.write(header, 0, 44); &#125;&#125; 调用代码： 123String recordFilePath=&quot;/storage/emulated/0/dacheASR/outfile.pcm&quot;; String wavFilePath=&quot;/storage/emulated/0/dacheASR/outfile.wav&quot;; convertPcmToWav.convertPcmToWav(recordFilePath,wavFilePath,16000,1,16);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android-获取当前屏幕的旋转角度/","text":"获知系统当前被旋转的度数，以便在重新启动平台显示的视频，和重启前的旋转度数一致。 Activity中的orientation感知，只能知道屏幕是横屏还是竖屏，而无法知道具体的旋转角度; 1234567891011121314151617int angle = ((WindowManager)getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();switch (angle) &#123; case Surface.ROTATION_0: Log.d(TAG,&quot;Rotation_0&quot;); break; case Surface.ROTATION_90: Log.d(TAG,&quot;ROTATION_90&quot;); break; case Surface.ROTATION_180: Log.d(TAG,&quot;ROTATION_180&quot;); break; case Surface.ROTATION_270: Log.d(TAG,&quot;ROTATION_270&quot;); break; default: Log.d(TAG,&quot;Default Rotation!&quot;); break;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-保存图片到本地相册并及时更新显示/","text":"12345678910111213141516171819202122232425262728293031323334353637383940public class SaveBitmapToPhoto &#123; /** * 保存图片到指定路径 * * @param context * @param bitmap 要保存的图片 * @param fileName 自定义图片名称 getString(R.string.app_name) + &quot;&quot; + System.currentTimeMillis()+&quot;.png&quot; * @return true 成功 false失败 */ public static boolean saveImageToGallery(Context context, Bitmap bitmap, String fileName) &#123; // 保存图片至指定路径 String storePath = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;qrcode&quot;; File appDir = new File(storePath); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); //通过io流的方式来压缩保存图片(80代表压缩20%) boolean isSuccess = bitmap.compress(Bitmap.CompressFormat.JPEG, 80, fos); fos.flush(); fos.close(); //发送广播通知系统图库刷新数据 Uri uri = Uri.fromFile(file); context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri)); if (isSuccess) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android-Jenkins自动打包/","text":"Jenkins是开源CI&amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要JenKins官网JenKins插件下载)","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android判断Url格式是否正确/","text":"12345 if (!Patterns.WEB_URL.matcher(url).matches()) &#123;//正则表达式模式，以匹配 RFC 3987 国际化 URL &#125;else &#123; //符合标准 &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/marktext/","text":"特性 Mark Text 所输及所见，摒弃了众多 markdown 编辑器左边写作右边预览的写作方式，巧妙的将编辑和预览融为一体。 snabbdom 作为 Mark Text 的渲染引擎，保证了极速渲染编辑页面，带来流畅的书写体验。 支持 CommonMark Spec 和 GitHub Flavored Markdown Spec 语法格式，生成的 Markdown 可以复制到任何支持 markdown 格式的社区、网站。 段落及行内样式快捷键提升您的编辑效率。 输出 HTML 和 PDF 格式文件，方便在浏览器中预览。 黑、白两款主题，自由切换。 多种编辑模式：源代码模式、打字机模式、专注模式。 ###可以斗图的 Markdown 编辑器Mark Text 内置斗图功能，省掉了寻找「斗图」的烦恼，通过快捷键 Cmd+&#x2F; 直接打开斗图搜索面板，你需要的有趣图片就在里面。斗图功能默认是关闭的，你需要从user preference 菜单中，打开 preference.md, 然后设置 aidou 为 true。保存然后重启编辑器就可以使用了。window安装和下载:https://github.com/marktext/marktext/releases/download/v0.12.25/marktext-setup-0.12.25.exe官网：https://github.com/marktext/marktext/blob/master/doc/i18n/zh_cn.md#readme","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/自制-9图实现和设计图一致的阴影效果/","text":"这次项目遇到老板要求阴影效果，美工离职，又碰上屏幕适配和shadowLayout阴影框架冲突，网上各种方法试遍了效果都不理想，后来发现的好东西，还是自己动手丰衣足食。 Android在5.0中提出了“高度”的概念，并提供了elevation属性给开发者直接设定z值高度。但其效果与Axure设计图相差甚远： 另外我们知道Android制作阴影的方法有很多种，下面就是利用点九图实现与Axure的设计图中一致的阴影效果的方法。 生成点九图点九图阴影效果在线生成网站：https://inloop.github.io/shadow4android/ 我们对比一下Axure的阴影属性和该网站支持的属性： 从上表可知，使用点九图制作，理论上可以完美实现和Axure设计图一致的阴影效果。 注意事项**需要根据屏幕像素等级制作不同分辨率的点九图** 虽然Android设备可以根据自身屏幕像素等级对资源进行缩放，但很多人都有切图的需求。针对不同分辨率需要制作的点九图是不同的，这里举例说明一下：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android-RecyclerView实现横向滑动翻页/","text":"最近项目需求要实现RecyclerView的分页滑动 先上效果图如下(视频压缩成的gif所以滑动切换效果有点卡顿了 效果为每页三条数据的滑动) ####一：创建横向布局管理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229package com.tyl.baseMoudle.utils;import android.graphics.Rect;import android.support.v7.widget.RecyclerView;import android.util.Log;import android.util.SparseArray;import android.view.View;import com.tyl.baseMoudle.interfaces.PageDecorationLastJudge;public class HorizontalPageLayoutManager extends RecyclerView.LayoutManager implements PageDecorationLastJudge &#123; @Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return null; &#125; int totalHeight = 0; int totalWidth = 0; int offsetY = 0; int offsetX = 0; public HorizontalPageLayoutManager(int rows, int columns) &#123; this.rows = rows; this.columns = columns; this.onePageSize = rows * columns; &#125; @Override public boolean canScrollHorizontally() &#123; return true; &#125; @Override public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; detachAndScrapAttachedViews(recycler); int newX = offsetX + dx; int result = dx; if (newX &gt; totalWidth) &#123; result = totalWidth - offsetX; &#125; else if (newX &lt; 0) &#123; result = 0 - offsetX; &#125; offsetX += result; offsetChildrenHorizontal(-result); recycleAndFillItems(recycler, state); return result; &#125; private SparseArray&lt;Rect&gt; allItemFrames = new SparseArray&lt;&gt;(); private int getUsableWidth() &#123; return getWidth() - getPaddingLeft() - getPaddingRight(); &#125; private int getUsableHeight() &#123; return getHeight() - getPaddingTop() - getPaddingBottom(); &#125; int rows = 0; int columns = 0; int pageSize = 0; int itemWidth = 0; int itemHeight = 0; int onePageSize = 0; int itemWidthUsed; int itemHeightUsed; @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() == 0) &#123; removeAndRecycleAllViews(recycler); return; &#125; if (state.isPreLayout()) &#123; return; &#125; //获取每个Item的平均宽高 itemWidth = getUsableWidth() / columns; itemHeight = getUsableHeight() / rows; //计算宽高已经使用的量，主要用于后期测量 itemWidthUsed = (columns - 1) * itemWidth; itemHeightUsed = (rows - 1) * itemHeight; //计算总的页数// pageSize = state.getItemCount() / onePageSize + (state.getItemCount() % onePageSize == 0 ? 0 : 1); computePageSize(state); Log.i(&quot;zzz&quot;, &quot;itemCount=&quot; + getItemCount() + &quot; state itemCount=&quot; + state.getItemCount() + &quot; pageSize=&quot; + pageSize); //计算可以横向滚动的最大值 totalWidth = (pageSize - 1) * getWidth(); //分离view detachAndScrapAttachedViews(recycler); int count = getItemCount(); for (int p = 0; p &lt; pageSize; p++) &#123; for (int r = 0; r &lt; rows; r++) &#123; for (int c = 0; c &lt; columns; c++) &#123; int index = p * onePageSize + r * columns + c; if (index == count) &#123; //跳出多重循环 c = columns; r = rows; p = pageSize; break; &#125; View view = recycler.getViewForPosition(index); addView(view); //测量item measureChildWithMargins(view, itemWidthUsed, itemHeightUsed); int width = getDecoratedMeasuredWidth(view); int height = getDecoratedMeasuredHeight(view); //记录显示范围 Rect rect = allItemFrames.get(index); if (rect == null) &#123; rect = new Rect(); &#125; int x = p * getUsableWidth() + c * itemWidth; int y = r * itemHeight; rect.set(x, y, width + x, height + y); allItemFrames.put(index, rect); &#125; &#125; //每一页循环以后就回收一页的View用于下一页的使用 removeAndRecycleAllViews(recycler); &#125; recycleAndFillItems(recycler, state); &#125; private void computePageSize(RecyclerView.State state) &#123; pageSize = state.getItemCount() / onePageSize + (state.getItemCount() % onePageSize == 0 ? 0 : 1); &#125; @Override public void onDetachedFromWindow(RecyclerView view, RecyclerView.Recycler recycler) &#123; super.onDetachedFromWindow(view, recycler); offsetX = 0; offsetY = 0; &#125; private void recycleAndFillItems(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (state.isPreLayout()) &#123; return; &#125; Rect displayRect = new Rect(getPaddingLeft() + offsetX, getPaddingTop(), getWidth() - getPaddingLeft() - getPaddingRight() + offsetX, getHeight() - getPaddingTop() - getPaddingBottom()); Rect childRect = new Rect(); for (int i = 0; i &lt; getChildCount(); i++) &#123; View child = getChildAt(i); childRect.left = getDecoratedLeft(child); childRect.top = getDecoratedTop(child); childRect.right = getDecoratedRight(child); childRect.bottom = getDecoratedBottom(child); if (!Rect.intersects(displayRect, childRect)) &#123; removeAndRecycleView(child, recycler); &#125; &#125; for (int i = 0; i &lt; getItemCount(); i++) &#123; if (Rect.intersects(displayRect, allItemFrames.get(i))) &#123; View view = recycler.getViewForPosition(i); addView(view); measureChildWithMargins(view, itemWidthUsed, itemHeightUsed); Rect rect = allItemFrames.get(i); layoutDecorated(view, rect.left - offsetX, rect.top, rect.right - offsetX, rect.bottom); &#125; &#125; &#125; @Override public boolean isLastRow(int index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; getItemCount()) &#123; int indexOfPage = index % onePageSize; indexOfPage++; if (indexOfPage &gt; (rows - 1) * columns &amp;&amp; indexOfPage &lt;= onePageSize) &#123; return true; &#125; &#125; return false; &#125; @Override public boolean isLastColumn(int position) &#123; if (position &gt;= 0 &amp;&amp; position &lt; getItemCount()) &#123; position++; if (position % columns == 0) &#123; return true; &#125; &#125; return false; &#125; @Override public boolean isPageLast(int position) &#123; position++; return position % onePageSize == 0; &#125; @Override public int computeHorizontalScrollRange(RecyclerView.State state) &#123; computePageSize(state); return pageSize * getWidth(); &#125; @Override public int computeHorizontalScrollOffset(RecyclerView.State state) &#123; return offsetX; &#125; @Override public int computeHorizontalScrollExtent(RecyclerView.State state) &#123; return getWidth(); &#125;&#125; ####二：创建接口PageDecorationLastJudge实现接口回调 12345public interface PageDecorationLastJudge &#123; boolean isLastRow(int position); boolean isLastColumn(int position); boolean isPageLast(int position);&#125; #####三：实现RecyclerView横向滚动工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294package com.tyl.baseMoudle.utils;import android.animation.Animator;import android.animation.AnimatorListenerAdapter;import android.animation.ValueAnimator;import android.support.v7.widget.RecyclerView;import android.util.Log;import android.view.MotionEvent;import android.view.View;public class PagingScrollHelper &#123; RecyclerView mRecyclerView = null; private MyOnScrollListener mOnScrollListener = new MyOnScrollListener(); private MyOnFlingListener mOnFlingListener = new MyOnFlingListener(); private int offsetY = 0; private int offsetX = 0; int startY = 0; int startX = 0; enum ORIENTATION &#123; HORIZONTAL, VERTICAL, NULL &#125; private ORIENTATION mOrientation = ORIENTATION.HORIZONTAL; public void setUpRecycleView(RecyclerView recycleView) &#123; if (recycleView == null) &#123; throw new IllegalArgumentException(&quot;recycleView must be not null&quot;); &#125; mRecyclerView = recycleView; //处理滑动 recycleView.setOnFlingListener(mOnFlingListener); //设置滚动监听，记录滚动的状态，和总的偏移量 recycleView.setOnScrollListener(mOnScrollListener); //记录滚动开始的位置 recycleView.setOnTouchListener(mOnTouchListener); //获取滚动的方向 updateLayoutManger(); &#125; public void updateLayoutManger() &#123; RecyclerView.LayoutManager layoutManager = mRecyclerView.getLayoutManager(); if (layoutManager != null) &#123; if (layoutManager.canScrollVertically()) &#123; mOrientation = ORIENTATION.VERTICAL; &#125; else if (layoutManager.canScrollHorizontally()) &#123; mOrientation = ORIENTATION.HORIZONTAL; &#125; else &#123; mOrientation = ORIENTATION.NULL; &#125; if (mAnimator != null) &#123; mAnimator.cancel(); &#125; startX = 0; startY = 0; offsetX = 0; offsetY = 0; &#125; &#125; /** * 获取总共的页数 */ public int getPageCount() &#123; if (mRecyclerView != null) &#123; if (mOrientation == ORIENTATION.NULL) &#123; return 0; &#125; if (mOrientation == ORIENTATION.VERTICAL &amp;&amp; mRecyclerView.computeVerticalScrollExtent() != 0) &#123; return mRecyclerView.computeVerticalScrollRange() / mRecyclerView.computeVerticalScrollExtent(); &#125; else if (mRecyclerView.computeHorizontalScrollExtent() != 0) &#123; Log.i(&quot;zzz&quot;,&quot;rang=&quot;+mRecyclerView.computeHorizontalScrollRange()+&quot; extent=&quot;+mRecyclerView.computeHorizontalScrollExtent()); return mRecyclerView.computeHorizontalScrollRange() / mRecyclerView.computeHorizontalScrollExtent(); &#125; &#125; return 0; &#125; ValueAnimator mAnimator = null; public void scrollToPosition(int position) &#123; if (mAnimator == null) &#123; mOnFlingListener.onFling(0, 0); &#125; if (mAnimator != null) &#123; int startPoint = mOrientation == ORIENTATION.VERTICAL ? offsetY : offsetX, endPoint = 0; if (mOrientation == ORIENTATION.VERTICAL) &#123; endPoint = mRecyclerView.getHeight() * position; &#125; else &#123; endPoint = mRecyclerView.getWidth() * position; &#125; if (startPoint != endPoint) &#123; mAnimator.setIntValues(startPoint, endPoint); mAnimator.start(); &#125; &#125; &#125; public class MyOnFlingListener extends RecyclerView.OnFlingListener &#123; @Override public boolean onFling(int velocityX, int velocityY) &#123; if (mOrientation == ORIENTATION.NULL) &#123; return false; &#125; //获取开始滚动时所在页面的index int p = getStartPageIndex(); //记录滚动开始和结束的位置 int endPoint = 0; int startPoint = 0; //如果是垂直方向 if (mOrientation == ORIENTATION.VERTICAL) &#123; startPoint = offsetY; if (velocityY &lt; 0) &#123; p--; &#125; else if (velocityY &gt; 0) &#123; p++; &#125; //更具不同的速度判断需要滚动的方向 //注意，此处有一个技巧，就是当速度为0的时候就滚动会开始的页面，即实现页面复位 endPoint = p * mRecyclerView.getHeight(); &#125; else &#123; startPoint = offsetX; if (velocityX &lt; 0) &#123; p--; &#125; else if (velocityX &gt; 0) &#123; p++; &#125; endPoint = p * mRecyclerView.getWidth(); &#125; if (endPoint &lt; 0) &#123; endPoint = 0; &#125; //使用动画处理滚动 if (mAnimator == null) &#123; mAnimator = new ValueAnimator().ofInt(startPoint, endPoint); mAnimator.setDuration(300); mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int nowPoint = (int) animation.getAnimatedValue(); if (mOrientation == ORIENTATION.VERTICAL) &#123; int dy = nowPoint - offsetY; //这里通过RecyclerView的scrollBy方法实现滚动。 mRecyclerView.scrollBy(0, dy); &#125; else &#123; int dx = nowPoint - offsetX; mRecyclerView.scrollBy(dx, 0); &#125; &#125; &#125;); mAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; //回调监听 if (null != mOnPageChangeListener) &#123; mOnPageChangeListener.onPageChange(getPageIndex()); &#125; //修复双击item bug mRecyclerView.stopScroll(); startY = offsetY; startX = offsetX; &#125; &#125;); &#125; else &#123; mAnimator.cancel(); mAnimator.setIntValues(startPoint, endPoint); &#125; mAnimator.start(); return true; &#125; &#125; public class MyOnScrollListener extends RecyclerView.OnScrollListener &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; //newState==0表示滚动停止，此时需要处理回滚 if (newState == 0 &amp;&amp; mOrientation != ORIENTATION.NULL) &#123; boolean move; int vX = 0, vY = 0; if (mOrientation == ORIENTATION.VERTICAL) &#123; int absY = Math.abs(offsetY - startY); //如果滑动的距离超过屏幕的一半表示需要滑动到下一页 move = absY &gt; recyclerView.getHeight() / 2; vY = 0; if (move) &#123; vY = offsetY - startY &lt; 0 ? -1000 : 1000; &#125; &#125; else &#123; int absX = Math.abs(offsetX - startX); move = absX &gt; recyclerView.getWidth() / 2; if (move) &#123; vX = offsetX - startX &lt; 0 ? -1000 : 1000; &#125; &#125; mOnFlingListener.onFling(vX, vY); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; //滚动结束记录滚动的偏移量 offsetY += dy; offsetX += dx; &#125; &#125; private MyOnTouchListener mOnTouchListener = new MyOnTouchListener(); private boolean firstTouch = true; public class MyOnTouchListener implements View.OnTouchListener &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; //手指按下的时候记录开始滚动的坐标 if (firstTouch) &#123; //第一次touch可能是ACTION_MOVE或ACTION_DOWN,所以使用这种方式判断 firstTouch = false; startY = offsetY; startX = offsetX; &#125; if (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL) &#123; firstTouch = true; &#125; return false; &#125; &#125; private int getPageIndex() &#123; int p = 0; if (mRecyclerView.getHeight() == 0 || mRecyclerView.getWidth() == 0) &#123; return p; &#125; if (mOrientation == ORIENTATION.VERTICAL) &#123; p = offsetY / mRecyclerView.getHeight(); &#125; else &#123; p = offsetX / mRecyclerView.getWidth(); &#125; return p; &#125; private int getStartPageIndex() &#123; int p = 0; if (mRecyclerView.getHeight() == 0 || mRecyclerView.getWidth() == 0) &#123; //没有宽高无法处理 return p; &#125; if (mOrientation == ORIENTATION.VERTICAL) &#123; p = startY / mRecyclerView.getHeight(); &#125; else &#123; p = startX / mRecyclerView.getWidth(); &#125; return p; &#125; onPageChangeListener mOnPageChangeListener; public void setOnPageChangeListener(onPageChangeListener listener) &#123; mOnPageChangeListener = listener; &#125; public interface onPageChangeListener &#123; void onPageChange(int index); &#125;&#125; ####初始化RecyclerView同时设置为横向滑动 1234567891011121314151617RecyclerView recy_files = findViewById(R.id.recy_files); //使用通用RecyclerView组件 PagingScrollHelper scrollHelper = new PagingScrollHelper();//初始化横向管理器 HorizontalPageLayoutManager horizontalPageLayoutManager = new HorizontalPageLayoutManager(1, 1);//这里两个参数是行列，这里实现的是一行三列 scrollHelper.setUpRecycleView(recy_files);//将横向布局管理器和recycler view绑定到一起 scrollHelper.setOnPageChangeListener(new PagingScrollHelper.onPageChangeListener() &#123; @Override public void onPageChange(int index) &#123; &#125; &#125;); //设置滑动监听 recy_files.setLayoutManager(horizontalPageLayoutManager);//设置为横向 scrollHelper.updateLayoutManger(); scrollHelper.scrollToPosition(0);//默认滑动到第一页 recy_files.setHorizontalScrollBarEnabled(true); FilesAdapter filesAdapter = new FilesAdapter(filesList); recy_files.setAdapter(filesAdapter);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/VAPTCHA-ANDROID-SDK部署文档/","text":"行为验证 Android SDK提供给集成Android原生客户端开发的开发者使用, SDK不依赖任何第三方库。 环境需求 条目 开发目标 API 14+ 开发环境 android studio demo依赖 okgo ####资源下载 条目 资源地址 jar下载 vaptcha_android_libary Demo工程下载 vaptcha_android ####配置#####1.获取JAR包通过git命令获取： 1234//Step 1. Add the JitPack repository to your build file maven &#123; url &#x27;https://www.jitpack.io&#x27; &#125;//Step 2. Add the dependencyimplementation &#x27;com.github.VAPTCHA:VAPTCHA-android:1.0.0&#x27;,&#123; exclude module: &quot;okio&quot; &#125; 手动下载JAR包：Github:vaptcha_android_libary ####2.studio导入####模式分类 模式 type 描述 嵌入式 embed 自定义验证视图 在xml中直接引入 点击式 popup 自定义按钮 在xml中直接引 隐藏式 invisible 定义了java方法 在用户需要的地方直接调用 ####manifest中加入加入权限： 1234//网络权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;//获取当前网络状态&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; ####代码示例#####1. 嵌入式 12345678910111213141516171819202122232425262728//在xml中直接引用并配置 &lt;com.vaptcha.VaptchaView android:id=&quot;@+id/vaptchaView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:vaptcha_scene=&quot;01&quot; app:vaptcha_type=&quot;embed&quot; app:vaptcha_vid=&quot;5af01666a485d42f244c7d0d&quot; /&gt;//初始化 并设置监听 VaptchaView vaptchaView = findViewById(R.id.vaptchaView); vaptchaView.setVaptchaListener(new vaptchaListener() &#123; @Override public void onError() &#123;// 验证失败 &#125; @Override public void onExection() &#123;// 验证异常 &#125; @Override public void onSuccess(String token) &#123;// 验证成功 拿到token tv_login.setEnabled(true); &#125; &#125;);//验证重置 vaptchaView.vaptchaReset(); 参数说明 参数名 描述 vaptcha_type embed（嵌入式） 必填 vaptcha_vid vaptcha获取到的vid 必填 vaptcha_scene 描述 必填 vaptcha_isOutAge true进入宕机模式 选填 vaptcha_outage_url 宕机模式的服务器地址 选填 vaptcha_lang 语言（简体中文 zh-Hans）（繁体中文 zh-Hant）（英文 en） 选填 效果图#####2点击式 1234567891011121314151617181920212223242526 &lt;com.vaptcha.VaptchaView android:id=&quot;@+id/vaptchaButton&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:vaptcha_color=&quot;#cccccc&quot; app:vaptcha_scene=&quot;01&quot; app:vaptcha_type=&quot;popup&quot; app:vaptcha_vid=&quot;5af01666a485d42f244c7d0d&quot; /&gt;//初始化 并设置监听 vaptchaButton=mView.findViewById(R.id.vaptchaButton); vaptchaButton.setVaptchaListener(new vaptchaListener() &#123; @Override public void onError() &#123; // 验证失败 &#125; @Override public void onExection() &#123; // 验证异常 &#125; @Override public void onSuccess(String token) &#123;// 验证成功 拿到token &#125; &#125;);//验证重置 vaptchaButton.vaptchaReset(); 参数说明 参数名 描述 vaptcha_type popup（点击式） 必填 vaptcha_vid vaptcha获取到的vid 必填 vaptcha_scene 描述 必填 vaptcha_isOutAge true进入宕机模式 选填 vaptcha_outage_url 宕机模式的服务器地址 选填 vaptcha_color 按钮颜色 选填 vaptcha_lang 语言（简体中文 zh-Hans）（繁体中文 zh-Hant）（英文 en） 选填 效果图 ####3隐藏式 12345678910111213141516171819 //初始化VaptchaView 并传入配置参数 VaptchaView hide_view =new VaptchaView(getContext(), &quot;invisible&quot;, &quot;5af01666a485d42f244c7d0d&quot;, &quot;01&quot;); //调起验证界面 hide_view.show();//添加验证监听 hide_view.setVaptchaListener( new vaptchaListener() &#123; @Override public void onError() &#123; //验证错误 &#125; @Override public void onExection() &#123; //验证异常 &#125; @Override public void onSuccess(String token) &#123; //验证成功 &#125; &#125;;); 参数说明 参数名 描述 Context 上下文 必填 vaptcha_type invisible 必填 vaptcha_vid vaptcha获取到的vid 必填 vaptcha_scene 描述 必填 vaptcha_isOutAge true进入宕机模式 选填 vaptcha_outage_url 宕机模式的服务器地址 选填 vaptcha_lang 语言（简体中文 zh-Hans）（繁体中文 zh-Hant）（英文 en） 选填 效果图 以上为VAPTCHA SDK提供的三种验证方式，具体更多参数设置详见 Demo。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android-Gps-位置信息开关检测/","text":"6.0以上获取位置信息，需要动态申请，这里讨论当位置权限申请同意了，但是位置信息关闭了（其实就是6.0以前的gps开关）高精度定位也会获取失败！（网上有的检测方法在某些手机上会检测失败，下列的方式亲测有效） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.guoshikeji.xiaoxiangDriver.utils;import android.content.Context;import android.content.Intent;import android.os.Build;import android.provider.Settings;import android.text.TextUtils; /** * Created by tyl * 2019/5/22/022 * Describe: */public class GpsUtil &#123; /** * 判断GPS是否开启，GPS或者AGPS开启一个就认为是开启的 * @param context * @return true 表示开启 */ public static final boolean isOPen(final Context context) &#123; if (context==null)&#123; return true; &#125; int locationMode = 0; String locationProviders; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; try &#123; locationMode = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE); &#125; catch (Settings.SettingNotFoundException e) &#123; e.printStackTrace(); return false; &#125; return locationMode != Settings.Secure.LOCATION_MODE_OFF; &#125; else &#123; locationProviders = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.LOCATION_PROVIDERS_ALLOWED); return !TextUtils.isEmpty(locationProviders); &#125; &#125; /** * 跳转设置 打开GPS * @param context */ public static final void openGPS(Context context) &#123; Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS); context.startActivity(intent); &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-eclpse快捷键大全/","text":"快捷键 描述 常用相关: Ctrl+1 快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如import类、try catch包围等） Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+M 添加类的import导入 Ctrl+Shift+O 组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用） Ctrl+Y 重做（与撤销Ctrl+Z相反） Alt+&#x2F; 内容辅助（帮你省了多少次键盘敲打，太常用了） Alt+↓ 当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了） Alt+↑ 当前行和上面一行交互位置（同上） Ctrl+Alt+↓ 复制当前行到下一行（复制增加） Ctrl+Alt+↑ 复制当前行到上一行（复制增加） Shift+Enter 在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后） Ctrl+&#x2F; 注释当前行,再按则取消注释 选择相关： Alt+Shift+↑ 选择封装元素 Alt+Shift+← 选择上一个元素 Alt+Shift+→ 选择下一个元素 Shift+← 从光标处开始往左选择字符 Shift+→ 选择下一个元素 Ctrl+Shift+← 选中光标左边的单词 Ctrl+Shift+→ 选中光标右边的单词 移动相关： Ctrl+← 光标移到左边单词的开头，相当于vim的b Ctrl+→ 光标移到右边单词的末尾，相当于vim的e 搜索相关： Ctrl+K 参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word） Ctrl+Shift+K 参照选中的Word快速定位到上一个 Ctrl+J 正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建） Ctrl+Shift+J 反向增量查找（和上条相同,只不过是从后往前查） Ctrl+Shift+U 列出所有包含字符串的行 Ctrl+H 打开搜索对话框 Ctrl+G 工作区中的声明 Ctrl+Shift+G 工作区中的引用 导航相关 Ctrl+Shift+T 搜索类（包括工程和关联的第三jar包） Ctrl+Shift+R 搜索工程中的文件 Ctrl+E 快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示） F4 打开类型层次结构 F3 跳转到声明处 Alt+← 前一个编辑的页面 Alt+→ 下一个编辑的页面（当然是针对上面那条来说了） Ctrl+PageUp&#x2F;PageDown 在编辑器中，切换已经打开的文件 调试相关 F5 单步跳入 F6 单步跳过 F7 单步返回 F8 继续 Ctrl+Shift+D 显示变量的值 Ctrl+Shift+B 在当前行设置或者去掉断点 Ctrl+R 运行至行(超好用，可以节省好多的断点) 重构相关： 一般重构的快捷键都是Alt+Shift开头的了 Alt+Shift+R 重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力） Alt+Shift+M 把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用） Alt+Shift+C 修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定） Alt+Shift+L 抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候） Alt+Shift+F 把Class中的local变量变为field变量 （比较实用的功能） Alt+Shift+I 合并变量（可能这样说有点不妥Inline） Alt+Shift+V 移动函数和变量（不怎么常用） Alt+Shift+Z 重构的后悔药（Undo） 其他 Alt+Enter 显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径 Ctrl+↑ 文本编辑器 上滚行 Ctrl+↓ 文本编辑器 下滚行 Ctrl+M 最大化当前的Edit或View （再按则反之） Ctrl+O 快速显示 OutLine（不开Outline窗口的同学，这个快捷键是必不可少的） Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer（windows下关闭打开的对话框也是这个，还有qq、旺旺、浏览器等都是） Ctrl+L 文本编辑器 转至行 F2 显示工具提示描述 #####android studio 设置Eclipse快捷键： 12file → settings → Keymap然后再右侧的keymaps中找到eclipse，选中后就可以更eclipse中的快捷键一样了","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/java-android-银行卡号查询银行卡类型及名称/","text":"####简述Bin号：BIN号即银行标识代码，英文全称是 Bank Identification Number。BIN由6位数字表示，出现在卡号的前6位，由国际标准化组织(ISO)分配给各从事跨行转接交换的银行卡组织。银行卡的卡号是标识发卡机构和持卡人信息的号码，由以下三部分组成：发卡行标识代码(BIN号)、发卡行自定义位、校验码。 ####使用方法： 123456//cardNum银行卡号BankCardInfoBean bankCardInfoBean = new BankCardInfoBean(cardNum); if (bankCardInfoBean!=null)&#123; String cardType = bankCardInfoBean.getCardType();//银行卡类型 比如：信用卡/储蓄卡 String bankName = bankCardInfoBean.getBankName();//银行卡名称 比如：建设银行/招商银行 &#125; ####效果图：####BankCardInfoBean （数据库表） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806package com.guoshikeji.driver95128.utils.getBankInfo;import java.util.regex.Pattern;/** * Created by mardawang on 2017/5/18. * &lt;p&gt; * &#123;@&quot;DC&quot;:@&quot;储蓄卡&quot;,@&quot;CC&quot;:@&quot;信用卡&quot;,@&quot;SCC&quot;:@&quot;准贷记卡&quot;,@&quot;PC&quot;:@&quot;预付费卡&quot;&#125; */public class BankCardInfoBean &#123; String s1 = &quot;^(621096|621098|622150|622151|622181|622188|622199|955100|621095|620062|621285|621798|621799|621797|620529|621622|621599|621674|623218|623219)\\\\d&#123;13&#125;$&quot;; String s2 = &quot;^(62215049|62215050|62215051|62218850|62218851|62218849)\\\\d&#123;11&#125;$&quot;; String s3 = &quot;^(622812|622810|622811|628310|625919)\\\\d&#123;10&#125;$&quot;; String s4 = &quot;^(620200|620302|620402|620403|620404|620406|620407|620409|620410|620411|620412|620502|620503|620405|620408|620512|620602|620604|620607|620611|620612|620704|620706|620707|620708|620709|620710|620609|620712|620713|620714|620802|620711|620904|620905|621001|620902|621103|621105|621106|621107|621102|621203|621204|621205|621206|621207|621208|621209|621210|621302|621303|621202|621305|621306|621307|621309|621311|621313|621211|621315|621304|621402|621404|621405|621406|621407|621408|621409|621410|621502|621317|621511|621602|621603|621604|621605|621608|621609|621610|621611|621612|621613|621614|621615|621616|621617|621607|621606|621804|621807|621813|621814|621817|621901|621904|621905|621906|621907|621908|621909|621910|621911|621912|621913|621915|622002|621903|622004|622005|622006|622007|622008|622010|622011|622012|621914|622015|622016|622003|622018|622019|622020|622102|622103|622104|622105|622013|622111|622114|622017|622110|622303|622304|622305|622306|622307|622308|622309|622314|622315|622317|622302|622402|622403|622404|622313|622504|622505|622509|622513|622517|622502|622604|622605|622606|622510|622703|622715|622806|622902|622903|622706|623002|623006|623008|623011|623012|622904|623015|623100|623202|623301|623400|623500|623602|623803|623901|623014|624100|624200|624301|624402|623700|624000)\\\\d&#123;12&#125;$&quot;; String s5 = &quot;^(622200|622202|622203|622208|621225|620058|621281|900000|621558|621559|621722|621723|620086|621226|621618|620516|621227|621288|621721|900010|623062|621670|621720|621379|621240|621724|621762|621414|621375|622926|622927|622928|622929|622930|622931|621733|621732|621372|621369|621763)\\\\d&#123;13&#125;$&quot;; String s6 = &quot;^(402791|427028|427038|548259|621376|621423|621428|621434|621761|621749|621300|621378|622944|622949|621371|621730|621734|621433|621370|621764|621464|621765|621750|621377|621367|621374|621731|621781)\\\\d&#123;10&#125;$&quot;; String s7 = &quot;^(9558)\\\\d&#123;15&#125;$&quot;; String s8 = &quot;^(370246|370248|370249|370247|370267|374738|374739)\\\\d&#123;9&#125;$&quot;; String s9 = &quot;^(427010|427018|427019|427020|427029|427030|427039|438125|438126|451804|451810|451811|458071|489734|489735|489736|510529|427062|524091|427064|530970|530990|558360|524047|525498|622230|622231|622232|622233|622234|622235|622237|622239|622240|622245|622238|451804|451810|451811|458071|628288|628286|622206|526836|513685|543098|458441|622246|544210|548943|356879|356880|356881|356882|528856|625330|625331|625332|622236|524374|550213|625929|625927|625939|625987|625930|625114|622159|625021|625022|625932|622889|625900|625915|625916|622171|625931|625113|625928|625914|625986|625925|625921|625926|625942|622158|625917|625922|625934|625933|625920|625924|625017|625018|625019)\\\\d&#123;10&#125;$&quot;; String s10 = &quot;^(45806|53098|45806|53098)\\\\d&#123;11&#125;$&quot;; String s11 = &quot;^(622210|622211|622212|622213|622214|622220|622223|622225|622229|622215|622224)\\\\d&#123;10&#125;$&quot;; String s12 = &quot;^(620054|620142|620184|620030|620050|620143|620149|620124|620183|620094|620186|620148|620185)\\\\d&#123;10&#125;$&quot;; String s13 = &quot;^(620114|620187|620046)\\\\d&#123;13&#125;$&quot;; String s14 = &quot;^(622841|622824|622826|622848|620059|621282|622828|622823|621336|621619|622821|622822|622825|622827|622845|622849|623018|623206|621671|622840|622843|622844|622846|622847|620501)\\\\d&#123;13&#125;$&quot;; String s15 = &quot;^(95595|95596|95597|95598|95599)\\\\d&#123;14&#125;$&quot;; String s16 = &quot;^(103)\\\\d&#123;16&#125;$&quot;; String s17 = &quot;^(403361|404117|404118|404119|404120|404121|463758|519412|519413|520082|520083|552599|558730|514027|622836|622837|628268|625996|625998|625997|622838|625336|625826|625827|544243|548478|628269)\\\\d&#123;10&#125;$&quot;; String s18 = &quot;^(622820|622830)\\\\d&#123;10&#125;$&quot;; String s19 = &quot;^(621660|621661|621662|621663|621665|621667|621668|621669|621666|456351|601382|621256|621212|621283|620061|621725|621330|621331|621332|621333|621297|621568|621569|621672|623208|621620|621756|621757|621758|621759|621785|621786|621787|621788|621789|621790|622273|622274|622771|622772|622770|621741|621041)\\\\d&#123;13&#125;$&quot;; String s20 = &quot;^(621293|621294|621342|621343|621364|621394|621648|621248|621215|621249|621231|621638|621334|621395|623040|622348)\\\\d&#123;10&#125;$&quot;; String s21 = &quot;^(625908|625910|625909|356833|356835|409665|409666|409668|409669|409670|409671|409672|512315|512316|512411|512412|514957|409667|438088|552742|553131|514958|622760|628388|518377|622788|628313|628312|622750|622751|625145|622479|622480|622789|625140|622346|622347)\\\\d&#123;10&#125;$&quot;; String s22 = &quot;^(518378|518379|518474|518475|518476|524865|525745|525746|547766|558868|622752|622753|622755|524864|622757|622758|622759|622761|622762|622763|622756|622754|622764|622765|558869|625905|625906|625907|625333)\\\\d&#123;10&#125;$&quot;; String s23 = &quot;^(53591|49102|377677)\\\\d&#123;11&#125;$&quot;; String s24 = &quot;^(620514|620025|620026|620210|620211|620019|620035|620202|620203|620048|620515|920000)\\\\d&#123;10&#125;$&quot;; String s25 = &quot;^(620040|620531|620513|921000|620038)\\\\d&#123;13&#125;$&quot;; String s26 = &quot;^(621284|436742|589970|620060|621081|621467|621598|621621|621700|622280|622700|623211|623668)\\\\d&#123;13&#125;$&quot;; String s27 = &quot;^(421349|434061|434062|524094|526410|552245|621080|621082|621466|621488|621499|622966|622988|622382|621487|621083|621084|620107)\\\\d&#123;10&#125;$&quot;; String s28 = &quot;^(436742193|622280193)\\\\d&#123;10&#125;$&quot;; String s29 = &quot;^(553242)\\\\d&#123;12&#125;$&quot;; String s30 = &quot;^(625362|625363|628316|628317|356896|356899|356895|436718|436738|436745|436748|489592|531693|532450|532458|544887|552801|557080|558895|559051|622166|622168|622708|625964|625965|625966|628266|628366|622381|622675|622676|622677)\\\\d&#123;10&#125;$&quot;; String s31 = &quot;^(5453242|5491031|5544033)\\\\d&#123;11&#125;$&quot;; String s32 = &quot;^(622725|622728|436728|453242|491031|544033|622707|625955|625956)\\\\d&#123;10&#125;$&quot;; String s33 = &quot;^(53242|53243)\\\\d&#123;11&#125;$&quot;; String s34 = &quot;^(622261|622260|622262|621002|621069|621436|621335)\\\\d&#123;13&#125;$&quot;; String s35 = &quot;^(620013)\\\\d&#123;10&#125;$&quot;; String s36 = &quot;^(405512|601428|405512|601428|622258|622259|405512|601428)\\\\d&#123;11&#125;$&quot;; String s37 = &quot;^(49104|53783)\\\\d&#123;11&#125;$&quot;; String s38 = &quot;^(434910|458123|458124|520169|522964|552853|622250|622251|521899|622253|622656|628216|622252|955590|955591|955592|955593|628218|625028|625029)\\\\d&#123;10&#125;$&quot;; String s39 = &quot;^(622254|622255|622256|622257|622284)\\\\d&#123;10&#125;$&quot;; String s40 = &quot;^(620021|620521)\\\\d&#123;13&#125;$&quot;; String s41 = &quot;^(402658|410062|468203|512425|524011|622580|622588|622598|622609|95555|621286|621483|621485|621486|621299)(\\\\d&#123;10&#125;|\\\\d&#123;11&#125;)$&quot;; String s42 = &quot;^(690755)\\\\d&#123;9&#125;$&quot;; String s43 = &quot;^(690755)\\\\d&#123;12&#125;$&quot;; String s44 = &quot;^(356885|356886|356887|356888|356890|439188|439227|479228|479229|521302|356889|545620|545621|545947|545948|552534|552587|622575|622576|622577|622578|622579|545619|622581|622582|545623|628290|439225|518710|518718|628362|439226|628262|625802|625803)\\\\d&#123;10&#125;$&quot;; String s45 = &quot;^(370285|370286|370287|370289)\\\\d&#123;9&#125;$&quot;; String s46 = &quot;^(620520)\\\\d&#123;13&#125;$&quot;; //民生银行 String s47 = &quot;^(622615|622616|622618|622622|622617|622619|415599|421393|421865|427570|427571|472067|472068|622620)\\\\d&#123;10&#125;$&quot;; String s48 = &quot;^(545392|545393|545431|545447|356859|356857|407405|421869|421870|421871|512466|356856|528948|552288|622600|622601|622602|517636|622621|628258|556610|622603|464580|464581|523952|545217|553161|356858|622623|625912|625913|625911)\\\\d&#123;10&#125;$&quot;; String s49 = &quot;^(377155|377152|377153|377158)\\\\d&#123;9&#125;$&quot;; String s50 = &quot;^(303)\\\\d&#123;13&#125;$&quot;; String s51 = &quot;^(90030)\\\\d&#123;11&#125;$&quot;; String s52 = &quot;^(620535)\\\\d&#123;13&#125;$&quot;; String s53 = &quot;^(620085|622660|622662|622663|622664|622665|622666|622667|622669|622670|622671|622672|622668|622661|622674|622673|620518|621489|621492)\\\\d&#123;10&#125;$&quot;; String s54 = &quot;^(356837|356838|486497|622657|622685|622659|622687|625978|625980|625981|625979|356839|356840|406252|406254|425862|481699|524090|543159|622161|622570|622650|622655|622658|625975|625977|628201|628202|625339|625976)\\\\d&#123;10&#125;$&quot;; String s55 = &quot;^(433670|433680|442729|442730|620082|622690|622691|622692|622696|622698|622998|622999|433671|968807|968808|968809|621771|621767|621768|621770|621772|621773|622453|622456)\\\\d&#123;10&#125;$&quot;; String s56 = &quot;^(622459)\\\\d&#123;11&#125;$&quot;; String s57 = &quot;^(376968|376969|376966)\\\\d&#123;9&#125;$&quot;; String s58 = &quot;^(400360|403391|403392|404158|404159|404171|404172|404173|404174|404157|433667|433668|433669|514906|403393|520108|433666|558916|622678|622679|622680|622688|622689|628206|556617|628209|518212|628208|356390|356391|356392|622916|622918|622919)\\\\d&#123;10&#125;$&quot;; String s59 = &quot;^(622630|622631|622632|622633|999999|621222|623020|623021|623022|623023)\\\\d&#123;10&#125;$&quot;; String s60 = &quot;^(523959|528709|539867|539868|622637|622638|628318|528708|622636|625967|625968|625969)\\\\d&#123;10&#125;$&quot;; String s61 = &quot;^(621626|623058)\\\\d&#123;13&#125;$&quot;; String s62 = &quot;^(602907|622986|622989|622298|627069|627068|627066|627067|412963|415752|415753|622535|622536|622538|622539|998800|412962|622983)\\\\d&#123;10&#125;$&quot;; String s63 = &quot;^(531659|622157|528020|622155|622156|526855|356869|356868|625360|625361|628296|435744|435745|483536|622525|622526|998801|998802)\\\\d&#123;10&#125;$&quot;; String s64 = &quot;^(620010)\\\\d&#123;10&#125;$&quot;; //兴业银行 String s65 = &quot;^(438589)\\\\d&#123;12&#125;$&quot;; String s66 = &quot;^(90592)\\\\d&#123;11&#125;$&quot;; String s67 = &quot;^(966666|622909|438588|622908)\\\\d&#123;12&#125;$&quot;; String s68 = &quot;^(461982|486493|486494|486861|523036|451289|527414|528057|622901|622902|622922|628212|451290|524070|625084|625085|625086|625087|548738|549633|552398|625082|625083|625960|625961|625962|625963)\\\\d&#123;10&#125;$&quot;; String s69 = &quot;^(620010)\\\\d&#123;10&#125;$&quot;; String s70 = &quot;^(621050|622172|622985|622987|620522|622267|622278|622279|622468|622892|940021)\\\\d&#123;12&#125;$&quot;; String s71 = &quot;^(438600)\\\\d&#123;10&#125;$&quot;; String s72 = &quot;^(356827|356828|356830|402673|402674|486466|519498|520131|524031|548838|622148|622149|622268|356829|622300|628230|622269|625099|625953)\\\\d&#123;10&#125;$&quot;; String s73 = &quot;^(622516|622517|622518|622521|622522|622523|984301|984303|621352|621793|621795|621796|621351|621390|621792|621791)\\\\d&#123;10&#125;$&quot;; String s74 = &quot;^(84301|84336|84373|84385|84390|87000|87010|87030|87040|84380|84361|87050|84342)\\\\d&#123;11&#125;$&quot;; String s75 = &quot;^(356851|356852|404738|404739|456418|498451|515672|356850|517650|525998|622177|622277|628222|622500|628221|622176|622276|622228|625957|625958|625993|625831)\\\\d&#123;10&#125;$&quot;; String s76 = &quot;^(622520|622519)\\\\d&#123;10&#125;$&quot;; String s77 = &quot;^(620530)\\\\d&#123;13&#125;$&quot;; // String s78 = &quot;^(622516|622517|622518|622521|622522|622523|984301|984303|621352|621793|621795|621796|621351|621390|621792|621791)\\\\d&#123;10&#125;$&quot;; String s79 = &quot;^(622568|6858001|6858009|621462)\\\\d&#123;13&#125;$&quot;; String s80 = &quot;^(9111)\\\\d&#123;15&#125;$&quot;; String s81 = &quot;^(406365|406366|428911|436768|436769|436770|487013|491032|491033|491034|491035|491036|491037|491038|436771|518364|520152|520382|541709|541710|548844|552794|493427|622555|622556|622557|622558|622559|622560|528931|558894|625072|625071|628260|628259|625805|625806|625807|625808|625809|625810)\\\\d&#123;10&#125;$&quot;; String s82 = &quot;^(685800|6858000)\\\\d&#123;13&#125;$&quot;; String s83 = &quot;^(621268|622684|622884|621453)\\\\d&#123;10&#125;$&quot;; String s84 = &quot;^(603445|622467|940016|621463)\\\\d&#123;13&#125;$&quot;; String s85 = &quot;^(622449|940051)\\\\d&#123;10&#125;$&quot;; String s86 = &quot;^(622450|628204)\\\\d&#123;10&#125;$&quot;; //温州银行 String s87 = &quot;^(621977)\\\\d&#123;10&#125;$&quot;; String s88 = &quot;^(622868|622899|628255)\\\\d&#123;10&#125;$&quot;; String s89 = &quot;^(622877|622879|621775|623203)\\\\d&#123;13&#125;$&quot;; String s90 = &quot;^(603601|622137|622327|622340|622366)\\\\d&#123;11&#125;$&quot;; String s91 = &quot;^(628251|622651|625828)\\\\d&#123;10&#125;$&quot;; String s92 = &quot;^(621076|622173|622131|621579|622876)\\\\d&#123;13&#125;$&quot;; String s93 = &quot;^(504923|622422|622447|940076)\\\\d&#123;10&#125;$&quot;; String s94 = &quot;^(628210|622283|625902)\\\\d&#123;10&#125;$&quot;; //南京银行 String s95 = &quot;^(621777|622305|621259)\\\\d&#123;10&#125;$&quot;; String s96 = &quot;^(622303|628242|622595|622596)\\\\d&#123;10&#125;$&quot;; String s97 = &quot;^(621279|622281|622316|940022)\\\\d&#123;10&#125;$&quot;; String s98 = &quot;^(621418)\\\\d&#123;13&#125;$&quot;; String s99 = &quot;^(625903|622778|628207|512431|520194|622282|622318)\\\\d&#123;10&#125;$&quot;; String s100 = &quot;^(625903|622778|628207|512431|520194|622282|622318)\\\\d&#123;10&#125;$&quot;; //北京银行 String s101 = &quot;^(522001|622163|622853|628203|622851|622852)\\\\d&#123;10&#125;$&quot;; String s102 = &quot;^(620088|621068|622138|621066|621560)\\\\d&#123;13&#125;$&quot;; String s103 = &quot;^(625526|625186|628336)\\\\d&#123;10&#125;$&quot;; String s104 = &quot;^(622946)\\\\d&#123;10&#125;$&quot;; String s105 = &quot;^(622406|621442)\\\\d&#123;11&#125;$&quot;; String s106 = &quot;^(622407|621443)\\\\d&#123;13&#125;$&quot;; String s107 = &quot;^(622360|622361|625034|625096|625098)\\\\d&#123;10&#125;$&quot;; //渣打银行 String s108 = &quot;^(622948|621740|622942|622994)\\\\d&#123;10&#125;$&quot;; String s109 = &quot;^(622482|622483|622484)\\\\d&#123;10&#125;$&quot;; String s110 = &quot;^(621062|621063)\\\\d&#123;10&#125;$&quot;; String s111 = &quot;^(625076|625077|625074|625075|622371|625091)\\\\d&#123;10&#125;$&quot;; //东亚银行 String s112 = &quot;^(622933|622938|623031|622943|621411)\\\\d&#123;13&#125;$&quot;; String s113 = &quot;^(622372|622471|622472|622265|622266|625972|625973)\\\\d&#123;10&#125;$&quot;; String s114 = &quot;^(622365)\\\\d&#123;11&#125;$&quot;; String s115 = &quot;^(621469|621625)\\\\d&#123;13&#125;$&quot;; String s116 = &quot;^(622128|622129|623035)\\\\d&#123;10&#125;$&quot;; String s117 = &quot;^(909810|940035|621522|622439)\\\\d&#123;12&#125;$&quot;; String s118 = &quot;^(622328|940062|623038)\\\\d&#123;13&#125;$&quot;; String s119 = &quot;^(625288|625888)\\\\d&#123;10&#125;$&quot;; String s120 = &quot;^(622333|940050)\\\\d&#123;10&#125;$&quot;; String s121 = &quot;^(621439|623010)\\\\d&#123;13&#125;$&quot;; String s122 = &quot;^(622888)\\\\d&#123;10&#125;$&quot;; String s123 = &quot;^(622302)\\\\d&#123;10&#125;$&quot;; String s124 = &quot;^(622477|622509|622510|622362|621018|621518)\\\\d&#123;13&#125;$&quot;; String s125 = &quot;^(622297|621277)\\\\d&#123;10&#125;$&quot;; String s126 = &quot;^(622375|622489)\\\\d&#123;11&#125;$&quot;; String s127 = &quot;^(622293|622295|622296|622373|622451|622294|625940)\\\\d&#123;10&#125;$&quot;; String s128 = &quot;^(622871|622958|622963|622957|622861|622932|622862|621298)\\\\d&#123;10&#125;$&quot;; String s129 = &quot;^(622798|625010|622775|622785)\\\\d&#123;10&#125;$&quot;; String s130 = &quot;^(621016|621015)\\\\d&#123;13&#125;$&quot;; String s131 = &quot;^(622487|622490|622491|622492)\\\\d&#123;10&#125;$&quot;; String s132 = &quot;^(622487|622490|622491|622492|621744|621745|621746|621747)\\\\d&#123;11&#125;$&quot;; String s133 = &quot;^(623078)\\\\d&#123;13&#125;$&quot;; String s134 = &quot;^(622384|940034)\\\\d&#123;11&#125;$&quot;; String s135 = &quot;^(940015|622331)\\\\d&#123;12&#125;$&quot;; String s136 = &quot;^(6091201)\\\\d&#123;11&#125;$&quot;; String s137 = &quot;^(622426|628205)\\\\d&#123;10&#125;$&quot;; String s138 = &quot;^(621019|622309|621019)\\\\d&#123;13&#125;$&quot;; String s139 = &quot;^(6223091100|6223092900|6223093310|6223093320|6223093330|6223093370|6223093380|6223096510|6223097910)\\\\d&#123;9&#125;$&quot;; String s140 = &quot;^(621213|621289|621290|621291|621292|621042|621743)\\\\d&#123;13&#125;$&quot;; String s141 = &quot;^(623041|622351)\\\\d&#123;10&#125;$&quot;; String s142 = &quot;^(625046|625044|625058|622349|622350)\\\\d&#123;10&#125;$&quot;; String s143 = &quot;^(620208|620209|625093|625095)\\\\d&#123;10&#125;$&quot;; //厦门银行 String s144 = &quot;^(622393|940023)\\\\d&#123;10&#125;$&quot;; String s145 = &quot;^(6886592)\\\\d&#123;11&#125;$&quot;; String s146 = &quot;^(623019|621600|)\\\\d&#123;13&#125;$&quot;; String s147 = &quot;^(622388)\\\\d&#123;10&#125;$&quot;; String s148 = &quot;^(621267|623063)\\\\d&#123;12&#125;$&quot;; String s149 = &quot;^(620043|)\\\\d&#123;12&#125;$&quot;; String s150 = &quot;^(622865|623131)\\\\d&#123;13&#125;$&quot;; String s151 = &quot;^(940012)\\\\d&#123;10&#125;$&quot;; String s152 = &quot;^(622178|622179|628358)\\\\d&#123;10&#125;$&quot;; //汉口银行 String s153 = &quot;^(990027)\\\\d&#123;12&#125;$&quot;; String s154 = &quot;^(622325|623105|623029)\\\\d&#123;10&#125;$&quot;; String s155 = &quot;^(566666)\\\\d&#123;12&#125;$&quot;; String s156 = &quot;^(622455|940039)\\\\d&#123;13&#125;$&quot;; String s157 = &quot;^(623108|623081)\\\\d&#123;10&#125;$&quot;; String s158 = &quot;^(622466|628285)\\\\d&#123;10&#125;$&quot;; String s159 = &quot;^(603708)\\\\d&#123;11&#125;$&quot;; String s160 = &quot;^(622993|623069|623070|623172|623173)\\\\d&#123;13&#125;$&quot;; String s161 = &quot;^(622383|622385|628299)\\\\d&#123;10&#125;$&quot;; String s162 = &quot;^(622498|622499|623000|940046)\\\\d&#123;13&#125;$&quot;; String s163 = &quot;^(622921|628321)\\\\d&#123;10&#125;$&quot;; //乌鲁木齐商业银行 String s164 = &quot;^(621751|622143|940001|621754)\\\\d&#123;13&#125;$&quot;; String s165 = &quot;^(622476|628278)\\\\d&#123;10&#125;$&quot;; String s166 = &quot;^(622486)\\\\d&#123;10&#125;$&quot;; String s167 = &quot;^(603602|623026|623086)\\\\d&#123;12&#125;$&quot;; String s168 = &quot;^(628291)\\\\d&#123;10&#125;$&quot;; String s169 = &quot;^(622152|622154|622996|622997|940027|622153|622135|621482|621532)\\\\d&#123;13&#125;$&quot;; String s170 = &quot;^(622442)\\\\d&#123;11&#125;$&quot;; String s171 = &quot;^(940053)\\\\d&#123;12&#125;$&quot;; String s172 = &quot;^(622442|623099)\\\\d&#123;13&#125;$&quot;; String s173 = &quot;^(622421)\\\\d&#123;13&#125;$&quot;; String s174 = &quot;^(940056)\\\\d&#123;11&#125;$&quot;; String s175 = &quot;^(96828)\\\\d&#123;11&#125;$&quot;; //宁夏银行 String s176 = &quot;^(621529|622429|621417|623089|623200)\\\\d&#123;13&#125;$&quot;; String s177 = &quot;^(628214|625529|622428)\\\\d&#123;10&#125;$&quot;; String s178 = &quot;^(9896)\\\\d&#123;12&#125;$&quot;; String s179 = &quot;^(622134|940018|623016)\\\\d&#123;10&#125;$&quot;; String s180 = &quot;^(621577|622425)\\\\d&#123;13&#125;$&quot;; String s181 = &quot;^(940049)\\\\d&#123;12&#125;$&quot;; String s182 = &quot;^(622425)\\\\d&#123;11&#125;$&quot;; String s183 = &quot;^(622139|940040|628263)\\\\d&#123;10&#125;$&quot;; String s184 = &quot;^(621242|621538|621496)\\\\d&#123;13&#125;$&quot;; String s185 = &quot;^(621252|622146|940061|628239)\\\\d&#123;10&#125;$&quot;; String s186 = &quot;^(621419|623170)\\\\d&#123;13&#125;$&quot;; String s187 = &quot;^(62249802|94004602)\\\\d&#123;11&#125;$&quot;; String s188 = &quot;^(621237|623003)\\\\d&#123;13&#125;$&quot;; //青海银行 String s189 = &quot;^(622310|940068)\\\\d&#123;11&#125;$&quot;; String s190 = &quot;^(622817|628287|625959)\\\\d&#123;10&#125;$&quot;; String s191 = &quot;^(62536601)\\\\d&#123;8&#125;$&quot;; String s192 = &quot;^(622427)\\\\d&#123;10&#125;$&quot;; String s193 = &quot;^(940069)\\\\d&#123;11&#125;$&quot;; String s194 = &quot;^(623039)\\\\d&#123;13&#125;$&quot;; String s195 = &quot;^(622321|628273)\\\\d&#123;10&#125;$&quot;; String s196 = &quot;^(625001)\\\\d&#123;10&#125;$&quot;; String s197 = &quot;^(694301)\\\\d&#123;12&#125;$&quot;; String s198 = &quot;^(940071|622368|621446)\\\\d&#123;13&#125;$&quot;; String s199 = &quot;^(625901|622898|622900|628281|628282|622806|628283)\\\\d&#123;10&#125;$&quot;; String s200 = &quot;^(620519)\\\\d&#123;13&#125;$&quot;; String s201 = &quot;^(683970|940074)\\\\d&#123;12&#125;$&quot;; String s202 = &quot;^(622370)\\\\d&#123;13&#125;$&quot;; String s203 = &quot;^(621437)\\\\d&#123;13&#125;$&quot;; String s204 = &quot;^(628319)\\\\d&#123;10&#125;$&quot;; String s205 = &quot;^(622336|621760)\\\\d&#123;11&#125;$&quot;; String s206 = &quot;^(622165)\\\\d&#123;10&#125;$&quot;; String s207 = &quot;^(622315|625950|628295)\\\\d&#123;10&#125;$&quot;; String s208 = &quot;^(621037|621097|621588|622977)\\\\d&#123;13&#125;$&quot;; String s209 = &quot;^(62321601)\\\\d&#123;11&#125;$&quot;; String s210 = &quot;^(622860)\\\\d&#123;10&#125;$&quot;; String s211 = &quot;^(622644|628333)\\\\d&#123;10&#125;$&quot;; String s212 = &quot;^(622478|940013|621495)\\\\d&#123;10&#125;$&quot;; String s213 = &quot;^(625500)\\\\d&#123;10&#125;$&quot;; String s214 = &quot;^(622611|622722|628211|625989)\\\\d&#123;10&#125;$&quot;; String s215 = &quot;^(622717)\\\\d&#123;10&#125;$&quot;; String s216 = &quot;^(628275|622565|622287)\\\\d&#123;10&#125;$&quot;; //内蒙古银行 String s217 = &quot;^(622147|621633)\\\\d&#123;13&#125;$&quot;; String s218 = &quot;^(628252)\\\\d&#123;10&#125;$&quot;; String s219 = &quot;^(623001)\\\\d&#123;10&#125;$&quot;; String s220 = &quot;^(628227)\\\\d&#123;10&#125;$&quot;; String s221 = &quot;^(621456)\\\\d&#123;11&#125;$&quot;; String s222 = &quot;^(621562)\\\\d&#123;13&#125;$&quot;; String s223 = &quot;^(628219)\\\\d&#123;10&#125;$&quot;; String s224 = &quot;^(621037|621097|621588|622977)\\\\d&#123;13&#125;$&quot;; String s225 = &quot;^(62321601)\\\\d&#123;11&#125;$&quot;; String s226 = &quot;^(622475|622860)\\\\d&#123;10&#125;$&quot;; String s227 = &quot;^(625588)\\\\d&#123;10&#125;$&quot;; String s228 = &quot;^(622270|628368|625090|622644|628333)\\\\d&#123;10&#125;$&quot;; String s229 = &quot;^(623088)\\\\d&#123;13&#125;$&quot;; String s230 = &quot;^(622829|628301|622808|628308)\\\\d&#123;10&#125;$&quot;; String s231 = &quot;^(622127|622184|621701|621251|621589|623036)\\\\d&#123;13&#125;$&quot;; String s232 = &quot;^(628232|622802|622290)\\\\d&#123;10&#125;$&quot;; String s233 = &quot;^(622531|622329)\\\\d&#123;13&#125;$&quot;; String s234 = &quot;^(622829|628301)\\\\d&#123;10&#125;$&quot;; String s235 = &quot;^(621578|623066|622452|622324)\\\\d&#123;13&#125;$&quot;; String s236 = &quot;^(622815|622816|628226)\\\\d&#123;10&#125;$&quot;; String s237 = &quot;^(622906|628386|625519|625506)\\\\d&#123;10&#125;$&quot;; String s238 = &quot;^(621592)\\\\d&#123;10&#125;$&quot;; String s239 = &quot;^(628392)\\\\d&#123;10&#125;$&quot;; //商丘市商业银行 String s240 = &quot;^(621748)\\\\d&#123;13&#125;$&quot;; String s241 = &quot;^(628271)\\\\d&#123;10&#125;$&quot;; String s242 = &quot;^(621366|621388)\\\\d&#123;13&#125;$&quot;; String s243 = &quot;^(628328)\\\\d&#123;10&#125;$&quot;; String s244 = &quot;^(621239|623068)\\\\d&#123;13&#125;$&quot;; String s245 = &quot;^(621653004)\\\\d&#123;10&#125;$&quot;; String s246 = &quot;^(622169|621519|621539|623090)\\\\d&#123;13&#125;$&quot;; String s247 = &quot;^(621238|620528)\\\\d&#123;13&#125;$&quot;; String s248 = &quot;^(628382|625158)\\\\d&#123;10&#125;$&quot;; String s249 = &quot;^(621004)\\\\d&#123;12&#125;$&quot;; String s250 = &quot;^(628217)\\\\d&#123;10&#125;$&quot;; String s251 = &quot;^(621416)\\\\d&#123;10&#125;$&quot;; String s252 = &quot;^(628217)\\\\d&#123;10&#125;$&quot;; //德州银行 String s253 = &quot;^(622937)\\\\d&#123;13&#125;$&quot;; String s254 = &quot;^(628397)\\\\d&#123;10&#125;$&quot;; //德州银行 String ss254 = &quot;^(628397)\\\\d&#123;10&#125;$&quot;; //云南农村信用社 String s255 = &quot;^(622469|628307)\\\\d&#123;10&#125;$&quot;; //柳州银行 String s256 = &quot;^(622292|622291|621412)\\\\d&#123;12&#125;$&quot;; String s257 = &quot;^(622880|622881)\\\\d&#123;10&#125;$&quot;; String s258 = &quot;^(62829)\\\\d&#123;10&#125;$&quot;; String s259 = &quot;^(623102)\\\\d&#123;10&#125;$&quot;; String s260 = &quot;^(628234)\\\\d&#123;10&#125;$&quot;; String s261 = &quot;^(628306)\\\\d&#123;10&#125;$&quot;; String s262 = &quot;^(622391|940072)\\\\d&#123;10&#125;$&quot;; String s263 = &quot;^(628391)\\\\d&#123;10&#125;$&quot;; String s264 = &quot;^(622967|940073)\\\\d&#123;13&#125;$&quot;; String s265 = &quot;^(628233)\\\\d&#123;10&#125;$&quot;; String s266 = &quot;^(628257)\\\\d&#123;10&#125;$&quot;; String s267 = &quot;^(621269|622275)\\\\d&#123;10&#125;$&quot;; String s268 = &quot;^(940006)\\\\d&#123;11&#125;$&quot;; String s269 = &quot;^(628305)\\\\d&#123;11&#125;$&quot;; //贵阳银行 String s270 = &quot;^(622133|621735)\\\\d&#123;13&#125;$&quot;; String s271 = &quot;^(888)\\\\d&#123;13&#125;$&quot;; String s272 = &quot;^(628213)\\\\d&#123;10&#125;$&quot;; String s273 = &quot;^(622990|940003)\\\\d&#123;11&#125;$&quot;; String s274 = &quot;^(628261)\\\\d&#123;10&#125;$&quot;; String s275 = &quot;^(622311|940057)\\\\d&#123;11&#125;$&quot;; String s276 = &quot;^(628311)\\\\d&#123;10&#125;$&quot;; String s277 = &quot;^(622363|940048)\\\\d&#123;13&#125;$&quot;; String s278 = &quot;^(628270)\\\\d&#123;10&#125;$&quot;; // 葫芦岛市商业银行 String s279 = &quot;^(622398|940054)\\\\d&#123;10&#125;$&quot;; String s280 = &quot;^(940055)\\\\d&#123;11&#125;$&quot;; String s281 = &quot;^(622397)\\\\d&#123;11&#125;$&quot;; String s282 = &quot;^(603367|622878)\\\\d&#123;12&#125;$&quot;; String s283 = &quot;^(622397)\\\\d&#123;11&#125;$&quot;; String s284 = &quot;^(603506)\\\\d&#123;13&#125;$&quot;; String s285 = &quot;^(622399|940043)\\\\d&#123;11&#125;$&quot;; String s286 = &quot;^(622420|940041)\\\\d&#123;11&#125;$&quot;; String s287 = &quot;^(622338)\\\\d&#123;13&#125;$&quot;; String s288 = &quot;^(940032)\\\\d&#123;10&#125;$&quot;; String s289 = &quot;^(622394|940025)\\\\d&#123;10&#125;$&quot;; String s290 = &quot;^(621245)\\\\d&#123;10&#125;$&quot;; String s291 = &quot;^(621328)\\\\d&#123;13&#125;$&quot;; String s292 = &quot;^(621651)\\\\d&#123;13&#125;$&quot;; String s293 = &quot;^(621077)\\\\d&#123;10&#125;$&quot;; String s294 = &quot;^(622409|621441)\\\\d&#123;13&#125;$&quot;; String s295 = &quot;^(622410|621440)\\\\d&#123;11&#125;$&quot;; String s296 = &quot;^(622950|622951)\\\\d&#123;10&#125;$&quot;; String s297 = &quot;^(625026|625024|622376|622378|622377|625092)\\\\d&#123;10&#125;$&quot;; String s298 = &quot;^(622359|940066)\\\\d&#123;13&#125;$&quot;; String s299 = &quot;^(622886)\\\\d&#123;10&#125;$&quot;; String s300 = &quot;^(940008|622379)\\\\d&#123;13&#125;&quot;; String s301 = &quot;^(628379)\\\\d&#123;10&#125;$&quot;; String s302 = &quot;^(620011|620027|620031|620039|620103|620106|620120|620123|620125|620220|620278|620812|621006|621011|621012|621020|621023|621025|621027|621031|620132|621039|621078|621220|621003)\\\\d&#123;10&#125;$&quot;; String s303 = &quot;^(625003|625011|625012|625020|625023|625025|625027|625031|621032|625039|625078|625079|625103|625106|625006|625112|625120|625123|625125|625127|625131|625032|625139|625178|625179|625220|625320|625111|625132|625244)\\\\d&#123;10&#125;$&quot;; String s304 = &quot;^(622355|623042)\\\\d&#123;10&#125;$&quot;; String s305 = &quot;^(621043|621742)\\\\d&#123;13&#125;$&quot;; String s306 = &quot;^(622352|622353|625048|625053|625060)\\\\d&#123;10&#125;$&quot;; String s307 = &quot;^(620206|620207)\\\\d&#123;10&#125;$&quot;; String s308 = &quot;^(622547|622548|622546)\\\\d&#123;13&#125;$&quot;; String s309 = &quot;^(625198|625196|625147)\\\\d&#123;10&#125;$&quot;; String s310 = &quot;^(620072)\\\\d&#123;13&#125;$&quot;; String s311 = &quot;^(620204|620205)\\\\d&#123;10&#125;$&quot;; String s312 = &quot;^(621064|622941|622974)\\\\d&#123;10&#125;$&quot;; String s313 = &quot;^(622493)\\\\d&#123;10&#125;$&quot;; String s314 = &quot;^(621274|621324)\\\\d&#123;13&#125;$&quot;; /** * bankName : 中国邮政储蓄银行 * bankCode : PSBC * patterns : [&#123;&quot;reg&quot;:&quot;^(621096|621098|622150|622151|622181|622188|622199|955100|621095|620062|621285|621798|621799|621797|620529|621622|621599|621674|623218|623219)\\\\d&#123;13&#125;$&quot;,&quot;cardType&quot;:&quot;DC&quot;&#125;,&#123;&quot;reg&quot;:&quot;^(62215049|62215050|62215051|62218850|62218851|62218849)\\\\d&#123;11&#125;$&quot;,&quot;cardType&quot;:&quot;DC&quot;&#125;,&#123;&quot;reg&quot;:&quot;^(622812|622810|622811|628310|625919)\\\\d&#123;10&#125;$&quot;,&quot;cardType&quot;:&quot;CC&quot;&#125;] */ private String totalBankcode; private String bankName; private String bankCode; private String reg; private String cardType; //构造函数 public BankCardInfoBean(String totalBankcode) &#123; this.totalBankcode = totalBankcode; &#125; public String getBankName() &#123; if (Pattern.matches(s1, totalBankcode) || Pattern.matches(s2, totalBankcode) || Pattern.matches(s3, totalBankcode)) &#123; return &quot;邮储银行&quot;; &#125; else if (Pattern.matches(s4, totalBankcode) || Pattern.matches(s5, totalBankcode) || Pattern.matches(s6, totalBankcode) || Pattern.matches(s7, totalBankcode) || Pattern.matches(s8, totalBankcode) || Pattern.matches(s9, totalBankcode) || Pattern.matches(s10, totalBankcode) || Pattern.matches(s11, totalBankcode) || Pattern.matches(s12, totalBankcode) || Pattern.matches(s13, totalBankcode)) &#123; return &quot;工商银行&quot;; &#125; else if (Pattern.matches(s14, totalBankcode) || Pattern.matches(s15, totalBankcode) || Pattern.matches(s16, totalBankcode) || Pattern.matches(s17, totalBankcode) || Pattern.matches(s18, totalBankcode)) &#123; return &quot;农业银行&quot;; &#125; else if (Pattern.matches(s19, totalBankcode) || Pattern.matches(s20, totalBankcode) || Pattern.matches(s21, totalBankcode) || Pattern.matches(s22, totalBankcode) || Pattern.matches(s23, totalBankcode) || Pattern.matches(s24, totalBankcode) || Pattern.matches(s25, totalBankcode)) &#123; return &quot;中国银行&quot;; &#125; else if (Pattern.matches(s26, totalBankcode) || Pattern.matches(s27, totalBankcode) || Pattern.matches(s28, totalBankcode) || Pattern.matches(s29, totalBankcode) || Pattern.matches(s30, totalBankcode) || Pattern.matches(s31, totalBankcode) || Pattern.matches(s32, totalBankcode) || Pattern.matches(s33, totalBankcode)) &#123; return &quot;建设银行&quot;; &#125; else if (Pattern.matches(s34, totalBankcode) || Pattern.matches(s35, totalBankcode) || Pattern.matches(s36, totalBankcode) || Pattern.matches(s37, totalBankcode) || Pattern.matches(s38, totalBankcode) || Pattern.matches(s39, totalBankcode) || Pattern.matches(s40, totalBankcode)) &#123; return &quot;交通银行&quot;; &#125; else if (Pattern.matches(s41, totalBankcode) || Pattern.matches(s42, totalBankcode) || Pattern.matches(s43, totalBankcode) || Pattern.matches(s44, totalBankcode) || Pattern.matches(s45, totalBankcode) || Pattern.matches(s46, totalBankcode)) &#123; return &quot;招商银行&quot;; &#125; else if (Pattern.matches(s47, totalBankcode) || Pattern.matches(s48, totalBankcode) || Pattern.matches(s49, totalBankcode)) &#123; return &quot;民生银行&quot;; &#125; else if (Pattern.matches(s50, totalBankcode) || Pattern.matches(s51, totalBankcode) || Pattern.matches(s52, totalBankcode) || Pattern.matches(s53, totalBankcode) || Pattern.matches(s54, totalBankcode)) &#123; return &quot;光大银行&quot;; &#125; else if (Pattern.matches(s55, totalBankcode) || Pattern.matches(s56, totalBankcode) || Pattern.matches(s57, totalBankcode) || Pattern.matches(s58, totalBankcode)) &#123; return &quot;中信银行&quot;; &#125; else if (Pattern.matches(s59, totalBankcode) || Pattern.matches(s60, totalBankcode)) &#123; return &quot;华夏银行&quot;; &#125; else if (Pattern.matches(s61, totalBankcode) || Pattern.matches(s62, totalBankcode) || Pattern.matches(s63, totalBankcode) || Pattern.matches(s64, totalBankcode)) &#123; return &quot;平安银行&quot;; &#125; else if (Pattern.matches(s65, totalBankcode) || Pattern.matches(s66, totalBankcode) || Pattern.matches(s67, totalBankcode) || Pattern.matches(s68, totalBankcode) || Pattern.matches(s69, totalBankcode)) &#123; return &quot;兴业银行&quot;; &#125; else if (Pattern.matches(s70, totalBankcode) || Pattern.matches(s71, totalBankcode) || Pattern.matches(s72, totalBankcode)) &#123; return &quot;上海银行&quot;; &#125; else if (Pattern.matches(s73, totalBankcode) || Pattern.matches(s74, totalBankcode) || Pattern.matches(s75, totalBankcode) || Pattern.matches(s76, totalBankcode) || Pattern.matches(s77, totalBankcode)) &#123; return &quot;浦发银行&quot;; &#125; else if (Pattern.matches(s79, totalBankcode) || Pattern.matches(s80, totalBankcode) || Pattern.matches(s81, totalBankcode) || Pattern.matches(s82, totalBankcode)) &#123; return &quot;广发银行&quot;; &#125; else if (Pattern.matches(s83, totalBankcode)) &#123; return &quot;渤海银行&quot;; &#125; else if (Pattern.matches(s84, totalBankcode)) &#123; return &quot;广州银行&quot;; &#125; else if (Pattern.matches(s85, totalBankcode) || Pattern.matches(s86, totalBankcode)) &#123; return &quot;金华银行&quot;; &#125; else if (Pattern.matches(s87, totalBankcode) || Pattern.matches(s88, totalBankcode)) &#123; return &quot;温州银行&quot;; &#125; else if (Pattern.matches(s89, totalBankcode) || Pattern.matches(s90, totalBankcode) || Pattern.matches(s91, totalBankcode)) &#123; return &quot;徽商银行&quot;; &#125; else if (Pattern.matches(s92, totalBankcode) || Pattern.matches(s93, totalBankcode) || Pattern.matches(s94, totalBankcode)) &#123; return &quot;江苏银行&quot;; &#125; else if (Pattern.matches(s95, totalBankcode) || Pattern.matches(s96, totalBankcode)) &#123; return &quot;南京银行&quot;; &#125; else if (Pattern.matches(s97, totalBankcode) || Pattern.matches(s98, totalBankcode) || Pattern.matches(s99, totalBankcode)) &#123; return &quot;宁波银行&quot;; &#125; else if (Pattern.matches(s100, totalBankcode) || Pattern.matches(s101, totalBankcode)) &#123; return &quot;北京银行&quot;; &#125; else if (Pattern.matches(s102, totalBankcode) || Pattern.matches(s103, totalBankcode)) &#123; return &quot;北京农村商业银行&quot;; &#125; else if (Pattern.matches(s104, totalBankcode) || Pattern.matches(s105, totalBankcode) || Pattern.matches(s106, totalBankcode) || Pattern.matches(s107, totalBankcode)) &#123; return &quot;汇丰银行&quot;; &#125; else if (Pattern.matches(s108, totalBankcode) || Pattern.matches(s109, totalBankcode)) &#123; return &quot;渣打银行&quot;; &#125; else if (Pattern.matches(s110, totalBankcode) || Pattern.matches(s111, totalBankcode)) &#123; return &quot;花旗银行&quot;; &#125; else if (Pattern.matches(s112, totalBankcode) || Pattern.matches(s113, totalBankcode) || Pattern.matches(s114, totalBankcode)) &#123; return &quot;东亚银行&quot;; &#125; else if (Pattern.matches(s115, totalBankcode)) &#123; return &quot;广东华兴银行&quot;; &#125; else if (Pattern.matches(s116, totalBankcode)) &#123; return &quot;深圳农村商业银行&quot;; &#125; else if (Pattern.matches(s117, totalBankcode)) &#123; return &quot;广州农村商业银行&quot;; &#125; else if (Pattern.matches(s118, totalBankcode) || Pattern.matches(s119, totalBankcode)) &#123; return &quot;东莞农村商业银行&quot;; &#125; else if (Pattern.matches(s120, totalBankcode) || Pattern.matches(s121, totalBankcode) || Pattern.matches(s122, totalBankcode)) &#123; return &quot;东莞市商业银行&quot;; &#125; else if (Pattern.matches(s123, totalBankcode) || Pattern.matches(s124, totalBankcode)) &#123; return &quot;广东省农村信用社联合社&quot;; &#125; else if (Pattern.matches(s125, totalBankcode) || Pattern.matches(s126, totalBankcode) || Pattern.matches(s127, totalBankcode)) &#123; return &quot;大新银行&quot;; &#125; else if (Pattern.matches(s128, totalBankcode) || Pattern.matches(s129, totalBankcode)) &#123; return &quot;永享银行&quot;; &#125; else if (Pattern.matches(s130, totalBankcode) || Pattern.matches(s131, totalBankcode) || Pattern.matches(s132, totalBankcode)) &#123; return &quot;星展银行香港有限公司&quot;; &#125; else if (Pattern.matches(s133, totalBankcode) || Pattern.matches(s134, totalBankcode)) &#123; return &quot;恒丰银行&quot;; &#125; else if (Pattern.matches(s136, totalBankcode) || Pattern.matches(s135, totalBankcode) | Pattern.matches(s137, totalBankcode)) &#123; return &quot;天津市商业银行&quot;; &#125; else if (Pattern.matches(s138, totalBankcode) || Pattern.matches(s139, totalBankcode)) &#123; return &quot;浙商银行&quot;; &#125; else if (Pattern.matches(s140, totalBankcode) || Pattern.matches(s141, totalBankcode) || Pattern.matches(s142, totalBankcode) || Pattern.matches(s143, totalBankcode)) &#123; return &quot;南洋商业银行&quot;; &#125; else if (Pattern.matches(s144, totalBankcode) || Pattern.matches(s145, totalBankcode) || Pattern.matches(s146, totalBankcode)) &#123; return &quot;厦门银行&quot;; &#125; else if (Pattern.matches(s147, totalBankcode) || Pattern.matches(s148, totalBankcode) || Pattern.matches(s149, totalBankcode)) &#123; return &quot;福建海峡银行&quot;; &#125; else if (Pattern.matches(s150, totalBankcode) || Pattern.matches(s151, totalBankcode) || Pattern.matches(s152, totalBankcode)) &#123; return &quot;吉林银行&quot;; &#125; else if (Pattern.matches(s153, totalBankcode) || Pattern.matches(s154, totalBankcode)) &#123; return &quot;汉口银行&quot;; &#125; else if (Pattern.matches(s155, totalBankcode) || Pattern.matches(s156, totalBankcode) || Pattern.matches(s157, totalBankcode) || Pattern.matches(s158, totalBankcode)) &#123; return &quot;盛京银行&quot;; &#125; else if (Pattern.matches(s159, totalBankcode) || Pattern.matches(s160, totalBankcode) || Pattern.matches(s161, totalBankcode)) &#123; return &quot;大连银行&quot;; &#125; else if (Pattern.matches(s162, totalBankcode) || Pattern.matches(s163, totalBankcode)) &#123; return &quot;河北银行&quot;; &#125; else if (Pattern.matches(s164, totalBankcode) || Pattern.matches(s165, totalBankcode)) &#123; return &quot;乌鲁木齐商业银行&quot;; &#125; else if (Pattern.matches(s166, totalBankcode) || Pattern.matches(s167, totalBankcode) || Pattern.matches(s168, totalBankcode)) &#123; return &quot;绍兴银行&quot;; &#125; else if (Pattern.matches(s169, totalBankcode)) &#123; return &quot;成都商业银行&quot;; &#125; else if (Pattern.matches(s170, totalBankcode) || Pattern.matches(s171, totalBankcode) || Pattern.matches(s172, totalBankcode)) &#123; return &quot;抚顺银行&quot;; &#125; else if (Pattern.matches(s173, totalBankcode) || Pattern.matches(s174, totalBankcode) || Pattern.matches(s175, totalBankcode)) &#123; return &quot;郑州银行&quot;; &#125; else if (Pattern.matches(s176, totalBankcode) || Pattern.matches(s177, totalBankcode)) &#123; return &quot;宁夏银行&quot;; &#125; else if (Pattern.matches(s178, totalBankcode) || Pattern.matches(s179, totalBankcode)) &#123; return &quot;重庆银行&quot;; &#125; else if (Pattern.matches(s180, totalBankcode) || Pattern.matches(s181, totalBankcode) || Pattern.matches(s182, totalBankcode)) &#123; return &quot;哈尔滨银行&quot;; &#125; else if (Pattern.matches(s183, totalBankcode) || Pattern.matches(s184, totalBankcode)) &#123; return &quot;兰州银行&quot;; &#125; else if (Pattern.matches(s185, totalBankcode) || Pattern.matches(s186, totalBankcode)) &#123; return &quot;青岛银行&quot;; &#125; else if (Pattern.matches(s187, totalBankcode) || Pattern.matches(s188, totalBankcode)) &#123; return &quot;秦皇岛市商业银行&quot;; &#125; else if (Pattern.matches(s189, totalBankcode) || Pattern.matches(s190, totalBankcode) || Pattern.matches(s191, totalBankcode)) &#123; return &quot;青海银行&quot;; &#125; else if (Pattern.matches(s192, totalBankcode) || Pattern.matches(s193, totalBankcode) || Pattern.matches(s194, totalBankcode) || Pattern.matches(s195, totalBankcode) || Pattern.matches(s196, totalBankcode)) &#123; return &quot;台州银行&quot;; &#125; else if (Pattern.matches(s197, totalBankcode) || Pattern.matches(s198, totalBankcode) || Pattern.matches(s199, totalBankcode) || Pattern.matches(s200, totalBankcode)) &#123; return &quot;长沙银行&quot;; &#125; else if (Pattern.matches(s201, totalBankcode) || Pattern.matches(s202, totalBankcode) || Pattern.matches(s203, totalBankcode) || Pattern.matches(s204, totalBankcode)) &#123; return &quot;泉州银行&quot;; &#125; else if (Pattern.matches(s205, totalBankcode) || Pattern.matches(s206, totalBankcode) || Pattern.matches(s207, totalBankcode)) &#123; return &quot;包商银行&quot;; &#125; else if (Pattern.matches(s208, totalBankcode) || Pattern.matches(s209, totalBankcode) || Pattern.matches(s210, totalBankcode) || Pattern.matches(s211, totalBankcode)) &#123; return &quot;龙江银行&quot;; &#125; else if (Pattern.matches(s212, totalBankcode) || Pattern.matches(s213, totalBankcode) || Pattern.matches(s214, totalBankcode)) &#123; return &quot;上海农商银行&quot;; &#125; else if (Pattern.matches(s215, totalBankcode) || Pattern.matches(s216, totalBankcode)) &#123; return &quot;浙江泰隆商业银行&quot;; &#125; else if (Pattern.matches(s217, totalBankcode) || Pattern.matches(s218, totalBankcode)) &#123; return &quot;内蒙古银行&quot;; &#125; else if (Pattern.matches(s219, totalBankcode) || Pattern.matches(s220, totalBankcode)) &#123; return &quot;广西北部湾银行&quot;; &#125; else if (Pattern.matches(s221, totalBankcode) || Pattern.matches(s222, totalBankcode) || Pattern.matches(s223, totalBankcode)) &#123; return &quot;桂林银行&quot;; &#125; else if (Pattern.matches(s224, totalBankcode) || Pattern.matches(s225, totalBankcode) || Pattern.matches(s226, totalBankcode) || Pattern.matches(s227, totalBankcode) || Pattern.matches(s228, totalBankcode)) &#123; return &quot;龙江银行&quot;; &#125; else if (Pattern.matches(s229, totalBankcode) || Pattern.matches(s230, totalBankcode)) &#123; return &quot;成都农村商业银行&quot;; &#125; else if (Pattern.matches(s231, totalBankcode) || Pattern.matches(s232, totalBankcode)) &#123; return &quot;福建省农村信用社联合社&quot;; &#125; else if (Pattern.matches(s233, totalBankcode) || Pattern.matches(s234, totalBankcode)) &#123; return &quot;天津农村商业银行&quot;; &#125; else if (Pattern.matches(s235, totalBankcode) || Pattern.matches(s236, totalBankcode)) &#123; return &quot;江苏省农村信用社联合社&quot;; &#125; else if (Pattern.matches(s237, totalBankcode)) &#123; return &quot;湖南省农村信用社联合社&quot;; &#125; else if (Pattern.matches(s238, totalBankcode) || Pattern.matches(s239, totalBankcode)) &#123; return &quot;江西省农村信用社联合社&quot;; &#125; else if (Pattern.matches(s240, totalBankcode) || Pattern.matches(s241, totalBankcode)) &#123; return &quot;商丘市商业银行&quot;; &#125; else if (Pattern.matches(s242, totalBankcode) || Pattern.matches(s243, totalBankcode)) &#123; return &quot;华融湘江银行&quot;; &#125; else if (Pattern.matches(s244, totalBankcode)) &#123; return &quot;衡水市商业银行&quot;; &#125; else if (Pattern.matches(s245, totalBankcode)) &#123; return &quot;重庆南川石银村镇银行&quot;; &#125; else if (Pattern.matches(s246, totalBankcode)) &#123; return &quot;湖南省农村信用社联合社&quot;; &#125; else if (Pattern.matches(s247, totalBankcode)) &#123; return &quot;邢台银行&quot;; &#125; else if (Pattern.matches(s248, totalBankcode)) &#123; return &quot;临汾市尧都区农村信用合作联社&quot;; &#125; else if (Pattern.matches(s249, totalBankcode) || Pattern.matches(s250, totalBankcode)) &#123; return &quot;东营银行&quot;; &#125; else if (Pattern.matches(s251, totalBankcode) || Pattern.matches(s252, totalBankcode)) &#123; return &quot;上饶银行&quot;; &#125; else if (Pattern.matches(s253, totalBankcode) || Pattern.matches(s254, totalBankcode)) &#123; return &quot;德州银行&quot;; &#125; else if (Pattern.matches(ss254, totalBankcode)) &#123; return &quot;承德银行&quot;; &#125; else if (Pattern.matches(s255, totalBankcode)) &#123; return &quot;云南农村信用社&quot;; &#125; else if (Pattern.matches(s257, totalBankcode) || Pattern.matches(s258, totalBankcode) || Pattern.matches(s256, totalBankcode)) &#123; return &quot;柳州银行&quot;; &#125; else if (Pattern.matches(s259, totalBankcode) || Pattern.matches(s260, totalBankcode)) &#123; return &quot;威海市商业银行&quot;; &#125; else if (Pattern.matches(s261, totalBankcode)) &#123; return &quot;湖州银行&quot;; &#125; else if (Pattern.matches(s262, totalBankcode) || Pattern.matches(s263, totalBankcode)) &#123; return &quot;潍坊银行&quot;; &#125; else if (Pattern.matches(s264, totalBankcode) || Pattern.matches(s265, totalBankcode)) &#123; return &quot;赣州银行&quot;; &#125; else if (Pattern.matches(s266, totalBankcode)) &#123; return &quot;日照银行&quot;; &#125; else if (Pattern.matches(s267, totalBankcode) || Pattern.matches(s268, totalBankcode) || Pattern.matches(s269, totalBankcode)) &#123; return &quot;南昌银行&quot;; &#125; else if (Pattern.matches(s270, totalBankcode) || Pattern.matches(s271, totalBankcode) || Pattern.matches(s272, totalBankcode)) &#123; return &quot;贵阳银行&quot;; &#125; else if (Pattern.matches(s273, totalBankcode) || Pattern.matches(s274, totalBankcode)) &#123; return &quot;锦州银行&quot;; &#125; else if (Pattern.matches(s275, totalBankcode) || Pattern.matches(s276, totalBankcode)) &#123; return &quot;齐商银行&quot;; &#125; else if (Pattern.matches(s277, totalBankcode) || Pattern.matches(s278, totalBankcode)) &#123; return &quot;珠海华润银行&quot;; &#125; else if (Pattern.matches(s279, totalBankcode)) &#123; return &quot;葫芦岛市商业银行&quot;; &#125; else if (Pattern.matches(s280, totalBankcode) || Pattern.matches(s281, totalBankcode)) &#123; return &quot;宜昌市商业银行&quot;; &#125; else if (Pattern.matches(s282, totalBankcode) || Pattern.matches(s283, totalBankcode)) &#123; return &quot;杭州商业银行&quot;; &#125; else if (Pattern.matches(s284, totalBankcode)) &#123; return &quot;苏州市商业银行&quot;; &#125; else if (Pattern.matches(s285, totalBankcode)) &#123; return &quot;辽阳银行&quot;; &#125; else if (Pattern.matches(s286, totalBankcode)) &#123; return &quot;洛阳银行&quot;; &#125; else if (Pattern.matches(s287, totalBankcode) || Pattern.matches(s288, totalBankcode)) &#123; return &quot;焦作市商业银行&quot;; &#125; else if (Pattern.matches(s289, totalBankcode)) &#123; return &quot;镇江市商业银行&quot;; &#125; else if (Pattern.matches(s290, totalBankcode)) &#123; return &quot;法国兴业银行&quot;; &#125; else if (Pattern.matches(s291, totalBankcode)) &#123; return &quot;大华银行&quot;; &#125; else if (Pattern.matches(s292, totalBankcode)) &#123; return &quot;企业银行&quot;; &#125; else if (Pattern.matches(s293, totalBankcode)) &#123; return &quot;华侨银行&quot;; &#125; else if (Pattern.matches(s294, totalBankcode) || Pattern.matches(s295, totalBankcode) || Pattern.matches(s296, totalBankcode) || Pattern.matches(s297, totalBankcode)) &#123; return &quot;恒生银行&quot;; &#125; else if (Pattern.matches(s298, totalBankcode)) &#123; return &quot;临沂商业银行&quot;; &#125; else if (Pattern.matches(s299, totalBankcode)) &#123; return &quot;烟台商业银行&quot;; &#125; else if (Pattern.matches(s300, totalBankcode) || Pattern.matches(s301, totalBankcode)) &#123; return &quot;齐鲁银行&quot;; &#125; else if (Pattern.matches(s302, totalBankcode) || Pattern.matches(s303, totalBankcode)) &#123; return &quot;BC卡公司&quot;; &#125; else if (Pattern.matches(s304, totalBankcode) || Pattern.matches(s305, totalBankcode) || Pattern.matches(s306, totalBankcode) || Pattern.matches(s307, totalBankcode)) &#123; return &quot;集友银行&quot;; &#125; else if (Pattern.matches(s308, totalBankcode) || Pattern.matches(s309, totalBankcode) || Pattern.matches(s310, totalBankcode) || Pattern.matches(s311, totalBankcode)) &#123; return &quot;大丰银行&quot;; &#125; else if (Pattern.matches(s312, totalBankcode) || Pattern.matches(s313, totalBankcode)) &#123; return &quot;AEON信贷财务亚洲有限公司&quot;; &#125; else if (Pattern.matches(s314, totalBankcode)) &#123; return &quot;澳门BDA&quot;; &#125; else &#123; return &quot;未知&quot;; &#125; &#125; public void setBankName(String bankName) &#123; this.bankName = bankName; &#125; public String getBankCode() &#123; return bankCode; &#125; public void setBankCode(String bankCode) &#123; this.bankCode = bankCode; &#125; public String getReg() &#123; return reg; &#125; public void setReg(String reg) &#123; this.reg = reg; &#125; public String getCardType() &#123; if (Pattern.matches(s1, totalBankcode) || Pattern.matches(s2, totalBankcode) || Pattern.matches(s4, totalBankcode) || Pattern.matches(s5, totalBankcode) || Pattern.matches(s6, totalBankcode) || Pattern.matches(s7, totalBankcode) || Pattern.matches(s14, totalBankcode) || Pattern.matches(s15, totalBankcode) || Pattern.matches(s16, totalBankcode) || Pattern.matches(s19, totalBankcode) || Pattern.matches(s20, totalBankcode) || Pattern.matches(s26, totalBankcode) || Pattern.matches(s27, totalBankcode) || Pattern.matches(s28, totalBankcode) || Pattern.matches(s34, totalBankcode) || Pattern.matches(s35, totalBankcode) || Pattern.matches(s36, totalBankcode) || Pattern.matches(s41, totalBankcode) || Pattern.matches(s42, totalBankcode) || Pattern.matches(s43, totalBankcode) || Pattern.matches(s47, totalBankcode) || Pattern.matches(s50, totalBankcode) || Pattern.matches(s51, totalBankcode) || Pattern.matches(s52, totalBankcode) || Pattern.matches(s53, totalBankcode) || Pattern.matches(s55, totalBankcode) || Pattern.matches(s56, totalBankcode) || Pattern.matches(s59, totalBankcode) || Pattern.matches(s61, totalBankcode) || Pattern.matches(s62, totalBankcode) || Pattern.matches(s65, totalBankcode) || Pattern.matches(s66, totalBankcode) || Pattern.matches(s67, totalBankcode) || Pattern.matches(s70, totalBankcode) || Pattern.matches(s71, totalBankcode) || Pattern.matches(s73, totalBankcode) || Pattern.matches(s74, totalBankcode) || Pattern.matches(s79, totalBankcode) || Pattern.matches(s80, totalBankcode) || Pattern.matches(s83, totalBankcode) || Pattern.matches(s84, totalBankcode) || Pattern.matches(s85, totalBankcode) || Pattern.matches(s87, totalBankcode) || Pattern.matches(s89, totalBankcode) || Pattern.matches(s90, totalBankcode) || Pattern.matches(s92, totalBankcode) || Pattern.matches(s93, totalBankcode) || Pattern.matches(s95, totalBankcode) || Pattern.matches(s97, totalBankcode) || Pattern.matches(s98, totalBankcode) || Pattern.matches(s100, totalBankcode) || Pattern.matches(s102, totalBankcode) || Pattern.matches(s104, totalBankcode) || Pattern.matches(s105, totalBankcode) || Pattern.matches(s106, totalBankcode) || Pattern.matches(s108, totalBankcode) || Pattern.matches(s110, totalBankcode) || Pattern.matches(s112, totalBankcode) || Pattern.matches(s115, totalBankcode) || Pattern.matches(s116, totalBankcode) || Pattern.matches(s117, totalBankcode) || Pattern.matches(s118, totalBankcode) || Pattern.matches(s120, totalBankcode) || Pattern.matches(s121, totalBankcode) || Pattern.matches(s123, totalBankcode) || Pattern.matches(s124, totalBankcode) || Pattern.matches(s125, totalBankcode) || Pattern.matches(s126, totalBankcode) || Pattern.matches(s128, totalBankcode) || Pattern.matches(s130, totalBankcode) || Pattern.matches(s131, totalBankcode) || Pattern.matches(s132, totalBankcode) || Pattern.matches(s133, totalBankcode) || Pattern.matches(s134, totalBankcode) | Pattern.matches(s135, totalBankcode) | Pattern.matches(s136, totalBankcode) || Pattern.matches(s138, totalBankcode) || Pattern.matches(s139, totalBankcode) || Pattern.matches(s140, totalBankcode) || Pattern.matches(s141, totalBankcode) || Pattern.matches(s144, totalBankcode) || Pattern.matches(s145, totalBankcode) || Pattern.matches(s146, totalBankcode) || Pattern.matches(s147, totalBankcode) || Pattern.matches(s148, totalBankcode) || Pattern.matches(s150, totalBankcode) || Pattern.matches(s151, totalBankcode) || Pattern.matches(s152, totalBankcode) || Pattern.matches(s153, totalBankcode) || Pattern.matches(s154, totalBankcode) || Pattern.matches(s155, totalBankcode) || Pattern.matches(s156, totalBankcode) || Pattern.matches(s157, totalBankcode) || Pattern.matches(s159, totalBankcode) || Pattern.matches(s160, totalBankcode) || Pattern.matches(s162, totalBankcode) || Pattern.matches(s164, totalBankcode) || Pattern.matches(s166, totalBankcode) || Pattern.matches(s167, totalBankcode) || Pattern.matches(s169, totalBankcode) || Pattern.matches(s170, totalBankcode) || Pattern.matches(s171, totalBankcode) || Pattern.matches(s172, totalBankcode) || Pattern.matches(s173, totalBankcode) || Pattern.matches(s174, totalBankcode) || Pattern.matches(s175, totalBankcode) || Pattern.matches(s176, totalBankcode) || Pattern.matches(s178, totalBankcode) || Pattern.matches(s179, totalBankcode) || Pattern.matches(s180, totalBankcode) || Pattern.matches(s181, totalBankcode) || Pattern.matches(s182, totalBankcode) || Pattern.matches(s183, totalBankcode) || Pattern.matches(s184, totalBankcode) || Pattern.matches(s185, totalBankcode) || Pattern.matches(s186, totalBankcode) || Pattern.matches(s187, totalBankcode) || Pattern.matches(s188, totalBankcode) || Pattern.matches(s189, totalBankcode) || Pattern.matches(s192, totalBankcode) || Pattern.matches(s193, totalBankcode) || Pattern.matches(s194, totalBankcode) || Pattern.matches(s197, totalBankcode) || Pattern.matches(s198, totalBankcode) || Pattern.matches(s201, totalBankcode) || Pattern.matches(s202, totalBankcode) || Pattern.matches(s203, totalBankcode) || Pattern.matches(s205, totalBankcode) || Pattern.matches(s206, totalBankcode) || Pattern.matches(s208, totalBankcode) || Pattern.matches(s209, totalBankcode) || Pattern.matches(s210, totalBankcode) || Pattern.matches(s212, totalBankcode) || Pattern.matches(s217, totalBankcode) || Pattern.matches(s219, totalBankcode) || Pattern.matches(s221, totalBankcode) || Pattern.matches(s222, totalBankcode) || Pattern.matches(s224, totalBankcode) || Pattern.matches(s225, totalBankcode) || Pattern.matches(s226, totalBankcode) || Pattern.matches(s229, totalBankcode) || Pattern.matches(s231, totalBankcode) || Pattern.matches(s233, totalBankcode) || Pattern.matches(s235, totalBankcode) || Pattern.matches(s238, totalBankcode) || Pattern.matches(s240, totalBankcode) || Pattern.matches(s242, totalBankcode) || Pattern.matches(s244, totalBankcode) || Pattern.matches(s245, totalBankcode) || Pattern.matches(s246, totalBankcode) || Pattern.matches(s247, totalBankcode) || Pattern.matches(s249, totalBankcode) || Pattern.matches(s251, totalBankcode) || Pattern.matches(s253, totalBankcode) || Pattern.matches(s256, totalBankcode) || Pattern.matches(s257, totalBankcode) || Pattern.matches(s259, totalBankcode) || Pattern.matches(s262, totalBankcode) || Pattern.matches(s264, totalBankcode) || Pattern.matches(s267, totalBankcode) || Pattern.matches(s268, totalBankcode) || Pattern.matches(s270, totalBankcode) || Pattern.matches(s271, totalBankcode) || Pattern.matches(s273, totalBankcode) || Pattern.matches(s275, totalBankcode) || Pattern.matches(s277, totalBankcode) || Pattern.matches(s279, totalBankcode) || Pattern.matches(s280, totalBankcode) || Pattern.matches(s282, totalBankcode) || Pattern.matches(s284, totalBankcode) || Pattern.matches(s285, totalBankcode) || Pattern.matches(s286, totalBankcode) || Pattern.matches(s287, totalBankcode) || Pattern.matches(s288, totalBankcode) || Pattern.matches(s289, totalBankcode) || Pattern.matches(s290, totalBankcode) || Pattern.matches(s291, totalBankcode) || Pattern.matches(s292, totalBankcode) || Pattern.matches(s293, totalBankcode) || Pattern.matches(s294, totalBankcode) || Pattern.matches(s295, totalBankcode) || Pattern.matches(s296, totalBankcode) || Pattern.matches(s298, totalBankcode) || Pattern.matches(s299, totalBankcode) || Pattern.matches(s300, totalBankcode) || Pattern.matches(s302, totalBankcode) || Pattern.matches(s304, totalBankcode) || Pattern.matches(s305, totalBankcode) || Pattern.matches(s308, totalBankcode) || Pattern.matches(s309, totalBankcode) || Pattern.matches(s312, totalBankcode) || Pattern.matches(s314, totalBankcode)) &#123; return &quot;储蓄卡&quot;; &#125; else if (Pattern.matches(s3, totalBankcode) || Pattern.matches(s8, totalBankcode) || Pattern.matches(s9, totalBankcode) || Pattern.matches(s10, totalBankcode) || Pattern.matches(s17, totalBankcode) || Pattern.matches(s21, totalBankcode) || Pattern.matches(s29, totalBankcode) || Pattern.matches(s30, totalBankcode) || Pattern.matches(s31, totalBankcode) || Pattern.matches(s37, totalBankcode) || Pattern.matches(s38, totalBankcode) || Pattern.matches(s44, totalBankcode) || Pattern.matches(s45, totalBankcode) || Pattern.matches(s48, totalBankcode) || Pattern.matches(s49, totalBankcode) || Pattern.matches(s54, totalBankcode) || Pattern.matches(s57, totalBankcode) || Pattern.matches(s58, totalBankcode) || Pattern.matches(s60, totalBankcode) || Pattern.matches(s63, totalBankcode) || Pattern.matches(s68, totalBankcode) || Pattern.matches(s72, totalBankcode) || Pattern.matches(s75, totalBankcode) || Pattern.matches(s81, totalBankcode) || Pattern.matches(s82, totalBankcode) || Pattern.matches(s86, totalBankcode) || Pattern.matches(s88, totalBankcode) || Pattern.matches(s91, totalBankcode) || Pattern.matches(s94, totalBankcode) || Pattern.matches(s96, totalBankcode) || Pattern.matches(s99, totalBankcode) || Pattern.matches(s101, totalBankcode) || Pattern.matches(s103, totalBankcode) || Pattern.matches(s107, totalBankcode) || Pattern.matches(s109, totalBankcode) || Pattern.matches(s111, totalBankcode) || Pattern.matches(s113, totalBankcode) || Pattern.matches(s114, totalBankcode) || Pattern.matches(s119, totalBankcode) || Pattern.matches(s122, totalBankcode) || Pattern.matches(s127, totalBankcode) || Pattern.matches(s129, totalBankcode) | Pattern.matches(s137, totalBankcode) || Pattern.matches(s142, totalBankcode) || Pattern.matches(s158, totalBankcode) || Pattern.matches(s161, totalBankcode) || Pattern.matches(s163, totalBankcode) || Pattern.matches(s165, totalBankcode) || Pattern.matches(s167, totalBankcode) || Pattern.matches(s177, totalBankcode) || Pattern.matches(s191, totalBankcode) || Pattern.matches(s190, totalBankcode) || Pattern.matches(s195, totalBankcode) || Pattern.matches(s199, totalBankcode) || Pattern.matches(s204, totalBankcode) || Pattern.matches(s207, totalBankcode) || Pattern.matches(s211, totalBankcode) || Pattern.matches(s214, totalBankcode) || Pattern.matches(s216, totalBankcode) || Pattern.matches(s218, totalBankcode) || Pattern.matches(s220, totalBankcode) || Pattern.matches(s223, totalBankcode) || Pattern.matches(s228, totalBankcode) || Pattern.matches(s230, totalBankcode) || Pattern.matches(s232, totalBankcode) || Pattern.matches(s234, totalBankcode) || Pattern.matches(s236, totalBankcode) || Pattern.matches(s237, totalBankcode) || Pattern.matches(s239, totalBankcode) || Pattern.matches(s241, totalBankcode) || Pattern.matches(s243, totalBankcode) || Pattern.matches(s248, totalBankcode) || Pattern.matches(s250, totalBankcode) || Pattern.matches(s252, totalBankcode) || Pattern.matches(s254, totalBankcode) || Pattern.matches(ss254, totalBankcode) || Pattern.matches(s255, totalBankcode) || Pattern.matches(s258, totalBankcode) || Pattern.matches(s260, totalBankcode) || Pattern.matches(s261, totalBankcode) || Pattern.matches(s263, totalBankcode) || Pattern.matches(s265, totalBankcode) || Pattern.matches(s266, totalBankcode) || Pattern.matches(s269, totalBankcode) || Pattern.matches(s272, totalBankcode) || Pattern.matches(s274, totalBankcode) || Pattern.matches(s276, totalBankcode) || Pattern.matches(s278, totalBankcode) || Pattern.matches(s281, totalBankcode) || Pattern.matches(s283, totalBankcode) || Pattern.matches(s297, totalBankcode) || Pattern.matches(s301, totalBankcode) || Pattern.matches(s303, totalBankcode) || Pattern.matches(s306, totalBankcode) || Pattern.matches(s313, totalBankcode)) &#123; return &quot;信用卡&quot;; &#125; else if (Pattern.matches(s11, totalBankcode) || Pattern.matches(s18, totalBankcode) || Pattern.matches(s22, totalBankcode) || Pattern.matches(s23, totalBankcode) || Pattern.matches(s32, totalBankcode) || Pattern.matches(s33, totalBankcode) || Pattern.matches(s39, totalBankcode) || Pattern.matches(s76, totalBankcode) || Pattern.matches(s196, totalBankcode) || Pattern.matches(s213, totalBankcode) || Pattern.matches(s215, totalBankcode) || Pattern.matches(s227, totalBankcode)) &#123; return &quot;准贷记卡&quot;; &#125; else if (Pattern.matches(s12, totalBankcode) || Pattern.matches(s13, totalBankcode) || Pattern.matches(s24, totalBankcode) || Pattern.matches(s25, totalBankcode) || Pattern.matches(s40, totalBankcode) || Pattern.matches(s46, totalBankcode) || Pattern.matches(s64, totalBankcode) || Pattern.matches(s69, totalBankcode) || Pattern.matches(s77, totalBankcode) || Pattern.matches(s143, totalBankcode) || Pattern.matches(s149, totalBankcode) || Pattern.matches(s200, totalBankcode) || Pattern.matches(s307, totalBankcode) || Pattern.matches(s310, totalBankcode) || Pattern.matches(s311, totalBankcode)) &#123; return &quot;预付费卡&quot;; &#125; else &#123; return &quot;未知&quot;; &#125; &#125; public void setCardType(String cardType) &#123; this.cardType = cardType; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Androd-开机自启动/","text":"###使用: 12345678910//屏幕解锁解锁权限 &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;//清单文件注册 &lt;receiver android:name=&quot;.service.StartupReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.QUICKBOOT_POWERON&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.jetshine.room_flat_moudle.service;import android.annotation.SuppressLint;import android.app.KeyguardManager;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.os.PowerManager;import android.util.Log;import com.jetshine.room_flat_moudle.MainActivity;/** * Created by shinelon on 2018/9/18. */public class StartupReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.i(&quot;jjc&quot;,intent.getAction()); //开机后一般会停留在锁屏页面且短时间内没有进行解锁操作屏幕会进入休眠状态，此时就需要先唤醒屏幕和解锁屏幕 //屏幕唤醒 PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE); @SuppressLint(&quot;InvalidWakeLockTag&quot;) PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;StartupReceiver&quot;);//最后的参数是LogCat里用的Tag wl.acquire(); //屏幕解锁 KeyguardManager km= (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE); KeyguardManager.KeyguardLock kl = km.newKeyguardLock(&quot;StartupReceiver&quot;);//参数是LogCat里用的Tag kl.disableKeyguard(); //开机启动 Intent mainIntent = new Intent(context, MainActivity.class); //在BroadcastReceiver中显示Activity，必须要设置FLAG_ACTIVITY_NEW_TASK标志 mainIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(mainIntent); &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android-在没有usb连接线的情况下如何连接手机设备/","text":"机设备上安装终端模拟器 下载地址是：https://jackpal.github.io/Android-Terminal-Emulator/ 打开链接，有个term.apk共同连接同一个局域网将手机设备与本地要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。打开 Android 设备上的终端模拟器在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 看ip 12之后ifconfig看下android 设备的ip此时如果直接adb connect ip:5555 可能会出现Connection refused 你需要做的是: 12stop adbdstart adbd 之后在重新连接即可","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android保活/","text":"1&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt; ####1.准备一个前台BackGroundService 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.guoshikeji.xiaoxiangDriver.services;import android.annotation.SuppressLint;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.IBinder;import com.guoshikeji.xiaoxiangDriver.MainActivity;import com.guoshikeji.xiaoxiangDriver.R;import static android.app.Notification.PRIORITY_MAX;/** * Created by tyl * 2019/11/12/012 * Describe: */public class BackGroundService extends Service &#123; Notification notification; private Context mContext; private static Thread uploadGpsThread; private MediaPlayer bgmediaPlayer; private boolean isrun = true; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; mContext = this; Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT); //1.通知栏占用，不清楚的看官网或者音乐类APP的效果 notification = new Notification.Builder(mContext) .setSmallIcon(R.mipmap.icon_notifacation_log) .setWhen(System.currentTimeMillis()) .setTicker(getResources().getString(R.string.app_name)) .setContentTitle(getResources().getString(R.string.app_name)) .setContentText(&quot;正在后台运行&quot;) .setOngoing(true) .setPriority(PRIORITY_MAX) .setContentIntent(pendingIntent) .setAutoCancel(false) .build(); /*使用startForeground,如果id为0，那么notification将不会显示*/ startForeground(2479, buildNotification()); //2.最关键的神来之笔，也是最投机的动作，没办法要骗过CPU //这就是播放音乐类APP不被杀的做法，自己找个无声MP3放进来循环播放 if(bgmediaPlayer == null)&#123; bgmediaPlayer = MediaPlayer.create(this,R.raw.slient); bgmediaPlayer.setLooping(true); bgmediaPlayer.start(); &#125; return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125; @Override public void onDestroy() &#123; isrun = false; stopForeground(true); bgmediaPlayer.release(); stopSelf(); super.onDestroy(); &#125; private NotificationManager notificationManager; private boolean isCreateChannel = false; @SuppressLint(&quot;NewApi&quot;) private Notification buildNotification() &#123; Notification.Builder builder = null; Notification notification = null; if (android.os.Build.VERSION.SDK_INT &gt;= 26) &#123; if (null == notificationManager) &#123; notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); &#125; String channelId = getPackageName(); if (!isCreateChannel) &#123; NotificationChannel notificationChannel = new NotificationChannel(channelId, &quot;BackgroundLocation&quot;, NotificationManager.IMPORTANCE_DEFAULT); notificationChannel.enableLights(false);//是否在桌面icon右上角展示小圆点 notificationChannel.setShowBadge(true); //是否在久按桌面图标时显示此渠道的通知 notificationManager.createNotificationChannel(notificationChannel); isCreateChannel = true; &#125; builder = new Notification.Builder(getApplicationContext(), channelId); &#125; else &#123; builder = new Notification.Builder(getApplicationContext()); &#125; builder.setSmallIcon(R.mipmap.icon_notifacation_log) .setColor(getResources().getColor(R.color.main_color)) .setContentTitle(getResources().getString(R.string.app_name)) .setContentText(&quot;正在后台运行&quot;) .setWhen(System.currentTimeMillis()); if (android.os.Build.VERSION.SDK_INT &gt;= 16) &#123; notification = builder.build(); &#125; else &#123; return builder.getNotification(); &#125; return notification; &#125;&#125; ###2. 在对应的activity里显示开启service 12Intent forgroundService = new Intent(this,BackGroundService.class); startService(forgroundService); ###3. 在AndroidManifest.xml文件里申明service 1234&lt;service android:name=&quot;.BackGroundService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android将String分割转化为ArrayList/","text":"1234567//itemName要处理的字符串,.split(分割的标识字符&#x27;,&#x27;) String itemName=&quot;项目1,项目2,项目3&quot;; List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(Arrays.asList(itemName.split(&quot;,&quot;))); for (int i = 0; i &lt;nameList.size() ; i++) &#123; Log.e(&quot;tyl&quot;,&quot;name=&quot;+nameList.get(i)); &#125; //结果:项目1 项目2 项目3","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android第三方常用安全漏洞检测/","text":"0×01 五大在线检测平台腾讯的金刚审计系统 http://service.security.tencent.com/kingkong 360的捉虫猎手 http://appscan.360.cn/ 阿里巴巴的聚安全http://jaq.alibaba.com/gc/appsec/index.htm 百度的移动云测试中心http://mtc.baidu.com/ 梆梆加固测试平台（http://dev.bangcle.com/apps/index） 效果对比这里选用墨迹天气app的测试结果 百度移动测试中心| 漏洞名称 | 风险级别 | 说明 | 修复建议 | 详情 || 组件暴露——Activity | 中危 | 当应用程序的组件被导出后，导出的组件可以被第三方app任意调用，从而导致敏感信息泄露，而且恶意攻击者也可以通过精心构造数据来达到攻击目标应用的的目的。 | 如果组件不需要与其他应用共享数据或进行交互，则在AndroidManifest.xml文件中设置该组件为 exported &#x3D; “false”，反之，则需要对导出的组件进行权限控制并且严格校验传入的参数。 | com.moji.mjweather.activity.main.MainActivity com.moji.mjweather.CSplashScreen com.moji.mjweather.activity.share.ManualShareActivity com.moji.mjweather.activity.skinshop.SkinSelectorActivity com.kepler.jd.login.AuthSuccessActivity com.moji.mjweather.activity.liveview.MessageDetailActivity com.moji.mjweather.activity.liveview.OwnerMessageCenterActivity com.moji.mjweather.activity.account.SnsLoginActivity com.moji.mjweather.activity.liveview.HomePageActivity com.moji.mjweather.activity.voiceclock.AlarmAlertActivity com.moji.mjweather.activity.voiceclock.AlarmAlertFullScreenActivity com.moji.mjweather.activity.share.SharePlatformDialog com.tencent.tauth.AuthActivity com.moji.mjweather.activity.liveview.LauncherCameraActivity com.moji.mjweather.activity.bindapp.InstallAppActivity com.moji.mjweather.activity.settings.WidgetConfigureActivity com.igexin.sdk.GActivity com.moji.mjweather.wxapi.WXPayEntryActivity com.moji.mjweather.wxapi.WXEntryActivity com.moji.mjweather.activity.forum.TopicActivity com.moji.mjweather.x5webview.BrowserActivity 共：21个。 || 组件暴露——Service | 中危 | 当应用程序的组件被导出后，导出的组件可以被第三方app任意调用，从而导致敏感信息泄露，而且恶意攻击者也可以通过精心构造数据来达到攻击目标应用的的目的。 | 如果组件不需要与其他应用共享数据或进行交互，则在AndroidManifest.xml文件中设置该组件为 exported &#x3D; “false”，反之，则需要对导出的组件进行权限控制并且严格校验传入的参数。 | com.moji.mjweather.service.ScreenService com.igexin.sdk.PushService com.igexin.sdk.PushServiceUser com.moji.mjweather.authaccount.AuthenticationService com.moji.mjweather.authaccount.SyncService 共：5个。 || 组件暴露——BroadcastReceiver | 中危 | 当应用程序的组件被导出后，导出的组件可以被第三方app任意调用，从而导致敏感信息泄露，而且恶意攻击者也可以通过精心构造数据来达到攻击目标应用的的目的。 | 如果组件不需要与其他应用共享数据或进行交互，则在AndroidManifest.xml文件中设置该组件为 exported &#x3D; “false”，反之，则需要对导出的组件进行权限控制并且严格校验传入的参数。 | com.moji.mjweather.receiver.PackageReceiver com.moji.mjweather.receiver.MojiReceiver com.moji.mjweather.CMojiWidget4x1 com.moji.mjweather.CMojiWidget4x2 com.moji.mjweather.CMojiWidget5x1 com.moji.mjweather.CMojiWidget5x2 com.igexin.sdk.PushReceiver com.igexin.download.DownloadReceiver com.baidu.bottom.service.BottomReceiver com.zk.drivermonitor.reciever.SystemStartReceiver 共：10个。 || 应用数据任意备份风险 | 中危 | 当AndroidManifest.xml配置文件中没有有设置allowBackup标志(默认为true)或将allowBackup标志设置为true时，应用程序的数据可以被任意备份和恢复，恶意攻击者可以通过adb工具备份复制应用程序的数据。 | 在AndroidManifest.xml文件中设置application的属性 android:allowBackup&#x3D;”false” | || 权限滥用风险 | 中危 | 自定义权限的保护级别过低，导致任意应用程序都可以使用此权限，无法起到保护作用。 | 如非必要，自定义权限的保护级别至少要设置为：signature。 | | | 漏洞名称 | 风险级别 | 说明 | 修复建议 | 详情 || WebView组件系统隐藏接口未移除漏洞 | 高危 | 使用Android WebView组件时，没有移除其中内置的searchBoxJavaBridge_，accessibility和accessibilityTraversal等导出接口, 可能导致远程代码任意执行 | 使用Android WebView组件时，通过调用removeJavascriptInterface方法移除searchBoxJavaBridge_, accessibility和accessibilityTraversal等导出接口，防止被恶意利用 | 源文件： 类：com.baidu.mobad.feeds.remote.BaiduActivity 方法：a 行数：-1 || WebView组件系统隐藏接口未移除漏洞 | 高危 | 使用Android WebView组件时，没有移除其中内置的searchBoxJavaBridge_，accessibility和accessibilityTraversal等导出接口, 可能导致远程代码任意执行 | 使用Android WebView组件时，通过调用removeJavascriptInterface方法移除searchBoxJavaBridge_, accessibility和accessibilityTraversal等导出接口，防止被恶意利用 | 源文件： 类：com.qq.e.comm.plugin.j.a 方法：onAfterCreate 行数：-1 || Dex文件动态加载风险 | 中危 | Android提供的DexClassLoader动态加载方法，并没有对DEX文件和路径进行安全校验，可能导致加载文件或者优化文件被恶意替换 | 使用DexClassLoader方法动态加载DEX文件时，对DEX文件进行安全校验，并保证加载路径和优化路径的安全 | 源文件： 类：com.baidu.mobad.feeds.remote.AdManager 方法：getPatchClassLoader 行数：-1 || SSL证书验证不当漏洞 | 中危 | 应用忽略证书校验错误或信任任意证书，会导致中间人攻击，造成隐私泄露 | 禁止使用ALLOW_ALL_HOSTNAME_VERIFIER；禁止使用X509TrustManager.checkServerTrusted方法来忽略证书验证错误；在使用HostnameVerifier时verify合理处理，禁止直接返回true | 源文件： 类：com.qq.e.comm.plugin.k.d$a$1 方法：verify 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.qq.e.comm.plugin.m.f 方法：a 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.qq.e.comm.plugin.m.f 方法：b 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.qq.e.comm.plugin.j.a 方法：onAfterCreate 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.baidu.mobad.feeds.remote.BaiduActivity 方法：a 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.baidu.mobad.feeds.remote.BaiduActivity$1 方法：shouldOverrideUrlLoading 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.baidu.mobad.feeds.remote.DownloaderTask 方法：a 行数：-1 || PendingIntent包含隐式Intent风险 | 低危 | PendingIntent以其发送方应用的权限使用该PendingIntent包含的Intent，如果该Intent为隐式的，可能造成隐私泄露和权限泄露 | 使用PendingIntent时，建议使用显示Intent | 源文件： 类：com.baidu.mobad.feeds.remote.download.e 方法：run 行数：-1 || PendingIntent包含隐式Intent风险 | 低危 | PendingIntent以其发送方应用的权限使用该PendingIntent包含的Intent，如果该Intent为隐式的，可能造成隐私泄露和权限泄露 | 使用PendingIntent时，建议使用显示Intent | 源文件： 类：com.qq.e.comm.plugin.a.b.c 方法：d 行数：-1 || PendingIntent包含隐式Intent风险 | 低危 | PendingIntent以其发送方应用的权限使用该PendingIntent包含的Intent，如果该Intent为隐式的，可能造成隐私泄露和权限泄露 | 使用PendingIntent时，建议使用显示Intent | 源文件： 类：com.qq.e.comm.plugin.a.i 方法：b 行数：-1 || WebView密码明文保存漏洞 | 低危 | 在默认情况下，如果用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases&#x2F;webview.db文件中，存在密码被泄露的风险 | 使用WebView.getSettings().setSavePassword(false)来禁止保存密码 | 源文件： 类：com.qq.e.comm.plugin.m.c 方法：d 行数：-1 || 日志泄露隐私风险 | 低危 | 调试输出接口未关闭可能导致敏感信息泄露 | 关闭调试接口，禁止输出敏感信息 | 源文件： 类：com.baidu.mobads.location.BDLocManager 方法：a 行数：-1 || 日志泄露隐私风险 | 低危 | 调试输出接口未关闭可能导致敏感信息泄露 | 关闭调试接口，禁止输出敏感信息 | 源文件： 类：com.qq.e.comm.plugin.g.a 方法：a 行数：-1 || 日志泄露隐私风险 | 低危 | 调试输出接口未关闭可能导致敏感信息泄露 | 关闭调试接口，禁止输出敏感信息 | 源文件：src&#x2F;com&#x2F;qihoo&#x2F;util&#x2F;StubApplication.java 类：com.qihoo.util.StubApplication 方法：initCrashReport 行数：93 | 梆梆加固测试结果:****| 内网测试信息残留漏洞 || 评估项 | 内网测试信息残留漏洞 || 漏洞描述 | 检测程序代码内部是否包含残留测试信息，例如内网url地址等。 || 漏洞影响 | 低 || 评估方案 | 通过检测是否包含内网URl地址,判断是否发布包中是否包含测试数据。残留的测试数据，例如URL地址，测试账号，密码，可能会被盗取并恶意利用在正式服务器上进行攻击，例如账号重试，攻击安全薄弱的测试服务器以获取服务器安全漏洞或者逻辑漏洞。 || 评估结果 | 安全 || 漏洞分析 | 该App应用中未包含测试数据信息。 || 漏洞详情 | N&#x2F;A || 解决方案 | N&#x2F;A | | 下载任意apk漏洞 || 评估项 | 下载任意apk漏洞 || 漏洞描述 | 检测应用中是否存在下载任意apk的漏洞。 || 漏洞影响 | 中 || 评估方案 | 具有下载apk功能的组件存在导出漏洞，并且未对组件调用者进行校验。攻击者可利用导出组件的手段下载攻击者指定的任意apk文件，并且在下载过程中伪装apk文件的下载信息，例如图标、描述等，导致用户被诱导下载安装恶意应用。 || 评估结果 | 安全 || 漏洞分析 | 该App应用中不存在可被导出的具有下载apk功能的组件。 || 漏洞详情 | N&#x2F;A || 解决方案 | N&#x2F;A | | HTTPS未校验服务器证书漏洞 || 评估项 | HTTPS未校验服务器证书漏洞 || 漏洞描述 | 检测App程序在使用HTTPS协议传输数据时是否对服务器证书进行完整校验。 || 漏洞影响 | 中 || 评估方案 | 使用HTTPS协议时，客户端必须对服务器证书进行完整校验，以验证服务器是真实合法的目标服务器。如果没有校验，客户端可能与仿冒的服务 器建立通信链接，即“中间人攻击”。仿冒的中间人可以冒充服务器与银行客户端进行交互，同时冒充银行客户端与银行服务器进行交互，在充当中间人转发信息的 时候，窃取手机号，账号，密码等敏感信息。 || 评估结果 | 存在漏洞 || 漏洞分析 | 该App应用在使用HTTPS进行数据传输时未校验服务器证书或者未校验主机名。 || 漏洞详情 | [“com.moji.mjweather.util.log.InstalledAppTrackerSDK.a:(ILjava&#x2F;lang&#x2F;String;Lorg&#x2F;apache&#x2F;http&#x2F;client&#x2F;methods&#x2F;HttpPost;)Ljava&#x2F;lang&#x2F;String;”] || 解决方案 | 在使用https时对服务器证书进行校验，并且使用STRICT_HOSTNAME_VERIFIER严格校验主机名。 | | Webview远程代码执行漏洞 || 评估项 | Webview远程代码执行漏洞 || 漏洞描述 | 检测app应用的webview组件中是否存在远程代码执行漏洞。 || 漏洞影响 | 高 || 评估方案 | Webview是Android用于浏览网页的组件，其包含的接口函数addJavascriptInterface可以将Java类或方 法导出以供JavaScript调用，实现网页JS与本地JAVA的交互。由于系统没有限制已注册JAVA类的方法调用，因此未注册的其它任何JAVA类 也可以被反射机制调用，这样可能导致被篡改的URL中存在的恶意代码被执行，用户手机被安装木马程序，发送扣费短信，通信录或者短信被窃取，甚至手机被远 程控制。 || 评估结果 | 存在漏洞 || 漏洞分析 | 该App应用中可能存在被addJavascriptInterface接口导出的未注册Java类函数。 || 漏洞详情 | [“com.tencent.bugly.crashreport.CrashReport.setJavascriptMonitor:(Landroid&#x2F;webkit&#x2F;WebView;ZZ)Z”] || 解决方案 | 取消使用addJavascriptInterface接口，以其他Java与 JavaScript互通方案代替；若必须使用，则应对访问的url进行过滤限制或对html页面进行完整性校验，同时显示移除对指定的 javascript接口的调用： removeJavascriptInterface(searchBoxJavaBridge_) emoveJavascriptInterface(accessibility)；removeJavascriptInterface(accessibilityTraversal)；。 | | Webview绕过证书校验漏洞 || 评估项 | Webview绕过证书校验漏洞 || 漏洞描述 | 检测App应用的webview组件是否在发现https网页证书错误后继续加载页面。 || 漏洞影响 | 低 || 评估方案 | 客户端的Webview组件访问使用HTTPS协议加密的url时，如果服务器证书校验错误，客户端应该拒绝继续加载页面。但如果重载 WebView的onReceivedSslError()函数并在其中执行handler.proceed()，客户端可以绕过证书校验错误继续访问此 非法URL。这样将会导致“中间人攻击”，攻击者冒充服务器与银行客户端进行交互，同时冒充银行客户端与银行服务器进行交互，在充当中间人转发信息的时 候，窃取手机号，账号，密码等敏感信息。 || 评估结果 | 存在漏洞 || 漏洞分析 | 该App应用的webview组件中存在忽略证书校验错误的漏洞。 || 漏洞详情 | [ “com.alipay.sdk.app.b.onReceivedSslError:(Landroid&#x2F;webkit&#x2F;WebView;Landroid&#x2F;webkit&#x2F;SslErrorHandler;Landroid&#x2F;net&#x2F;http&#x2F;SslError;)V”, “com.alipay.sdk.app.d.onClick:(Landroid&#x2F;content&#x2F;DialogInterface;I)V”, “com.alipay.sdk.auth.AuthActivity.b.onReceivedSslError:(Landroid&#x2F;webkit&#x2F;WebView;Landroid&#x2F;webkit&#x2F;SslErrorHandler;Landroid&#x2F;net&#x2F;http&#x2F;SslError;)V”, “com.alipay.sdk.auth.f.onClick:(Landroid&#x2F;content&#x2F;DialogInterface;I)V”, “com.tencent.smtt.sdk.aw.b.proceed:()V”] || 解决方案 | 取消在Webveiw组件中对onReceivedSslError()函数的重载。 | 360捉虫猎手检测结果：**** 因结果扫了很久还没出来，就直接来张其他app的扫描结果吧 阿里聚对墨迹天气的安全检测结果:****| 漏洞详情 | 风险等级 | 修复建议 || webview远程代码执行漏洞（2个）addJavascriptInterface存在高危远程代码执行漏洞,应尽量避免使用,API 17中用@JavascriptInterface 代替addjavascriptInterface;移除系统webkit内置的危险接口searchBoxJavaBridge_,accessibility,accessibilityTraversal [ 了解更多 ] [ 实际案例 ] | 高危触及安全红线 | 应尽量避免使用,API 17中用@JavascriptInterface 代替addjavascriptInterface;移除系统webkit内置的危险接口searchBoxJavaBridge_,accessibility,accessibilityTraversal || WebView不校验证书漏洞（1个）调用了android&#x2F;webkit&#x2F;SslErrorHandler类的proceed方法,可能导致WebView忽略校验证书的步骤 | 高危触及安全红线 | 不要调用android.webkit.SslErrorHandler的proceed方法 || 中间人攻击漏洞（1个）HTTPS禁止使用ALLOW_ALL_HOSTNAME_VERIFIER，因为这样会存在中间人攻击的风险 [ 了解更多 ] | 高危触及安全红线 | 必须使用STRIC_HOSTNAME_VERIFIER并校验证书 || 备份标识配置风险（1个）当这个标志被设置为true或不设置该标志时应用程序数据可以备份和恢复，adb调试备份允许恶意攻击者复制应用程序数据。 [ 了解更多 ] [ 实际案例 ] | 中危触及安全红线 | 在AndroidManifest.xml中设置android:allowBackup&#x3D;”false” || 拒绝服务漏洞（22个）不校验导出组件（Activity，Service等）的传递参数，导致拒绝服务，需注意空值判定以及类型转换判断。 [ 了解更多 ] [ 实际案例 ] | 中危触及安全红线 | 请严格校验输入参数，注意空值判定和类型转换判断，防止由于异常输入导致的应用崩溃. || SharedPrefs任意读写漏洞（2个）存在内容被替换的风险，SharedPreference禁止使用MODE_WORLD_READABLE和MODE_WORLD_WRITABLE [ 了解更多 ] | 中危触及安全红线 | 不要使用MODE_WORLD_READABLE和MODE_WORLD_WRITABLE。 || 主机名弱效验（3个）在实现的HostnameVerifier子类中未对主机名做效验，这样会导致恶意程序利用中间人攻击绕过主机名效验。利用HostnameVerifier子类中的verify函数效验服务器主机名的合法性。 | 中危触及安全红线 | 在实现的HostnameVerifier子类verify函数中校验主机名的合法性。 || 证书弱校验（3个）在实现的HostnameVerifier子类中未对主机名做效验，这样会导致恶意程序利用中间人攻击绕过主机名效验。利用HostnameVerifier子类中的verify函数效验服务器主机名的合法性。 | 中危触及安全红线 | 在实现的X509TrustManager子类中checkServerTrusted函数效验服务器端证书的合法性。 || File任意读写漏洞（7个）存在内容被替换的风险，openFileOutput禁止使用MODE_WORLD_READABLE和MODE_WORLD_WRITABLE [ 了解更多 ] | 中危触及安全红线 | 不要使用MODE_WORLD_READABLE和MODE_WORLD_WRITABLE。 || 随机数生成函数使用错误（1个）使用SecureRandom时不要使用SecureRandom (byte[] seed)这个构造函数，会造成生成的随机数不随机。 [ 了解更多 ] | 高危 | 建议通过&#x2F;dev&#x2F;urandom或者&#x2F;dev&#x2F;random获取的熵值来初始化伪随机数生成器PRNG || AES&#x2F;DES弱加密风险（19个）使用AES&#x2F;DES加密算法时，应显式指定使用CBC或CFB模式.否则容易受到选择明文攻击(CPA)的风险，造成信息泄露。 | 高危 | 使用AES&#x2F;DES加密算法时应使用CBC或CFB模式。或者使用安全组件的安全加密接口SecurityCipher进行加密。 || Native动态调试（1个）so文件存在被调试的风险，攻击者可以利用此风险对应用进行动态调试，造成核心逻辑和敏感数据等信息泄漏。 | 高危 | 聚安全安全组件通过监控进程的多种调试状态特征，给应用提供全方位的反调试保护。 || 密钥硬编码风险（9个）本地存储密钥存在被攻击者利用并通过密钥构造伪数据的风险。 [ 实际案例 ] | 高危 | 1、禁止把密钥写死在程序中，2、使用聚安全提供的安全加密组件。 || 初始化IvParameterSpec函数错误（7个）使用固定初始化向量，结果密码文本可预测性会高得多，容易受到字典式攻击。修复建议：1、禁止使用常量初始化矢量参数构建IvParameterSpec，2、推荐使用聚安全提供的安全组件。 [ 实际案例 ] | 中危 | 修复建议：1、禁止使用常量初始化矢量参数构建IvParameterSpec，2、推荐使用聚安全提供的安全组件。 || 未进行安全加固风险（1个）应用没有被安全加固，攻击者可以利用重打包等手段修改程序的原始逻辑和内容，并上传仿冒app到第三方应用市场，欺骗用户。 [ 实际案例 ] | 中危 | 建议使用聚安全的应用加固方案，聚安全应用加固提供对dex、so等文件的保护以及混淆。 || PendingIntent误用风险（5个）使用PendingIntent的时候，如果使用了一个空Intent，会导致恶意用户劫持修改Intent的内容。禁止使用一个空Intent去构造PendingIntent，构造PendingIntent的Intent一定要设置ComponentName或者action。 | 中危 | 禁止使用一个空Intent去构造PendingIntent，构造PendingIntent的Intent一定要设置ComponentName或者action。 || Webview明文存储密码漏洞（5个）使用Webview时需要关闭webview的自动保存密码功能，防止用户密码被webview明文存储。 | 中危 | 显示设置webView.getSetting().setSavePassword(false) || 未移除有风险的Webview系统隐藏接口（17个）android webview组件包含3个隐藏的系统接口：searchBoxJavaBridge_, accessibilityTraversal以及accessibility，恶意程序可以利用它们实现远程代码执行。请通过显示调用removeJavascriptInterface移除这三个系统隐藏接口。 [ 实际案例 ] | 中危 | 请通过显示调用removeJavascriptInterface移除这三个系统隐藏接口。 || 数据弱保护（1个）数据安全保护级别较低，攻击者可以通过逆向分析等手段，较容易得获取应用的关键数据，比如签名算法、加密密钥、加密数据等。 | 中危 | 推荐使用安全组件的数据加签和安全存储功能，提高应用的安全保护级别。 || 日志泄漏风险（20个）使用System.out.print等标准输出打印日志信息或转存日志信息，容易泄漏敏感信息。建议删除所有使用System.out.print等标准输出打印日志或转存日志信息的代码 [ 实际案例 ] | 低危 | 建议删除所有使用System.out.print等标准输出打印日志或转存日志信息的代码 | 关于阿里巴巴的聚安全，聚安全会给代码详情打码，如下图（4.1号以后的新规则，需要验证app的签名，会给你一个demo,你需要把keystore签到阿里官方给的demo中，验证应用开发者，然后才能看到详情）如下图： 有些朋友说，出现了这个 “为保护应用隐私，查看详情漏洞位置请先申请应用所有权认证”， 如何签名如何签名：`**jarsigner** **-verbose** **-keystore** [keystorePath] **-signedjar** [apkOut] [apkin] [alias]` 命令格式及参数意义： -verbose -&gt; 输出签名过程的详细信息 -keystore [keystorePath] -&gt; 密钥的库的位置 -signedjar [apkOut] -&gt; 签名后的输出文件名 [apkin] -&gt; 待签名的文件名 [alias] -&gt; 证书别名 示例： `**D**:\\>**jarsigner** **-verbose** **-keystore** **demo**.keystore **-signedjar** **jaq_demo_signed**.apk **jaq_demo**.apk **demo**.keystore` 下面讲下如何对app的应用开发者进行认证： 那么如何签名呢 创建一个keystore，用来存放签名app时要用的： `**keytool** **-genkey** **-v** **-keystore** **relax**.keystore **-alias** **rela** **-keyalg** **RSA** 生成私钥` 用私钥对apk进行重新签名 `root@kali:~/Desktop# jarsigner -verbose -sigalg MD5withRSA --digestalg SHA1 -keystore /root/Desktop/relax.keystore jaq_demo_1460103308355.apk rela` 就是说，使用开发者的keystore对聚安全的那个demo.apk进行签名，然后就完成了认证 聚安全的一些其他看点聚安全结合乌云，里面有很多实例，有很多常用漏洞的集合，是新手快速解决问题的好去处。 聚安全还有一个仿冒监测：（这里说下为什么会出现仿冒软件，因为app没有加固，导致被反编译，被打包后，植入而已代码后又在其他地方上线，所以这里忠告一下，下app，一定要去官方网站上下载，能提供验证MD5，尽量要验证一下） 检测结果总结：阿里聚安全问题汇总： webview远程代码执行漏洞 WebView不校验证书漏洞 中间人攻击漏洞 备份标识配置风险 拒绝服务漏洞 SharedPrefs任意读写漏洞 主机名弱效验 证书弱校验 File任意读写漏洞 随机数生成函数使用错误 AES&#x2F;DES弱加密风险 Native动态调试 密钥硬编码风险 初始化IvParameterSpec函数错误 未进行安全加固风险 PendingIntent误用风险 Webview明文存储密码漏洞 未移除有风险的Webview系统隐藏接口 数据弱保护 日志泄露隐私风险（logcat日志输出) 百度移动测试中心问题汇总： 组件暴露——Activity 组件暴露——Service 组件暴露——BroadcastReceiver 应用数据任意备份风险 权限滥用风险 WebView组件系统隐藏接口未移除漏洞 Dex文件动态加载风险 SSL证书验证不当漏洞 WebView密码明文保存漏洞 PendingIntent包含隐式Intent风险 日志泄露隐私风险 最后看下梆梆的检测结果：**** Java代码保护风险 组件导出风险 敏感函数调用风险 调试日志函数调用风险 应用数据任意备份风险 明文数字证书风险 未使用HTTPS协议的数据传输风险 Webview明文存储密码风险 HTTPS未校验服务器证书漏洞 Webview远程代码执行漏洞 Webview绕过证书校验漏洞 梆梆的新鲜的亮点: 到一处 直接打印出app里涉及到的url列表地址了，是不是涉及到很多新鲜的子域名和url。 总结和一些争议评估一下APP的安全性可以综合参考以上的检测，然后综合性的评估，阿里的需要验证开发者权限，百度那个要花钱的，还不错，梆梆也可以（很方便渗透额），360怎么一直扫描不出报告。开发不一定能改第三方的包的安全问题，所以本包的问题能改的尽量改，咱们能做的就是给app进行加固。 加固前后效果对比： 加固后，可以看到数据备份还是没有打钩，因为，我没对apk中的（在AndroidManifest.xml中设置android:allowBackup&#x3D;”false”）这个设置项进行更改。 后记本次在线检测实战旨在帮助开发者更快的评估自己的android问题，作为一个菜鸟app检测人员，希望带给大家的是让自己的app更加安全，当然安全从开发开始构思时，就该考虑是否使用第三方包，这样，对app的安全更加可控。 阅读拓展http://www.droidsec.cn/ 安卓安全中文站 http://blog.nsfocus.net/mobile-app-security-security-test/ 移动app检测要点 http://zbc.baijia.baidu.com/article/365622 10大移动安全威胁","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android自定义四个方向滚动的跑马灯MarqueeViewLibrary/","text":"#####在大佬MarqueeViewLibrary框架的基础上实现控件的各项参数动态配置; 12原文地址:https://gitcode.net/mirrors/gongwen/MarqueeViewLibrary 实现后效果图: ####配置参数 动态替换下面的值即可 123456789101112131415161718Boolean isPlayAnim = true;//是否滚动 int width = 600;//控件宽度dp int heigh = 80;//控件高度dp int margin_left = 5;//左边距 dp int margin_right = 0;//右边距 dp int margin_top = 5;//上边距 dp int margin_bottom = 0;//下边距 dp String backgroundColor = &quot;#cccccc&quot;;//控件背景色 int fontSize = 14;//字体大小dp String textColor = &quot;#000000&quot;;//字体颜色 int scrollSpeed = 4000;//翻页速度 毫秒 int scrollDirection = 4;//滚动方向:1上2下3左4右 其他默认左; int animSpeed = 2000;//动画持续时间 毫秒 boolean isSingleLine = true;//是否单行 int textAlineType = 1;//文字居中方式:1居中,2横向居中3纵向居中 默认1 //设置数据源 final List&lt;String&gt; datas = Arrays.asList(&quot;《赋得古原草送别》&quot;, &quot;离离原上草，一岁一枯荣。&quot;, &quot;野火烧不尽，春风吹又生。&quot;, &quot;远芳侵古道，晴翠接荒城。&quot;,&quot;又送王孙去，萋萋满别情。&quot;, &quot;文字显示不下时，系统的处理方式(可选：none，start，middle，end)&quot;); ####配置控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//本地父布局 RelativeLayout rl_main_layout = findViewById(R.id.rl_main_layout); int widthPx = MyUtils.px2dip(this, width); int heighPx = MyUtils.px2dip(this, heigh); SimpleMarqueeView marqueeView = new SimpleMarqueeView(this); RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) rl_main_layout.getLayoutParams(); layoutParams.width = widthPx; layoutParams.height = heighPx; layoutParams.setMargins(MyUtils.dip2px(this, margin_left), MyUtils.dip2px(this, margin_top), MyUtils.dip2px(this, margin_right), MyUtils.dip2px(this, margin_bottom)); marqueeView.setLayoutParams(layoutParams);//设置宽高及margin rl_main_layout.setBackgroundColor(Color.parseColor(backgroundColor));//设置背景色 rl_main_layout.addView(marqueeView); /** * 设置动画 * SimpleMarqueeView marqueeView SimpleMarqueeView控件 * int scrollDirection 滚动方向 * int animSpeed 动画持续时间 * int width控件宽度 * */ setAnimation(marqueeView, scrollDirection, animSpeed, widthPx, heighPx); marqueeView.setFlipInterval(scrollSpeed);//翻页时间间隔 marqueeView.setTextColor(Color.parseColor(textColor));//字体颜色 marqueeView.setTextSize(MyUtils.dip2px(this, fontSize)); marqueeView.setTextEllipsize(TextUtils.TruncateAt.END);//文字显示不下时，系统的处理方式 switch (textAlineType) &#123;//1居中,2横向居中3纵向居中 默认1 case 1: marqueeView.setTextGravity(Gravity.CENTER); break; case 2: marqueeView.setTextGravity(Gravity.CENTER_HORIZONTAL); break; case 3: marqueeView.setTextGravity(Gravity.CENTER_VERTICAL); break; default: marqueeView.setTextGravity(Gravity.CENTER); break; &#125; marqueeView.setTextSingleLine(isSingleLine);//是否单行 SimpleMF&lt;String&gt; marqueeFactory = new SimpleMF(this); marqueeFactory.setData(datas); marqueeView.setMarqueeFactory(marqueeFactory); if (isPlayAnim &amp;&amp; datas != null || datas.size() &gt; 0) &#123; marqueeView.startFlipping(); &#125; else &#123; marqueeView.stopFlipping(); &#125; ####动画配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private void setAnimation(SimpleMarqueeView marqueeView, int scrollDirection, int animSpeed, int width, int heigh) &#123; switch (scrollDirection) &#123; case 1://上 setBottomToTop(marqueeView, animSpeed, heigh); break; case 2://下 setTopToBottom(marqueeView, animSpeed, heigh); break; case 3://左 setRightToLeftAnim(marqueeView, animSpeed, width); break; case 4://右 setLeftToRoght(marqueeView, animSpeed, width); break; default://左 setRightToLeftAnim(marqueeView, animSpeed, width); break; &#125; &#125; //从下到上 private void setBottomToTop(SimpleMarqueeView marqueeView, int animSpeed, int heigth) &#123; AlphaAnimation alphaAnim = new AlphaAnimation(0f, 1f); TranslateAnimation translateAnim = new TranslateAnimation(0, 0f, heigth, 0); AnimationSet in_bottom = new AnimationSet(true); in_bottom.addAnimation(alphaAnim); in_bottom.addAnimation(translateAnim); in_bottom.setDuration(animSpeed); AlphaAnimation alphaAnim1 = new AlphaAnimation(1, 0f); TranslateAnimation translateAnim1 = new TranslateAnimation(0f, 0, 0, -heigth); AnimationSet out_top = new AnimationSet(true); out_top.addAnimation(alphaAnim1); out_top.addAnimation(translateAnim1); out_top.setDuration(animSpeed); marqueeView.setInAndOutAnim(in_bottom, out_top); &#125; //从上到下 private void setTopToBottom(SimpleMarqueeView marqueeView, int animSpeed, int heigth) &#123; AlphaAnimation alphaAnim = new AlphaAnimation(0f, 1f); TranslateAnimation translateAnim = new TranslateAnimation(0, 0f, -heigth, 0); AnimationSet in_bottom = new AnimationSet(true); in_bottom.addAnimation(alphaAnim); in_bottom.addAnimation(translateAnim); in_bottom.setDuration(animSpeed); AlphaAnimation alphaAnim1 = new AlphaAnimation(1, 0f); TranslateAnimation translateAnim1 = new TranslateAnimation(0f, 0, 0,heigth); AnimationSet out_top = new AnimationSet(true); out_top.addAnimation(alphaAnim1); out_top.addAnimation(translateAnim1); out_top.setDuration(animSpeed); marqueeView.setInAndOutAnim(in_bottom, out_top); &#125; //从右到左 private void setRightToLeftAnim(SimpleMarqueeView marqueeView, int animSpeed, int width) &#123; TranslateAnimation translateAnim = new TranslateAnimation(width, 0f, 0, 0); AnimationSet in_right = new AnimationSet(true); in_right.addAnimation(translateAnim); in_right.setDuration(animSpeed); TranslateAnimation translateAnim1 = new TranslateAnimation(0f, -width, 0, 0); AnimationSet out_left = new AnimationSet(true); out_left.setDuration(animSpeed); out_left.addAnimation(translateAnim1); marqueeView.setInAndOutAnim(in_right, out_left); &#125; //从左到右 private void setLeftToRoght(SimpleMarqueeView marqueeView, int animSpeed, int width) &#123; TranslateAnimation translateAnim = new TranslateAnimation(-width, 0, 0, 0); AnimationSet in_right = new AnimationSet(true); in_right.addAnimation(translateAnim); in_right.setDuration(animSpeed); TranslateAnimation translateAnim1 = new TranslateAnimation(0, width, 0, 0); AnimationSet out_left = new AnimationSet(true); out_left.setDuration(animSpeed); out_left.addAnimation(translateAnim1); marqueeView.setInAndOutAnim(in_right, out_left); &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/EventBus/","text":"#####常用事件消息传递 一个实现了监听器接口的类，必须把它自身注册到它想要监听的类中去 使用广播，内部的实现都需要IPC，从传递效率上来讲，可能并不太适合上层的组件间通信 Activity间的消息传递便是通过startActivityForResult和onActivityResult,会产生较多的状态和逻辑判断，而且intent或Bundle传值还得检测类型，容易发生错误 #####集成 1compile &#x27;org.greenrobot:eventbus:3.1.1&#x27; EventBus是一款针对Anddoid优化的发布&#x2F;订阅事件总线。主要是替代intent,Handler，BroadCast在Fragment,activity，service线程之间传递消息。优点：开销小，代码更优雅，以及将发送者和节后这解耦 #####基本用法 注册12EventBus.getDefault.register(this);EventBus.getDefault.register(this,methodName,Event.class); 取消注册1EventBus.getDefault.unregister(this); 订阅处理数据123onEventMainThread onEventonEventPostThread onEventAsynconEventBackgroundThread 发布数据1EventBus.getDefault().post(new Event(msg)); #####简单的demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MainActivity extends AppCompatActivity &#123;//第一个界面 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this);//注册 findViewById(R.id.bn_main).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; startActivity(new Intent(MainActivity.this,SecondActivity.class)); &#125; &#125;); &#125; @Subscribe(threadMode = ThreadMode.MAIN)//需要加上注解 public void onEventMainThred(MyEvent event)&#123; Log.e(&quot;tyl&quot;,&quot;masg=&quot;+event.getEvent()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);//注销 &#125;&#125;//第二个界面public class SecondActivity extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.bn_main).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; MyEvent myEvent = new MyEvent(); myEvent.setEvent(&quot;hello&quot;); EventBus.getDefault().post(myEvent); finish(); &#125; &#125;); &#125;&#125;//消息源public class MyEvent &#123; private String event; public String getEvent() &#123; return event; &#125; public void setEvent(String event) &#123; this.event = event; &#125;&#125; #####ThreadMode分类在EventBus中，您可以使用四个ThreadModes中的一个来定义将调用事件处理方法的线程。 ThreadMode.POSTING订阅者将在发布事件的同一线程中调用。这是默认值。事件传递是同步完成的，一旦发布完成，所有订阅者都将被调用。此ThreadMode意味着开销最小，因为它完全避免了线程切换。因此，这是已知完成的简单任务的推荐模式，是一个非常短的时间而不需要主线程。使用此模式的事件处理程序应该快速返回以避免阻止发布线程，这可能是主线程。123456//在同一个线程中调用（默认）// ThreadMode在这里是可选的@Subscribe(threadMode = ThreadMode.POSTING)public void onMessageEvent(MessageEvent event) &#123; textView.setText(event.message);&#125; ThreadMode.MAIN订阅者将在Android的主线程（有时称为UI线程）中调用。如果发布线程是主线程，则将直接调用事件处理程序方法（与ThreadMode.POSTING所描述的同步）。使用此模式的事件处理程序必须快速返回以避免阻塞主线程。12345@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) &#123; Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show(); textView.setText(event.message);&#125; ThreadMode.MAIN_ORDERED订阅者将在Android的主线程中调用。该事件总是排队等待以后交付给订阅者，因此对post的调用将立即返回。这为事件处理提供了更严格且更一致的顺序（因此名称为MAIN_ORDERED）。例如，如果您在具有MAIN线程模式的事件处理程序中发布另一个事件，则第二个事件处理程序将在第一个事件处理程序之前完成（因为它是同步调用的 - 将其与方法调用进行比较）。使用MAIN_ORDERED，第一个事件处理程序将完成，然后第二个事件处理程序将在稍后的时间点调用（一旦主线程具有容量），使用此模式的事件处理程序必须快速返回以避免阻塞主线程。123456//在Android UI主线程中调用@Subscribe(threadMode = ThreadMode.MAIN_ORDERED)public void onMessageEvent(MessageEvent event) &#123; Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show(); textView.setText(event.message);&#125; ThreadMode.BACKGROUND订阅者将在后台线程中调用。如果发布线程不是主线程，则将在发布线程中直接调用事件处理程序方法。如果发布线程是主线程，则EventBus使用单个后台线程，该线程将按顺序传递其所有事件。使用此模式的事件处理程序应尝试快速返回以避免阻塞后台线程。12345//在后台线程中调用@Subscribe(threadMode = ThreadMode.BACKGROUND)public void onMessage(MessageEvent event)&#123; saveToDisk(event.message);&#125; ThreadMode.ASYNC事件处理程序方法在单独的线程中调用。这始终独立于发布线程和主线程。发布事件永远不会等待使用此模式的事件处理程序方法。如果事件处理程序的执行可能需要一些时间，例如用于网络访问，则应使用此模式。避免同时触发大量长时间运行的异步处理程序方法来限制并发线程数。EventBus使用线程池从已完成的异步事件处理程序通知中有效地重用线程。12345//在一个单线程中调用@Subscribe(threadMode = ThreadMode.ASYNC)public void onMessage(MessageEvent event)&#123; backend.send(event.message);&#125; #####总结我们根据EventBus中的不同ThreadMode的方式来进行对我们项目的使用，在什么情况中使用哪种线程将是我们所需要考虑的。根据Android 中的线程不同，来使用不同的EventBus的不同线程。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/GreenDao/","text":"#####android 原生提供的API带来的不方便的地方： 要手动拼装sql 要自己写操作数据库的常规代码 不能自动把数据库中的数据映射成对象 没有实现级联查询 #####什么是GreenDao： GreenDao是一个高效的数据库访问ORM框架，节省了自己编写SQL的时间，快速的增删查改等操作。#####什么是ORM：对象关系映射,，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换#####GreenDao优点： 让业务代码访问对象，而不是数据库源 隐藏了面向对象的逻辑SQL查询详情 无需处理数据库实现 最高性能（可能是Android上最快的ORM）; 我们的基准也是开源的 易于使用的强大API，涵盖关系和连接 最小的内存消耗 小库大小（&lt;100KB）以保持较低的构建时间并避免65k方法限制 数据库加密：greenDAO支持SQLCipher，以确保用户的数据安全 强大的社区：超过5000个GitHub Starts表明有一个强大而活跃的社区 #####集成GreenDao 3.0采用注解的方式来定义实体类，通过gradle插件生成相应的代码。您可以使用greenDAO Gradle插件，无需任何其他配置,但至少要设置schema的版本等; 1234567891011121314151617181920// In your root build.gradle file: 项目的build.gradle中buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:3.1.1&#x27; classpath &#x27;org.greenrobot:greendao-gradle-plugin:3.2.2&#x27; // add plugin 这里添加plugin &#125;&#125; // In your app projects build.gradle file: 在app的build.gradle中 apply plugin: &#x27;com.android.application&#x27;apply plugin: &#x27;org.greenrobot.greendao&#x27; // apply plugin 顶部添加 dependencies &#123; implementation &#x27;org.greenrobot:greendao:3.2.2&#x27; // add library 引入包&#125;//无需混淆","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/RxJava-RxAndroid/","text":"####为什么要使用RxJava和RxAndroid RxJava能提高动作效率 RxJava能优雅的解决复杂业务场景 RxJava使用越来越流行RxJava文档RxJava中文文档Rxjava经典资料 ####响应式编程是一种基于异步数据流概念的编程模式！浅谈响应式编程####RxJava概述 异步数据处理库 扩展的观察者模式 ####RxJava特点 &lt;1MB jar 轻量级框架 支持Java8 lambda表达式 支持java6+ &amp; Android 2.3+ 支持异步和同步 ####RxAndroid概述 RxAndroid是RxJava针对Android平台的一个扩展，用于Android开发 提高响应式扩展组件快速、易于开发android应用程序","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Svn忽略Android项目上传文件-文件夹/","text":"TortoiseSVN-&gt;Settings-&gt;General-&gt;Global ignore pattern忽略规则以空号分割 12//忽略规则.gradle *.idea *build *.iml","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Sentry-Android集成-使用-混淆/","text":"Sentry是一个实时事件日志记录和汇集的平台。其专注于错误监控以及提取一切事后处理所需信息而不依赖于麻烦的用户反馈。####集成： 12//app-build.gradle:implementation &#x27;io.sentry:sentry-android:1.7.27&#x27; ####初始化： 123//MyApplication: String sentryDsn = &quot;http://6c89c12e4d4e4ee7a007ee5166637642@183.230.93.80:9100/8&quot;; Sentry.init(sentryDsn, new AndroidSentryClientFactory(getApplicationContext())); ####获取Dsn:&#x2F;&#x2F;项目-设置####混淆： 123-keepattributes LineNumberTable,SourceFile-dontwarn org.slf4j.**-dontwarn javax.** ####官方文档：https://docs.sentry.io/clients/java/integrations/#android####官方demo: https://github.com/getsentry/examples/tree/master/android####PS：1 其实很简单的集成,建议不要去看官方的集成文档很坑，直接看demo都好!2 另外就是异常信息如果是同类型的会归为1个异常里面 需要点异常信息进去查看 我之前就是一直以为没有集成成功,最好才发现是筛选后遭成的显示问题","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-RadioButton-drawableTop图片变型/","text":"12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@mipmap/nav_zyjd_selected&quot; android:state_checked=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@mipmap/nav_zyjd&quot; android:state_checked=&quot;false&quot;/&gt;&lt;/selector&gt; 12345int width = MyUtils.dip2px(TrialingActivity.this, 11);int heigth = MyUtils.dip2px(TrialingActivity.this, 12); Drawable dispute = getResources().getDrawable(R.drawable.selector_trialing_dispute); dispute.setBounds(0, 0,width ,heigth); rb_dispute.setCompoundDrawables(null, dispute, null, null);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Glide设置圆角、圆形图片（无需再创建工具类了）/","text":"####加载圆形图片： 123456RequestOptions mRequestOptions = RequestOptions.circleCropTransform().diskCacheStrategy(DiskCacheStrategy.NONE)//不做磁盘缓存.skipMemoryCache(true);//不做内存缓存.error(R.mipmap.icon_store_default_head)//错误图片.placeholder(R.mipmap.icon_store_default_head)//预加载图片Glide.with(mContext).load(userInfo.getImage()).apply(mRequestOptions).into(mUserIcon); ####加载圆角图片： 123456//设置图片圆角角度RoundedCorners roundedCorners= new RoundedCorners(6);//px//通过RequestOptions扩展功能,override:采样率,因为ImageView就这么大,可以压缩图片,降低内存消耗RequestOptions options=RequestOptions.bitmapTransform(roundedCorners).override(300, 300);Glide.with(context).load(files.getFilePath()).apply(options).into(mUserPhoto);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-获取assets内的文件转File/","text":"1234567891011//调用方法 String dirPath = ContextCompat.getExternalFilesDirs(MainActivity.this, Environment.DIRECTORY_DCIM)[0].getAbsolutePath() + File.separator + &quot;PrintFile&quot;; try &#123; copyAssetToFile(&quot;庭审系统安卓端操作手册.pdf&quot;,dirPath,&quot;/庭审系统安卓端操作手册.pdf&quot;); &#125; catch (IOException e) &#123; Log.e(&quot;tyl&quot;,&quot;IOException=&quot;+e.getMessage()); e.printStackTrace(); &#125;//读取到本地file文件 File file = new File(dirPath+&quot;/庭审系统安卓端操作手册.pdf&quot;); 1234567891011121314151617181920212223242526272829/** * 复制assets下的文件到本地文件 * assetName assets内的文件名称 * savepath 本地文件夹路径 * savename 保存的文件名称需带后缀文件类型 如.pdf * @throws IOException */ public void copyAssetToFile(String assetName, String savepath, String savename) throws IOException &#123; InputStream myInput; File dir = new File(savepath); if (!dir.exists()) &#123; dir.mkdirs(); &#125; File dbf = new File(savepath + savename); if (dbf.exists()) &#123; dbf.delete(); &#125; String outFileName = savepath + savename; OutputStream myOutput = new FileOutputStream(outFileName); myInput = this.getAssets().open(assetName); byte[] buffer = new byte[1024]; int length; while ((length = myInput.read(buffer)) &gt; 0) &#123; myOutput.write(buffer, 0, length); &#125; myOutput.flush(); myInput.close(); myOutput.close(); &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-本地日历插入事件/","text":"####1.权限申请为了实现在项目中调用系统日历和插入日程事件，我们首先在AndroidManifest.xml文件中添加如下相关权限 12&lt;uses-permission android:name=&quot;android.permission.READ_CALENDAR&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CALENDAR&quot; /&gt; ####2.日历相关uri系统calendar content provider相关的uri，以下为Android2.2版本以后的uri 123private static String CALENDER_URL = &quot;content://com.android.calendar/calendars&quot;;private static String CALENDER_EVENT_URL = &quot;content://com.android.calendar/events&quot;;private static String CALENDER_REMINDER_URL = &quot;content://com.android.calendar/reminders&quot;; ####3.具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package com.guoshikeji.calendar.utils;import android.content.ContentUris;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.graphics.Color;import android.net.Uri;import android.provider.CalendarContract;import android.text.TextUtils;import java.util.Calendar;import java.util.TimeZone;/** * Created by tyl * 2018/11/20/020 * Describe:往本地日历插入事件 */public class CalendarReminderUtils &#123; private static String CALENDER_URL = &quot;content://com.android.calendar/calendars&quot;; private static String CALENDER_EVENT_URL = &quot;content://com.android.calendar/events&quot;; private static String CALENDER_REMINDER_URL = &quot;content://com.android.calendar/reminders&quot;; private static String CALENDARS_NAME = &quot;boohee&quot;; private static String CALENDARS_ACCOUNT_NAME = &quot;BOOHEE@boohee.com&quot;; private static String CALENDARS_ACCOUNT_TYPE = &quot;com.android.boohee&quot;; private static String CALENDARS_DISPLAY_NAME = &quot;BOOHEE账户&quot;; /** * 检查是否已经添加了日历账户，如果没有添加先添加一个日历账户再查询 * 获取账户成功返回账户id，否则返回-1 */ private static int checkAndAddCalendarAccount(Context context) &#123; int oldId = checkCalendarAccount(context); if( oldId &gt;= 0 )&#123; return oldId; &#125;else&#123; long addId = addCalendarAccount(context); if (addId &gt;= 0) &#123; return checkCalendarAccount(context); &#125; else &#123; return -1; &#125; &#125; &#125; /** * 检查是否存在现有账户，存在则返回账户id，否则返回-1 */ private static int checkCalendarAccount(Context context) &#123; Cursor userCursor = context.getContentResolver().query(Uri.parse(CALENDER_URL), null, null, null, null); try &#123; if (userCursor == null) &#123; //查询返回空值 return -1; &#125; int count = userCursor.getCount(); if (count &gt; 0) &#123; //存在现有账户，取第一个账户的id返回 userCursor.moveToFirst(); return userCursor.getInt(userCursor.getColumnIndex(CalendarContract.Calendars._ID)); &#125; else &#123; return -1; &#125; &#125; finally &#123; if (userCursor != null) &#123; userCursor.close(); &#125; &#125; &#125; /** * 添加日历账户，账户创建成功则返回账户id，否则返回-1 */ private static long addCalendarAccount(Context context) &#123; TimeZone timeZone = TimeZone.getDefault(); ContentValues value = new ContentValues(); value.put(CalendarContract.Calendars.NAME, CALENDARS_NAME); value.put(CalendarContract.Calendars.ACCOUNT_NAME, CALENDARS_ACCOUNT_NAME); value.put(CalendarContract.Calendars.ACCOUNT_TYPE, CALENDARS_ACCOUNT_TYPE); value.put(CalendarContract.Calendars.CALENDAR_DISPLAY_NAME, CALENDARS_DISPLAY_NAME); value.put(CalendarContract.Calendars.VISIBLE, 1); value.put(CalendarContract.Calendars.CALENDAR_COLOR, Color.BLUE); value.put(CalendarContract.Calendars.CALENDAR_ACCESS_LEVEL, CalendarContract.Calendars.CAL_ACCESS_OWNER); value.put(CalendarContract.Calendars.SYNC_EVENTS, 1); value.put(CalendarContract.Calendars.CALENDAR_TIME_ZONE, timeZone.getID()); value.put(CalendarContract.Calendars.OWNER_ACCOUNT, CALENDARS_ACCOUNT_NAME); value.put(CalendarContract.Calendars.CAN_ORGANIZER_RESPOND, 0); Uri calendarUri = Uri.parse(CALENDER_URL); calendarUri = calendarUri.buildUpon() .appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, &quot;true&quot;) .appendQueryParameter(CalendarContract.Calendars.ACCOUNT_NAME, CALENDARS_ACCOUNT_NAME) .appendQueryParameter(CalendarContract.Calendars.ACCOUNT_TYPE, CALENDARS_ACCOUNT_TYPE) .build(); Uri result = context.getContentResolver().insert(calendarUri, value); long id = result == null ? -1 : ContentUris.parseId(result); return id; &#125; /** * 添加日历事件 */ public static void addCalendarEvent(Context context, String title, String description, long reminderTime, int previousDate) &#123; if (context == null) &#123; return; &#125; int calId = checkAndAddCalendarAccount(context); //获取日历账户的id if (calId &lt; 0) &#123; //获取账户id失败直接返回，添加日历事件失败 return; &#125; //添加日历事件 Calendar mCalendar = Calendar.getInstance(); mCalendar.setTimeInMillis(reminderTime);//设置开始时间 long start = mCalendar.getTime().getTime(); mCalendar.setTimeInMillis(start + 10 * 60 * 1000);//设置终止时间，开始时间加10分钟 long end = mCalendar.getTime().getTime(); ContentValues event = new ContentValues(); event.put(&quot;title&quot;, title); event.put(&quot;description&quot;, description); event.put(&quot;calendar_id&quot;, calId); //插入账户的id event.put(CalendarContract.Events.DTSTART, start); event.put(CalendarContract.Events.DTEND, end); event.put(CalendarContract.Events.HAS_ALARM, 1);//设置有闹钟提醒 event.put(CalendarContract.Events.EVENT_TIMEZONE, &quot;Asia/Shanghai&quot;);//这个是时区，必须有 Uri newEvent = context.getContentResolver().insert(Uri.parse(CALENDER_EVENT_URL), event); //添加事件 if (newEvent == null) &#123; //添加日历事件失败直接返回 return; &#125; //事件提醒的设定 ContentValues values = new ContentValues(); values.put(CalendarContract.Reminders.EVENT_ID, ContentUris.parseId(newEvent)); values.put(CalendarContract.Reminders.MINUTES, previousDate * 24 * 60);// 提前previousDate天有提醒 values.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_ALERT); Uri uri = context.getContentResolver().insert(Uri.parse(CALENDER_REMINDER_URL), values); if(uri == null) &#123; //添加事件提醒失败直接返回 return; &#125; &#125; /** * 删除日历事件 */ public static void deleteCalendarEvent(Context context,String title) &#123; if (context == null) &#123; return; &#125; Cursor eventCursor = context.getContentResolver().query(Uri.parse(CALENDER_EVENT_URL), null, null, null, null); try &#123; if (eventCursor == null) &#123; //查询返回空值 return; &#125; if (eventCursor.getCount() &gt; 0) &#123; //遍历所有事件，找到title跟需要查询的title一样的项 for (eventCursor.moveToFirst(); !eventCursor.isAfterLast(); eventCursor.moveToNext()) &#123; String eventTitle = eventCursor.getString(eventCursor.getColumnIndex(&quot;title&quot;)); if (!TextUtils.isEmpty(title) &amp;&amp; title.equals(eventTitle)) &#123; int id = eventCursor.getInt(eventCursor.getColumnIndex(CalendarContract.Calendars._ID));//取得id Uri deleteUri = ContentUris.withAppendedId(Uri.parse(CALENDER_EVENT_URL), id); int rows = context.getContentResolver().delete(deleteUri, null, null); if (rows == -1) &#123; //事件删除失败 return; &#125; &#125; &#125; &#125; &#125; finally &#123; if (eventCursor != null) &#123; eventCursor.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-透明度数值记录表/","text":"透明度 数值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-软键盘工具类/","text":"判断软键盘是否弹出： 12345678private boolean isSoftShowing() &#123; //获取当前屏幕内容的高度 int screenHeight = getWindow().getDecorView().getHeight(); //获取View可见区域的bottom Rect rect = new Rect(); getWindow().getDecorView().getWindowVisibleDisplayFrame(rect); return screenHeight - rect.bottom != 0; &#125; 隐藏软键盘(只适用于Activity，不适用于Fragment) 1234567public static void hideSoftKeyboard(Activity activity) &#123; View view = activity.getCurrentFocus(); if (view != null) &#123; InputMethodManager inputMethodManager = (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE); inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); &#125;&#125; 隐藏软键盘(可用于Activity，Fragment) 1234567public static void hideSoftKeyboard(Context context, List&lt;View&gt; viewList) &#123; if (viewList == null) return; InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Activity.INPUT_METHOD_SERVICE); for (View v : viewList) &#123; inputMethodManager.hideSoftInputFromWindow(v.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android明进康5-1盒子定时开关机/","text":"配置: 1234567//工程的build.gradle中添加:allprojects &#123; repositories &#123; ... maven &#123; url &#x27;https://www.jitpack.io&#x27; &#125; &#125; &#125; 1implementation &#x27;com.github.fs437563:JetShineBoxSwitchPower:1.2&#x27; 1.添加权限 123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 2.同步系统时间 12//系统时间同步并非立即生效有1/2秒延迟,不要和开关机设置同时间执行BoxSwitchPowerUtil.getInstance().synSystemTime(2021,07,05,12,01,50; 3.设置开机 123 BoxSwitchPowerUtil.getInstance().openPower(MainActivity.this);//or BoxSwitchPowerUtil.getInstance().setStartTime(MainActivity.this,&quot;2021-07-05 12:03:00&quot;); 4.设置关机 123BoxSwitchPowerUtil.getInstance().closePower(MainActivity.this);//orBoxSwitchPowerUtil.getInstance().setCloseTime(MainActivity.this,&quot;2021-07-05 12:02:00&quot;);","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android调试输出log打印信息到本地文件/","text":"在android开发中，Eclipse或者AndroidStudio调试时打印的信息很多，或者某些log字数超过Eclipse一行的字数限制，这个时候Eclipse就傻傻地把超出一行的log省略掉了，给我们开发中带来不方便。或者在进行黑盒测试时，为了更加方便的找到错误信息，我们可以把log信息使用命令行查看或者直接输出到本地。下面是命令的格式： 12345678 V Verbose (default for &lt;tag&gt;) D Debug (default for &#x27;*&#x27;) I Info W Warn E Error F Fatal S Silent (suppress all output)adb shell logcat TAG:I *:S &gt; D:\\\\log.txt","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/app是否正在运行-运行状态/","text":"1234567891011121314151617181920212223/** * 返回app运行状态 * @param packageName 要判断应用的包名 * @return int 1:前台 2:后台 0:不存在 */private int isAppAlive(Context context, String packageName) &#123; ActivityManager activityManager = (ActivityManager) context .getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; listInfos = activityManager .getRunningTasks(20); // 判断程序是否在栈顶 if (listInfos.get(0).topActivity.getPackageName().equals(packageName)) &#123; return 1; &#125; else &#123; // 判断程序是否在栈里 for (ActivityManager.RunningTaskInfo info : listInfos) &#123; if (info.topActivity.getPackageName().equals(packageName)) &#123; return 2; &#125; &#125; return 0;// 栈里找不到，返回3 &#125;&#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/在线图片去底工具---将纯色背景的图片转换为背景透明的图片/","text":"#####地址：http://www.aigei.com/bgremover/工具说明： 当我们在提取一些素材图片的时候，可能由于图片格式等原因，使得原本背景透明的图片变成了纯色背景的图片。这时候我们可以使用BgRemover图片去底工具将“纯色背景的图片”再次还原成“透明背景的图片”。 操作方法： 点击“浏览文件”按钮，选择需要去底的图片，BgRemover会自动帮你完成图片去底工作，去底完成后点击下载按钮保存已去底的图片即可。 浏览器要求： 请使用IE9+,或者谷歌,火狐,360,搜狗等浏览器。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/自定义圆形头像CircleImageView的使用/","text":"效果图： 使用： 2个类：CircleImageView类：package com.lzyi.tpm.utils; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.RectF; import android.util.AttributeSet; import io.jchat.android.view.BaseImageView; public class CircleImageViewextends BaseImageView { public CircleImageView(Context context) { super(context); } public CircleImageView(Context context, AttributeSet attrs) { super(context, attrs); } public CircleImageView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } public static BitmapgetBitmap(int width, int height) { Bitmap bitmap &#x3D; Bitmap.createBitmap(width, height, ​ Bitmap.Config.ARGB_8888); ​ Canvas canvas &#x3D;new Canvas(bitmap); ​ Paint paint &#x3D;new Paint(Paint.ANTI_ALIAS_FLAG); ​ paint.setColor(Color.BLACK); ​ canvas.drawOval(new RectF(0.0f, 0.0f, width, height), paint); ​ return bitmap; } @Override public BitmapgetBitmap() { return getBitmap(getWidth(), getHeight()); } } BaseImageView类:package io.jchat.android.view; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.Paint; import android.graphics.PorterDuff; import android.graphics.PorterDuffXfermode; import android.graphics.Xfermode; import android.graphics.drawable.Drawable; import android.util.AttributeSet; import android.util.Log; import android.widget.ImageView; import java.lang.ref.WeakReference; public abstract class BaseImageViewextends ImageView { private static final StringTAG &#x3D; BaseImageView.class.getSimpleName(); protected ContextmContext; private static final XfermodesXfermode &#x3D;new PorterDuffXfermode(PorterDuff.Mode.DST_IN); &#x2F;&#x2F; private BitmapShader mBitmapShader; private BitmapmMaskBitmap; private PaintmPaint; private WeakReferencemWeakBitmap; public BaseImageView(Context context) { super(context); ​ sharedConstructor(context); } public BaseImageView(Context context, AttributeSet attrs) { super(context, attrs); ​ sharedConstructor(context); } public BaseImageView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); ​ sharedConstructor(context); } private void sharedConstructor(Context context) { mContext &#x3D; context; ​ mPaint &#x3D;new Paint(Paint.ANTI_ALIAS_FLAG); } public void invalidate() { mWeakBitmap &#x3D;null; ​ if (mMaskBitmap !&#x3D;null) {mMaskBitmap.recycle(); } super.invalidate(); } @SuppressLint(“DrawAllocation”) @Override protected void onDraw(Canvas canvas) { if (!isInEditMode()) { int i &#x3D; canvas.saveLayer(0.0f, 0.0f, getWidth(), getHeight(), ​ null, Canvas.ALL_SAVE_FLAG); ​ try { Bitmap bitmap &#x3D;mWeakBitmap !&#x3D;null ?mWeakBitmap.get() :null; ​ &#x2F;&#x2F; Bitmap not loaded. ​ if (bitmap &#x3D;&#x3D;null || bitmap.isRecycled()) { Drawable drawable &#x3D; getDrawable(); ​ if (drawable !&#x3D;null) { &#x2F;&#x2F; Allocation onDraw but it’s ok because it will not always be called. ​ bitmap &#x3D; Bitmap.createBitmap(getWidth(), ​ getHeight(), Bitmap.Config.ARGB_8888); ​ Canvas bitmapCanvas &#x3D;new Canvas(bitmap); ​ drawable.setBounds(0, 0, getWidth(), getHeight()); ​ drawable.draw(bitmapCanvas); ​ &#x2F;&#x2F; If mask is already set, skip and use cached mask. ​ if (mMaskBitmap &#x3D;&#x3D;null ||mMaskBitmap.isRecycled()) { mMaskBitmap &#x3D; getBitmap(); ​ } &#x2F;&#x2F; Draw Bitmap. ​ mPaint.reset(); ​ mPaint.setFilterBitmap(false); ​ mPaint.setXfermode(sXfermode); &#x2F;&#x2F; mBitmapShader &#x3D; new BitmapShader(mMaskBitmap, &#x2F;&#x2F; Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); &#x2F;&#x2F; mPaint.setShader(mBitmapShader); ​ bitmapCanvas.drawBitmap(mMaskBitmap, 0.0f, 0.0f, mPaint); ​ mWeakBitmap &#x3D;new WeakReference(bitmap); ​ } } &#x2F;&#x2F; Bitmap already loaded. ​ if (bitmap !&#x3D;null) { mPaint.setXfermode(null); &#x2F;&#x2F; mPaint.setShader(null); ​ canvas.drawBitmap(bitmap, 0.0f, 0.0f, mPaint); return; ​ } }catch (Exception e) { System.gc(); ​ Log.e(TAG, String.format(“Failed to draw, Id :: %s. Error occurred :: %s”, getId(), e.toString())); ​ }finally { canvas.restoreToCount(i); ​ } }else { super.onDraw(canvas); ​ } } public abstract BitmapgetBitmap(); }","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android FrameWork/VIM使用/","text":"描述 命令 linux安装vim sudo apt-get install vim 打开目标文件 vim MainActivity.java(目标路径） 不保存退出 :q 保存后退出 :wq 上 k 下 j 左 h 右 l 进入插入模式，进入可编辑模式 i 或a 或c 进入普通模式，退出可编辑模式 esc 进入可视模式,用来选中文字 小写v键（普通可视，自由选中），大写V键（行可视，只能整行选中），ctrl+v（列可视，整列的选中或移动） 光标移动到下一单词的开头 w 光标移动到上一单词的开头 b 光标移动到下一单词的结尾 e 光标移动到下一单词的结尾 ge 查找并移动到下一个｛char｝字符处 f{char} (分开按) 查找并移动到上一个｛char｝字符处 F{char} 查找并移动到下一个｛char｝字符的前一个字符处 t{char} 查找并移动到上一个｛char｝字符的前一个字符处 T{char} 重复上一次的字符查找命令 ； 反转方向重复上一次的字符查找命令 ， 分隔符文本对象选择，a(选中分隔符及分隔符包含的内容) 需要在v模式下执行,如： a(或ab ，选中（）及包含的内容；其他符号如(),{},[],&lt;&gt;,””,’’同理 分隔符文本对象选择，i(选中分隔符内部的内容，不包含分隔符) 需要在v模式下执行,如： i(或ib ，选中（）包含的内容不包含（）符号；其他符号如(),{},[],&lt;&gt;,””,’’同理 范围文本对象，选中当前单词 iw 范围文本对象，选中当前单词及一个空格 aw 范围文本对象，选中当前单词或字符串 iW 范围文本对象，选中当前单词或字符串及一个空格 aW 范围文本对象，选中当前句子 is 范围文本对象，选中当前句子及一个空格 as 范围文本对象，选中当前段落 ip 范围文本对象，选中当前段落及一个空格 ap 删除模式 d 分隔符文本对象或范围文本对象（上面提到的命令），如diw删除当前单词，dis删除当前句子 修改模式 c 分隔符文本对象或范围文本对象（上面提到的命令），如ciw删除当前单词并进入编辑模式，cis删除当前句子并进入编辑模式 复制模式 y 分隔符文本对象或范围文本对象（上面提到的命令），如yiw复制当前单词，yis复制当前句子 删除一行 dd 删除一行并进入插入模式 cc 复制一行 yy 粘贴 p 恢复上步操作&#x2F;撤销 u 设置标记 m{make} ，({make}是指任意键，如mm,可以同时标记多个) 返回标记 ` {make},&#96;是esc下面那个键 返回行首 gg vim代码提示器插件配置链接：https://pan.baidu.com/s/1uKEsv8vVhHjD8dF4lOt8cA 提取码：l11q 代码提示器快捷键：xx 命令 +tab键","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/adb常用命令/","text":"四大组件相关 1234567891011121314151617只查看当前Activity的包名(可能有多个)adb shell dumpsys activity top | grep ACTIVITY查看Activity详细信息adb shell dumpsys activity top也可以将输出重定向到文件中，下述命令会打印出所有应用的四大组件adb shell dumpsys &gt; info.txt查看Activity任务栈adb shell dumpsys activity activities查看后台Service信息adb shell service list 查看指定报名的数据库存储信息（包括存储的SQL语句，查看应用操作数据库信息）adb shell dumpsys dbinfo 包名 操作相关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768adb shell am force-stop 包名 # 强制关闭一个应用程序adb shell input tap x y # 点击坐标点adb shell input keyevent 82(keycode) # 发送按键adb shell input text XXXX # 输入文本录制日志到处到电脑本地adb logcat -s &gt; D:/logcat.txt截屏adb shell screencap -p /sdcard/screen.pngadb pull /sdcard/screen.pngadb shell rm /sdcard/screen.png 录屏adb shell screenrecord # 默认录制时间为180sadb shell screenrecord --time-limit 10 /sdcard/demo.mp4 # 限制时间为10s及输出路径adb shell screenrecord --size 1280*720 /sdcard/demo.mp4 # 指定分辨率adb shell screenrecord --bit-rate 6000000 /sdcard/demo.mp4 # 指定比特率adb shell screenrecord --verbose /sdcard/demo.mp4 # 在命令显示日志拉取设备中的文件到本地(如遇权限问题，用chmod改一下权限即可)adb pull &lt;手机路径&gt; &lt;本机路径&gt; 从手机中拉取信息放到本地电脑adb push &lt;本机路径&gt; &lt;手机路径&gt;从本地推送信息到手机上去推送文件到设备中adb push 设备的端口转发（IDA中调试很常用）adb forward 远程端协议:端口号 设备端协议:端口号查看设备中可以被调试的应用的进程号adb jdwp进adb shell才可以执行 查看进程信息ps | grep 过滤内容ps -t 进程id清空用户数据，安装，卸载pm clear 包名pm install apk文件pm uninstall 包名 启动应用，服务，发送广播am start -n 包名/包名.Activity名am startservice -n 包名/包名.Service名am broadcast -a 广播动作查看设备ip地址netcfg查看设备端口号netstat运行Java代码app_process 运行目录 运行主类运行一个dex文件dalvikvm -cp dex文件 运行主类查看当前应用的CPU消耗信息top 查看系统属性值getprop 属性名称 刷机相关 123adb reboot # 重启手机adb reboot bootloader # 重启到bootloader(刷机模式)adb reboot recovery # 重启到recovery(恢复模式) 安装包相关 12345678adb shell dumpsys package 包名 # 获取安装包信息aapt dump badging xxx.apk # 查看应用包名package和入口activity名dexdump xxx.dex # 查看一个dex文件的详细信息adb install -r &lt;apkfile&gt; # 覆盖安装(保留数据域缓存文件，重新安装apk)adb install -s &lt;apkfile&gt; # 安装apk到sd卡adb install -d &lt;apkfile&gt; # 无视版本号安装adb uninstall -k &lt;package&gt; # 卸载app(保留数据与缓存文件)adb shell pm list packages # 查看所有安装app的包名 设备信息 1234567891011121314151617adb shell cat /system/build.prop # 设备信息adb shell getprop [key] [value] # 设置/获取属性信息adb shell dumpsys window displays # 设备分辨率adb shell cat /sys/class/net/wlan0/address # MAC地址adb shell dumpsys account # 账号信息adb shell dumpsys cpuinfo # CPU信息adb shell cat /proc/cpuinfo # CPU序列号adb shell dumpsys wifi # Wifi信息adb shell dumpsys SurfaceFlinger # UI绘制的各个层级信息adb shell dumpsys window # 键盘，窗口和它们的关系adb shell dumpsys usagestats # 每个应用的启动次数与时间adb shell dumpsys statusbar # 状态栏相关的信息adb shell dumpsys meminfo # 内存信息adb shell dumpsys diskstats # 磁盘信息adb shell dumpsys battery # 电池信息adb shell dumpsys batterystats # 统计系统耗电量adb shell dumpsys alarm # Alarm 6.日志相关 清除log缓存 1adb logcat -c 查看过滤日志，每条日志都有一个标记和优先级与之关联 标记：简短字符串，标识原始信息来源 优先级：V-明细、D-调试、I-信息、W-警告、E-错误、F-严重错误 1adb logcat ActivityManager:I *:S 其他元数据字段 123456789101112131415brief — 显示优先级/标记和原始进程的PID (默认格式)process — 仅显示进程PIDtag — 仅显示优先级/标记thread — 仅显示进程：线程和优先级/标记raw — 显示原始的日志信息，没有其他的元数据字段time — 显示日期，调用时间，优先级/标记，PIDlong —显示所有的元数据字段并且用空行分隔消息内容adb logcat -v thread 指定循环缓冲区 1234567radio — 查看包含在无线/电话相关的缓冲区消息events — 查看事件相关的消息main — 查看主缓冲区 (默认缓冲区)adb logcat -b radio 打印系统事件的日志，如触屏 1adb logcat -b events -v time 导出ANR日志 12adb pull data/anr/traces.txt # 老版本Androidadb bugreport # 高版本用(老版本导出出现 → adb: error: failed to stat remote object) 其他 12345678910111213141516adb shell cat /proc/iomem # 查看wifi密码(要root权限)adb shell dumpsys activity|grep oom_adj # 设置线程的优先级adb shell cat proc/pid/maps # 指定进程内存地址映射adb shell cat proc/pid/smaps # 指定进程内存详细使用信息adb shell procrank # VSS. RSS. PSS. USS 信息adb shell procmem pid # 指定进程VSS. RSS. PSS. USS 详细信息adb shell getevent -p # 查看可输入的设备adb shell getevent /dev/input/event0 # 获得特定设备的输入信息adb shell ps | findstr mobileqq # 查看报名中包含mobileqq的进程adb get-serialno # 获取序列号adb shell top # CPU和内存占用情况adb shell top -m 6 # 占用内存前6的APPadb shell top -n 1 # 刷新一次内存信息，然后返回adb shell procrank # 各进程内存使用情况adb shell ps -x [PID] # 指定进程状态adb shell cat /proc/iomem # 查看IO内存分区","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android FrameWork/LINUX基础命令/","text":"常用命令 描述 pwd 显示当前路劲 cd xx 切换到xx路径 cd .. 切换到上级路径 cd ～ 快速返回根目录 clear 清空命令列表 ls 当前路上下所有文件 (ls后面可以一起输入 比如：ls _lh，ls_lah（没有顺序要求）) ls _l 列表形式显示文件 ls _a 显示隐藏文件 ls _l _h 列表显示并kb显示文件大小 ls 通配符： *代表0或多个任意字符 ls *.txt 显示.txt结尾的文件 ls 1* 显示所有以1开头的文件 ls 1*.txt 显示所有1开头.txt结尾的文件 ls xx 列出制定路径的文件及文件夹 ？ 代表1个任意字符(不能?单独使用需要有匹配信息) ls ??.txt 显示2个字符并且.txt结尾的文件 ls [0_9] [a_z] 可以直接写区间 tab键 自动不全（有多个匹配的情况下默认不补全，按2次tab键匹配） 方向键上&#x2F;下 快捷读取历史命令 121.隐藏文件都是以.开头，创建隐藏文件也是命名时.开头命名即可;2.&#x27;&#x27;路径或者名称有空格的 可以用&#x27;&#x27;包含起来 文件常用命令 描述 touch xx.txt 创建xx.txt文件到当前路径 mkdir xx 创建xx文件夹 rm xx.txt 移除xx文件 rm -d xx rm -d 移除文件夹 rm -r xx rm -r移除文件夹 mv xx.txt aa 移动xx文件或xx文件夹到aa文件夹，目标路径可以是相对路径或绝对路径（可移动时重命名） cp xx.txt aa 复制xx文件到aa文件夹（可复制时重命名） cp -r xx aa 复制xx文件夹到aa文件夹 xx –help 查看某个命令的帮助手册 man xx 查看某个命令的帮助手册 which xx 查看xx命令对应的文件对应路径 find 搜索范围 搜索条件 示例：find &#x2F;home -name 123.txt &#x2F;&#x2F;精准搜索 find &#x2F;hone -name *.txt &#x2F;&#x2F;模糊搜索 find &#x2F;home -iname *.txt &#x2F;&#x2F;不区分大小写 find &#x2F;home -type f &#x2F;&#x2F;-type f搜索所有文件,-type d搜索所有文件夹，-type l所有软链接 locate xx 全局模糊搜索xx文件及文件夹，搜索速度快，缺点有可能搜索不到最新创建的文件或文件夹，原因是locate本地自身有搜索库，新建的文件被收录到搜索库有延迟 cat xx 打开xx文件 more xx 分页显示xx文件，按空格翻页 echo xx 显示xx内容 echo 内容 &gt; 文件 &gt;把xx内容输入到xx文件，&gt;覆盖原有内容, &gt;&gt;追加内容 |（管道） 前面的结果作为输入,执行后面的命令使用，如：ls -lh | reap 123.txt ln 目标路径 创建路径及名称(软链接&#x2F;快捷方式) ln aa&#x2F;123.txt 123.txt sudo gedit xx 打开xx路径的文件","categories":[{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"}]},{"path":"wiki/Android Application/AndroidStudio插件/Alibaba-Java-Coding-Guidelines（阿里代码规范检测）/","text":"1.打开 IDEA ，选择 File - Settings - Plugins - Browse repositories打开 IDEA，选择 File - Settings - Plugins - Browse repositories 后，输入 alibaba 选中 Alibaba Java Coding Guidelines，点击 Install。2.重启IDEA，开始使用安装后，会提示你重启 IDEA 已启用插件，重启后就可以在你的项目上疯狂点击右键了，当然菜单栏也会出现俩按钮，它有个快捷键是Ctrl+Shift+Alt+J。选中某一个类，或者在这个类里边右键也可以重启后再工具栏按钮下拉框就会多一个阿里编码规约按钮，然后点击编码规约扫描，就会扫描你当前的项目了。 不扫不知道。一扫吓一跳，以前不以为然的写法，都会在这暴露无疑，重点是对于有线程安全问题的代码他也会提示。这很重要！！！","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"AndroidStudio插件","slug":"Android-Application/AndroidStudio插件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/AndroidStudio%E6%8F%92%E4%BB%B6/"}]},{"path":"wiki/Android Application/AndroidStudio插件/Studio汉化插件/","text":"","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"AndroidStudio插件","slug":"Android-Application/AndroidStudio插件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/AndroidStudio%E6%8F%92%E4%BB%B6/"}]},{"path":"wiki/Android Application/AndroidStudio插件/database-navigator查看数据库/","text":"####一 database navigatordatabase navigator是android studio的一个插件，可以用来查看sqlite数据库，也可以查看MySQL等其他数据库。####二 安装插件安装完成后会提示重启android studio，重启后，右侧出现DB Browser，至此安装完成。####三 导出database在device file explore中找到应用的db文件（在android studio 3.0才有该功能，之前的版本用DDMS导出）#####1.打开device file explore第一种：主体窗口的右下角，点击后直接打开第二种：通过工具栏打开， View &gt; Tool Windows &gt; Device File Explore这样就可以找到我们安装的app里的文件了。贴一张效果图：####找到手机里的db文件一般在data-包名-databases下的右键文件，导出到电脑中####四 使用database navigator查看数据库1、连接数据库2、添加刚刚导出的数据库文件3、打开SQL命令行工具4、输入sql语句 12//LOCAL_SYSTEM_MSG表名称select * from LOCAL_SYSTEM_MSG 5、查看结果#####注意android greenDao生成的不是db文件需要将文件末尾修改.db即可","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"AndroidStudio插件","slug":"Android-Application/AndroidStudio插件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/AndroidStudio%E6%8F%92%E4%BB%B6/"}]},{"path":"wiki/Android Application/AndroidStudio插件/翻译插件Translation/","text":"作为蛋蛋忧伤的程序员，在开发过程中，英文的命名是一件很要命的事情，不是词穷，就是拼音一顿命名，好阔怕的赶脚。每个程序员身边都有一个《有道》默默陪伴着！Translation 的使用：File-&gt;Settings-&gt;Plugins-&gt; 输入Translation即可，如下图 ####修改默认快捷键？File-&gt;Settings-&gt;keymap 输入translate设置完成之后的效果： 捕获logcat 下的日志翻译也是阔以的：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"AndroidStudio插件","slug":"Android-Application/AndroidStudio插件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/AndroidStudio%E6%8F%92%E4%BB%B6/"}]},{"path":"wiki/Android Application/Android动画/LayoutTransition（通用隐藏显示动画）/","text":"在Android应用开发的时候经常会用到View的setVisibility()方法来动态隐藏和显示view，但是这样子是没有过渡动画的，变化的时候会显得很生硬。 LayoutTransition是一个在4.0新引入的Api，主要功能是在ViewGroup的layout发生变化的时候能够自动创建动画。具体使用的时候，首先创建一个LayoutTransition对象，并在容器布局调用setLayoutTransition(LayoutTransition)方法。这样，每当有子view从容器中出现或消失的时候，默认的animator就会被自动调用。当然，你也可以通过setAnimator()来设置自定义的动画。 java中设置： 123ViewGroup container = (ViewGroup) findViewById(R.id.container);LayoutTransition transition = new LayoutTransition();container.setLayoutTransition(transition); 此外xml文件中我们在容器的中下面一句代码： 1android:animateLayoutChanges=&quot;true&quot; 在4.1 JellyBean上还有一个增强的功能，可以在容器内的子view的layout发生变化时也播放动画，用法如下: 12LayoutTransition transition = container.getLayoutTransition();transition.enableTransitionType(LayoutTransition.CHANGING); 效果图：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"}]},{"path":"wiki/Android Application/Android动画/共享元素（Shared-Element）/","text":"什么是共享元素呢？可以理解为当页面跳转是，看起来一个View属于界面A又属于界面B。 看一下下边这个效果： #####Step1: 123&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;&lt;/style&gt; #####Step2:为共享元素设置上transtionName。设置name的时候两个界面都要添加上，这样才可以检测到是哪两个元素共享。 123456&lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;100dp&quot; android:transitionName=&quot;image&quot; android:src=&quot;@drawable/default_image&quot; /&gt; 也可以在代码中设置：imageView.setTransitionName(“image”);#####Step3:设置好以上的参数后，就可以通过跳转来添加相应的动画了。是不是特别的简单。是的。没有错。只不过再跳转的时候还需要加点东西。看下代码： 1234Intent i = new Intent(mContext, Main2Activity.class);ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(mContext, holder.image, &quot;image&quot;);startActivity(i,optionsCompat.toBundle()); 通过上面的代码就可以实现ImageView的共享了。类似文章开头的效果。设置多个元素共享的时候需要这样: 123456Intent i = new Intent(mContext, Main2Activity.class);Pair&lt;View, String&gt; pair = new Pair&lt;View, String&gt;(holder.image,&quot;image&quot;);Pair&lt;View,String&gt; pairText = new Pair&lt;View, String&gt;(holder.text,&quot;text&quot;);ActivityOptionsCompat optionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(mContext, pair,pairText);startActivity(i,optionsCompat.toBundle()); 在上面的跳转代码中我们用到了ActivityOptionsCompat的两个静态方法。分别是 12makeSceneTransitionAnimation(Activity activity,View sharedElement,String sharedElementName)makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;... sharedElements) 通过函数的参数我们应该就可以看的明白，就不解释了。这两个函数就是用来设置共享元素的。","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"}]},{"path":"wiki/Android Application/Android动画/启动页缩放动画/","text":"1234567891011121314151617181920iv_start.setImageResource(R.drawable.start); //进行缩放动画 ScaleAnimation scaleAnimation = new ScaleAnimation(1.4f, 1.0f, 1.4f, 1.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnimation.setDuration(4000);//动画持续时间 //动画播放完成后保持形状 scaleAnimation.setFillAfter(true); scaleAnimation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; //可以在这里先进行某些操作 &#125; @Override public void onAnimationEnd(Animation animation) &#123; //动画执行结束 &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); view.startAnimation(scaleAnimation);//开始动画 要缩放哪个控件就用哪个控件来启动即可 ######效果图：","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"}]},{"path":"wiki/Android Application/Android动画/帧动画/","text":"####帧动画概念以及用法帧动画非常容易理解，其实就是简单的由N张静态图片收集起来，然后我们通过控制依次显示 这些图片，因为人眼”视觉残留”的原因，会让我们造成动画的”错觉”，跟放电影的原理一样！#####示例：#####代码实现：首先编写我们的动画文件，非常简单，先在res下的drawable创建一个文件： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;!--android:oneshot是设置动画是否只是播放一次，true只播放一次，false循环播放！--&gt; &lt;item android:drawable=&quot;@drawable/img_music&quot; android:duration=&quot;200&quot;/&gt; &lt;!--drawable 引用图片或其他drawable资源 --&gt; &lt;!--duration 执行时间--&gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot; android:duration=&quot;200&quot;/&gt;&lt;/animation-list&gt; 动画有了在view中设置src或者background引用动画的drawable文件： 12345&lt;ImageView android:id=&quot;@+id/img_anim&quot; android:src=&quot;@drawable/zhen_anim&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 控制动画的开始以及暂停： 12345 ImageView img_anim = findViewById(R.id.img_anim); AnimationDrawable anim_drawable = (AnimationDrawable)img_anim.getDrawable();// 这里如果是src引用的就用getDrawable（）如果是background就用getBackground（）强转为AnimationDrawable anim_drawable.start(); anim_drawable.stop();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"}]},{"path":"wiki/Android Application/Android动画/揭露效果/","text":"揭露效果是一个新增动画效果，体验非常不错。很多App都已经开始用起来了。效果图： 12345678910111213&lt;ImageView android:id=&quot;@+id/rect&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:layout_marginTop=&quot;30dp&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; rect = (ImageView) findViewById(R.id.rect); Animator animator2 = ViewAnimationUtils.createCircularReveal(rect, 0, 0, 0, (float) Math.hypot(rect.getWidth(), rect.getHeight()));animator2.setDuration(2000);animator2.start();","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"}]},{"path":"wiki/Android Application/Android动画/补间动画/","text":"####补间动画的分类和InterpolatorAndoird所支持的补间动画效果有如下这五种，或者说四种吧，第五种是前面几种的组合而已~ AlphaAnimation：透明度渐变效果，创建时许指定开始以及结束透明度，还有动画的持续 时间，透明度的变化范围(0,1)，0是完全透明，1是完全不透明；对应标签！ ScaleAnimation：缩放渐变效果，创建时需指定开始以及结束的缩放比，以及缩放参考点， 还有动画的持续时间；对应标签！ TranslateAnimation：位移渐变效果，创建时指定起始以及结束位置，并指定动画的持续 时间即可；对应标签！ RotateAnimation：旋转渐变效果，创建时指定动画起始以及结束的旋转角度，以及动画 持续时间和旋转的轴心；对应标签 AnimationSet：组合渐变，就是前面多种渐变的组合，对应标签 #####先要来了解一个东西：Interpolator用来控制动画的变化速度，可以理解成动画渲染器，当然我们也可以自己实现Interpolator 接口，自行来控制动画的变化速度，而Android中已经为我们提供了五个可供选择的实现类： LinearInterpolator：动画以均匀的速度改变 AccelerateInterpolator：在动画开始的地方改变速度较慢，然后开始加速 AccelerateDecelerateInterpolator：在动画开始、结束的地方改变速度较慢，中间时加速 CycleInterpolator：动画循环播放特定次数，变化速度按正弦曲线改变： Math.sin(2 * mCycles * Math.PI * input) DecelerateInterpolator：在动画开始的地方改变速度较快，然后开始减速 AnticipateInterpolator：反向，先向相反方向改变一段再加速播放 AnticipateOvershootInterpolator：开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator： 跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100 OvershottInterpolator：回弹，最后超出目的值然后缓慢改变到目的值而这个东东，我们一般是在写动画xml文件时会用到，属性是：android:interpolator， 而上面对应的值是：@android:anim&#x2F;linear_interpolator，其实就是驼峰命名法变下划线而已 AccelerateDecelerateInterpolator对应：@android:anim&#x2F;accelerate_decelerate_interpolator！ ####各种动画的详细讲解动画的xml文件都是建在res下的anim文件夹内这里的android:duration都是动画的持续时间，单位是毫秒~####AlphaAnimation(透明度渐变) 12345&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot; android:duration=&quot;2000&quot;/&gt; 属性解释： fromAlpha :起始透明度 toAlpha:结束透明度 透明度的范围为：0-1，完全透明-完全不透明 ####ScaleAnimation(缩放渐变) 123456789&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromXScale=&quot;0.2&quot; android:toXScale=&quot;1.5&quot; android:fromYScale=&quot;0.2&quot; android:toYScale=&quot;1.5&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:duration=&quot;2000&quot;/&gt; 属性解释： fromXScale&#x2F;fromYScale：沿着X轴&#x2F;Y轴缩放的起始比例 toXScale&#x2F;toYScale：沿着X轴&#x2F;Y轴缩放的结束比例 pivotX&#x2F;pivotY：缩放的中轴点X&#x2F;Y坐标，即距离自身左边缘的位置，比如50%就是以图像的 中心为中轴点 ####TranslateAnimation(位移渐变) 1234567&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;320&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;0&quot; android:duration=&quot;2000&quot;/&gt; 属性解释： fromXDelta&#x2F;fromYDelta：动画起始位置的X&#x2F;Y坐标 toXDelta&#x2F;toYDelta：动画结束位置的X&#x2F;Y坐标 ####RotateAnimation(旋转渐变) 123456789&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:duration=&quot;1000&quot; android:repeatCount=&quot;1&quot; android:pivotX=&quot;50.0%&quot; android:pivotY=&quot;50.0%&quot; android:repeatMode=&quot;reverse&quot;/&gt; 属性解释： fromDegrees&#x2F;toDegrees：旋转的起始&#x2F;结束角度 repeatCount：旋转的次数，默认值为0，代表一次，假如是其他值，比如3，则旋转4次 另外，值为-1或者infinite时，表示动画永不停止 repeatMode：设置重复模式，默认restart，但只有当repeatCount大于0或者infinite或-1时 才有效。还可以设置成reverse，表示偶数次显示动画时会做方向相反的运动！ ####AnimationSet(组合渐变)非常简单，就是前面几个动画组合到一起而已~ 1234567891011121314151617181920212223242526272829303132&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:shareInterpolator=&quot;true&quot; &gt; &lt;scale android:duration=&quot;2000&quot; android:fromXScale=&quot;0.2&quot; android:fromYScale=&quot;0.2&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.5&quot; android:toYScale=&quot;1.5&quot; /&gt; &lt;rotate android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; android:toDegrees=&quot;360&quot; /&gt; &lt;translate android:duration=&quot;2000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;320&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;alpha android:duration=&quot;2000&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.1&quot; /&gt; &lt;/set&gt; ####动画调用： 123456789101112131415161718192021222324252627282930@Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_alpha: Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha); img_show.startAnimation(animation); break; case R.id.btn_scale: Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_scale); img_show.startAnimation(animation); break; case R.id.btn_tran: Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_translate); img_show.startAnimation(animation); break; case R.id.btn_rotate: Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_rotate); img_show.startAnimation(animation); break; case R.id.btn_set: Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_set); img_show.startAnimation(animation); break; &#125; &#125; ####动画状态的监听我们可以对动画的执行状态进行监听，调用动画对象的：setAnimationListener(new AnimationListener())方法，重写下面的三个方法： onAnimationStart()：动画开始 onAnimtaionRepeat()：动画重复 onAnimationEnd()：动画结束即可完成动画执行状态的监听~ ####为View动态设置动画效果先调用AnimationUtils.loadAnimation(动画xml文件)，然后View控件调用startAnimation(anim) 开始动画这是静态加载的方式，当然你也可以直接创建一个动画对象，用Java代码完成设置，再调用 startAnimation开启动画####注意补间动画位置改变后，其位置还是在原来的地方只是视图位置改变了，像按钮的点击事件还是在原来的地方！","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"}]},{"path":"wiki/Android Application/android-https双向验证/Glide-okhttps证书验证全局配置/","text":"第一步 新建AppGlideModule： 123456789101112131415161718192021222324252627282930313233343536373839package com.guoshikeji.dramecard.utils;import android.content.Context;import android.support.annotation.NonNull;import android.util.Log;import com.bumptech.glide.Glide;import com.bumptech.glide.GlideBuilder;import com.bumptech.glide.Registry;import com.bumptech.glide.annotation.GlideModule;import com.bumptech.glide.load.model.GlideUrl;import com.bumptech.glide.module.AppGlideModule;import java.io.InputStream;/** * Register &#123;@link FlickrModelLoader&#125; for the Flickr sample app. */@GlideModulepublic class FlickrGlideModule extends AppGlideModule &#123; @Override public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) &#123; super.applyOptions(context, builder);// builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_ARGB_8888)); &#125; @Override public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) &#123; Log.e(&quot;tyl&quot;,&quot;-----registerComponents-------&quot;); registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory()); &#125; @Override public boolean isManifestParsingEnabled() &#123; return false; &#125;&#125; 第二步 AndroidManifest.xml中配置meta-data ： 123456 &lt;application&gt; &lt;meta-data android:name=&quot;com.guoshikeji.dramecard.utils.FlickrGlideModule&quot; android:value=&quot;GlideModule&quot; /&gt;&lt;!--activitys /&gt;--&gt; &lt;application/&gt; 第三步 proguard-rules.pro文件中忽略GlideModule混淆： 123#GlideModule路径-keepnames class com.guoshikeji.dramecard.utils.FlickrGlideModule-keepresourcexmlelements manifest/application/meta-data@value=GlideModule 第四步 在继承AppGlideModule类的registerComponents方法中添加忽略证书认证： 12registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory()); &lt;!--重点是这句话：new OkHttpUrlLoader.Factory()--&gt; 重写OkHttpUrlLoader类的Factory，给OkHttpClient添加证书认证： 123456789101112131415161718192021222324252627 public static class Factory implements ModelLoaderFactory&lt;GlideUrl, InputStream&gt; &#123; private static volatile Call.Factory internalClient; private final Call.Factory client; private static Call.Factory getInternalClient() &#123;// glide添加双向认证 OkHttpClient.Builder okHttpClient = new OkHttpClient().newBuilder(); okHttpClient.hostnameVerifier(new Home());//忽略证书域名不受信任问题 okHttpClient.sslSocketFactory(MySSLSocketFactory.getSocketFactory(MyApplication.getInstance()));//添加证书 OkHttpClient build = okHttpClient.build(); if (internalClient == null) &#123; synchronized (Factory.class) &#123; if (internalClient == null) &#123; internalClient = build; &#125; &#125; &#125; return internalClient; &#125; private static class Home implements HostnameVerifier &#123; public SSLSession sslSession; @Override public boolean verify(String hostname, SSLSession session) &#123; this.sslSession = session; return true; &#125; &#125; 添加证书的MySSLSocketFactory类代码可复制https://www.jianshu.com/p/6229d10d3550中的SSLSocketFactory类和X509TrustManager 这2个类即可！ ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a ####工具类： 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/P12证书转BKS证书/","text":"1.请先下载第三方转换工具protecle，配置java环境 下载链接： http://download.csdn.net/detail/zhangyong125/93766672.点击运行protecle.jar3.新建BKSStore4.导入p12密钥对(p12文件)，包含公钥和私钥4.修改别名5.为客户端的私钥创建密码6.另存为BKS ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/android-https双向验证-总结/","text":"####各类知识点整理： 1234567891011121314151617 单双向验证基础知识点：https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器：https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/android-okhttps双向验证/","text":"使用： 12345678910111213141516171819202122232425262728293031323334353637 public void getHttps() &#123; try &#123; OkHttpClient mOkHttpClient = null; mOkHttpClient = new OkHttpClient().newBuilder()// 主要就是下面2句，其他的和正常请求都一样的 .hostnameVerifier(new Home())//忽略服务器域名不信任警告 .sslSocketFactory(MySSLSocketFactory.getSocketFactory(MainActivity.this))//加入证书 .build(); Request request = new Request.Builder() .url(url) .build(); Call call = mOkHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, final IOException e) &#123; Log.e(&quot;tyl&quot;, &quot;onFailure=&quot; + e.getMessage()); &#125; @Override public void onResponse(Call call, final Response response) throws IOException &#123; Log.e(&quot;tyl&quot;, &quot;onResponse=&quot; + response.body().string()); &#125; &#125;); &#125; catch (Exception e) &#123; Log.e(&quot;tyl&quot;, &quot;IOException=&quot; + e); e.printStackTrace(); &#125; &#125; public class Home implements HostnameVerifier &#123; public SSLSession sslSession; @Override public boolean verify(String hostname, SSLSession session) &#123; this.sslSession = session; return true; &#125; &#125; 证书文件放在： SSLSocketFactory: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.tgdz.my.testhttps;import android.content.Context;import android.util.Log;import java.io.IOException;import java.io.InputStream;import java.security.KeyStore;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import javax.net.ssl.KeyManagerFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.TrustManagerFactory;import javax.net.ssl.X509TrustManager;/** * Created by tyl * 2018/7/9/009 * Describe: */public class MySSLSocketFactory &#123; private static final String KEY_STORE_TYPE_BKS = &quot;bks&quot;;//证书类型 private static final String KEY_STORE_TYPE_P12 = &quot;PKCS12&quot;;//证书类型 private static final String KEY_STORE_PASSWORD = &quot;123456&quot;;//证书密码（应该是客户端证书密码，没有密码的直接改为空字符串） private static final String KEY_STORE_TRUST_PASSWORD = &quot;123456&quot;;//授信证书密码（应该是服务端证书密码） private static InputStream trust_input; private static InputStream client_input; public static SSLSocketFactory getSocketFactory(Context context) &#123;// 可以使用bks和client.cer来验证 去掉注释的代码，client.p12替换ca.p12即可，也可以直接通过p12我测试的时候也是通过的 try &#123; //服务器授信证书// trust_input = context.getResources().getAssets().open(&quot;client.bks&quot;); //客户端证书 client_input = context.getResources().getAssets().open(&quot;ca.p12&quot;); SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);// KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());// trustStore.load(trust_input, KEY_STORE_TRUST_PASSWORD.toCharArray());// KeyStore存放证书及密匙的仓库 KeyStore keyStore = KeyStore.getInstance(KEY_STORE_TYPE_P12); keyStore.load(client_input, KEY_STORE_PASSWORD.toCharArray());// KeyManagerFactory证书管理类 KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, KEY_STORE_PASSWORD.toCharArray());// 核心代码 SSLContext此类的实例表示安全套接字协议的实现， 它是SSLSocketFactory、SSLServerSocketFactory和SSLEngine的工厂。// 这里注意有一个坑，之前我写的时候参考的网上文档大部分都是使用的是TrustManager系统默认的证书管理器但是自建证书需要使用X509TrustManager来实现 sslContext.init(keyManagerFactory.getKeyManagers(),new TrustManager[]&#123;new TrustAllCerts()&#125;, new SecureRandom()); SSLSocketFactory factory = sslContext.getSocketFactory(); return factory; &#125; catch (Exception e) &#123; e.printStackTrace(); Log.e(&quot;tyl&quot;,&quot;Exception=&quot;+e.getMessage()); return null; &#125; finally &#123; try &#123;// trust_input.close(); client_input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.e(&quot;tyl&quot;,&quot;Exception=&quot;+e.getMessage()); &#125; &#125; &#125;&#125;; X509TrustManager : 123456789101112131415161718192021222324252627282930313233package com.tgdz.my.testhttps;import android.util.Log;import java.security.cert.X509Certificate;import javax.net.ssl.X509TrustManager;/** * Created by tyl * 2018/7/12/012 * Describe: */public class TrustAllCerts implements X509TrustManager &#123;// 默认的下面3个接口都会抛出一个异常,这里直接去掉异常,就是客户端忽略验证服务器端的验证信息直接通过 @Override public void checkClientTrusted( X509Certificate[] chain, String authType) &#123; Log.e(&quot;tyl&quot;,&quot;checkClientTrusted&quot;); &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) &#123; Log.e(&quot;tyl&quot;,&quot;checkServerTrusted&quot;); &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; Log.e(&quot;tyl&quot;,&quot;getAcceptedIssuers&quot;); return new X509Certificate[]&#123;&#125;;&#125;&#125; ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/android-webView的双向验证/","text":"使用： 1my_webview.setWebViewClient(new SslWebViewClient(this)); 直接复制下面2个类之后webview调用(虽然代码有点多，但其实有很多是没有用到的！只是因为不同证书类型可能会用到不同的代码而暂时保留) com.tgdz.my.testhttps;1234567891011121314151617181920212223242526272829303132import android.util.Log;import java.security.cert.X509Certificate;import javax.net.ssl.X509TrustManager;/** * Created by tyl * 2018/7/12/012 * Describe: */public class TrustAllCerts implements X509TrustManager &#123;// 默认的下面3个接口都会抛出一个异常,这里直接去掉异常,就是客户端忽略验证服务器端的验证信息直接通过 @Override public void checkClientTrusted( X509Certificate[] chain, String authType) &#123; Log.e(&quot;tyl&quot;,&quot;checkClientTrusted&quot;); &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) &#123; Log.e(&quot;tyl&quot;,&quot;checkServerTrusted&quot;); &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; Log.e(&quot;tyl&quot;,&quot;getAcceptedIssuers&quot;); return new X509Certificate[]&#123;&#125;;&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248package com.tgdz.my.testhttps; import android.annotation.TargetApi; import android.content.Context; import android.net.Uri; import android.os.Build; import android.util.Log; import android.webkit.WebResourceRequest; import android.webkit.WebResourceResponse; import android.webkit.WebView; import android.webkit.WebViewClient; import java.io.IOException; import java.io.InputStream; import java.net.MalformedURLException; import java.net.URL; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.UnrecoverableKeyException; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.KeyManager; import javax.net.ssl.KeyManagerFactory; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import javax.net.ssl.TrustManagerFactory; import javax.net.ssl.X509TrustManager;public class SslWebViewClient extends WebViewClient &#123; private SSLContext sslContext; private static final String KEY_STORE_TYPE_BKS = &quot;bks&quot;;//证书类型 private static final String KEY_STORE_TYPE_P12 = &quot;PKCS12&quot;;//证书类型 private static final String KEY_STORE_PASSWORD = &quot;&quot;;//证书密码（应该是客户端证书密码） private static final String KEY_STORE_TRUST_PASSWORD = &quot;123456&quot;;//授信证书密码（应该是服务端证书密码） private static InputStream trust_input; private static InputStream client_input; public SslWebViewClient(Context context) &#123; try &#123; //服务器授信证书// trust_input = context.getResources().getAssets().open(&quot;client.bks&quot;); //客户端证书 client_input = context.getResources().getAssets().open(&quot;ca.p12&quot;); sslContext = SSLContext.getInstance(&quot;TLS&quot;);// KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());// trustStore.load(trust_input, KEY_STORE_TRUST_PASSWORD.toCharArray()); KeyStore keyStore = KeyStore.getInstance(KEY_STORE_TYPE_P12); keyStore.load(client_input, KEY_STORE_PASSWORD.toCharArray());// TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());// trustManagerFactory.init(trustStore); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, KEY_STORE_PASSWORD.toCharArray()); sslContext.init(keyManagerFactory.getKeyManagers(),new TrustManager[]&#123;new TrustAllCerts()&#125;, new SecureRandom());// SSLSocketFactory factory = sslContext.getSocketFactory(); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.e(&quot;tyl&quot;,&quot;Exception=&quot;+e.getMessage()); &#125; finally &#123; try &#123;// trust_input.close(); client_input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.e(&quot;tyl&quot;,&quot;Exception=&quot;+e.getMessage()); &#125; &#125; &#125; @Override public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; return processRequest(Uri.parse(url)); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123; return processRequest(request.getUrl()); &#125; private WebResourceResponse processRequest(Uri uri) &#123; try &#123; //设置连接 URL url = new URL(uri.toString()); HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); //为request设置SSL Socket Factory urlConnection.setSSLSocketFactory(sslContext.getSocketFactory()); urlConnection.setHostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); //获取请求的内容、contentType、encoding InputStream inputStream = urlConnection.getInputStream(); String contentType = urlConnection.getContentType(); String encoding = urlConnection.getContentEncoding(); if (null != contentType)&#123; String mimeType = contentType; if (contentType.contains(&quot;;&quot;))&#123; mimeType = contentType.split(&quot;;&quot;)[0].trim(); &#125; //返回新的response return new WebResourceResponse(mimeType, encoding, inputStream); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private TrustManager[] prepareTrustManager(InputStream... certificates) &#123; if (certificates == null || certificates.length &lt;= 0)&#123; return null; &#125; try &#123; CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null); int index = 0; for (InputStream certificate : certificates) &#123; String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate)); try &#123; if (certificate != null) certificate.close(); &#125; catch (IOException e)&#123; &#125; &#125; TrustManagerFactory trustManagerFactory = null; trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); return trustManagers; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private KeyManager[] prepareKeyManager(InputStream bksFile, String password) &#123; try &#123; if (bksFile == null || password == null)&#123; return null; &#125; KeyStore clientKeyStore = KeyStore.getInstance(&quot;BKS&quot;); clientKeyStore.load(bksFile, password.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(clientKeyStore, password.toCharArray()); return keyManagerFactory.getKeyManagers(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) &#123; for (TrustManager trustManager : trustManagers) &#123; if (trustManager instanceof X509TrustManager) &#123; return (X509TrustManager) trustManager; &#125; &#125; return null; &#125; public static class MyTrustManager implements X509TrustManager&#123; private X509TrustManager defaultTrustManager; private X509TrustManager localTrustManager; public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException &#123; TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); var4.init((KeyStore) null); defaultTrustManager = chooseTrustManager(var4.getTrustManagers()); this.localTrustManager = localTrustManager; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; try &#123; defaultTrustManager.checkServerTrusted(chain, authType); &#125; catch (CertificateException ce) &#123; localTrustManager.checkServerTrusted(chain, authType); &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125; public static class UnSafeTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new java.security.cert.X509Certificate[]&#123;&#125;; &#125; &#125;&#125; ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/android-单双向验证知识点/","text":"单向认证和双向认证的区别： 单向认证只要求站点部署了ssl证书就行，任何用户都可以去访问（IP被限制除外等），只是服务端提供了身份认证。 而双向认证则是需要是服务端需要客户端提供身份认证，只能是服务端允许的客户能去访问，安全性相对于要高一些 双向认证SSL 协议的具体通讯过程，这种情况要求服务器和客户端双方都有证书。 单向认证SSL 协议不需要客户端拥有CA证书，以及在协商对称密码方案，对称通话密钥时，服务器发送给客户端的是没有加过密的（这并不影响SSL过程的安全性）密码方案。 这样，双方具体的通讯内容，就是加密过的数据。 如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密的数据进行解密，这时候的安全就依赖于密码方案的安全。 而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够的安全。这也是我们强调要求使用128位加密通讯的原因。 一般Web应用都是采用单向认证的，原因很简单，用户数目广泛，且无需做在通讯层做用户身份验证，一般都在应用逻辑层来保证用户的合法登入。 但如果是企业应用对接，情况就不一样，可能会要求对客户端（相对而言）做身份验证。这时就需要做双向认证。单向认证和双向认证的过程： ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/android获取证书文件/","text":"我们作为android前端，一般获取证书的方式就2种：1：服务器组直接给（之前在写的时候看到好多网上的文档，都说的java要jks文件，android用bks文件，但是我写好之后测试后台给我的p12文件就直接可以的）；2：从浏览器获取（也可以说是p12转cer的一种方式，下面以谷歌浏览器为例，）：选择证书：记得加上.cer的后缀名 ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/https双向认证证书生成/","text":"前期准备：ssl证书生成一般可以通过2种工具：java环境下的keytool和openssl 但是大部分使用的都是openssl网上的命令文档也是以openssl居多，下面以openssl举例;penSSL 是一个安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。单独下载openssl的话需要配置环境，这点可以自行百度进行配置！我这边因为还需要配置phpsudy服务器而phpstudy自带有openssl工具所以我就没有去单独下载，后面也是以phpstudy自带的openssl为例说明：phpstudy本地路劲：比如正常的openssl命令是下面这样： 1openssl genrsa -des3 -out ca.key 2048 使用的时候则把openssl指向自己本地路劲的位置即可： 1F:\\PHPStudy\\PHPTutorial\\Apache\\bin\\openssl genrsa -des3 -out ca.key 2048 下面则直接使用正常命令，路劲手动替换一下即可：win系统下新建一个文件夹用系统管理员打开windows.powershell界面：开始正式生成证书：1.CA私钥: ca.key 1openssl genrsa -out ca.key 1024 2.创建根证书请求文件ca.csr: 1openssl req -new -out ca.csr -key ca.key.key 这里需要填入配置信息： 123456789Country Name (2 letter code) [AU]:cn 国家名(2个字母的代号)State or Province Name (full name) [Some-State]:cq 省Locality Name (eg, city) []:cq 市Organization Name (eg, company) [Internet Widgits Pty Ltd]:gs 公司名Organizational Unit Name (eg, section) []:gs 组织或部门名Common Name (eg, YOUR name) []:test.com 域名（尽量用服务器域名，不然会引起服务器警告）Email Address []: 邮箱地址(不填直接回车)A challenge password []:123456 密码An optional company name []:gs 公司名 3.自签根证书ca.cer： 1openssl x509 -req -in ca.csr -out ca.cer -signkey ca.key -CAcreateserial -days 3650 4.生成p12格式根证书ca.p12(密码填写123456,之前ca.csr的密码,ps:这里输入的时候是不可见的输入完成后回车即可) 1openssl pkcs12 -export -clcerts -in ca.cer -inkey ca.key -out ca.p12 5.生成服务端key server.key: 1F:\\PHPStudy\\PHPTutorial\\Apache\\bin\\openssl genrsa -out server.key 1024 6.生成服务端请求文件 server.csr 1openssl req -new -out server.csr -key server.key 填入证书配置信息： 123456789Country Name (2 letter code) [AU]:cn 国家名(2个字母的代号)State or Province Name (full name) [Some-State]:cq 省Locality Name (eg, city) []:cq 市Organization Name (eg, company) [Internet Widgits Pty Ltd]:gs 公司名Organizational Unit Name (eg, section) []:gs 组织或部门名Common Name (eg, YOUR name) []:test.com 域名（尽量用服务器域名，不然会引起服务器警告）Email Address []: 邮箱地址A challenge password []:123456 密码An optional company name []:gs 公司名 7.生成服务端证书server.cer（ca.cer，ca.key，servr.key，server.csr这4个生成服务端证书）: 1openssl x509 -req -in server.csr -out server.cer -signkey server.key -CA ca.cer -CAkey ca.key -CAcreateserial -days 3650 8.生成客户端key client.key: 1openssl genrsa -out client.key 1024 9.生成客户端请求文件client.csr: 1openssl req -new -out client.csr -key client.key 填入证书配置信息: 123456789Country Name (2 letter code) [AU]:cn 国家名(2个字母的代号)State or Province Name (full name) [Some-State]:cq 省Locality Name (eg, city) []:cq 市Organization Name (eg, company) [Internet Widgits Pty Ltd]:gs 公司名Organizational Unit Name (eg, section) []:gs 组织或部门名Common Name (eg, YOUR name) []:tyl 签发机构\\开发者人员（这里随意）Email Address []: 邮箱地址A challenge password []:123456 密码An optional company name []:gs 公司名 10.生成客户端证书 client.cer: 1openssl x509 -req -in client.csr -out client.cer -signkey client.key -CA ca.cer -CAkey ca.key -CAcreateserial -days 3650 11.生成客户端p12格式根证书client.p12(密码设置123456)： 1openssl pkcs12 -export -clcerts -in client.cer -inkey client.key -out client.p12 至此，证书就制作完毕了：服务器端配置(详细配置过程可见：https://www.jianshu.com/p/bbf853fc28f3)： 12345678910111213141516171819server &#123; listen 443 ssl; #http的端口号是80，https的端口为443 server_name www.test.com #服务器域名 配置多个时不要添加;号即可 ServerName 127.0.0.1 ServerName 192.168.0.111; ssl on; #开启ssl ssl_certificate C:\\Users\\Administrator\\Desktop\\ssl4\\server.cer; #服务器证书文件 ssl_certificate_key C:\\Users\\Administrator\\Desktop\\ssl4\\server.key; #服务器证书密匙 ssl_client_certificate C:\\Users\\Administrator\\Desktop\\ssl4\\ca.cer; #根证书 ssl_verify_depth 1; ssl_verify_client on; #开启客户端验证 location / &#123; root F:\\PHPStudy\\PHPTutorial\\WWW; #本地网站文件目录 index index.HTML index.html index.htm ; &#125; &#125; 小建议：制作的时候有的命令可以自行修改的，如证书名称等。可自建一个txt文本，把openssl命令复制进去后再进行修改好后，才复制到windows powershell界面中执行注意：windows powershell执行openssl命令不能有错误提示，认真比对一下证书生成过后的提示，哪怕是警告也可能造成证书是失效的！我就踩过不少的坑，有的错误可以自行百度错误提示解决！","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/配置完成后的测试/","text":"以本地服务器为例（我的本地域名配置的是www.test.com）:浏览器打开浏览器输入https://www.test.com/出现下面的界面，这是现在还没有导入证书服务器拒绝访问：谷歌浏览器为例： 打开浏览器设置-高级-管理证书-导入-下一步-浏览(选择证书路劲，选中client.p12，文件类型那里改为全部类型就可以看到p12文件了)-输入p12证书密码-下一步一直至完成即可-导入完成后重启浏览器-输入https://www.test.com/-弹出证书导入弹窗选择确定-正常访问目标网页！备注：因为我们是android端，这里其实只是浏览器可以进行服务器访问了，但是我们在手机端进行访问的话，还是会找不到本地服务器地址，这是因为服务器还需要配置局域网访问，我这里是直接通过配置dns服务器来解决的，相关资料可自行百度! ####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 phpstudy搭建本地服务器： https://www.jianshu.com/p/bbf853fc28f3 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/android-https双向验证/phpstudy搭建本地服务器/","text":"这里只是做一个phpstudy的配置回顾，因为我也是配置成功之后回头来梳理一下，有的细节可能忘掉了，尽量弄详细一些！phpStudy是一个PHP调试环境的程序集成包。 该程序包集成最新的Apache+PHP+MySQL+NIGINX+phpMyAdmin+ZendOptimizer,一次性安装,无须配置即可使用,是非常方便、好用的PHP调试环境.该程序不仅包括PHP调试环境,还包括了数据库、开发工具、开发手册等.。同时phpStudy还自带有openssl工具（我们证书生成所要用到的）；下载地址：http://phpstudy.php.cn/正常启动后的客户端：默认的服务器应该是php+apache，因为apache的双向验证资料太少所以我选择了用nginx服务器：服务器切换完毕之后，打开vhosts文件简单的服务器配置： 12345678910111213141516server &#123; listen 443 ssl; #http的端口号是80，https的端口为443 server_name www.test.com #服务器域名 配置多个时不要添加;号即可 ServerName 127.0.0.1 ServerName 192.168.0.111; #本机电脑的ip地址 ssl on; #开启ssl ssl_certificate C:\\Users\\Administrator\\Desktop\\ssl4\\server.cer; #服务器证书文件 ssl_certificate_key C:\\Users\\Administrator\\Desktop\\ssl4\\server.key; #服务器证书密匙 ssl_client_certificate C:\\Users\\Administrator\\Desktop\\ssl4\\ca.cer; #根证书 ssl_verify_depth 1; #这里不是必须的，好像是根证书层级！ ssl_verify_client on; #开启客户端验证 location / &#123; root F:\\PHPStudy\\PHPTutorial\\WWW; #本地网站文件目录 index index.HTML index.html index.htm ; &#125; &#125; html本地文件的路径会有差异，自己配置一下应该不难！html里面的内容： 12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;测试Demo&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;测试&lt;/h1&gt;&lt;/center&gt;&lt;center&gt;123456&lt;/center&gt;&lt;hr&gt;&lt;center&gt;aaa&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 打开phpstudy自带的openssl工具，在后面证书生成的时候需要： 到这里基本上就已经配置完了，还是比较简单的！正常状态的话下面2个圆点都是绿色的，红色的话说明是哪里配置错误了，因为现在端口号配置的是https所以本地是打不开的 ！其他的可以自己百度一下其他资料，也可以查看一下PHPStudy\\PHPTutorial\\nginx\\logs目录下的成功或者错误日志！####各类知识点整理： android https双向验证 前言及总结：https://www.jianshu.com/p/07ce321d80ab 单双向验证基础知识点： https://www.jianshu.com/p/ea5f4b1d9c00 浏览器获取证书文件（p12转cer）：https://www.jianshu.com/p/7f74acab6c74 https双向认证证书生成：https://www.jianshu.com/p/094c7fc8cb85 android okhttps双向验证(代码实现)：https://www.jianshu.com/p/6229d10d3550 android webView的双向验证：https://www.jianshu.com/p/e98119d04fd9 配置完成后的测试：https://www.jianshu.com/p/cfcf708a591a Glide okhttps证书验证全局配置:https://www.jianshu.com/p/ac0b5c5f3ca7 ####工具类： P12证书转BKS证书：https://www.jianshu.com/p/2a96c36b27fe 服务器网址检测（兼容性及协议检测）：https://www.ssllabs.com/index.html ####源码： github：https://github.com/fs437563/android_https","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}]},{"path":"wiki/Android Application/Android工具类/Android动态修改桌面图标及应用桌面应用名称/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--系统默认入口--&gt; &lt;activity android:name=&quot;.login_moudle.StartActivity&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;!--&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; 注释掉LAUNCHER--&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- icon-桌面图标 name-名称可以随意 label-可以省略 修改应用名称 targetActivity-要跳转的activity(主activity) enabled-不要动态修改 --&gt; &lt;!--默认图标--&gt; &lt;activity-alias android:icon=&quot;@mipmap/ic_launcher&quot; android:name=&quot;default&quot; android:label=&quot;@string/app_name&quot; android:targetActivity=&quot;.login_moudle.StartActivity&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; &lt;!--要修改的图标--&gt; &lt;activity-alias android:icon=&quot;@mipmap/ic_launcher_round&quot; android:name=&quot;icon1&quot; android:label=&quot;@string/call_110&quot; android:targetActivity=&quot;.login_moudle.StartActivity&quot; android:enabled=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; 12345678910111213141516171819202122232425262728293031323334353637public class StartActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); final ComponentName iconCom = new ComponentName(StartActivity.this, &quot;com.guoshikeji.driver95128.icon1&quot;);//这里填写的是 包名+activity-alias中的name final ComponentName defaultCom = new ComponentName(StartActivity.this, &quot;com.guoshikeji.driver95128.default&quot;); findViewById(R.id.bn_default).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;//切换为icon1图标 enableComponent(iconCom); disableComponent(defaultCom); &#125; &#125;); findViewById(R.id.bn_icon1).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;//切换为default图标 enableComponent(defaultCom); disableComponent(iconCom); &#125; &#125;); &#125;//不可用状态：COMPONENT_ENABLED_STATE_DISABLED //可用状态：COMPONENT_ENABLED_STATE_ENABLED //默认状态：COMPONENT_ENABLED_STATE_DEFAULT private void enableComponent(ComponentName componentName) &#123; getPackageManager().setComponentEnabledSetting(componentName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0); &#125; private void disableComponent(ComponentName componentName) &#123; getPackageManager().setComponentEnabledSetting(componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);// 0立即生效会杀掉进程 DONT_KILL_APP约10秒后生效 android10也会杀掉进程 10以下不会 &#125;&#125; 以上方式测试android10以下可以完美实现替换图标功能，android10测试仍会杀掉进程，我个人的处理方式是在android10的手机上监听应用退到后台时进行更换，不影响应用内在线版本升级","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/Android发布自定义库到JitPack上/","text":"####一、本地配置工程的buil.grade添加 1classpath &#x27;com.github.dcendents:android-maven-gradle-plugin:2.1&#x27; #####plugin版本需对应下图: 库模块的buil.grade开头添加： 123apply plugin: &#x27;com.android.library&#x27;apply plugin: &#x27;com.github.dcendents.android-maven&#x27;group=&#x27;com.github.fs437563&#x27;//其中fs437563是GitHub的用户名 做好以上两点修改后，把代码上传同步到GitHub上。 ###二、GitHub上创建版本 代码传好后，在GitHub的【Code】页，选择“releases”进去新建版本。注意版本号要认真填写，例如可以是：v1.0 ###三、JitPack查询 打开JitPack ，输入GitHub项目地址，例如：https://github.com/fs437563/JetShineBoxSwitchPower点击查询，则可以查询到发布的版本列表。Log处标签是绿色则配置成功,红色为失败; ###四、集成使用选取一个最新的版本，点击“Get it”，下面会在“How to”里出现集成使用方法，非常简单","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/JAVA内存划分/","text":"####java的内存划分为5个部分:#####1. 栈(Stack):存放的都是方法中的局部变量,方法的运行一堆是在栈当中运行. 局部变量:方法的参数或者是方法&#123;&#125;内部的变量. 作用域:一旦超出作用域,立刻从栈内存当中消失. 2. 堆(Heap):凡是new出来的东西都在堆当中堆内存里面的东西都要一个地址值:16进制 堆内存里面的数据都要默认值.如: 整数 默认为0 浮点数 默认为0.0 字符 默认为&quot;\\u0000&quot; 布尔 默认为false 引用类型 默认为null 3.方法区(Meathod Area):存储.class相关信息,包含方法的信息.4. 本地方法栈(Native Method Stack):与操作系统相关.5.寄存器(Pc Register):与CPU相关.####数组在内存当中的图形表示:","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-studio-mac-获取MD5-SHA1-SHA256证书指纹/","text":"切换到密匙文件所在目录，文件-打开命令提示符 1keytool -list -v -keystore SportsCard.jks 输入jks密匙","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/android-textview空格占位符以及一些其他占位符汇总/","text":"12345678910111213&amp;#32; == 普通的英文半角空格&amp;#160; == &amp;nbsp; == &amp;#xA0; == no-break space （普通的英文半角空格但不换行）&amp;#12288; == 中文全角空格 （一个中文宽度）&amp;#8194; == &amp;ensp; == en空格 （半个中文宽度）&amp;#8195; == &amp;emsp; == em空格 （一个中文宽度）&amp;#8197; == 四分之一em空格 （四分之一中文宽度）相比平时的空格（&amp;#32;），nbsp拥有不间断（non-breaking）特性。即连续的nbsp会在同一行内显示。即使有100个连续的nbsp，浏览器也不会把它们拆成两行。 123456789101112131415&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;5dp&quot; android:text=&quot;性&amp;#12288;&amp;#12288;别:&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;10dp&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;5dp&quot; android:text=&quot;手&amp;#8194;机&amp;#8194;号:&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;10dp&quot; /&gt;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/github图片加载失败/","text":"找到系统盘下的这个目录:C:\\Windows\\System32\\drivers\\etc打开etc文件夹后在最后面添加: 12140.82.112.4 www.github.com199.232.68.133 raw.githubusercontent.com 保存后即可!","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"path":"wiki/Android Application/Android工具类/判断某个activity是否存在栈堆中/","text":"12345678910111213141516private boolean isExistMainActivity(Class&lt;?&gt; activity) &#123; Intent intent = new Intent(this, activity); ComponentName cmpName = intent.resolveActivity(getPackageManager()); boolean flag = false; if (cmpName != null) &#123;// 说明系统中存在这个activity ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; taskInfoList = am.getRunningTasks(10);//获取从栈顶开始往下查找的10个activity for (ActivityManager.RunningTaskInfo taskInfo : taskInfoList) &#123; if (taskInfo.baseActivity.equals(cmpName)) &#123;// 说明它已经启动了 flag = true; break;//跳出循环，优化效率 &#125; &#125; &#125; return flag;//true 存在 falese 不存在 &#125;","categories":[{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]}],"categories":[{"name":"其他笔记","slug":"其他笔记","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"},{"name":"我的简历","slug":"其他笔记/我的简历","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/"},{"name":"Android进阶","slug":"Android进阶","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"},{"name":"Jetpack","slug":"Android进阶/Jetpack","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"},{"name":"性能优化","slug":"Android进阶/性能优化","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Android FrameWork","slug":"Android-FrameWork","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/"},{"name":"Framework源码分析","slug":"Android-FrameWork/Framework源码分析","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android 13","slug":"Android-FrameWork/Framework源码分析/Android-13","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"},{"name":"WMSAMS","slug":"Android-FrameWork/Framework源码分析/Android-13/WMSAMS","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"},{"name":"Android Application","slug":"Android-Application","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/"},{"name":"Android工具类","slug":"Android-Application/Android工具类","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"InPutManagerService","slug":"Android-FrameWork/Framework源码分析/Android-13/InPutManagerService","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"},{"name":"NDK","slug":"Android进阶/NDK","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/"},{"name":"蒋超大佬扫盲","slug":"Android进阶/NDK/蒋超大佬扫盲","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/"},{"name":"Android进阶之旅","slug":"Android进阶/NDK/Android进阶之旅","permalink":"https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/"},{"name":"Framework相关","slug":"Android-FrameWork/Framework相关","permalink":"https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E7%9B%B8%E5%85%B3/"},{"name":"C++","slug":"C","permalink":"https://cq_tyl.gitee.io/categories/C/"},{"name":"C++教程从0到1入门编程","slug":"C/C-教程从0到1入门编程","permalink":"https://cq_tyl.gitee.io/categories/C/C-%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/"},{"name":"svn配置及使用","slug":"其他笔记/svn配置及使用","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"name":"Android日常问题","slug":"Android-Application/Android日常问题","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Material-Design新控件","slug":"Android-Application/Material-Design新控件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/"},{"name":"rxjava2","slug":"Android-Application/rxjava2","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/rxjava2/"},{"name":"Flutter","slug":"其他笔记/Flutter","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/"},{"name":"QT","slug":"其他笔记/QT","permalink":"https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/"},{"name":"Android兼容适配","slug":"Android-Application/Android兼容适配","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/"},{"name":"Android日常记录","slug":"Android-Application/Android日常记录","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"android-加密-解密-数据压缩","slug":"Android-Application/android-加密-解密-数据压缩","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"},{"name":"Android基础","slug":"Android-Application/Android基础","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%9F%BA%E7%A1%80/"},{"name":"AndroidStudio插件","slug":"Android-Application/AndroidStudio插件","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/AndroidStudio%E6%8F%92%E4%BB%B6/"},{"name":"Android动画","slug":"Android-Application/Android动画","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%8A%A8%E7%94%BB/"},{"name":"android-https双向验证","slug":"Android-Application/android-https双向验证","permalink":"https://cq_tyl.gitee.io/categories/Android-Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/"}],"tags":[]}