<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>TYL</title>
    
    
        <meta name="keywords" content="TYL" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="cq_tyl的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="TYL">
<meta property="og:url" content="https://cq_tyl.gitee.io/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="cq_tyl的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            启动流程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/">2.自定义系统服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/3.%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8ALauncher%E7%9B%B8%E5%85%B3/">3.环境安装及启动相关</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/3.1Launcher%E7%BC%96%E8%AF%91%E4%B9%8BAidegen/"></a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/WatchDog%20%E8%AF%A6%E8%A7%A3/">WatchDog 详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/">0.jetpack合集</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.1.leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">3.1.leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.0.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96&ANR/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/">0.app性能优化集合</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/">MVC、MVP、MVVM架构</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IDE工具相关
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用命令汇总</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            命令相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/ADB_Monkey%E6%B5%8B%E8%AF%95/">ADB_Monkey测试</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            我的简历
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/Framework%E7%AE%80%E5%8E%86/">Framework简历</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">完整项目经历</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main">
        <article id="post-其他笔记/IDE工具相关/Git常用命令汇总" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/">IDE工具相关</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>###基本配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">安装：</span><br><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br><span class="line">配置用户名和邮箱:</span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> xxx </span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> xxx@qq.<span class="property">com</span></span><br><span class="line"></span><br><span class="line">创建密钥:（生成的密钥默认存放在~/.<span class="property">ssh</span>目录下）</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="本地仓库及操作"><a href="#本地仓库及操作" class="headerlink" title="本地仓库及操作"></a>本地仓库及操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">git init (初始化一个仓库)</span><br><span class="line">git add [文件名] (添加新的文件)</span><br><span class="line">git commit -m [关于本次提交的相关说明] (提交)</span><br><span class="line">git status (当前Git仓库的状态)</span><br><span class="line">git diff   (如果文件改变，比较两个文件内容)</span><br><span class="line">git add[文件名] ||  git commit -a -m [关于本次提交的相关说明] (若文文件改变，将改变的文件放到缓冲区中 || 放到缓冲区并提价)</span><br><span class="line">git log (查看提交说明)</span><br><span class="line">git reset --hard head~[N]  (返回到前N个版本)</span><br><span class="line">git reset --hard [commit id] (回到commit id对应的版本)</span><br><span class="line">git reflog (找不到commit id 时 使用该命令，显示有可能产生commit id的命令对应的commit id)</span><br><span class="line">撤销修改:</span><br><span class="line">git checkout --[文件名] （--很重要，没有--，就变成了“切换到另一个分支”的命令）</span><br><span class="line">说明: 把文件在 工作区 的修改全部撤销，这里有两种情况：(已commit则回到commit前，没有commit则回到远程仓库一致)</span><br><span class="line">  一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</span><br><span class="line">  一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</span><br><span class="line">总之，就是让这个文件回到最近一次git commit或git add时的状态;</span><br><span class="line"></span><br><span class="line">删除操作:</span><br><span class="line">git rm [文件名]</span><br><span class="line">直接在windows窗口中删除 或者 使用该命令删除都可以，但是这只是工作区删除，还没有在版本库中删除。</span><br><span class="line"></span><br><span class="line">删除后提交:</span><br><span class="line">git commit -m [关于本次提交的相关说明] (提交，将版本库中的文件也删除)</span><br><span class="line">如果不小心删错了文件，不要怕，妹妹教你</span><br><span class="line">git checkout --[文件名] （因为版本库里还有，所以可以把误删的文件恢复到最新版本）</span><br><span class="line"></span><br><span class="line">刷新忽略文件</span><br><span class="line">## git rm -r --cached . (可以用于刷新忽略文件)</span><br></pre></td></tr></table></figure>

<p>####远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git remote add [远程仓库名] [远程仓库地址] </span><br><span class="line">git remote rm  [远程仓库名] (git remote rm origin   删除远程仓储)</span><br><span class="line">git push -u [远程仓库名] [分支名]  （把本地库的内容推送到远程 git push -u origin master 第一次推送master分支时，加上了-u</span><br><span class="line">	参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，当然，在</span><br><span class="line">	以后的推送或者拉取时就可以简化命令了。）</span><br><span class="line">git push [远程仓库名] [分支名]	（从现在起，只要本地作了提交，就可以通过命令：$ git push origin master 提交）</span><br><span class="line">git clone是把整个git项目拷贝下来，包括里面的日志信息，git项目里的分支，你也可以直接切换、使用里面的分支等等</span><br><span class="line">git pull相当于git fetch和git merge。其意思是先从远程下载git项目里的文件，然后将文件与本地的分支进行merge。</span><br><span class="line">git remote -v 查看远程仓储名称（分支）  </span><br><span class="line">git branch [分支名称]（创建新的分支）</span><br><span class="line">git branch (查看当前所在的分支)</span><br><span class="line">git branch -d [分支名称]  (删除分支)</span><br><span class="line">git checkout [分支名称] （切换到不同分支）</span><br><span class="line">git checkout -b [分支名称] （创建并切换到不同的分支）</span><br><span class="line">git merge [分支名称] （合并指定分支到当前分支）</span><br></pre></td></tr></table></figure>

<p>####添加上游分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给fork配置远程库</span><br><span class="line">	使用 git remote -v 查看远程状态</span><br><span class="line"> </span><br><span class="line">	确定一个将被同步给 fork 远程的上游仓库  </span><br><span class="line">	git remote add upstream git [git路径]</span><br><span class="line"> </span><br><span class="line">	再次 git remote -v  查看状态确认是否配置成功。</span><br><span class="line">	同步fork，从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支 upstream/master  </span><br><span class="line">	git fetch upstream</span><br><span class="line"> </span><br><span class="line">	切换到本地主分支(如果不在的话)  </span><br><span class="line">	git checkout master</span><br><span class="line"> </span><br><span class="line">	把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。  </span><br><span class="line">	git merge upstream/master</span><br><span class="line"> </span><br><span class="line">	如果想更新到 GitHub 的 fork 上，直接  </span><br><span class="line">	git push origin master 就好了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>






            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/WatchDog 详解" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> <strong>源码基于：Android R</strong></p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Watchdog&spm=1001.2101.3001.7020">Watchdog</a>字面上是“看门狗”的意思，有做过嵌入式低层的朋友应该知道，为了防止嵌入式系统MCU里的程序因为干扰而跑飞，专门在MCU里设计了一个定时器电路，叫做看门狗。当MCU正常工作的，每隔一段时间会输出一个信号给看门狗，也就是所谓的喂狗。如果程序跑飞，MCU在规定的时间内没法喂狗，这时看门狗就会直接触发一个reset信号，让CPU重新启动。</p>
<p>在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Android&spm=1001.2101.3001.7020">Android</a>系统的framework中，设计了一个系统服务Watchdog，它类似于一个软件看门狗，用来保护重要的系统服务。它的源代码位于：</p>
<p><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;Watchdog.java</strong></p>
<h2 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h2><p><img src="/../../images/70.png"></p>
<h2 id="1-获取WatchDog-对象"><a href="#1-获取WatchDog-对象" class="headerlink" title="1. 获取WatchDog 对象"></a><strong>1. 获取WatchDog 对象</strong></h2><pre><code>public class Watchdog extends Thread &#123; &#125;
</code></pre>
<p>想要分析一个功能代码，可能先从本身的源头找起，对于Java 类首先看的就是类的定义以及构造构造函数啦！</p>
<p>从这里看 WatchDog 其实一个Thread，这个Thread 可能比较特殊而已，至于怎么特殊，下面会在SystemServer 分析的时候说明。那对于一个Thread，核心的操作部分就是run() 函数了，这个最重要的部分会放在最后解析。</p>
<p>再来看下WatchDog 的构造函数：</p>
<pre><code>private Watchdog() &#123; &#125;
</code></pre>
<p>WatchDog 构造函数是private，对于外界获取对象的接口为：</p>
<pre><code>    public static Watchdog getInstance() &#123;        if (sWatchdog == null) &#123;            sWatchdog = new Watchdog();        &#125;         return sWatchdog;    &#125;
</code></pre>
<p>外界获取WatchDog 就是通过getInstance()，至于这个“外界”后面会补充。</p>
<h2 id="2-WatchDog-的启动"><a href="#2-WatchDog-的启动" class="headerlink" title="2. WatchDog 的启动"></a>2. WatchDog 的启动</h2><pre><code>/frameworks/base/services/java/com/android/server/SystemServer.java     private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123;        t.traceBegin(&quot;startBootstrapServices&quot;);         // Start the watchdog as early as possible so we can crash the system server        // if we deadlock during early boot        t.traceBegin(&quot;StartWatchdog&quot;);        final Watchdog watchdog = Watchdog.getInstance();        watchdog.start();        t.traceEnd();         ...         t.traceBegin(&quot;InitWatchdog&quot;);        watchdog.init(mSystemContext, mActivityManagerService);        t.traceEnd();         ...    &#125; 
</code></pre>
<p>从第一节得知 WatchDog 实际是一个 thread，而且是以单例的形式存在，则需要确定其启动的地方。</p>
<p>这部分代码主要作用：</p>
<ul>
<li>创建WatchDog 实例；</li>
<li>运行WatchDog thread；</li>
<li>在AMS 启动后，执行init() 函数，传入mSystemContext 和 AMS 实例；</li>
</ul>
<p>由此，WatchDog 线程是在 system_server 进程中启动，专门用来给 system_server 中的其他线程喂狗。</p>
<h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h2><pre><code>private Watchdog() &#123;    //线程名为watchdog	super(&quot;watchdog&quot;);  	//将fg thread 单独提出作为主要的checker	mMonitorChecker = new HandlerChecker(FgThread.getHandler(),			&quot;foreground thread&quot;, DEFAULT_TIMEOUT);	mHandlerCheckers.add(mMonitorChecker);	    //创建主线程的checker	mHandlerCheckers.add(new HandlerChecker(new Handler(Looper.getMainLooper()),			&quot;main thread&quot;, DEFAULT_TIMEOUT));	//创建UI thread 的checker	mHandlerCheckers.add(new HandlerChecker(UiThread.getHandler(),			&quot;ui thread&quot;, DEFAULT_TIMEOUT));	//创建Io thread 的checker	mHandlerCheckers.add(new HandlerChecker(IoThread.getHandler(),			&quot;i/o thread&quot;, DEFAULT_TIMEOUT));	//创建display thread 的checker	mHandlerCheckers.add(new HandlerChecker(DisplayThread.getHandler(),			&quot;display thread&quot;, DEFAULT_TIMEOUT));	//创建animation thread 的checker	mHandlerCheckers.add(new HandlerChecker(AnimationThread.getHandler(),			&quot;animation thread&quot;, DEFAULT_TIMEOUT));	//创建surface animation thread 的checker	mHandlerCheckers.add(new HandlerChecker(SurfaceAnimationThread.getHandler(),			&quot;surface animation thread&quot;, DEFAULT_TIMEOUT)); 	//fg thread的checker 中添加对binder 的checker	addMonitor(new BinderThreadMonitor());     // 添加对watchdog 相关目录的监控	mOpenFdMonitor = OpenFdMonitor.create(); 	mInterestingJavaPids.add(Process.myPid()); 	// See the notes on DEFAULT_TIMEOUT.	assert DB ||			DEFAULT_TIMEOUT &gt; ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;&#125;
</code></pre>
<h4 id="3-1-设定线程名"><a href="#3-1-设定线程名" class="headerlink" title="3.1 设定线程名"></a>3.1 设定线程名</h4><p>设WatchDog 的线程名为 <em><strong>watchdog</strong></em></p>
<h4 id="3-2-创建-HandlerChecker"><a href="#3-2-创建-HandlerChecker" class="headerlink" title="3.2 创建 HandlerChecker"></a>3.2 创建 HandlerChecker</h4><p>WatchDog 中靠 HandlerChecker 来完成check 工作，每个 HandlerChecker 伴随一个Handler，即一个独立的 Looper 和 Thread。</p>
<p>WatchDog 在创建的时候指定对 FgThread、MainThread、UIThread、IoThread、DisplayThread、AnimationThread、SurfaceAnimationThread 等thread 的监控，当然后期可以通过接口动态添加到 check list(<strong>mHandlerCheckers</strong>) 中，例如通过接口 addThread()，该函数后面会详细剖析，可以查看第 <strong>5.2</strong> 节。</p>
<ul>
<li><p>MainThread 是在 SystemServer 运行的时候创建的</p>
<p>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.javaprivate void run() {    …    Looper.prepareMainLooper();    …}</p>
</li>
<li><p>其他的Thread 最终都是继承自HandlerThread（详细看  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/shift_wwx/article/details/49666749" title="Android HandlerThread 详解">Android HandlerThread 详解</a>**）</p>
</li>
</ul>
<p>HandlerChecker 有3 个参数分别是Handler 对象、name、以及触发watchdog 的最大时间间隔，详细的HandlerChecker 看下面<strong>第6节</strong>。</p>
<ul>
<li>重要的几个 thread 在这里都有监听，它们都有专门的名字：<ul>
<li>android**.**fg</li>
<li>android**.**ui</li>
<li>android**.**io</li>
<li>android**.**display</li>
<li>android**.**anim</li>
<li>android**.<strong>anim</strong>.**lf</li>
</ul>
</li>
</ul>
<h4 id="3-3-添加对binder-的监控"><a href="#3-3-添加对binder-的监控" class="headerlink" title="3.3 添加对binder 的监控"></a>3.3 添加对binder 的监控</h4><pre><code>    private static final class BinderThreadMonitor implements Watchdog.Monitor &#123;        @Override        public void monitor() &#123;            Binder.blockUntilThreadAvailable();        &#125;    &#125;
</code></pre>
<p>monitor() 会调用到 native 层 IPCThreadState：</p>
<pre><code>frameworks/native/libs/binder/IPCThreadState.cpp void IPCThreadState::blockUntilThreadAvailable()&#123;    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);    while (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads) &#123;        ALOGW(&quot;Waiting for thread to be free. mExecutingThreadsCount=%lu mMaxThreads=%lu\n&quot;,                static_cast&lt;unsigned long&gt;(mProcess-&gt;mExecutingThreadsCount),                static_cast&lt;unsigned long&gt;(mProcess-&gt;mMaxThreads));        pthread_cond_wait(&amp;mProcess-&gt;mThreadCountDecrement, &amp;mProcess-&gt;mThreadCountLock);    &#125;    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);&#125;
</code></pre>
<p>BinderThreadMonitor 会被添加到 <strong>fg thread</strong> 中，主要是用于确认binder 是否有出现不够用的情况，例如，假设 binder 的max thread 为15个，超过15后就需要 check 是否存在 binder 阻塞。</p>
<h4 id="3-4-创建OpenFdMonitor"><a href="#3-4-创建OpenFdMonitor" class="headerlink" title="3.4 创建OpenFdMonitor"></a>3.4 创建OpenFdMonitor</h4><pre><code>public static OpenFdMonitor create() &#123;	// Only run the FD monitor on debuggable builds (such as userdebug and eng builds).	if (!Build.IS_DEBUGGABLE) &#123;		return null;	&#125; 	final StructRlimit rlimit;	try &#123;		rlimit = android.system.Os.getrlimit(OsConstants.RLIMIT_NOFILE);	&#125; catch (ErrnoException errno) &#123;		Slog.w(TAG, &quot;Error thrown from getrlimit(RLIMIT_NOFILE)&quot;, errno);		return null;	&#125;  	final File fdThreshold = new File(&quot;/proc/self/fd/&quot; + (rlimit.rlim_cur - FD_HIGH_WATER_MARK));	return new OpenFdMonitor(new File(&quot;/data/anr&quot;), fdThreshold);&#125;
</code></pre>
<ul>
<li>只有 debug 版本才做 fd monitor，例如 userdebug 或 eng；</li>
<li>主要是确认 <strong>&#x2F;data&#x2F;anr</strong> 路径的正常性；</li>
</ul>
<h4 id="3-5-mInterestingJavaPids"><a href="#3-5-mInterestingJavaPids" class="headerlink" title="3.5 mInterestingJavaPids"></a>3.5 mInterestingJavaPids</h4><p>主要是触发WatchDog 或者 HALF time 的时候，将这里存的 pid 所对应的堆栈dump 出来。AMS 中每次启动一个进程时，都会调用 handleProcessStartedLocked() 最终调用 WatchDog**.**processStarted() 添加到 WatchDog 中，而process 也是有限定的，如下：</p>
<pre><code>    private static boolean isInterestingJavaProcess(String processName) &#123;        return processName.equals(StorageManagerService.sMediaStoreAuthorityProcessName)                || processName.equals(&quot;com.android.phone&quot;);    &#125;      public void processStarted(String processName, int pid) &#123;        if (isInterestingJavaProcess(processName)) &#123;            Slog.i(TAG, &quot;Interesting Java process &quot; + processName + &quot; started. Pid &quot; + pid);            synchronized (this) &#123;                mInterestingJavaPids.add(pid);            &#125;        &#125;    &#125;
</code></pre>
<h2 id="4-init-函数"><a href="#4-init-函数" class="headerlink" title="4. init 函数"></a>4. init 函数</h2><pre><code>    public void init(Context context, ActivityManagerService activity) &#123;        mResolver = context.getContentResolver();        mActivity = activity;         context.registerReceiver(new RebootRequestReceiver(),                new IntentFilter(Intent.ACTION_REBOOT),                android.Manifest.permission.REBOOT, null);    &#125;
</code></pre>
<p>注册了reboot 的广播，软重启的操作是在这里进行的：</p>
<pre><code>    final class RebootRequestReceiver extends BroadcastReceiver &#123;        @Override        public void onReceive(Context c, Intent intent) &#123;            if (intent.getIntExtra(&quot;nowait&quot;, 0) != 0) &#123;                rebootSystem(&quot;Received ACTION_REBOOT broadcast&quot;);                return;            &#125;            Slog.w(TAG, &quot;Unsupported ACTION_REBOOT broadcast: &quot; + intent);        &#125;    &#125;     void rebootSystem(String reason) &#123;        Slog.i(TAG, &quot;Rebooting system because: &quot; + reason);        IPowerManager pms = (IPowerManager)ServiceManager.getService(Context.POWER_SERVICE);        try &#123;            pms.reboot(false, reason, false);        &#125; catch (RemoteException ex) &#123;        &#125;    &#125;
</code></pre>
<p>该软重启的 intent 中需要设定一个参数 nowait，且不为0.</p>
<h2 id="5-其他几个重要函数"><a href="#5-其他几个重要函数" class="headerlink" title="5. 其他几个重要函数"></a>5. 其他几个重要函数</h2><h3 id="5-1-addMonitor"><a href="#5-1-addMonitor" class="headerlink" title="5.1 addMonitor()"></a>5.1 addMonitor()</h3><pre><code>    public void addMonitor(Monitor monitor) &#123;        synchronized (this) &#123;            mMonitorChecker.addMonitorLocked(monitor);//通过此接口会将monitor添加到fg thread中        &#125;    &#125;
</code></pre>
<p>本函数是将 monitor 添加到 mMonitorChecker 中监控；</p>
<pre><code>    public interface Monitor &#123;        void monitor();    &#125;
</code></pre>
<p>例如AMS 构造函数中：</p>
<pre><code>Watchdog.getInstance().addMonitor(this);
</code></pre>
<h3 id="5-2-addThread"><a href="#5-2-addThread" class="headerlink" title="5.2 addThread()"></a>5.2 addThread()</h3><pre><code>    public void addThread(Handler thread) &#123;        addThread(thread, DEFAULT_TIMEOUT);    &#125;     public void addThread(Handler thread, long timeoutMillis) &#123;//通过此接口新建HandlerChecker        synchronized (this) &#123;            final String name = thread.getLooper().getThread().getName();            mHandlerCheckers.add(new HandlerChecker(thread, name, timeoutMillis));        &#125;    &#125;
</code></pre>
<p>通过本函数<strong>新建 HandlerChecker</strong> 并添加到 mHandlerCheckers 中，然后进行 check 该线程是否阻塞，默认timeout 为 60s；</p>
<p>例如 AMS 构造函数中：</p>
<pre><code>Watchdog.getInstance().addThread(mHandler);
</code></pre>
<h2 id="6-HandlerChecker类"><a href="#6-HandlerChecker类" class="headerlink" title="6. HandlerChecker类"></a>6. HandlerChecker类</h2><p>在分析WatchDog 核心函数 run 之前，先来分析下核心处理类 HandlerChecker，所有 thread 的监听、处理都是在这个类中。</p>
<h4 id="6-1-HandlerChecker-是一个Runnable"><a href="#6-1-HandlerChecker-是一个Runnable" class="headerlink" title="6.1 HandlerChecker 是一个Runnable"></a>6.1 HandlerChecker 是一个Runnable</h4><pre><code>public final class HandlerChecker implements Runnable &#123;
</code></pre>
<h4 id="6-2-HandlerChecker的构造"><a href="#6-2-HandlerChecker的构造" class="headerlink" title="6.2  HandlerChecker的构造"></a>6.2  HandlerChecker的构造</h4><pre><code>HandlerChecker(Handler handler, String name, long waitMaxMillis) &#123;	mHandler = handler;	mName = name;	mWaitMax = waitMaxMillis;	mCompleted = true;&#125;
</code></pre>
<p>构造参数有三个：</p>
<ul>
<li>handler 用来发消息，通过handler 可以确定 thread；</li>
<li>name 为 HandlerChecker 对应thread 的描述时使用，除了构造中的特殊的checker 有特殊的name，其他通过 addThread() 接口创建的 checker，都是使用线程名；</li>
<li>waitMaxMillis 为监控时最大时长，默认为60s；</li>
</ul>
<h4 id="6-3-核心变量"><a href="#6-3-核心变量" class="headerlink" title="6.3 核心变量"></a>6.3 核心变量</h4><pre><code>private final ArrayList&lt;Monitor&gt; mMonitors = new ArrayList&lt;Monitor&gt;();private final ArrayList&lt;Monitor&gt; mMonitorQueue = new ArrayList&lt;Monitor&gt;();
</code></pre>
<p>一个HandlerChecker 中可以添加多个monitor，为了安全考虑，防止在monitor check 过程中添加新的monitor，将过程分两部分：</p>
<ul>
<li>每次HandlerChecker 在schedule check的时候，只检查 mMonitors；</li>
<li>schedule check 过程中，新添加的monitor 都临时存放在 mMonitorQueue 中；</li>
</ul>
<p>详细看scheduleCheckLocked() 函数，即第 <strong>6.4</strong> 节。</p>
<h4 id="6-4-scheduleCheckLocked"><a href="#6-4-scheduleCheckLocked" class="headerlink" title="6.4 scheduleCheckLocked"></a>6.4 scheduleCheckLocked</h4><pre><code>public void scheduleCheckLocked() &#123;	if (mCompleted) &#123; //step 1		// Safe to update monitors in queue, Handler is not in the middle of work		mMonitors.addAll(mMonitorQueue);		mMonitorQueue.clear();	&#125;	if ((mMonitors.size() == 0 &amp;&amp; mHandler.getLooper().getQueue().isPolling())			|| (mPauseCount &gt; 0)) &#123; //step 2		mCompleted = true;		return;	&#125;	if (!mCompleted) &#123; //step 3		// we already have a check in flight, so no need		return;	&#125; 	mCompleted = false; //step 4	mCurrentMonitor = null;	mStartTime = SystemClock.uptimeMillis();	mHandler.postAtFrontOfQueue(this);&#125;
</code></pre>
<p>逻辑比较简单，见代码中注释，将逻辑分为4个部分：</p>
<ul>
<li><strong>step1：</strong> 新的 schedule 时 mCompleted 为 true，会将 mMonitorQueue 中的 monitor copy到mMonitor 中，用以在 run() 函数中 check；</li>
<li><strong>step2</strong>：如果 handle 的 Looper 处于 polling 状态，且没有 monitor 添加进来，或者是HandlerChecker 处于pause 状态，不做 schedule check，直接指定 schedule 完成状态；</li>
<li><strong>step3：</strong>如果 HandlerChecker 中有 monitor 或者是 Looper 中有消息在处理，会跳过 <strong>step2</strong>, 如果是第一次执行 <strong>step3</strong> 的 case 是不会处理，如果 mCompleted 此时为false，那肯定是schedule 已经执行过一次，但是30s 的时候并没有执行完成，于是这里直接return，为了再给一次机会，再等 30s 等待 monitor 或者 msg 处理完成；</li>
<li><strong>step4：</strong>能进入 <strong>step4</strong>，是因为上一次的 schedule 顺利执行完成，通过mHandler.post() 函数准备执行 run() 函数，run() 如果顺利执行完成则会将mCompleted 置为true，不会进入 <strong>step3</strong>；</li>
</ul>
<h4 id="6-5-run-函数"><a href="#6-5-run-函数" class="headerlink" title="6.5 run() 函数"></a>6.5 run() 函数</h4><pre><code>public void run() &#123;	final int size = mMonitors.size();	for (int i = 0 ; i &lt; size ; i++) &#123;		synchronized (Watchdog.this) &#123;			mCurrentMonitor = mMonitors.get(i);		&#125;		mCurrentMonitor.monitor();	&#125; 	synchronized (Watchdog.this) &#123;		mCompleted = true;		mCurrentMonitor = null;	&#125;&#125;
</code></pre>
<p>通过一个循环分别调用每一个 monitor 的 <strong>monitor()</strong> 函数，如果其中一个阻塞了，则无法退出该循环，mCompleted 状态也不会变成 true，如果 mCompleted 为false，WatchDog 只能通过时间来进一步确认状态，在下面一节中会详细说明。</p>
<p>用 AMS 中的 monitor 来举例：</p>
<pre><code>frameworks/base/services/core/java/com/android/server/am/AMS.java     public void monitor() &#123;        synchronized (this) &#123; &#125;    &#125;
</code></pre>
<p>AMS 的 monitor 就是为了 check <strong>AMS 是否死锁</strong>了。</p>
<h2 id="7-WatchDog-的run-函数"><a href="#7-WatchDog-的run-函数" class="headerlink" title="7. WatchDog 的run() 函数"></a>7. WatchDog 的run() 函数</h2><p>上面的基本函数都大概解析完了，对于一个Thread 那最重要的肯定还是run() 函数，这里也是WatchDog 的监测机制所在，因为代码比较多，这里裁剪分析。</p>
<h4 id="step-1：建立死循环"><a href="#step-1：建立死循环" class="headerlink" title="step 1：建立死循环"></a>step 1：建立死循环</h4><p>WatchDog 在整个系统运行过程中都需要存在的，除非了进程或是系统重启了，不然WatchDog 需要长期运行。</p>
<pre><code>    public void run() &#123;        boolean waitedHalf = false;        while (true) &#123;            ...        &#125;    &#125;
</code></pre>
<h4 id="step2：创建schedule"><a href="#step2：创建schedule" class="headerlink" title="step2：创建schedule"></a>step2：创建schedule</h4><pre><code>            synchronized (this) &#123;                long timeout = CHECK_INTERVAL;                 for (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123;                    HandlerChecker hc = mHandlerCheckers.get(i);                    hc.scheduleCheckLocked();                &#125;
</code></pre>
<p>读取所有的 mHandlerCheckers，执行每一个 checker 中的 scheduleCheckLocked() 函数，下面会等待 30 s 的时间，然后在收集这些 checker 的状态。</p>
<p>注意两点：</p>
<ul>
<li>timeout 默认为30s（DEFAULT_TIMEOUT &#x2F; 2），所有的 schedule 启动完会 wait 30s 等待所有的 schedule 都能顺利执行完；</li>
<li>启动schedule 会加上锁，与 HandlerChecker 的run() 函数互斥，这就要求，在wait 之前，HandlerChecker 的runnable 是无法运行的，下文在 wait() 的时候会释放this 对象的锁，runnable 才可以顺利执行(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/x_wukong/p/4009709.html" title="wait/synchronized 使用">wait&#x2F;synchronized 使用</a>)；</li>
</ul>
<h4 id="step3：-等待30s"><a href="#step3：-等待30s" class="headerlink" title="step3： 等待30s"></a>step3： 等待30s</h4><pre><code>                long start = SystemClock.uptimeMillis();                while (timeout &gt; 0) &#123;                    if (Debug.isDebuggerConnected()) &#123;                        debuggerWasConnected = 2;                    &#125;                    try &#123;                        wait(timeout);                        // Note: mHandlerCheckers and mMonitorChecker may have changed after waiting                    &#125; catch (InterruptedException e) &#123;                        Log.wtf(TAG, e);                    &#125;                    if (Debug.isDebuggerConnected()) &#123;                        debuggerWasConnected = 2;                    &#125;                    timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);                &#125;
</code></pre>
<p>这里等待30s，直到时间完全用完。此处调用 wait() 会临时释放 this 这把锁，这样所有的 checker 就会进入下一步处理，即 runnable() 处理。 </p>
<h4 id="step4：收集check-完成状态"><a href="#step4：收集check-完成状态" class="headerlink" title="step4：收集check 完成状态"></a>step4：收集check 完成状态</h4><pre><code>                    final int waitState = evaluateCheckerCompletionLocked();                    if (waitState == COMPLETED) &#123;                        // The monitors have returned; reset                        waitedHalf = false;                        continue;                    &#125; else if (waitState == WAITING) &#123;                        // still waiting but within their configured intervals; back off and recheck                        continue;                    &#125; else if (waitState == WAITED_HALF) &#123;                        if (!waitedHalf) &#123;                            Slog.i(TAG, &quot;WAITED_HALF&quot;);                            // We&#39;ve waited half the deadlock-detection interval.  Pull a stack                            // trace and wait another half.                            ArrayList&lt;Integer&gt; pids = new ArrayList&lt;&gt;(mInterestingJavaPids);                            ActivityManagerService.dumpStackTraces(pids, null, null,                                    getInterestingNativePids(), null);                            waitedHalf = true;                        &#125;                        continue;                    &#125;
</code></pre>
<p>在 30s 时间等待完成后，通过 evaluateCheckerCompletionLocked() 函数来收集所有 checkers 的状态。</p>
<p>状态分：</p>
<ul>
<li><strong>COMPLETED：</strong>顺利完成</li>
<li><strong>WAITING：</strong>有可能 HandlerChecker 中的 monitor 比较多，而部分 monitor 占用时间比较长，这就导致有些 monitor 执行不到30s时，wait 就结束了，这时候会返回WAITING 状态，继续等待下一个schedule；</li>
<li><strong>WATIED_HALF：</strong>同WAITING，会继续等待下一个schedule，不同于 WAITING，WAITED_HALF 会通过AMS 去 dump 一次 stack；</li>
<li><strong>OVERDUE：</strong>有 monitor 执行超过了60s，这个是不允许的，step5 会处理OVERDUE的情况</li>
</ul>
<h4 id="step5：处理OVERDUE-情况"><a href="#step5：处理OVERDUE-情况" class="headerlink" title="step5：处理OVERDUE 情况"></a>step5：处理OVERDUE 情况</h4><pre><code>                    blockedCheckers = getBlockedCheckersLocked();                    subject = describeCheckersLocked(blockedCheckers);
</code></pre>
<p>最开始是统计出OVERDUE 的HandlerChecker，存入blockedCheckers 中，并统计这些HandlerChecker 的描述。</p>
<pre><code>    private ArrayList&lt;HandlerChecker&gt; getBlockedCheckersLocked() &#123;        ArrayList&lt;HandlerChecker&gt; checkers = new ArrayList&lt;HandlerChecker&gt;();        for (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123;            HandlerChecker hc = mHandlerCheckers.get(i);            if (hc.isOverdueLocked()) &#123;                checkers.add(hc);            &#125;        &#125;        return checkers;    &#125;
</code></pre>
<p>统计所有状态OVERDUE 的HandlerChecker。</p>
<pre><code>    private String describeCheckersLocked(List&lt;HandlerChecker&gt; checkers) &#123;        StringBuilder builder = new StringBuilder(128);        for (int i=0; i&lt;checkers.size(); i++) &#123;            if (builder.length() &gt; 0) &#123;                builder.append(&quot;, &quot;);            &#125;            builder.append(checkers.get(i).describeBlockedStateLocked());        &#125;        return builder.toString();    &#125;
</code></pre>
<p>统计所有符合条件的OVERDUE 的HandlerChecker 的描述，以逗号分割。</p>
<p>例如：</p>
<pre><code>11-06 00:05:28.603  2197  2441 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in monitor com.android.server.am.ActivityManagerService on foreground thread (android.fg), Blocked in handler on ActivityManager (ActivityManager)
</code></pre>
<p>接着就是保存日志，包括一些运行时的堆栈信息，这些日志是我们解决Watchdog问题的重要依据。如果判断需要杀掉system_server进程，则给当前进程(system_server)发送signal 9，详细信息看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/shift_wwx/article/details/81030749" title="Android 系统中WatchDog 日志分析">Android 系统中WatchDog 日志分析</a></p>
<h2 id="8-通过AMS引入WatchDog-监控的根本形式"><a href="#8-通过AMS引入WatchDog-监控的根本形式" class="headerlink" title="8. 通过AMS引入WatchDog 监控的根本形式"></a>8. 通过AMS引入WatchDog 监控的根本形式</h2><pre><code>    Watchdog.getInstance().addMonitor(this);    Watchdog.getInstance().addThread(mHandler);
</code></pre>
<p>来看下一直说的monitor 是什么东西：</p>
<pre><code>    public void monitor() &#123;        synchronized (this) &#123; &#125;    &#125;
</code></pre>
<p>这里其实就是确认AMS 中是否存在死锁，30秒后还是没有放出来这个锁，WatchDog 会在给一次机会，如果还是没有释放的话，会打印堆栈信息并且结束AMS 所在进程。</p>
<p><strong>需要注意的</strong>是WatchDog 的监控，除了WatchDog 构造函数中的默认Thread，外界若需要添加监控，需要通过两种途径：</p>
<ul>
<li>addMonitor(Monitor monitor)；</li>
<li>addThread(Handler thread)；</li>
</ul>
<p>两个接口区别在于参数，一个传入的是monitor，例如WatchDog 内部的 BinderThreadMonitor 或AMS 的monitor，monitor() 的处理是在  fg thread 中；另一个传入的是Handler，通过第 <strong>5</strong> 节得知，addThread() 会创建一个HandlerChecker 对象单独监控；</p>
<p>那么，结合 HandlerChecker 的 **scheduleCheckLocked() **函数，可以认定，WatchDog 可以监控的形式有两种：</p>
<ul>
<li><strong>monitor：</strong>HandlerChecker专门用来维护monitor，run() 中逐个确认monitor是否正常运行</li>
<li><strong>handler - msg：</strong>HandlerChecker 专门用来维护消息的监控，run() 中不会确认 monitor 的状态，而是直接将 mCompleted 置为 true，但是前提是Handler 中的 Looper 此时如果正在处理消息，这个消息不能阻塞此次 schedule 的 post，如果 Looper 中的消息处理超过 30s，那么HandlerChecker 中的 run() 只能等下一次 30s 时候才能有机会执行；</li>
</ul>
<h2 id="9-WatchDog-针对系统的-monitor-监控"><a href="#9-WatchDog-针对系统的-monitor-监控" class="headerlink" title="9. WatchDog 针对系统的 monitor 监控"></a>9. WatchDog 针对系统的 monitor 监控</h2><ul>
<li>ActivityManagerService</li>
<li>InputManagerService</li>
<li>MediaProjectionManagerService</li>
<li>MediaRouterService</li>
<li>MediaSessionService</li>
<li>PowerManagerService</li>
<li>StorageManagerService</li>
<li>TvRemoteService</li>
<li>WindowManagerService</li>
</ul>
<p>都是通过<strong>addMonitor()</strong> 添加到 <strong>fg thread</strong> 的 HandlerChecker 中。</p>
<h2 id="10-WatchDog-中Handler-msg监控"><a href="#10-WatchDog-中Handler-msg监控" class="headerlink" title="10. WatchDog 中Handler msg监控"></a>10. WatchDog 中Handler msg监控</h2><p>都是通过 Handler 的方式添加到各自的 HandlerChecker 中，有的是在 WatchDog 的构造的时候添加，有的是后期通过 addThread() 方式添加。</p>
<h2 id="11-AMS-WD-举例"><a href="#11-AMS-WD-举例" class="headerlink" title="11. AMS WD 举例"></a>11. AMS WD 举例</h2><p>第 <strong>8</strong> 节中列出了AMS 代码中 <strong>addMonitor()</strong> 和 <strong>addThread()</strong> 两种方式都使用了，所以在dump trace 的时候会列举 fg thread 的 stack trace 和 ActivityManager stack trace：</p>
<pre><code>11-06 00:05:28.603  2197  2441 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in monitor com.android.server.am.ActivityManagerService on foreground thread (android.fg), Blocked in handler on ActivityManager (ActivityManager)11-06 00:05:28.603  2197  2441 W Watchdog: foreground thread stack trace:11-06 00:05:28.603  2197  2441 W Watchdog:     at com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:23862)11-06 00:05:28.604  2197  2441 W Watchdog:     at com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:211)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.Handler.handleCallback(Handler.java:790)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.Handler.dispatchMessage(Handler.java:99)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.Looper.loop(Looper.java:164)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.HandlerThread.run(HandlerThread.java:65)11-06 00:05:28.604  2197  2441 W Watchdog:     at com.android.server.ServiceThread.run(ServiceThread.java:46)11-06 00:05:28.604  2197  2441 W Watchdog: ActivityManager stack trace:11-06 00:05:28.604  2197  2441 W Watchdog:     at com.android.server.am.ActivityManagerService.idleUids(ActivityManagerService.java:23305)11-06 00:05:28.604  2197  2441 W Watchdog:     at com.android.server.am.ActivityManagerService$MainHandler.handleMessage(ActivityManagerService.java:2428)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.Handler.dispatchMessage(Handler.java:106)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.Looper.loop(Looper.java:164)11-06 00:05:28.604  2197  2441 W Watchdog:     at android.os.HandlerThread.run(HandlerThread.java:65)11-06 00:05:28.604  2197  2441 W Watchdog:     at com.android.server.ServiceThread.run(ServiceThread.java:46)11-06 00:05:28.604  2197  2441 W Watchdog: *** GOODBYE
</code></pre>
<p>具体的可以看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/shift_wwx/article/details/81030749" title="Android 系统中WatchDog 日志分析">Android 系统中WatchDog 日志分析</a></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>Android 中的WatchDog 主要是监测系统中重要服务，例如AMS、WMS 等，当注册的monitor 无法通过检测，或者是消息处理超时的时候就会触发WatchDog，最后可能会引起系统的重启。</p>
<p>下一篇博文 <a target="_blank" rel="noopener" href="https://blog.csdn.net/shift_wwx/article/details/81030749" title="Android 系统中WatchDog 日志分析">Android 系统中WatchDog 日志分析</a> 中会结合实例详解run() 第 <strong>4</strong> 步保存日志。</p>
<h2 id="附加：WatchDog-类图"><a href="#附加：WatchDog-类图" class="headerlink" title="附加：WatchDog 类图"></a><strong>附加：WatchDog 类图</strong></h2><p><img src="/../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdlcnBwcA==,size_16,color_FFFFFF,t_70.png"></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-其他笔记/我的简历/完整项目经历" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/">我的简历</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>###项目经历</p>
<ul>
<li><p>重庆捷旭科技有限公司   	                                   2021.02-至今                                         Android工程师 </p>
<ul>
<li><p>捷宇rk3566-android13_r6 framework定制开发</p>
<p>产品简介：<a target="_blank" rel="noopener" href="http://www.fjjieyu.com/product/index/133">http://www.fjjieyu.com/product/index/133</a></p>
<p>1.将云法庭apk内置成系统应用并实现不可退出不可卸载的需求；<br>2.修改开关机动画为云上共享法庭的启动动画；<br>3.app执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;<br>4.实现带鱼屏宽屏的分屏场景-双屏动画切换移动功能；<br>5.冻屏bug处理<br>6.壁纸切换闪黑bug解决</p>
</li>
<li><p>云上共享法庭 android开发<br>重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，独立负责里面的内网法官&#x2F;当事人&#x2F;签字<br>端&#x2F;手机端&#x2F;电视端的开发及适配处理；</p>
</li>
<li><p>信息发布 android开发<br>类似与广告机的应用，动态实现图片&#x2F;音视频&#x2F;文字&#x2F;定制布局等不同场景的展示及开机自启和自动升级等功能；</p>
</li>
<li><p>案件排期 android开发<br>一款基层法院窗口信息显示应用，通过与条屏厂家对接实现条屏的适配显示窗口信息等；</p>
</li>
<li><p>傲视取号机 android开发<br>一款基层法院取号应用，通过与硬件厂家对接实现刷身份证，取号，叫号，切纸等操作；</p>
</li>
</ul>
</li>
<li><p>重庆国狮科技有限公司                                         2018.02-2019.03                                   Android组负责人</p>
<ul>
<li>出行加司机 android开发<br>一款专用于出行加网约车平台司机接单应用,根据司机注册公司及车辆信息，可动态接<br>取不同类型的网约车订单，该应用已繁衍出小巷约车应用。</li>
<li>出行加乘客 android开发<br>一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不<br>同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以<br>激励用户的使用</li>
<li>项目名称： 商务司机<br>一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不<br>同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以<br>激励用户的使用</li>
<li>文具购（二次开发 Android<br>是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类<br>查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能</li>
<li>vaptcha手势验证 android开发<br>公司接的一个外包项目，android应用的第三方库开发，识别并计算出用户的手势滑动<br>坐标并上传至后台返回完成手势验证。<br>Vaptcha Sdk文档 https &#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/1b72ea2142c2">www.jianshu.com/p/1b72ea2142c2</a></li>
<li>富山 android开发<br>类似于梦想打卡的投资类项目，主体由android原生结合webView完成，该项目完成<br>周期仅用了3个星期的时间并通过招商等形式繁衍出了富海应用。</li>
<li>完美日程 android开发<br>一款仿谷歌日历的本地日历应用，已完成大部分业务逻辑，包含了自定义日历视图，<br>本地日历活动同步，节假日的动态显示以及用户自定义个人目标等功能。</li>
<li>梦想打卡 android开发<br>一款提供给用户在固定时间进行签到的应用，用户可选择参与不同的打卡签到活动，<br>在指定时间完成签到则获得现金奖励，该项目通过招商等形式已繁衍出喔喔打卡&#x2F;星星<br>打卡等应用。</li>
</ul>
</li>
<li><p>重庆全心协力科技有限公司                             2016.04-2018.02                             Android工程师 </p>
<ul>
<li>现场云 android开发<br>是公司自己的项目（已维护更新5个版本），打造的一款提升工厂生产效率，旨 在避免<br>问题产生到问题解决无人监管无人记录导致同一问题反复出现或无人处 理的情况，兼<br>具点检和报表统计，即时聊天等功能。</li>
<li>文具购（二次开发） android开发<br>是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类<br>查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能</li>
<li>健康西南 android开发<br>是在医事通平台下，西南医院的一款App，也集合了预约挂号、导医、查询等 功能。</li>
<li>小马医疗 android开发<br>一款为以医疗、推广为主的App。主要功能有预约挂号、健康咨询、健康商城 等。分<br>四个主界面全部用原生的页面撰写，其余二级页面加载网页</li>
<li>医事通 android开发<br>广州市卫生信息服务平台的手机版，为用户更方便快捷的提供预约挂号服务</li>
</ul>
</li>
</ul>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-其他笔记/我的简历/Framework简历" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/">我的简历</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>####个人信息</p>
<ul>
<li><p>姓名：唐玉龙                                                                                        状态：在职</p>
</li>
<li><p>性 别：男						                                                                       年 龄：34 </p>
</li>
<li><p>手 机：18996195388			                                                               邮 箱：<a href="mailto:&#x31;&#x31;&#48;&#x34;&#x36;&#x35;&#x33;&#x32;&#x36;&#x32;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#x31;&#x31;&#48;&#x34;&#x36;&#x35;&#x33;&#x32;&#x36;&#x32;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a></p>
</li>
<li><p>学校：重庆交通大学(非全) 本科           		                                       专 业：计算机科学与技术</p>
</li>
<li><p>工作年限：7年app&amp;1年framework                                                   岗 位：Android研发工程师</p>
</li>
<li><p>简书：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/517b3c07af90">https://www.jianshu.com/u/517b3c07af90</a>                         博客：<a target="_blank" rel="noopener" href="https://cq-tyl.github.io/">https://cq-tyl.github.io</a></p>
</li>
</ul>
<p>####专业技能</p>
<ul>
<li>8年互联网开发经验(7年app&amp;1年framework)，熟悉Android、Java，了解C++；</li>
<li>熟悉安卓系统架构，熟悉Android系统启动流程，熟悉IMS,WMS,AMS模块；</li>
<li>熟悉SystemUl,Launcher3系统应用的定制开发；</li>
<li>熟悉熟悉多指触控协议、画中画、分屏、自由窗口；</li>
<li>熟悉winscop,perfetto,systrace,Profile,adb,logcat,dumpsys等常用调试工具；</li>
<li>熟练处理冻屏、闪黑、黑屏、定屏、ANR、Crash等问题;</li>
<li>熟悉app组件化开发、jetpack及各种安卓开发组件；</li>
<li>熟悉app性能优化、屏幕适配、进程保活、软件稳定性处理；</li>
<li>熟悉git,svn,as,asfp,vscode,vim等常用开发工具；</li>
<li>能够解决Framework层的定制问题并熟悉Android APK及Android系统应用的开发流程，拥有良好的表达能力与沟通能力,工作积极主动,能尽心尽责地完成本职工作. 热衷于移动互联的垂直领域,对Hal及bsp方向有着浓厚的兴趣；</li>
</ul>
<p>####工作经历</p>
<ul>
<li><p>重庆捷旭科技有限公司   	                             2020.03-至今                                     Android工程师 </p>
</li>
<li><p>重庆国狮科技有限公司                                   2018.06-2020.02                              Android组负责人</p>
</li>
<li><p>重庆全心协力科技有限公司                           2016.04-2018.06                               Android工程师</p>
</li>
</ul>
<p>####重点项目经历</p>
<ul>
<li><p>捷宇M32-rk3566-android13_r6 framework定制开发</p>
<ul>
<li>项目简介：定制M32信息交互终端设备，集成身份核验、电子签名、指纹采集、社保卡读写、二维码扫描、高拍仪、服务评价、数据加密等功能的设备，能有效实现业务无纸化办理，应用于电子政务、医保社保、卫生健康、公共服务等智慧办公、身份核验及签批审核无纸化等领域。</li>
<li>项目地址：<a target="_blank" rel="noopener" href="http://www.fjjieyu.com/product/index/133">http://www.fjjieyu.com/product/index/133</a></li>
<li>项目职责：framework定制及bug处理</li>
<li>需求&amp;技术：<ul>
<li>动态开关触摸功能，注入触摸事件，Native层实现原始触摸识别</li>
<li>画中画、分屏、自由窗口;</li>
<li>冻屏bug处理</li>
<li>壁纸切换闪黑bug解决</li>
<li>内置系统apk应用实现不可退出不可卸载的需求；</li>
<li>修改开关机动画为云上共享法庭的启动动画；</li>
<li>app无root执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;</li>
</ul>
</li>
</ul>
</li>
<li><p>云上共享法庭APP开发</p>
<ul>
<li>项目简介：重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，已在各级法院正式投入使用并繁衍出多种不同的定制版本；</li>
<li>项目地址：<a target="_blank" rel="noopener" href="https://www.jetshine.com.cn/product.html?id=1520657316474638337">https://www.jetshine.com.cn/product.html?id=1520657316474638337</a></li>
<li>项目职责：独立负责该项目的法官&#x2F;当事人&#x2F;签字端&#x2F;手机端&#x2F;电视端的Android开发及适配任务；</li>
<li>需求&amp;技术：<ul>
<li>组件化+mvp架构实现多身份多模块解耦；</li>
<li>Jetpack+Retrofit+AutoSize+第三方硬件厂商sdk对接完成技术功能；</li>
<li>profile+perfetto+systrace+leakcanary保障app性能；</li>
<li>monkey+自定义异常收集类保障应用稳定性；</li>
</ul>
</li>
</ul>
</li>
<li><p>出行加司机&amp;乘客 android开发 </p>
<ul>
<li><p>项目简介：一款专用于出行加网约车平台司机接单,网约车乘客派单的应用，根据司机注册公司及车辆信息，可动态接取不同类型的网约车订单，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用，该应用已繁衍出小巷约车应用；</p>
</li>
<li><p>项目地址：<a target="_blank" rel="noopener" href="https://www.dacheruanjian.cn/index.html">https://www.dacheruanjian.cn/index.html</a></p>
</li>
<li><p>项目职责：独立负责该项目的乘客及司机端的开发及适配任务；</p>
</li>
<li><p>需求&amp;技术：</p>
<ul>
<li>Jetpack+Okhttp+AutoSize+高德&#x2F;微信&#x2F;支付宝等第三方api;</li>
<li>https双向验证+ssl证书</li>
<li>进程保活+Sentry自动打包</li>
</ul>
</li>
</ul>
</li>
<li><p>完整项目经历地址： <a target="_blank" rel="noopener" href="https://cq-tyl.github.io/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">https://cq-tyl.github.io/wiki/其他笔记/我的简历/完整项目经历/</a></p>
</li>
</ul>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/MVC、MVP、MVVM架构" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="01-架构介绍"><a href="#01-架构介绍" class="headerlink" title="01 架构介绍"></a>01 架构介绍</h2><p>先来看一下MVC、MVP、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020">MVVM</a>的架构图。</p>
<p><img src="/../../images/be7811835b0814ddeebca2ffa18b4b7b.png"></p>
<p>从这些架构图中，可以看到每种架构都有3个模块以及数据流动方向箭头。</p>
<p><strong>模块</strong></p>
<p>在系统架构中，首先要做的就是把系统整体按照一定的原则划分成模块。</p>
<p><strong>数据流动</strong></p>
<p>模块划分之后，模块之间的通信，就是数据的流动。在Android中，流动数据包括两部分，事件和数据。</p>
<p><strong>架构</strong></p>
<p>模块和模块之间的数据通信方式构成不同的架构。在这3种架构中，都是把系统整体划分成了3个模块：<strong>视图层，数据层，业务层。</strong> 他们之间的区别在于，模块之间的通信方式（数据流动方向）不一致。</p>
<ul>
<li>MVC是视图层接收到事件后调用到业务层处理业务逻辑，业务层调用数据层处理数据，数据层再调用视图层更新页面。</li>
<li>MVP是视图层接收到事件后调用到业务层处理，业务层调用数据层处理数据，数据层处理数据后回调给业务层，业务层再回调给视图层更新页面。（数据层已不再持有视图层，他们之间通过业务层（Presenter）交互，具体使用接口实现，使数据层和视图层解耦。</li>
<li>MVVM在MVP的基础上实现了视图层和业务层的双向数据绑定（data binding），不再通过接口的方式交互，ViewModel不在和Presenter一样持有视图层，使视图层和业务层解耦。</li>
</ul>
<h2 id="02-具体实现"><a href="#02-具体实现" class="headerlink" title="02 具体实现"></a>02 具体实现</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="/../../images/c37db6c4812686b6d6ed0a1396bfd213.png"></p>
<p>视图层：在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVC%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">MVC架构</a>中， Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理。需要和Activity一起才能够构成一个完整的视图层。</p>
<p>业务层：大多数的MVC架构开发的安卓项目， 并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，这就是MVC的缺点之一。 在本例中，我们会将业务层独立出来，实现一个标准的MVC架构。</p>
<p>数据层：数据层Model指的是，数据管理模块，这包括了数据的获取，处理。存储等。 MVP、MVVM的架构中的Model也是一样。后面不再赘述。</p>
<p><strong>代码结构</strong></p>
<img src="../../images/e27724fe4c2920ff7b1623bf12b8f015.png" style="zoom:67%;" />

<p><strong>xml代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/ll_gallery_outer&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/tv_result&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=<span class="string">&quot;@+id/tv_account&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;40dp&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">&quot;16dp&quot;</span></span><br><span class="line">        android:layout_marginTop=<span class="string">&quot;20dp&quot;</span></span><br><span class="line">        android:layout_marginRight=<span class="string">&quot;16dp&quot;</span></span><br><span class="line">        android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:hint=<span class="string">&quot;输入用户名&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=<span class="string">&quot;@+id/tv_pwd&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;40dp&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">&quot;16dp&quot;</span></span><br><span class="line">        android:layout_marginRight=<span class="string">&quot;16dp&quot;</span></span><br><span class="line">        android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:hint=<span class="string">&quot;输入密码&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/btn_login&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;40dp&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">&quot;16dp&quot;</span></span><br><span class="line">        android:layout_marginRight=<span class="string">&quot;16dp&quot;</span></span><br><span class="line">        android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;登录&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>




<p><strong>Activity代码</strong></p>
<pre><code>public class MVCActivity extends AppCompatActivity &#123;

    TextView tvResult;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
         tvResult = findViewById(R.id.tv_result);
        TextView tvAccount = findViewById(R.id.tv_account);
        TextView tvPwd = findViewById(R.id.tv_pwd);
        Button btnLogin = findViewById(R.id.btn_login);

        MVCController mvcController = new MVCController();

        btnLogin.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                mvcController.login(tvAccount.getText().toString(),tvPwd.getText().toString(), MVCActivity.this);
            &#125;
        &#125;);
    &#125;

    public void loginSuccess()&#123;
        tvResult.setText(&quot;登录结果：登录成功&quot;);
    &#125;

    public void loginFail()&#123;
        tvResult.setText(&quot;登录结果：登录失败&quot;);
    &#125;

&#125;
</code></pre>
<p>​    </p>
<p><strong>Controller代码</strong></p>
<pre><code>public class MVCController &#123;

    MVCModel mvcModel;

    public MVCController() &#123;
        mvcModel = new MVCModel();
    &#125;

    public void login(String account, String pwd, MVCActivity loginActivity) &#123;
        mvcModel.login(account, pwd, loginActivity);
    &#125;
&#125;
</code></pre>
<p>​    </p>
<p><strong>Model代码</strong></p>
<pre><code>public class MVCModel &#123;

    public void login(String account, String pwd, MVCActivity loginActivity)&#123;

        if (account == null || account.length()==0) &#123;
            loginActivity.loginFail();
        &#125;

        if (pwd == null || pwd.length()==0) &#123;
            loginActivity.loginFail();
        &#125;

        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd))&#123;
            loginActivity.loginSuccess();
        &#125;

    &#125;

&#125;
</code></pre>
<h4 id="实现代码说明"><a href="#实现代码说明" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>在Activity中监听登录按钮的事件，接收到事件之后，调用Controller的登录方法处理登录逻辑，在Controller的登录方法中调用Model请求网络数据（这里是模拟）判断是否登录成功，Model拿到登录结果后，调用Activity的方法刷新页面数据，展示登录结果。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：通过划分模块的方式，将系统分成了3个模块，视图层，业务层和数据层。 代码开发实现不再是只在一个代码文件中，一定程度便于程序开发。</p>
<p>缺点：但是三个模块之间还存在很强的耦合关系。 不利于业务需求的更变和代码维护工作。</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><img src="../../images/aa8a22ae779896db83a16b173c9782a4.png" style="zoom:67%;" />

<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVP%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">MVP架构</a>是基于MVC的改进，将MVC的中Controller独立出来作为Presenter。 xml和Activity还是作为视图层， 视图层接收到页面数据，调用Presenter进行业务逻辑处理，Presenter调用Model进行数据处理，Model回传数据给Presenter，Presenter回传数据给View。数据的回传通过接口回调的方式来实现。</p>
<p><strong>代码结构</strong></p>
<img src="../../images/ceb4b647e87386e3bbdaa4a844249588.png" style="zoom:50%;" />

<p><strong>IModel接口代码</strong></p>
<pre><code>public interface IModel &#123;
    public boolean login(String account, String pwd);
&#125;
</code></pre>
<p>​    </p>
<p><strong>IView接口代码</strong></p>
<pre><code>public interface IView &#123;
    public void loginSuccess();
    public void loginFail();
&#125;
</code></pre>
<p>​    </p>
<p><strong>Activity代码</strong></p>
<pre><code>public class MVPActivity extends AppCompatActivity implements IView &#123;

    TextView tvResult;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);

        tvResult = findViewById(R.id.tv_result);

        TextView tvAccount = findViewById(R.id.tv_account);
        TextView tvPwd = findViewById(R.id.tv_pwd);
        Button btnLogin = findViewById(R.id.btn_login);

        MVPPresenter presenter = new MVPPresenter();
        presenter.setiView(this);
        btnLogin.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                presenter.login(tvAccount.getText().toString(), tvPwd.getText().toString());
            &#125;
        &#125;);
    &#125;

    public void loginSuccess() &#123;
        tvResult.setText(&quot;登录结果：登录成功&quot;);
    &#125;

    public void loginFail() &#123;
        tvResult.setText(&quot;登录结果：登录失败&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>Model代码</strong></p>
<pre><code>public class MVPModel implements IModel &#123;
    public boolean login(String account, String pwd) &#123;

        if (account == null || account.length() == 0) &#123;
            return false;
        &#125;

        if (pwd == null || pwd.length() == 0) &#123;
            return false;
        &#125;

        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123;
            return true;

        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>Presenter代码</strong></p>
<pre><code>public class MVPPresenter &#123;

    MVPModel model;

    public MVPPresenter() &#123;
        model = new MVPModel();
    &#125;

    IView iView;

    public void setiView(IView iView) &#123;
        this.iView = iView;
    &#125;

    public void login(String account, String pwd) &#123;
        boolean loginResult = model.login(account, pwd);

        if (loginResult)&#123;
            iView.loginSuccess();
        &#125;else &#123;
            iView.loginFail();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="实现代码说明-1"><a href="#实现代码说明-1" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>定义了两个接口，IView和IModel, Activity和Model分别实现了这两个接口。 在Presenter中持有这两个实例。Presenter调用Model处理数据后，通过Iview的接口方法回调给Activity刷新页面。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>从上面的代码可以看到，三个模块之间的通信是通过接口实现的，在实际开发，定义的接口和方法会非常多。 导致很简单的一个页面功能也需要实现多个接口和方法。</p>
<p>优点就是通过Presenter，把MVC中的Controller代码抽出来了，并且Presenter作为View和Model通信的桥梁，完成了Model和View的解耦。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><img src="../../images/721acde222529fd6f3964f1fa7755c63.png" style="zoom:50%;" />

<p>MVVM在MVP的基础上加入了双向绑定，使View能够感知ViewModel中的数据变化，ViewModel能够感知View数据的变化。</p>
<p><strong>代码结构</strong></p>
<img src="../../images/945eade69fd1693f76c583b4251da203.png" style="zoom:50%;" />

<p><strong>xml代码</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;

        &lt;variable
            name=&quot;viewModel&quot;
            type=&quot;com.domain.android.study.notes.architecture.mvvm.MVVMViewModel&quot; /&gt;

    &lt;/data&gt;

    &lt;LinearLayout
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:id=&quot;@+id/ll_gallery_outer&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_result&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@&#123;viewModel.result&#125;&quot;
            android:layout_gravity=&quot;center&quot; /&gt;

        &lt;EditText
            android:id=&quot;@+id/tv_account&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:layout_height=&quot;40dp&quot;
            android:hint=&quot;输入用户名&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;@=&#123;viewModel.account&#125;&quot;

            android:layout_gravity=&quot;center&quot;
            android:layout_marginTop=&quot;20dp&quot; /&gt;

        &lt;EditText
            android:id=&quot;@+id/tv_pwd&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:layout_height=&quot;40dp&quot;
            android:hint=&quot;输入密码&quot;
            android:text=&quot;@=&#123;viewModel.pwd&#125;&quot;
            android:gravity=&quot;center&quot;
            android:layout_gravity=&quot;center&quot; /&gt;

        &lt;Button
            android:id=&quot;@+id/btn_login&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:layout_height=&quot;40dp&quot;
            android:text=&quot;登录&quot;
            android:gravity=&quot;center&quot;
            android:layout_gravity=&quot;center&quot; /&gt;

    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>Activity代码</strong></p>
<pre><code>public class MVVMActivity extends AppCompatActivity &#123;

    MVVMViewModel viewModel;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        ActivityLoginBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_login);
        viewModel = ViewModelProviders.of(this).get(MVVMViewModel.class);
        binding.setVariable(BR.viewModel, viewModel);
        binding.setLifecycleOwner(this);
        binding.btnLogin.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                viewModel.login();
            &#125;
        &#125;);

    &#125;

&#125;
</code></pre>
<p><strong>ViewModel代码</strong></p>
<pre><code>public class MVVMViewModel  extends ViewModel &#123;

    public ObservableField&lt;String&gt; account = new ObservableField&lt;&gt;(&quot;&quot;);
    public ObservableField&lt;String&gt; pwd = new ObservableField&lt;&gt;(&quot;&quot;);
    public ObservableField&lt;String&gt; result = new ObservableField&lt;&gt;(&quot;&quot;);

    MVVMModel mvvmModel;
    public MVVMViewModel() &#123;
         mvvmModel = new MVVMModel();
    &#125;

    public void login()&#123;
        boolean loginResult = mvvmModel.login(account.get(), pwd.get());
        result.set(loginResult ? &quot;登录结果：成功&quot; :&quot;登录结果：失败&quot;);
    &#125;

&#125;
</code></pre>
<p><strong>Model代码</strong></p>
<pre><code>public class MVVMModel &#123;
    public boolean login(String account, String pwd) &#123;
        if (account == null || account.length() == 0) &#123;
            return false;
        &#125;

        if (pwd == null || pwd.length() == 0) &#123;
            return false;
        &#125;
        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p>在本例MVVM架构实现中，用到了Android提供的data binding这个数据双向绑定框架。需要在APP模块的gralde文件中添加以下配置开启：</p>
<pre><code> android &#123;
 ...
 dataBinding &#123;
        enabled true
    &#125;
  ...
    &#125;
</code></pre>
<h4 id="实现代码说明-2"><a href="#实现代码说明-2" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>通过Android提供的数据双向绑定库data binding 将Acitvity&#x2F;xml视图层与ViewModel绑定。在xml布局文件中，通过<code>@&#123;&#125;</code>来表示单向绑定或者<code>@=&#123;&#125;</code>来表示双向绑定。Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。</p>
<p><strong>注意</strong></p>
<p>data binding通过观察者模式实现。 内部具体实现也是通过调用notify通知数据变化给观察者，notify调用了观察者实现的接口方法。</p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：经过数据双向绑定之后，我们不在需要想MVP中写那么多接口回调方法区实现视图层和业务层的交互。业务层也不再持有视图层的引用。</p>
<p>缺点：通过这种方式进行数据双向绑定后，xml中会多出一些标签、表达式、甚至和业务有点的简单计算代码。这不利于业务的逻辑的查看。并且由于双向绑定是data binding实现的。在这个过程中， 如果出现bug导致数据没有被感知改变，不方便排错，因为xml不能debug调试。</p>
<h2 id="03-总结"><a href="#03-总结" class="headerlink" title="03 总结"></a>03 总结</h2><p>MVC、MVP、MVVM大体上都是把系统划分成3个模块：视图层、业务层、数据层。 但是他们的通信方式、数据流动方向不一致，形成了不同的架构。 其后面产生的架构都是为了更好的解耦，解决已有架构的不足。每个架构都有自己的优缺点，<strong>没有最好的架构，只有最合适的架构。</strong></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/Jetpack/0.jetpack合集" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/">Jetpack</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            

	<div class="row">
    <embed src="/pdf/jetpack合集.pdf" width="100%" height="550" type="application/pdf">
	</div>



            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/性能优化/0.app性能优化集合" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            

	<div class="row">
    <embed src="/pdf/app性能优化.pdf" width="100%" height="550" type="application/pdf">
	</div>




<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性能优化</span></span><br><span class="line">性能优化:包括了启动，内存，布局，卡顿，网络，电量，瘦身，稳定性；</span><br><span class="line">性能监测平台：外网：听云，内网：自检各种性能检测机制，统一上报；</span><br><span class="line"></span><br><span class="line"><span class="comment">//App启动优化</span></span><br><span class="line"><span class="number">1.</span>获取启动耗时：</span><br><span class="line"> 		<span class="number">1.</span>手动埋点，aop统一处理，systrace/traceview获取</span><br><span class="line"> <span class="number">2.</span>优化手段：延迟加载或者异步加载(充分利用CPU，将任务放到子线程中执行分担主线程任务，jetpack的App Startup框架，或者自定义使</span><br><span class="line"> 	用线程池异步加载)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//内存优化：内存优化主要体现在两个地方，第一个是内存抖动，第二个是内存泄漏</span></span><br><span class="line"><span class="number">1.</span> 内存抖动： 主要是由于快速的内存创建和释放造成的，容易产生<span class="built_in">GC</span>(Profiler);</span><br><span class="line"><span class="number">2.</span> 内存泄漏：主要是由于长生命周期的引用了短生命周期的对象造成的(leakcary);</span><br><span class="line"><span class="number">3.</span> 检测方式：AS的Profiler（Memory Profiler/Memory Analyzer）主动检测，leakcary被动的自动检测；</span><br><span class="line"></span><br><span class="line"><span class="comment">//布局优化</span></span><br><span class="line"><span class="number">1.</span> 绘制时长检测：</span><br><span class="line">  	<span class="number">1.</span>AOP（面向切面编程,在指定的地方执行特定的代码）的方式获取每个界面的绘制耗时;</span><br><span class="line">  	<span class="number">1.</span>Systrace查看整体绘制情况，查看是否存在绘制耗时等情况；</span><br><span class="line">  	<span class="number">2.</span>as自带的布局检测工具Inspector，查看视图层次结构；</span><br><span class="line"><span class="number">2.</span>如存在io加载布局文件慢</span><br><span class="line">  	<span class="number">1.</span>使用AsyncLayoutInflater/X2C异步加载布局</span><br><span class="line"><span class="number">3.</span> 布局层级:减少布局层级，减少过度绘制</span><br><span class="line">    <span class="number">1.</span>减少View树层级</span><br><span class="line">    <span class="number">2.</span>宽而浅，避免窄而深</span><br><span class="line">   	<span class="number">3.</span>尽量使用 ConstraintLayout布局控件</span><br><span class="line"> <span class="number">2.</span>gpu过度绘制<span class="comment">//开发者选项-调试gpu过度绘制打开设置</span></span><br><span class="line">    <span class="number">1.</span>一个像素最好只被绘制一次</span><br><span class="line">    <span class="number">2.</span>调试GPU过度绘制</span><br><span class="line">    <span class="number">3.</span>蓝色可接受</span><br><span class="line"> <span class="number">3.</span> 卡顿的原因就是CPU数据处理不过来，比如层级过深，CPU太忙，GC，之类的，可以通过systrace 工具进行检测，</span><br><span class="line">		然后通过编舞者监测帧率定位时间，再然后可以通过looper的日志功能定位到卡顿点。网上也有库blockcanary</span><br><span class="line"> <span class="number">3.</span>在Systrace 报告中，你可以查看应用程序布局绘制的相关事件，包括布局计算、绘制命令的发送、GPU 图形呈现等阶段所花费的时间</span><br><span class="line"> </span><br><span class="line"><span class="comment">//卡顿优化</span></span><br><span class="line"><span class="number">1.</span>硬件性能导致卡顿：CPU Profiler/Systrace 分析查看CPU利用率</span><br><span class="line"><span class="number">2.</span>使用blockcanary可以实现自动化监测卡顿</span><br><span class="line"><span class="number">3.</span>anr检测：ANR-WatchDog，logcat/trace.txt日志分析信息</span><br><span class="line">	</span><br><span class="line"><span class="comment">//网络优化</span></span><br><span class="line"><span class="number">1.</span>网络缓存：</span><br><span class="line">	<span class="number">1.</span>服务端返回加上过期时间，避免每次重新获取</span><br><span class="line">  <span class="number">2.</span>OkHttp、Retfort、Volley都有较好实践</span><br><span class="line">  <span class="number">3.</span>无网络时展示数据缓存；</span><br><span class="line"><span class="number">2.</span>网络质量：</span><br><span class="line">	<span class="number">1.</span>时长、业务成功率、失败率的统计，在OkHttp、Retfort、Volley等自行统计相关数据并在特定场景合并上报；</span><br><span class="line">	<span class="number">2.</span>弱网络模拟</span><br><span class="line"><span class="number">3.</span>增量更新：</span><br><span class="line">	<span class="number">1.</span>加上版本的概念，只传输有变化的数据</span><br><span class="line"><span class="number">4.</span>数据压缩:</span><br><span class="line">  <span class="number">1.</span>Post请求Body使用GZip压缩(字符压缩)</span><br><span class="line">  <span class="number">2.</span>图片上传之前必须压缩</span><br><span class="line"><span class="number">5.</span>图片相关：</span><br><span class="line">  <span class="number">1.</span>图片使用策略细化:优先缩略图</span><br><span class="line">  <span class="number">2.</span>使用WebP格式图片</span><br><span class="line"></span><br><span class="line"><span class="comment">//电量优化</span></span><br><span class="line"><span class="number">1.</span>电量优化检测方案：</span><br><span class="line">	Battery Historian</span><br><span class="line">  - Google推出的一款Android系统电量分析工具</span><br><span class="line">  - 支持<span class="number">50</span>(API21)及以上系统的电量分析</span><br><span class="line">  - 功能强大，推荐使用</span><br><span class="line">  - 可视化展示指标:耗电比例、执行时间、次数</span><br><span class="line">  - 适合线下使用</span><br><span class="line"><span class="number">2.</span>电量优化套路总结：</span><br><span class="line">	<span class="number">1.</span>网络相关:控制请求时机及次数,数据压缩，减少时间</span><br><span class="line">  <span class="number">2.</span>传感器相关:</span><br><span class="line">  	<span class="number">1.</span>根据场景谨慎选择定位模式</span><br><span class="line">	  <span class="number">2.</span>考虑网络定位代替GPS</span><br><span class="line">    <span class="number">3.</span>使用后务必及时关闭，减少更新频率</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//瘦身优化</span></span><br><span class="line"><span class="number">1.</span>代码混淆，统一三方库、删除无用代码</span><br><span class="line"><span class="number">2.</span>资源在线化</span><br><span class="line"><span class="number">3.</span>So:只保留Armeabi、或者只保留armeabi-v7a、arm64-v8a</span><br><span class="line"><span class="number">4.</span> 图片优化：</span><br><span class="line">	<span class="number">1.</span>根据场景使用不同的文件，比如将png换成webp，像什么需要来回改变的简单的图可以使用svg替换，去除不需要的图片资源</span><br><span class="line">	<span class="number">2.</span>图片压缩</span><br><span class="line"><span class="number">5.</span> 备用资源：默认情况下Android会有很多备用资源，比如string，包含了多国语言，我们可以指定需要的语言即可；</span><br><span class="line"></span><br><span class="line"><span class="comment">//稳定性优化</span></span><br><span class="line"><span class="number">1.</span>统一编码规范、增强编码功底、技术评审</span><br><span class="line"><span class="number">2.</span>架构优化:统一容错，功能模块解耦</span><br><span class="line"><span class="number">3.</span>回归测试，压力测试，兼容性测试，</span><br><span class="line"><span class="number">4.</span>容灾方案：热更新(bugly),功能开关，崩溃后自启等</span><br></pre></td></tr></table></figure>


            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/4.WMS窗口相关流程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <hr>
<h2 id="4-WMS窗口相关流程"><a href="#4-WMS窗口相关流程" class="headerlink" title="4.WMS窗口相关流程"></a>4.WMS窗口相关流程</h2><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>什么是窗口<br>窗口即是屏幕上的一块用于绘制各种UI元素并可以响应<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5&spm=1001.2101.3001.7020">用户输入</a>的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。<br>Window是个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&spm=1001.2101.3001.7020">抽象类</a>其实现类为PhoneWindow。<br>本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。<br>其他建议：可以先学习<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树相关内容，有助于对窗口模块的理解<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132174913">Android T 窗口层级其一 —— 容器类</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132213111">Android T 窗口层级其二 —— 层级结构树的构建</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132722735">Android T 窗口层级其三 —— 层级结构树添加窗口</a></p>
<h2 id="二、流程简述"><a href="#二、流程简述" class="headerlink" title="二、流程简述"></a>二、流程简述</h2><p>当Activity.onResume()被调用之后，客户端会与WMS进行通信将我们的布局显示在屏幕上。其中主要涉及以下几个过程：<br>客户端通知WMS创建一个窗口，并添加到WindowToken。即addToDisplayAsUser阶段。<br>客户端通知WMS创建Surface，并计算窗口尺寸大小。即relayoutWindow阶段。<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度。即performMeasure阶段。<br>客户端确定该窗口下View的尺寸和位置。即performLayout阶段。<br>确定好View的尺寸大小位置之后，便对View进行绘制。即performDraw阶段。<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来。即reportDrawFinished阶段。<br><img src="/../../../../../images/9bac0587c3614e088e376a948ffb45cb.png" alt="在这里插入图片描述"><br>这里以Activity.onResume()被调用之后为起点</p>
<h3 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h3><p>WindowManager：是一个接口类，负责窗口的管理（增、删、改）。</p>
<p>WindowManagerImpl：WindowManager的实现类，但是他把对于窗口的具体管理操作交给WindowManagerGlobal来处理。</p>
<p>WindowManagerGlobal：是一个单例类，实现了窗口的添加、删除、更新的逻辑，但是</p>
<p>ViewRootImpl：通过IWindowSession与WMS进行通信。其内部类W实现了WMS与ViewRootImpl的通信。<br><img src="/../../../../../images/7817e0249e55462596f58e9a66e68ac9.png" alt="在这里插入图片描述"></p>
<p>ActivityThread.java</p>
<ul>
<li>handleResumeActivity<br>通过WindowManager接口添加view，即<code>wm.addView(decor, l);</code>，wm为ViewManager对象，即<code>ViewManager wm = a.getWindowManager();</code></li>
</ul>
<p>WindowManagerImpl.java</p>
<ul>
<li>addView<br><code>mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,mContext.getUserId());</code>mGlobal为WindowManagerGlobal对象。</li>
</ul>
<p>WindowManagerGlobal.java</p>
<ul>
<li>addView<br><code>root.setView(view, wparams, panelParentView, userId);</code>root为ViewRootImpl对象。<br><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>parentWindow为Window（Window为抽象类，PhoneWindow继承于Window），即在Window中调用adjustLayoutParamsForSubWindow，用于赋值参数布局的token以及title</li>
</ul>
<p>ViewRootImpl.java</p>
<ul>
<li>setView<br>1.addToDisplayAsUser<br>客户端通知WMS创建一个窗口，并添加到WindowToken<br><code>res = mWindowSession.addToDisplayAsUser(mWindow,mWindowAttributes,getHostVisibility(), mDisplay.getDisplayId(), userId,mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,mTempControls);</code><br>2.requestLayout<br>在添加到窗口管理器之前安排第一个布局，以确保我们在从系统接收任何其他事件之前进行重新布局<br>scheduleTraversals-&gt;doTraversal-&gt;performTraversals<br>performTraversals中调用了五个关键方法：<br>relayoutWindow<br>客户端通知WMS创建Surface，并计算窗口尺寸大小<br>performMeasure<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度<br>performLayout<br>客户端确定该窗口下View的尺寸和位置<br>performDraw<br>确定好View的尺寸大小位置之后，便对View进行绘制<br>createSyncIfNeeded-&gt;reportDrawFinished<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来</li>
</ul>
<h3 id="2-通信方式"><a href="#2-通信方式" class="headerlink" title="2. 通信方式"></a>2. 通信方式</h3><p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p>
<ul>
<li><p>IWindowSession.aidl<br>ViewRootImpl中通过此接口调用服务端<br>1.addToDisplayAsUser<br>2.relayout<br>3.finishDrawing</p>
</li>
<li><p>Session.java<br>IWindowSession的实现在这里，最终调用到WMS中<br>1.addToDisplayAsUser-&gt;addWindow<br>2.relayout-&gt;relayoutWindow<br>3.finishDrawing-&gt;finishDrawingWindow</p>
</li>
</ul>
<h3 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3. 服务端"></a>3. 服务端</h3><p>WindowManagerService：负责为Activity对应的窗口分配Surface，管理Surface的显示顺序以及位置尺寸，控制窗口动画，并且还是输入系统的一个重要中转站。</p>
<p>WindowState：和客户端窗口一一对应，在向WMS添加一个窗口时，WMS会为其创建一个WindowState，来表示窗口的所有属性，WindowState相当于属性窗口管理（比如对外提供操作接口，属于层级结构中最底部的容器），窗口画面相关都剥离给了WindowStateAnimator，WindowState也是WMS中事实上的窗口。</p>
<p>WindowStateAnimator：主要用于管理WindowState相关画面surface，通过mDrawState参数来描述Surface所处的状态。</p>
<p>WindowToken：保存了所有具有同一个token的WindowState，将属于同一个activity的窗口组织在一起，activity在需要更新窗口时，必须向WMS提供WindowToken以表名自己的身份，并且窗口的类型必须与所持有的的WindowToken类型一致。<br>补充：一个WindowToken可以对应多个WindowState。 WindowToken是一个用于表示窗口层次结构中的窗口的标识符。每个Window具有一个与之关联的WindowToken，它用于帮助系统管理窗口的显示和交互。<br>一个WindowToken可以有多个WindowState表示与之相关的窗口。这是因为在Android系统中，可能会存在一些特殊情况，例如PopupWindow、Dialog等，它们属于同一个WindowToken，但是显示在不同的窗口上。<br>因此，一个WindowToken可以与多个WindowState关联，这样可以实现多个窗口的操作和管理。</p>
<p>WindowSurfaceController：用来创建SurfaceControl。</p>
<p>DisplayContent：即代表的是单个屏幕。隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每个DisplayContent都对应着一个唯一的id，在添加窗口时可以通过指定这个ID决定将其显示在哪个屏幕中。</p>
<p>WindowSurfacePlacer：整个窗口层次结构刷新的入口。</p>
<p>RootWindowContainer：是窗口容器的顶层容器，其直接管理DisplayContent。</p>
<p><strong>WindowManagerService.java</strong></p>
<h4 id="3-1-addWindow"><a href="#3-1-addWindow" class="headerlink" title="3.1.addWindow"></a>3.1.addWindow</h4><p><img src="/../../../../../images/f032b7cd5a8c470baec7a233a96571a1.png" alt="在这里插入图片描述"><br>1.根据客户端传来的token获取WindowToken或创建WindowToken，并将其挂载到对应的层级节点上<br><code>WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);</code><br>判断WindowToken是否有父亲,即parentWindow 是否不为空<br><code>final boolean hasParent = parentWindow != null;</code><br>注：前面代码有判断是否是子窗口，是则会给parentWindow 赋值；否则parentWindow仍为初始值，即为空<br><img src="/../../../../../images/5b2dfebaa2fa466bbc667e9140ea7150.png" alt="在这里插入图片描述"><br>关于窗口类型，见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/130442487">窗口常见参数汇总</a><br>Activity启动时会在ActivityRecord的构造方法中new Token()。<br><strong>应用侧直接通过addView的方式添加窗口不会有ActivityRecord,因此不会在ActivityRecord的构造方法中new Token()。</strong><br><strong>系统侧直接添加的窗口（状态栏、导航栏等），是通过new WindowToken.Builder的方式添加</strong><br><strong>即主动使用ViewManager.addView来添加一个窗口则不会在ActivityRecord的构造方法中new Token()，否则通过new WindowToken.Builder的方式添加。</strong><br>attrs.token这个参数一可以在应用端设置，应用没有设置token那么就为空，token为IBinder类型对象，默认值为空<code>public IBinder token = null;</code><br>例如：<br>在应用侧可通过mLayoutParams.token的方式设置值<br><code>private WindowManager.LayoutParams mLayoutParams;</code><br><code>mLayoutParams.token = null;</code></p>
<p>后面会继续判断token是否为空,最终会到最后的else中创建token<br><img src="/../../../../../images/72554e9137594c86972bb0cda59bae86.png" alt="在这里插入图片描述"><br>2.创建WindowState<br><code>final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId,session.mCanAddInternalSystemWindow);</code><br>3.验证当前窗口是否可以添加到WMS<br><code>res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</code><br>该方法会对窗口TYPE,FLAG等多方面判断。只有返回ADD_OKAY时表示允许当前窗口的添加，反之则不允许添加该窗口。假如想禁止某些应用做添加窗口操作时，可以在里面通过应用的包名过滤该应用，也可以直接在WindowManagerGlobal.java的addView()方法中直接对应用想要添加的窗口进行过滤。<br>注：<code>ADD_OKAY</code>在WindowManagerGlobal中定义，这个类里面还有一些其他的返回值，所有返回给<code>res</code>的常量最终会在ViewRootImpl的setView方法中判断<br>4.调用openInputChannel，初始化input相关通路（本文不做讨论）<br><code>final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);</code><br><code>if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125;</code><br>5.将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WMS窗口添加之后，还没有创建Surface，此时mDrawState状态为NO_SURFACE</p>
<h4 id="3-2-relayoutWindow"><a href="#3-2-relayoutWindow" class="headerlink" title="3.2 relayoutWindow"></a>3.2 relayoutWindow</h4><p><img src="/../../../../../images/0251fd28a86a46fea1e29a81b2f55897.png" alt="在这里插入图片描述"><br>1.根据客户端传递过来的IWindow的mWindowMap获取窗口添加阶段创建的WindowState<br><code>final WindowState win = windowForClientLocked(session, client, false);</code><br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br><code>win.setDisplayLayoutNeeded();</code>win为WindowState对象，该方法实际操作在DisplayContent中<br><code>final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;(win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || win.mActivityRecord.isClientVisible());</code><br>3.创建SurfaceControl<br>在layoutWindow()调用了createSurfaceControl方法创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code>该方法的实现仍然在WMS中<br>这里以createSurfaceControl方法为起点<br><img src="/../../../../../images/c9cf74cf9cbd45bfb3476c07e3f990b3.png" alt="在这里插入图片描述"><br>在createSurfaceControl()中调用WindowStateAnimator执行具体的SurfaceControl的创建 <code>surfaceController = winAnimator.createSurfaceLocked();</code><br>创建Surface后，Surface还未进行绘制，此时mDrawState状态为DRAW_PENDING<br>将创建的SurfaceControl赋值给客户端的outSurfaceControl<br><code>surfaceController.getSurfaceControl(outSurfaceControl);</code><br>4.窗口尺寸的计算以及Surface状态更新<br>在layoutWindow()调用了performSurfacePlacement<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code>mWindowPlacerLocked为WindowSurfacePlacer对象，因此这里以WindowSurfacePlacer的performSurfacePlacement()为起点<br><img src="/../../../../../images/45182f6e931246bda89e986fff0005f6.png" alt="在这里插入图片描述"><br>处理窗口布局循环<br>WindowSurfacePlacer.performSurfacePlacementLoop()<br>处理Surface的状态更变，以及调用LayoutWindowLw的流程<br>RootWindowContainer.performSurfacePlacementNoTrace()<br>计算窗口位置大小<br>DisplayPolicy.layoutWindowLw()</p>
<h4 id="3-3-finishDrawingWindow"><a href="#3-3-finishDrawingWindow" class="headerlink" title="3.3 finishDrawingWindow"></a>3.3 finishDrawingWindow</h4><p><img src="/../../../../../images/aa5261464c984b56830d1931ec67e207.png" alt="在这里插入图片描述"><br><img src="/../../../../../images/8d84cc58579d4e5cb0c2e924ce3f8afc.png" alt="在这里插入图片描述"></p>
<p>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PEDING<code>win.finishDrawing(postDrawTransaction, seqId)</code>,并请求窗口布局<code>mWindowPlacerLocked.requestTraversal();</code><br>2.通过mApplySurfaceChangesTransaction的callback，</p>
<p><img src="/../../../../../images/9e5c8036f3504e6f84c1a9f80070bdfa.png" alt="在这里插入图片描述"><br>调用commitFinishDrawingLocked()<img src="/../../../../../images/a2c46436037a4a3da9af6fa7c12d1b47.png" alt="在这里插入图片描述"><br>改变mDrawState状态将mDrawState更新为READY_TO_SHOW,<br>最终mDrawState更新为HAS_DRAW后，再次请求窗口布局<br><img src="/../../../../../images/cae5471da1f24847b7e954bd0827ad11.png" alt="在这里插入图片描述"><br>3.执行show Surface<br><code>showSurfaceRobustlyLocked(t)</code><br>注：WindowStateAnimator的commitFinishDrawingLocked()方法中，如果是<strong>应用通过WindowManager中的addView的方式创建窗口，则不会有ActivityRecord</strong>，或者该窗口类型为启动窗口，则直接调用<code>result = mWin.performShowLocked();</code>，即WindowState的performShowLocked()方法改变窗口状态为HAS_DRAW，否则会从RootWindowContainer的checkAppTransitionReady方法逐步调用到performShowLocked()<br><img src="/../../../../../images/97725b2413d74debb25621deab0c5c62.png" alt="在这里插入图片描述"></p>
<h3 id="4-窗口状态变化总结"><a href="#4-窗口状态变化总结" class="headerlink" title="4.窗口状态变化总结"></a>4.窗口状态变化总结</h3><p>WMS为了管理窗口的显示进度，在WindowStateAnimator中定义了mDrawState来描述Surface所处的状态。主要有如下五种状态：<br>NO_SURFACE:WMS添加窗口,即调用addWindow之后，还没有创建Surface，mDrawState处于该状态。<br>DRAW_PENDING:app调用relayoutWindow创建Surface后，但是Surface还没有进行绘制，mDrawState处于该状态。<br>COMMIT_DRAW_PENDING:app完成Surface的绘制，调用finishDrawing，将mDrawState设置为该状态。<br>READY_TO_SHOW:在performSurfacePlacement过程中会将所有处于COMMIT_DRAW_PENDING状态的mDrawState变更为READY_TO_SHOW。<br>HAS_DRAW:若准备显示窗口，WMS执行performShowLocked，将mDrawState设置为该状态<br><img src="/../../../../../images/ad8fdb698a23430a942bcfd773fcba80.png" alt="在这里插入图片描述"></p>
<p>窗口显示相关方法</p>
<p>工作内容解释</p>
<p>addWindow</p>
<p>App向WMS请求添加窗口记录，会在WMS里新建WindowState(NO_SURFACE)</p>
<p>relayoutWindow</p>
<p>App向WMS申请surface用于绘制，执行后window拥有了surface(NO_SURFACE-&gt;DRAW_PENDING)</p>
<p>finishDrawingWindow</p>
<p>App在surface上完成绘制后，通知WMS(DRAW_PENDING-&gt;COMMIT_DRAW_PENDING)</p>
<p>commitFinishDrawingLocked</p>
<p>WMS遍历window，对于完成绘制的window(COMMIT_DRAW_PENDING-&gt;READY_TO_SHOW)</p>
<p>performShowLocked</p>
<p>判断系统是否允许窗口显示isReadyForDisplay(READY_TO_SHOW-&gt;HAS_DRAWN)</p>
<p>showSurfaceRobustlyLocked</p>
<p>对HAS_DRAWN状态的窗口，用SurfaceControl通知SurfaceFlinger显示出来</p>
<h3 id="5-移除流程简述"><a href="#5-移除流程简述" class="headerlink" title="5.移除流程简述"></a>5.移除流程简述</h3><p>窗口移除从App端发起，当Activity执行destroy(),即以handleDestroyActivity()为起点，执行wm.removeViewImmediate()开启；<br><strong>通过WindowManagerGlobal–&gt;ViewRootImpl–&gt;Session–&gt;WindowManagerService的removeWindow()，调用到WindowState的removeIfPossible()–&gt;removeImmediately()，接着调用到WindowStateAnimator的destroySurfaceLocked()–&gt;destroySurface(),逐步调用改变绘制状态为NO_SURFACE–&gt;WindowSurfaceController的destroy()最终调用到SurfaceControl的remove()来通知SurfaceFlinger来移除layer</strong>；</p>
<h2 id="三、代码流程详解"><a href="#三、代码流程详解" class="headerlink" title="三、代码流程详解"></a>三、代码流程详解</h2><h3 id="1-客户端-1"><a href="#1-客户端-1" class="headerlink" title="1.客户端"></a>1.客户端</h3><h4 id="1-1-Activity走到onresume后"><a href="#1-1-Activity走到onresume后" class="headerlink" title="1.1 Activity走到onresume后"></a>1.1 Activity走到onresume后</h4><p>从ActivityThread.handleResumeActivity方法看起<br>1.调用performResumeActivity，执行onResume。<br>2.获取WindowManager的实现类WindowManagerImpl的实例。<br>3.调用WindowManagerImpl.addView传入DecorView和当前布局参数WindowManager.LayoutParams。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p>
<pre><code>@Override
    public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,
            boolean isForward, String reason) &#123;
            ......
        // TODO Push resumeArgs into the activity for consideration
        // skip below steps for double-resume and r.mFinish = true case.
        /*1.执行onResume*/
        if (!performResumeActivity(r, finalStateRequest, reason)) &#123;
            return;
        &#125;
        ......
        //获取Activity实例
        final Activity a = r.activity;
        ......
        // If the window hasn&#39;t yet been added to the window manager,
        // and this guy didn&#39;t finish itself or start another activity,
        // then go ahead and add the window.
        //mStartedActivity在performLaunchActivity和performResumeActivity方法中被置为false
        boolean willBeVisible = !a.mStartedActivity;
        ......
        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;
            //获取当前Activity的PhoneWindow
            r.window = r.activity.getWindow();
            //从PhoneWindow中获取DecorView
            View decor = r.window.getDecorView();
            //将view的可见性状态设置为INVISIBLE,view不可见但是仍然占用布局空间
            decor.setVisibility(View.INVISIBLE);
            /*2.获取WindowManager的实现类WindowManagerImpl的实例*/
            ViewManager wm = a.getWindowManager();
            //获取布局参数
            WindowManager.LayoutParams l = r.window.getAttributes();
            //将phoneWindow的DecorView赋值给mDecor
            a.mDecor = decor;
            //设置窗口类型为TYPE_BASE_APPLICATION
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (r.mPreserveWindow) &#123;
                a.mWindowAdded = true;
                r.mPreserveWindow = false;
                // Normally the ViewRoot sets up callbacks with the Activity
                // in addView-&gt;ViewRootImpl#setView. If we are instead reusing
                // the decor view we have to notify the view root that the
                // callbacks may have changed.
                ViewRootImpl impl = decor.getViewRootImpl();
                if (impl != null) &#123;
                    impl.notifyChildRebuilt();
                &#125;
            &#125;
            if (a.mVisibleFromClient) &#123;
                if (!a.mWindowAdded) &#123;
                    a.mWindowAdded = true;
                    /*3.传入DecorView和当前布局参数WindowManager.LayoutParams*/
                    wm.addView(decor, l);
                &#125; else &#123;
                    // The activity will get a callback for this &#123;@link LayoutParams&#125; change
                    // earlier. However, at that time the decor will not be set (this is set
                    // in this method), so no action will be taken. This call ensures the
                    // callback occurs with the decor set.
                    a.onWindowAttributesChanged(l);
                &#125;
            &#125;
        &#125;
        ......
    &#125;
</code></pre>
<p><code>wm.addView(decor, l);</code>WindowManager接口的实现是WindowManagerImpl，即实际调用的是WindowManagerImpl中的addView方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerImpl.java</p>
<pre><code>    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;
        applyTokens(params);
        //转交给windowManagerGlobal，添加view
        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
                mContext.getUserId());
    &#125;
</code></pre>
<p>WindowManagerImpl对窗口的管理交给WindowManagerGlobal，调用WindowManagerGlobal的addView方法<br>WindowManagerGlobal中对窗口的处理主要如下几个步骤：<br>1.对WindowManagerImpl传进来的参数进行检查。<br>2.设置WindowManager.LayoutParams中的token、title等相关属性。查看“【<strong>1.2 Token的创建与传递</strong>】”。<br>3.创建ViewRootImpl对象，并获取客户端与WMS通信的Session。查看“【<strong>1.3 ViewRootImpl的创建</strong>】”。<br>4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。<br>5.调用ViewRootImpl，与WMS通信添加窗口。查看“【<strong>1.4 ViewRootImpl与WMS的通信</strong>】”。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p>
<pre><code>    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow, int userId) &#123;
        /*1.对WindowManagerImpl传进来的参数进行检查*/
        if (view == null) &#123;
            throw new IllegalArgumentException(&quot;view must not be null&quot;);
        &#125;
        if (display == null) &#123;
            throw new IllegalArgumentException(&quot;display must not be null&quot;);
        &#125;
        if (!(params instanceof WindowManager.LayoutParams)) &#123;
            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);
        &#125;

        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
        //此处的ParentWindow即当Activity的PhoneWindow
        if (parentWindow != null) &#123;
            /*2.为wparams的token进行赋值*/
            parentWindow.adjustLayoutParamsForSubWindow(wparams);
        &#125; else &#123;
            ......
        &#125;

        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) &#123;
            ......
            IWindowSession windowlessSession = null;
            ......
            if (windowlessSession == null) &#123;
                   /*3.新建ViewRootImpl，在新建时会通过WindowManagerGlobal获取session*/
                root = new ViewRootImpl(view.getContext(), display);
            &#125; else &#123;
                root = new ViewRootImpl(view.getContext(), display,
                        windowlessSession);
            &#125;

            view.setLayoutParams(wparams);
            /*4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。*/
            //当前view加入到view列表中
            mViews.add(view);
            //将新建的viewRootImpl加入到root列表中
            mRoots.add(root);
            //将当前布局参数加入到布局参数列表中
            mParams.add(wparams);

            // do this last because it fires off messages to start doing things
            try &#123;
                /*5.调用ViewRootImpl，设置view，panelParentView为null，与WMS通信添加窗口*/
                root.setView(view, wparams, panelParentView, userId);
            &#125; catch (RuntimeException e) &#123;
                // BadTokenException or InvalidDisplayException, clean up.
                if (index &gt;= 0) &#123;
                    removeViewLocked(index, true);
                &#125;
                throw e;
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="1-2-Token的创建与传递"><a href="#1-2-Token的创建与传递" class="headerlink" title="1.2 Token的创建与传递"></a>1.2 Token的创建与传递</h4><p><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>调用Window的adjustLayoutParamsForSubWindow()方法<br>在adjustLayoutParamsForSubWindow中会分别对WindowManager.LayoutParams中的token以及title进行赋值。<br>1.首先针对子窗口、系统窗口以及应用窗口做了不同的处理，此处我们只关注应用窗口的处理。<br>2.其次将当前PhoneWindow.mAppToken赋值给WindowManager.LayoutParams.token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p>
<pre><code>    void adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123;
        CharSequence curTitle = wp.getTitle();
        if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;
                wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;
                //对子窗口的Token以及Title赋值
                ......
        &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp;
                wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;
                //对子窗口的Token以及Title赋值
                ......
        &#125; else &#123;
            //对应用窗口的Token以及Title赋值
            if (wp.token == null) &#123;
                //将当前PhoneWindow的mAppToken赋值给wp.Token
                wp.token = mContainer == null ? mAppToken : mContainer.mAppToken;
            &#125;
            //将Title设置为mAppName
            if ((curTitle == null || curTitle.length() == 0)
                    &amp;&amp; mAppName != null) &#123;
                wp.setTitle(mAppName);
            &#125;
        &#125;
        //设置为packageName 
        if (wp.packageName == null) &#123;
            wp.packageName = mContext.getPackageName();
        &#125;
        ......
    &#125;
</code></pre>
<p>此处的mAppToken便是在Activity启动时，在ATMS端创建的Token。<br>接下来我们看看Token是如何从ATMS端传递过来，并赋值给PhoneWindow.mAppToken的<br><img src="/../../../../../images/e778248cfd7e4dd5a3fa856039013d62.png" alt="在这里插入图片描述"></p>
<p>1.在ATMS端新建ActivityRecord时，便新建了Token。并赋值给ActivityRecord.token<br>ActivityRecord继承WindowToken<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p>
<pre><code> private ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,
            int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage,
            @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType,
            ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,
            String _resultWho, int _reqCode, boolean _componentSpecified,
            boolean _rootVoiceInteraction, ActivityTaskSupervisor supervisor,
            ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState,
            TaskDescription _taskDescription, long _createTime) &#123;
        //新建Token
        super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
                null /* displayContent */, false /* ownerCanManageAppTokens */);
        ......
&#125;
</code></pre>
<p>2.将ActivityRecord.token封装在clientTransaction中，并将这个传递到客户端<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskSupervisor.java</p>
<pre><code>    boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
            boolean andResume, boolean checkConfig) throws RemoteException &#123;
        ......
        final Task task = r.getTask();
        final Task rootTask = task.getRootTask();
        ......

        try &#123;
            ......

            try &#123;
                ......
                // Create activity launch transaction.
                /*将ActivityRecord.token封装在clientTransaction中*/
                final ClientTransaction clientTransaction = ClientTransaction.obtain(
                        proc.getThread(), r.token);

                final boolean isTransitionForward = r.isTransitionForward();
                final IBinder fragmentToken = r.getTaskFragment().getFragmentToken();
                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
                        System.identityHashCode(r), r.info,
                        // TODO: Have this take the merged configuration instead of separate global
                        // and override configs.
                        mergedConfiguration.getGlobalConfiguration(),
                        mergedConfiguration.getOverrideConfiguration(), r.compat,
                        r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor,
                        proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(),
                        results, newIntents, r.takeOptions(), isTransitionForward,
                        proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController,
                        r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken));
                ......

                // Schedule transaction.
                /*将clientTransaction传递给客户端*/
                mService.getLifecycleManager().scheduleTransaction(clientTransaction);
                ......

            &#125; catch (RemoteException e) &#123;
                ......
            &#125;
        &#125; finally &#123;
            ......
        &#125;
        ......
        return true;
    &#125;
</code></pre>
<p><code>final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.token);</code><br>在ClientTransaction中调用obtain方法，把ActivityRecord.token存到mActivityToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;ClientTransaction.java</p>
<pre><code>    /** Obtain an instance initialized with provided params. */
    public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123;
        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);
        if (instance == null) &#123;
        //创建ClientTransaction
            instance = new ClientTransaction();
        &#125;
        instance.mClient = client;
        /*把ActivityRecord.token存到mActivityToken*/
        //private IBinder mActivityToken;
        instance.mActivityToken = activityToken;

        return instance;
    &#125;
</code></pre>
<p>3.客户端从ClientTransaction中获取ATMS端传来的Token，并传递到LaunchActivityItem中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;TransactionExecutor.java</p>
<pre><code>   /** Cycle through all states requested by callbacks and execute them at proper times. */
    @VisibleForTesting
    public void executeCallbacks(ClientTransaction transaction) &#123;
        final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();
        ......
        /*从ClientTransaction中获取ATMS端传来的Token*/
        final IBinder token = transaction.getActivityToken();
        ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
        ......

        final int size = callbacks.size();
        for (int i = 0; i &lt; size; ++i) &#123;
            final ClientTransactionItem item = callbacks.get(i);
            ......
            /*将Token传递到LaunchActivityItem中*/
            item.execute(mTransactionHandler, token, mPendingActions);
            item.postExecute(mTransactionHandler, token, mPendingActions);
            ......
        &#125;
    &#125;
</code></pre>
<p>4.在LaunchActivityItem中将客户端传过来的Token保存在ActivityClientRecord.token中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;LaunchActivityItem.java</p>
<pre><code>    @Override
    public void execute(ClientTransactionHandler client, IBinder token,
            PendingTransactionActions pendingActions) &#123;
        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
        //将客户端传过来的Token保存在ActivityClientRecord的token中
        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,
                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,
                mPendingResults, mPendingNewIntents, mActivityOptions, mIsForward, mProfilerInfo,
                client, mAssistToken, mShareableActivityToken, mLaunchedFromBubble,
                mTaskFragmentToken);
        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);
        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
    &#125;
</code></pre>
<p><code>client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</code>ClientTransactionHandler调用handleLaunchActivity方法，ClientTransactionHandler为抽象类，其子类为ActivityThread，即实际调用的是该类中的handleLaunchActivity()，有从该方法中调用到了performLaunchActivity()<br>5.客户端ActivityThread将ActivityClientRecord以及其对应的token保存在ActivityThread.mActivities数组中，并调用Activity.attach将Token传给Activity。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p>
<pre><code>    /**  Core implementation of activity launch. */
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;
        ......
        try &#123;
            Application app = r.packageInfo.makeApplicationInner(false, mInstrumentation);
            ......
            synchronized (mResourcesManager) &#123;
                /*将ActivityClientRecord以及其对应的Token保存在mActivities中*/
                //mActivities的类型为ArrayMap&lt;IBinder, ActivityClientRecord&gt;
                mActivities.put(r.token, r);
            &#125;

            if (activity != null) &#123;
                ......
                /*将Token赋值给Activity.mToken*/
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.activityConfigCallback,
                        r.assistToken, r.shareableActivityToken);
                ......

        &#125; catch (SuperNotCalledException e) &#123;
            throw e;

        &#125; catch (Exception e) &#123;
            ......
        &#125;

        return activity;
    &#125;
</code></pre>
<p>6.在Activity中将客户端传来的Token赋值给Activity.mToken。此外在该方法中还新建了PhoneWindow,并将PhoneWindow.mAppToken也设置为客户端传过来的Token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Activity.java</p>
<pre><code>    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,
            IBinder shareableActivityToken) &#123;
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);
        /*新建PhoneWindow*/
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        ......
        /*将客户端传过来的Token赋值给mToken*/
        mToken = token;
        ......
        /*PhoneWindow.mAppToken设置为当前客户端传递过来的Token*/
        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        ......
    &#125;
</code></pre>
<p>PhoneWindow继承Window，setWindowManager实际调用的是其父类方法，把mAppToken设置为当前客户端传递过来的mToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p>
<pre><code>    /**
     * Set the window manager for use by this Window to, for example,
     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the
     * Window itself -- that must be done by the client.
     *
     * @param wm The window manager for adding new windows.
     */
    public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123;
        //传递客户端的mToken给appToken
        setWindowManager(wm, appToken, appName, false);
    &#125;

    /**
     * Set the window manager for use by this Window to, for example,
     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the
     * Window itself -- that must be done by the client.
     *
     * @param wm The window manager for adding new windows.
     */
    public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) &#123;
        /*把appToken赋值给mAppToken*/
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated;
        if (wm == null) &#123;
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        &#125;
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    &#125;
</code></pre>
<h4 id="1-3-ViewRootImpl的创建"><a href="#1-3-ViewRootImpl的创建" class="headerlink" title="1.3 ViewRootImpl的创建"></a>1.3 ViewRootImpl的创建</h4><p><code>root = new ViewRootImpl(view.getContext(), display);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用创建ViewRootImpl，这里我们看下ViewRootImpl的构造方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</p>
<pre><code>    public ViewRootImpl(Context context, Display display) &#123;
        this(context, display, WindowManagerGlobal.getWindowSession(),
                false /* useSfChoreographer */);
    &#125;

    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) &#123;
        this(context, display, session, false /* useSfChoreographer */);
    &#125;

    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
            boolean useSfChoreographer) &#123;
        mContext = context;
        mWindowSession = session;
        ......
    &#125;
</code></pre>
<p>从这个构造方法中我们可以看出，通过WindowManagerGlobal.getWindowSession获取到客户端与WMS沟通的桥梁IWindowSession，并将其赋值给ViewRootImpl.mWindowSession。</p>
<p>下面我们查看WindowManagerGlobal中是如何获取Session的。<br>1.通过getWindowManagerService获取IWindowManager，而WindowManagerService则实现了这个Binder接口。<br>2.调用IWindowManager.openSession方法即WMS.openSession，在WMS端便会新建Session。至此客户端与WMS通信的桥梁便已经搭建好了<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p>
<pre><code>    @UnsupportedAppUsage
    public static IWindowSession getWindowSession() &#123;
        synchronized (WindowManagerGlobal.class) &#123;
            if (sWindowSession == null) &#123;
                try &#123;
                    // Emulate the legacy behavior.  The global instance of InputMethodManager
                    // was instantiated here.
                    // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage
                    InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();
                    /*1.获取Binder*/
                    IWindowManager windowManager = getWindowManagerService();
                    /*2.调用WMS的openSession*/
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() &#123;
                                @Override
                                public void onAnimatorScaleChanged(float scale) &#123;
                                    ValueAnimator.setDurationScale(scale);
                                &#125;
                            &#125;);
                &#125; catch (RemoteException e) &#123;
                    throw e.rethrowFromSystemServer();
                &#125;
            &#125;
            return sWindowSession;
        &#125;
    &#125;
</code></pre>
<p>从代码中可以看出如果sWindowSession不为空则直接返回，sWindowSession为当前WindowManagerGlobal属性，且WindowManagerGloba又是单例的，所以客户端一个进程中只有一个IWindowSession与WMS通信。如果sWindowSession为空，则会创建IWindowSession。</p>
<p>调用WindowManagerService中的openSession，新建Session<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    @Override
    public IWindowSession openSession(IWindowSessionCallback callback) &#123;
        /*新建Session*/
        return new Session(this, callback);
    &#125;
</code></pre>
<h4 id="1-4-ViewRootImpl与WMS的通信"><a href="#1-4-ViewRootImpl与WMS的通信" class="headerlink" title="1.4 ViewRootImpl与WMS的通信"></a>1.4 ViewRootImpl与WMS的通信</h4><p><code>root.setView(view, wparams, panelParentView, userId);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用ViewRootImpl与WMS的通信，继续看看<br>当前方法是与WMS进行通信添加窗口的入口，在此处我们只关注两点:<br>1.requestLayout()该方法会调用到doTraversal()，之后调用performTraversals()，最终调用到relayoutWindow()和reportDrawFinished()流程，在通过Session与服务端通信<br>2.mWindowSession.addToDisplayAsUser，与服务端进行Binder通信，调用Session的addToDisplayAsUser方法。</p>
<pre><code>   /**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;
        setView(view, attrs, panelParentView, UserHandle.myUserId());
    &#125;

    /**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
            int userId) &#123;
        synchronized (this) &#123;
            if (mView == null) &#123;
                mView = view;
                ......
                //将布局参数拷贝纸mWindowAttributes
                mWindowAttributes.copyFrom(attrs);
                //设置包名
                if (mWindowAttributes.packageName == null) &#123;
                    mWindowAttributes.packageName = mBasePackageName;
                &#125;
                mWindowAttributes.privateFlags |=
                        WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;

                attrs = mWindowAttributes;
                ......
                // Keep track of the actual window flags supplied by the client.
                //获取当前布局的flags
                mClientWindowLayoutFlags = attrs.flags;
                ......
                int res; /* = WindowManagerImpl.ADD_OKAY; */

                // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                /*请求布局，对应服务端layoutWindow流程*/
                requestLayout();
                InputChannel inputChannel = null;
                if ((mWindowAttributes.inputFeatures
                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;
                    inputChannel = new InputChannel();
                &#125;
                ......

                try &#123;
                    ......
                    /*与服务端进行Binder通信，调用Session的addToDisplayAsUser方法*/
                    //执行addWindow的相关流程
                    res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(), userId,
                            mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                            mTempControls);
                    ......
                &#125; catch (RemoteException e) &#123;
                    ......
                &#125; finally &#123;
                    if (restore) &#123;
                        attrs.restore();
                    &#125;
                &#125;
                ......
                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow);
                if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;
                    mAttachInfo.mRootView = null;
                    mAdded = false;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    switch (res) &#123;
                        case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                        case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- token &quot; + attrs.token
                                    + &quot; is not valid; is your activity running?&quot;);
                        case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- token &quot; + attrs.token
                                    + &quot; is not for an application&quot;);
                        case WindowManagerGlobal.ADD_APP_EXITING:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- app for token &quot; + attrs.token
                                    + &quot; is exiting&quot;);
                        case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- window &quot; + mWindow
                                    + &quot; has already been added&quot;);
                        case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                            // Silently ignore -- we would have just removed it
                            // right away, anyway.
                            return;
                        case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- another window of type &quot;
                                    + mWindowAttributes.type + &quot; already exists&quot;);
                        case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- permission denied for window type &quot;
                                    + mWindowAttributes.type);
                        case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- the specified display can not be found&quot;);
                        case WindowManagerGlobal.ADD_INVALID_TYPE:
                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- the specified window type &quot;
                                    + mWindowAttributes.type + &quot; is not valid&quot;);
                        case WindowManagerGlobal.ADD_INVALID_USER:
                            throw new WindowManager.BadTokenException(&quot;Unable to add Window &quot;
                                    + mWindow + &quot; -- requested userId is not valid&quot;);
                    &#125;
                    throw new RuntimeException(
                            &quot;Unable to add window -- unknown error code &quot; + res);
                &#125;
                ......
            &#125;
        &#125;
    &#125;
</code></pre>
<p>其中关键的添加代码为</p>
<pre><code>res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
        getHostVisibility(), mDisplay.getDisplayId(), userId,
        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
        mTempControls);
</code></pre>
<p><code>addToDisplayAsUser()</code>方法最终会走到WindowManagerService.java的addWindow方法，addWindow方法的返回值最后会返回给<code>res</code>，之后回看ViewRootImpl的setView方法，返回值如果满足<code>if (res &lt; WindowManagerGlobal.ADD_OKAY)</code>条件，那么会根据<code>switch (res)</code>中对应的case抛出异常。<br>至此，客户端流程结束，后面进入服务端流程。</p>
<h3 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h3><h4 id="2-1-窗口添加"><a href="#2-1-窗口添加" class="headerlink" title="2.1 窗口添加"></a>2.1 窗口添加</h4><p>WMS通过Session接受客户端添加窗口的请求，因此WMS会新建WindowState、将WindowState加入到WindowToken，并更新WindowToken下所有WindowState的z-order。<br>客户端通过Binder通信调用WMS端的Session.addToDisplayAsUser进入addWindow的流程。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.WindowState初始化<br>3.WindowState加入到WIndowToken</p>
<h5 id="2-1-1-接收客户端请求"><a href="#2-1-1-接收客户端请求" class="headerlink" title="2.1.1 接收客户端请求"></a>2.1.1 接收客户端请求</h5><p>客户端传递给Session的参数<br>IWindow window:是WMS与客户端通信的句柄。<br>WindowManager.LayoutParams arrts：窗口布局参数。<br>viewVisibility：附着在窗口的rootView的可见性。<br>displayId：顾名思义，display id表示的是DisplayContent即屏幕的id。<br>InsetsVisibilities requestedVisibilities:当前对象的mVisibilities记录了insets的可见性。<br>InputChannel outInputChannel：InputDispatcher接收InputReader读取到的事件，分发给对应窗口，InputDispatcher属于system_server进程和各个应用不在同一进程，它们之间的联系靠的就是InputChannel。<br>InsetsState outInsetsState：用来保存系统中所有Insets的状态，该对象只是在客户端创建，内部属性需要在WMS端赋值。<br>InsetsSourceControl[] outActiveControls：InSetsSourceControl数组。该对象也是只在客户端创建，内部属性需要在WMS端赋值。<br>Session调用<strong>WindowManagerService.addWindow</strong> 将客户端传入的参数传递给WindowManagerService。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public int addToDisplayAsUser(IWindow window, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, int userId, InsetsVisibilities requestedVisibilities,
            InputChannel outInputChannel, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls) &#123;
        return mService.addWindow(this, window, attrs, viewVisibility, displayId, userId,
                requestedVisibilities, outInputChannel, outInsetsState, outActiveControls);
    &#125;
</code></pre>
<h5 id="2-1-2-addWindow"><a href="#2-1-2-addWindow" class="headerlink" title="2.1.2 addWindow"></a>2.1.2 addWindow</h5><p>添加窗口的主要逻辑均在WMS.addWindow执行，该方法主要实现以下功能：<br>1.首先进行权限验证以及各种条件判断。<br>2.根据客户端传来的token获取windowToken。<br>3.借助客户端传来的参数，创建WindowState实例，并将其加入到WMS. mWindowMap中。<br>4.将新建的WindowState加入到相应的WindowToken，并为每个窗口赋值一个z-order。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility,
            int displayId, int requestUserId, InsetsVisibilities requestedVisibilities,
            InputChannel outInputChannel, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls) &#123;
        ......
        
        /*1.进行权限验证以及各种条件判断*/
        //判断调用者是否有权限add window
        int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,
                appOp);
        if (res != ADD_OKAY) &#123;
            return res;
        &#125;

        WindowState parentWindow = null;
        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();
        //获取将要添加的窗口类型
        final int type = attrs.type;

        synchronized (mGlobalLock) &#123;
            ......
            //根据displayId以及客户端传过来的token获取相应的displayContent
            final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
            ......
            //判断mWindowMap中是否已经存在当前客户端的key,如果有则已经将当前客户端的window添加了，无需重复添加
            if (mWindowMap.containsKey(client.asBinder())) &#123;
                ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client);
                return WindowManagerGlobal.ADD_DUPLICATE_ADD;
            &#125;
            //判断是否是子窗口
            if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;
                parentWindow = windowForClientLocked(null, attrs.token, false);
                if (parentWindow == null) &#123;
                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is not a window: &quot;
                            + &quot;%s.  Aborting.&quot;, attrs.token);
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                &#125;
                if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW
                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;
                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is a sub-window: &quot;
                            + &quot;%s.  Aborting.&quot;, attrs.token);
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                &#125;
            &#125;
            //判断当前DisplayContent是否是私有的，只拥有该display或者display已经的应用才可以在其上创建
            if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) &#123;
                ProtoLog.w(WM_ERROR,
                        &quot;Attempted to add private presentation window to a non-private display.  &quot;
                                + &quot;Aborting.&quot;);
                return WindowManagerGlobal.ADD_PERMISSION_DENIED;
            &#125;
            ......
            ActivityRecord activity = null;
            //设置是否有父窗口的标志位
            final boolean hasParent = parentWindow != null;
            // Use existing parent window token for child windows since they go in the same token
            // as there parent window so we can apply the same policy on them.
           
             /*2.根据客户端传来的token获取windowToken*/
            //attrs.token去DisplayContent.mTokenMap中去取WindowToken
            //那么WindowToken是什么时候加入到mTokenMap中的呢
            	//这就要追溯到Activity的启动时，加入到DisplayContent中
            //在ActivityStarter.startActivityInner中调用addOrReparentStartingActivity通过addChild一步步调用到WindowContainert中。
            //在调用setParent,最终通过onDisplayChanged将ActivityRecord加入到DisplayContent.mTokenMap中
            WindowToken token = displayContent.getWindowToken(
                    hasParent ? parentWindow.mAttrs.token : attrs.token);
            // If this is a child window, we want to apply the same type checking rules as the
            // parent window type.
            final int rootType = hasParent ? parentWindow.mAttrs.type : type;

            boolean addToastWindowRequiresToken = false;

            final IBinder windowContextToken = attrs.mWindowContextToken;

            if (token == null) &#123;
            ......
             &#125;else if (rootType &gt;= FIRST_APPLICATION_WINDOW
                    &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;
                //当前窗口为应用窗口，通过token，获取ActivityRecord
                activity = token.asActivityRecord();
            ......
            &#125; else if (token.asActivityRecord() != null) &#123;
                ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;,
                        rootType);
                // It is not valid to use an app token with other system types; we will
                // instead make a new token for it (as if null had been passed in for the token).
                attrs.token = null;
                token = new WindowToken.Builder(this, client.asBinder(), type)
                        .setDisplayContent(displayContent)
                        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)
                        .build();
            &#125;
            /*3.创建WindowState*/
            final WindowState win = new WindowState(this, session, client, token, parentWindow,
                    appOp[0], attrs, viewVisibility, session.mUid, userId,
                    session.mCanAddInternalSystemWindow);
            //将客户端传过来的Insets可见性赋值给WindowState的requestedVisibilities
            win.setRequestedVisibilities(requestedVisibilities);
            //验证当前窗口是否可以添加到WMS
            res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);
            if (res != ADD_OKAY) &#123;
                return res;
            &#125;
            //调用openInputChannel，初始化input相关通路
            final boolean openInputChannels = (outInputChannel != null
                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);
            if  (openInputChannels) &#123;
                win.openInputChannel(outInputChannel);
            &#125;
            //创建SufaceSession用于SurfaceFlinger通信
            win.attach();
            //将客户端与WindowState加入到mWindowMap中
            mWindowMap.put(client.asBinder(), win);
            win.initAppOpsState();
            ......
            /*4.将WindowState加入到WindowToken*/
            win.mToken.addWindow(win);
            ......
        return res;
    &#125;
</code></pre>
<p><strong>mWindowMap保存了每个WindowState和客户端窗口的映射关系，客户端应用请求窗口操作时，通过mWindowMap查询到对应的WindowState</strong></p>
<h5 id="2-1-3-WindowToken的创建"><a href="#2-1-3-WindowToken的创建" class="headerlink" title="2.1.3 WindowToken的创建"></a>2.1.3 WindowToken的创建</h5><pre><code>token = new WindowToken.Builder(this, client.asBinder(), type)
        .setDisplayContent(displayContent)
        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)
        .build();
</code></pre>
<p>这里调用的是其WindowToken自身的build方法创建<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p>
<pre><code>WindowToken build() &#123;
    return new WindowToken(mService, mToken, mType, mPersistOnEmpty, mDisplayContent,
            mOwnerCanManageAppTokens, mRoundedCornerOverlay, mFromClientToken, mOptions);
&#125;

protected WindowToken(WindowManagerService service, IBinder _token, int type,
        boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens,
        boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123;
    super(service);
    token = _token;
    windowType = type;
    mOptions = options;
    mPersistOnEmpty = persistOnEmpty;
    mOwnerCanManageAppTokens = ownerCanManageAppTokens;
    mRoundedCornerOverlay = roundedCornerOverlay;
    mFromClientToken = fromClientToken;
    if (dc != null) &#123;
        dc.addWindowToken(token, this);
    &#125;
&#125;
</code></pre>
<p><code>dc.addWindowToken(token, this);</code>在WindowToken构造方法中，调用DisplayContent.addWindowToken将WindowToken添加到以DisplayContent为根节点的WindowContainer层级结构中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    void addWindowToken(IBinder binder, WindowToken token) &#123;
        final DisplayContent dc = mWmService.mRoot.getWindowTokenDisplay(token);
        if (dc != null) &#123;
            // We currently don&#39;t support adding a window token to the display if the display
            // already has the binder mapped to another token. If there is a use case for supporting
            // this moving forward we will either need to merge the WindowTokens some how or have
            // the binder map to a list of window tokens.
            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;
                    + getName() + &quot; already mapped to display=&quot; + dc + &quot; tokens=&quot; + dc.mTokenMap);
        &#125;
        if (binder == null) &#123;
            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;
                    + getName() + &quot; binder is null&quot;);
        &#125;
        if (token == null) &#123;
            throw new IllegalArgumentException(&quot;Can&#39;t map null token to display=&quot;
                    + getName() + &quot; binder=&quot; + binder);
        &#125;

        mTokenMap.put(binder, token);

        if (token.asActivityRecord() == null) &#123;
            // Set displayContent for non-app token to prevent same token will add twice after
            // onDisplayChanged.
            // TODO: Check if it&#39;s fine that super.onDisplayChanged of WindowToken
            //  (WindowsContainer#onDisplayChanged) may skipped when token.mDisplayContent assigned.
            token.mDisplayContent = this;
            // Add non-app token to container hierarchy on the display. App tokens are added through
            // the parent container managing them (e.g. Tasks).
            //1.调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。
            final DisplayArea.Tokens da = findAreaForToken(token).asTokens();
            //2.将WindowToken添加到父容器中。
            da.addChild(token);
        &#125;
    &#125;
</code></pre>
<p>这里我们分两步看<br>1.<code>final DisplayArea.Tokens da = findAreaForToken(token).asTokens();</code>调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。</p>
<pre><code>    /**
     * Finds the &#123;@link DisplayArea&#125; for the &#123;@link WindowToken&#125; to attach to.
     * &lt;p&gt;
     * Note that the differences between this API and
     * &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; is that this API finds a
     * &#123;@link DisplayArea&#125; in &#123;@link DisplayContent&#125; level, which may find a &#123;@link DisplayArea&#125;
     * from multiple &#123;@link RootDisplayArea RootDisplayAreas&#125; under this &#123;@link DisplayContent&#125;&#39;s
     * hierarchy, while &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; finds a
     * &#123;@link DisplayArea.Tokens&#125; from a &#123;@link DisplayArea.Tokens&#125; list mapped to window layers.
     * &lt;/p&gt;
     *
     * @see DisplayContent#findAreaForTokenInLayer(WindowToken)
     */
    DisplayArea findAreaForToken(WindowToken windowToken) &#123;
        return findAreaForWindowType(windowToken.getWindowType(), windowToken.mOptions,
                windowToken.mOwnerCanManageAppTokens, windowToken.mRoundedCornerOverlay);
    &#125;
</code></pre>
<p>​    </p>
<p>为传入的WindowToken找到一个DisplayArea对象来添加进去。</p>
<pre><code>    DisplayArea findAreaForWindowType(int windowType, Bundle options,
            boolean ownerCanManageAppToken, boolean roundedCornerOverlay) &#123;
        // TODO(b/159767464): figure out how to find an appropriate TDA.
        //1.如果是App窗口，那么返回默认的TaskDisplayArea对象。
        if (windowType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; windowType &lt;= LAST_APPLICATION_WINDOW) &#123;
            return getDefaultTaskDisplayArea();
        &#125;

        // Return IME container here because it could be in one of sub RootDisplayAreas depending on
        // the focused edit text. Also, the RootDisplayArea choosing strategy is implemented by
        // the server side, but not mSelectRootForWindowFunc customized by OEM.
        //2.如果是输入法窗口，那么返回ImeContainer。
        if (windowType == TYPE_INPUT_METHOD || windowType == TYPE_INPUT_METHOD_DIALOG) &#123;
            return getImeContainer();
        &#125;
        //3.如果是其他类型，继续寻找。
        return mDisplayAreaPolicy.findAreaForWindowType(windowType, options,
                ownerCanManageAppToken, roundedCornerOverlay);
    &#125;
</code></pre>
<p>如果是App窗口，那么返回默认的TaskDisplayArea对象。<br>如果是输入法窗口，那么返回ImeContainer。<br>如果是其他类型，继续寻找。<br><code>mDisplayAreaPolicy.findAreaForWindowType(windowType, options, ownerCanManageAppToken, roundedCornerOverlay);</code>调用的是DisplayAreaPolicy中的findAreaForWindowType方法，DisplayAreaPolicy为抽象类,DisplayAreaPolicyBuilder中的Result继承了该类<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>static class Result extends DisplayAreaPolicy &#123;
    ......
       @Override
       public DisplayArea.Tokens findAreaForWindowType(int type, Bundle options,
               boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123;
           return mSelectRootForWindowFunc.apply(type, options).findAreaForWindowTypeInLayer(type,
                   ownerCanManageAppTokens, roundedCornerOverlay);
       &#125;
       ......
</code></pre>
<p>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootDisplayArea.java</p>
<pre><code>  DisplayArea.Tokens findAreaForWindowTypeInLayer(int windowType, boolean ownerCanManageAppTokens,
           boolean roundedCornerOverlay) &#123;
       //通过getWindowLayerFromTypeLw方法获取对应的窗口类型
       int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,
               ownerCanManageAppTokens, roundedCornerOverlay);
       if (windowLayerFromType == APPLICATION_LAYER) &#123;
           throw new IllegalArgumentException(
                   &quot;There shouldn&#39;t be WindowToken on APPLICATION_LAYER&quot;);
       &#125;
       return mAreaForLayer[windowLayerFromType];
   &#125;
</code></pre>
<p>通过getWindowLayerFromTypeLw方法计算出该窗口的类型对应的层级值windowLayerFromType，然后从mAreaForLayer数组中，找到windowLayerFromType对应的那个DisplayArea.Tokens对象。<br>2. <code>da.addChild(token);</code>将WindowToken添加到父容器（叶子节点）中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayArea.java</p>
<pre><code>    /**
     * DisplayArea that contains WindowTokens, and orders them according to their type.
     */
    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;
        ......
        void addChild(WindowToken token) &#123;
            addChild(token, mWindowComparator);
        &#125;
        ......
</code></pre>
<p><code>addChild(token, mWindowComparator);</code>最终调用到WindowContainer.addChild方法添加WindowToken到叶子节点</p>
<h5 id="2-1-4-WindowState初始化"><a href="#2-1-4-WindowState初始化" class="headerlink" title="2.1.4 WindowState初始化"></a>2.1.4 WindowState初始化</h5><p>在addWindow中初始化WindowState</p>
<pre><code>final WindowState win = new WindowState(this, session, client, token, parentWindow,
        appOp[0], attrs, viewVisibility, session.mUid, userId,
        session.mCanAddInternalSystemWindow);
</code></pre>
<p>下面我们看一下在WindowState的实例化过程中，都做了什么。<br>1.根据客户端传过来的参数，对相关属性进行赋值。<br>2.根据当前窗口的类型获取mBaseLayer,当将WindowState加入到WindowToken时，该值用来确定加入窗口在WindowToken数组中的位置。<br>3.实例化WindowStateAnimator，该类会跟踪当前WIndowState的动画以及surface操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,
            WindowState parentWindow, int appOp, WindowManager.LayoutParams a, int viewVisibility,
            int ownerId, int showUserId, boolean ownerCanAddInternalSystemWindow,
            PowerManagerWrapper powerManagerWrapper) &#123;
        /*1.根据客户端传递过来的参数，对相关属性进行赋值*/
        //调用WindowState的父类WindowContainer构造方法，将WMS赋值给其父类属性mWmService
        super(service);
        //获取事务
        mTmpTransaction = service.mTransactionFactory.get();
        //将Session赋值给mSession
        mSession = s;
        //将与客户端通信的Binder赋值给mClient
        mClient = c;
        mAppOp = appOp;
        //将当前activity的token赋值给mToken
        mToken = token;
        //通过token，获取当前窗口对的ActivityRecord
        mActivityRecord = mToken.asActivityRecord();
        //赋值id
        mOwnerUid = ownerId;
        mShowUserId = showUserId;
        //是否可以添加系统窗口的标志位
        mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;
        mWindowId = new WindowId(this);
        //布局参数赋值给mAttrs
        mAttrs.copyFrom(a);
        //将surfaceInsets赋值给mLastSurfaceInsets
        mLastSurfaceInsets.set(mAttrs.surfaceInsets);
        //将窗口可见性赋值给mViewVisibility 
        mViewVisibility = viewVisibility;
        //将窗口WindowManagerPolicy赋值给mPolicy 
        mPolicy = mWmService.mPolicy;
        mContext = mWmService.mContext;
        ......
        /*2.获取当前窗口的BaseLayer*/
        if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;
            ......
        &#125; else &#123;
            // The multiplier here is to reserve space for multiple
            // windows in the same type layer.
            //当前为应用窗口所以mPolicy.getWindowLayerLw(this)获取值为2，即应用层级
            //TYPE_LAYER_MULTIPLIER为同一类型的多窗口保留空间
            //TYPE_LAYER_OFFSET将同一组窗口移动到同一层中其他窗口的上方或者下方
            mBaseLayer = mPolicy.getWindowLayerLw(this)
                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
            mSubLayer = 0;
            mIsChildWindow = false;
            mLayoutAttached = false;
            mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD
                    || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;
            mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;
        &#125;
        ......
        /*3.新建windowStateAnimator，该类会跟踪当前WindowState的动画以及surface操作*/
        mWinAnimator = new WindowStateAnimator(this);
        //将透明度alpha赋值给mAlpha 
        mWinAnimator.mAlpha = a.alpha;
        ......
    &#125;
</code></pre>
<h5 id="2-1-5-将WindowState加入到WindowToken"><a href="#2-1-5-将WindowState加入到WindowToken" class="headerlink" title="2.1.5 将WindowState加入到WindowToken"></a>2.1.5 将WindowState加入到WindowToken</h5><p>在addWindow中将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WindowState加入到WindowToken中的具体过程：<br>1.将要加入的WindowState.mBaseLayer与WindowToken中现有的WindowState.mBaseLayer相比，按照mBaseLayer有小到大存放到数组中，若mBaseLayer相等，则后加入的WindowState放在数组后面。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p>
<pre><code> void addWindow(final WindowState win) &#123;
        ProtoLog.d(WM_DEBUG_FOCUS,
                &quot;addWindow: win=%s Callers=%s&quot;, win, Debug.getCallers(5));

        if (win.isChildWindow()) &#123;
            // Child windows are added to their parent windows.
            //如果是子窗口直接返回
            return;
        &#125;
        // This token is created from WindowContext and the client requests to addView now, create a
        // surface for this token.
        if (mSurfaceControl == null) &#123;
            createSurfaceControl(true /* force */);

            // Layers could have been assigned before the surface was created, update them again
            reassignLayer(getSyncTransaction());
        &#125;
        if (!mChildren.contains(win)) &#123;
            ProtoLog.v(WM_DEBUG_ADD_REMOVE, &quot;Adding %s to %s&quot;, win, this);
            //调用WindowContainer.addChild方法
            addChild(win, mWindowComparator);
            mWmService.mWindowsChanged = true;
            // TODO: Should we also be setting layout needed here and other places?
        &#125;
    &#125;
 /**
   * Compares two child window of this token and returns -1 if the first is lesser than the
   * second in terms of z-order and 1 otherwise.
   */
  private final Comparator&lt;WindowState&gt; mWindowComparator =
          (WindowState newWindow, WindowState existingWindow) -&gt; &#123;
      final WindowToken token = WindowToken.this;
      ......
      //如果新窗口的mBaseLayer 不小于（大于等于）已经存在的WindowState的BaseLayer，则返回1，否则返回-1
      return isFirstChildWindowGreaterThanSecond(newWindow, existingWindow) ? 1 : -1;
  &#125;;
    /**
     * Returns true if the new window is considered greater than the existing window in terms of
     * z-order.
     */
    protected boolean isFirstChildWindowGreaterThanSecond(WindowState newWindow,
            WindowState existingWindow) &#123;
        // New window is considered greater if it has a higher or equal base layer.
        //此处可以发现比较的是两个窗口的mBaseLayer
        return newWindow.mBaseLayer &gt;= existingWindow.mBaseLayer;
    &#125;
</code></pre>
<p>我们看看WindowContainer.addChild方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>   /**
     * Adds the input window container has a child of this container in order based on the input
     * comparator.
     * @param child The window container to add as a child of this window container.
     * @param comparator Comparator to use in determining the position the child should be added to.
     *                   If null, the child will be added to the top.
     */
    @CallSuper
    protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123;
        ......
        //记录插入数组的位置，若为-1则将windowState加入到后面
        int positionToAdd = -1;
        if (comparator != null) &#123;
            //判断当前WindowToken中WindowState的数量
            //依次比较将要加入的窗口与已经存在的WindowState的BaseLayer
            //mChildren越大放到数组最前面WindowToken
            final int count = mChildren.size();
            for (int i = 0; i &lt; count; i++) &#123;
                //比较baseLayer，如果child大于列表中已经存在的，则需要返回1，否则返回-1
                //新加入的的child大于mChildren.get(i)则返回1，小于则返回-1
                //注：comparator比较器的逻辑见上面代码的mWindowComparator 
                if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123;
                    //记录当前要插入的位置
                    positionToAdd = i;
                    break;
                &#125;
            &#125;
        &#125;
        //如果新加入的窗口大于现在所有窗口
        if (positionToAdd == -1) &#123;
            //将该窗口加入到列表最后
            mChildren.add(child);
        &#125; else &#123;
            mChildren.add(positionToAdd, child);
        &#125;

        // Set the parent after we&#39;ve actually added a child in case a subclass depends on this.
        //此处将child的mParent设置为this
        child.setParent(this);
    &#125;
</code></pre>
<p>2.将WindowState的mParent置为刚才的WindowToken，并更新其Parent的mTreeWeight。mTreeWeight记录了其子节点的数量。<br>继续查看WindowState的父类WindowContainer.setParent</p>
<pre><code>    final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123;
        //将当前WindowState的mParent设置为相应的WindowToken
        final WindowContainer oldParent = mParent;
        mParent = parent;

        if (mParent != null) &#123;
            //更新parent中的mTreeWeight属性
            //mTreeWeight代表以parent的根节点的子树中的元素的数量
            mParent.onChildAdded(this);
        &#125; else if (mSurfaceAnimator.hasLeash()) &#123;
            mSurfaceAnimator.cancelAnimation();
        &#125;
        if (!mReparenting) &#123;
            onSyncReparent(oldParent, mParent);
            if (mParent != null &amp;&amp; mParent.mDisplayContent != null
                    &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;
                onDisplayChanged(mParent.mDisplayContent);
            &#125;
            //计算显示layer
            onParentChanged(mParent, oldParent);
        &#125;
    &#125;
</code></pre>
<p>3.将WindowState加入到WindowToken之后，调用parent的assignChildLayers方法，调整其所有child的z-order。主要经历以下步骤：<br>初始化layer&#x3D;0，代表着z-order。<br>遍历mChildren数组，判断Children是否需要提高到顶部（判断标志位mNeedsZBoost）。如果不需要则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果需要则执行下一遍循环。<br>再次遍历mChildren数组，判断Children是否需要提高到顶部。如果需要则则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果不需要则执行下一次循环。<br>注：<strong>Z-order</strong>也被称为深度顺序（depth order）或Z轴顺序，它用于确定图层（Layers）在屏幕上的堆叠顺序。简单来说，<strong>Z-order</strong>就是图层在Z轴上的位置，Z轴位置越低，图层越在底层，Z轴位置越高，图层越在顶层。<br>继续看onParentChanged方法</p>
<pre><code>/**
     * Callback that is triggered when @link WindowContainer#setParent(WindowContainer)&#125; was called.
     * Supposed to be overridden and contain actions that should be executed after parent was set.
     */
    @Override
    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123;
        onParentChanged(newParent, oldParent, null);
    &#125;

    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent,
            PreAssignChildLayersCallback callback) &#123;
        ......
        if (mSurfaceControl == null) &#123;
            // If we don&#39;t yet have a surface, but we now have a parent, we should
            // build a surface.
            //创建一个SurfaceControl来调整窗口的z-order
            createSurfaceControl(false /*force*/);
        &#125; else &#123;
               ......
        &#125;
        ......
        // Either way we need to ask the parent to assign us a Z-order.
        //进入WindowToken的父类WindowContainer中，调整窗口的z-order
        mParent.assignChildLayers();
        scheduleAnimation();
    &#125;
    
    void assignChildLayers() &#123;
        assignChildLayers(getSyncTransaction());
        scheduleAnimation();
    &#125;
    
    void assignChildLayers(Transaction t) &#123;
    //分配给当前窗口的z-order，初始化为0
        int layer = 0;

        // We use two passes as a way to promote children which
        // need Z-boosting to the end of the list.
        //此处会以parent为根节点向下遍历到子节点，再从下到上依次进行处理
        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;
            final WindowContainer wc = mChildren.get(j);
            wc.assignChildLayers(t);
            //needsZBoot是用来判断当前窗口是否应该提升到容器的顶部
            //若不需要提升到容器的顶部
            if (!wc.needsZBoost()) &#123;
                //调用WindowState的父类WindowContainer中的assignLayer
                wc.assignLayer(t, layer++);
            &#125;
        &#125;
        //处理需要提升到容器顶部的窗口
        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;
            final WindowContainer wc = mChildren.get(j);
            if (wc.needsZBoost()) &#123;
                wc.assignLayer(t, layer++);
            &#125;
        &#125;
        if (mOverlayHost != null) &#123;
            mOverlayHost.setLayer(t, layer++);
        &#125;
    &#125;
</code></pre>
<p>4.在Children的assignLayer中会首先判断此次要调整的layer与自己上次layer是否相等，不相等则最终会调用nativeSetLayer来调整自己的z-order。</p>
<pre><code>    void assignLayer(Transaction t, int layer) &#123;
        // Don&#39;t assign layers while a transition animation is playing
        // TODO(b/173528115): establish robust best-practices around z-order fighting.
        //如果正在执行Transaction，则不需要进行assignLayer
        if (mTransitionController.isPlaying()) return;
        //layer为此次要调整的z-order
        final boolean changed = layer != mLastLayer || mLastRelativeToLayer != null;
        //如果需要调整
        if (mSurfaceControl != null &amp;&amp; changed) &#123;
            //调用setLayer调整窗口的z-order
            setLayer(t, layer);
            //将mLastLayer调整为新的z-order
            mLastLayer = layer;
            mLastRelativeToLayer = null;
        &#125;
    &#125;
    
    protected void setLayer(Transaction t, int layer) &#123;
        if (mSurfaceFreezer.hasLeash()) &#123;
               ......
        &#125; else &#123;
            // Route through surface animator to accommodate that our surface control might be
            // attached to the leash, and leash is attached to parent container.
            //调用SurfaceAnimator中的setLayer
            mSurfaceAnimator.setLayer(t, layer);
        &#125;
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;SurfaceAnimator.java</p>
<pre><code>    /**
     * Sets the layer of the surface.
     * &lt;p&gt;
     * When the layer of the surface needs to be adjusted, we need to set it on the leash if the
     * surface is reparented to the leash. This method takes care of that.
     */
    void setLayer(Transaction t, int layer) &#123;
          //调用SurfaceControl中的setlayer方法
        t.setLayer(mLeash != null ? mLeash : mAnimatable.getSurfaceControl(), layer);
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>        /**
         * Set the Z-order for a given SurfaceControl, relative to it&#39;s siblings.
         * If two siblings share the same Z order the ordering is undefined. Surfaces
         * with a negative Z will be placed below the parent surface.
         *
         * @param sc The SurfaceControl to set the Z order on
         * @param z The Z-order
         * @return This Transaction.
         */
        @NonNull
        public Transaction setLayer(@NonNull SurfaceControl sc,
                @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z) &#123;
            //调用调整layer
            checkPreconditions(sc);
            nativeSetLayer(mNativeObject, sc.mNativeObject, z);
            return this;
        &#125;
</code></pre>
<h4 id="2-2-窗口位置和大小计算"><a href="#2-2-窗口位置和大小计算" class="headerlink" title="2.2 窗口位置和大小计算"></a>2.2 窗口位置和大小计算</h4><p>当WindowState加入到WindowToken并调整z-order之后，客户端会再次调用<strong>WindowManagerService.relayoutWindow</strong>执行窗口布局。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.创建SurfaceControl<br>3.窗口位置和大小计算</p>
<h5 id="2-2-1-接收客户端请求"><a href="#2-2-1-接收客户端请求" class="headerlink" title="2.2.1 接收客户端请求"></a>2.2.1 接收客户端请求</h5><p>与addWindow流程的调用过程类似，WindowManagerService.relayoutWindow也是由客户端通过Session来调用的。<br>首先我们来看一下客户端给我们传递了哪些参数吧。<br>window：是WMS与客户端通信的Binder。<br>attrs：窗口的布局属性，根据attrs提供的属性来布局窗口。<br>requestWidth、requestHeight：客户端请求的窗口尺寸。<br>viewFlags：窗口的可见性。包括VISIBLE（0，view可见），INVISIBLE（4，view不可见，但是仍然占用布局空间）GONE（8，view不可见，不占用布局空间）<br>flags：定义一些布局行为。<br>outFrames：返回给客户端的，保存了重新布局之后的位置与大小。<br>mergedConfiguration:相关配置信息。<br>outSurfaceControl:返回给客户端的surfaceControl。<br>outInsetsState：用来保存系统中所有Insets的状态。<br>outActiveControls：InSetsSourceControl数组。<br>outSyncSeqIdBundle：与布局同步有关。<br>Session调用WMS.relayoutWindow将客户端传入的参数传递给WMS。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public int relayout(IWindow window, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags, int flags,
            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Bundle outSyncSeqIdBundle) &#123;
        if (false) Slog.d(TAG_WM, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot;
                + Binder.getCallingPid());
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, mRelayoutTag);
        int res = mService.relayoutWindow(this, window, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrames, mergedConfiguration, outSurfaceControl, outInsetsState,
                outActiveControls, outSyncSeqIdBundle);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        if (false) Slog.d(TAG_WM, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot;
                + Binder.getCallingPid());
        return res;
    &#125;
</code></pre>
<h5 id="2-2-2-relayoutWindow"><a href="#2-2-2-relayoutWindow" class="headerlink" title="2.2.2 relayoutWindow"></a>2.2.2 relayoutWindow</h5><p>在WMS.relayoutWindow中主要做了以下事情：<br>1.根据客户端传过来的IWindow在mWindowMap获取窗口添加阶段创建的WindowState。<br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br>3.Surface的创建流程。<br>4.窗口尺寸的计算以及Surface的状态变更。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    public int relayoutWindow(Session session, IWindow client, LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility, int flags,
            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle) &#123;
        ......
        synchronized (mGlobalLock) &#123;
            /*1.根据客户端传过来的Iwindow从mWindowMap中获取对应的WindowState*/
            final WindowState win = windowForClientLocked(session, client, false);
            if (win == null) &#123;
                return 0;
            &#125;
            //获取DisplayContent、DisplayPolicy以及WindowStateAnimator 
            final DisplayContent displayContent = win.getDisplayContent();
            final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();

            WindowStateAnimator winAnimator = win.mWinAnimator;
            if (viewVisibility != View.GONE) &#123;
                //根据客户端请求的窗口大小设置WindowState的requestedWidth, requestedHeight
                //并设置WindowState.mLayoutNeeded为true
                win.setRequestedSize(requestedWidth, requestedHeight);
            &#125;
            ......
            //根据请求的宽带和高度窗口缩放比例
            win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);
            ......
            //获取原来window的可见性，此时为INVISIBLE
            final int oldVisibility = win.mViewVisibility;
            ......
            //代表现在没有surface但应该很快就有标志位
            win.mRelayoutCalled = true;
            win.mInRelayout = true;
            //将当前窗口的可见性有原来的INVISIBLE调整为VISIBLE
            win.setViewVisibility(viewVisibility);
            ProtoLog.i(WM_DEBUG_SCREEN_ON,
                    &quot;Relayout %s: oldVis=%d newVis=%d. %s&quot;, win, oldVisibility,
                            viewVisibility, new RuntimeException().fillInStackTrace());
            /*2.1.将displayContent中的布局标志为mLayoutNeeded置为true*/
            win.setDisplayLayoutNeeded();
            win.mGivenInsetsPending = (flags &amp; WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;

            // We should only relayout if the view is visible, it is a starting window, or the
            // associated appToken is not hidden.
            /*2.2.判断是否允许relayout，此时为true*/
            //判断条件：view可见且（activityRecord不为空，或者布局类型为TYPE_APPLICATION_STARTING，或者窗口已经告诉客户端可以显示）
            final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING
                            || win.mActivityRecord.isClientVisible());
            ......
            // Create surfaceControl before surface placement otherwise layout will be skipped
            // (because WS.isGoneForLayout() is true when there is no surface.
            /*3.surface的创建流程*/
            if (shouldRelayout) &#123;
                try &#123;
                    //进入creatSurfaceControl开始创建SurfaceControl
                    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);
                &#125; catch (Exception e) &#123;
                    ......
                    return 0;
                &#125;
            &#125;

            // We may be deferring layout passes at the moment, but since the client is interested
            // in the new out values right now we need to force a layout.
            /*4.窗口尺寸的计算以及Surface的状态变更*/
            //WindowSurfacePlacer在WMS初始化的时候创建
            mWindowPlacerLocked.performSurfacePlacement(true /* force */);
            ......
            //填充计算好的frame返回给客户端，更新mergedConfiguration对象
            win.fillClientWindowFramesAndConfiguration(outFrames, mergedConfiguration,
                    false /* useLatestConfig */, shouldRelayout);

            // Set resize-handled here because the values are sent back to the client.
            win.onResizeHandled();
            ......
        &#125;

        Binder.restoreCallingIdentity(origId);
        //返回result
        return result;
    &#125;
</code></pre>
<h5 id="2-2-3-创建SurfaceControl"><a href="#2-2-3-创建SurfaceControl" class="headerlink" title="2.2.3 创建SurfaceControl"></a>2.2.3 创建SurfaceControl</h5><p>在relayoutWindow中创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code><br>关于SurfaceControl的创建在WMS中主要做两件事：<br>1.调用WindwoStateAnimator执行具体的SurfaceControl的创建。<br>2.将创建的SurfaceControl赋值给客户端的outSurfaceControl。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    private int createSurfaceControl(SurfaceControl outSurfaceControl, int result,
            WindowState win, WindowStateAnimator winAnimator) &#123;
        ......
        WindowSurfaceController surfaceController;
        try &#123;
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;createSurfaceControl&quot;);
            /*
             * WindowStateAnimator用来帮助WindowState管理animator和surface基本操作的
             * 1.WMS将创建的surfaceContorl的操作交给windowAnimator来处理
             */
            surfaceController = winAnimator.createSurfaceLocked();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
        if (surfaceController != null) &#123;
            /*2.将WMS的SurfaceControl赋值给客户端的outSurfaceControl*/
            surfaceController.getSurfaceControl(outSurfaceControl);
            ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot;OUT SURFACE %s: copied&quot;, outSurfaceControl);

        &#125; else &#123;
            // For some reason there isn&#39;t a surface.  Clear the
            // caller&#39;s object so they see the same state.
            ProtoLog.w(WM_ERROR, &quot;Failed to create surface control for %s&quot;, win);
            outSurfaceControl.release();
        &#125;

        return result;
    &#125;
</code></pre>
<p>在WindowStateAnimator中创建SurfaceControl主要经过以下三个步骤：<br>1.重置Surface标志位，变更mDrawState状态为DRAW_PENDING。<br>2.通过实例化WindowSurfaceController来创建SurfaceControl。<br>3.处理Surface标志位，将其置为true，标志着当前WindowState已经有surface了<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>   WindowSurfaceController createSurfaceLocked() &#123;
        final WindowState w = mWin;
        
        //首先判断是否存在mSurfaceController
        if (mSurfaceController != null) &#123;
            return mSurfaceController;
        &#125;
        /*1.1.设置WindowState的mHasSurface设置为false*/
        w.setHasSurface(false);

        ProtoLog.i(WM_DEBUG_ANIM, &quot;createSurface %s: mDrawState=DRAW_PENDING&quot;, this);
        /*1.2.将WindowStateAnimator中的DrawState设置为DRAW_PENDING*/
        resetDrawState();

        mService.makeWindowFreezingScreenIfNeededLocked(w);

        /*1.3.将surface创建flag设置为hidden*/
        int flags = SurfaceControl.HIDDEN;
        //获取windowState的布局参数
        final WindowManager.LayoutParams attrs = w.mAttrs;

        // Set up surface control with initial size.
        try &#123;
            	......
            	/*2.创建WindowSurfaceController*/
            	//attrs.getTitle().toString()为当前activity的全路径名
            	//format为位图格式
            	//flags为surface创建的标志位（如：HIDDED(0x04,surface创建为隐藏)，SKIP_SCREENSHOT(0x040，截屏时跳过此图层将不会包含在非主显示器上),SECURE(0X080,禁止复制表面的内容，屏幕截图和次要的非安全显示将呈现黑色内容而不是surface内容)等）
            	//attrs.type为窗口类型
            mSurfaceController = new WindowSurfaceController(attrs.getTitle().toString(), format,
                    flags, this, attrs.type);
            mSurfaceController.setColorSpaceAgnostic((attrs.privateFlags
                    &amp; WindowManager.LayoutParams.PRIVATE_FLAG_COLOR_SPACE_AGNOSTIC) != 0);

            /*3.将WindowState的hasSurface标志设置为true，标志着道歉WindowState已经有surface了*/
            w.setHasSurface(true);
            ......
        &#125; catch (OutOfResourcesException e) &#123;
            ......
        &#125; catch (Exception e) &#123;
            ......
        &#125;
        ......
        return mSurfaceController;
    &#125;
</code></pre>
<p>SurfaceControl的创建过程为典型的建造者模式<br>接下来看看WindowSurfaceController的构造方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p>
<pre><code>WindowSurfaceController(String name, int format, int flags, WindowStateAnimator animator,
            int windowType) &#123;
        //设置WindowStateAnimator
        mAnimator = animator;
        //窗口名
        title = name;
        //WMS对象
        mService = animator.mService;
        //WindowState对象
        final WindowState win = animator.mWin;
        //窗口类型
        mWindowType = windowType;
        //IWindowSession对象
        mWindowSession = win.mSession;

        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;new SurfaceControl&quot;);
        //makeSurface最终会调用到DisplayContent的makeChildSurface方法，返回SurfaceControl.Builder
        final SurfaceControl.Builder b = win.makeSurface()
                .setParent(win.getSurfaceControl())
                .setName(name)
                .setFormat(format)
                .setFlags(flags)
                .setMetadata(METADATA_WINDOW_TYPE, windowType)
                .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid)
                .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid)
                .setCallsite(&quot;WindowSurfaceController&quot;);
        ......
        //获取SurfaceControl实例对象
        mSurfaceControl = b.build();

        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    &#125;
</code></pre>
<p>两个关键方法win.makeSurface()和b.build()<br>1.<code>final SurfaceControl.Builder b = win.makeSurface()</code><br>我们先来看看win.makeSurface()，windowState中没有makeSurface()方法，因此调用其父类WindowContainer的makeSurface()方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>    SurfaceControl.Builder makeSurface() &#123;
        final WindowContainer p = getParent();
        return p.makeChildSurface(this);
    &#125;
        /**
     * @param child The WindowContainer this child surface is for, or null if the Surface
     *              is not assosciated with a WindowContainer (e.g. a surface used for Dimming).
     */
    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;
        final WindowContainer p = getParent();
        // Give the parent a chance to set properties. In hierarchy v1 we rely
        // on this to set full-screen dimensions on all our Surface-less Layers.
        return p.makeChildSurface(child)
                .setParent(mSurfaceControl);
    &#125;
</code></pre>
<p>最终会调用到DisplayContent的makeChildSurface<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    @Override
    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;
        //此时child为WindowState
        //获取SurfaceSession，SurfaceSession的创建在Session.windowAddedLocked中，其最开始调用在WindowManagerService.addWindow中win.attach()中创建
        SurfaceSession s = child != null ? child.getSession() : getSession();
        //返回SurfaceControl.Builder
        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(s).setContainerLayer();
        if (child == null) &#123;
            return b;
        &#125;
        //设置SurfaceControl.Builder的name以及parent
        return b.setName(child.getName())
                .setParent(mSurfaceControl);
    &#125;
</code></pre>
<p>2.<code>mSurfaceControl = b.build();</code><br>再来看看b.build()，调用SurfaceControl中的build<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>    /**
      * Construct a new &#123;@link SurfaceControl&#125; with the set parameters. The builder
      * remains valid.
      */
     @NonNull
     public SurfaceControl build() &#123;
     	//检查width以及height，初始都应该为0
         if (mWidth &lt; 0 || mHeight &lt; 0) &#123;
             throw new IllegalStateException(
                     &quot;width and height must be positive or unset&quot;);
         &#125;
         if ((mWidth &gt; 0 || mHeight &gt; 0) &amp;&amp; (isEffectLayer() || isContainerLayer())) &#123;
             throw new IllegalStateException(
                     &quot;Only buffer layers can set a valid buffer size.&quot;);
         &#125;
    
         if ((mFlags &amp; FX_SURFACE_MASK) == FX_SURFACE_NORMAL) &#123;
             setBLASTLayer();
         &#125;
    //创建SurfaceControl的实例
         return new SurfaceControl(
                 mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,
                 mLocalOwnerView, mCallsite);
     &#125;
    
   /**
    * @param session  The surface session, must not be null.
    * @param name     The surface name, must not be null.
    * @param w        The surface initial width.
    * @param h        The surface initial height.
    * @param flags    The surface creation flags.
    * @param metadata Initial metadata.
    * @param callsite String uniquely identifying callsite that created this object. Used for
    *                 leakage tracking.
    * @throws throws OutOfResourcesException If the SurfaceControl cannot be created.
    */
    private SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags,
         SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView,
         String callsite)
                 throws OutOfResourcesException, IllegalArgumentException &#123;
     if (name == null) &#123;
         throw new IllegalArgumentException(&quot;name must not be null&quot;);
     &#125;
    
     mName = name;
     mWidth = w;
     mHeight = h;
     mLocalOwnerView = localOwnerView;
     //创建Parcel用来传递数据
     Parcel metaParcel = Parcel.obtain();
     try &#123;
       	......
       	//调用native层
         mNativeObject = nativeCreate(session, name, w, h, format, flags,
                 parent != null ? parent.mNativeObject : 0, metaParcel);
     &#125; finally &#123;
         metaParcel.recycle();
     &#125;
     if (mNativeObject == 0) &#123;
         throw new OutOfResourcesException(
                 &quot;Couldn&#39;t allocate SurfaceControl native object&quot;);
     &#125;
     mNativeHandle = nativeGetHandle(mNativeObject);
     mCloseGuard.openWithCallSite(&quot;release&quot;, callsite);
    &#125;
</code></pre>
<p>​    </p>
<p>SurfaceControl的构造方法调用完成后，返回查看前面<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code></p>
<h5 id="2-2-4-计算窗口大小位置"><a href="#2-2-4-计算窗口大小位置" class="headerlink" title="2.2.4 计算窗口大小位置"></a>2.2.4 计算窗口大小位置</h5><p>在relayoutWindow中计算窗口大小位置<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code><br>该流程我们分为三部分介绍：<br>1.该部分处理有关窗口布局循环的逻辑。<br>2.该部分处理Surface的状态变更，以及调用layoutWindowLw的流程。<br>3.计算窗口位置大小。</p>
<h6 id="1-处理窗口布局循环"><a href="#1-处理窗口布局循环" class="headerlink" title="1.处理窗口布局循环"></a>1.处理窗口布局循环</h6><p>performSurfacePlacement是一个确定所有窗口的Surface的如何摆放，如何显示、显示在什么位置、显示区域多大的一个入口方法。<br>该方法主要设置了布局的循环条件，当mTraversalScheduled 标志位为true，且loopCount大于0。将会调用performSurfacePlacementLoop执行布局操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p>
<pre><code>    final void performSurfacePlacement(boolean force) &#123;
        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;
            mDeferredRequests++;
            return;
        &#125;
        //将循环的最大次数设置为6次
        int loopCount = 6;
        do &#123;
            //将该标志为设置为false
            mTraversalScheduled = false;
            //执行窗口布局操作
            performSurfacePlacementLoop();
            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);
            loopCount--;
        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局
        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);
        mService.mRoot.mWallpaperActionPending = false;
    &#125;
</code></pre>
<p>performSurfacePlacementLoop方法主要做两件事：<br>1.调用RootWindowContainer对所有窗口执行布局操作，<br>2.处理是否再次进行布局的逻辑。如果DisplayContent.mLayoutNeeded标志位为true且布局循环次数小于6次，则会将mTraversalScheduled标志位置为true，在performSurfacePlacement中会再次调用performSurfacePlacementLoop。</p>
<pre><code>    private void performSurfacePlacementLoop() &#123;
        //若当前已经进行布局操作，则无需重复调用直接返回
        if (mInLayout) &#123;
            ......
            return;
        &#125;
        ......
        //将该标志位置为true，表示正在处于布局过程中
        mInLayout = true;
        ......
        try &#123;
            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/
            mService.mRoot.performSurfacePlacement();

            mInLayout = false;

            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;

            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;
                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);
                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);
            &#125;
        &#125; catch (RuntimeException e) &#123;
            mInLayout = false;
            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);
        &#125;
    &#125;
</code></pre>
<h6 id="2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程"><a href="#2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程" class="headerlink" title="2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程"></a>2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程</h6><p><code>mService.mRoot.performSurfacePlacement();</code><br>上面说到在RootWindowContainer.performSurfacePlacement()中调用了performSurfaceNoTrace()方法，该方法为实际的处理布局的方法，主要处理以下流程：<br>1.如果有焦点变化，更新焦点。<br>2.执行窗口尺寸计算，surface状态变更等操作。<br>3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在finishdrawing()中再详细分析。<br>4.如果壁纸有变化，更新壁纸。<br>5.再次处理焦点变化。<br>6.如果过程中由size或者位置变化，则通知客户端重新relayout。<br>7.销毁不可见的窗口<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    void performSurfacePlacement() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);
        try &#123;
            //调用performSurfacePlacementNoTrace()
            performSurfacePlacementNoTrace();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;
    // TODO: Super long method that should be broken down...
    void performSurfacePlacementNoTrace() &#123;
        ......
        /*1.如果有焦点变化，更新焦点*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(
                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);
        &#125;
        ......
        
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);
        //开启事务，获取GlobalTransactionWrapper对象
        mWmService.openSurfaceTransaction();
        try &#123;
            /*2.执行窗口尺寸计算，surface状态变更等操作*/
            applySurfaceChangesTransaction();
        &#125; catch (RuntimeException e) &#123;
            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);
        &#125; finally &#123;
            //关闭事务
            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            if (SHOW_LIGHT_TRANSACTIONS) &#123;
                Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);
            &#125;
        &#125;
        ......
        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/
        checkAppTransitionReady(surfacePlacer);
        ......
        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/
        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;
            final DisplayContent displayContent = mChildren.get(displayNdx);
            //判断DisplayContent的壁纸是否需要改变
            if (displayContent.mWallpaperMayChange) &#123;
                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,
                            displayContent.pendingLayoutChanges);
                &#125;
            &#125;
        &#125;
        /*5.在此处理焦点变化*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
                    false /*updateInputWindows*/);
        &#125;
        ......
        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/
        handleResizingWindows();

        if (mWmService.mDisplayFrozen) &#123;
            ProtoLog.v(WM_DEBUG_ORIENTATION,
                    &quot;With display frozen, orientationChangeComplete=%b&quot;,
                    mOrientationChangeComplete);
        &#125;
        if (mOrientationChangeComplete) &#123;
            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;
                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;
                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
            &#125;
            mWmService.stopFreezingDisplayLocked();
        &#125;

        // Destroy the surface of any windows that are no longer visible.
        /*7.销毁不可见的窗口*/
        i = mWmService.mDestroySurface.size();
        if (i &gt; 0) &#123;
            do &#123;
                i--;
                WindowState win = mWmService.mDestroySurface.get(i);
                win.mDestroying = false;
                final DisplayContent displayContent = win.getDisplayContent();
                if (displayContent.mInputMethodWindow == win) &#123;
                    displayContent.setInputMethodWindowLocked(null);
                &#125;
                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;
                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                &#125;
                win.destroySurfaceUnchecked();
            &#125; while (i &gt; 0);
            mWmService.mDestroySurface.clear();
        &#125;
        ......
    &#125;
</code></pre>
<p>​    </p>
<p>在<code>applySurfaceChangesTransaction();</code>方法中其主要执行：<br>1.水印、StrictMode警告框以及模拟器显示的布局。<br>2.遍历所有DisplayContent执行其applySurfaceChangesTransaction<br>我们一起看看这个方法</p>
<pre><code>    private void applySurfaceChangesTransaction() &#123;
        mHoldScreenWindow = null;
        mObscuringWindow = null;

        // TODO(multi-display): Support these features on secondary screens.
        /*1.水印、StrictMode警告框以及模拟器显示的布局*/
        //获取手机默认DisplayContent的信息
        final DisplayContent defaultDc = mWmService.getDefaultDisplayContentLocked();
        final DisplayInfo defaultInfo = defaultDc.getDisplayInfo();
        final int defaultDw = defaultInfo.logicalWidth;
        final int defaultDh = defaultInfo.logicalHeight;
        //布局水印
        if (mWmService.mWatermark != null) &#123;
            mWmService.mWatermark.positionSurface(defaultDw, defaultDh, mDisplayTransaction);
        &#125;
        //布局StrictMode警告框
        if (mWmService.mStrictModeFlash != null) &#123;
            mWmService.mStrictModeFlash.positionSurface(defaultDw, defaultDh, mDisplayTransaction);
        &#125;
        //布局模拟器显示覆盖
        if (mWmService.mEmulatorDisplayOverlay != null) &#123;
            mWmService.mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh,
                    mWmService.getDefaultDisplayRotation(), mDisplayTransaction);
        &#125;
        /*2.遍历RootWindowContainer下所有DisplayContent执行其applySurfaceChangesTransaction()*/
        final int count = mChildren.size();
        for (int j = 0; j &lt; count; ++j) &#123;
            final DisplayContent dc = mChildren.get(j);
            dc.applySurfaceChangesTransaction();
        &#125;

        // Give the display manager a chance to adjust properties like display rotation if it needs
        // to.
        mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction);
        SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);
    &#125;
</code></pre>
<p>接下来继续跟踪<code>dc.applySurfaceChangesTransaction();</code><br>该方法主要<br>1.遍历所有窗口，计算窗口的布局大小，具体流程查看performLayoutNoTrace。（主要跟踪点）<br>2.surface的状态更改。（见“<strong>2.3.3mDrawState变更为HAS_DRAW”流程</strong>”）<br>3.处理surface的位置、大小以及显示等。（见“<strong>2.3.4 show Surface”流程</strong>”）<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    void applySurfaceChangesTransaction() &#123;
        //获取WindowSurfacePlacer 
        final WindowSurfacePlacer surfacePlacer = mWmService.mWindowPlacerLocked;
        ......
        // Perform a layout, if needed.
        /*1.执行布局，该方法最终会调用performLayoutNoTrace，计算窗口的布局参数*/
        performLayout(true /* initial */, false /* updateInputWindows */);
        ......
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applyWindowSurfaceChanges&quot;);
        try &#123;
            /*2.遍历所有窗口，主要是改变surface的状态。见“2.3.3mDrawState变更为HAS_DRAW”流程*/
            forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
        /*3.处理各个surface的位置、大小以及是否要在屏幕上显示等。后面finishDrawing()流程中再跟踪*/
        prepareSurfaces();
        ......
    &#125;
</code></pre>
<p>继续跟踪<code>performLayout(true /* initial */, false /* updateInputWindows */);</code><br>该方法主要就是调用performLayoutNoTrace()方法，首先判断布局标志位mLayoutNeeded，该标志位在WMS.relayoutWindow中被置为true。<br>false则直接返回不会进行布局操作。<br>true则分别遍历父窗口和子窗口进行布局，我们暂且只分析父窗口的布局操作，查看mPerformLayout。</p>
<pre><code>    void performLayout(boolean initial, boolean updateInputWindows) &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performLayout&quot;);
        try &#123;
            //调用performLayoutNoTrace
            performLayoutNoTrace(initial, updateInputWindows);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    private void performLayoutNoTrace(boolean initial, boolean updateInputWindows) &#123;
            /*1.判断是否需要布局，不需要则直接返回，即判断布局标志位mLayoutNeeded是否为true*/
        if (!isLayoutNeeded()) &#123;
            return;
        &#125;
        //将DisplayContent.mLayoutNeeded属性置为false
        clearLayoutNeeded();
        ......
        // First perform layout of any root windows (not attached to another window).
        /*2.对所有顶级窗口进行布局*/
        //最终会回调mPerformLayout
        forAllWindows(mPerformLayout, true /* traverseTopToBottom */);

        // Now perform layout of attached windows, which usually depend on the position of the
        // window they are attached to. XXX does not deal with windows that are attached to windows
        // that are themselves attached.
        /*3.处理子窗口的布局*/
        //最终会回调mPerformLayoutAttached
        forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);
        ......
    &#125;
</code></pre>
<p><code>forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);</code><br>当遍历到DisplayContent下的每个窗口时都会执行mPerformLayout，该方法会将WindowState.mLayoutNeeded标志位置false，并将具体的布局操作交给DisplayPolicy进行处理，见“<strong>3. 计算窗口位置大小</strong>“。</p>
<pre><code>    private final Consumer&lt;WindowState&gt; mPerformLayout = w -&gt; &#123;
        //如果当前窗口为子窗口则直接返回
        if (w.mLayoutAttached) &#123;
            return;
        &#125;

        // Don&#39;t do layout of a window if it is not visible, or soon won&#39;t be visible, to avoid
        // wasting time and funky changes while a window is animating away.
        //先判断当前窗口是否会不可见
        final boolean gone = w.isGoneForLayout();
        ......

        // If this view is GONE, then skip it -- keep the current frame, and let the caller know
        // so they can ignore it if they want.  (We do the normal layout for INVISIBLE windows,
        // since that means &quot;perform layout as normal, just don&#39;t display&quot;).
        if (!gone || !w.mHaveFrame || w.mLayoutNeeded) &#123;
            if (mTmpInitial) &#123;
                //设置窗口布局WindowFrames.mContentChanged为false
                w.resetContentChanged();
            &#125;
            //将mSurfacePlacementNeeded标志为置为true
            w.mSurfacePlacementNeeded = true;
            //将WindowState.mLayoutNeeded标志位置为false
            w.mLayoutNeeded = false;
            //判断当前窗口是否是第一次布局
            final boolean firstLayout = !w.isLaidOut();
            //调用DisplayPolicy.layoutWindowLw进行布局，根据DisplayFrames对象对WindowState.mWindowFrames中的各个Rect对象属性进行确定
            getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);
            w.mLayoutSeq = mLayoutSeq;

            // If this is the first layout, we need to initialize the last frames and inset values,
            // as otherwise we&#39;d immediately cause an unnecessary resize.
            if (firstLayout) &#123;
                // The client may compute its actual requested size according to the first layout,
                // so we still request the window to resize if the current frame is empty.
                if (!w.getFrame().isEmpty()) &#123;
                    w.updateLastFrames();
                &#125;
                w.onResizeHandled();
            &#125;

            if (DEBUG_LAYOUT) Slog.v(TAG, &quot;  LAYOUT: mFrame=&quot; + w.getFrame()
                    + &quot; mParentFrame=&quot; + w.getParentFrame()
                    + &quot; mDisplayFrame=&quot; + w.getDisplayFrame());
        &#125;
    &#125;;
</code></pre>
<p>当mLayoutNeeded标志被设置时，表示布局需要更新；mSurfacePlacementNeeded标志被设置时，表示需要更新surface位置的条件之一（WindowState.updateSurfacePosition方法中有判断）。</p>
<h6 id="3-计算窗口位置大小"><a href="#3-计算窗口位置大小" class="headerlink" title="3.计算窗口位置大小"></a>3.计算窗口位置大小</h6><p><code>getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);</code><br>layoutWindowLw主要做了以下三件事<br>1.首先会获DisplayFrames：DisplayContent新建时创建，内部数据由屏幕提供。<br>2.其次调用WindowLayout.computeFrames计算窗口布局大小。<br>3.最后调用WindowState.setFrames将计算的布局参数赋值给当前窗口的windowFrames。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayPolicy.java</p>
<pre><code>    /**
     * Called for each window attached to the window manager as layout is proceeding. The
     * implementation of this function must take care of setting the window&#39;s frame, either here or
     * in finishLayout().
     *
     * @param win The window being positioned.
     * @param attached For sub-windows, the window it is attached to; this
     *                 window will already have had layoutWindow() called on it
     *                 so you can use its Rect.  Otherwise null.
     * @param displayFrames The display frames.
     */
    public void layoutWindowLw(WindowState win, WindowState attached, DisplayFrames displayFrames) &#123;
        //判断是否需要跳过布局
        if (win.skipLayout()) &#123;
            return;
        &#125;

        // This window might be in the simulated environment.
        // We invoke this to get the proper DisplayFrames.
        /*1.获取DisplayFrames*/
        displayFrames = win.getDisplayFrames(displayFrames);
        //获取某个方向的窗口布局参数
        final WindowManager.LayoutParams attrs = win.getLayoutingAttrs(displayFrames.mRotation);
        //null
        final Rect attachedWindowFrame = attached != null ? attached.getFrame() : null;

        // If this window has different LayoutParams for rotations, we cannot trust its requested
        // size. Because it might have not sent its requested size for the new rotation.
        final boolean trustedSize = attrs == win.mAttrs;
        final int requestedWidth = trustedSize ? win.mRequestedWidth : UNSPECIFIED_LENGTH;
        final int requestedHeight = trustedSize ? win.mRequestedHeight : UNSPECIFIED_LENGTH;
        /*2.调用WindowLayout.computeFrames计算窗口布局大小*/
        mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,
                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,
                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,
                sTmpClientFrames);
        /*3.将计算的布局参数赋值给windowFrames*/
        win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);
    &#125;
</code></pre>
<p>先来看看computeFrames，计算窗口布局大小</p>
<pre><code>mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,
                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,
                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,
                sTmpClientFrames);
</code></pre>
<p>调用的是WindowLayout的computeFrames方法</p>
<pre><code>public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,
            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,
            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,
            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames)
</code></pre>
<p>入参说明：<br><code>attrs</code>：这些是窗口的布局参数。它们定义了窗口的位置、大小、堆叠顺序等属性。<br><code>state</code>：这个参数代表了窗口的边距状态。边距是窗口与设备边缘之间的空间，可能会被其他元素（如状态栏或导航栏）占据。<br><code>displayCutoutSafe</code>：这是一个矩形，表示在计算窗口大小时可以安全忽略的显示切边区域。这通常是为了防止应用程序内容与设备上的物理切边重叠。<br><code>windowBounds</code>：这是窗口的边界矩形，通常表示窗口在屏幕上的位置和大小。<br><code>windowingMode</code>：这个参数定义了窗口的窗口模式。例如，它可以是全屏、浮动等模式。<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br><code>requestedVisibilities</code>：请求的可见性。这定义了应用程序请求的边距可见性，例如状态栏或导航栏是否可见。<br><code>attachedWindowFrame</code>：附加窗口的边界。如果这个窗口是附加到另一个窗口的，这个参数表示它相对于其父窗口的位置和大小。<br><code>compatScale</code>：兼容性比例，一个缩放因子，用于调整窗口内容的显示大小以适应不同的屏幕尺寸或分辨率。<br><code>outFrames</code>：用于返回计算后的窗口信息。它包含了窗口的实际边界、边距等信息。<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowLayout.java</p>
<pre><code>    public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,
            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,
            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,
            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames) &#123;
        //传入的参数attrs中提取出窗口的类型（type）、标志（fl）、私有标志（pfl）和布局是否在屏幕内（layoutInScreen）
        final int type = attrs.type;
        final int fl = attrs.flags;
        final int pfl = attrs.privateFlags;
        final boolean layoutInScreen = (fl &amp; FLAG_LAYOUT_IN_SCREEN) == FLAG_LAYOUT_IN_SCREEN;
        //定义了用于存储结果的矩形变量，包含：显示边界（outDisplayFrame）、父边界（outParentFrame）和实际边界（outFrame）
        final Rect outDisplayFrame = outFrames.displayFrame;
        final Rect outParentFrame = outFrames.parentFrame;
        final Rect outFrame = outFrames.frame;

        // Compute bounds restricted by insets
        //计算窗口被Insets限制的边界。Insets是屏幕边缘的空间，用于放置状态栏、导航栏等。
        //这一步通过调用state.calculateInsets()方法完成，该方法需要窗口边界和窗口布局参数作为输入。
        final Insets insets = state.calculateInsets(windowBounds, attrs.getFitInsetsTypes(),
                attrs.isFitInsetsIgnoringVisibility());
        //代码根据Insets的边类型（LEFT、TOP、RIGHT、BOTTOM），从计算出的Insets中提取出相应的边距，
        //并将它们添加到窗口的原始边界上，得到显示边界。
        final @WindowInsets.Side.InsetsSide int sides = attrs.getFitInsetsSides();
        final int left = (sides &amp; WindowInsets.Side.LEFT) != 0 ? insets.left : 0;
        final int top = (sides &amp; WindowInsets.Side.TOP) != 0 ? insets.top : 0;
        final int right = (sides &amp; WindowInsets.Side.RIGHT) != 0 ? insets.right : 0;
        final int bottom = (sides &amp; WindowInsets.Side.BOTTOM) != 0 ? insets.bottom : 0;
        //代码将计算出的显示边界赋值给outDisplayFrame
        outDisplayFrame.set(windowBounds.left + left, windowBounds.top + top,
                windowBounds.right - right, windowBounds.bottom - bottom);

        //根据窗口的附加信息和布局属性来确定父边界的位置和大小。
        if (attachedWindowFrame == null) &#123;
            //将outParentFrame设置为与outDisplayFrame相同，这意味着父边界与显示边界相同
            outParentFrame.set(outDisplayFrame);
            //检查私有标志PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME是否被设置。
            //这个标志可能表示是否需要根据输入法窗口（IME）的位置来调整父边界。
            if ((pfl &amp; PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME) != 0) &#123;
                //从状态中获取输入法窗口的源（source）
                final InsetsSource source = state.peekSource(ITYPE_IME);
                if (source != null) &#123;
                    //如果输入法窗口的source存在，则使用该source来计算父边界的内边距（Insets）。
                    outParentFrame.inset(source.calculateInsets(
                            outParentFrame, false /* ignoreVisibility */));//这里忽略source的可见性。
                &#125;
            &#125;
        &#125; else &#123;
            //如果layoutInScreen为true，则将outParentFrame设置为与attachedWindowFrame相同。
            //这表示父边界是由附加窗口的边界决定的。
            //如果layoutInScreen为false，则将outParentFrame设置为与outDisplayFrame相同。
            //这表示父边界与显示边界相同。
            outParentFrame.set(!layoutInScreen ? attachedWindowFrame : outDisplayFrame);
        &#125;

        // Compute bounds restricted by display cutout
        //根据屏幕的显示切边和窗口的布局属性来计算窗口在屏幕上受到限制的位置和大小，确保窗口不会覆盖到显示切边区域
        final int cutoutMode = attrs.layoutInDisplayCutoutMode;//切边模式
        final DisplayCutout cutout = state.getDisplayCutout();//屏幕上的显示切边区域
        //将displayCutoutSafeExceptMaybeBars设置为与displayCutoutSafe相同，
        //这是一个临时矩形，用于稍后计算不受某些系统界面元素（如状态栏）影响的显示切边安全区域。
        final Rect displayCutoutSafeExceptMaybeBars = mTempDisplayCutoutSafeExceptMaybeBarsRect;
        displayCutoutSafeExceptMaybeBars.set(displayCutoutSafe);
        //将outFrames.isParentFrameClippedByDisplayCutout设置为false，表示父边界目前没有被显示切边裁剪
        outFrames.isParentFrameClippedByDisplayCutout = false;
        //如果layoutInDisplayCutoutMode不是ALWAYS并且显示切边不为空
        if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS &amp;&amp; !cutout.isEmpty()) &#123;
            // Ensure that windows with a non-ALWAYS display cutout mode are laid out in
            // the cutout safe zone.
            //获取屏幕的显示边界（displayFrame）
            final Rect displayFrame = state.getDisplayFrame();
            //获取状态的Source
            final InsetsSource statusBarSource = state.peekSource(ITYPE_STATUS_BAR);
            //检查状态栏源（statusBarSource）是否存在，并且如果displayCutoutSafe.top大于屏幕的顶部
            if (statusBarSource != null &amp;&amp; displayCutoutSafe.top &gt; displayFrame.top) &#123;
                // Make sure that the zone we&#39;re avoiding for the cutout is at least as tall as the
                // status bar; otherwise fullscreen apps will end up cutting halfway into the status
                // bar.
                //调整displayCutoutSafeExceptMaybeBars.top以确保切边避开的区域至少与状态栏一样高。
                displayCutoutSafeExceptMaybeBars.top =
                        Math.max(statusBarSource.getFrame().bottom, displayCutoutSafe.top);
            &#125;
            //如果layoutInDisplayCutoutMode是SHORT_EDGES
            if (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES) &#123;
                if (displayFrame.width() &lt; displayFrame.height()) &#123;
                    //如果屏幕的宽度小于高度，则将displayCutoutSafeExceptMaybeBars的顶部和底部设置为最大和最小整数值，
                    //这意味着不考虑这些方向上的显示切边。
                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125; else &#123;
                    //否则，将左侧和右侧设置为最大和最小整数值
                    //这意味着不考虑这些方向上的显示切边。
                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;
                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;
                &#125;
            &#125;
            //通过位运算检查attrs.flags中的FLAG_LAYOUT_INSET_DECOR标志是否被设置。如果被设置，则layoutInsetDecor为true
            // FLAG_LAYOUT_INSET_DECOR:使窗口的内容布局在DecorView（装饰视图）之内
            final boolean layoutInsetDecor = (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) != 0;
            //检查布局是否应在屏幕上进行且是否需要考虑显示切边
            //布局在屏幕上、DecorView之内 且 显示切边模式为默认或短边缘模式
            if (layoutInScreen &amp;&amp; layoutInsetDecor
                    &amp;&amp; (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
                    || cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)) &#123;
                //使用给定的displayFrame、系统栏类型和可见性请求来计算系统栏的插入
                //系统栏包含： STATUS_BARS | NAVIGATION_BARS | CAPTION_BAR
                final Insets systemBarsInsets = state.calculateInsets(
                        displayFrame, WindowInsets.Type.systemBars(), requestedVisibilities);
                //如果系统栏在左侧、顶部、右侧或底部的插入大于0，则调整displayCutoutSafeExceptMaybeBars的相应边界，
                //使其尽可能地远离屏幕边缘。这是为了确保窗口不会覆盖到这些系统栏。
                if (systemBarsInsets.left &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;
                &#125;
                if (systemBarsInsets.top &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;
                &#125;
                if (systemBarsInsets.right &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;
                &#125;
                if (systemBarsInsets.bottom &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125;
            &#125;
            //如果窗口类型是输入法（IME）
            if (type == TYPE_INPUT_METHOD) &#123;
                //获取导航栏的Source
                final InsetsSource navSource = state.peekSource(ITYPE_NAVIGATION_BAR);
                //如果存在导航栏且其底部插入大于0
                if (navSource != null &amp;&amp; navSource.calculateInsets(displayFrame, true).bottom &gt; 0) &#123;
                    // The IME can always extend under the bottom cutout if the navbar is there.
                    //调整displayCutoutSafeExceptMaybeBars.bottom，允许IME窗口扩展到底部显示切边以下。
                    //这是为了确保IME可以正常显示在有导航栏的设备上。
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125;
            &#125;
            //如果窗口已附加到其父窗口并且不是全屏布局，则attachedInParent为true
            final boolean attachedInParent = attachedWindowFrame != null &amp;&amp; !layoutInScreen;

            // TYPE_BASE_APPLICATION windows are never considered floating here because they don&#39;t
            // get cropped / shifted to the displayFrame in WindowState.
            //判断窗口是否为浮窗
            //如果窗口不是全屏的、全屏布局的并且不是基础应用程序类型，那么它是一个浮动在屏幕上的窗口，简称浮窗。
            final boolean floatingInScreenWindow = !attrs.isFullscreen() &amp;&amp; layoutInScreen
                    &amp;&amp; type != TYPE_BASE_APPLICATION;

            // Windows that are attached to a parent and laid out in said parent already avoid
            // the cutout according to that parent and don&#39;t need to be further constrained.
            // Floating IN_SCREEN windows get what they ask for and lay out in the full screen.
            // They will later be cropped or shifted using the displayFrame in WindowState,
            // which prevents overlap with the DisplayCutout.
            //对于非附加到父窗口和非浮动在屏幕上的窗口，需要处理其与显示切边的交集。这是因为这些窗口需要避免与显示切边重叠。
            if (!attachedInParent &amp;&amp; !floatingInScreenWindow) &#123;
                mTempRect.set(outParentFrame); //临时存储父窗口的边界
                //将父窗口的边界设置为与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界
                outParentFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);
                //如果父窗口的边界交集后与原始边界不同，则表示父窗口的边界被切边裁剪了
                outFrames.isParentFrameClippedByDisplayCutout = !mTempRect.equals(outParentFrame);
            &#125;
            //将输出显示边界设置与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界
            outDisplayFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);
        &#125;

        //检查attrs.flags中的FLAG_LAYOUT_NO_LIMITS位是否被设置。
        //FLAG_LAYOUT_NO_LIMITS表示允许窗口布局到屏幕外侧。
        final boolean noLimits = (attrs.flags &amp; FLAG_LAYOUT_NO_LIMITS) != 0;
        //检查当前窗口是否处于多窗口模式
        final boolean inMultiWindowMode = WindowConfiguration.inMultiWindowMode(windowingMode);

        // TYPE_SYSTEM_ERROR is above the NavigationBar so it can&#39;t be allowed to extend over it.
        // Also, we don&#39;t allow windows in multi-window mode to extend out of the screen.
        //noLimits是否为true即允许窗口布局到屏幕外）  
        //type是否不等于TYPE_SYSTEM_ERROR（表示窗口类型不是系统错误）  
        //inMultiWindowMode是否为false（表示窗口不在多窗口模式下）
        if (noLimits &amp;&amp; type != TYPE_SYSTEM_ERROR &amp;&amp; !inMultiWindowMode) &#123;
            //设置输出显示的窗口边界
            //[left,top]为左上角左边，[right,bottom]为右上角坐标，两个坐标构成一个矩形
            //左上角左边设置为屏幕最小点，右下角坐标设置为屏幕最大点，即窗口将占据整个屏幕的边界
            outDisplayFrame.left = MIN_X;
            outDisplayFrame.top = MIN_Y;
            outDisplayFrame.right = MAX_X;
            outDisplayFrame.bottom = MAX_Y;
        &#125;

        //如果compatScale不等于1，则hasCompatScale为true。这意味着存在一个兼容的缩放因子。
        final boolean hasCompatScale = compatScale != 1f;
        //父窗口的宽度和高度
        final int pw = outParentFrame.width();
        final int ph = outParentFrame.height();
        //判断窗口的布局尺寸是否因为显示切边而扩展
        //某些设备可能具有物理上的切边（如刘海屏、水滴屏等），这些切边区域不能用于显示内容。
        //PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT作用就是为了确保应用程序的布局在具有切边的设备上仍然正确显示
        //设置这个标志时，窗口的实际尺寸将大于其请求的尺寸，以便在切边区域周围填充空间。
        final boolean extendedByCutout =
                (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != 0;
        //请求的窗口宽度和高度
        int rw = requestedWidth;
        int rh = requestedHeight;
        //窗口的位置坐标
        float x, y;
        //最终确定的窗口宽度和高度
        int w, h;

        // If the view hierarchy hasn&#39;t been measured, the requested width and height would be
        // UNSPECIFIED_LENGTH. This can happen in the first layout of a window or in the simulated
        // layout. If extendedByCutout is true, we cannot use the requested lengths. Otherwise,
        // the window frame might be extended again because the requested lengths may come from the
        // window frame.
        //如果请求的窗口宽度或高度，是UNSPECIFIED_LENGTH或者窗口因为显示切边而扩展，
        //那么其大于或等于0则使用attrs.width或attrs.height的值，否则使用父窗口的宽度和高度
        if (rw == UNSPECIFIED_LENGTH || extendedByCutout) &#123;
            rw = attrs.width &gt;= 0 ? attrs.width : pw;
        &#125;
        if (rh == UNSPECIFIED_LENGTH || extendedByCutout) &#123;
            rh = attrs.height &gt;= 0 ? attrs.height : ph;
        &#125;

        //如果设置了FLAG_SCALED标志，代码会根据是否应用兼容性缩放来调整窗口的宽度和高度。
        if ((attrs.flags &amp; FLAG_SCALED) != 0) &#123;
            if (attrs.width &lt; 0) &#123;
                w = pw;
            &#125; else if (hasCompatScale) &#123;
                w = (int) (attrs.width * compatScale + .5f);
            &#125; else &#123;
                w = attrs.width;
            &#125;
            if (attrs.height &lt; 0) &#123;
                h = ph;
            &#125; else if (hasCompatScale) &#123;
                h = (int) (attrs.height * compatScale + .5f);
            &#125; else &#123;
                h = attrs.height;
            &#125;
        &#125; else &#123;
            if (attrs.width == MATCH_PARENT) &#123;
                w = pw;
            &#125; else if (hasCompatScale) &#123;
                w = (int) (rw * compatScale + .5f);
            &#125; else &#123;
                w = rw;
            &#125;
            if (attrs.height == MATCH_PARENT) &#123;
                h = ph;
            &#125; else if (hasCompatScale) &#123;
                h = (int) (rh * compatScale + .5f);
            &#125; else &#123;
                h = rh;
            &#125;
        &#125;

        //如果存在兼容缩放因子，则调整窗口的x和y位置以考虑缩放。否则，直接使用原始的x和y位置。
        if (hasCompatScale) &#123;
            x = attrs.x * compatScale;
            y = attrs.y * compatScale;
        &#125; else &#123;
            x = attrs.x;
            y = attrs.y;
        &#125;
        
        //当前窗口是多窗口且设置PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME
        //PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME的作用是窗口应该根据其父窗口的边界来调整自己的大小和位置。
        //即控制子窗口在其父窗口内的布局行为，确保子窗口不会超出父窗口的边界。
        if (inMultiWindowMode
                &amp;&amp; (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME) == 0) &#123;
            // Make sure window fits in parent frame since it is in a non-fullscreen task as
            // required by &#123;@link Gravity#apply&#125; call.
            //将窗口的宽度和高度分别设置为它们与父窗口宽度和高度中的较小值。
            //这样做的目的是确保子窗口的大小不会超过其父窗口的大小。
            w = Math.min(w, pw);
            h = Math.min(h, ph);
        &#125;

        // We need to fit it to the display if either
        // a) The window is in a fullscreen container, or we don&#39;t have a task (we assume fullscreen
        // for the taskless windows)
        // b) If it&#39;s a secondary app window, we also need to fit it to the display unless
        // FLAG_LAYOUT_NO_LIMITS is set. This is so we place Popups, dialogs, and similar windows on
        // screen, but SurfaceViews want to be always at a specific location so we don&#39;t fit it to
        // the display.
    
        //如果窗口不在多窗口模式下，或者窗口类型不是基础应用程序类型并且noLimits标志未设置，那么窗口需要适应显示。
        final boolean fitToDisplay = !inMultiWindowMode
                || ((attrs.type != TYPE_BASE_APPLICATION) &amp;&amp; !noLimits);

        // Set mFrame
        //根据给定的重力属性、宽度、高度、父边界等，计算并设置outFrame。
        //这里主要是确定窗口的位置。
        Gravity.apply(attrs.gravity, w, h, outParentFrame,
                (int) (x + attrs.horizontalMargin * pw),
                (int) (y + attrs.verticalMargin * ph), outFrame);

        // Now make sure the window fits in the overall display frame.
        //如果窗口需要适应显示，那么使用Gravity.applyDisplay方法来调整outFrame(实际边界)的大小和位置在outDisplayFrame(显示边界)之内。
        if (fitToDisplay) &#123;
            Gravity.applyDisplay(attrs.gravity, outDisplayFrame, outFrame);
        &#125;

         //确保应用窗口的位置不会与设备的切边冲突。
         //如果窗口的布局因为切边的存在而进行了扩展，并且窗口的边界超出了安全区域，那么它会调整窗口的位置，使其位于安全区域内。
        if (extendedByCutout &amp;&amp; !displayCutoutSafe.contains(outFrame)) &#123;
            mTempRect.set(outFrame);

            // Move the frame into displayCutoutSafe.
            final int clipFlags = DISPLAY_CLIP_VERTICAL | DISPLAY_CLIP_HORIZONTAL;
            Gravity.applyDisplay(attrs.gravity &amp; ~clipFlags, displayCutoutSafe,
                    mTempRect);

            if (mTempRect.intersect(outDisplayFrame)) &#123;
                outFrame.union(mTempRect);
            &#125;
        &#125;

        if (DEBUG) Log.d(TAG, &quot;computeWindowFrames &quot; + attrs.getTitle()
                + &quot; outFrames=&quot; + outFrames
                + &quot; windowBounds=&quot; + windowBounds.toShortString()
                + &quot; attachedWindowFrame=&quot; + (attachedWindowFrame != null
                        ? attachedWindowFrame.toShortString()
                        : &quot;null&quot;)
                + &quot; requestedWidth=&quot; + requestedWidth
                + &quot; requestedHeight=&quot; + requestedHeight
                + &quot; compatScale=&quot; + compatScale
                + &quot; windowingMode=&quot; + WindowConfiguration.windowingModeToString(windowingMode)
                + &quot; displayCutoutSafe=&quot; + displayCutoutSafe
                + &quot; attrs=&quot; + attrs
                + &quot; state=&quot; + state
                + &quot; requestedVisibilities=&quot; + requestedVisibilities);
  &#125;
</code></pre>
<p>computeFrame方法是WindowState类中的一个重要方法，用于计算窗口的位置和大小。具体来说，它负责计算窗口的绘制区域，即窗口的内容在屏幕上实际显示的位置和大小。这个计算涉及到考虑窗口的位置、大小、布局参数以及可能的边界限制，确保窗口内容不会超出屏幕边界或被其他窗口遮挡。</p>
<p>在窗口管理器中，computeFrame方法通常会在以下情况被调用：</p>
<ul>
<li>当窗口第一次被创建时，需要计算其初始位置和大小。</li>
<li>当窗口的布局参数或内容发生变化时，需要重新计算窗口的位置和大小。</li>
<li>当屏幕旋转或大小变化等系统事件发生时，需要调整所有窗口的位置和大小。</li>
</ul>
<p>总之，computeFrame方法在Android窗口管理系统中起到了非常重要的作用，确保应用程序窗口能够正确地在屏幕上显示，并且适应不同的设备和系统事件, 为了计算小窗的位置，以及处理小窗内的View 的边界异常情况，</p>
<p>再来看看setFrames，更新窗口大小位置变化</p>
<pre><code> win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);
</code></pre>
<p>调用的是WindowState的setFrames方法<br>入参说明：<br><code>sTmpClientFrames</code>：在computeFrames方法计算后的值，用于传递的窗口位置大小相关信息<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    void setFrames(ClientWindowFrames clientWindowFrames, int requestedWidth, int requestedHeight) &#123;
        final WindowFrames windowFrames = mWindowFrames;
        //用mTmpRect存储windowFrames.mParentFrame
        mTmpRect.set(windowFrames.mParentFrame);
        
        //LOCAL_LAYOUTd的值取决于配置项persist.debug.local_layout的值
        if (LOCAL_LAYOUT) &#123;
            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。
            windowFrames.mCompatFrame.set(clientWindowFrames.frame);
            
            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。
            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。
            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。
            windowFrames.mFrame.set(clientWindowFrames.frame);
            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);
            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);
            if (hasCompatScale()) &#123;
                // The frames sent from the client need to be adjusted to the real coordinate space.
                //如果存在兼容比例（通过调用hasCompatScale()方法检查），则对windowFrames中的Frame进行缩放，以适应实际的坐标空间。
                //这里使用mGlobalScale作为缩放因子。
                windowFrames.mFrame.scale(mGlobalScale);
                windowFrames.mDisplayFrame.scale(mGlobalScale);
                windowFrames.mParentFrame.scale(mGlobalScale);
            &#125;
        &#125; else &#123;
            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。
            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。
            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。
            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);
            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);
            windowFrames.mFrame.set(clientWindowFrames.frame);

            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。
            windowFrames.mCompatFrame.set(windowFrames.mFrame);
            if (hasCompatScale()) &#123;
                // Also, the scaled frame that we report to the app needs to be adjusted to be in
                // its coordinate space.
                //仅对windowFrames.mCompatFrame缩放
                windowFrames.mCompatFrame.scale(mInvGlobalScale);
            &#125;
        &#125;
        //isParentFrameClippedByDisplayCutout是一个Boolean
        //如果为true，表示父窗口的边界被显示切边裁剪了；如果为false，表示父窗口的边界没有被显示切边裁剪。
        windowFrames.setParentFrameWasClippedByDisplayCutout(
                clientWindowFrames.isParentFrameClippedByDisplayCutout);

        // Calculate relative frame
        //将mRelFrame设置为与mFrame相同的值。这意味着mRelFrame现在存储了与mFrame相同的位置和尺寸信息。
        windowFrames.mRelFrame.set(windowFrames.mFrame);
        //获取当前窗口的父容器
        WindowContainer&lt;?&gt; parent = getParent();
        //初始化parentLeft和parentTop为0，表示父容器的左上角坐标
        int parentLeft = 0;
        int parentTop = 0; 
        if (mIsChildWindow) &#123;//如果当前窗口是一个子窗口
            //从父窗口的状态中获取其边界的位置信息。
            parentLeft = ((WindowState) parent).mWindowFrames.mFrame.left;
            parentTop = ((WindowState) parent).mWindowFrames.mFrame.top;
        &#125; else if (parent != null) &#123;//如果当前窗口不是子窗口，并且父容器不为空
            //获取父容器的边界位置
            final Rect parentBounds = parent.getBounds();
            parentLeft = parentBounds.left;
            parentTop = parentBounds.top;
        &#125;
        //调整mRelFrame的位置，使其相对于父容器的左上角有一个偏移
        windowFrames.mRelFrame.offsetTo(windowFrames.mFrame.left - parentLeft,
                windowFrames.mFrame.top - parentTop);

        //如果请求的宽度、高度或者父框架与上次不同
        if (requestedWidth != mLastRequestedWidth || requestedHeight != mLastRequestedHeight
                || !mTmpRect.equals(windowFrames.mParentFrame)) &#123;
            //更新最后请求的宽度和高度，并标记内容已更改
            mLastRequestedWidth = requestedWidth;
            mLastRequestedHeight = requestedHeight;
            windowFrames.setContentChanged(true);
        &#125;
        //如果窗口的类型是TYPE_DOCK_DIVIDER，并且边界的位置发生了变化，mMovedByResize标记为true。
        //在分屏的场合，YPE_DOCK_DIVIDER窗口类型用于绘制这个分隔栏，并处理用户的触摸事件以实现大小调整功能。
        if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;
            if (!windowFrames.mFrame.equals(windowFrames.mLastFrame)) &#123;
                mMovedByResize = true;
            &#125;
        &#125;
        
        //如果当前窗口是壁纸，并且框架的宽度或高度发生了变化，更新壁纸的位置。
        if (mIsWallpaper) &#123;
            final Rect lastFrame = windowFrames.mLastFrame;
            final Rect frame = windowFrames.mFrame;
            if (lastFrame.width() != frame.width() || lastFrame.height() != frame.height()) &#123;
                mDisplayContent.mWallpaperController.updateWallpaperOffset(this, false /* sync */);
            &#125;
        &#125;
        
        //更新windowFrames.mFrame
        updateSourceFrame(windowFrames.mFrame);

        //如果定义了LOCAL_LAYOUT，并且还没有边界，更新最后边界的位置。
        if (LOCAL_LAYOUT) &#123;
            if (!mHaveFrame) &#123;
                // The first frame should not be considered as moved.
                updateLastFrames();
            &#125;
        &#125;
        
        //如果存在活动记录，并且当前窗口不是子窗口
        if (mActivityRecord != null &amp;&amp; !mIsChildWindow) &#123;
            //调用mActivityRecord.layoutLetterbox(this);来填充空白区域。也就是Letterbox模式
            mActivityRecord.layoutLetterbox(this);
        &#125;
        //设置mSurfacePlacementNeeded为true。
        mSurfacePlacementNeeded = true;
        //设置mHaveFrame为true，表示已经设置了边界
        mHaveFrame = true;
    &#125;
</code></pre>
<p>其中WindowFrames 是一个表示窗口边框大小和位置的类。<br>WindowFrames 中有一些重要成员变量，用于描述不同的窗口区域。</p>
<p><code>mFrame</code>表示窗口在屏幕上的位置和大小，是窗口管理和界面绘制的基础依据。<br><code>mVisibleFrame</code>表示窗口可见区域的位置和大小，即除去状态栏和导航栏等系统 UI 元素后，窗口实际可以显示的区域。<br><code>mDecorFrame</code>表示窗口装饰区域的位置和大小，即窗口除去实际内容区域外，包含的标题栏、边框、按钮等 UI 元素所占用的空间。<br><code>mDisplayFrame</code>表示整个屏幕的可见区域的位置和大小，也就是说它包含了状态栏和导航栏等系统 UI 元素。</p>
<p>这些成员变量共同描述了窗口在屏幕中的位置和大小，并提供给其他模块使用，比如 WindowManager 和 View 系统。<br>在 Android Framework 中，WindowManagerService 会在每次窗口大小发生变化时，调用 WindowFrames 的 setFrames() 方法，更新这些成员变量的值。</p>
<h4 id="2-3-窗口状态刷新"><a href="#2-3-窗口状态刷新" class="headerlink" title="2.3 窗口状态刷新"></a>2.3 窗口状态刷新</h4><p>当应用端执行measure-layout-draw之后，便会调用<strong>WindowManagerService.finishDrawingWindow</strong>，处理Surface的状态变更并将Surface show出来。<br>首先还是看一下该阶段的流程图，对整个流程有个初步的了解。<br>将整个流程分为三部分：<br>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PENDING，并请求窗口布局。<br>2.mDrawState更新为HAS_DRAW，再次请求窗口布局。<br>3.执行show Surface。</p>
<h5 id="2-3-1-接受客户端请求"><a href="#2-3-1-接受客户端请求" class="headerlink" title="2.3.1 接受客户端请求"></a>2.3.1 接受客户端请求</h5><p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public void finishDrawing(IWindow window,
            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;
        if (DEBUG) Slog.v(TAG_WM, &quot;IWindow finishDrawing called for &quot; + window);
        //调用WMS中的finishDrawingWindow处理
        mService.finishDrawingWindow(this, window, postDrawTransaction, seqId);
    &#125;
</code></pre>
<h5 id="2-3-2-finishDrawingWindow"><a href="#2-3-2-finishDrawingWindow" class="headerlink" title="2.3.2 finishDrawingWindow"></a>2.3.2 finishDrawingWindow</h5><p>1.在WMS中根据客户端的Binder在mWindowMap中获取对应的WindowState。<br>2.调用WindowState.finishDrawing执行mDrawState的状态变更。<br>3.将WindowState.mLayoutNeeded标志位置为true。<br>4.请求进行布局刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    void finishDrawingWindow(Session session, IWindow client,
            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;
        if (postDrawTransaction != null) &#123;
            postDrawTransaction.sanitize();
        &#125;

        final long origId = Binder.clearCallingIdentity();
        try &#123;
            synchronized (mGlobalLock) &#123;
                /*1.根据客户端的Binder在mWindowMap中获取对应的WindowState*/
                WindowState win = windowForClientLocked(session, client, false);
                ProtoLog.d(WM_DEBUG_ADD_REMOVE, &quot;finishDrawingWindow: %s mDrawState=%s&quot;,
                        win, (win != null ? win.mWinAnimator.drawStateToString() : &quot;null&quot;));
                /*2.finishDrawing执行mDrawState的状态更变*/
                if (win != null &amp;&amp; win.finishDrawing(postDrawTransaction, seqId)) &#123;
                    if (win.hasWallpaper()) &#123;
                        win.getDisplayContent().pendingLayoutChanges |=
                                WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                    &#125;
                    /*3.将当前WindowState.mLayoutNeeded置为true*/
                    //该标志位是判断是否进行窗口大小尺寸计算的条件之一
                    win.setDisplayLayoutNeeded();
                    /*4.请求进行布局刷新*/
                    mWindowPlacerLocked.requestTraversal();
                &#125;
            &#125;
        &#125; finally &#123;
            Binder.restoreCallingIdentity(origId);
        &#125;
    &#125;
</code></pre>
<h6 id="1-mDrawState的状态更变"><a href="#1-mDrawState的状态更变" class="headerlink" title="1.mDrawState的状态更变"></a>1.mDrawState的状态更变</h6><p>在finishDrawingWindow中调用WindowState的finishDrawing方法<br><code>win.finishDrawing(postDrawTransaction, seqId)</code><br>这个方法主要调用了WindowStateAnimator的finishDrawingLocked进行状态更变<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>   boolean finishDrawing(SurfaceControl.Transaction postDrawTransaction, int syncSeqId) &#123;
           ......
           //调用WindowStateAnimator.finishDrawingLocked，会将mDrawState的状态更改为COMMIT_DRAW_PENDING
        final boolean layoutNeeded =
                mWinAnimator.finishDrawingLocked(postDrawTransaction, mClientWasDrawingForSync);
        mClientWasDrawingForSync = false;
        // We always want to force a traversal after a finish draw for blast sync.
        return !skipLayout &amp;&amp; (hasSyncHandlers || layoutNeeded);
    &#125;
</code></pre>
<p>我们继续看看WindowStateAnimator中的finishDrawingLocked()方法<br>首先判断mDrawState的状态是否为DRAW_PENDING，在我们创建SurfaceControl时，会将mDrawState状态更新为DRAW_PENDING。因此接下来将状态调整为COMMIT_DRAW_PENDING。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>    boolean finishDrawingLocked(SurfaceControl.Transaction postDrawTransaction,
            boolean forceApplyNow) &#123;
        ......
        boolean layoutNeeded = false;

        if (mDrawState == DRAW_PENDING) &#123;
            ......
            //如果当前状态为DRAW_PENDING，则将mDrawState更变为COMMIT_DRAW_PENDING
            mDrawState = COMMIT_DRAW_PENDING;
            layoutNeeded = true;
        &#125;
        ......
        return layoutNeeded;
    &#125;
</code></pre>
<h6 id="2-请求布局刷新"><a href="#2-请求布局刷新" class="headerlink" title="2.请求布局刷新"></a>2.请求布局刷新</h6><p>在finishDrawingWindow中请求布局刷新<br><code>mWindowPlacerLocked.requestTraversal();</code><br>requestTraversal中主要做了两件事：<br>1.首先将遍历标志为mTraversalSchedule置为true。<br>2.其次发送handle消息mPerformSurfacePlacement</p>
<pre><code>    void requestTraversal() &#123;
        //判断遍历标志mTraversalScheduled是否为true
        if (mTraversalScheduled) &#123;
            return;
        &#125;

        // Set as scheduled even the request will be deferred because mDeferredRequests is also
        // increased, then the end of deferring will perform the request.
        //将遍历标志位置为true
        mTraversalScheduled = true;
        if (mDeferDepth &gt; 0) &#123;
            mDeferredRequests++;
            if (DEBUG) Slog.i(TAG, &quot;Defer requestTraversal &quot; + Debug.getCallers(3));
            return;
        &#125;
        //发送handle消息，处理消息会调用mPerformSurfacePlacement
        mService.mAnimationHandler.post(mPerformSurfacePlacement);
    &#125;
</code></pre>
<p>mPerformSurfacePlacement会新建一个线程调用performSurfacePlacement。<br>performSurfacePlacement方法我们在讲relayoutWindow相关流程的时候讲过，这是执行遍历布局的入口。可以回看下【<strong>2.2.4 计算窗口大小位置中的“1.处理窗口布局循环”</strong>】</p>
<pre><code>    private class Traverser implements Runnable &#123;
        @Override
        public void run() &#123;
            synchronized (mService.mGlobalLock) &#123;
                //调用执行performSurfacePlacement
                performSurfacePlacement();
            &#125;
        &#125;
    &#125;

    private final Traverser mPerformSurfacePlacement = new Traverser();
    
    final void performSurfacePlacement(boolean force) &#123;
        //当mDeferDepth大于0且force为false时，则将延迟布局请求数+1，并直接返回
        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;
            mDeferredRequests++;
            return;
        &#125;
        //将循环的最大次数设置为6次
        int loopCount = 6;
        do &#123;
            //将该标志为设置为false
            mTraversalScheduled = false;
            //执行窗口布局操作
            performSurfacePlacementLoop();
            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);
            loopCount--;
        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局
        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);
        mService.mRoot.mWallpaperActionPending = false;
    &#125;

    private void performSurfacePlacementLoop() &#123;
        //若当前已经进行布局操作，则无需重复调用直接返回
        if (mInLayout) &#123;
            ......
            return;
        &#125;
        ......
        //将该标志位置为true，表示正在处于布局过程中
        mInLayout = true;
        ......
        try &#123;
            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/
            mService.mRoot.performSurfacePlacement();

            mInLayout = false;

            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;

            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;
                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);
                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);
            &#125;
        &#125; catch (RuntimeException e) &#123;
            mInLayout = false;
            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);
        &#125;
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    void performSurfacePlacement() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);
        try &#123;
            //调用performSurfacePlacementNoTrace()
            performSurfacePlacementNoTrace();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;
    // TODO: Super long method that should be broken down...
    void performSurfacePlacementNoTrace() &#123;
        ......
        /*1.如果有焦点变化，更新焦点*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(
                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);
        &#125;
        ......
        
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);
        //开启事务，获取GlobalTransactionWrapper对象
        mWmService.openSurfaceTransaction();
        try &#123;
            /*2.执行窗口尺寸计算，surface状态变更等操作*/
            applySurfaceChangesTransaction();
        &#125; catch (RuntimeException e) &#123;
            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);
        &#125; finally &#123;
            //关闭事务，把事务提交
            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            if (SHOW_LIGHT_TRANSACTIONS) &#123;
                Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);
            &#125;
        &#125;
        ......
        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/
        checkAppTransitionReady(surfacePlacer);
        ......
        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/
        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;
            final DisplayContent displayContent = mChildren.get(displayNdx);
            //判断DisplayContent的壁纸是否需要改变
            if (displayContent.mWallpaperMayChange) &#123;
                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,
                            displayContent.pendingLayoutChanges);
                &#125;
            &#125;
        &#125;
        /*5.在此处理焦点变化*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
                    false /*updateInputWindows*/);
        &#125;
        ......
        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/
        handleResizingWindows();

        if (mWmService.mDisplayFrozen) &#123;
            ProtoLog.v(WM_DEBUG_ORIENTATION,
                    &quot;With display frozen, orientationChangeComplete=%b&quot;,
                    mOrientationChangeComplete);
        &#125;
        if (mOrientationChangeComplete) &#123;
            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;
                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;
                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
            &#125;
            mWmService.stopFreezingDisplayLocked();
        &#125;

        // Destroy the surface of any windows that are no longer visible.
        /*7.销毁不可见的窗口*/
        i = mWmService.mDestroySurface.size();
        if (i &gt; 0) &#123;
            do &#123;
                i--;
                WindowState win = mWmService.mDestroySurface.get(i);
                win.mDestroying = false;
                final DisplayContent displayContent = win.getDisplayContent();
                if (displayContent.mInputMethodWindow == win) &#123;
                    displayContent.setInputMethodWindowLocked(null);
                &#125;
                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;
                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                &#125;
                win.destroySurfaceUnchecked();
            &#125; while (i &gt; 0);
            mWmService.mDestroySurface.clear();
        &#125;
        ......
    &#125;
</code></pre>
<p>​    </p>
<p>这里我们主要关注<code>applySurfaceChangesTransaction();</code>和<code>checkAppTransitionReady(surfacePlacer);</code></p>
<h6 id="窗口位置计算与窗口状态刷新流程不同点"><a href="#窗口位置计算与窗口状态刷新流程不同点" class="headerlink" title="* 窗口位置计算与窗口状态刷新流程不同点"></a>* 窗口位置计算与窗口状态刷新流程不同点</h6><p>可以发现，窗口位置计算流程与窗口状态刷新流程都调用了performSurfacePlacement，两次调用的主要不同点在于：<br>1.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用mApplySurfaceChangesTransaction，处理mDrawState状态。<br>2.窗口状态刷新流程在RootWindowContainer.performSurfacePlacementNoTrace中调用checkAppTransitionReady，处理mDrawState状态变更为HAS_DRAWN，触发Activity过渡动画。<br>3.窗口状态刷新流程在WindowSurfacePlacementLoop.performSurfacePlacementLoop中会调用requestTraversal，请求再次布局。<br>4.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用prepareSurfaces()处理处理surface的位置、大小以及显示等。</p>
<h5 id="2-3-3-mDrawState变更为HAS-DRAW"><a href="#2-3-3-mDrawState变更为HAS-DRAW" class="headerlink" title="2.3.3 mDrawState变更为HAS_DRAW"></a>2.3.3 mDrawState变更为HAS_DRAW</h5><h6 id="1-mApplySurfaceChangesTransaction"><a href="#1-mApplySurfaceChangesTransaction" class="headerlink" title="1.mApplySurfaceChangesTransaction"></a>1.mApplySurfaceChangesTransaction</h6><p>RootWindowContainer的applySurfaceChangesTransaction()方法最终会调用到DisplayContent中调用的applySurfaceChangesTransaction()方法（【2.2.4 计算窗口大小位置】中讲过流程，不再赘述）<br>我们接着该方法中的mApplySurfaceChangesTransaction跟踪。<br><code>forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);</code><br>如果当前WindowState存在surfaceControl，则进入到WindowStateAnimator进行mDrawState的状态更变。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;
        ......
        //首先判断当前windowState的是否有surfaceControl
        if (w.mHasSurface) &#123;
            // Take care of the window being ready to display.
            //调用WindowStateAnimator的commitFinishDrawingLocked()方法
            final boolean committed = winAnimator.commitFinishDrawingLocked();
            ......
        &#125;
        ......
    &#125;;
</code></pre>
<p>继续看看WindowStateAnimator的commitFinishDrawingLocked()方法<br><code>final boolean committed = winAnimator.commitFinishDrawingLocked();</code><br>1.对mDrawState的状态进行过滤，非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回。<br>2.此时我们的mDrawState已经在“<strong>【2.3.2 finishDrawingWindow】</strong>”将状态更新为COMMIT_DRAW_PENDING，因此此处将其变更为READY_TO_SHOW。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>    // This must be called while inside a transaction.
    boolean commitFinishDrawingLocked() &#123;
        //非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回
        if (mDrawState != COMMIT_DRAW_PENDING &amp;&amp; mDrawState != READY_TO_SHOW) &#123;
            return false;
        &#125;
        ProtoLog.i(WM_DEBUG_ANIM, &quot;commitFinishDrawingLocked: mDrawState=READY_TO_SHOW %s&quot;,
                mSurfaceController);
        //将状态更变为READY_TO_SHOW
        mDrawState = READY_TO_SHOW;
        boolean result = false;
        final ActivityRecord activity = mWin.mActivityRecord;
        //直接进入到WindowState.performShowLocked()流程的三种情况
        //1.如果ActivityRecord为空，这种情况可以理解为不依赖Activity的窗口，比如常见的悬浮窗
        //2.或者canShowWindows()为true，这个方法大概是说：只有当所有窗口都已绘制完成，并且没有正在进行父级窗口的应用过渡动画，并且没有非默认颜色的窗口存在时，返回true
        //3.或者窗口类型为启动窗口，启动窗口就是StartingWindow，应用启动时出现的窗口，常见的就是Splash screen ，许多应用都会定义自己的SplashActivity
        //进入performShowLocked()流程后mDrawState更新HAS_DRAWN
        //由于非这三种情况最终也会调用到performShowLocked()，因此下面这种情况我们暂不讨论
        if (activity == null || activity.canShowWindows()
                || mWin.mAttrs.type == TYPE_APPLICATION_STARTING) &#123;
            result = mWin.performShowLocked();
        &#125;
        return result;
    &#125;
</code></pre>
<h6 id="2-checkAppTransitionReady"><a href="#2-checkAppTransitionReady" class="headerlink" title="2.checkAppTransitionReady()"></a>2.checkAppTransitionReady()</h6><p>这里我们继续跟踪RootWindowContainer.performSurfacePlacementNoTrace()方法中的checkAppTransitionReady()方法<br><code>checkAppTransitionReady(surfacePlacer);</code><br>该方法会遍历所有DisplayContent，处理activity的过滤动画，此处我们只有跟踪有关mDrawState状态更变的相关代码<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    private void checkAppTransitionReady(WindowSurfacePlacer surfacePlacer) &#123;
        // Trace all displays app transition by Z-order for pending layout change.
        for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123;
            final DisplayContent curDisplay = mChildren.get(i);

            // If we are ready to perform an app transition, check through all of the app tokens
            // to be shown and see if they are ready to go.
            //检查所有要显示的app token，是否已经准备就绪
            if (curDisplay.mAppTransition.isReady()) &#123;
                // handleAppTransitionReady may modify curDisplay.pendingLayoutChanges.
                curDisplay.mAppTransitionController.handleAppTransitionReady();
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;after handleAppTransitionReady&quot;,
                            curDisplay.pendingLayoutChanges);
                &#125;
            &#125;
            ......
        &#125;
    &#125;
</code></pre>
<p>调用AppTransitionController的handleAppTransitionReady()方法，该方法主要做了以下事情<br>1.处理activity的过渡动画（远程动画）<br>2.分别调用 handleClosingApps以及handleOpeningApps对要关闭的和要打开的Activity进行可见性更新。<br>3.由于activity的可见性变更，将DisplayContent.mLayoutNeeded设置为true，该标志位在DisplayContent.performLayoutNoTrace中用来判断是否对当前DisplayContent下的所有窗口进行刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;AppTransitionController.java</p>
<pre><code>    /**
     * Handle application transition for given display.
     */
    void handleAppTransitionReady() &#123;
        ......
        try &#123;
            /*1.1应用app transition动画（远程动画）*/
            applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,
                    voiceInteraction);
            /*1.2处理closing activity可见性*/
            handleClosingApps();
            /*1.3处理opening actvity可见性*/
            handleOpeningApps();
            ......
        &#125; finally &#123;
            mService.mSurfaceAnimationRunner.continueStartingAnimations();
        &#125;
        ......

        // This has changed the visibility of windows, so perform
        // a new layout to get them all up-to-date.
        /*2.由于activity的可见性变更，将DisplayContent.mLayoutNeeded标志位置为true*/
        mDisplayContent.setLayoutNeeded();
        ......
    &#125;
</code></pre>
<p><strong>applyAnimations()</strong><br>基于一组ActivityRecord来应用动画，这些ActivityRecord表示正在进行切换的应用程序。<br><code>applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,voiceInteraction);</code></p>
<pre><code>    /**
     * Apply an app transition animation based on a set of &#123;@link ActivityRecord&#125;
     *
     * @param openingApps The list of opening apps to which an app transition animation applies.
     * @param closingApps The list of closing apps to which an app transition animation applies.
     * @param transit The current transition type.
     * @param animLp Layout parameters in which an app transition animation runs.
     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice
     *                         interaction session driving task.
     */
    private void applyAnimations(ArraySet&lt;ActivityRecord&gt; openingApps,
            ArraySet&lt;ActivityRecord&gt; closingApps, @TransitionOldType int transit,
            LayoutParams animLp, boolean voiceInteraction) &#123;
        //方法检查过渡类型是否未设置，或者打开和关闭的应用程序是否都为空。如果是，则方法直接返回，不执行任何动画。
        if (transit == WindowManager.TRANSIT_OLD_UNSET
                || (openingApps.isEmpty() &amp;&amp; closingApps.isEmpty())) &#123;
            return;
        &#125;

        //调用getAnimationTargets方法获取打开和关闭的窗口容器（WindowContainer）
        final ArraySet&lt;WindowContainer&gt; openingWcs = getAnimationTargets(
                openingApps, closingApps, true /* visible */);
        final ArraySet&lt;WindowContainer&gt; closingWcs = getAnimationTargets(
                openingApps, closingApps, false /* visible */);
        //打开和关闭的窗口应用动画。这是通过调重载的applyAnimations方法完成的，传递相应的参数，如动画的目标、过渡类型等。
        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,
                voiceInteraction);
        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,
                voiceInteraction);
        //如果存在最近任务动画控制器（RecentsAnimationController），则发送任务出现任务
        final RecentsAnimationController rac = mService.getRecentsAnimationController();
        if (rac != null) &#123;
            rac.sendTasksAppeared();
        &#125;

        //遍历打开和关闭的应用程序，并设置mOverrideTaskTransition为false
        for (int i = 0; i &lt; openingApps.size(); ++i) &#123;
            openingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;
        &#125;
        for (int i = 0; i &lt; closingApps.size(); ++i) &#123;
            closingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;
        &#125;

        //如果存在辅助功能控制器（AccessibilityController）且有回调，则调用其onAppWindowTransition方法。
        final AccessibilityController accessibilityController =
                mDisplayContent.mWmService.mAccessibilityController;
        if (accessibilityController.hasCallbacks()) &#123;
            accessibilityController.onAppWindowTransition(mDisplayContent.getDisplayId(), transit);
        &#125;
    &#125;
</code></pre>
<p>入参含义：<br><code>openingApps</code> 和 <code>closingApps</code>: 这两个参数是ActivityRecord类型的数组，分别表示正在打开和关闭的应用程序，即这些ActivityRecord表示正在进行切换的应用程序。<br><code>transit</code>: 这是一个整型参数，表示过渡类型。例如，WindowManager.TRANSIT_OLD_UNSET表示没有特定的过渡类型。<br><code>animLp</code>: 这是一个LayoutParams对象，用于定义窗口的布局参数。<br><code>voiceInteraction</code>: 一个布尔值，表示是否为语音交互。</p>
<p>总而言之，该方法主要负责处理应用程序窗口的打开和关闭动画。它确保应用程序在切换时有一个平滑的视觉效果，为用户提供更好的体验。最后还与辅助功能服务交互，确保辅助功能用户也能正确地感知应用程序窗口的切换。</p>
<p>再来说说其中调用的applyAnimations方法部分</p>
<pre><code>        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,
                voiceInteraction);
        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,
                voiceInteraction);
</code></pre>
<p>调用的是重载的applyAnimations方法</p>
<pre><code>      /**
     * Apply animation to the set of window containers.
     *
     * @param wcs The list of &#123;@link WindowContainer&#125;s to which an app transition animation applies.
     * @param apps The list of &#123;@link ActivityRecord&#125;s being transitioning.
     * @param transit The current transition type.
     * @param visible &#123;@code true&#125; if the apps becomes visible, &#123;@code false&#125; if the apps becomes
     *                invisible.
     * @param animLp Layout parameters in which an app transition animation runs.
     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice
     *                         interaction session driving task.
     */
    private void applyAnimations(ArraySet&lt;WindowContainer&gt; wcs, ArraySet&lt;ActivityRecord&gt; apps,
            @TransitionOldType int transit, boolean visible, LayoutParams animLp,
            boolean voiceInteraction) &#123;
        //获取窗口容器的数量
        final int wcsCount = wcs.size();
        //遍历每一个窗口容器
        for (int i = 0; i &lt; wcsCount; i++) &#123;
            final WindowContainer wc = wcs.valueAt(i);
            // If app transition animation target is promoted to higher level, SurfaceAnimator
            // triggers WC#onAnimationFinished only on the promoted target. So we need to take care
            // of triggering AR#onAnimationFinished on each ActivityRecord which is a part of the
            // app transition.
            //对于每一个窗口容器，检查正在进行切换的应用程序（apps）中哪些是该窗口容器的后代。
            //这些后代应用程序将被添加到一个列表中。
            final ArrayList&lt;ActivityRecord&gt; transitioningDescendants = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt; apps.size(); ++j) &#123;
                final ActivityRecord app = apps.valueAt(j);
                if (app.isDescendantOf(wc)) &#123;
                    transitioningDescendants.add(app);
                &#125;
            &#125;
            //调用每个窗口容器的applyAnimation方法，传入相应的参数（如动画的布局参数、过渡类型、是否可见等）以及后代应用程序的列表。
            wc.applyAnimation(animLp, transit, visible, voiceInteraction, transitioningDescendants);
        &#125;
    &#125;
</code></pre>
<p>入参含义：<br><code>wcs</code>: 一个WindowContainer对象的集合，这些对象是需要应用动画的窗口容器。<br><code>apps</code>: 一个ActivityRecord对象的集合，这些对象表示正在进行切换的应用程序。<br><code>transit</code>: 当前的过渡类型，例如淡入淡出、滑动等。<br><code>visible</code>: 一个布尔值，表示应用程序是否变为可见。<br><code>animLp</code>: 布局参数，定义了动画运行时的布局。<br><code>voiceInteraction</code>: 一个布尔值，表示是否有语音交互。</p>
<p>这部分远程动画流程，这里不做重点</p>
<p><strong>handleClosingApps()</strong><br>该方法中主要的作用就是将所有即将close的activity的mVisible标志设置为false。该标志位在后续prepareSurfaces中是判断是否show surface的条件之一。</p>
<pre><code>   private void handleClosingApps() &#123;
        final ArraySet&lt;ActivityRecord&gt; closingApps = mDisplayContent.mClosingApps;
        final int appsCount = closingApps.size();

        for (int i = 0; i &lt; appsCount; i++) &#123;
            final ActivityRecord app = closingApps.valueAt(i);
            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now closing app %s&quot;, app);
            //设置activity的可见性，将mVisible设置为false
            app.commitVisibility(false /* visible */, false /* performLayout */);
            app.updateReportedVisibilityLocked();
            // Force the allDrawn flag, because we want to start
            // this guy&#39;s animations regardless of whether it&#39;s
            // gotten drawn.
            //强制将allDrawn设置为true
            app.allDrawn = true;
            ......
        &#125;
    &#125;
</code></pre>
<p><strong>handleOpeningApps()</strong><br>该方法与handleClosingApps方法类似,主要处理两件事情：<br>1.将所有即将open的activity的mVisible标志位设置为true.<br>2.调用ActivityRecord.showAllWindowsLocked()，最终会调用到WindowState.performShowLocked() ，处理mDrawState的状态变更</p>
<pre><code>    private void handleOpeningApps() &#123;
        final ArraySet&lt;ActivityRecord&gt; openingApps = mDisplayContent.mOpeningApps;
        final int appsCount = openingApps.size();

        for (int i = 0; i &lt; appsCount; i++) &#123;
            final ActivityRecord app = openingApps.valueAt(i);
            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now opening app %s&quot;, app);
            /*1.设置activity的可见性，将mVisible设置为true*/
            app.commitVisibility(true /* visible */, false /* performLayout */);
            ......
            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
                    &quot;&gt;&gt;&gt; OPEN TRANSACTION handleAppTransitionReady()&quot;);
            //开启事务
            mService.openSurfaceTransaction();
            try &#123;
                /*2.此方法最终会调用到WindowState.performShowLocked*/
                app.showAllWindowsLocked();
            &#125; finally &#123;
            //关闭事务
            mService.closeSurfaceTransaction(&quot;handleAppTransitionReady&quot;);
                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION handleAppTransitionReady()&quot;);
            &#125;
            ......
        &#125;
    &#125;
</code></pre>
<p><code>app.showAllWindowsLocked();</code>先调用到ActivityRecord的showAllWindowsLocked()<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p>
<pre><code>    /**
     * This must be called while inside a transaction.
     */
    void showAllWindowsLocked() &#123;
        forAllWindows(windowState -&gt; &#123;
            if (DEBUG_VISIBILITY) Slog.v(TAG, &quot;performing show on: &quot; + windowState);
            windowState.performShowLocked();
        &#125;, false /* traverseTopToBottom */);
    &#125;
</code></pre>
<p><code>windowState.performShowLocked();</code>再调用到WindowState的performShowLocked()<br>将mDrawState的状态由READY_TO_SHOW变更为HAS_DRAW<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    // This must be called while inside a transaction.
    boolean performShowLocked() &#123;
        ......
        //获取WindowStateAnimator.mDrawState
        final int drawState = mWinAnimator.mDrawState;
        //这里判断（drawState 状态为HAS_DRAWN 或者READY_TO_SHOW）且ActivityRecord不为空
        if ((drawState == HAS_DRAWN || drawState == READY_TO_SHOW) &amp;&amp; mActivityRecord != null) &#123;
            //窗口类型不为启动窗口
            if (mAttrs.type != TYPE_APPLICATION_STARTING) &#123;
                mActivityRecord.onFirstWindowDrawn(this);
            &#125; else &#123;
                mActivityRecord.onStartingWindowDrawn();
            &#125;
        &#125;
        //如果当前mDrawState的状态不为READY_TO_SHOW ，则直接返回
        if (mWinAnimator.mDrawState != READY_TO_SHOW || !isReadyForDisplay()) &#123;
            return false;
        &#125;
        ......
        //走入窗口动画流程
        mWinAnimator.applyEnterAnimationLocked();
        
        // Force the show in the next prepareSurfaceLocked() call.
        mWinAnimator.mLastAlpha = -1;
        ProtoLog.v(WM_DEBUG_ANIM, &quot;performShowLocked: mDrawState=HAS_DRAWN in %s&quot;, this);
        //设置mDrawState的状态为HAS_DRAWN
        mWinAnimator.mDrawState = HAS_DRAWN;
        mWmService.scheduleAnimationLocked();
        ......
        return true;
    &#125;
</code></pre>
<p>添加窗口时，会调用这个<code>mWinAnimator.applyEnterAnimationLocked();</code>窗口动画的方法，然后调用到<code>applyAnimationLocked()</code>；窗口移除时，会直接调用<code>applyAnimationLocked()</code>显示动画。可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/134289284?spm=1001.2014.3001.5502">Android T窗口动画显示和退出流程</a></p>
<h6 id="3-再次请求布局"><a href="#3-再次请求布局" class="headerlink" title="3.再次请求布局"></a>3.再次请求布局</h6><p>回到WindowSurfacePlacer中通过requestTraversals()，再次请求布局，该方法将mTraversalScheduled标志位设置为true的判断条件有两个：<br>1.遍历所有DisplayContent.mLayoutNeeded标志为是否为true。（由于AppTransitionController.handleAppTransitionReady阶段已经将mLayoutNeeded置为true，因此该条件为真）<br>2.重复布局的次数不能超过6次，该条件也为真。（因为当前还只是第一次布局)<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p>
<pre><code>    private void performSurfacePlacementLoop() &#123;
        ......
        try &#123;
            ......
            /*1.遍历所有DisplayContent.mLayoutNeeded标志位是否为true*/
            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.如果需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;
            ......
        &#125; catch (RuntimeException e) &#123;
        ......
        &#125;
    &#125;
</code></pre>
<p>接下来进入<strong>第二次布局循环</strong>，其主要目的是为了show surface</p>
<h5 id="2-3-4-show-Surface"><a href="#2-3-4-show-Surface" class="headerlink" title="2.3.4 show Surface"></a>2.3.4 show Surface</h5><p>在第二次循环中，我们主要关注DisplayContent中applySurfaceChangesTransaction()方法调用的prepareSurfaces()</p>
<p>该方法最终会调用到根容器WindowContainer，来遍历所有子容器中的prepareSurfaces。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    @Override
    void prepareSurfaces() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;prepareSurfaces&quot;);
        try &#123;
            //获取事务
            final Transaction transaction = getPendingTransaction();
            //调用其父类方法
            super.prepareSurfaces();

            // TODO: Once we totally eliminate global transaction we will pass transaction in here
            //       rather than merging to global.
            SurfaceControl.mergeToGlobalTransaction(transaction);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;
</code></pre>
<p>调用其父类方法<code>super.prepareSurfaces();</code><br>DisplayContent的父类为WindowContainer<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>    void prepareSurfaces() &#123;
        // If a leash has been set when the transaction was committed, then the leash reparent has
        // been committed.
        mCommittedReparentToAnimationLeash = mSurfaceAnimator.hasLeash();
        //调用所有子容器中的prepareSurfaces
        for (int i = 0; i &lt; mChildren.size(); i++) &#123;
            mChildren.get(i).prepareSurfaces();
        &#125;
    &#125;
</code></pre>
<p><code>mChildren.get(i).prepareSurfaces();</code>在WindowState.prepareSurfaces中，主要做了两方面工作。<br>1.将mWindowFrames中计算出来的left以及top设置surface位置，并调整窗口比例。<br>2.控制surface的可见性，查看WindowStateAnimator.prepareSurfaceLocked<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    void prepareSurfaces() &#123;
        mIsDimming = false;
        applyDims();
        //实际调用的是其父类WindowContainer的方法
        /*1.最终调用自身的updateSurfacePosition()（自身有重写该方法）计算surface的位置*/
        updateSurfacePositionNonOrganized();
        // Send information to SurfaceFlinger about the priority of the current window.
        updateFrameRateSelectionPriorityIfNeeded();
        //更新窗口比例
        updateScaleIfNeeded();

        /*2.控制surface的可见性，调用WindowStateAnimator的prepareSurfaceLocked()方法*/
        mWinAnimator.prepareSurfaceLocked(getSyncTransaction());
        super.prepareSurfaces();
    &#125;
    
    @Override
    @VisibleForTesting
    void updateSurfacePosition(Transaction t) &#123;
        if (mSurfaceControl == null) &#123;
            return;
        &#125;

        //这段代码首先检查布局是否被延迟（通过 isLayoutDeferred() 方法）
        //或者应用是否正在进行布局（通过 isGoneForLayout() 方法）。
        //如果满足这些条件并且 mSurfacePlacementNeeded 为 false，则方法返回，不执行后续操作。
        //这是因为当布局被延迟或应用正在进行布局时，界面的位置可能不是最新的，因此不执行updateSurfacePosition。
        if ((mWmService.mWindowPlacerLocked.isLayoutDeferred() || isGoneForLayout())
                &amp;&amp; !mSurfacePlacementNeeded) &#123;
            // Since this relies on mWindowFrames, changes made while layout is deferred are
            // likely to be invalid. Similarly, if it&#39;s goneForLayout, mWindowFrames may not be
            // up-to-date and thus can&#39;t be relied on.
            return;
        &#125;
        
        //将mSurfacePlacementNeeded设置为false
        mSurfacePlacementNeeded = false;
        //将mSurfacePosition的left以及top设置mWindowFrames中计算出来的left以及top，并根据parent进行偏移
        transformFrameToSurfacePosition(mWindowFrames.mFrame.left, mWindowFrames.mFrame.top,
                mSurfacePosition);
        //根据壁纸的比例对SurfacePosition进行调整
        if (mWallpaperScale != 1f) &#123;
            final Rect bounds = getLastReportedBounds();
            Matrix matrix = mTmpMatrix;
            matrix.setTranslate(mXOffset, mYOffset);
            matrix.postScale(mWallpaperScale, mWallpaperScale, bounds.exactCenterX(),
                    bounds.exactCenterY());
            matrix.getValues(mTmpMatrixArray);
            mSurfacePosition.offset(Math.round(mTmpMatrixArray[Matrix.MTRANS_X]),
                Math.round(mTmpMatrixArray[Matrix.MTRANS_Y]));
        &#125; else &#123;
            mSurfacePosition.offset(mXOffset, mYOffset);
        &#125;
        ......
    &#125;
</code></pre>
<p><code>mWinAnimator.prepareSurfaceLocked(getSyncTransaction());</code> 调用WindowStateAnimator的prepareSurfaceLocked()方法，该则真正的处理触发surface show的逻辑。主要分为两部分。<br>1.将计算的alpha应用于当前surface。<br>2.判断是否调用showSurfaceRobustlyLocked将surface show出来。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>   void prepareSurfaceLocked(SurfaceControl.Transaction t) &#123;
        final WindowState w = mWin;
        //首先判断是否有SurfaceControl
        if (!hasSurface()) &#123;
            ......
            return;
        &#125;
        //设置mShowAlpha
        computeShownFrameLocked();

        //判断parentWindow是否hidden，或者当前窗口是否on-screen
        if (w.isParentWindowHidden() || !w.isOnScreen()) &#123;
            ......
        &#125; else if (mLastAlpha != mShownAlpha
                || mLastHidden) &#123;
            mLastAlpha = mShownAlpha;
            ProtoLog.i(WM_SHOW_TRANSACTIONS,
                    &quot;SURFACE controller=%s alpha=%f HScale=%f, VScale=%f: %s&quot;,
                    mSurfaceController, mShownAlpha, w.mHScale, w.mVScale, w);
            /*1.设置surface的alpha*/
            boolean prepared =
                mSurfaceController.prepareToShowInTransaction(t, mShownAlpha);
            //如果当前状态为HAS_DRAWN
            if (prepared &amp;&amp; mDrawState == HAS_DRAWN) &#123;
                if (mLastHidden) &#123;
                /*2.触发show surface*/
                    if (showSurfaceRobustlyLocked(t)) &#123;
                        mAnimator.requestRemovalOfReplacedWindows(w);
                        //设置mLastHidden为false
                        mLastHidden = false;
                        .......
                    &#125; else &#123;
                        w.setOrientationChanging(false);
                    &#125;
                &#125;
            &#125;
        &#125; else &#123;
            if (mWin.isAnimating(TRANSITION | PARENTS)) &#123;
                ProtoLog.v(WM_DEBUG_ANIM, &quot;prepareSurface: No changes in animation for %s&quot;, this);
            &#125;
        &#125;

        ......
    &#125;
</code></pre>
<p>从上述代码中可以看出触发showSurfaceRobustlyLocked的判断条件有以下几点：<br>1.w.isParentWindowHidden判断其parent的mHidden是否为true，此时当前窗口没有parent直接返回false<br>2.w.isOnScreen，判断当前窗口是否在屏幕上，如果该窗口mVisible为true或者在不可见之前正在运行动画，判断为在屏幕上。我们在上次布局的AppTransitionController.handleAppTransitionReady阶段将当前窗口的mVisible置为了true，因此w.isOnScreen返回true。<br>3.mLastAlpha !&#x3D; mShownAlpha以及mLastHidden满足其一即可，此处我们分析mLastHidden，该标志位在创建SurfaceControl或者hide surface时会被置为true，因为当前窗口才刚刚被创建，因此mLastHidden为true。<br>经过以上判断可以得出我们顺利触发showSurfaceRobustlyLocked<br>后面通过WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController</p>
<pre><code>    /**
     * Have the surface flinger show a surface, robustly dealing with
     * error conditions.  In particular, if there is not enough memory
     * to show the surface, then we will try to get rid of other surfaces
     * in order to succeed.
     *
     * @return Returns true if the surface was successfully shown.
     */
    private boolean showSurfaceRobustlyLocked(SurfaceControl.Transaction t) &#123;
        //WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController
        //调用WindowSurfaceController的showRobustly方法
        boolean shown = mSurfaceController.showRobustly(t);
        //如果没有成功返回false
        if (!shown)
            return false;

        t.merge(mPostDrawTransaction);
        return true;
    &#125;
</code></pre>
<p>在WindowSurfaceController中，首先判断标志位mSurfaceShown，若为true则直接返回；若为false，则将mSurfaceShown置为true，并调用SurfaceControl.show。至此真正的绘图已经显示出来，但是否真正的被用户看见，还需要看其parent是否被show。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p>
<pre><code>    boolean showRobustly(SurfaceControl.Transaction t) &#123;
        ......

        //首先判断surface是否已经shown
        if (mSurfaceShown) &#123;
            return true;
        &#125;
        //将mSurfaceShown设置为true
        setShown(true);
        //调用SurfceControl中的show方法，将surface show出来
        t.show(mSurfaceControl);
        if (mAnimator.mIsWallpaper) &#123;
            EventLog.writeEvent(EventLogTags.WM_WALLPAPER_SURFACE,
                    mAnimator.mWin.getDisplayId(), 1 /* request shown */);
        &#125;
        return true;
    &#125;
</code></pre>
<p>从SurfaceControl的创建以及show的流程上看，可以发现WMS是通过WindowSurfaceController对SurfaceControl进行管理的。<br>最后我们看一下SurfaceControl中的show方法<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>        /**
         * Request that a given surface and it&#39;s sub-tree be shown.
         *
         * @param sc The surface to show.
         * @return This transaction.
         * @hide
         */
        @UnsupportedAppUsage
        public Transaction show(SurfaceControl sc) &#123;
            checkPreconditions(sc);
            nativeSetFlags(mNativeObject, sc.mNativeObject, 0, SURFACE_HIDDEN);
            return this;
        &#125;
</code></pre>
<h4 id="2-4-performSurfacePlacement-流程总结"><a href="#2-4-performSurfacePlacement-流程总结" class="headerlink" title="2.4 performSurfacePlacement()流程总结"></a>2.4 performSurfacePlacement()流程总结</h4><p><img src="/../../../../../images/0b16f1c79359438783f3ed8e5f94ce84.png" alt="在这里插入图片描述"><br>在“【<strong>2.2 窗口位置计算</strong>】”以及“【<strong>2.3 窗口状态刷新</strong>】”部分均调用了WindowSurfacePlacer.performSurfacePlacement()，实际上任何窗口属性变化都会触发该方法，但我们在performSurfacePlacement中只关注了窗口位置大小计算以及窗口状态变更的相关流程。此处再对该流程进行简单的梳理。<br>当调用到WindowSurfacePlacer.performSurfacePlacement()时首先会执行“<strong>1</strong>”更新所有窗口的大小以及状态信息，在执行“<strong>2</strong>”处理是否在此调用执行performSurfacePlacement。<br><strong>1.1.1</strong>：主要调用computeFrames，计算窗口的尺寸大小。<br><strong>1.1.2</strong>：主要处理mDrawState的状态变更，在commitFinishDrawingLocked中会将处于DRAW_PENDING状态的mDrawState更新为COMMIT_DRAW_PENDING。<br><strong>1.1.3</strong>：主要根据computerFrames中计算出来的窗口大小来设置Surface的位置，并调用SurfaceControl.show()将窗口show出来。<br><strong>1.2</strong>：将处于COMMIT_DRAW_PENDING状态的mDrawState更新为READY_TO_SHOW，并将DisplayContent.mLayoutNeeded设置为true。在“<strong>2</strong>”中会判断该标志位来处理是否再次调用performSurfacePlacement的操作。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/3.窗口层级_层级结构树添加窗口" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/">WMSAMS</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>尚未添加窗口的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树，如图<br><img src="/../../../../../images/52bf50fb1c174a14809994182587a19e.png" alt="在这里插入图片描述">DisplayArea层级结构中的每一个DisplayArea，都包含着一个层级值范围，这个层级值范围表明了这个DisplayArea可以容纳哪些类型的窗口。<br>每种窗口类型，都可以通过WindowManagerPolicy.getWindowLayerFromTypeLw方法，返回一个相应的层级值。</p>
<pre><code>/**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.
     */
    default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;
        return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow,
                false /* roundedCornerOverlay */);
    &#125;

    /**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @param roundedCornerOverlay 
</code></pre>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/2.窗口层级 _层级结构树的构建" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/">WMSAMS</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>如何通过dump中的内容找到对应的代码？<br>我们dump窗口层级发现会有很多信息，<code>adb shell dumpsys activity containers</code><br><img src="/../../../../../images/555fb894ede74f2eaa1c225401c5b842.png" alt="在这里插入图片描述">这里我们以其中的DefaultTaskDisplayArea为例</p>
<p><img src="/../../../../../images/97cd0ef57f694c56ac83261890469dd0.png" alt="在这里插入图片描述">在源码的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=framework&spm=1001.2101.3001.7020">framework</a>目录下查找该字符串，找到对应的代码就可以通过打印堆栈或者搜索代码跟踪的方式找到其调用逻辑</p>
<pre><code>final TaskDisplayArea defaultTaskDisplayArea = 
            new TaskDisplayArea(content, wmService,
            &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
</code></pre>
<p>也就是这一句</p>
<p>当然我们上篇文章也讲到了DisplayContent代表的屏幕的DisplayArea层级结构的根节点，我们可以直接从DisplayContent.java的构造方法出发，追踪其流程</p>
<h2 id="DisplayContent初始化"><a href="#DisplayContent初始化" class="headerlink" title="DisplayContent初始化"></a>DisplayContent初始化</h2><p>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>/**
     * Create new &#123;@link DisplayContent&#125; instance, add itself to the root window container and
     * initialize direct children.
     * @param display May not be null.
     * @param root &#123;@link RootWindowContainer&#125;
     */
    DisplayContent(Display display, RootWindowContainer root) &#123;
        super(root.mWindowManager, &quot;DisplayContent&quot;, FEATURE_ROOT);
        ......
        final Transaction pendingTransaction = getPendingTransaction();
        configureSurfaces(pendingTransaction);
        pendingTransaction.apply();
        ......
    &#125;
</code></pre>
<p>创建新的DisplayContent实例，将其自身添加到根窗口容器并初始化直接子级<br><strong>FEATURE_ROOT，对应DisplayContent，一个屏幕上的根DisplayArea，也就是dump中的Display节点。</strong><br><img src="/../../../../../images/653d5a70093f4f4a8d6938e860f90e5d.png" alt="在这里插入图片描述"></p>
<p>这里我们主要关注一下<code>configureSurfaces(pendingTransaction);</code></p>
<pre><code> /**
     * Configures the surfaces hierarchy for DisplayContent
     * This method always recreates the main surface control but reparents the children
     * if they are already created.
     * @param transaction as part of which to perform the configuration
     */
    private void configureSurfaces(Transaction transaction) &#123;
        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(mSession)
                .setOpaque(true)
                .setContainerLayer()
                .setCallsite(&quot;DisplayContent&quot;);
        mSurfaceControl = b.setName(getName()).setContainerLayer().build();

        if (mDisplayAreaPolicy == null) &#123;
            // Setup the policy and build the display area hierarchy.
            // Build the hierarchy only after creating the surface so it is reparented correctly
            mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                    mWmService, this /* content */, this /* root */,
                    mImeWindowsContainer);
        &#125;
        ......
       
    &#125;
</code></pre>
<p>通过DisplayContent来配置图层结构</p>
<h2 id="DisplayAreaPolicy初始化"><a href="#DisplayAreaPolicy初始化" class="headerlink" title="DisplayAreaPolicy初始化"></a>DisplayAreaPolicy初始化</h2><p>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicy.java</p>
<pre><code>mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
        mWmService, this /* content */, this /* root */,
        mImeWindowsContainer)
</code></pre>
<p>调用DisplayAreaPolicy中的Provider接口instantiate方法，去初始化一个DisplayArea层级结构<br><strong>记住这边传递的参数，后面代码需要结合起来看</strong></p>
<h3 id="DisplayAreaPolicy-Provider"><a href="#DisplayAreaPolicy-Provider" class="headerlink" title="DisplayAreaPolicy.Provider"></a>DisplayAreaPolicy.Provider</h3><pre><code>    /**
     * Provider for &#123;@link DisplayAreaPolicy&#125; instances.
     *
     * &lt;p&gt;By implementing this interface and overriding the
     * &#123;@code config_deviceSpecificDisplayAreaPolicyProvider&#125;, a device-specific implementations
     * of &#123;@link DisplayAreaPolicy&#125; can be supplied.
     */
    public interface Provider &#123;
        /**
         * Instantiates a new &#123;@link DisplayAreaPolicy&#125;. It should set up the &#123;@link DisplayArea&#125;
         * hierarchy.
         *
         * @see DisplayAreaPolicy#DisplayAreaPolicy
         */
        DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content,
                RootDisplayArea root, DisplayArea.Tokens imeContainer);
</code></pre>
<p>用来实例化一个DisplayAreaPolicy对象，这个对象应该建立起DisplayArea层级结构，实际走到的则是DisplayAreaPolicy.Provider的实现类DisplayAreaPolicy.DefaultProvider.instantiate方法</p>
<h3 id="DisplayAreaPolicy-DefaultProvider"><a href="#DisplayAreaPolicy-DefaultProvider" class="headerlink" title="DisplayAreaPolicy.DefaultProvider"></a>DisplayAreaPolicy.DefaultProvider</h3><pre><code> /** Provider for platform-default display area policy. */
    static final class DefaultProvider implements DisplayAreaPolicy.Provider &#123;
        @Override
        public DisplayAreaPolicy instantiate(WindowManagerService wmService,
                DisplayContent content, RootDisplayArea root,
                DisplayArea.Tokens imeContainer) &#123;
             //1.创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中
            final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                    &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
            final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();
            tdaList.add(defaultTaskDisplayArea);

            // Define the features that will be supported under the root of the whole logical
            // display. The policy will build the DisplayArea hierarchy based on this.
            //2.创建HierarchyBuilder
            final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
            // Set the essential containers (even if the display doesn&#39;t support IME).
            //3.1添加ImeContainer到HierarchyBuilder
            //3.2创建并保存默认TaskDisplayArea到HierarchyBuilder
            rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
            if (content.isTrusted()) &#123;
                // Only trusted display can have system decorations.
                //4.为HierarchyBuilder添加Feature
                configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
            &#125;

            // Instantiate the policy with the hierarchy defined above. This will create and attach
            // all the necessary DisplayAreas to the root.
            //5.生成DisplayArea层级结构
            return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
        &#125;
</code></pre>
<p>我们先了解下DisplayArea.Tokens的构造方法</p>
<pre><code>        Tokens(WindowManagerService wms, Type type, String name) &#123;
            this(wms, type, name, FEATURE_WINDOW_TOKENS);
        &#125;
</code></pre>
<p><strong>FEATURE_WINDOW_TOKENS，容纳非activity窗口的DisplayArea，dump中对应着ImeContainer、WindowToken等</strong><br>这里DefaultProvider实现了这个接口。<br>这个方法主要干了这几件事情：</p>
<h4 id="1-初始化TaskDisplayArea"><a href="#1-初始化TaskDisplayArea" class="headerlink" title="1.初始化TaskDisplayArea"></a>1.初始化TaskDisplayArea</h4><pre><code>final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
        &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();
tdaList.add(defaultTaskDisplayArea);
</code></pre>
<p><strong>FEATURE_DEFAULT_TASK_CONTAINER，容纳默认Task容器的DisplayArea，dump中正是以“DefaultTaskDisplayArea”命名</strong><br>创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中</p>
<h4 id="2-创建HierarchyBuilder"><a href="#2-创建HierarchyBuilder" class="headerlink" title="2.创建HierarchyBuilder"></a>2.创建HierarchyBuilder</h4><pre><code>final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
</code></pre>
<p>HierarchyBuilder是什么？是用来定义在整个逻辑显示的根里面所需的一些Feature<br>HierarchyBuilder是在DisplayAreaPolicyBuilder中定义的<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>    /**
     *  Builder to define &#123;@link Feature&#125; and &#123;@link DisplayArea&#125; hierarchy under a
     * &#123;@link RootDisplayArea&#125;
     */
    static class HierarchyBuilder &#123;
        private static final int LEAF_TYPE_TASK_CONTAINERS = 1;
        private static final int LEAF_TYPE_IME_CONTAINERS = 2;
        private static final int LEAF_TYPE_TOKENS = 0;

        private final RootDisplayArea mRoot;
        private final ArrayList&lt;DisplayAreaPolicyBuilder.Feature&gt; mFeatures = new ArrayList&lt;&gt;();
        private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;();
        @Nullable
        private DisplayArea.Tokens mImeContainer;

        HierarchyBuilder(RootDisplayArea root) &#123;
            mRoot = root;
        &#125;
        ......
    &#125;
</code></pre>
<p>从代码中我们可以看出，HierarchyBuilder用来构建一个DisplayArea层级结构，该层级结构的根节点<br>其构造方法<code>HierarchyBuilder(RootDisplayArea root)</code>传入的是RootDisplayArea的对象。<br>结合前面的<code>configureSurfaces</code>方法中我们可以发现传入的是DisplayContent，即HierarchyBuilder以DisplayContent对象为根节点，生成一个DisplayArea层级结构。</p>
<h4 id="3-1添加ImeContainer到HierarchyBuilder"><a href="#3-1添加ImeContainer到HierarchyBuilder" class="headerlink" title="3.1添加ImeContainer到HierarchyBuilder"></a>3.1添加ImeContainer到HierarchyBuilder</h4><pre><code>rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
</code></pre>
<p>我们先看<code>setImeContainer(imeContainer)</code>部分。其中参数imeContainer是DisplayArea.Tokens的对象。</p>
<p>在DisplayContent中DisplayAreaPolicy初始化时，传递了一个<strong>mImeWindowsContainer</strong>对应我们这里的<strong>imeContainer</strong>形参，其是在DisplayContent中定义并初始化的<br>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    // Contains all IME window containers. Note that the z-ordering of the IME windows will depend
    // on the IME target. We mainly have this container grouping so we can keep track of all the IME
    // window containers together and move them in-sync if/when needed. We use a subclass of
    // WindowContainer which is omitted from screen magnification, as the IME is never magnified.
    // TODO(display-area): is &quot;no magnification&quot; in the comment still true?
    private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
</code></pre>
<p>ImeContainer就是输入法的容器，其继承在DisplayContent中DisplayArea.Tokens</p>
<pre><code>    /**
     * Container for IME windows.
     *
     * This has some special behaviors:
     * - layers assignment is ignored except if setNeedsLayer() has been called before (and no
     *   layer has been assigned since), to facilitate assigning the layer from the IME target, or
     *   fall back if there is no target.
     * - the container doesn&#39;t always participate in window traversal, according to
     *   &#123;@link #skipImeWindowsDuringTraversal()&#125;
     */
    private static class ImeContainer extends DisplayArea.Tokens &#123;
</code></pre>
<p>HierarchyBuilder的setImeContainer方法<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>        private DisplayArea.Tokens mImeContainer;
        
        /** Sets IME container as a child of this hierarchy root. */
        HierarchyBuilder setImeContainer(DisplayArea.Tokens imeContainer) &#123;
            mImeContainer = imeContainer;
            return this;
        &#125;
</code></pre>
<p>从代码中可以看出，就是将<strong>DisplayContent的mImeWindowsContainer</strong>保存到了<strong>HierarchyBuilder的mImeContainer</strong>成员变量中，后续创建DisplayArea层级结构时可以直接拿来使用。</p>
<h4 id="3-2添加TaskDisplayArea到HierarchyBuilder"><a href="#3-2添加TaskDisplayArea到HierarchyBuilder" class="headerlink" title="3.2添加TaskDisplayArea到HierarchyBuilder"></a>3.2添加TaskDisplayArea到HierarchyBuilder</h4><pre><code>rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
</code></pre>
<p>这里我们看<code>setTaskDisplayAreas(tdaList)</code>部分，第一步【1.初始化TaskDisplayArea】的时候，就已经把名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到tdaList中，</p>
<pre><code>        private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;();

       /**
         * Sets &#123;@link TaskDisplayArea&#125; that are children of this hierarchy root.
         * &#123;@link DisplayArea&#125; group must have at least one &#123;@link TaskDisplayArea&#125;.
         */
        HierarchyBuilder setTaskDisplayAreas(List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;
            mTaskDisplayAreas.clear();
            mTaskDisplayAreas.addAll(taskDisplayAreas);
            return this;
        &#125;
</code></pre>
<p>虽然TaskDisplayArea是支持嵌套的，并且这里也采用了一个ArrayList来管理TaskDisplayArea，但是目前TaskDisplayArea只在这里被创建，即目前一个DisplayContent只有一个名为“DefaultTaskDisplayArea”的TaskDisplayArea。从dumpsys activity containers 中我们也可以看到,整个文件也只有一个“DefaultTaskDisplayArea”</p>
<h4 id="4-为HierarchyBuilder添加Feature"><a href="#4-为HierarchyBuilder添加Feature" class="headerlink" title="4.为HierarchyBuilder添加Feature"></a>4.为HierarchyBuilder添加Feature</h4><pre><code>// Only trusted display can have system decorations.
configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
</code></pre>
<p><code>configureTrustedHierarchyBuilder</code>这个方法就在DisplayAreaPolicy.DefaultProvider内部</p>
<pre><code>private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
                WindowManagerService wmService, DisplayContent content) &#123;
            // WindowedMagnification should be on the top so that there is only one surface
            // to be magnified.
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                    FEATURE_WINDOWED_MAGNIFICATION)
                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                    // Make the DA dimmable so that the magnify window also mirrors the dim layer.
                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                    .build());
            if (content.isDefaultDisplay) &#123;
                // Only default display can have cutout.
                // See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked.
                rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                        FEATURE_HIDE_DISPLAY_CUTOUT)
                        .all()
                        .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                                TYPE_NOTIFICATION_SHADE)
                        .build())
                        .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                                FEATURE_ONE_HANDED)
                                .all()
                                .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                        TYPE_SECURE_SYSTEM_OVERLAY)
                                .build());
            &#125;
            rootHierarchy
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                            FEATURE_FULLSCREEN_MAGNIFICATION)
                            .all()
                            .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                    TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                    TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                            .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                            FEATURE_IME_PLACEHOLDER)
                            .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                            .build());
        &#125;
    &#125;
</code></pre>
<p>从代码中可以看到五大的Feature：WindowedMagnification、HideDisplayCutout、OneHanded、FullscreenMagnification、ImePlaceholder，这些Feature其实也就是我们在dumpsys中看到那些，还有一些关键方法all()、and()、except()、upto()、build()等<br>在我们正式开始聊这个几个Feature添加之前，我们先来看看，Feature是怎么定义的</p>
<h5 id="4-1-Feature的定义"><a href="#4-1-Feature的定义" class="headerlink" title="4.1 Feature的定义"></a>4.1 Feature的定义</h5><p>从HierarchyBuilder的addFeature方法跟踪发现，Feature是在DisplayAreaPolicyBuilder中定义的</p>
<pre><code>        HierarchyBuilder addFeature(DisplayAreaPolicyBuilder.Feature feature) &#123;
            mFeatures.add(feature);
            return this;
        &#125;
</code></pre>
<p>Feature的定义<br>代码路径&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>    /**
     * A feature that requires &#123;@link DisplayArea DisplayArea(s)&#125;.
     */
    static class Feature &#123;
        private final String mName;
        private final int mId;
        private final boolean[] mWindowLayers;
        private final NewDisplayAreaSupplier mNewDisplayAreaSupplier;

        private Feature(String name, int id, boolean[] windowLayers,
                NewDisplayAreaSupplier newDisplayAreaSupplier) &#123;
            mName = name;
            mId = id;
            mWindowLayers = windowLayers;
            mNewDisplayAreaSupplier = newDisplayAreaSupplier;
        &#125;
        ......
    &#125;
</code></pre>
<p>首先Feature代表的是DisplayArea的一个特征，可以根据Feature来对不同的DisplayArea进行划分。</p>
<ul>
<li>mName：这个Feature的名字，如上面的“WindowedMagnification”，“HideDisplayCutout”之类的，后续DisplayArea层级结构建立起来后，每个DisplayArea的名字用的就是当前DisplayArea对应的那个Feature的名字。</li>
<li>mId：Feature的ID，如上面的FEATURE_WINDOWED_MAGNIFICATION和FEATURE_HIDE_DISPLAY_CUTOUT，虽说是Feature的ID，因为Feature又是DisplayArea的特征</li>
<li>mWindowLayers：代表了这个DisplayArea可以包含哪些层级对应的窗口</li>
<li>mNewDisplayAreaSupplier：只是一个接口，内部定义一个create方法。</li>
</ul>
<p>关键是其Feature内部定义Builder类以及其build()方法</p>
<h6 id="Feature-Builder和Feature-Builder-build"><a href="#Feature-Builder和Feature-Builder-build" class="headerlink" title="Feature.Builder和Feature.Builder.build()"></a>Feature.Builder和Feature.Builder.build()</h6><pre><code>static class Builder &#123;
            private final WindowManagerPolicy mPolicy;
            private final String mName;
            private final int mId;
            private final boolean[] mLayers;
            private NewDisplayAreaSupplier mNewDisplayAreaSupplier = DisplayArea::new;
            private boolean mExcludeRoundedCorner = true;

            /**
             * Builds a new feature that applies to a set of window types as specified by the
             * builder methods.
             *
             * &lt;p&gt;The set of types is updated iteratively in the order of the method invocations.
             * For example, &#123;@code all().except(TYPE_STATUS_BAR)&#125; expresses that a feature should
             * apply to all types except TYPE_STATUS_BAR.
             *
             * &lt;p&gt;The builder starts out with the feature not applying to any types.
             *
             * @param name the name of the feature.
             * @param id of the feature. &#123;@see Feature#getId&#125;
             */
            Builder(WindowManagerPolicy policy, String name, int id) &#123;
                mPolicy = policy;
                mName = name;
                mId = id;
                mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1];
            &#125;
            ......
            Feature build() &#123;
                if (mExcludeRoundedCorner) &#123;
                    // Always put the rounded corner layer to the top most layer.
                    mLayers[mPolicy.getMaxWindowLayer()] = false;
                &#125;
                return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);
            &#125;
</code></pre>
<p>通过一套适用于具体的窗口类型构建方法来构建新Feature<br>其中<code>mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1];</code> mPolicy.getMaxWindowLayer()返回的是窗口最大层数。</p>
<pre><code>    /**
     * Returns the max window layer.
     * &lt;p&gt;Note that the max window layer should be higher that the maximum value which reported
     * by &#123;@link #getWindowLayerFromTypeLw(int, boolean)&#125; to contain rounded corner overlay.&lt;/p&gt;
     *
     * @see WindowManager.LayoutParams#PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY
     */
    default int getMaxWindowLayer() &#123;
        return 36;
    &#125;
</code></pre>
<p>1.代码中最大层数是36，这里+1，则也就是<code>mLayers = new boolean[37]</code>，即窗口层级区间为<code>[0,36]</code><br>2.在看看<code>build()</code>方法中的 <code>mLayers[mPolicy.getMaxWindowLayer()] = false;</code>，则表示<code>mLayers[36]</code> &#x3D; false，即第36层在build时会置为false（注：mExcludeRoundedCorner这个变量的值一直是true，没有改动）<br>3.<code>return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);</code><br>其中<strong>mLayers</strong>对应的就是<strong>Feature中的mWindowLayers</strong>，即<code>mLayers.clone()</code>就是把<strong>Feature.mWindowLayer</strong>的值复制给<strong>Feature.Builder.mLayer</strong>。</p>
<p>下面我们来说说构建Feature的关键星魂</p>
<h5 id="4-2-构建Feature的核心方法"><a href="#4-2-构建Feature的核心方法" class="headerlink" title="4.2 构建Feature的核心方法"></a>4.2 构建Feature的核心方法</h5><p>以下代码均在DisplayAreaPolicyBuilder.Feature.Builder中</p>
<h6 id="Feature-Builder第一星魂：all"><a href="#Feature-Builder第一星魂：all" class="headerlink" title="Feature.Builder第一星魂：all()"></a>Feature.Builder第一星魂：all()</h6><pre><code>        /**
         * Set that the feature applies to all window types.
         */
        Builder all() &#123;
            Arrays.fill(mLayers, true);
            return this;
        &#125;
</code></pre>
<p>将mLayers数组中的所有元素都设置为true，表示当前DisplayArea可以包含所有类型的窗口。<br><strong>简述，all()就是把所有类型窗口置为true（添加）</strong></p>
<h6 id="Feature-Builder第二星魂：and"><a href="#Feature-Builder第二星魂：and" class="headerlink" title="Feature.Builder第二星魂：and()"></a>Feature.Builder第二星魂：and()</h6><pre><code>        /**
         * Set that the feature applies to the given window types.
         */
        Builder and(int... types) &#123;
            for (int i = 0; i &lt; types.length; i++) &#123;
                int type = types[i];
                set(type, true);
            &#125;
            return this;
        &#125;
</code></pre>
<p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为true，表示该DisplayArea可以包含传入的窗口类型对应的窗口。<br><strong>简述，and就是把你传入的所有参数（窗口类型）置为true（添加）</strong></p>
<h6 id="Feature-Builder第三星魂：except"><a href="#Feature-Builder第三星魂：except" class="headerlink" title="Feature.Builder第三星魂：except()"></a>Feature.Builder第三星魂：except()</h6><pre><code>        /**
         * Set that the feature does not apply to the given window types.
         */
        Builder except(int... types) &#123;
            for (int i = 0; i &lt; types.length; i++) &#123;
                int type = types[i];
                set(type, false);
            &#125;
            return this;
        &#125;
</code></pre>
<p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为false，表示该DisplayArea不再包含传入的窗口类型对应的窗口。<br><strong>简述，except就是你传入的所有参数（窗口类型）置为false（不添加）</strong></p>
<h6 id="Feature-Builder第四星魂（必点）：upTo"><a href="#Feature-Builder第四星魂（必点）：upTo" class="headerlink" title="Feature.Builder第四星魂（必点）：upTo()"></a>Feature.Builder第四星魂（必点）：upTo()</h6><pre><code>        /**
         * Set that the feature applies window types that are layerd at or below the layer of
         * the given window type.
         */
        Builder upTo(int typeInclusive) &#123;
            final int max = layerFromType(typeInclusive, false);
            for (int i = 0; i &lt; max; i++) &#123;
                mLayers[i] = true;
            &#125;
            set(typeInclusive, true);
            return this;
        &#125;
</code></pre>
<p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的的元素之前的所有元素（包含该元素）设置为true，表示当前DisplayArea可以包含比传入的窗口类型层级值低的所有窗口。<br><strong>简述，upTo把就是[0,typeInclusive]区间内的所有类型窗口置为true（添加）。</strong><br>其中layerFromType方法非常重要，我们一起看看</p>
<pre><code>            private int layerFromType(int type, boolean internalWindows) &#123;
                return mPolicy.getWindowLayerFromTypeLw(type, internalWindows);
            &#125;
</code></pre>
<p>调用的了WindowManagerPolicy.getWindowLayerFromTypeLw方法</p>
<h6 id="WindowManagerPolicy-getWindowLayerFromTypeLw"><a href="#WindowManagerPolicy-getWindowLayerFromTypeLw" class="headerlink" title="WindowManagerPolicy.getWindowLayerFromTypeLw"></a>WindowManagerPolicy.getWindowLayerFromTypeLw</h6><pre><code>  /**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.
     */
    default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;
        return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow,
                false /* roundedCornerOverlay */);
    &#125;

    /**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @param roundedCornerOverlay 
</code></pre>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
        </nav>
    
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>