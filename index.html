<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>TYL</title>
    
    
        <meta name="keywords" content="TYL" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="cq_tyl的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="TYL">
<meta property="og:url" content="https://cq_tyl.gitee.io/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="cq_tyl的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">Android事件分发</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/">Android自定义View</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ADB%E5%92%8CMonkey%E6%B5%8B%E8%AF%95/">ADB和Monkey测试</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/">0.jetpack合集</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.1.leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">3.1.leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.0.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96&ANR/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/">0.app性能优化集合</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/">MVC、MVP、MVVM架构</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  <li class="file"><a href="/wiki/C++/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            QT
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            我的简历
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E6%AD%A3%E5%BC%8F%E7%AE%80%E5%8E%86/">我的简历</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">完整项目经历</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main">
        <article id="post-其他笔记/我的简历/完整项目经历" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/">我的简历</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>##项目经历</p>
<ul>
<li><p>重庆捷旭科技有限公司   	                                   2021.02-至今                                         Android工程师 </p>
<ul>
<li><p>捷宇rk3566-android13_r6 framework定制开发</p>
<p>产品简介：<a target="_blank" rel="noopener" href="http://www.fjjieyu.com/product/index/133">http://www.fjjieyu.com/product/index/133</a></p>
<p>1.将云法庭apk内置成系统应用并实现不可退出不可卸载的需求；<br>2.修改开关机动画为云上共享法庭的启动动画；<br>3.app执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;<br>4.实现带鱼屏宽屏的分屏场景-双屏动画切换移动功能；<br>5.冻屏bug处理<br>6.壁纸切换闪黑bug解决</p>
</li>
<li><p>云上共享法庭 android开发<br>重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，独立负责里面的内网法官&#x2F;当事人&#x2F;签字<br>端&#x2F;手机端&#x2F;电视端的开发及适配处理；</p>
</li>
<li><p>信息发布 android开发<br>类似与广告机的应用，动态实现图片&#x2F;音视频&#x2F;文字&#x2F;定制布局等不同场景的展示及开机自启和自动升级等功能；</p>
</li>
<li><p>案件排期 android开发<br>一款基层法院窗口信息显示应用，通过与条屏厂家对接实现条屏的适配显示窗口信息等；</p>
</li>
<li><p>傲视取号机 android开发<br>一款基层法院取号应用，通过与硬件厂家对接实现刷身份证，取号，叫号，切纸等操作；</p>
</li>
</ul>
</li>
<li><p>重庆国狮科技有限公司                                         2018.02-2019.03                                   Android组负责人</p>
<ul>
<li>出行加司机 android开发<br>一款专用于出行加网约车平台司机接单应用,根据司机注册公司及车辆信息，可动态接<br>取不同类型的网约车订单，该应用已繁衍出小巷约车应用。</li>
<li>出行加乘客 android开发<br>一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不<br>同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以<br>激励用户的使用</li>
<li>项目名称： 商务司机<br>一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不<br>同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以<br>激励用户的使用</li>
<li>文具购（二次开发 Android<br>是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类<br>查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能</li>
<li>vaptcha手势验证 android开发<br>公司接的一个外包项目，android应用的第三方库开发，识别并计算出用户的手势滑动<br>坐标并上传至后台返回完成手势验证。<br>Vaptcha Sdk文档 https &#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/1b72ea2142c2">www.jianshu.com/p/1b72ea2142c2</a></li>
<li>富山 android开发<br>类似于梦想打卡的投资类项目，主体由android原生结合webView完成，该项目完成<br>周期仅用了3个星期的时间并通过招商等形式繁衍出了富海应用。</li>
<li>完美日程 android开发<br>一款仿谷歌日历的本地日历应用，已完成大部分业务逻辑，包含了自定义日历视图，<br>本地日历活动同步，节假日的动态显示以及用户自定义个人目标等功能。</li>
<li>梦想打卡 android开发<br>一款提供给用户在固定时间进行签到的应用，用户可选择参与不同的打卡签到活动，<br>在指定时间完成签到则获得现金奖励，该项目通过招商等形式已繁衍出喔喔打卡&#x2F;星星<br>打卡等应用。</li>
</ul>
</li>
<li><p>重庆全心协力科技有限公司                             2016.04-2018.02                             Android工程师 </p>
<ul>
<li>现场云 android开发<br>是公司自己的项目（已维护更新5个版本），打造的一款提升工厂生产效率，旨 在避免<br>问题产生到问题解决无人监管无人记录导致同一问题反复出现或无人处 理的情况，兼<br>具点检和报表统计，即时聊天等功能。</li>
<li>文具购（二次开发） android开发<br>是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类<br>查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能</li>
<li>健康西南 android开发<br>是在医事通平台下，西南医院的一款App，也集合了预约挂号、导医、查询等 功能。</li>
<li>小马医疗 android开发<br>一款为以医疗、推广为主的App。主要功能有预约挂号、健康咨询、健康商城 等。分<br>四个主界面全部用原生的页面撰写，其余二级页面加载网页</li>
<li>医事通 android开发<br>广州市卫生信息服务平台的手机版，为用户更方便快捷的提供预约挂号服务</li>
</ul>
</li>
</ul>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-其他笔记/我的简历/正式简历" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/">我的简历</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
             <center>
     <h1>唐玉龙</h1>
 </center>

<p>##个人信息</p>
<ul>
<li><p>性 别：男						                                                                     年 龄：34 </p>
</li>
<li><p>手 机：18996195388			                                                             邮 箱：<a href="mailto:&#x31;&#x31;&#x30;&#x34;&#x36;&#53;&#51;&#x32;&#54;&#50;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;">&#x31;&#x31;&#x30;&#x34;&#x36;&#53;&#51;&#x32;&#54;&#50;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;</a></p>
</li>
<li><p>学校：重庆交通大学(非全) 本科           		                                      专 业：计算机科学与技术</p>
</li>
<li><p>工作年限：7年app&amp;1年framework                                                  岗 位：Android研发工程师</p>
</li>
<li><p>博客：<a target="_blank" rel="noopener" href="https://cq-tyl.github.io/">https://cq-tyl.github.io</a>                                                            简书：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/517b3c07af90">https://www.jianshu.com/u/517b3c07af90</a></p>
</li>
</ul>
<p>##专业技能</p>
<ul>
<li>8年互联网开发经验(7年app&amp;1年framework)，精通Java语言，了解C语言，并熟悉SDK及NDK、JNI开发；</li>
<li>熟悉安卓系统架构，熟悉Android系统启动流程，熟悉IMS,了解WMS，AMS模块；</li>
<li>熟悉画中画、分屏、自由窗口,了解SystemUl,Launcher3等系统应用的定制开发；</li>
<li>熟悉winscop,perfetto,systrace,Profile,adb,logcat,dumpsys等常用调试工具；</li>
<li>熟悉Binder,Aidl,socket等跨进程通信;</li>
<li>熟练处理冻屏、闪黑、不开机、重启、死机、黑屏、定屏、ANR、Crash等问题;</li>
<li>熟悉app组件化开发、jetpack及各种安卓开发组件；</li>
<li>熟悉app性能优化、屏幕适配、进程保活、软件稳定性处理；</li>
<li>熟悉git,svn,as,asfp,vscode,vim等常用开发工具；</li>
<li>能够解决Framework层的定制问题并熟悉Android APK及Android系统应用的开发流程，拥有良好的表达能力与沟通能力,工作积极主动,<br>能尽心尽责地完成本职工作. 热衷于移动互联的垂直领域,对Hal及bsp方向有着浓厚的兴趣；</li>
</ul>
<p>##工作经历</p>
<ul>
<li><p>重庆捷旭科技有限公司   	                                   2021.02-至今                                         Android工程师 </p>
</li>
<li><p>重庆国狮科技有限公司                                          2018.02-2019.03                                  Android组负责人</p>
</li>
<li><p>重庆全心协力科技有限公司                                  2016.04-2018.02                                  Android工程师</p>
</li>
</ul>
<p>##重点项目经历</p>
<ul>
<li><p>捷宇M32-rk3566-android13_r6 framework定制开发</p>
<ul>
<li>项目简介：定制M32信息交互终端设备，集成身份核验、电子签名、指纹采集、社保卡读写、二维码扫描、高拍仪、服务评价、数据加密等功能，能有效实现业务无纸化办理，应用于电子政务、医保社保、卫生健康、公共服务等智慧办公、身份核验及签批审核无纸化等领域。</li>
<li>项目地址：<a target="_blank" rel="noopener" href="http://www.fjjieyu.com/product/index/133">http://www.fjjieyu.com/product/index/133</a></li>
<li>项目职责：</li>
<li>使用技术：<ul>
<li><p>将apk内置成系统应用实现不可退出不可卸载的需求；</p>
</li>
<li><p>修改开关机动画为云上共享法庭的启动动画；</p>
</li>
<li><p>app执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;</p>
</li>
<li><p>实现带鱼屏宽屏的分屏场景-双屏动画切换移动功能；</p>
</li>
<li><p>冻屏bug处理</p>
</li>
<li><p>壁纸切换闪黑bug解决</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>云上共享法庭APP开发</p>
<ul>
<li><p>项目简介：重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，独立负责里面的内网法官&#x2F;当事人&#x2F;签字端&#x2F;手机端&#x2F;电视端的Android开发及适配处理任务；</p>
</li>
<li><p>项目地址：<a target="_blank" rel="noopener" href="https://www.jetshine.com.cn/product.html?id=1520657316474638337">https://www.jetshine.com.cn/product.html?id=1520657316474638337</a></p>
</li>
<li><p>项目职责：</p>
</li>
<li><p>使用技术：</p>
</li>
</ul>
</li>
<li><p>出行加司机&amp;乘客 android开发 </p>
<ul>
<li><p>项目简介：一款专用于出行加网约车平台司机接单,网约车乘客派单的应用，根据司机注册公司及车辆信息，可动态接取不同类型的网约车订单，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用，该应用已繁衍出小巷约车应用；</p>
</li>
<li><p>项目地址：<a target="_blank" rel="noopener" href="https://www.dacheruanjian.cn/index.html">https://www.dacheruanjian.cn/index.html</a></p>
</li>
<li><p>项目职责：</p>
</li>
<li><p>使用技术：</p>
</li>
</ul>
</li>
</ul>
<p>##完整项目经历</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/MVC、MVP、MVVM架构" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="01-架构介绍"><a href="#01-架构介绍" class="headerlink" title="01 架构介绍"></a>01 架构介绍</h2><p>先来看一下MVC、MVP、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020">MVVM</a>的架构图。</p>
<p><img src="/../../images/be7811835b0814ddeebca2ffa18b4b7b.png"></p>
<p>从这些架构图中，可以看到每种架构都有3个模块以及数据流动方向箭头。</p>
<p><strong>模块</strong></p>
<p>在系统架构中，首先要做的就是把系统整体按照一定的原则划分成模块。</p>
<p><strong>数据流动</strong></p>
<p>模块划分之后，模块之间的通信，就是数据的流动。在Android中，流动数据包括两部分，事件和数据。</p>
<p><strong>架构</strong></p>
<p>模块和模块之间的数据通信方式构成不同的架构。在这3种架构中，都是把系统整体划分成了3个模块：<strong>视图层，数据层，业务层。</strong> 他们之间的区别在于，模块之间的通信方式（数据流动方向）不一致。</p>
<ul>
<li>MVC是视图层接收到事件后调用到业务层处理业务逻辑，业务层调用数据层处理数据，数据层再调用视图层更新页面。</li>
<li>MVP是视图层接收到事件后调用到业务层处理，业务层调用数据层处理数据，数据层处理数据后回调给业务层，业务层再回调给视图层更新页面。（数据层已不再持有视图层，他们之间通过业务层（Presenter）交互，具体使用接口实现，使数据层和视图层解耦。</li>
<li>MVVM在MVP的基础上实现了视图层和业务层的双向数据绑定（data binding），不再通过接口的方式交互，ViewModel不在和Presenter一样持有视图层，使视图层和业务层解耦。</li>
</ul>
<h2 id="02-具体实现"><a href="#02-具体实现" class="headerlink" title="02 具体实现"></a>02 具体实现</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="/../../images/c37db6c4812686b6d6ed0a1396bfd213.png"></p>
<p>视图层：在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVC%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">MVC架构</a>中， Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理。需要和Activity一起才能够构成一个完整的视图层。</p>
<p>业务层：大多数的MVC架构开发的安卓项目， 并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，这就是MVC的缺点之一。 在本例中，我们会将业务层独立出来，实现一个标准的MVC架构。</p>
<p>数据层：数据层Model指的是，数据管理模块，这包括了数据的获取，处理。存储等。 MVP、MVVM的架构中的Model也是一样。后面不再赘述。</p>
<p><strong>代码结构</strong></p>
<img src="../../images/e27724fe4c2920ff7b1623bf12b8f015.png" style="zoom:67%;" />

<p><strong>xml代码</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_gallery_outer&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_result&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center&quot; /&gt;

    &lt;EditText
        android:id=&quot;@+id/tv_account&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:layout_gravity=&quot;center&quot;
        android:layout_marginLeft=&quot;16dp&quot;
        android:layout_marginTop=&quot;20dp&quot;
        android:layout_marginRight=&quot;16dp&quot;
        android:gravity=&quot;center&quot;
        android:hint=&quot;输入用户名&quot; /&gt;

    &lt;EditText
        android:id=&quot;@+id/tv_pwd&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:layout_gravity=&quot;center&quot;
        android:layout_marginLeft=&quot;16dp&quot;
        android:layout_marginRight=&quot;16dp&quot;
        android:gravity=&quot;center&quot;
        android:hint=&quot;输入密码&quot; /&gt;

    &lt;Button
        android:id=&quot;@+id/btn_login&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:layout_gravity=&quot;center&quot;
        android:layout_marginLeft=&quot;16dp&quot;
        android:layout_marginRight=&quot;16dp&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;登录&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<p><strong>Activity代码</strong></p>
<pre><code>public class MVCActivity extends AppCompatActivity &#123;

    TextView tvResult;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
         tvResult = findViewById(R.id.tv_result);
        TextView tvAccount = findViewById(R.id.tv_account);
        TextView tvPwd = findViewById(R.id.tv_pwd);
        Button btnLogin = findViewById(R.id.btn_login);

        MVCController mvcController = new MVCController();

        btnLogin.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                mvcController.login(tvAccount.getText().toString(),tvPwd.getText().toString(), MVCActivity.this);
            &#125;
        &#125;);
    &#125;

    public void loginSuccess()&#123;
        tvResult.setText(&quot;登录结果：登录成功&quot;);
    &#125;

    public void loginFail()&#123;
        tvResult.setText(&quot;登录结果：登录失败&quot;);
    &#125;

&#125;
</code></pre>
<p>​    </p>
<p><strong>Controller代码</strong></p>
<pre><code>public class MVCController &#123;

    MVCModel mvcModel;

    public MVCController() &#123;
        mvcModel = new MVCModel();
    &#125;

    public void login(String account, String pwd, MVCActivity loginActivity) &#123;
        mvcModel.login(account, pwd, loginActivity);
    &#125;
&#125;
</code></pre>
<p>​    </p>
<p><strong>Model代码</strong></p>
<pre><code>public class MVCModel &#123;

    public void login(String account, String pwd, MVCActivity loginActivity)&#123;

        if (account == null || account.length()==0) &#123;
            loginActivity.loginFail();
        &#125;

        if (pwd == null || pwd.length()==0) &#123;
            loginActivity.loginFail();
        &#125;

        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd))&#123;
            loginActivity.loginSuccess();
        &#125;

    &#125;

&#125;
</code></pre>
<h4 id="实现代码说明"><a href="#实现代码说明" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>在Activity中监听登录按钮的事件，接收到事件之后，调用Controller的登录方法处理登录逻辑，在Controller的登录方法中调用Model请求网络数据（这里是模拟）判断是否登录成功，Model拿到登录结果后，调用Activity的方法刷新页面数据，展示登录结果。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：通过划分模块的方式，将系统分成了3个模块，视图层，业务层和数据层。 代码开发实现不再是只在一个代码文件中，一定程度便于程序开发。</p>
<p>缺点：但是三个模块之间还存在很强的耦合关系。 不利于业务需求的更变和代码维护工作。</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><img src="/../../images/aa8a22ae779896db83a16b173c9782a4.png"></p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVP%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">MVP架构</a>是基于MVC的改进，将MVC的中Controller独立出来作为Presenter。 xml和Activity还是作为视图层， 视图层接收到页面数据，调用Presenter进行业务逻辑处理，Presenter调用Model进行数据处理，Model回传数据给Presenter，Presenter回传数据给View。数据的回传通过接口回调的方式来实现。</p>
<p><strong>代码结构</strong></p>
<p><img src="/../../images/ceb4b647e87386e3bbdaa4a844249588.png"></p>
<p><strong>IModel接口代码</strong></p>
<pre><code>public interface IModel &#123;
    public boolean login(String account, String pwd);
&#125;
</code></pre>
<p>​    </p>
<p><strong>IView接口代码</strong></p>
<pre><code>public interface IView &#123;
    public void loginSuccess();
    public void loginFail();
&#125;
</code></pre>
<p>​    </p>
<p><strong>Activity代码</strong></p>
<pre><code>public class MVPActivity extends AppCompatActivity implements IView &#123;

    TextView tvResult;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);

        tvResult = findViewById(R.id.tv_result);

        TextView tvAccount = findViewById(R.id.tv_account);
        TextView tvPwd = findViewById(R.id.tv_pwd);
        Button btnLogin = findViewById(R.id.btn_login);

        MVPPresenter presenter = new MVPPresenter();
        presenter.setiView(this);
        btnLogin.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                presenter.login(tvAccount.getText().toString(), tvPwd.getText().toString());
            &#125;
        &#125;);
    &#125;

    public void loginSuccess() &#123;
        tvResult.setText(&quot;登录结果：登录成功&quot;);
    &#125;

    public void loginFail() &#123;
        tvResult.setText(&quot;登录结果：登录失败&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>Model代码</strong></p>
<pre><code>public class MVPModel implements IModel &#123;
    public boolean login(String account, String pwd) &#123;

        if (account == null || account.length() == 0) &#123;
            return false;
        &#125;

        if (pwd == null || pwd.length() == 0) &#123;
            return false;
        &#125;

        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123;
            return true;

        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>Presenter代码</strong></p>
<pre><code>public class MVPPresenter &#123;

    MVPModel model;

    public MVPPresenter() &#123;
        model = new MVPModel();
    &#125;

    IView iView;

    public void setiView(IView iView) &#123;
        this.iView = iView;
    &#125;

    public void login(String account, String pwd) &#123;
        boolean loginResult = model.login(account, pwd);

        if (loginResult)&#123;
            iView.loginSuccess();
        &#125;else &#123;
            iView.loginFail();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="实现代码说明-1"><a href="#实现代码说明-1" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>定义了两个接口，IView和IModel, Activity和Model分别实现了这两个接口。 在Presenter中持有这两个实例。Presenter调用Model处理数据后，通过Iview的接口方法回调给Activity刷新页面。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>从上面的代码可以看到，三个模块之间的通信是通过接口实现的，在实际开发，定义的接口和方法会非常多。 导致很简单的一个页面功能也需要实现多个接口和方法。</p>
<p>优点就是通过Presenter，把MVC中的Controller代码抽出来了，并且Presenter作为View和Model通信的桥梁，完成了Model和View的解耦。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><img src="/../../images/721acde222529fd6f3964f1fa7755c63.png"></p>
<p>MVVM在MVP的基础上加入了双向绑定，使View能够感知ViewModel中的数据变化，ViewModel能够感知View数据的变化。</p>
<p><strong>代码结构</strong></p>
<p><img src="/../../images/945eade69fd1693f76c583b4251da203.png"></p>
<p><strong>xml代码</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;

        &lt;variable
            name=&quot;viewModel&quot;
            type=&quot;com.domain.android.study.notes.architecture.mvvm.MVVMViewModel&quot; /&gt;

    &lt;/data&gt;

    &lt;LinearLayout
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:id=&quot;@+id/ll_gallery_outer&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_result&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@&#123;viewModel.result&#125;&quot;
            android:layout_gravity=&quot;center&quot; /&gt;

        &lt;EditText
            android:id=&quot;@+id/tv_account&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:layout_height=&quot;40dp&quot;
            android:hint=&quot;输入用户名&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;@=&#123;viewModel.account&#125;&quot;

            android:layout_gravity=&quot;center&quot;
            android:layout_marginTop=&quot;20dp&quot; /&gt;

        &lt;EditText
            android:id=&quot;@+id/tv_pwd&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:layout_height=&quot;40dp&quot;
            android:hint=&quot;输入密码&quot;
            android:text=&quot;@=&#123;viewModel.pwd&#125;&quot;
            android:gravity=&quot;center&quot;
            android:layout_gravity=&quot;center&quot; /&gt;

        &lt;Button
            android:id=&quot;@+id/btn_login&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:layout_height=&quot;40dp&quot;
            android:text=&quot;登录&quot;
            android:gravity=&quot;center&quot;
            android:layout_gravity=&quot;center&quot; /&gt;

    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>Activity代码</strong></p>
<pre><code>public class MVVMActivity extends AppCompatActivity &#123;

    MVVMViewModel viewModel;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        ActivityLoginBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_login);
        viewModel = ViewModelProviders.of(this).get(MVVMViewModel.class);
        binding.setVariable(BR.viewModel, viewModel);
        binding.setLifecycleOwner(this);
        binding.btnLogin.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                viewModel.login();
            &#125;
        &#125;);

    &#125;

&#125;
</code></pre>
<p><strong>ViewModel代码</strong></p>
<pre><code>public class MVVMViewModel  extends ViewModel &#123;

    public ObservableField&lt;String&gt; account = new ObservableField&lt;&gt;(&quot;&quot;);
    public ObservableField&lt;String&gt; pwd = new ObservableField&lt;&gt;(&quot;&quot;);
    public ObservableField&lt;String&gt; result = new ObservableField&lt;&gt;(&quot;&quot;);

    MVVMModel mvvmModel;
    public MVVMViewModel() &#123;
         mvvmModel = new MVVMModel();
    &#125;

    public void login()&#123;
        boolean loginResult = mvvmModel.login(account.get(), pwd.get());
        result.set(loginResult ? &quot;登录结果：成功&quot; :&quot;登录结果：失败&quot;);
    &#125;

&#125;
</code></pre>
<p><strong>Model代码</strong></p>
<pre><code>public class MVVMModel &#123;
    public boolean login(String account, String pwd) &#123;
        if (account == null || account.length() == 0) &#123;
            return false;
        &#125;

        if (pwd == null || pwd.length() == 0) &#123;
            return false;
        &#125;
        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p>在本例MVVM架构实现中，用到了Android提供的data binding这个数据双向绑定框架。需要在APP模块的gralde文件中添加以下配置开启：</p>
<pre><code> android &#123;
 ...
 dataBinding &#123;
        enabled true
    &#125;
  ...
    &#125;
</code></pre>
<h4 id="实现代码说明-2"><a href="#实现代码说明-2" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>通过Android提供的数据双向绑定库data binding 将Acitvity&#x2F;xml视图层与ViewModel绑定。在xml布局文件中，通过<code>@&#123;&#125;</code>来表示单向绑定或者<code>@=&#123;&#125;</code>来表示双向绑定。Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。</p>
<p><strong>注意</strong></p>
<p>data binding通过观察者模式实现。 内部具体实现也是通过调用notify通知数据变化给观察者，notify调用了观察者实现的接口方法。</p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：经过数据双向绑定之后，我们不在需要想MVP中写那么多接口回调方法区实现视图层和业务层的交互。业务层也不再持有视图层的引用。</p>
<p>缺点：通过这种方式进行数据双向绑定后，xml中会多出一些标签、表达式、甚至和业务有点的简单计算代码。这不利于业务的逻辑的查看。并且由于双向绑定是data binding实现的。在这个过程中， 如果出现bug导致数据没有被感知改变，不方便排错，因为xml不能debug调试。</p>
<h2 id="03-总结"><a href="#03-总结" class="headerlink" title="03 总结"></a>03 总结</h2><p>MVC、MVP、MVVM大体上都是把系统划分成3个模块：视图层、业务层、数据层。 但是他们的通信方式、数据流动方向不一致，形成了不同的架构。 其后面产生的架构都是为了更好的解耦，解决已有架构的不足。每个架构都有自己的优缺点，<strong>没有最好的架构，只有最合适的架构。</strong></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/Jetpack/0.jetpack合集" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/">Jetpack</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            

	<div class="row">
    <embed src="/pdf/jetpack合集.pdf" width="100%" height="550" type="application/pdf">
	</div>



            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/性能优化/0.app性能优化集合" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            

	<div class="row">
    <embed src="/pdf/app性能优化.pdf" width="100%" height="550" type="application/pdf">
	</div>





            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/4.WMS窗口相关流程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <hr>
<h2 id="4-WMS窗口相关流程"><a href="#4-WMS窗口相关流程" class="headerlink" title="4.WMS窗口相关流程"></a>4.WMS窗口相关流程</h2><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>什么是窗口<br>窗口即是屏幕上的一块用于绘制各种UI元素并可以响应<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5&spm=1001.2101.3001.7020">用户输入</a>的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。<br>Window是个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&spm=1001.2101.3001.7020">抽象类</a>其实现类为PhoneWindow。<br>本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。<br>其他建议：可以先学习<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树相关内容，有助于对窗口模块的理解<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132174913">Android T 窗口层级其一 —— 容器类</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132213111">Android T 窗口层级其二 —— 层级结构树的构建</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132722735">Android T 窗口层级其三 —— 层级结构树添加窗口</a></p>
<h2 id="二、流程简述"><a href="#二、流程简述" class="headerlink" title="二、流程简述"></a>二、流程简述</h2><p>当Activity.onResume()被调用之后，客户端会与WMS进行通信将我们的布局显示在屏幕上。其中主要涉及以下几个过程：<br>客户端通知WMS创建一个窗口，并添加到WindowToken。即addToDisplayAsUser阶段。<br>客户端通知WMS创建Surface，并计算窗口尺寸大小。即relayoutWindow阶段。<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度。即performMeasure阶段。<br>客户端确定该窗口下View的尺寸和位置。即performLayout阶段。<br>确定好View的尺寸大小位置之后，便对View进行绘制。即performDraw阶段。<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来。即reportDrawFinished阶段。<br><img src="/../../../../../images/9bac0587c3614e088e376a948ffb45cb.png" alt="在这里插入图片描述"><br>这里以Activity.onResume()被调用之后为起点</p>
<h3 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h3><p>WindowManager：是一个接口类，负责窗口的管理（增、删、改）。</p>
<p>WindowManagerImpl：WindowManager的实现类，但是他把对于窗口的具体管理操作交给WindowManagerGlobal来处理。</p>
<p>WindowManagerGlobal：是一个单例类，实现了窗口的添加、删除、更新的逻辑，但是</p>
<p>ViewRootImpl：通过IWindowSession与WMS进行通信。其内部类W实现了WMS与ViewRootImpl的通信。<br><img src="/../../../../../images/7817e0249e55462596f58e9a66e68ac9.png" alt="在这里插入图片描述"></p>
<p>ActivityThread.java</p>
<ul>
<li>handleResumeActivity<br>通过WindowManager接口添加view，即<code>wm.addView(decor, l);</code>，wm为ViewManager对象，即<code>ViewManager wm = a.getWindowManager();</code></li>
</ul>
<p>WindowManagerImpl.java</p>
<ul>
<li>addView<br><code>mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,mContext.getUserId());</code>mGlobal为WindowManagerGlobal对象。</li>
</ul>
<p>WindowManagerGlobal.java</p>
<ul>
<li>addView<br><code>root.setView(view, wparams, panelParentView, userId);</code>root为ViewRootImpl对象。<br><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>parentWindow为Window（Window为抽象类，PhoneWindow继承于Window），即在Window中调用adjustLayoutParamsForSubWindow，用于赋值参数布局的token以及title</li>
</ul>
<p>ViewRootImpl.java</p>
<ul>
<li>setView<br>1.addToDisplayAsUser<br>客户端通知WMS创建一个窗口，并添加到WindowToken<br><code>res = mWindowSession.addToDisplayAsUser(mWindow,mWindowAttributes,getHostVisibility(), mDisplay.getDisplayId(), userId,mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,mTempControls);</code><br>2.requestLayout<br>在添加到窗口管理器之前安排第一个布局，以确保我们在从系统接收任何其他事件之前进行重新布局<br>scheduleTraversals-&gt;doTraversal-&gt;performTraversals<br>performTraversals中调用了五个关键方法：<br>relayoutWindow<br>客户端通知WMS创建Surface，并计算窗口尺寸大小<br>performMeasure<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度<br>performLayout<br>客户端确定该窗口下View的尺寸和位置<br>performDraw<br>确定好View的尺寸大小位置之后，便对View进行绘制<br>createSyncIfNeeded-&gt;reportDrawFinished<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来</li>
</ul>
<h3 id="2-通信方式"><a href="#2-通信方式" class="headerlink" title="2. 通信方式"></a>2. 通信方式</h3><p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p>
<ul>
<li><p>IWindowSession.aidl<br>ViewRootImpl中通过此接口调用服务端<br>1.addToDisplayAsUser<br>2.relayout<br>3.finishDrawing</p>
</li>
<li><p>Session.java<br>IWindowSession的实现在这里，最终调用到WMS中<br>1.addToDisplayAsUser-&gt;addWindow<br>2.relayout-&gt;relayoutWindow<br>3.finishDrawing-&gt;finishDrawingWindow</p>
</li>
</ul>
<h3 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3. 服务端"></a>3. 服务端</h3><p>WindowManagerService：负责为Activity对应的窗口分配Surface，管理Surface的显示顺序以及位置尺寸，控制窗口动画，并且还是输入系统的一个重要中转站。</p>
<p>WindowState：和客户端窗口一一对应，在向WMS添加一个窗口时，WMS会为其创建一个WindowState，来表示窗口的所有属性，WindowState相当于属性窗口管理（比如对外提供操作接口，属于层级结构中最底部的容器），窗口画面相关都剥离给了WindowStateAnimator，WindowState也是WMS中事实上的窗口。</p>
<p>WindowStateAnimator：主要用于管理WindowState相关画面surface，通过mDrawState参数来描述Surface所处的状态。</p>
<p>WindowToken：保存了所有具有同一个token的WindowState，将属于同一个activity的窗口组织在一起，activity在需要更新窗口时，必须向WMS提供WindowToken以表名自己的身份，并且窗口的类型必须与所持有的的WindowToken类型一致。<br>补充：一个WindowToken可以对应多个WindowState。 WindowToken是一个用于表示窗口层次结构中的窗口的标识符。每个Window具有一个与之关联的WindowToken，它用于帮助系统管理窗口的显示和交互。<br>一个WindowToken可以有多个WindowState表示与之相关的窗口。这是因为在Android系统中，可能会存在一些特殊情况，例如PopupWindow、Dialog等，它们属于同一个WindowToken，但是显示在不同的窗口上。<br>因此，一个WindowToken可以与多个WindowState关联，这样可以实现多个窗口的操作和管理。</p>
<p>WindowSurfaceController：用来创建SurfaceControl。</p>
<p>DisplayContent：即代表的是单个屏幕。隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每个DisplayContent都对应着一个唯一的id，在添加窗口时可以通过指定这个ID决定将其显示在哪个屏幕中。</p>
<p>WindowSurfacePlacer：整个窗口层次结构刷新的入口。</p>
<p>RootWindowContainer：是窗口容器的顶层容器，其直接管理DisplayContent。</p>
<p><strong>WindowManagerService.java</strong></p>
<h4 id="3-1-addWindow"><a href="#3-1-addWindow" class="headerlink" title="3.1.addWindow"></a>3.1.addWindow</h4><p><img src="/../../../../../images/f032b7cd5a8c470baec7a233a96571a1.png" alt="在这里插入图片描述"><br>1.根据客户端传来的token获取WindowToken或创建WindowToken，并将其挂载到对应的层级节点上<br><code>WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);</code><br>判断WindowToken是否有父亲,即parentWindow 是否不为空<br><code>final boolean hasParent = parentWindow != null;</code><br>注：前面代码有判断是否是子窗口，是则会给parentWindow 赋值；否则parentWindow仍为初始值，即为空<br><img src="/../../../../../images/5b2dfebaa2fa466bbc667e9140ea7150.png" alt="在这里插入图片描述"><br>关于窗口类型，见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/130442487">窗口常见参数汇总</a><br>Activity启动时会在ActivityRecord的构造方法中new Token()。<br><strong>应用侧直接通过addView的方式添加窗口不会有ActivityRecord,因此不会在ActivityRecord的构造方法中new Token()。</strong><br><strong>系统侧直接添加的窗口（状态栏、导航栏等），是通过new WindowToken.Builder的方式添加</strong><br><strong>即主动使用ViewManager.addView来添加一个窗口则不会在ActivityRecord的构造方法中new Token()，否则通过new WindowToken.Builder的方式添加。</strong><br>attrs.token这个参数一可以在应用端设置，应用没有设置token那么就为空，token为IBinder类型对象，默认值为空<code>public IBinder token = null;</code><br>例如：<br>在应用侧可通过mLayoutParams.token的方式设置值<br><code>private WindowManager.LayoutParams mLayoutParams;</code><br><code>mLayoutParams.token = null;</code></p>
<p>后面会继续判断token是否为空,最终会到最后的else中创建token<br><img src="/../../../../../images/72554e9137594c86972bb0cda59bae86.png" alt="在这里插入图片描述"><br>2.创建WindowState<br><code>final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId,session.mCanAddInternalSystemWindow);</code><br>3.验证当前窗口是否可以添加到WMS<br><code>res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</code><br>该方法会对窗口TYPE,FLAG等多方面判断。只有返回ADD_OKAY时表示允许当前窗口的添加，反之则不允许添加该窗口。假如想禁止某些应用做添加窗口操作时，可以在里面通过应用的包名过滤该应用，也可以直接在WindowManagerGlobal.java的addView()方法中直接对应用想要添加的窗口进行过滤。<br>注：<code>ADD_OKAY</code>在WindowManagerGlobal中定义，这个类里面还有一些其他的返回值，所有返回给<code>res</code>的常量最终会在ViewRootImpl的setView方法中判断<br>4.调用openInputChannel，初始化input相关通路（本文不做讨论）<br><code>final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);</code><br><code>if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125;</code><br>5.将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WMS窗口添加之后，还没有创建Surface，此时mDrawState状态为NO_SURFACE</p>
<h4 id="3-2-relayoutWindow"><a href="#3-2-relayoutWindow" class="headerlink" title="3.2 relayoutWindow"></a>3.2 relayoutWindow</h4><p><img src="/../../../../../images/0251fd28a86a46fea1e29a81b2f55897.png" alt="在这里插入图片描述"><br>1.根据客户端传递过来的IWindow的mWindowMap获取窗口添加阶段创建的WindowState<br><code>final WindowState win = windowForClientLocked(session, client, false);</code><br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br><code>win.setDisplayLayoutNeeded();</code>win为WindowState对象，该方法实际操作在DisplayContent中<br><code>final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;(win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || win.mActivityRecord.isClientVisible());</code><br>3.创建SurfaceControl<br>在layoutWindow()调用了createSurfaceControl方法创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code>该方法的实现仍然在WMS中<br>这里以createSurfaceControl方法为起点<br><img src="/../../../../../images/c9cf74cf9cbd45bfb3476c07e3f990b3.png" alt="在这里插入图片描述"><br>在createSurfaceControl()中调用WindowStateAnimator执行具体的SurfaceControl的创建 <code>surfaceController = winAnimator.createSurfaceLocked();</code><br>创建Surface后，Surface还未进行绘制，此时mDrawState状态为DRAW_PENDING<br>将创建的SurfaceControl赋值给客户端的outSurfaceControl<br><code>surfaceController.getSurfaceControl(outSurfaceControl);</code><br>4.窗口尺寸的计算以及Surface状态更新<br>在layoutWindow()调用了performSurfacePlacement<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code>mWindowPlacerLocked为WindowSurfacePlacer对象，因此这里以WindowSurfacePlacer的performSurfacePlacement()为起点<br><img src="/../../../../../images/45182f6e931246bda89e986fff0005f6.png" alt="在这里插入图片描述"><br>处理窗口布局循环<br>WindowSurfacePlacer.performSurfacePlacementLoop()<br>处理Surface的状态更变，以及调用LayoutWindowLw的流程<br>RootWindowContainer.performSurfacePlacementNoTrace()<br>计算窗口位置大小<br>DisplayPolicy.layoutWindowLw()</p>
<h4 id="3-3-finishDrawingWindow"><a href="#3-3-finishDrawingWindow" class="headerlink" title="3.3 finishDrawingWindow"></a>3.3 finishDrawingWindow</h4><p><img src="/../../../../../images/aa5261464c984b56830d1931ec67e207.png" alt="在这里插入图片描述"><br><img src="/../../../../../images/8d84cc58579d4e5cb0c2e924ce3f8afc.png" alt="在这里插入图片描述"></p>
<p>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PEDING<code>win.finishDrawing(postDrawTransaction, seqId)</code>,并请求窗口布局<code>mWindowPlacerLocked.requestTraversal();</code><br>2.通过mApplySurfaceChangesTransaction的callback，</p>
<p><img src="/../../../../../images/9e5c8036f3504e6f84c1a9f80070bdfa.png" alt="在这里插入图片描述"><br>调用commitFinishDrawingLocked()<img src="/../../../../../images/a2c46436037a4a3da9af6fa7c12d1b47.png" alt="在这里插入图片描述"><br>改变mDrawState状态将mDrawState更新为READY_TO_SHOW,<br>最终mDrawState更新为HAS_DRAW后，再次请求窗口布局<br><img src="/../../../../../images/cae5471da1f24847b7e954bd0827ad11.png" alt="在这里插入图片描述"><br>3.执行show Surface<br><code>showSurfaceRobustlyLocked(t)</code><br>注：WindowStateAnimator的commitFinishDrawingLocked()方法中，如果是<strong>应用通过WindowManager中的addView的方式创建窗口，则不会有ActivityRecord</strong>，或者该窗口类型为启动窗口，则直接调用<code>result = mWin.performShowLocked();</code>，即WindowState的performShowLocked()方法改变窗口状态为HAS_DRAW，否则会从RootWindowContainer的checkAppTransitionReady方法逐步调用到performShowLocked()<br><img src="/../../../../../images/97725b2413d74debb25621deab0c5c62.png" alt="在这里插入图片描述"></p>
<h3 id="4-窗口状态变化总结"><a href="#4-窗口状态变化总结" class="headerlink" title="4.窗口状态变化总结"></a>4.窗口状态变化总结</h3><p>WMS为了管理窗口的显示进度，在WindowStateAnimator中定义了mDrawState来描述Surface所处的状态。主要有如下五种状态：<br>NO_SURFACE:WMS添加窗口,即调用addWindow之后，还没有创建Surface，mDrawState处于该状态。<br>DRAW_PENDING:app调用relayoutWindow创建Surface后，但是Surface还没有进行绘制，mDrawState处于该状态。<br>COMMIT_DRAW_PENDING:app完成Surface的绘制，调用finishDrawing，将mDrawState设置为该状态。<br>READY_TO_SHOW:在performSurfacePlacement过程中会将所有处于COMMIT_DRAW_PENDING状态的mDrawState变更为READY_TO_SHOW。<br>HAS_DRAW:若准备显示窗口，WMS执行performShowLocked，将mDrawState设置为该状态<br><img src="/../../../../../images/ad8fdb698a23430a942bcfd773fcba80.png" alt="在这里插入图片描述"></p>
<p>窗口显示相关方法</p>
<p>工作内容解释</p>
<p>addWindow</p>
<p>App向WMS请求添加窗口记录，会在WMS里新建WindowState(NO_SURFACE)</p>
<p>relayoutWindow</p>
<p>App向WMS申请surface用于绘制，执行后window拥有了surface(NO_SURFACE-&gt;DRAW_PENDING)</p>
<p>finishDrawingWindow</p>
<p>App在surface上完成绘制后，通知WMS(DRAW_PENDING-&gt;COMMIT_DRAW_PENDING)</p>
<p>commitFinishDrawingLocked</p>
<p>WMS遍历window，对于完成绘制的window(COMMIT_DRAW_PENDING-&gt;READY_TO_SHOW)</p>
<p>performShowLocked</p>
<p>判断系统是否允许窗口显示isReadyForDisplay(READY_TO_SHOW-&gt;HAS_DRAWN)</p>
<p>showSurfaceRobustlyLocked</p>
<p>对HAS_DRAWN状态的窗口，用SurfaceControl通知SurfaceFlinger显示出来</p>
<h3 id="5-移除流程简述"><a href="#5-移除流程简述" class="headerlink" title="5.移除流程简述"></a>5.移除流程简述</h3><p>窗口移除从App端发起，当Activity执行destroy(),即以handleDestroyActivity()为起点，执行wm.removeViewImmediate()开启；<br><strong>通过WindowManagerGlobal–&gt;ViewRootImpl–&gt;Session–&gt;WindowManagerService的removeWindow()，调用到WindowState的removeIfPossible()–&gt;removeImmediately()，接着调用到WindowStateAnimator的destroySurfaceLocked()–&gt;destroySurface(),逐步调用改变绘制状态为NO_SURFACE–&gt;WindowSurfaceController的destroy()最终调用到SurfaceControl的remove()来通知SurfaceFlinger来移除layer</strong>；</p>
<h2 id="三、代码流程详解"><a href="#三、代码流程详解" class="headerlink" title="三、代码流程详解"></a>三、代码流程详解</h2><h3 id="1-客户端-1"><a href="#1-客户端-1" class="headerlink" title="1.客户端"></a>1.客户端</h3><h4 id="1-1-Activity走到onresume后"><a href="#1-1-Activity走到onresume后" class="headerlink" title="1.1 Activity走到onresume后"></a>1.1 Activity走到onresume后</h4><p>从ActivityThread.handleResumeActivity方法看起<br>1.调用performResumeActivity，执行onResume。<br>2.获取WindowManager的实现类WindowManagerImpl的实例。<br>3.调用WindowManagerImpl.addView传入DecorView和当前布局参数WindowManager.LayoutParams。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p>
<pre><code>@Override
    public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,
            boolean isForward, String reason) &#123;
            ......
        // TODO Push resumeArgs into the activity for consideration
        // skip below steps for double-resume and r.mFinish = true case.
        /*1.执行onResume*/
        if (!performResumeActivity(r, finalStateRequest, reason)) &#123;
            return;
        &#125;
        ......
        //获取Activity实例
        final Activity a = r.activity;
        ......
        // If the window hasn&#39;t yet been added to the window manager,
        // and this guy didn&#39;t finish itself or start another activity,
        // then go ahead and add the window.
        //mStartedActivity在performLaunchActivity和performResumeActivity方法中被置为false
        boolean willBeVisible = !a.mStartedActivity;
        ......
        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;
            //获取当前Activity的PhoneWindow
            r.window = r.activity.getWindow();
            //从PhoneWindow中获取DecorView
            View decor = r.window.getDecorView();
            //将view的可见性状态设置为INVISIBLE,view不可见但是仍然占用布局空间
            decor.setVisibility(View.INVISIBLE);
            /*2.获取WindowManager的实现类WindowManagerImpl的实例*/
            ViewManager wm = a.getWindowManager();
            //获取布局参数
            WindowManager.LayoutParams l = r.window.getAttributes();
            //将phoneWindow的DecorView赋值给mDecor
            a.mDecor = decor;
            //设置窗口类型为TYPE_BASE_APPLICATION
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (r.mPreserveWindow) &#123;
                a.mWindowAdded = true;
                r.mPreserveWindow = false;
                // Normally the ViewRoot sets up callbacks with the Activity
                // in addView-&gt;ViewRootImpl#setView. If we are instead reusing
                // the decor view we have to notify the view root that the
                // callbacks may have changed.
                ViewRootImpl impl = decor.getViewRootImpl();
                if (impl != null) &#123;
                    impl.notifyChildRebuilt();
                &#125;
            &#125;
            if (a.mVisibleFromClient) &#123;
                if (!a.mWindowAdded) &#123;
                    a.mWindowAdded = true;
                    /*3.传入DecorView和当前布局参数WindowManager.LayoutParams*/
                    wm.addView(decor, l);
                &#125; else &#123;
                    // The activity will get a callback for this &#123;@link LayoutParams&#125; change
                    // earlier. However, at that time the decor will not be set (this is set
                    // in this method), so no action will be taken. This call ensures the
                    // callback occurs with the decor set.
                    a.onWindowAttributesChanged(l);
                &#125;
            &#125;
        &#125;
        ......
    &#125;
</code></pre>
<p><code>wm.addView(decor, l);</code>WindowManager接口的实现是WindowManagerImpl，即实际调用的是WindowManagerImpl中的addView方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerImpl.java</p>
<pre><code>    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;
        applyTokens(params);
        //转交给windowManagerGlobal，添加view
        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
                mContext.getUserId());
    &#125;
</code></pre>
<p>WindowManagerImpl对窗口的管理交给WindowManagerGlobal，调用WindowManagerGlobal的addView方法<br>WindowManagerGlobal中对窗口的处理主要如下几个步骤：<br>1.对WindowManagerImpl传进来的参数进行检查。<br>2.设置WindowManager.LayoutParams中的token、title等相关属性。查看“【<strong>1.2 Token的创建与传递</strong>】”。<br>3.创建ViewRootImpl对象，并获取客户端与WMS通信的Session。查看“【<strong>1.3 ViewRootImpl的创建</strong>】”。<br>4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。<br>5.调用ViewRootImpl，与WMS通信添加窗口。查看“【<strong>1.4 ViewRootImpl与WMS的通信</strong>】”。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p>
<pre><code>    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow, int userId) &#123;
        /*1.对WindowManagerImpl传进来的参数进行检查*/
        if (view == null) &#123;
            throw new IllegalArgumentException(&quot;view must not be null&quot;);
        &#125;
        if (display == null) &#123;
            throw new IllegalArgumentException(&quot;display must not be null&quot;);
        &#125;
        if (!(params instanceof WindowManager.LayoutParams)) &#123;
            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);
        &#125;

        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
        //此处的ParentWindow即当Activity的PhoneWindow
        if (parentWindow != null) &#123;
            /*2.为wparams的token进行赋值*/
            parentWindow.adjustLayoutParamsForSubWindow(wparams);
        &#125; else &#123;
            ......
        &#125;

        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) &#123;
            ......
            IWindowSession windowlessSession = null;
            ......
            if (windowlessSession == null) &#123;
                   /*3.新建ViewRootImpl，在新建时会通过WindowManagerGlobal获取session*/
                root = new ViewRootImpl(view.getContext(), display);
            &#125; else &#123;
                root = new ViewRootImpl(view.getContext(), display,
                        windowlessSession);
            &#125;

            view.setLayoutParams(wparams);
            /*4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。*/
            //当前view加入到view列表中
            mViews.add(view);
            //将新建的viewRootImpl加入到root列表中
            mRoots.add(root);
            //将当前布局参数加入到布局参数列表中
            mParams.add(wparams);

            // do this last because it fires off messages to start doing things
            try &#123;
                /*5.调用ViewRootImpl，设置view，panelParentView为null，与WMS通信添加窗口*/
                root.setView(view, wparams, panelParentView, userId);
            &#125; catch (RuntimeException e) &#123;
                // BadTokenException or InvalidDisplayException, clean up.
                if (index &gt;= 0) &#123;
                    removeViewLocked(index, true);
                &#125;
                throw e;
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="1-2-Token的创建与传递"><a href="#1-2-Token的创建与传递" class="headerlink" title="1.2 Token的创建与传递"></a>1.2 Token的创建与传递</h4><p><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>调用Window的adjustLayoutParamsForSubWindow()方法<br>在adjustLayoutParamsForSubWindow中会分别对WindowManager.LayoutParams中的token以及title进行赋值。<br>1.首先针对子窗口、系统窗口以及应用窗口做了不同的处理，此处我们只关注应用窗口的处理。<br>2.其次将当前PhoneWindow.mAppToken赋值给WindowManager.LayoutParams.token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p>
<pre><code>    void adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123;
        CharSequence curTitle = wp.getTitle();
        if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;
                wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;
                //对子窗口的Token以及Title赋值
                ......
        &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp;
                wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;
                //对子窗口的Token以及Title赋值
                ......
        &#125; else &#123;
            //对应用窗口的Token以及Title赋值
            if (wp.token == null) &#123;
                //将当前PhoneWindow的mAppToken赋值给wp.Token
                wp.token = mContainer == null ? mAppToken : mContainer.mAppToken;
            &#125;
            //将Title设置为mAppName
            if ((curTitle == null || curTitle.length() == 0)
                    &amp;&amp; mAppName != null) &#123;
                wp.setTitle(mAppName);
            &#125;
        &#125;
        //设置为packageName 
        if (wp.packageName == null) &#123;
            wp.packageName = mContext.getPackageName();
        &#125;
        ......
    &#125;
</code></pre>
<p>此处的mAppToken便是在Activity启动时，在ATMS端创建的Token。<br>接下来我们看看Token是如何从ATMS端传递过来，并赋值给PhoneWindow.mAppToken的<br><img src="/../../../../../images/e778248cfd7e4dd5a3fa856039013d62.png" alt="在这里插入图片描述"></p>
<p>1.在ATMS端新建ActivityRecord时，便新建了Token。并赋值给ActivityRecord.token<br>ActivityRecord继承WindowToken<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p>
<pre><code> private ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,
            int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage,
            @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType,
            ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,
            String _resultWho, int _reqCode, boolean _componentSpecified,
            boolean _rootVoiceInteraction, ActivityTaskSupervisor supervisor,
            ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState,
            TaskDescription _taskDescription, long _createTime) &#123;
        //新建Token
        super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
                null /* displayContent */, false /* ownerCanManageAppTokens */);
        ......
&#125;
</code></pre>
<p>2.将ActivityRecord.token封装在clientTransaction中，并将这个传递到客户端<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskSupervisor.java</p>
<pre><code>    boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
            boolean andResume, boolean checkConfig) throws RemoteException &#123;
        ......
        final Task task = r.getTask();
        final Task rootTask = task.getRootTask();
        ......

        try &#123;
            ......

            try &#123;
                ......
                // Create activity launch transaction.
                /*将ActivityRecord.token封装在clientTransaction中*/
                final ClientTransaction clientTransaction = ClientTransaction.obtain(
                        proc.getThread(), r.token);

                final boolean isTransitionForward = r.isTransitionForward();
                final IBinder fragmentToken = r.getTaskFragment().getFragmentToken();
                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
                        System.identityHashCode(r), r.info,
                        // TODO: Have this take the merged configuration instead of separate global
                        // and override configs.
                        mergedConfiguration.getGlobalConfiguration(),
                        mergedConfiguration.getOverrideConfiguration(), r.compat,
                        r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor,
                        proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(),
                        results, newIntents, r.takeOptions(), isTransitionForward,
                        proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController,
                        r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken));
                ......

                // Schedule transaction.
                /*将clientTransaction传递给客户端*/
                mService.getLifecycleManager().scheduleTransaction(clientTransaction);
                ......

            &#125; catch (RemoteException e) &#123;
                ......
            &#125;
        &#125; finally &#123;
            ......
        &#125;
        ......
        return true;
    &#125;
</code></pre>
<p><code>final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.token);</code><br>在ClientTransaction中调用obtain方法，把ActivityRecord.token存到mActivityToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;ClientTransaction.java</p>
<pre><code>    /** Obtain an instance initialized with provided params. */
    public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123;
        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);
        if (instance == null) &#123;
        //创建ClientTransaction
            instance = new ClientTransaction();
        &#125;
        instance.mClient = client;
        /*把ActivityRecord.token存到mActivityToken*/
        //private IBinder mActivityToken;
        instance.mActivityToken = activityToken;

        return instance;
    &#125;
</code></pre>
<p>3.客户端从ClientTransaction中获取ATMS端传来的Token，并传递到LaunchActivityItem中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;TransactionExecutor.java</p>
<pre><code>   /** Cycle through all states requested by callbacks and execute them at proper times. */
    @VisibleForTesting
    public void executeCallbacks(ClientTransaction transaction) &#123;
        final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();
        ......
        /*从ClientTransaction中获取ATMS端传来的Token*/
        final IBinder token = transaction.getActivityToken();
        ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
        ......

        final int size = callbacks.size();
        for (int i = 0; i &lt; size; ++i) &#123;
            final ClientTransactionItem item = callbacks.get(i);
            ......
            /*将Token传递到LaunchActivityItem中*/
            item.execute(mTransactionHandler, token, mPendingActions);
            item.postExecute(mTransactionHandler, token, mPendingActions);
            ......
        &#125;
    &#125;
</code></pre>
<p>4.在LaunchActivityItem中将客户端传过来的Token保存在ActivityClientRecord.token中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;LaunchActivityItem.java</p>
<pre><code>    @Override
    public void execute(ClientTransactionHandler client, IBinder token,
            PendingTransactionActions pendingActions) &#123;
        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
        //将客户端传过来的Token保存在ActivityClientRecord的token中
        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,
                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,
                mPendingResults, mPendingNewIntents, mActivityOptions, mIsForward, mProfilerInfo,
                client, mAssistToken, mShareableActivityToken, mLaunchedFromBubble,
                mTaskFragmentToken);
        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);
        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
    &#125;
</code></pre>
<p><code>client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</code>ClientTransactionHandler调用handleLaunchActivity方法，ClientTransactionHandler为抽象类，其子类为ActivityThread，即实际调用的是该类中的handleLaunchActivity()，有从该方法中调用到了performLaunchActivity()<br>5.客户端ActivityThread将ActivityClientRecord以及其对应的token保存在ActivityThread.mActivities数组中，并调用Activity.attach将Token传给Activity。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p>
<pre><code>    /**  Core implementation of activity launch. */
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;
        ......
        try &#123;
            Application app = r.packageInfo.makeApplicationInner(false, mInstrumentation);
            ......
            synchronized (mResourcesManager) &#123;
                /*将ActivityClientRecord以及其对应的Token保存在mActivities中*/
                //mActivities的类型为ArrayMap&lt;IBinder, ActivityClientRecord&gt;
                mActivities.put(r.token, r);
            &#125;

            if (activity != null) &#123;
                ......
                /*将Token赋值给Activity.mToken*/
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.activityConfigCallback,
                        r.assistToken, r.shareableActivityToken);
                ......

        &#125; catch (SuperNotCalledException e) &#123;
            throw e;

        &#125; catch (Exception e) &#123;
            ......
        &#125;

        return activity;
    &#125;
</code></pre>
<p>6.在Activity中将客户端传来的Token赋值给Activity.mToken。此外在该方法中还新建了PhoneWindow,并将PhoneWindow.mAppToken也设置为客户端传过来的Token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Activity.java</p>
<pre><code>    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,
            IBinder shareableActivityToken) &#123;
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);
        /*新建PhoneWindow*/
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        ......
        /*将客户端传过来的Token赋值给mToken*/
        mToken = token;
        ......
        /*PhoneWindow.mAppToken设置为当前客户端传递过来的Token*/
        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        ......
    &#125;
</code></pre>
<p>PhoneWindow继承Window，setWindowManager实际调用的是其父类方法，把mAppToken设置为当前客户端传递过来的mToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p>
<pre><code>    /**
     * Set the window manager for use by this Window to, for example,
     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the
     * Window itself -- that must be done by the client.
     *
     * @param wm The window manager for adding new windows.
     */
    public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123;
        //传递客户端的mToken给appToken
        setWindowManager(wm, appToken, appName, false);
    &#125;

    /**
     * Set the window manager for use by this Window to, for example,
     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the
     * Window itself -- that must be done by the client.
     *
     * @param wm The window manager for adding new windows.
     */
    public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) &#123;
        /*把appToken赋值给mAppToken*/
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated;
        if (wm == null) &#123;
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        &#125;
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    &#125;
</code></pre>
<h4 id="1-3-ViewRootImpl的创建"><a href="#1-3-ViewRootImpl的创建" class="headerlink" title="1.3 ViewRootImpl的创建"></a>1.3 ViewRootImpl的创建</h4><p><code>root = new ViewRootImpl(view.getContext(), display);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用创建ViewRootImpl，这里我们看下ViewRootImpl的构造方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</p>
<pre><code>    public ViewRootImpl(Context context, Display display) &#123;
        this(context, display, WindowManagerGlobal.getWindowSession(),
                false /* useSfChoreographer */);
    &#125;

    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) &#123;
        this(context, display, session, false /* useSfChoreographer */);
    &#125;

    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
            boolean useSfChoreographer) &#123;
        mContext = context;
        mWindowSession = session;
        ......
    &#125;
</code></pre>
<p>从这个构造方法中我们可以看出，通过WindowManagerGlobal.getWindowSession获取到客户端与WMS沟通的桥梁IWindowSession，并将其赋值给ViewRootImpl.mWindowSession。</p>
<p>下面我们查看WindowManagerGlobal中是如何获取Session的。<br>1.通过getWindowManagerService获取IWindowManager，而WindowManagerService则实现了这个Binder接口。<br>2.调用IWindowManager.openSession方法即WMS.openSession，在WMS端便会新建Session。至此客户端与WMS通信的桥梁便已经搭建好了<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p>
<pre><code>    @UnsupportedAppUsage
    public static IWindowSession getWindowSession() &#123;
        synchronized (WindowManagerGlobal.class) &#123;
            if (sWindowSession == null) &#123;
                try &#123;
                    // Emulate the legacy behavior.  The global instance of InputMethodManager
                    // was instantiated here.
                    // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage
                    InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();
                    /*1.获取Binder*/
                    IWindowManager windowManager = getWindowManagerService();
                    /*2.调用WMS的openSession*/
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() &#123;
                                @Override
                                public void onAnimatorScaleChanged(float scale) &#123;
                                    ValueAnimator.setDurationScale(scale);
                                &#125;
                            &#125;);
                &#125; catch (RemoteException e) &#123;
                    throw e.rethrowFromSystemServer();
                &#125;
            &#125;
            return sWindowSession;
        &#125;
    &#125;
</code></pre>
<p>从代码中可以看出如果sWindowSession不为空则直接返回，sWindowSession为当前WindowManagerGlobal属性，且WindowManagerGloba又是单例的，所以客户端一个进程中只有一个IWindowSession与WMS通信。如果sWindowSession为空，则会创建IWindowSession。</p>
<p>调用WindowManagerService中的openSession，新建Session<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    @Override
    public IWindowSession openSession(IWindowSessionCallback callback) &#123;
        /*新建Session*/
        return new Session(this, callback);
    &#125;
</code></pre>
<h4 id="1-4-ViewRootImpl与WMS的通信"><a href="#1-4-ViewRootImpl与WMS的通信" class="headerlink" title="1.4 ViewRootImpl与WMS的通信"></a>1.4 ViewRootImpl与WMS的通信</h4><p><code>root.setView(view, wparams, panelParentView, userId);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用ViewRootImpl与WMS的通信，继续看看<br>当前方法是与WMS进行通信添加窗口的入口，在此处我们只关注两点:<br>1.requestLayout()该方法会调用到doTraversal()，之后调用performTraversals()，最终调用到relayoutWindow()和reportDrawFinished()流程，在通过Session与服务端通信<br>2.mWindowSession.addToDisplayAsUser，与服务端进行Binder通信，调用Session的addToDisplayAsUser方法。</p>
<pre><code>   /**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;
        setView(view, attrs, panelParentView, UserHandle.myUserId());
    &#125;

    /**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
            int userId) &#123;
        synchronized (this) &#123;
            if (mView == null) &#123;
                mView = view;
                ......
                //将布局参数拷贝纸mWindowAttributes
                mWindowAttributes.copyFrom(attrs);
                //设置包名
                if (mWindowAttributes.packageName == null) &#123;
                    mWindowAttributes.packageName = mBasePackageName;
                &#125;
                mWindowAttributes.privateFlags |=
                        WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;

                attrs = mWindowAttributes;
                ......
                // Keep track of the actual window flags supplied by the client.
                //获取当前布局的flags
                mClientWindowLayoutFlags = attrs.flags;
                ......
                int res; /* = WindowManagerImpl.ADD_OKAY; */

                // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                /*请求布局，对应服务端layoutWindow流程*/
                requestLayout();
                InputChannel inputChannel = null;
                if ((mWindowAttributes.inputFeatures
                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;
                    inputChannel = new InputChannel();
                &#125;
                ......

                try &#123;
                    ......
                    /*与服务端进行Binder通信，调用Session的addToDisplayAsUser方法*/
                    //执行addWindow的相关流程
                    res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(), userId,
                            mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                            mTempControls);
                    ......
                &#125; catch (RemoteException e) &#123;
                    ......
                &#125; finally &#123;
                    if (restore) &#123;
                        attrs.restore();
                    &#125;
                &#125;
                ......
                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow);
                if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;
                    mAttachInfo.mRootView = null;
                    mAdded = false;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    switch (res) &#123;
                        case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                        case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- token &quot; + attrs.token
                                    + &quot; is not valid; is your activity running?&quot;);
                        case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- token &quot; + attrs.token
                                    + &quot; is not for an application&quot;);
                        case WindowManagerGlobal.ADD_APP_EXITING:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- app for token &quot; + attrs.token
                                    + &quot; is exiting&quot;);
                        case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- window &quot; + mWindow
                                    + &quot; has already been added&quot;);
                        case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                            // Silently ignore -- we would have just removed it
                            // right away, anyway.
                            return;
                        case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- another window of type &quot;
                                    + mWindowAttributes.type + &quot; already exists&quot;);
                        case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- permission denied for window type &quot;
                                    + mWindowAttributes.type);
                        case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- the specified display can not be found&quot;);
                        case WindowManagerGlobal.ADD_INVALID_TYPE:
                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- the specified window type &quot;
                                    + mWindowAttributes.type + &quot; is not valid&quot;);
                        case WindowManagerGlobal.ADD_INVALID_USER:
                            throw new WindowManager.BadTokenException(&quot;Unable to add Window &quot;
                                    + mWindow + &quot; -- requested userId is not valid&quot;);
                    &#125;
                    throw new RuntimeException(
                            &quot;Unable to add window -- unknown error code &quot; + res);
                &#125;
                ......
            &#125;
        &#125;
    &#125;
</code></pre>
<p>其中关键的添加代码为</p>
<pre><code>res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
        getHostVisibility(), mDisplay.getDisplayId(), userId,
        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
        mTempControls);
</code></pre>
<p><code>addToDisplayAsUser()</code>方法最终会走到WindowManagerService.java的addWindow方法，addWindow方法的返回值最后会返回给<code>res</code>，之后回看ViewRootImpl的setView方法，返回值如果满足<code>if (res &lt; WindowManagerGlobal.ADD_OKAY)</code>条件，那么会根据<code>switch (res)</code>中对应的case抛出异常。<br>至此，客户端流程结束，后面进入服务端流程。</p>
<h3 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h3><h4 id="2-1-窗口添加"><a href="#2-1-窗口添加" class="headerlink" title="2.1 窗口添加"></a>2.1 窗口添加</h4><p>WMS通过Session接受客户端添加窗口的请求，因此WMS会新建WindowState、将WindowState加入到WindowToken，并更新WindowToken下所有WindowState的z-order。<br>客户端通过Binder通信调用WMS端的Session.addToDisplayAsUser进入addWindow的流程。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.WindowState初始化<br>3.WindowState加入到WIndowToken</p>
<h5 id="2-1-1-接收客户端请求"><a href="#2-1-1-接收客户端请求" class="headerlink" title="2.1.1 接收客户端请求"></a>2.1.1 接收客户端请求</h5><p>客户端传递给Session的参数<br>IWindow window:是WMS与客户端通信的句柄。<br>WindowManager.LayoutParams arrts：窗口布局参数。<br>viewVisibility：附着在窗口的rootView的可见性。<br>displayId：顾名思义，display id表示的是DisplayContent即屏幕的id。<br>InsetsVisibilities requestedVisibilities:当前对象的mVisibilities记录了insets的可见性。<br>InputChannel outInputChannel：InputDispatcher接收InputReader读取到的事件，分发给对应窗口，InputDispatcher属于system_server进程和各个应用不在同一进程，它们之间的联系靠的就是InputChannel。<br>InsetsState outInsetsState：用来保存系统中所有Insets的状态，该对象只是在客户端创建，内部属性需要在WMS端赋值。<br>InsetsSourceControl[] outActiveControls：InSetsSourceControl数组。该对象也是只在客户端创建，内部属性需要在WMS端赋值。<br>Session调用<strong>WindowManagerService.addWindow</strong> 将客户端传入的参数传递给WindowManagerService。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public int addToDisplayAsUser(IWindow window, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, int userId, InsetsVisibilities requestedVisibilities,
            InputChannel outInputChannel, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls) &#123;
        return mService.addWindow(this, window, attrs, viewVisibility, displayId, userId,
                requestedVisibilities, outInputChannel, outInsetsState, outActiveControls);
    &#125;
</code></pre>
<h5 id="2-1-2-addWindow"><a href="#2-1-2-addWindow" class="headerlink" title="2.1.2 addWindow"></a>2.1.2 addWindow</h5><p>添加窗口的主要逻辑均在WMS.addWindow执行，该方法主要实现以下功能：<br>1.首先进行权限验证以及各种条件判断。<br>2.根据客户端传来的token获取windowToken。<br>3.借助客户端传来的参数，创建WindowState实例，并将其加入到WMS. mWindowMap中。<br>4.将新建的WindowState加入到相应的WindowToken，并为每个窗口赋值一个z-order。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility,
            int displayId, int requestUserId, InsetsVisibilities requestedVisibilities,
            InputChannel outInputChannel, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls) &#123;
        ......
        
        /*1.进行权限验证以及各种条件判断*/
        //判断调用者是否有权限add window
        int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,
                appOp);
        if (res != ADD_OKAY) &#123;
            return res;
        &#125;

        WindowState parentWindow = null;
        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();
        //获取将要添加的窗口类型
        final int type = attrs.type;

        synchronized (mGlobalLock) &#123;
            ......
            //根据displayId以及客户端传过来的token获取相应的displayContent
            final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
            ......
            //判断mWindowMap中是否已经存在当前客户端的key,如果有则已经将当前客户端的window添加了，无需重复添加
            if (mWindowMap.containsKey(client.asBinder())) &#123;
                ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client);
                return WindowManagerGlobal.ADD_DUPLICATE_ADD;
            &#125;
            //判断是否是子窗口
            if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;
                parentWindow = windowForClientLocked(null, attrs.token, false);
                if (parentWindow == null) &#123;
                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is not a window: &quot;
                            + &quot;%s.  Aborting.&quot;, attrs.token);
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                &#125;
                if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW
                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;
                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is a sub-window: &quot;
                            + &quot;%s.  Aborting.&quot;, attrs.token);
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                &#125;
            &#125;
            //判断当前DisplayContent是否是私有的，只拥有该display或者display已经的应用才可以在其上创建
            if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) &#123;
                ProtoLog.w(WM_ERROR,
                        &quot;Attempted to add private presentation window to a non-private display.  &quot;
                                + &quot;Aborting.&quot;);
                return WindowManagerGlobal.ADD_PERMISSION_DENIED;
            &#125;
            ......
            ActivityRecord activity = null;
            //设置是否有父窗口的标志位
            final boolean hasParent = parentWindow != null;
            // Use existing parent window token for child windows since they go in the same token
            // as there parent window so we can apply the same policy on them.
           
             /*2.根据客户端传来的token获取windowToken*/
            //attrs.token去DisplayContent.mTokenMap中去取WindowToken
            //那么WindowToken是什么时候加入到mTokenMap中的呢
            	//这就要追溯到Activity的启动时，加入到DisplayContent中
            //在ActivityStarter.startActivityInner中调用addOrReparentStartingActivity通过addChild一步步调用到WindowContainert中。
            //在调用setParent,最终通过onDisplayChanged将ActivityRecord加入到DisplayContent.mTokenMap中
            WindowToken token = displayContent.getWindowToken(
                    hasParent ? parentWindow.mAttrs.token : attrs.token);
            // If this is a child window, we want to apply the same type checking rules as the
            // parent window type.
            final int rootType = hasParent ? parentWindow.mAttrs.type : type;

            boolean addToastWindowRequiresToken = false;

            final IBinder windowContextToken = attrs.mWindowContextToken;

            if (token == null) &#123;
            ......
             &#125;else if (rootType &gt;= FIRST_APPLICATION_WINDOW
                    &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;
                //当前窗口为应用窗口，通过token，获取ActivityRecord
                activity = token.asActivityRecord();
            ......
            &#125; else if (token.asActivityRecord() != null) &#123;
                ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;,
                        rootType);
                // It is not valid to use an app token with other system types; we will
                // instead make a new token for it (as if null had been passed in for the token).
                attrs.token = null;
                token = new WindowToken.Builder(this, client.asBinder(), type)
                        .setDisplayContent(displayContent)
                        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)
                        .build();
            &#125;
            /*3.创建WindowState*/
            final WindowState win = new WindowState(this, session, client, token, parentWindow,
                    appOp[0], attrs, viewVisibility, session.mUid, userId,
                    session.mCanAddInternalSystemWindow);
            //将客户端传过来的Insets可见性赋值给WindowState的requestedVisibilities
            win.setRequestedVisibilities(requestedVisibilities);
            //验证当前窗口是否可以添加到WMS
            res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);
            if (res != ADD_OKAY) &#123;
                return res;
            &#125;
            //调用openInputChannel，初始化input相关通路
            final boolean openInputChannels = (outInputChannel != null
                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);
            if  (openInputChannels) &#123;
                win.openInputChannel(outInputChannel);
            &#125;
            //创建SufaceSession用于SurfaceFlinger通信
            win.attach();
            //将客户端与WindowState加入到mWindowMap中
            mWindowMap.put(client.asBinder(), win);
            win.initAppOpsState();
            ......
            /*4.将WindowState加入到WindowToken*/
            win.mToken.addWindow(win);
            ......
        return res;
    &#125;
</code></pre>
<p><strong>mWindowMap保存了每个WindowState和客户端窗口的映射关系，客户端应用请求窗口操作时，通过mWindowMap查询到对应的WindowState</strong></p>
<h5 id="2-1-3-WindowToken的创建"><a href="#2-1-3-WindowToken的创建" class="headerlink" title="2.1.3 WindowToken的创建"></a>2.1.3 WindowToken的创建</h5><pre><code>token = new WindowToken.Builder(this, client.asBinder(), type)
        .setDisplayContent(displayContent)
        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)
        .build();
</code></pre>
<p>这里调用的是其WindowToken自身的build方法创建<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p>
<pre><code>WindowToken build() &#123;
    return new WindowToken(mService, mToken, mType, mPersistOnEmpty, mDisplayContent,
            mOwnerCanManageAppTokens, mRoundedCornerOverlay, mFromClientToken, mOptions);
&#125;

protected WindowToken(WindowManagerService service, IBinder _token, int type,
        boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens,
        boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123;
    super(service);
    token = _token;
    windowType = type;
    mOptions = options;
    mPersistOnEmpty = persistOnEmpty;
    mOwnerCanManageAppTokens = ownerCanManageAppTokens;
    mRoundedCornerOverlay = roundedCornerOverlay;
    mFromClientToken = fromClientToken;
    if (dc != null) &#123;
        dc.addWindowToken(token, this);
    &#125;
&#125;
</code></pre>
<p><code>dc.addWindowToken(token, this);</code>在WindowToken构造方法中，调用DisplayContent.addWindowToken将WindowToken添加到以DisplayContent为根节点的WindowContainer层级结构中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    void addWindowToken(IBinder binder, WindowToken token) &#123;
        final DisplayContent dc = mWmService.mRoot.getWindowTokenDisplay(token);
        if (dc != null) &#123;
            // We currently don&#39;t support adding a window token to the display if the display
            // already has the binder mapped to another token. If there is a use case for supporting
            // this moving forward we will either need to merge the WindowTokens some how or have
            // the binder map to a list of window tokens.
            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;
                    + getName() + &quot; already mapped to display=&quot; + dc + &quot; tokens=&quot; + dc.mTokenMap);
        &#125;
        if (binder == null) &#123;
            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;
                    + getName() + &quot; binder is null&quot;);
        &#125;
        if (token == null) &#123;
            throw new IllegalArgumentException(&quot;Can&#39;t map null token to display=&quot;
                    + getName() + &quot; binder=&quot; + binder);
        &#125;

        mTokenMap.put(binder, token);

        if (token.asActivityRecord() == null) &#123;
            // Set displayContent for non-app token to prevent same token will add twice after
            // onDisplayChanged.
            // TODO: Check if it&#39;s fine that super.onDisplayChanged of WindowToken
            //  (WindowsContainer#onDisplayChanged) may skipped when token.mDisplayContent assigned.
            token.mDisplayContent = this;
            // Add non-app token to container hierarchy on the display. App tokens are added through
            // the parent container managing them (e.g. Tasks).
            //1.调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。
            final DisplayArea.Tokens da = findAreaForToken(token).asTokens();
            //2.将WindowToken添加到父容器中。
            da.addChild(token);
        &#125;
    &#125;
</code></pre>
<p>这里我们分两步看<br>1.<code>final DisplayArea.Tokens da = findAreaForToken(token).asTokens();</code>调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。</p>
<pre><code>    /**
     * Finds the &#123;@link DisplayArea&#125; for the &#123;@link WindowToken&#125; to attach to.
     * &lt;p&gt;
     * Note that the differences between this API and
     * &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; is that this API finds a
     * &#123;@link DisplayArea&#125; in &#123;@link DisplayContent&#125; level, which may find a &#123;@link DisplayArea&#125;
     * from multiple &#123;@link RootDisplayArea RootDisplayAreas&#125; under this &#123;@link DisplayContent&#125;&#39;s
     * hierarchy, while &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; finds a
     * &#123;@link DisplayArea.Tokens&#125; from a &#123;@link DisplayArea.Tokens&#125; list mapped to window layers.
     * &lt;/p&gt;
     *
     * @see DisplayContent#findAreaForTokenInLayer(WindowToken)
     */
    DisplayArea findAreaForToken(WindowToken windowToken) &#123;
        return findAreaForWindowType(windowToken.getWindowType(), windowToken.mOptions,
                windowToken.mOwnerCanManageAppTokens, windowToken.mRoundedCornerOverlay);
    &#125;
</code></pre>
<p>​    </p>
<p>为传入的WindowToken找到一个DisplayArea对象来添加进去。</p>
<pre><code>    DisplayArea findAreaForWindowType(int windowType, Bundle options,
            boolean ownerCanManageAppToken, boolean roundedCornerOverlay) &#123;
        // TODO(b/159767464): figure out how to find an appropriate TDA.
        //1.如果是App窗口，那么返回默认的TaskDisplayArea对象。
        if (windowType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; windowType &lt;= LAST_APPLICATION_WINDOW) &#123;
            return getDefaultTaskDisplayArea();
        &#125;

        // Return IME container here because it could be in one of sub RootDisplayAreas depending on
        // the focused edit text. Also, the RootDisplayArea choosing strategy is implemented by
        // the server side, but not mSelectRootForWindowFunc customized by OEM.
        //2.如果是输入法窗口，那么返回ImeContainer。
        if (windowType == TYPE_INPUT_METHOD || windowType == TYPE_INPUT_METHOD_DIALOG) &#123;
            return getImeContainer();
        &#125;
        //3.如果是其他类型，继续寻找。
        return mDisplayAreaPolicy.findAreaForWindowType(windowType, options,
                ownerCanManageAppToken, roundedCornerOverlay);
    &#125;
</code></pre>
<p>如果是App窗口，那么返回默认的TaskDisplayArea对象。<br>如果是输入法窗口，那么返回ImeContainer。<br>如果是其他类型，继续寻找。<br><code>mDisplayAreaPolicy.findAreaForWindowType(windowType, options, ownerCanManageAppToken, roundedCornerOverlay);</code>调用的是DisplayAreaPolicy中的findAreaForWindowType方法，DisplayAreaPolicy为抽象类,DisplayAreaPolicyBuilder中的Result继承了该类<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>static class Result extends DisplayAreaPolicy &#123;
    ......
       @Override
       public DisplayArea.Tokens findAreaForWindowType(int type, Bundle options,
               boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123;
           return mSelectRootForWindowFunc.apply(type, options).findAreaForWindowTypeInLayer(type,
                   ownerCanManageAppTokens, roundedCornerOverlay);
       &#125;
       ......
</code></pre>
<p>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootDisplayArea.java</p>
<pre><code>  DisplayArea.Tokens findAreaForWindowTypeInLayer(int windowType, boolean ownerCanManageAppTokens,
           boolean roundedCornerOverlay) &#123;
       //通过getWindowLayerFromTypeLw方法获取对应的窗口类型
       int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,
               ownerCanManageAppTokens, roundedCornerOverlay);
       if (windowLayerFromType == APPLICATION_LAYER) &#123;
           throw new IllegalArgumentException(
                   &quot;There shouldn&#39;t be WindowToken on APPLICATION_LAYER&quot;);
       &#125;
       return mAreaForLayer[windowLayerFromType];
   &#125;
</code></pre>
<p>通过getWindowLayerFromTypeLw方法计算出该窗口的类型对应的层级值windowLayerFromType，然后从mAreaForLayer数组中，找到windowLayerFromType对应的那个DisplayArea.Tokens对象。<br>2. <code>da.addChild(token);</code>将WindowToken添加到父容器（叶子节点）中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayArea.java</p>
<pre><code>    /**
     * DisplayArea that contains WindowTokens, and orders them according to their type.
     */
    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;
        ......
        void addChild(WindowToken token) &#123;
            addChild(token, mWindowComparator);
        &#125;
        ......
</code></pre>
<p><code>addChild(token, mWindowComparator);</code>最终调用到WindowContainer.addChild方法添加WindowToken到叶子节点</p>
<h5 id="2-1-4-WindowState初始化"><a href="#2-1-4-WindowState初始化" class="headerlink" title="2.1.4 WindowState初始化"></a>2.1.4 WindowState初始化</h5><p>在addWindow中初始化WindowState</p>
<pre><code>final WindowState win = new WindowState(this, session, client, token, parentWindow,
        appOp[0], attrs, viewVisibility, session.mUid, userId,
        session.mCanAddInternalSystemWindow);
</code></pre>
<p>下面我们看一下在WindowState的实例化过程中，都做了什么。<br>1.根据客户端传过来的参数，对相关属性进行赋值。<br>2.根据当前窗口的类型获取mBaseLayer,当将WindowState加入到WindowToken时，该值用来确定加入窗口在WindowToken数组中的位置。<br>3.实例化WindowStateAnimator，该类会跟踪当前WIndowState的动画以及surface操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,
            WindowState parentWindow, int appOp, WindowManager.LayoutParams a, int viewVisibility,
            int ownerId, int showUserId, boolean ownerCanAddInternalSystemWindow,
            PowerManagerWrapper powerManagerWrapper) &#123;
        /*1.根据客户端传递过来的参数，对相关属性进行赋值*/
        //调用WindowState的父类WindowContainer构造方法，将WMS赋值给其父类属性mWmService
        super(service);
        //获取事务
        mTmpTransaction = service.mTransactionFactory.get();
        //将Session赋值给mSession
        mSession = s;
        //将与客户端通信的Binder赋值给mClient
        mClient = c;
        mAppOp = appOp;
        //将当前activity的token赋值给mToken
        mToken = token;
        //通过token，获取当前窗口对的ActivityRecord
        mActivityRecord = mToken.asActivityRecord();
        //赋值id
        mOwnerUid = ownerId;
        mShowUserId = showUserId;
        //是否可以添加系统窗口的标志位
        mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;
        mWindowId = new WindowId(this);
        //布局参数赋值给mAttrs
        mAttrs.copyFrom(a);
        //将surfaceInsets赋值给mLastSurfaceInsets
        mLastSurfaceInsets.set(mAttrs.surfaceInsets);
        //将窗口可见性赋值给mViewVisibility 
        mViewVisibility = viewVisibility;
        //将窗口WindowManagerPolicy赋值给mPolicy 
        mPolicy = mWmService.mPolicy;
        mContext = mWmService.mContext;
        ......
        /*2.获取当前窗口的BaseLayer*/
        if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;
            ......
        &#125; else &#123;
            // The multiplier here is to reserve space for multiple
            // windows in the same type layer.
            //当前为应用窗口所以mPolicy.getWindowLayerLw(this)获取值为2，即应用层级
            //TYPE_LAYER_MULTIPLIER为同一类型的多窗口保留空间
            //TYPE_LAYER_OFFSET将同一组窗口移动到同一层中其他窗口的上方或者下方
            mBaseLayer = mPolicy.getWindowLayerLw(this)
                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
            mSubLayer = 0;
            mIsChildWindow = false;
            mLayoutAttached = false;
            mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD
                    || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;
            mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;
        &#125;
        ......
        /*3.新建windowStateAnimator，该类会跟踪当前WindowState的动画以及surface操作*/
        mWinAnimator = new WindowStateAnimator(this);
        //将透明度alpha赋值给mAlpha 
        mWinAnimator.mAlpha = a.alpha;
        ......
    &#125;
</code></pre>
<h5 id="2-1-5-将WindowState加入到WindowToken"><a href="#2-1-5-将WindowState加入到WindowToken" class="headerlink" title="2.1.5 将WindowState加入到WindowToken"></a>2.1.5 将WindowState加入到WindowToken</h5><p>在addWindow中将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WindowState加入到WindowToken中的具体过程：<br>1.将要加入的WindowState.mBaseLayer与WindowToken中现有的WindowState.mBaseLayer相比，按照mBaseLayer有小到大存放到数组中，若mBaseLayer相等，则后加入的WindowState放在数组后面。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p>
<pre><code> void addWindow(final WindowState win) &#123;
        ProtoLog.d(WM_DEBUG_FOCUS,
                &quot;addWindow: win=%s Callers=%s&quot;, win, Debug.getCallers(5));

        if (win.isChildWindow()) &#123;
            // Child windows are added to their parent windows.
            //如果是子窗口直接返回
            return;
        &#125;
        // This token is created from WindowContext and the client requests to addView now, create a
        // surface for this token.
        if (mSurfaceControl == null) &#123;
            createSurfaceControl(true /* force */);

            // Layers could have been assigned before the surface was created, update them again
            reassignLayer(getSyncTransaction());
        &#125;
        if (!mChildren.contains(win)) &#123;
            ProtoLog.v(WM_DEBUG_ADD_REMOVE, &quot;Adding %s to %s&quot;, win, this);
            //调用WindowContainer.addChild方法
            addChild(win, mWindowComparator);
            mWmService.mWindowsChanged = true;
            // TODO: Should we also be setting layout needed here and other places?
        &#125;
    &#125;
 /**
   * Compares two child window of this token and returns -1 if the first is lesser than the
   * second in terms of z-order and 1 otherwise.
   */
  private final Comparator&lt;WindowState&gt; mWindowComparator =
          (WindowState newWindow, WindowState existingWindow) -&gt; &#123;
      final WindowToken token = WindowToken.this;
      ......
      //如果新窗口的mBaseLayer 不小于（大于等于）已经存在的WindowState的BaseLayer，则返回1，否则返回-1
      return isFirstChildWindowGreaterThanSecond(newWindow, existingWindow) ? 1 : -1;
  &#125;;
    /**
     * Returns true if the new window is considered greater than the existing window in terms of
     * z-order.
     */
    protected boolean isFirstChildWindowGreaterThanSecond(WindowState newWindow,
            WindowState existingWindow) &#123;
        // New window is considered greater if it has a higher or equal base layer.
        //此处可以发现比较的是两个窗口的mBaseLayer
        return newWindow.mBaseLayer &gt;= existingWindow.mBaseLayer;
    &#125;
</code></pre>
<p>我们看看WindowContainer.addChild方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>   /**
     * Adds the input window container has a child of this container in order based on the input
     * comparator.
     * @param child The window container to add as a child of this window container.
     * @param comparator Comparator to use in determining the position the child should be added to.
     *                   If null, the child will be added to the top.
     */
    @CallSuper
    protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123;
        ......
        //记录插入数组的位置，若为-1则将windowState加入到后面
        int positionToAdd = -1;
        if (comparator != null) &#123;
            //判断当前WindowToken中WindowState的数量
            //依次比较将要加入的窗口与已经存在的WindowState的BaseLayer
            //mChildren越大放到数组最前面WindowToken
            final int count = mChildren.size();
            for (int i = 0; i &lt; count; i++) &#123;
                //比较baseLayer，如果child大于列表中已经存在的，则需要返回1，否则返回-1
                //新加入的的child大于mChildren.get(i)则返回1，小于则返回-1
                //注：comparator比较器的逻辑见上面代码的mWindowComparator 
                if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123;
                    //记录当前要插入的位置
                    positionToAdd = i;
                    break;
                &#125;
            &#125;
        &#125;
        //如果新加入的窗口大于现在所有窗口
        if (positionToAdd == -1) &#123;
            //将该窗口加入到列表最后
            mChildren.add(child);
        &#125; else &#123;
            mChildren.add(positionToAdd, child);
        &#125;

        // Set the parent after we&#39;ve actually added a child in case a subclass depends on this.
        //此处将child的mParent设置为this
        child.setParent(this);
    &#125;
</code></pre>
<p>2.将WindowState的mParent置为刚才的WindowToken，并更新其Parent的mTreeWeight。mTreeWeight记录了其子节点的数量。<br>继续查看WindowState的父类WindowContainer.setParent</p>
<pre><code>    final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123;
        //将当前WindowState的mParent设置为相应的WindowToken
        final WindowContainer oldParent = mParent;
        mParent = parent;

        if (mParent != null) &#123;
            //更新parent中的mTreeWeight属性
            //mTreeWeight代表以parent的根节点的子树中的元素的数量
            mParent.onChildAdded(this);
        &#125; else if (mSurfaceAnimator.hasLeash()) &#123;
            mSurfaceAnimator.cancelAnimation();
        &#125;
        if (!mReparenting) &#123;
            onSyncReparent(oldParent, mParent);
            if (mParent != null &amp;&amp; mParent.mDisplayContent != null
                    &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;
                onDisplayChanged(mParent.mDisplayContent);
            &#125;
            //计算显示layer
            onParentChanged(mParent, oldParent);
        &#125;
    &#125;
</code></pre>
<p>3.将WindowState加入到WindowToken之后，调用parent的assignChildLayers方法，调整其所有child的z-order。主要经历以下步骤：<br>初始化layer&#x3D;0，代表着z-order。<br>遍历mChildren数组，判断Children是否需要提高到顶部（判断标志位mNeedsZBoost）。如果不需要则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果需要则执行下一遍循环。<br>再次遍历mChildren数组，判断Children是否需要提高到顶部。如果需要则则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果不需要则执行下一次循环。<br>注：<strong>Z-order</strong>也被称为深度顺序（depth order）或Z轴顺序，它用于确定图层（Layers）在屏幕上的堆叠顺序。简单来说，<strong>Z-order</strong>就是图层在Z轴上的位置，Z轴位置越低，图层越在底层，Z轴位置越高，图层越在顶层。<br>继续看onParentChanged方法</p>
<pre><code>/**
     * Callback that is triggered when @link WindowContainer#setParent(WindowContainer)&#125; was called.
     * Supposed to be overridden and contain actions that should be executed after parent was set.
     */
    @Override
    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123;
        onParentChanged(newParent, oldParent, null);
    &#125;

    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent,
            PreAssignChildLayersCallback callback) &#123;
        ......
        if (mSurfaceControl == null) &#123;
            // If we don&#39;t yet have a surface, but we now have a parent, we should
            // build a surface.
            //创建一个SurfaceControl来调整窗口的z-order
            createSurfaceControl(false /*force*/);
        &#125; else &#123;
               ......
        &#125;
        ......
        // Either way we need to ask the parent to assign us a Z-order.
        //进入WindowToken的父类WindowContainer中，调整窗口的z-order
        mParent.assignChildLayers();
        scheduleAnimation();
    &#125;
    
    void assignChildLayers() &#123;
        assignChildLayers(getSyncTransaction());
        scheduleAnimation();
    &#125;
    
    void assignChildLayers(Transaction t) &#123;
    //分配给当前窗口的z-order，初始化为0
        int layer = 0;

        // We use two passes as a way to promote children which
        // need Z-boosting to the end of the list.
        //此处会以parent为根节点向下遍历到子节点，再从下到上依次进行处理
        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;
            final WindowContainer wc = mChildren.get(j);
            wc.assignChildLayers(t);
            //needsZBoot是用来判断当前窗口是否应该提升到容器的顶部
            //若不需要提升到容器的顶部
            if (!wc.needsZBoost()) &#123;
                //调用WindowState的父类WindowContainer中的assignLayer
                wc.assignLayer(t, layer++);
            &#125;
        &#125;
        //处理需要提升到容器顶部的窗口
        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;
            final WindowContainer wc = mChildren.get(j);
            if (wc.needsZBoost()) &#123;
                wc.assignLayer(t, layer++);
            &#125;
        &#125;
        if (mOverlayHost != null) &#123;
            mOverlayHost.setLayer(t, layer++);
        &#125;
    &#125;
</code></pre>
<p>4.在Children的assignLayer中会首先判断此次要调整的layer与自己上次layer是否相等，不相等则最终会调用nativeSetLayer来调整自己的z-order。</p>
<pre><code>    void assignLayer(Transaction t, int layer) &#123;
        // Don&#39;t assign layers while a transition animation is playing
        // TODO(b/173528115): establish robust best-practices around z-order fighting.
        //如果正在执行Transaction，则不需要进行assignLayer
        if (mTransitionController.isPlaying()) return;
        //layer为此次要调整的z-order
        final boolean changed = layer != mLastLayer || mLastRelativeToLayer != null;
        //如果需要调整
        if (mSurfaceControl != null &amp;&amp; changed) &#123;
            //调用setLayer调整窗口的z-order
            setLayer(t, layer);
            //将mLastLayer调整为新的z-order
            mLastLayer = layer;
            mLastRelativeToLayer = null;
        &#125;
    &#125;
    
    protected void setLayer(Transaction t, int layer) &#123;
        if (mSurfaceFreezer.hasLeash()) &#123;
               ......
        &#125; else &#123;
            // Route through surface animator to accommodate that our surface control might be
            // attached to the leash, and leash is attached to parent container.
            //调用SurfaceAnimator中的setLayer
            mSurfaceAnimator.setLayer(t, layer);
        &#125;
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;SurfaceAnimator.java</p>
<pre><code>    /**
     * Sets the layer of the surface.
     * &lt;p&gt;
     * When the layer of the surface needs to be adjusted, we need to set it on the leash if the
     * surface is reparented to the leash. This method takes care of that.
     */
    void setLayer(Transaction t, int layer) &#123;
          //调用SurfaceControl中的setlayer方法
        t.setLayer(mLeash != null ? mLeash : mAnimatable.getSurfaceControl(), layer);
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>        /**
         * Set the Z-order for a given SurfaceControl, relative to it&#39;s siblings.
         * If two siblings share the same Z order the ordering is undefined. Surfaces
         * with a negative Z will be placed below the parent surface.
         *
         * @param sc The SurfaceControl to set the Z order on
         * @param z The Z-order
         * @return This Transaction.
         */
        @NonNull
        public Transaction setLayer(@NonNull SurfaceControl sc,
                @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z) &#123;
            //调用调整layer
            checkPreconditions(sc);
            nativeSetLayer(mNativeObject, sc.mNativeObject, z);
            return this;
        &#125;
</code></pre>
<h4 id="2-2-窗口位置和大小计算"><a href="#2-2-窗口位置和大小计算" class="headerlink" title="2.2 窗口位置和大小计算"></a>2.2 窗口位置和大小计算</h4><p>当WindowState加入到WindowToken并调整z-order之后，客户端会再次调用<strong>WindowManagerService.relayoutWindow</strong>执行窗口布局。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.创建SurfaceControl<br>3.窗口位置和大小计算</p>
<h5 id="2-2-1-接收客户端请求"><a href="#2-2-1-接收客户端请求" class="headerlink" title="2.2.1 接收客户端请求"></a>2.2.1 接收客户端请求</h5><p>与addWindow流程的调用过程类似，WindowManagerService.relayoutWindow也是由客户端通过Session来调用的。<br>首先我们来看一下客户端给我们传递了哪些参数吧。<br>window：是WMS与客户端通信的Binder。<br>attrs：窗口的布局属性，根据attrs提供的属性来布局窗口。<br>requestWidth、requestHeight：客户端请求的窗口尺寸。<br>viewFlags：窗口的可见性。包括VISIBLE（0，view可见），INVISIBLE（4，view不可见，但是仍然占用布局空间）GONE（8，view不可见，不占用布局空间）<br>flags：定义一些布局行为。<br>outFrames：返回给客户端的，保存了重新布局之后的位置与大小。<br>mergedConfiguration:相关配置信息。<br>outSurfaceControl:返回给客户端的surfaceControl。<br>outInsetsState：用来保存系统中所有Insets的状态。<br>outActiveControls：InSetsSourceControl数组。<br>outSyncSeqIdBundle：与布局同步有关。<br>Session调用WMS.relayoutWindow将客户端传入的参数传递给WMS。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public int relayout(IWindow window, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags, int flags,
            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Bundle outSyncSeqIdBundle) &#123;
        if (false) Slog.d(TAG_WM, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot;
                + Binder.getCallingPid());
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, mRelayoutTag);
        int res = mService.relayoutWindow(this, window, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrames, mergedConfiguration, outSurfaceControl, outInsetsState,
                outActiveControls, outSyncSeqIdBundle);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        if (false) Slog.d(TAG_WM, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot;
                + Binder.getCallingPid());
        return res;
    &#125;
</code></pre>
<h5 id="2-2-2-relayoutWindow"><a href="#2-2-2-relayoutWindow" class="headerlink" title="2.2.2 relayoutWindow"></a>2.2.2 relayoutWindow</h5><p>在WMS.relayoutWindow中主要做了以下事情：<br>1.根据客户端传过来的IWindow在mWindowMap获取窗口添加阶段创建的WindowState。<br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br>3.Surface的创建流程。<br>4.窗口尺寸的计算以及Surface的状态变更。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    public int relayoutWindow(Session session, IWindow client, LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility, int flags,
            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle) &#123;
        ......
        synchronized (mGlobalLock) &#123;
            /*1.根据客户端传过来的Iwindow从mWindowMap中获取对应的WindowState*/
            final WindowState win = windowForClientLocked(session, client, false);
            if (win == null) &#123;
                return 0;
            &#125;
            //获取DisplayContent、DisplayPolicy以及WindowStateAnimator 
            final DisplayContent displayContent = win.getDisplayContent();
            final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();

            WindowStateAnimator winAnimator = win.mWinAnimator;
            if (viewVisibility != View.GONE) &#123;
                //根据客户端请求的窗口大小设置WindowState的requestedWidth, requestedHeight
                //并设置WindowState.mLayoutNeeded为true
                win.setRequestedSize(requestedWidth, requestedHeight);
            &#125;
            ......
            //根据请求的宽带和高度窗口缩放比例
            win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);
            ......
            //获取原来window的可见性，此时为INVISIBLE
            final int oldVisibility = win.mViewVisibility;
            ......
            //代表现在没有surface但应该很快就有标志位
            win.mRelayoutCalled = true;
            win.mInRelayout = true;
            //将当前窗口的可见性有原来的INVISIBLE调整为VISIBLE
            win.setViewVisibility(viewVisibility);
            ProtoLog.i(WM_DEBUG_SCREEN_ON,
                    &quot;Relayout %s: oldVis=%d newVis=%d. %s&quot;, win, oldVisibility,
                            viewVisibility, new RuntimeException().fillInStackTrace());
            /*2.1.将displayContent中的布局标志为mLayoutNeeded置为true*/
            win.setDisplayLayoutNeeded();
            win.mGivenInsetsPending = (flags &amp; WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;

            // We should only relayout if the view is visible, it is a starting window, or the
            // associated appToken is not hidden.
            /*2.2.判断是否允许relayout，此时为true*/
            //判断条件：view可见且（activityRecord不为空，或者布局类型为TYPE_APPLICATION_STARTING，或者窗口已经告诉客户端可以显示）
            final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING
                            || win.mActivityRecord.isClientVisible());
            ......
            // Create surfaceControl before surface placement otherwise layout will be skipped
            // (because WS.isGoneForLayout() is true when there is no surface.
            /*3.surface的创建流程*/
            if (shouldRelayout) &#123;
                try &#123;
                    //进入creatSurfaceControl开始创建SurfaceControl
                    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);
                &#125; catch (Exception e) &#123;
                    ......
                    return 0;
                &#125;
            &#125;

            // We may be deferring layout passes at the moment, but since the client is interested
            // in the new out values right now we need to force a layout.
            /*4.窗口尺寸的计算以及Surface的状态变更*/
            //WindowSurfacePlacer在WMS初始化的时候创建
            mWindowPlacerLocked.performSurfacePlacement(true /* force */);
            ......
            //填充计算好的frame返回给客户端，更新mergedConfiguration对象
            win.fillClientWindowFramesAndConfiguration(outFrames, mergedConfiguration,
                    false /* useLatestConfig */, shouldRelayout);

            // Set resize-handled here because the values are sent back to the client.
            win.onResizeHandled();
            ......
        &#125;

        Binder.restoreCallingIdentity(origId);
        //返回result
        return result;
    &#125;
</code></pre>
<h5 id="2-2-3-创建SurfaceControl"><a href="#2-2-3-创建SurfaceControl" class="headerlink" title="2.2.3 创建SurfaceControl"></a>2.2.3 创建SurfaceControl</h5><p>在relayoutWindow中创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code><br>关于SurfaceControl的创建在WMS中主要做两件事：<br>1.调用WindwoStateAnimator执行具体的SurfaceControl的创建。<br>2.将创建的SurfaceControl赋值给客户端的outSurfaceControl。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    private int createSurfaceControl(SurfaceControl outSurfaceControl, int result,
            WindowState win, WindowStateAnimator winAnimator) &#123;
        ......
        WindowSurfaceController surfaceController;
        try &#123;
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;createSurfaceControl&quot;);
            /*
             * WindowStateAnimator用来帮助WindowState管理animator和surface基本操作的
             * 1.WMS将创建的surfaceContorl的操作交给windowAnimator来处理
             */
            surfaceController = winAnimator.createSurfaceLocked();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
        if (surfaceController != null) &#123;
            /*2.将WMS的SurfaceControl赋值给客户端的outSurfaceControl*/
            surfaceController.getSurfaceControl(outSurfaceControl);
            ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot;OUT SURFACE %s: copied&quot;, outSurfaceControl);

        &#125; else &#123;
            // For some reason there isn&#39;t a surface.  Clear the
            // caller&#39;s object so they see the same state.
            ProtoLog.w(WM_ERROR, &quot;Failed to create surface control for %s&quot;, win);
            outSurfaceControl.release();
        &#125;

        return result;
    &#125;
</code></pre>
<p>在WindowStateAnimator中创建SurfaceControl主要经过以下三个步骤：<br>1.重置Surface标志位，变更mDrawState状态为DRAW_PENDING。<br>2.通过实例化WindowSurfaceController来创建SurfaceControl。<br>3.处理Surface标志位，将其置为true，标志着当前WindowState已经有surface了<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>   WindowSurfaceController createSurfaceLocked() &#123;
        final WindowState w = mWin;
        
        //首先判断是否存在mSurfaceController
        if (mSurfaceController != null) &#123;
            return mSurfaceController;
        &#125;
        /*1.1.设置WindowState的mHasSurface设置为false*/
        w.setHasSurface(false);

        ProtoLog.i(WM_DEBUG_ANIM, &quot;createSurface %s: mDrawState=DRAW_PENDING&quot;, this);
        /*1.2.将WindowStateAnimator中的DrawState设置为DRAW_PENDING*/
        resetDrawState();

        mService.makeWindowFreezingScreenIfNeededLocked(w);

        /*1.3.将surface创建flag设置为hidden*/
        int flags = SurfaceControl.HIDDEN;
        //获取windowState的布局参数
        final WindowManager.LayoutParams attrs = w.mAttrs;

        // Set up surface control with initial size.
        try &#123;
            	......
            	/*2.创建WindowSurfaceController*/
            	//attrs.getTitle().toString()为当前activity的全路径名
            	//format为位图格式
            	//flags为surface创建的标志位（如：HIDDED(0x04,surface创建为隐藏)，SKIP_SCREENSHOT(0x040，截屏时跳过此图层将不会包含在非主显示器上),SECURE(0X080,禁止复制表面的内容，屏幕截图和次要的非安全显示将呈现黑色内容而不是surface内容)等）
            	//attrs.type为窗口类型
            mSurfaceController = new WindowSurfaceController(attrs.getTitle().toString(), format,
                    flags, this, attrs.type);
            mSurfaceController.setColorSpaceAgnostic((attrs.privateFlags
                    &amp; WindowManager.LayoutParams.PRIVATE_FLAG_COLOR_SPACE_AGNOSTIC) != 0);

            /*3.将WindowState的hasSurface标志设置为true，标志着道歉WindowState已经有surface了*/
            w.setHasSurface(true);
            ......
        &#125; catch (OutOfResourcesException e) &#123;
            ......
        &#125; catch (Exception e) &#123;
            ......
        &#125;
        ......
        return mSurfaceController;
    &#125;
</code></pre>
<p>SurfaceControl的创建过程为典型的建造者模式<br>接下来看看WindowSurfaceController的构造方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p>
<pre><code>WindowSurfaceController(String name, int format, int flags, WindowStateAnimator animator,
            int windowType) &#123;
        //设置WindowStateAnimator
        mAnimator = animator;
        //窗口名
        title = name;
        //WMS对象
        mService = animator.mService;
        //WindowState对象
        final WindowState win = animator.mWin;
        //窗口类型
        mWindowType = windowType;
        //IWindowSession对象
        mWindowSession = win.mSession;

        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;new SurfaceControl&quot;);
        //makeSurface最终会调用到DisplayContent的makeChildSurface方法，返回SurfaceControl.Builder
        final SurfaceControl.Builder b = win.makeSurface()
                .setParent(win.getSurfaceControl())
                .setName(name)
                .setFormat(format)
                .setFlags(flags)
                .setMetadata(METADATA_WINDOW_TYPE, windowType)
                .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid)
                .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid)
                .setCallsite(&quot;WindowSurfaceController&quot;);
        ......
        //获取SurfaceControl实例对象
        mSurfaceControl = b.build();

        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    &#125;
</code></pre>
<p>两个关键方法win.makeSurface()和b.build()<br>1.<code>final SurfaceControl.Builder b = win.makeSurface()</code><br>我们先来看看win.makeSurface()，windowState中没有makeSurface()方法，因此调用其父类WindowContainer的makeSurface()方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>    SurfaceControl.Builder makeSurface() &#123;
        final WindowContainer p = getParent();
        return p.makeChildSurface(this);
    &#125;
        /**
     * @param child The WindowContainer this child surface is for, or null if the Surface
     *              is not assosciated with a WindowContainer (e.g. a surface used for Dimming).
     */
    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;
        final WindowContainer p = getParent();
        // Give the parent a chance to set properties. In hierarchy v1 we rely
        // on this to set full-screen dimensions on all our Surface-less Layers.
        return p.makeChildSurface(child)
                .setParent(mSurfaceControl);
    &#125;
</code></pre>
<p>最终会调用到DisplayContent的makeChildSurface<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    @Override
    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;
        //此时child为WindowState
        //获取SurfaceSession，SurfaceSession的创建在Session.windowAddedLocked中，其最开始调用在WindowManagerService.addWindow中win.attach()中创建
        SurfaceSession s = child != null ? child.getSession() : getSession();
        //返回SurfaceControl.Builder
        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(s).setContainerLayer();
        if (child == null) &#123;
            return b;
        &#125;
        //设置SurfaceControl.Builder的name以及parent
        return b.setName(child.getName())
                .setParent(mSurfaceControl);
    &#125;
</code></pre>
<p>2.<code>mSurfaceControl = b.build();</code><br>再来看看b.build()，调用SurfaceControl中的build<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>    /**
      * Construct a new &#123;@link SurfaceControl&#125; with the set parameters. The builder
      * remains valid.
      */
     @NonNull
     public SurfaceControl build() &#123;
     	//检查width以及height，初始都应该为0
         if (mWidth &lt; 0 || mHeight &lt; 0) &#123;
             throw new IllegalStateException(
                     &quot;width and height must be positive or unset&quot;);
         &#125;
         if ((mWidth &gt; 0 || mHeight &gt; 0) &amp;&amp; (isEffectLayer() || isContainerLayer())) &#123;
             throw new IllegalStateException(
                     &quot;Only buffer layers can set a valid buffer size.&quot;);
         &#125;
    
         if ((mFlags &amp; FX_SURFACE_MASK) == FX_SURFACE_NORMAL) &#123;
             setBLASTLayer();
         &#125;
    //创建SurfaceControl的实例
         return new SurfaceControl(
                 mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,
                 mLocalOwnerView, mCallsite);
     &#125;
    
   /**
    * @param session  The surface session, must not be null.
    * @param name     The surface name, must not be null.
    * @param w        The surface initial width.
    * @param h        The surface initial height.
    * @param flags    The surface creation flags.
    * @param metadata Initial metadata.
    * @param callsite String uniquely identifying callsite that created this object. Used for
    *                 leakage tracking.
    * @throws throws OutOfResourcesException If the SurfaceControl cannot be created.
    */
    private SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags,
         SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView,
         String callsite)
                 throws OutOfResourcesException, IllegalArgumentException &#123;
     if (name == null) &#123;
         throw new IllegalArgumentException(&quot;name must not be null&quot;);
     &#125;
    
     mName = name;
     mWidth = w;
     mHeight = h;
     mLocalOwnerView = localOwnerView;
     //创建Parcel用来传递数据
     Parcel metaParcel = Parcel.obtain();
     try &#123;
       	......
       	//调用native层
         mNativeObject = nativeCreate(session, name, w, h, format, flags,
                 parent != null ? parent.mNativeObject : 0, metaParcel);
     &#125; finally &#123;
         metaParcel.recycle();
     &#125;
     if (mNativeObject == 0) &#123;
         throw new OutOfResourcesException(
                 &quot;Couldn&#39;t allocate SurfaceControl native object&quot;);
     &#125;
     mNativeHandle = nativeGetHandle(mNativeObject);
     mCloseGuard.openWithCallSite(&quot;release&quot;, callsite);
    &#125;
</code></pre>
<p>​    </p>
<p>SurfaceControl的构造方法调用完成后，返回查看前面<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code></p>
<h5 id="2-2-4-计算窗口大小位置"><a href="#2-2-4-计算窗口大小位置" class="headerlink" title="2.2.4 计算窗口大小位置"></a>2.2.4 计算窗口大小位置</h5><p>在relayoutWindow中计算窗口大小位置<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code><br>该流程我们分为三部分介绍：<br>1.该部分处理有关窗口布局循环的逻辑。<br>2.该部分处理Surface的状态变更，以及调用layoutWindowLw的流程。<br>3.计算窗口位置大小。</p>
<h6 id="1-处理窗口布局循环"><a href="#1-处理窗口布局循环" class="headerlink" title="1.处理窗口布局循环"></a>1.处理窗口布局循环</h6><p>performSurfacePlacement是一个确定所有窗口的Surface的如何摆放，如何显示、显示在什么位置、显示区域多大的一个入口方法。<br>该方法主要设置了布局的循环条件，当mTraversalScheduled 标志位为true，且loopCount大于0。将会调用performSurfacePlacementLoop执行布局操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p>
<pre><code>    final void performSurfacePlacement(boolean force) &#123;
        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;
            mDeferredRequests++;
            return;
        &#125;
        //将循环的最大次数设置为6次
        int loopCount = 6;
        do &#123;
            //将该标志为设置为false
            mTraversalScheduled = false;
            //执行窗口布局操作
            performSurfacePlacementLoop();
            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);
            loopCount--;
        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局
        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);
        mService.mRoot.mWallpaperActionPending = false;
    &#125;
</code></pre>
<p>performSurfacePlacementLoop方法主要做两件事：<br>1.调用RootWindowContainer对所有窗口执行布局操作，<br>2.处理是否再次进行布局的逻辑。如果DisplayContent.mLayoutNeeded标志位为true且布局循环次数小于6次，则会将mTraversalScheduled标志位置为true，在performSurfacePlacement中会再次调用performSurfacePlacementLoop。</p>
<pre><code>    private void performSurfacePlacementLoop() &#123;
        //若当前已经进行布局操作，则无需重复调用直接返回
        if (mInLayout) &#123;
            ......
            return;
        &#125;
        ......
        //将该标志位置为true，表示正在处于布局过程中
        mInLayout = true;
        ......
        try &#123;
            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/
            mService.mRoot.performSurfacePlacement();

            mInLayout = false;

            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;

            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;
                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);
                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);
            &#125;
        &#125; catch (RuntimeException e) &#123;
            mInLayout = false;
            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);
        &#125;
    &#125;
</code></pre>
<h6 id="2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程"><a href="#2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程" class="headerlink" title="2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程"></a>2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程</h6><p><code>mService.mRoot.performSurfacePlacement();</code><br>上面说到在RootWindowContainer.performSurfacePlacement()中调用了performSurfaceNoTrace()方法，该方法为实际的处理布局的方法，主要处理以下流程：<br>1.如果有焦点变化，更新焦点。<br>2.执行窗口尺寸计算，surface状态变更等操作。<br>3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在finishdrawing()中再详细分析。<br>4.如果壁纸有变化，更新壁纸。<br>5.再次处理焦点变化。<br>6.如果过程中由size或者位置变化，则通知客户端重新relayout。<br>7.销毁不可见的窗口<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    void performSurfacePlacement() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);
        try &#123;
            //调用performSurfacePlacementNoTrace()
            performSurfacePlacementNoTrace();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;
    // TODO: Super long method that should be broken down...
    void performSurfacePlacementNoTrace() &#123;
        ......
        /*1.如果有焦点变化，更新焦点*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(
                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);
        &#125;
        ......
        
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);
        //开启事务，获取GlobalTransactionWrapper对象
        mWmService.openSurfaceTransaction();
        try &#123;
            /*2.执行窗口尺寸计算，surface状态变更等操作*/
            applySurfaceChangesTransaction();
        &#125; catch (RuntimeException e) &#123;
            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);
        &#125; finally &#123;
            //关闭事务
            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            if (SHOW_LIGHT_TRANSACTIONS) &#123;
                Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);
            &#125;
        &#125;
        ......
        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/
        checkAppTransitionReady(surfacePlacer);
        ......
        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/
        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;
            final DisplayContent displayContent = mChildren.get(displayNdx);
            //判断DisplayContent的壁纸是否需要改变
            if (displayContent.mWallpaperMayChange) &#123;
                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,
                            displayContent.pendingLayoutChanges);
                &#125;
            &#125;
        &#125;
        /*5.在此处理焦点变化*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
                    false /*updateInputWindows*/);
        &#125;
        ......
        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/
        handleResizingWindows();

        if (mWmService.mDisplayFrozen) &#123;
            ProtoLog.v(WM_DEBUG_ORIENTATION,
                    &quot;With display frozen, orientationChangeComplete=%b&quot;,
                    mOrientationChangeComplete);
        &#125;
        if (mOrientationChangeComplete) &#123;
            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;
                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;
                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
            &#125;
            mWmService.stopFreezingDisplayLocked();
        &#125;

        // Destroy the surface of any windows that are no longer visible.
        /*7.销毁不可见的窗口*/
        i = mWmService.mDestroySurface.size();
        if (i &gt; 0) &#123;
            do &#123;
                i--;
                WindowState win = mWmService.mDestroySurface.get(i);
                win.mDestroying = false;
                final DisplayContent displayContent = win.getDisplayContent();
                if (displayContent.mInputMethodWindow == win) &#123;
                    displayContent.setInputMethodWindowLocked(null);
                &#125;
                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;
                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                &#125;
                win.destroySurfaceUnchecked();
            &#125; while (i &gt; 0);
            mWmService.mDestroySurface.clear();
        &#125;
        ......
    &#125;
</code></pre>
<p>​    </p>
<p>在<code>applySurfaceChangesTransaction();</code>方法中其主要执行：<br>1.水印、StrictMode警告框以及模拟器显示的布局。<br>2.遍历所有DisplayContent执行其applySurfaceChangesTransaction<br>我们一起看看这个方法</p>
<pre><code>    private void applySurfaceChangesTransaction() &#123;
        mHoldScreenWindow = null;
        mObscuringWindow = null;

        // TODO(multi-display): Support these features on secondary screens.
        /*1.水印、StrictMode警告框以及模拟器显示的布局*/
        //获取手机默认DisplayContent的信息
        final DisplayContent defaultDc = mWmService.getDefaultDisplayContentLocked();
        final DisplayInfo defaultInfo = defaultDc.getDisplayInfo();
        final int defaultDw = defaultInfo.logicalWidth;
        final int defaultDh = defaultInfo.logicalHeight;
        //布局水印
        if (mWmService.mWatermark != null) &#123;
            mWmService.mWatermark.positionSurface(defaultDw, defaultDh, mDisplayTransaction);
        &#125;
        //布局StrictMode警告框
        if (mWmService.mStrictModeFlash != null) &#123;
            mWmService.mStrictModeFlash.positionSurface(defaultDw, defaultDh, mDisplayTransaction);
        &#125;
        //布局模拟器显示覆盖
        if (mWmService.mEmulatorDisplayOverlay != null) &#123;
            mWmService.mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh,
                    mWmService.getDefaultDisplayRotation(), mDisplayTransaction);
        &#125;
        /*2.遍历RootWindowContainer下所有DisplayContent执行其applySurfaceChangesTransaction()*/
        final int count = mChildren.size();
        for (int j = 0; j &lt; count; ++j) &#123;
            final DisplayContent dc = mChildren.get(j);
            dc.applySurfaceChangesTransaction();
        &#125;

        // Give the display manager a chance to adjust properties like display rotation if it needs
        // to.
        mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction);
        SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);
    &#125;
</code></pre>
<p>接下来继续跟踪<code>dc.applySurfaceChangesTransaction();</code><br>该方法主要<br>1.遍历所有窗口，计算窗口的布局大小，具体流程查看performLayoutNoTrace。（主要跟踪点）<br>2.surface的状态更改。（见“<strong>2.3.3mDrawState变更为HAS_DRAW”流程</strong>”）<br>3.处理surface的位置、大小以及显示等。（见“<strong>2.3.4 show Surface”流程</strong>”）<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    void applySurfaceChangesTransaction() &#123;
        //获取WindowSurfacePlacer 
        final WindowSurfacePlacer surfacePlacer = mWmService.mWindowPlacerLocked;
        ......
        // Perform a layout, if needed.
        /*1.执行布局，该方法最终会调用performLayoutNoTrace，计算窗口的布局参数*/
        performLayout(true /* initial */, false /* updateInputWindows */);
        ......
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applyWindowSurfaceChanges&quot;);
        try &#123;
            /*2.遍历所有窗口，主要是改变surface的状态。见“2.3.3mDrawState变更为HAS_DRAW”流程*/
            forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
        /*3.处理各个surface的位置、大小以及是否要在屏幕上显示等。后面finishDrawing()流程中再跟踪*/
        prepareSurfaces();
        ......
    &#125;
</code></pre>
<p>继续跟踪<code>performLayout(true /* initial */, false /* updateInputWindows */);</code><br>该方法主要就是调用performLayoutNoTrace()方法，首先判断布局标志位mLayoutNeeded，该标志位在WMS.relayoutWindow中被置为true。<br>false则直接返回不会进行布局操作。<br>true则分别遍历父窗口和子窗口进行布局，我们暂且只分析父窗口的布局操作，查看mPerformLayout。</p>
<pre><code>    void performLayout(boolean initial, boolean updateInputWindows) &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performLayout&quot;);
        try &#123;
            //调用performLayoutNoTrace
            performLayoutNoTrace(initial, updateInputWindows);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    private void performLayoutNoTrace(boolean initial, boolean updateInputWindows) &#123;
            /*1.判断是否需要布局，不需要则直接返回，即判断布局标志位mLayoutNeeded是否为true*/
        if (!isLayoutNeeded()) &#123;
            return;
        &#125;
        //将DisplayContent.mLayoutNeeded属性置为false
        clearLayoutNeeded();
        ......
        // First perform layout of any root windows (not attached to another window).
        /*2.对所有顶级窗口进行布局*/
        //最终会回调mPerformLayout
        forAllWindows(mPerformLayout, true /* traverseTopToBottom */);

        // Now perform layout of attached windows, which usually depend on the position of the
        // window they are attached to. XXX does not deal with windows that are attached to windows
        // that are themselves attached.
        /*3.处理子窗口的布局*/
        //最终会回调mPerformLayoutAttached
        forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);
        ......
    &#125;
</code></pre>
<p><code>forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);</code><br>当遍历到DisplayContent下的每个窗口时都会执行mPerformLayout，该方法会将WindowState.mLayoutNeeded标志位置false，并将具体的布局操作交给DisplayPolicy进行处理，见“<strong>3. 计算窗口位置大小</strong>“。</p>
<pre><code>    private final Consumer&lt;WindowState&gt; mPerformLayout = w -&gt; &#123;
        //如果当前窗口为子窗口则直接返回
        if (w.mLayoutAttached) &#123;
            return;
        &#125;

        // Don&#39;t do layout of a window if it is not visible, or soon won&#39;t be visible, to avoid
        // wasting time and funky changes while a window is animating away.
        //先判断当前窗口是否会不可见
        final boolean gone = w.isGoneForLayout();
        ......

        // If this view is GONE, then skip it -- keep the current frame, and let the caller know
        // so they can ignore it if they want.  (We do the normal layout for INVISIBLE windows,
        // since that means &quot;perform layout as normal, just don&#39;t display&quot;).
        if (!gone || !w.mHaveFrame || w.mLayoutNeeded) &#123;
            if (mTmpInitial) &#123;
                //设置窗口布局WindowFrames.mContentChanged为false
                w.resetContentChanged();
            &#125;
            //将mSurfacePlacementNeeded标志为置为true
            w.mSurfacePlacementNeeded = true;
            //将WindowState.mLayoutNeeded标志位置为false
            w.mLayoutNeeded = false;
            //判断当前窗口是否是第一次布局
            final boolean firstLayout = !w.isLaidOut();
            //调用DisplayPolicy.layoutWindowLw进行布局，根据DisplayFrames对象对WindowState.mWindowFrames中的各个Rect对象属性进行确定
            getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);
            w.mLayoutSeq = mLayoutSeq;

            // If this is the first layout, we need to initialize the last frames and inset values,
            // as otherwise we&#39;d immediately cause an unnecessary resize.
            if (firstLayout) &#123;
                // The client may compute its actual requested size according to the first layout,
                // so we still request the window to resize if the current frame is empty.
                if (!w.getFrame().isEmpty()) &#123;
                    w.updateLastFrames();
                &#125;
                w.onResizeHandled();
            &#125;

            if (DEBUG_LAYOUT) Slog.v(TAG, &quot;  LAYOUT: mFrame=&quot; + w.getFrame()
                    + &quot; mParentFrame=&quot; + w.getParentFrame()
                    + &quot; mDisplayFrame=&quot; + w.getDisplayFrame());
        &#125;
    &#125;;
</code></pre>
<p>当mLayoutNeeded标志被设置时，表示布局需要更新；mSurfacePlacementNeeded标志被设置时，表示需要更新surface位置的条件之一（WindowState.updateSurfacePosition方法中有判断）。</p>
<h6 id="3-计算窗口位置大小"><a href="#3-计算窗口位置大小" class="headerlink" title="3.计算窗口位置大小"></a>3.计算窗口位置大小</h6><p><code>getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);</code><br>layoutWindowLw主要做了以下三件事<br>1.首先会获DisplayFrames：DisplayContent新建时创建，内部数据由屏幕提供。<br>2.其次调用WindowLayout.computeFrames计算窗口布局大小。<br>3.最后调用WindowState.setFrames将计算的布局参数赋值给当前窗口的windowFrames。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayPolicy.java</p>
<pre><code>    /**
     * Called for each window attached to the window manager as layout is proceeding. The
     * implementation of this function must take care of setting the window&#39;s frame, either here or
     * in finishLayout().
     *
     * @param win The window being positioned.
     * @param attached For sub-windows, the window it is attached to; this
     *                 window will already have had layoutWindow() called on it
     *                 so you can use its Rect.  Otherwise null.
     * @param displayFrames The display frames.
     */
    public void layoutWindowLw(WindowState win, WindowState attached, DisplayFrames displayFrames) &#123;
        //判断是否需要跳过布局
        if (win.skipLayout()) &#123;
            return;
        &#125;

        // This window might be in the simulated environment.
        // We invoke this to get the proper DisplayFrames.
        /*1.获取DisplayFrames*/
        displayFrames = win.getDisplayFrames(displayFrames);
        //获取某个方向的窗口布局参数
        final WindowManager.LayoutParams attrs = win.getLayoutingAttrs(displayFrames.mRotation);
        //null
        final Rect attachedWindowFrame = attached != null ? attached.getFrame() : null;

        // If this window has different LayoutParams for rotations, we cannot trust its requested
        // size. Because it might have not sent its requested size for the new rotation.
        final boolean trustedSize = attrs == win.mAttrs;
        final int requestedWidth = trustedSize ? win.mRequestedWidth : UNSPECIFIED_LENGTH;
        final int requestedHeight = trustedSize ? win.mRequestedHeight : UNSPECIFIED_LENGTH;
        /*2.调用WindowLayout.computeFrames计算窗口布局大小*/
        mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,
                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,
                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,
                sTmpClientFrames);
        /*3.将计算的布局参数赋值给windowFrames*/
        win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);
    &#125;
</code></pre>
<p>先来看看computeFrames，计算窗口布局大小</p>
<pre><code>mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,
                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,
                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,
                sTmpClientFrames);
</code></pre>
<p>调用的是WindowLayout的computeFrames方法</p>
<pre><code>public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,
            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,
            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,
            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames)
</code></pre>
<p>入参说明：<br><code>attrs</code>：这些是窗口的布局参数。它们定义了窗口的位置、大小、堆叠顺序等属性。<br><code>state</code>：这个参数代表了窗口的边距状态。边距是窗口与设备边缘之间的空间，可能会被其他元素（如状态栏或导航栏）占据。<br><code>displayCutoutSafe</code>：这是一个矩形，表示在计算窗口大小时可以安全忽略的显示切边区域。这通常是为了防止应用程序内容与设备上的物理切边重叠。<br><code>windowBounds</code>：这是窗口的边界矩形，通常表示窗口在屏幕上的位置和大小。<br><code>windowingMode</code>：这个参数定义了窗口的窗口模式。例如，它可以是全屏、浮动等模式。<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br><code>requestedVisibilities</code>：请求的可见性。这定义了应用程序请求的边距可见性，例如状态栏或导航栏是否可见。<br><code>attachedWindowFrame</code>：附加窗口的边界。如果这个窗口是附加到另一个窗口的，这个参数表示它相对于其父窗口的位置和大小。<br><code>compatScale</code>：兼容性比例，一个缩放因子，用于调整窗口内容的显示大小以适应不同的屏幕尺寸或分辨率。<br><code>outFrames</code>：用于返回计算后的窗口信息。它包含了窗口的实际边界、边距等信息。<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowLayout.java</p>
<pre><code>    public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,
            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,
            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,
            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames) &#123;
        //传入的参数attrs中提取出窗口的类型（type）、标志（fl）、私有标志（pfl）和布局是否在屏幕内（layoutInScreen）
        final int type = attrs.type;
        final int fl = attrs.flags;
        final int pfl = attrs.privateFlags;
        final boolean layoutInScreen = (fl &amp; FLAG_LAYOUT_IN_SCREEN) == FLAG_LAYOUT_IN_SCREEN;
        //定义了用于存储结果的矩形变量，包含：显示边界（outDisplayFrame）、父边界（outParentFrame）和实际边界（outFrame）
        final Rect outDisplayFrame = outFrames.displayFrame;
        final Rect outParentFrame = outFrames.parentFrame;
        final Rect outFrame = outFrames.frame;

        // Compute bounds restricted by insets
        //计算窗口被Insets限制的边界。Insets是屏幕边缘的空间，用于放置状态栏、导航栏等。
        //这一步通过调用state.calculateInsets()方法完成，该方法需要窗口边界和窗口布局参数作为输入。
        final Insets insets = state.calculateInsets(windowBounds, attrs.getFitInsetsTypes(),
                attrs.isFitInsetsIgnoringVisibility());
        //代码根据Insets的边类型（LEFT、TOP、RIGHT、BOTTOM），从计算出的Insets中提取出相应的边距，
        //并将它们添加到窗口的原始边界上，得到显示边界。
        final @WindowInsets.Side.InsetsSide int sides = attrs.getFitInsetsSides();
        final int left = (sides &amp; WindowInsets.Side.LEFT) != 0 ? insets.left : 0;
        final int top = (sides &amp; WindowInsets.Side.TOP) != 0 ? insets.top : 0;
        final int right = (sides &amp; WindowInsets.Side.RIGHT) != 0 ? insets.right : 0;
        final int bottom = (sides &amp; WindowInsets.Side.BOTTOM) != 0 ? insets.bottom : 0;
        //代码将计算出的显示边界赋值给outDisplayFrame
        outDisplayFrame.set(windowBounds.left + left, windowBounds.top + top,
                windowBounds.right - right, windowBounds.bottom - bottom);

        //根据窗口的附加信息和布局属性来确定父边界的位置和大小。
        if (attachedWindowFrame == null) &#123;
            //将outParentFrame设置为与outDisplayFrame相同，这意味着父边界与显示边界相同
            outParentFrame.set(outDisplayFrame);
            //检查私有标志PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME是否被设置。
            //这个标志可能表示是否需要根据输入法窗口（IME）的位置来调整父边界。
            if ((pfl &amp; PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME) != 0) &#123;
                //从状态中获取输入法窗口的源（source）
                final InsetsSource source = state.peekSource(ITYPE_IME);
                if (source != null) &#123;
                    //如果输入法窗口的source存在，则使用该source来计算父边界的内边距（Insets）。
                    outParentFrame.inset(source.calculateInsets(
                            outParentFrame, false /* ignoreVisibility */));//这里忽略source的可见性。
                &#125;
            &#125;
        &#125; else &#123;
            //如果layoutInScreen为true，则将outParentFrame设置为与attachedWindowFrame相同。
            //这表示父边界是由附加窗口的边界决定的。
            //如果layoutInScreen为false，则将outParentFrame设置为与outDisplayFrame相同。
            //这表示父边界与显示边界相同。
            outParentFrame.set(!layoutInScreen ? attachedWindowFrame : outDisplayFrame);
        &#125;

        // Compute bounds restricted by display cutout
        //根据屏幕的显示切边和窗口的布局属性来计算窗口在屏幕上受到限制的位置和大小，确保窗口不会覆盖到显示切边区域
        final int cutoutMode = attrs.layoutInDisplayCutoutMode;//切边模式
        final DisplayCutout cutout = state.getDisplayCutout();//屏幕上的显示切边区域
        //将displayCutoutSafeExceptMaybeBars设置为与displayCutoutSafe相同，
        //这是一个临时矩形，用于稍后计算不受某些系统界面元素（如状态栏）影响的显示切边安全区域。
        final Rect displayCutoutSafeExceptMaybeBars = mTempDisplayCutoutSafeExceptMaybeBarsRect;
        displayCutoutSafeExceptMaybeBars.set(displayCutoutSafe);
        //将outFrames.isParentFrameClippedByDisplayCutout设置为false，表示父边界目前没有被显示切边裁剪
        outFrames.isParentFrameClippedByDisplayCutout = false;
        //如果layoutInDisplayCutoutMode不是ALWAYS并且显示切边不为空
        if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS &amp;&amp; !cutout.isEmpty()) &#123;
            // Ensure that windows with a non-ALWAYS display cutout mode are laid out in
            // the cutout safe zone.
            //获取屏幕的显示边界（displayFrame）
            final Rect displayFrame = state.getDisplayFrame();
            //获取状态的Source
            final InsetsSource statusBarSource = state.peekSource(ITYPE_STATUS_BAR);
            //检查状态栏源（statusBarSource）是否存在，并且如果displayCutoutSafe.top大于屏幕的顶部
            if (statusBarSource != null &amp;&amp; displayCutoutSafe.top &gt; displayFrame.top) &#123;
                // Make sure that the zone we&#39;re avoiding for the cutout is at least as tall as the
                // status bar; otherwise fullscreen apps will end up cutting halfway into the status
                // bar.
                //调整displayCutoutSafeExceptMaybeBars.top以确保切边避开的区域至少与状态栏一样高。
                displayCutoutSafeExceptMaybeBars.top =
                        Math.max(statusBarSource.getFrame().bottom, displayCutoutSafe.top);
            &#125;
            //如果layoutInDisplayCutoutMode是SHORT_EDGES
            if (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES) &#123;
                if (displayFrame.width() &lt; displayFrame.height()) &#123;
                    //如果屏幕的宽度小于高度，则将displayCutoutSafeExceptMaybeBars的顶部和底部设置为最大和最小整数值，
                    //这意味着不考虑这些方向上的显示切边。
                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125; else &#123;
                    //否则，将左侧和右侧设置为最大和最小整数值
                    //这意味着不考虑这些方向上的显示切边。
                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;
                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;
                &#125;
            &#125;
            //通过位运算检查attrs.flags中的FLAG_LAYOUT_INSET_DECOR标志是否被设置。如果被设置，则layoutInsetDecor为true
            // FLAG_LAYOUT_INSET_DECOR:使窗口的内容布局在DecorView（装饰视图）之内
            final boolean layoutInsetDecor = (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) != 0;
            //检查布局是否应在屏幕上进行且是否需要考虑显示切边
            //布局在屏幕上、DecorView之内 且 显示切边模式为默认或短边缘模式
            if (layoutInScreen &amp;&amp; layoutInsetDecor
                    &amp;&amp; (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
                    || cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)) &#123;
                //使用给定的displayFrame、系统栏类型和可见性请求来计算系统栏的插入
                //系统栏包含： STATUS_BARS | NAVIGATION_BARS | CAPTION_BAR
                final Insets systemBarsInsets = state.calculateInsets(
                        displayFrame, WindowInsets.Type.systemBars(), requestedVisibilities);
                //如果系统栏在左侧、顶部、右侧或底部的插入大于0，则调整displayCutoutSafeExceptMaybeBars的相应边界，
                //使其尽可能地远离屏幕边缘。这是为了确保窗口不会覆盖到这些系统栏。
                if (systemBarsInsets.left &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;
                &#125;
                if (systemBarsInsets.top &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;
                &#125;
                if (systemBarsInsets.right &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;
                &#125;
                if (systemBarsInsets.bottom &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125;
            &#125;
            //如果窗口类型是输入法（IME）
            if (type == TYPE_INPUT_METHOD) &#123;
                //获取导航栏的Source
                final InsetsSource navSource = state.peekSource(ITYPE_NAVIGATION_BAR);
                //如果存在导航栏且其底部插入大于0
                if (navSource != null &amp;&amp; navSource.calculateInsets(displayFrame, true).bottom &gt; 0) &#123;
                    // The IME can always extend under the bottom cutout if the navbar is there.
                    //调整displayCutoutSafeExceptMaybeBars.bottom，允许IME窗口扩展到底部显示切边以下。
                    //这是为了确保IME可以正常显示在有导航栏的设备上。
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125;
            &#125;
            //如果窗口已附加到其父窗口并且不是全屏布局，则attachedInParent为true
            final boolean attachedInParent = attachedWindowFrame != null &amp;&amp; !layoutInScreen;

            // TYPE_BASE_APPLICATION windows are never considered floating here because they don&#39;t
            // get cropped / shifted to the displayFrame in WindowState.
            //判断窗口是否为浮窗
            //如果窗口不是全屏的、全屏布局的并且不是基础应用程序类型，那么它是一个浮动在屏幕上的窗口，简称浮窗。
            final boolean floatingInScreenWindow = !attrs.isFullscreen() &amp;&amp; layoutInScreen
                    &amp;&amp; type != TYPE_BASE_APPLICATION;

            // Windows that are attached to a parent and laid out in said parent already avoid
            // the cutout according to that parent and don&#39;t need to be further constrained.
            // Floating IN_SCREEN windows get what they ask for and lay out in the full screen.
            // They will later be cropped or shifted using the displayFrame in WindowState,
            // which prevents overlap with the DisplayCutout.
            //对于非附加到父窗口和非浮动在屏幕上的窗口，需要处理其与显示切边的交集。这是因为这些窗口需要避免与显示切边重叠。
            if (!attachedInParent &amp;&amp; !floatingInScreenWindow) &#123;
                mTempRect.set(outParentFrame); //临时存储父窗口的边界
                //将父窗口的边界设置为与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界
                outParentFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);
                //如果父窗口的边界交集后与原始边界不同，则表示父窗口的边界被切边裁剪了
                outFrames.isParentFrameClippedByDisplayCutout = !mTempRect.equals(outParentFrame);
            &#125;
            //将输出显示边界设置与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界
            outDisplayFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);
        &#125;

        //检查attrs.flags中的FLAG_LAYOUT_NO_LIMITS位是否被设置。
        //FLAG_LAYOUT_NO_LIMITS表示允许窗口布局到屏幕外侧。
        final boolean noLimits = (attrs.flags &amp; FLAG_LAYOUT_NO_LIMITS) != 0;
        //检查当前窗口是否处于多窗口模式
        final boolean inMultiWindowMode = WindowConfiguration.inMultiWindowMode(windowingMode);

        // TYPE_SYSTEM_ERROR is above the NavigationBar so it can&#39;t be allowed to extend over it.
        // Also, we don&#39;t allow windows in multi-window mode to extend out of the screen.
        //noLimits是否为true即允许窗口布局到屏幕外）  
        //type是否不等于TYPE_SYSTEM_ERROR（表示窗口类型不是系统错误）  
        //inMultiWindowMode是否为false（表示窗口不在多窗口模式下）
        if (noLimits &amp;&amp; type != TYPE_SYSTEM_ERROR &amp;&amp; !inMultiWindowMode) &#123;
            //设置输出显示的窗口边界
            //[left,top]为左上角左边，[right,bottom]为右上角坐标，两个坐标构成一个矩形
            //左上角左边设置为屏幕最小点，右下角坐标设置为屏幕最大点，即窗口将占据整个屏幕的边界
            outDisplayFrame.left = MIN_X;
            outDisplayFrame.top = MIN_Y;
            outDisplayFrame.right = MAX_X;
            outDisplayFrame.bottom = MAX_Y;
        &#125;

        //如果compatScale不等于1，则hasCompatScale为true。这意味着存在一个兼容的缩放因子。
        final boolean hasCompatScale = compatScale != 1f;
        //父窗口的宽度和高度
        final int pw = outParentFrame.width();
        final int ph = outParentFrame.height();
        //判断窗口的布局尺寸是否因为显示切边而扩展
        //某些设备可能具有物理上的切边（如刘海屏、水滴屏等），这些切边区域不能用于显示内容。
        //PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT作用就是为了确保应用程序的布局在具有切边的设备上仍然正确显示
        //设置这个标志时，窗口的实际尺寸将大于其请求的尺寸，以便在切边区域周围填充空间。
        final boolean extendedByCutout =
                (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != 0;
        //请求的窗口宽度和高度
        int rw = requestedWidth;
        int rh = requestedHeight;
        //窗口的位置坐标
        float x, y;
        //最终确定的窗口宽度和高度
        int w, h;

        // If the view hierarchy hasn&#39;t been measured, the requested width and height would be
        // UNSPECIFIED_LENGTH. This can happen in the first layout of a window or in the simulated
        // layout. If extendedByCutout is true, we cannot use the requested lengths. Otherwise,
        // the window frame might be extended again because the requested lengths may come from the
        // window frame.
        //如果请求的窗口宽度或高度，是UNSPECIFIED_LENGTH或者窗口因为显示切边而扩展，
        //那么其大于或等于0则使用attrs.width或attrs.height的值，否则使用父窗口的宽度和高度
        if (rw == UNSPECIFIED_LENGTH || extendedByCutout) &#123;
            rw = attrs.width &gt;= 0 ? attrs.width : pw;
        &#125;
        if (rh == UNSPECIFIED_LENGTH || extendedByCutout) &#123;
            rh = attrs.height &gt;= 0 ? attrs.height : ph;
        &#125;

        //如果设置了FLAG_SCALED标志，代码会根据是否应用兼容性缩放来调整窗口的宽度和高度。
        if ((attrs.flags &amp; FLAG_SCALED) != 0) &#123;
            if (attrs.width &lt; 0) &#123;
                w = pw;
            &#125; else if (hasCompatScale) &#123;
                w = (int) (attrs.width * compatScale + .5f);
            &#125; else &#123;
                w = attrs.width;
            &#125;
            if (attrs.height &lt; 0) &#123;
                h = ph;
            &#125; else if (hasCompatScale) &#123;
                h = (int) (attrs.height * compatScale + .5f);
            &#125; else &#123;
                h = attrs.height;
            &#125;
        &#125; else &#123;
            if (attrs.width == MATCH_PARENT) &#123;
                w = pw;
            &#125; else if (hasCompatScale) &#123;
                w = (int) (rw * compatScale + .5f);
            &#125; else &#123;
                w = rw;
            &#125;
            if (attrs.height == MATCH_PARENT) &#123;
                h = ph;
            &#125; else if (hasCompatScale) &#123;
                h = (int) (rh * compatScale + .5f);
            &#125; else &#123;
                h = rh;
            &#125;
        &#125;

        //如果存在兼容缩放因子，则调整窗口的x和y位置以考虑缩放。否则，直接使用原始的x和y位置。
        if (hasCompatScale) &#123;
            x = attrs.x * compatScale;
            y = attrs.y * compatScale;
        &#125; else &#123;
            x = attrs.x;
            y = attrs.y;
        &#125;
        
        //当前窗口是多窗口且设置PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME
        //PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME的作用是窗口应该根据其父窗口的边界来调整自己的大小和位置。
        //即控制子窗口在其父窗口内的布局行为，确保子窗口不会超出父窗口的边界。
        if (inMultiWindowMode
                &amp;&amp; (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME) == 0) &#123;
            // Make sure window fits in parent frame since it is in a non-fullscreen task as
            // required by &#123;@link Gravity#apply&#125; call.
            //将窗口的宽度和高度分别设置为它们与父窗口宽度和高度中的较小值。
            //这样做的目的是确保子窗口的大小不会超过其父窗口的大小。
            w = Math.min(w, pw);
            h = Math.min(h, ph);
        &#125;

        // We need to fit it to the display if either
        // a) The window is in a fullscreen container, or we don&#39;t have a task (we assume fullscreen
        // for the taskless windows)
        // b) If it&#39;s a secondary app window, we also need to fit it to the display unless
        // FLAG_LAYOUT_NO_LIMITS is set. This is so we place Popups, dialogs, and similar windows on
        // screen, but SurfaceViews want to be always at a specific location so we don&#39;t fit it to
        // the display.
    
        //如果窗口不在多窗口模式下，或者窗口类型不是基础应用程序类型并且noLimits标志未设置，那么窗口需要适应显示。
        final boolean fitToDisplay = !inMultiWindowMode
                || ((attrs.type != TYPE_BASE_APPLICATION) &amp;&amp; !noLimits);

        // Set mFrame
        //根据给定的重力属性、宽度、高度、父边界等，计算并设置outFrame。
        //这里主要是确定窗口的位置。
        Gravity.apply(attrs.gravity, w, h, outParentFrame,
                (int) (x + attrs.horizontalMargin * pw),
                (int) (y + attrs.verticalMargin * ph), outFrame);

        // Now make sure the window fits in the overall display frame.
        //如果窗口需要适应显示，那么使用Gravity.applyDisplay方法来调整outFrame(实际边界)的大小和位置在outDisplayFrame(显示边界)之内。
        if (fitToDisplay) &#123;
            Gravity.applyDisplay(attrs.gravity, outDisplayFrame, outFrame);
        &#125;

         //确保应用窗口的位置不会与设备的切边冲突。
         //如果窗口的布局因为切边的存在而进行了扩展，并且窗口的边界超出了安全区域，那么它会调整窗口的位置，使其位于安全区域内。
        if (extendedByCutout &amp;&amp; !displayCutoutSafe.contains(outFrame)) &#123;
            mTempRect.set(outFrame);

            // Move the frame into displayCutoutSafe.
            final int clipFlags = DISPLAY_CLIP_VERTICAL | DISPLAY_CLIP_HORIZONTAL;
            Gravity.applyDisplay(attrs.gravity &amp; ~clipFlags, displayCutoutSafe,
                    mTempRect);

            if (mTempRect.intersect(outDisplayFrame)) &#123;
                outFrame.union(mTempRect);
            &#125;
        &#125;

        if (DEBUG) Log.d(TAG, &quot;computeWindowFrames &quot; + attrs.getTitle()
                + &quot; outFrames=&quot; + outFrames
                + &quot; windowBounds=&quot; + windowBounds.toShortString()
                + &quot; attachedWindowFrame=&quot; + (attachedWindowFrame != null
                        ? attachedWindowFrame.toShortString()
                        : &quot;null&quot;)
                + &quot; requestedWidth=&quot; + requestedWidth
                + &quot; requestedHeight=&quot; + requestedHeight
                + &quot; compatScale=&quot; + compatScale
                + &quot; windowingMode=&quot; + WindowConfiguration.windowingModeToString(windowingMode)
                + &quot; displayCutoutSafe=&quot; + displayCutoutSafe
                + &quot; attrs=&quot; + attrs
                + &quot; state=&quot; + state
                + &quot; requestedVisibilities=&quot; + requestedVisibilities);
  &#125;
</code></pre>
<p>computeFrame方法是WindowState类中的一个重要方法，用于计算窗口的位置和大小。具体来说，它负责计算窗口的绘制区域，即窗口的内容在屏幕上实际显示的位置和大小。这个计算涉及到考虑窗口的位置、大小、布局参数以及可能的边界限制，确保窗口内容不会超出屏幕边界或被其他窗口遮挡。</p>
<p>在窗口管理器中，computeFrame方法通常会在以下情况被调用：</p>
<ul>
<li>当窗口第一次被创建时，需要计算其初始位置和大小。</li>
<li>当窗口的布局参数或内容发生变化时，需要重新计算窗口的位置和大小。</li>
<li>当屏幕旋转或大小变化等系统事件发生时，需要调整所有窗口的位置和大小。</li>
</ul>
<p>总之，computeFrame方法在Android窗口管理系统中起到了非常重要的作用，确保应用程序窗口能够正确地在屏幕上显示，并且适应不同的设备和系统事件, 为了计算小窗的位置，以及处理小窗内的View 的边界异常情况，</p>
<p>再来看看setFrames，更新窗口大小位置变化</p>
<pre><code> win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);
</code></pre>
<p>调用的是WindowState的setFrames方法<br>入参说明：<br><code>sTmpClientFrames</code>：在computeFrames方法计算后的值，用于传递的窗口位置大小相关信息<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    void setFrames(ClientWindowFrames clientWindowFrames, int requestedWidth, int requestedHeight) &#123;
        final WindowFrames windowFrames = mWindowFrames;
        //用mTmpRect存储windowFrames.mParentFrame
        mTmpRect.set(windowFrames.mParentFrame);
        
        //LOCAL_LAYOUTd的值取决于配置项persist.debug.local_layout的值
        if (LOCAL_LAYOUT) &#123;
            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。
            windowFrames.mCompatFrame.set(clientWindowFrames.frame);
            
            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。
            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。
            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。
            windowFrames.mFrame.set(clientWindowFrames.frame);
            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);
            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);
            if (hasCompatScale()) &#123;
                // The frames sent from the client need to be adjusted to the real coordinate space.
                //如果存在兼容比例（通过调用hasCompatScale()方法检查），则对windowFrames中的Frame进行缩放，以适应实际的坐标空间。
                //这里使用mGlobalScale作为缩放因子。
                windowFrames.mFrame.scale(mGlobalScale);
                windowFrames.mDisplayFrame.scale(mGlobalScale);
                windowFrames.mParentFrame.scale(mGlobalScale);
            &#125;
        &#125; else &#123;
            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。
            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。
            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。
            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);
            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);
            windowFrames.mFrame.set(clientWindowFrames.frame);

            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。
            windowFrames.mCompatFrame.set(windowFrames.mFrame);
            if (hasCompatScale()) &#123;
                // Also, the scaled frame that we report to the app needs to be adjusted to be in
                // its coordinate space.
                //仅对windowFrames.mCompatFrame缩放
                windowFrames.mCompatFrame.scale(mInvGlobalScale);
            &#125;
        &#125;
        //isParentFrameClippedByDisplayCutout是一个Boolean
        //如果为true，表示父窗口的边界被显示切边裁剪了；如果为false，表示父窗口的边界没有被显示切边裁剪。
        windowFrames.setParentFrameWasClippedByDisplayCutout(
                clientWindowFrames.isParentFrameClippedByDisplayCutout);

        // Calculate relative frame
        //将mRelFrame设置为与mFrame相同的值。这意味着mRelFrame现在存储了与mFrame相同的位置和尺寸信息。
        windowFrames.mRelFrame.set(windowFrames.mFrame);
        //获取当前窗口的父容器
        WindowContainer&lt;?&gt; parent = getParent();
        //初始化parentLeft和parentTop为0，表示父容器的左上角坐标
        int parentLeft = 0;
        int parentTop = 0; 
        if (mIsChildWindow) &#123;//如果当前窗口是一个子窗口
            //从父窗口的状态中获取其边界的位置信息。
            parentLeft = ((WindowState) parent).mWindowFrames.mFrame.left;
            parentTop = ((WindowState) parent).mWindowFrames.mFrame.top;
        &#125; else if (parent != null) &#123;//如果当前窗口不是子窗口，并且父容器不为空
            //获取父容器的边界位置
            final Rect parentBounds = parent.getBounds();
            parentLeft = parentBounds.left;
            parentTop = parentBounds.top;
        &#125;
        //调整mRelFrame的位置，使其相对于父容器的左上角有一个偏移
        windowFrames.mRelFrame.offsetTo(windowFrames.mFrame.left - parentLeft,
                windowFrames.mFrame.top - parentTop);

        //如果请求的宽度、高度或者父框架与上次不同
        if (requestedWidth != mLastRequestedWidth || requestedHeight != mLastRequestedHeight
                || !mTmpRect.equals(windowFrames.mParentFrame)) &#123;
            //更新最后请求的宽度和高度，并标记内容已更改
            mLastRequestedWidth = requestedWidth;
            mLastRequestedHeight = requestedHeight;
            windowFrames.setContentChanged(true);
        &#125;
        //如果窗口的类型是TYPE_DOCK_DIVIDER，并且边界的位置发生了变化，mMovedByResize标记为true。
        //在分屏的场合，YPE_DOCK_DIVIDER窗口类型用于绘制这个分隔栏，并处理用户的触摸事件以实现大小调整功能。
        if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;
            if (!windowFrames.mFrame.equals(windowFrames.mLastFrame)) &#123;
                mMovedByResize = true;
            &#125;
        &#125;
        
        //如果当前窗口是壁纸，并且框架的宽度或高度发生了变化，更新壁纸的位置。
        if (mIsWallpaper) &#123;
            final Rect lastFrame = windowFrames.mLastFrame;
            final Rect frame = windowFrames.mFrame;
            if (lastFrame.width() != frame.width() || lastFrame.height() != frame.height()) &#123;
                mDisplayContent.mWallpaperController.updateWallpaperOffset(this, false /* sync */);
            &#125;
        &#125;
        
        //更新windowFrames.mFrame
        updateSourceFrame(windowFrames.mFrame);

        //如果定义了LOCAL_LAYOUT，并且还没有边界，更新最后边界的位置。
        if (LOCAL_LAYOUT) &#123;
            if (!mHaveFrame) &#123;
                // The first frame should not be considered as moved.
                updateLastFrames();
            &#125;
        &#125;
        
        //如果存在活动记录，并且当前窗口不是子窗口
        if (mActivityRecord != null &amp;&amp; !mIsChildWindow) &#123;
            //调用mActivityRecord.layoutLetterbox(this);来填充空白区域。也就是Letterbox模式
            mActivityRecord.layoutLetterbox(this);
        &#125;
        //设置mSurfacePlacementNeeded为true。
        mSurfacePlacementNeeded = true;
        //设置mHaveFrame为true，表示已经设置了边界
        mHaveFrame = true;
    &#125;
</code></pre>
<p>其中WindowFrames 是一个表示窗口边框大小和位置的类。<br>WindowFrames 中有一些重要成员变量，用于描述不同的窗口区域。</p>
<p><code>mFrame</code>表示窗口在屏幕上的位置和大小，是窗口管理和界面绘制的基础依据。<br><code>mVisibleFrame</code>表示窗口可见区域的位置和大小，即除去状态栏和导航栏等系统 UI 元素后，窗口实际可以显示的区域。<br><code>mDecorFrame</code>表示窗口装饰区域的位置和大小，即窗口除去实际内容区域外，包含的标题栏、边框、按钮等 UI 元素所占用的空间。<br><code>mDisplayFrame</code>表示整个屏幕的可见区域的位置和大小，也就是说它包含了状态栏和导航栏等系统 UI 元素。</p>
<p>这些成员变量共同描述了窗口在屏幕中的位置和大小，并提供给其他模块使用，比如 WindowManager 和 View 系统。<br>在 Android Framework 中，WindowManagerService 会在每次窗口大小发生变化时，调用 WindowFrames 的 setFrames() 方法，更新这些成员变量的值。</p>
<h4 id="2-3-窗口状态刷新"><a href="#2-3-窗口状态刷新" class="headerlink" title="2.3 窗口状态刷新"></a>2.3 窗口状态刷新</h4><p>当应用端执行measure-layout-draw之后，便会调用<strong>WindowManagerService.finishDrawingWindow</strong>，处理Surface的状态变更并将Surface show出来。<br>首先还是看一下该阶段的流程图，对整个流程有个初步的了解。<br>将整个流程分为三部分：<br>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PENDING，并请求窗口布局。<br>2.mDrawState更新为HAS_DRAW，再次请求窗口布局。<br>3.执行show Surface。</p>
<h5 id="2-3-1-接受客户端请求"><a href="#2-3-1-接受客户端请求" class="headerlink" title="2.3.1 接受客户端请求"></a>2.3.1 接受客户端请求</h5><p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public void finishDrawing(IWindow window,
            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;
        if (DEBUG) Slog.v(TAG_WM, &quot;IWindow finishDrawing called for &quot; + window);
        //调用WMS中的finishDrawingWindow处理
        mService.finishDrawingWindow(this, window, postDrawTransaction, seqId);
    &#125;
</code></pre>
<h5 id="2-3-2-finishDrawingWindow"><a href="#2-3-2-finishDrawingWindow" class="headerlink" title="2.3.2 finishDrawingWindow"></a>2.3.2 finishDrawingWindow</h5><p>1.在WMS中根据客户端的Binder在mWindowMap中获取对应的WindowState。<br>2.调用WindowState.finishDrawing执行mDrawState的状态变更。<br>3.将WindowState.mLayoutNeeded标志位置为true。<br>4.请求进行布局刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    void finishDrawingWindow(Session session, IWindow client,
            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;
        if (postDrawTransaction != null) &#123;
            postDrawTransaction.sanitize();
        &#125;

        final long origId = Binder.clearCallingIdentity();
        try &#123;
            synchronized (mGlobalLock) &#123;
                /*1.根据客户端的Binder在mWindowMap中获取对应的WindowState*/
                WindowState win = windowForClientLocked(session, client, false);
                ProtoLog.d(WM_DEBUG_ADD_REMOVE, &quot;finishDrawingWindow: %s mDrawState=%s&quot;,
                        win, (win != null ? win.mWinAnimator.drawStateToString() : &quot;null&quot;));
                /*2.finishDrawing执行mDrawState的状态更变*/
                if (win != null &amp;&amp; win.finishDrawing(postDrawTransaction, seqId)) &#123;
                    if (win.hasWallpaper()) &#123;
                        win.getDisplayContent().pendingLayoutChanges |=
                                WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                    &#125;
                    /*3.将当前WindowState.mLayoutNeeded置为true*/
                    //该标志位是判断是否进行窗口大小尺寸计算的条件之一
                    win.setDisplayLayoutNeeded();
                    /*4.请求进行布局刷新*/
                    mWindowPlacerLocked.requestTraversal();
                &#125;
            &#125;
        &#125; finally &#123;
            Binder.restoreCallingIdentity(origId);
        &#125;
    &#125;
</code></pre>
<h6 id="1-mDrawState的状态更变"><a href="#1-mDrawState的状态更变" class="headerlink" title="1.mDrawState的状态更变"></a>1.mDrawState的状态更变</h6><p>在finishDrawingWindow中调用WindowState的finishDrawing方法<br><code>win.finishDrawing(postDrawTransaction, seqId)</code><br>这个方法主要调用了WindowStateAnimator的finishDrawingLocked进行状态更变<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>   boolean finishDrawing(SurfaceControl.Transaction postDrawTransaction, int syncSeqId) &#123;
           ......
           //调用WindowStateAnimator.finishDrawingLocked，会将mDrawState的状态更改为COMMIT_DRAW_PENDING
        final boolean layoutNeeded =
                mWinAnimator.finishDrawingLocked(postDrawTransaction, mClientWasDrawingForSync);
        mClientWasDrawingForSync = false;
        // We always want to force a traversal after a finish draw for blast sync.
        return !skipLayout &amp;&amp; (hasSyncHandlers || layoutNeeded);
    &#125;
</code></pre>
<p>我们继续看看WindowStateAnimator中的finishDrawingLocked()方法<br>首先判断mDrawState的状态是否为DRAW_PENDING，在我们创建SurfaceControl时，会将mDrawState状态更新为DRAW_PENDING。因此接下来将状态调整为COMMIT_DRAW_PENDING。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>    boolean finishDrawingLocked(SurfaceControl.Transaction postDrawTransaction,
            boolean forceApplyNow) &#123;
        ......
        boolean layoutNeeded = false;

        if (mDrawState == DRAW_PENDING) &#123;
            ......
            //如果当前状态为DRAW_PENDING，则将mDrawState更变为COMMIT_DRAW_PENDING
            mDrawState = COMMIT_DRAW_PENDING;
            layoutNeeded = true;
        &#125;
        ......
        return layoutNeeded;
    &#125;
</code></pre>
<h6 id="2-请求布局刷新"><a href="#2-请求布局刷新" class="headerlink" title="2.请求布局刷新"></a>2.请求布局刷新</h6><p>在finishDrawingWindow中请求布局刷新<br><code>mWindowPlacerLocked.requestTraversal();</code><br>requestTraversal中主要做了两件事：<br>1.首先将遍历标志为mTraversalSchedule置为true。<br>2.其次发送handle消息mPerformSurfacePlacement</p>
<pre><code>    void requestTraversal() &#123;
        //判断遍历标志mTraversalScheduled是否为true
        if (mTraversalScheduled) &#123;
            return;
        &#125;

        // Set as scheduled even the request will be deferred because mDeferredRequests is also
        // increased, then the end of deferring will perform the request.
        //将遍历标志位置为true
        mTraversalScheduled = true;
        if (mDeferDepth &gt; 0) &#123;
            mDeferredRequests++;
            if (DEBUG) Slog.i(TAG, &quot;Defer requestTraversal &quot; + Debug.getCallers(3));
            return;
        &#125;
        //发送handle消息，处理消息会调用mPerformSurfacePlacement
        mService.mAnimationHandler.post(mPerformSurfacePlacement);
    &#125;
</code></pre>
<p>mPerformSurfacePlacement会新建一个线程调用performSurfacePlacement。<br>performSurfacePlacement方法我们在讲relayoutWindow相关流程的时候讲过，这是执行遍历布局的入口。可以回看下【<strong>2.2.4 计算窗口大小位置中的“1.处理窗口布局循环”</strong>】</p>
<pre><code>    private class Traverser implements Runnable &#123;
        @Override
        public void run() &#123;
            synchronized (mService.mGlobalLock) &#123;
                //调用执行performSurfacePlacement
                performSurfacePlacement();
            &#125;
        &#125;
    &#125;

    private final Traverser mPerformSurfacePlacement = new Traverser();
    
    final void performSurfacePlacement(boolean force) &#123;
        //当mDeferDepth大于0且force为false时，则将延迟布局请求数+1，并直接返回
        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;
            mDeferredRequests++;
            return;
        &#125;
        //将循环的最大次数设置为6次
        int loopCount = 6;
        do &#123;
            //将该标志为设置为false
            mTraversalScheduled = false;
            //执行窗口布局操作
            performSurfacePlacementLoop();
            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);
            loopCount--;
        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局
        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);
        mService.mRoot.mWallpaperActionPending = false;
    &#125;

    private void performSurfacePlacementLoop() &#123;
        //若当前已经进行布局操作，则无需重复调用直接返回
        if (mInLayout) &#123;
            ......
            return;
        &#125;
        ......
        //将该标志位置为true，表示正在处于布局过程中
        mInLayout = true;
        ......
        try &#123;
            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/
            mService.mRoot.performSurfacePlacement();

            mInLayout = false;

            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;

            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;
                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);
                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);
            &#125;
        &#125; catch (RuntimeException e) &#123;
            mInLayout = false;
            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);
        &#125;
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    void performSurfacePlacement() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);
        try &#123;
            //调用performSurfacePlacementNoTrace()
            performSurfacePlacementNoTrace();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;
    // TODO: Super long method that should be broken down...
    void performSurfacePlacementNoTrace() &#123;
        ......
        /*1.如果有焦点变化，更新焦点*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(
                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);
        &#125;
        ......
        
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);
        //开启事务，获取GlobalTransactionWrapper对象
        mWmService.openSurfaceTransaction();
        try &#123;
            /*2.执行窗口尺寸计算，surface状态变更等操作*/
            applySurfaceChangesTransaction();
        &#125; catch (RuntimeException e) &#123;
            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);
        &#125; finally &#123;
            //关闭事务，把事务提交
            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            if (SHOW_LIGHT_TRANSACTIONS) &#123;
                Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);
            &#125;
        &#125;
        ......
        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/
        checkAppTransitionReady(surfacePlacer);
        ......
        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/
        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;
            final DisplayContent displayContent = mChildren.get(displayNdx);
            //判断DisplayContent的壁纸是否需要改变
            if (displayContent.mWallpaperMayChange) &#123;
                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,
                            displayContent.pendingLayoutChanges);
                &#125;
            &#125;
        &#125;
        /*5.在此处理焦点变化*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
                    false /*updateInputWindows*/);
        &#125;
        ......
        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/
        handleResizingWindows();

        if (mWmService.mDisplayFrozen) &#123;
            ProtoLog.v(WM_DEBUG_ORIENTATION,
                    &quot;With display frozen, orientationChangeComplete=%b&quot;,
                    mOrientationChangeComplete);
        &#125;
        if (mOrientationChangeComplete) &#123;
            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;
                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;
                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
            &#125;
            mWmService.stopFreezingDisplayLocked();
        &#125;

        // Destroy the surface of any windows that are no longer visible.
        /*7.销毁不可见的窗口*/
        i = mWmService.mDestroySurface.size();
        if (i &gt; 0) &#123;
            do &#123;
                i--;
                WindowState win = mWmService.mDestroySurface.get(i);
                win.mDestroying = false;
                final DisplayContent displayContent = win.getDisplayContent();
                if (displayContent.mInputMethodWindow == win) &#123;
                    displayContent.setInputMethodWindowLocked(null);
                &#125;
                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;
                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                &#125;
                win.destroySurfaceUnchecked();
            &#125; while (i &gt; 0);
            mWmService.mDestroySurface.clear();
        &#125;
        ......
    &#125;
</code></pre>
<p>​    </p>
<p>这里我们主要关注<code>applySurfaceChangesTransaction();</code>和<code>checkAppTransitionReady(surfacePlacer);</code></p>
<h6 id="窗口位置计算与窗口状态刷新流程不同点"><a href="#窗口位置计算与窗口状态刷新流程不同点" class="headerlink" title="* 窗口位置计算与窗口状态刷新流程不同点"></a>* 窗口位置计算与窗口状态刷新流程不同点</h6><p>可以发现，窗口位置计算流程与窗口状态刷新流程都调用了performSurfacePlacement，两次调用的主要不同点在于：<br>1.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用mApplySurfaceChangesTransaction，处理mDrawState状态。<br>2.窗口状态刷新流程在RootWindowContainer.performSurfacePlacementNoTrace中调用checkAppTransitionReady，处理mDrawState状态变更为HAS_DRAWN，触发Activity过渡动画。<br>3.窗口状态刷新流程在WindowSurfacePlacementLoop.performSurfacePlacementLoop中会调用requestTraversal，请求再次布局。<br>4.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用prepareSurfaces()处理处理surface的位置、大小以及显示等。</p>
<h5 id="2-3-3-mDrawState变更为HAS-DRAW"><a href="#2-3-3-mDrawState变更为HAS-DRAW" class="headerlink" title="2.3.3 mDrawState变更为HAS_DRAW"></a>2.3.3 mDrawState变更为HAS_DRAW</h5><h6 id="1-mApplySurfaceChangesTransaction"><a href="#1-mApplySurfaceChangesTransaction" class="headerlink" title="1.mApplySurfaceChangesTransaction"></a>1.mApplySurfaceChangesTransaction</h6><p>RootWindowContainer的applySurfaceChangesTransaction()方法最终会调用到DisplayContent中调用的applySurfaceChangesTransaction()方法（【2.2.4 计算窗口大小位置】中讲过流程，不再赘述）<br>我们接着该方法中的mApplySurfaceChangesTransaction跟踪。<br><code>forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);</code><br>如果当前WindowState存在surfaceControl，则进入到WindowStateAnimator进行mDrawState的状态更变。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;
        ......
        //首先判断当前windowState的是否有surfaceControl
        if (w.mHasSurface) &#123;
            // Take care of the window being ready to display.
            //调用WindowStateAnimator的commitFinishDrawingLocked()方法
            final boolean committed = winAnimator.commitFinishDrawingLocked();
            ......
        &#125;
        ......
    &#125;;
</code></pre>
<p>继续看看WindowStateAnimator的commitFinishDrawingLocked()方法<br><code>final boolean committed = winAnimator.commitFinishDrawingLocked();</code><br>1.对mDrawState的状态进行过滤，非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回。<br>2.此时我们的mDrawState已经在“<strong>【2.3.2 finishDrawingWindow】</strong>”将状态更新为COMMIT_DRAW_PENDING，因此此处将其变更为READY_TO_SHOW。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>    // This must be called while inside a transaction.
    boolean commitFinishDrawingLocked() &#123;
        //非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回
        if (mDrawState != COMMIT_DRAW_PENDING &amp;&amp; mDrawState != READY_TO_SHOW) &#123;
            return false;
        &#125;
        ProtoLog.i(WM_DEBUG_ANIM, &quot;commitFinishDrawingLocked: mDrawState=READY_TO_SHOW %s&quot;,
                mSurfaceController);
        //将状态更变为READY_TO_SHOW
        mDrawState = READY_TO_SHOW;
        boolean result = false;
        final ActivityRecord activity = mWin.mActivityRecord;
        //直接进入到WindowState.performShowLocked()流程的三种情况
        //1.如果ActivityRecord为空，这种情况可以理解为不依赖Activity的窗口，比如常见的悬浮窗
        //2.或者canShowWindows()为true，这个方法大概是说：只有当所有窗口都已绘制完成，并且没有正在进行父级窗口的应用过渡动画，并且没有非默认颜色的窗口存在时，返回true
        //3.或者窗口类型为启动窗口，启动窗口就是StartingWindow，应用启动时出现的窗口，常见的就是Splash screen ，许多应用都会定义自己的SplashActivity
        //进入performShowLocked()流程后mDrawState更新HAS_DRAWN
        //由于非这三种情况最终也会调用到performShowLocked()，因此下面这种情况我们暂不讨论
        if (activity == null || activity.canShowWindows()
                || mWin.mAttrs.type == TYPE_APPLICATION_STARTING) &#123;
            result = mWin.performShowLocked();
        &#125;
        return result;
    &#125;
</code></pre>
<h6 id="2-checkAppTransitionReady"><a href="#2-checkAppTransitionReady" class="headerlink" title="2.checkAppTransitionReady()"></a>2.checkAppTransitionReady()</h6><p>这里我们继续跟踪RootWindowContainer.performSurfacePlacementNoTrace()方法中的checkAppTransitionReady()方法<br><code>checkAppTransitionReady(surfacePlacer);</code><br>该方法会遍历所有DisplayContent，处理activity的过滤动画，此处我们只有跟踪有关mDrawState状态更变的相关代码<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    private void checkAppTransitionReady(WindowSurfacePlacer surfacePlacer) &#123;
        // Trace all displays app transition by Z-order for pending layout change.
        for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123;
            final DisplayContent curDisplay = mChildren.get(i);

            // If we are ready to perform an app transition, check through all of the app tokens
            // to be shown and see if they are ready to go.
            //检查所有要显示的app token，是否已经准备就绪
            if (curDisplay.mAppTransition.isReady()) &#123;
                // handleAppTransitionReady may modify curDisplay.pendingLayoutChanges.
                curDisplay.mAppTransitionController.handleAppTransitionReady();
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;after handleAppTransitionReady&quot;,
                            curDisplay.pendingLayoutChanges);
                &#125;
            &#125;
            ......
        &#125;
    &#125;
</code></pre>
<p>调用AppTransitionController的handleAppTransitionReady()方法，该方法主要做了以下事情<br>1.处理activity的过渡动画（远程动画）<br>2.分别调用 handleClosingApps以及handleOpeningApps对要关闭的和要打开的Activity进行可见性更新。<br>3.由于activity的可见性变更，将DisplayContent.mLayoutNeeded设置为true，该标志位在DisplayContent.performLayoutNoTrace中用来判断是否对当前DisplayContent下的所有窗口进行刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;AppTransitionController.java</p>
<pre><code>    /**
     * Handle application transition for given display.
     */
    void handleAppTransitionReady() &#123;
        ......
        try &#123;
            /*1.1应用app transition动画（远程动画）*/
            applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,
                    voiceInteraction);
            /*1.2处理closing activity可见性*/
            handleClosingApps();
            /*1.3处理opening actvity可见性*/
            handleOpeningApps();
            ......
        &#125; finally &#123;
            mService.mSurfaceAnimationRunner.continueStartingAnimations();
        &#125;
        ......

        // This has changed the visibility of windows, so perform
        // a new layout to get them all up-to-date.
        /*2.由于activity的可见性变更，将DisplayContent.mLayoutNeeded标志位置为true*/
        mDisplayContent.setLayoutNeeded();
        ......
    &#125;
</code></pre>
<p><strong>applyAnimations()</strong><br>基于一组ActivityRecord来应用动画，这些ActivityRecord表示正在进行切换的应用程序。<br><code>applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,voiceInteraction);</code></p>
<pre><code>    /**
     * Apply an app transition animation based on a set of &#123;@link ActivityRecord&#125;
     *
     * @param openingApps The list of opening apps to which an app transition animation applies.
     * @param closingApps The list of closing apps to which an app transition animation applies.
     * @param transit The current transition type.
     * @param animLp Layout parameters in which an app transition animation runs.
     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice
     *                         interaction session driving task.
     */
    private void applyAnimations(ArraySet&lt;ActivityRecord&gt; openingApps,
            ArraySet&lt;ActivityRecord&gt; closingApps, @TransitionOldType int transit,
            LayoutParams animLp, boolean voiceInteraction) &#123;
        //方法检查过渡类型是否未设置，或者打开和关闭的应用程序是否都为空。如果是，则方法直接返回，不执行任何动画。
        if (transit == WindowManager.TRANSIT_OLD_UNSET
                || (openingApps.isEmpty() &amp;&amp; closingApps.isEmpty())) &#123;
            return;
        &#125;

        //调用getAnimationTargets方法获取打开和关闭的窗口容器（WindowContainer）
        final ArraySet&lt;WindowContainer&gt; openingWcs = getAnimationTargets(
                openingApps, closingApps, true /* visible */);
        final ArraySet&lt;WindowContainer&gt; closingWcs = getAnimationTargets(
                openingApps, closingApps, false /* visible */);
        //打开和关闭的窗口应用动画。这是通过调重载的applyAnimations方法完成的，传递相应的参数，如动画的目标、过渡类型等。
        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,
                voiceInteraction);
        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,
                voiceInteraction);
        //如果存在最近任务动画控制器（RecentsAnimationController），则发送任务出现任务
        final RecentsAnimationController rac = mService.getRecentsAnimationController();
        if (rac != null) &#123;
            rac.sendTasksAppeared();
        &#125;

        //遍历打开和关闭的应用程序，并设置mOverrideTaskTransition为false
        for (int i = 0; i &lt; openingApps.size(); ++i) &#123;
            openingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;
        &#125;
        for (int i = 0; i &lt; closingApps.size(); ++i) &#123;
            closingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;
        &#125;

        //如果存在辅助功能控制器（AccessibilityController）且有回调，则调用其onAppWindowTransition方法。
        final AccessibilityController accessibilityController =
                mDisplayContent.mWmService.mAccessibilityController;
        if (accessibilityController.hasCallbacks()) &#123;
            accessibilityController.onAppWindowTransition(mDisplayContent.getDisplayId(), transit);
        &#125;
    &#125;
</code></pre>
<p>入参含义：<br><code>openingApps</code> 和 <code>closingApps</code>: 这两个参数是ActivityRecord类型的数组，分别表示正在打开和关闭的应用程序，即这些ActivityRecord表示正在进行切换的应用程序。<br><code>transit</code>: 这是一个整型参数，表示过渡类型。例如，WindowManager.TRANSIT_OLD_UNSET表示没有特定的过渡类型。<br><code>animLp</code>: 这是一个LayoutParams对象，用于定义窗口的布局参数。<br><code>voiceInteraction</code>: 一个布尔值，表示是否为语音交互。</p>
<p>总而言之，该方法主要负责处理应用程序窗口的打开和关闭动画。它确保应用程序在切换时有一个平滑的视觉效果，为用户提供更好的体验。最后还与辅助功能服务交互，确保辅助功能用户也能正确地感知应用程序窗口的切换。</p>
<p>再来说说其中调用的applyAnimations方法部分</p>
<pre><code>        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,
                voiceInteraction);
        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,
                voiceInteraction);
</code></pre>
<p>调用的是重载的applyAnimations方法</p>
<pre><code>      /**
     * Apply animation to the set of window containers.
     *
     * @param wcs The list of &#123;@link WindowContainer&#125;s to which an app transition animation applies.
     * @param apps The list of &#123;@link ActivityRecord&#125;s being transitioning.
     * @param transit The current transition type.
     * @param visible &#123;@code true&#125; if the apps becomes visible, &#123;@code false&#125; if the apps becomes
     *                invisible.
     * @param animLp Layout parameters in which an app transition animation runs.
     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice
     *                         interaction session driving task.
     */
    private void applyAnimations(ArraySet&lt;WindowContainer&gt; wcs, ArraySet&lt;ActivityRecord&gt; apps,
            @TransitionOldType int transit, boolean visible, LayoutParams animLp,
            boolean voiceInteraction) &#123;
        //获取窗口容器的数量
        final int wcsCount = wcs.size();
        //遍历每一个窗口容器
        for (int i = 0; i &lt; wcsCount; i++) &#123;
            final WindowContainer wc = wcs.valueAt(i);
            // If app transition animation target is promoted to higher level, SurfaceAnimator
            // triggers WC#onAnimationFinished only on the promoted target. So we need to take care
            // of triggering AR#onAnimationFinished on each ActivityRecord which is a part of the
            // app transition.
            //对于每一个窗口容器，检查正在进行切换的应用程序（apps）中哪些是该窗口容器的后代。
            //这些后代应用程序将被添加到一个列表中。
            final ArrayList&lt;ActivityRecord&gt; transitioningDescendants = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt; apps.size(); ++j) &#123;
                final ActivityRecord app = apps.valueAt(j);
                if (app.isDescendantOf(wc)) &#123;
                    transitioningDescendants.add(app);
                &#125;
            &#125;
            //调用每个窗口容器的applyAnimation方法，传入相应的参数（如动画的布局参数、过渡类型、是否可见等）以及后代应用程序的列表。
            wc.applyAnimation(animLp, transit, visible, voiceInteraction, transitioningDescendants);
        &#125;
    &#125;
</code></pre>
<p>入参含义：<br><code>wcs</code>: 一个WindowContainer对象的集合，这些对象是需要应用动画的窗口容器。<br><code>apps</code>: 一个ActivityRecord对象的集合，这些对象表示正在进行切换的应用程序。<br><code>transit</code>: 当前的过渡类型，例如淡入淡出、滑动等。<br><code>visible</code>: 一个布尔值，表示应用程序是否变为可见。<br><code>animLp</code>: 布局参数，定义了动画运行时的布局。<br><code>voiceInteraction</code>: 一个布尔值，表示是否有语音交互。</p>
<p>这部分远程动画流程，这里不做重点</p>
<p><strong>handleClosingApps()</strong><br>该方法中主要的作用就是将所有即将close的activity的mVisible标志设置为false。该标志位在后续prepareSurfaces中是判断是否show surface的条件之一。</p>
<pre><code>   private void handleClosingApps() &#123;
        final ArraySet&lt;ActivityRecord&gt; closingApps = mDisplayContent.mClosingApps;
        final int appsCount = closingApps.size();

        for (int i = 0; i &lt; appsCount; i++) &#123;
            final ActivityRecord app = closingApps.valueAt(i);
            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now closing app %s&quot;, app);
            //设置activity的可见性，将mVisible设置为false
            app.commitVisibility(false /* visible */, false /* performLayout */);
            app.updateReportedVisibilityLocked();
            // Force the allDrawn flag, because we want to start
            // this guy&#39;s animations regardless of whether it&#39;s
            // gotten drawn.
            //强制将allDrawn设置为true
            app.allDrawn = true;
            ......
        &#125;
    &#125;
</code></pre>
<p><strong>handleOpeningApps()</strong><br>该方法与handleClosingApps方法类似,主要处理两件事情：<br>1.将所有即将open的activity的mVisible标志位设置为true.<br>2.调用ActivityRecord.showAllWindowsLocked()，最终会调用到WindowState.performShowLocked() ，处理mDrawState的状态变更</p>
<pre><code>    private void handleOpeningApps() &#123;
        final ArraySet&lt;ActivityRecord&gt; openingApps = mDisplayContent.mOpeningApps;
        final int appsCount = openingApps.size();

        for (int i = 0; i &lt; appsCount; i++) &#123;
            final ActivityRecord app = openingApps.valueAt(i);
            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now opening app %s&quot;, app);
            /*1.设置activity的可见性，将mVisible设置为true*/
            app.commitVisibility(true /* visible */, false /* performLayout */);
            ......
            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
                    &quot;&gt;&gt;&gt; OPEN TRANSACTION handleAppTransitionReady()&quot;);
            //开启事务
            mService.openSurfaceTransaction();
            try &#123;
                /*2.此方法最终会调用到WindowState.performShowLocked*/
                app.showAllWindowsLocked();
            &#125; finally &#123;
            //关闭事务
            mService.closeSurfaceTransaction(&quot;handleAppTransitionReady&quot;);
                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION handleAppTransitionReady()&quot;);
            &#125;
            ......
        &#125;
    &#125;
</code></pre>
<p><code>app.showAllWindowsLocked();</code>先调用到ActivityRecord的showAllWindowsLocked()<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p>
<pre><code>    /**
     * This must be called while inside a transaction.
     */
    void showAllWindowsLocked() &#123;
        forAllWindows(windowState -&gt; &#123;
            if (DEBUG_VISIBILITY) Slog.v(TAG, &quot;performing show on: &quot; + windowState);
            windowState.performShowLocked();
        &#125;, false /* traverseTopToBottom */);
    &#125;
</code></pre>
<p><code>windowState.performShowLocked();</code>再调用到WindowState的performShowLocked()<br>将mDrawState的状态由READY_TO_SHOW变更为HAS_DRAW<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    // This must be called while inside a transaction.
    boolean performShowLocked() &#123;
        ......
        //获取WindowStateAnimator.mDrawState
        final int drawState = mWinAnimator.mDrawState;
        //这里判断（drawState 状态为HAS_DRAWN 或者READY_TO_SHOW）且ActivityRecord不为空
        if ((drawState == HAS_DRAWN || drawState == READY_TO_SHOW) &amp;&amp; mActivityRecord != null) &#123;
            //窗口类型不为启动窗口
            if (mAttrs.type != TYPE_APPLICATION_STARTING) &#123;
                mActivityRecord.onFirstWindowDrawn(this);
            &#125; else &#123;
                mActivityRecord.onStartingWindowDrawn();
            &#125;
        &#125;
        //如果当前mDrawState的状态不为READY_TO_SHOW ，则直接返回
        if (mWinAnimator.mDrawState != READY_TO_SHOW || !isReadyForDisplay()) &#123;
            return false;
        &#125;
        ......
        //走入窗口动画流程
        mWinAnimator.applyEnterAnimationLocked();
        
        // Force the show in the next prepareSurfaceLocked() call.
        mWinAnimator.mLastAlpha = -1;
        ProtoLog.v(WM_DEBUG_ANIM, &quot;performShowLocked: mDrawState=HAS_DRAWN in %s&quot;, this);
        //设置mDrawState的状态为HAS_DRAWN
        mWinAnimator.mDrawState = HAS_DRAWN;
        mWmService.scheduleAnimationLocked();
        ......
        return true;
    &#125;
</code></pre>
<p>添加窗口时，会调用这个<code>mWinAnimator.applyEnterAnimationLocked();</code>窗口动画的方法，然后调用到<code>applyAnimationLocked()</code>；窗口移除时，会直接调用<code>applyAnimationLocked()</code>显示动画。可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/134289284?spm=1001.2014.3001.5502">Android T窗口动画显示和退出流程</a></p>
<h6 id="3-再次请求布局"><a href="#3-再次请求布局" class="headerlink" title="3.再次请求布局"></a>3.再次请求布局</h6><p>回到WindowSurfacePlacer中通过requestTraversals()，再次请求布局，该方法将mTraversalScheduled标志位设置为true的判断条件有两个：<br>1.遍历所有DisplayContent.mLayoutNeeded标志为是否为true。（由于AppTransitionController.handleAppTransitionReady阶段已经将mLayoutNeeded置为true，因此该条件为真）<br>2.重复布局的次数不能超过6次，该条件也为真。（因为当前还只是第一次布局)<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p>
<pre><code>    private void performSurfacePlacementLoop() &#123;
        ......
        try &#123;
            ......
            /*1.遍历所有DisplayContent.mLayoutNeeded标志位是否为true*/
            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.如果需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;
            ......
        &#125; catch (RuntimeException e) &#123;
        ......
        &#125;
    &#125;
</code></pre>
<p>接下来进入<strong>第二次布局循环</strong>，其主要目的是为了show surface</p>
<h5 id="2-3-4-show-Surface"><a href="#2-3-4-show-Surface" class="headerlink" title="2.3.4 show Surface"></a>2.3.4 show Surface</h5><p>在第二次循环中，我们主要关注DisplayContent中applySurfaceChangesTransaction()方法调用的prepareSurfaces()</p>
<p>该方法最终会调用到根容器WindowContainer，来遍历所有子容器中的prepareSurfaces。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    @Override
    void prepareSurfaces() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;prepareSurfaces&quot;);
        try &#123;
            //获取事务
            final Transaction transaction = getPendingTransaction();
            //调用其父类方法
            super.prepareSurfaces();

            // TODO: Once we totally eliminate global transaction we will pass transaction in here
            //       rather than merging to global.
            SurfaceControl.mergeToGlobalTransaction(transaction);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;
</code></pre>
<p>调用其父类方法<code>super.prepareSurfaces();</code><br>DisplayContent的父类为WindowContainer<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>    void prepareSurfaces() &#123;
        // If a leash has been set when the transaction was committed, then the leash reparent has
        // been committed.
        mCommittedReparentToAnimationLeash = mSurfaceAnimator.hasLeash();
        //调用所有子容器中的prepareSurfaces
        for (int i = 0; i &lt; mChildren.size(); i++) &#123;
            mChildren.get(i).prepareSurfaces();
        &#125;
    &#125;
</code></pre>
<p><code>mChildren.get(i).prepareSurfaces();</code>在WindowState.prepareSurfaces中，主要做了两方面工作。<br>1.将mWindowFrames中计算出来的left以及top设置surface位置，并调整窗口比例。<br>2.控制surface的可见性，查看WindowStateAnimator.prepareSurfaceLocked<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    void prepareSurfaces() &#123;
        mIsDimming = false;
        applyDims();
        //实际调用的是其父类WindowContainer的方法
        /*1.最终调用自身的updateSurfacePosition()（自身有重写该方法）计算surface的位置*/
        updateSurfacePositionNonOrganized();
        // Send information to SurfaceFlinger about the priority of the current window.
        updateFrameRateSelectionPriorityIfNeeded();
        //更新窗口比例
        updateScaleIfNeeded();

        /*2.控制surface的可见性，调用WindowStateAnimator的prepareSurfaceLocked()方法*/
        mWinAnimator.prepareSurfaceLocked(getSyncTransaction());
        super.prepareSurfaces();
    &#125;
    
    @Override
    @VisibleForTesting
    void updateSurfacePosition(Transaction t) &#123;
        if (mSurfaceControl == null) &#123;
            return;
        &#125;

        //这段代码首先检查布局是否被延迟（通过 isLayoutDeferred() 方法）
        //或者应用是否正在进行布局（通过 isGoneForLayout() 方法）。
        //如果满足这些条件并且 mSurfacePlacementNeeded 为 false，则方法返回，不执行后续操作。
        //这是因为当布局被延迟或应用正在进行布局时，界面的位置可能不是最新的，因此不执行updateSurfacePosition。
        if ((mWmService.mWindowPlacerLocked.isLayoutDeferred() || isGoneForLayout())
                &amp;&amp; !mSurfacePlacementNeeded) &#123;
            // Since this relies on mWindowFrames, changes made while layout is deferred are
            // likely to be invalid. Similarly, if it&#39;s goneForLayout, mWindowFrames may not be
            // up-to-date and thus can&#39;t be relied on.
            return;
        &#125;
        
        //将mSurfacePlacementNeeded设置为false
        mSurfacePlacementNeeded = false;
        //将mSurfacePosition的left以及top设置mWindowFrames中计算出来的left以及top，并根据parent进行偏移
        transformFrameToSurfacePosition(mWindowFrames.mFrame.left, mWindowFrames.mFrame.top,
                mSurfacePosition);
        //根据壁纸的比例对SurfacePosition进行调整
        if (mWallpaperScale != 1f) &#123;
            final Rect bounds = getLastReportedBounds();
            Matrix matrix = mTmpMatrix;
            matrix.setTranslate(mXOffset, mYOffset);
            matrix.postScale(mWallpaperScale, mWallpaperScale, bounds.exactCenterX(),
                    bounds.exactCenterY());
            matrix.getValues(mTmpMatrixArray);
            mSurfacePosition.offset(Math.round(mTmpMatrixArray[Matrix.MTRANS_X]),
                Math.round(mTmpMatrixArray[Matrix.MTRANS_Y]));
        &#125; else &#123;
            mSurfacePosition.offset(mXOffset, mYOffset);
        &#125;
        ......
    &#125;
</code></pre>
<p><code>mWinAnimator.prepareSurfaceLocked(getSyncTransaction());</code> 调用WindowStateAnimator的prepareSurfaceLocked()方法，该则真正的处理触发surface show的逻辑。主要分为两部分。<br>1.将计算的alpha应用于当前surface。<br>2.判断是否调用showSurfaceRobustlyLocked将surface show出来。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>   void prepareSurfaceLocked(SurfaceControl.Transaction t) &#123;
        final WindowState w = mWin;
        //首先判断是否有SurfaceControl
        if (!hasSurface()) &#123;
            ......
            return;
        &#125;
        //设置mShowAlpha
        computeShownFrameLocked();

        //判断parentWindow是否hidden，或者当前窗口是否on-screen
        if (w.isParentWindowHidden() || !w.isOnScreen()) &#123;
            ......
        &#125; else if (mLastAlpha != mShownAlpha
                || mLastHidden) &#123;
            mLastAlpha = mShownAlpha;
            ProtoLog.i(WM_SHOW_TRANSACTIONS,
                    &quot;SURFACE controller=%s alpha=%f HScale=%f, VScale=%f: %s&quot;,
                    mSurfaceController, mShownAlpha, w.mHScale, w.mVScale, w);
            /*1.设置surface的alpha*/
            boolean prepared =
                mSurfaceController.prepareToShowInTransaction(t, mShownAlpha);
            //如果当前状态为HAS_DRAWN
            if (prepared &amp;&amp; mDrawState == HAS_DRAWN) &#123;
                if (mLastHidden) &#123;
                /*2.触发show surface*/
                    if (showSurfaceRobustlyLocked(t)) &#123;
                        mAnimator.requestRemovalOfReplacedWindows(w);
                        //设置mLastHidden为false
                        mLastHidden = false;
                        .......
                    &#125; else &#123;
                        w.setOrientationChanging(false);
                    &#125;
                &#125;
            &#125;
        &#125; else &#123;
            if (mWin.isAnimating(TRANSITION | PARENTS)) &#123;
                ProtoLog.v(WM_DEBUG_ANIM, &quot;prepareSurface: No changes in animation for %s&quot;, this);
            &#125;
        &#125;

        ......
    &#125;
</code></pre>
<p>从上述代码中可以看出触发showSurfaceRobustlyLocked的判断条件有以下几点：<br>1.w.isParentWindowHidden判断其parent的mHidden是否为true，此时当前窗口没有parent直接返回false<br>2.w.isOnScreen，判断当前窗口是否在屏幕上，如果该窗口mVisible为true或者在不可见之前正在运行动画，判断为在屏幕上。我们在上次布局的AppTransitionController.handleAppTransitionReady阶段将当前窗口的mVisible置为了true，因此w.isOnScreen返回true。<br>3.mLastAlpha !&#x3D; mShownAlpha以及mLastHidden满足其一即可，此处我们分析mLastHidden，该标志位在创建SurfaceControl或者hide surface时会被置为true，因为当前窗口才刚刚被创建，因此mLastHidden为true。<br>经过以上判断可以得出我们顺利触发showSurfaceRobustlyLocked<br>后面通过WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController</p>
<pre><code>    /**
     * Have the surface flinger show a surface, robustly dealing with
     * error conditions.  In particular, if there is not enough memory
     * to show the surface, then we will try to get rid of other surfaces
     * in order to succeed.
     *
     * @return Returns true if the surface was successfully shown.
     */
    private boolean showSurfaceRobustlyLocked(SurfaceControl.Transaction t) &#123;
        //WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController
        //调用WindowSurfaceController的showRobustly方法
        boolean shown = mSurfaceController.showRobustly(t);
        //如果没有成功返回false
        if (!shown)
            return false;

        t.merge(mPostDrawTransaction);
        return true;
    &#125;
</code></pre>
<p>在WindowSurfaceController中，首先判断标志位mSurfaceShown，若为true则直接返回；若为false，则将mSurfaceShown置为true，并调用SurfaceControl.show。至此真正的绘图已经显示出来，但是否真正的被用户看见，还需要看其parent是否被show。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p>
<pre><code>    boolean showRobustly(SurfaceControl.Transaction t) &#123;
        ......

        //首先判断surface是否已经shown
        if (mSurfaceShown) &#123;
            return true;
        &#125;
        //将mSurfaceShown设置为true
        setShown(true);
        //调用SurfceControl中的show方法，将surface show出来
        t.show(mSurfaceControl);
        if (mAnimator.mIsWallpaper) &#123;
            EventLog.writeEvent(EventLogTags.WM_WALLPAPER_SURFACE,
                    mAnimator.mWin.getDisplayId(), 1 /* request shown */);
        &#125;
        return true;
    &#125;
</code></pre>
<p>从SurfaceControl的创建以及show的流程上看，可以发现WMS是通过WindowSurfaceController对SurfaceControl进行管理的。<br>最后我们看一下SurfaceControl中的show方法<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>        /**
         * Request that a given surface and it&#39;s sub-tree be shown.
         *
         * @param sc The surface to show.
         * @return This transaction.
         * @hide
         */
        @UnsupportedAppUsage
        public Transaction show(SurfaceControl sc) &#123;
            checkPreconditions(sc);
            nativeSetFlags(mNativeObject, sc.mNativeObject, 0, SURFACE_HIDDEN);
            return this;
        &#125;
</code></pre>
<h4 id="2-4-performSurfacePlacement-流程总结"><a href="#2-4-performSurfacePlacement-流程总结" class="headerlink" title="2.4 performSurfacePlacement()流程总结"></a>2.4 performSurfacePlacement()流程总结</h4><p><img src="/../../../../../images/0b16f1c79359438783f3ed8e5f94ce84.png" alt="在这里插入图片描述"><br>在“【<strong>2.2 窗口位置计算</strong>】”以及“【<strong>2.3 窗口状态刷新</strong>】”部分均调用了WindowSurfacePlacer.performSurfacePlacement()，实际上任何窗口属性变化都会触发该方法，但我们在performSurfacePlacement中只关注了窗口位置大小计算以及窗口状态变更的相关流程。此处再对该流程进行简单的梳理。<br>当调用到WindowSurfacePlacer.performSurfacePlacement()时首先会执行“<strong>1</strong>”更新所有窗口的大小以及状态信息，在执行“<strong>2</strong>”处理是否在此调用执行performSurfacePlacement。<br><strong>1.1.1</strong>：主要调用computeFrames，计算窗口的尺寸大小。<br><strong>1.1.2</strong>：主要处理mDrawState的状态变更，在commitFinishDrawingLocked中会将处于DRAW_PENDING状态的mDrawState更新为COMMIT_DRAW_PENDING。<br><strong>1.1.3</strong>：主要根据computerFrames中计算出来的窗口大小来设置Surface的位置，并调用SurfaceControl.show()将窗口show出来。<br><strong>1.2</strong>：将处于COMMIT_DRAW_PENDING状态的mDrawState更新为READY_TO_SHOW，并将DisplayContent.mLayoutNeeded设置为true。在“<strong>2</strong>”中会判断该标志位来处理是否再次调用performSurfacePlacement的操作。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/3.窗口层级_层级结构树添加窗口" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/">WMSAMS</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>尚未添加窗口的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树，如图<br><img src="/../../../../../images/52bf50fb1c174a14809994182587a19e.png" alt="在这里插入图片描述">DisplayArea层级结构中的每一个DisplayArea，都包含着一个层级值范围，这个层级值范围表明了这个DisplayArea可以容纳哪些类型的窗口。<br>每种窗口类型，都可以通过WindowManagerPolicy.getWindowLayerFromTypeLw方法，返回一个相应的层级值。</p>
<pre><code>/**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.
     */
    default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;
        return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow,
                false /* roundedCornerOverlay */);
    &#125;

    /**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @param roundedCornerOverlay 
</code></pre>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/2.窗口层级 _层级结构树的构建" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/">WMSAMS</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>如何通过dump中的内容找到对应的代码？<br>我们dump窗口层级发现会有很多信息，<code>adb shell dumpsys activity containers</code><br><img src="/../../../../../images/555fb894ede74f2eaa1c225401c5b842.png" alt="在这里插入图片描述">这里我们以其中的DefaultTaskDisplayArea为例</p>
<p><img src="/../../../../../images/97cd0ef57f694c56ac83261890469dd0.png" alt="在这里插入图片描述">在源码的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=framework&spm=1001.2101.3001.7020">framework</a>目录下查找该字符串，找到对应的代码就可以通过打印堆栈或者搜索代码跟踪的方式找到其调用逻辑</p>
<pre><code>final TaskDisplayArea defaultTaskDisplayArea = 
            new TaskDisplayArea(content, wmService,
            &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
</code></pre>
<p>也就是这一句</p>
<p>当然我们上篇文章也讲到了DisplayContent代表的屏幕的DisplayArea层级结构的根节点，我们可以直接从DisplayContent.java的构造方法出发，追踪其流程</p>
<h2 id="DisplayContent初始化"><a href="#DisplayContent初始化" class="headerlink" title="DisplayContent初始化"></a>DisplayContent初始化</h2><p>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>/**
     * Create new &#123;@link DisplayContent&#125; instance, add itself to the root window container and
     * initialize direct children.
     * @param display May not be null.
     * @param root &#123;@link RootWindowContainer&#125;
     */
    DisplayContent(Display display, RootWindowContainer root) &#123;
        super(root.mWindowManager, &quot;DisplayContent&quot;, FEATURE_ROOT);
        ......
        final Transaction pendingTransaction = getPendingTransaction();
        configureSurfaces(pendingTransaction);
        pendingTransaction.apply();
        ......
    &#125;
</code></pre>
<p>创建新的DisplayContent实例，将其自身添加到根窗口容器并初始化直接子级<br><strong>FEATURE_ROOT，对应DisplayContent，一个屏幕上的根DisplayArea，也就是dump中的Display节点。</strong><br><img src="/../../../../../images/653d5a70093f4f4a8d6938e860f90e5d.png" alt="在这里插入图片描述"></p>
<p>这里我们主要关注一下<code>configureSurfaces(pendingTransaction);</code></p>
<pre><code> /**
     * Configures the surfaces hierarchy for DisplayContent
     * This method always recreates the main surface control but reparents the children
     * if they are already created.
     * @param transaction as part of which to perform the configuration
     */
    private void configureSurfaces(Transaction transaction) &#123;
        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(mSession)
                .setOpaque(true)
                .setContainerLayer()
                .setCallsite(&quot;DisplayContent&quot;);
        mSurfaceControl = b.setName(getName()).setContainerLayer().build();

        if (mDisplayAreaPolicy == null) &#123;
            // Setup the policy and build the display area hierarchy.
            // Build the hierarchy only after creating the surface so it is reparented correctly
            mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                    mWmService, this /* content */, this /* root */,
                    mImeWindowsContainer);
        &#125;
        ......
       
    &#125;
</code></pre>
<p>通过DisplayContent来配置图层结构</p>
<h2 id="DisplayAreaPolicy初始化"><a href="#DisplayAreaPolicy初始化" class="headerlink" title="DisplayAreaPolicy初始化"></a>DisplayAreaPolicy初始化</h2><p>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicy.java</p>
<pre><code>mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
        mWmService, this /* content */, this /* root */,
        mImeWindowsContainer)
</code></pre>
<p>调用DisplayAreaPolicy中的Provider接口instantiate方法，去初始化一个DisplayArea层级结构<br><strong>记住这边传递的参数，后面代码需要结合起来看</strong></p>
<h3 id="DisplayAreaPolicy-Provider"><a href="#DisplayAreaPolicy-Provider" class="headerlink" title="DisplayAreaPolicy.Provider"></a>DisplayAreaPolicy.Provider</h3><pre><code>    /**
     * Provider for &#123;@link DisplayAreaPolicy&#125; instances.
     *
     * &lt;p&gt;By implementing this interface and overriding the
     * &#123;@code config_deviceSpecificDisplayAreaPolicyProvider&#125;, a device-specific implementations
     * of &#123;@link DisplayAreaPolicy&#125; can be supplied.
     */
    public interface Provider &#123;
        /**
         * Instantiates a new &#123;@link DisplayAreaPolicy&#125;. It should set up the &#123;@link DisplayArea&#125;
         * hierarchy.
         *
         * @see DisplayAreaPolicy#DisplayAreaPolicy
         */
        DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content,
                RootDisplayArea root, DisplayArea.Tokens imeContainer);
</code></pre>
<p>用来实例化一个DisplayAreaPolicy对象，这个对象应该建立起DisplayArea层级结构，实际走到的则是DisplayAreaPolicy.Provider的实现类DisplayAreaPolicy.DefaultProvider.instantiate方法</p>
<h3 id="DisplayAreaPolicy-DefaultProvider"><a href="#DisplayAreaPolicy-DefaultProvider" class="headerlink" title="DisplayAreaPolicy.DefaultProvider"></a>DisplayAreaPolicy.DefaultProvider</h3><pre><code> /** Provider for platform-default display area policy. */
    static final class DefaultProvider implements DisplayAreaPolicy.Provider &#123;
        @Override
        public DisplayAreaPolicy instantiate(WindowManagerService wmService,
                DisplayContent content, RootDisplayArea root,
                DisplayArea.Tokens imeContainer) &#123;
             //1.创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中
            final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                    &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
            final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();
            tdaList.add(defaultTaskDisplayArea);

            // Define the features that will be supported under the root of the whole logical
            // display. The policy will build the DisplayArea hierarchy based on this.
            //2.创建HierarchyBuilder
            final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
            // Set the essential containers (even if the display doesn&#39;t support IME).
            //3.1添加ImeContainer到HierarchyBuilder
            //3.2创建并保存默认TaskDisplayArea到HierarchyBuilder
            rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
            if (content.isTrusted()) &#123;
                // Only trusted display can have system decorations.
                //4.为HierarchyBuilder添加Feature
                configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
            &#125;

            // Instantiate the policy with the hierarchy defined above. This will create and attach
            // all the necessary DisplayAreas to the root.
            //5.生成DisplayArea层级结构
            return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
        &#125;
</code></pre>
<p>我们先了解下DisplayArea.Tokens的构造方法</p>
<pre><code>        Tokens(WindowManagerService wms, Type type, String name) &#123;
            this(wms, type, name, FEATURE_WINDOW_TOKENS);
        &#125;
</code></pre>
<p><strong>FEATURE_WINDOW_TOKENS，容纳非activity窗口的DisplayArea，dump中对应着ImeContainer、WindowToken等</strong><br>这里DefaultProvider实现了这个接口。<br>这个方法主要干了这几件事情：</p>
<h4 id="1-初始化TaskDisplayArea"><a href="#1-初始化TaskDisplayArea" class="headerlink" title="1.初始化TaskDisplayArea"></a>1.初始化TaskDisplayArea</h4><pre><code>final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
        &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();
tdaList.add(defaultTaskDisplayArea);
</code></pre>
<p><strong>FEATURE_DEFAULT_TASK_CONTAINER，容纳默认Task容器的DisplayArea，dump中正是以“DefaultTaskDisplayArea”命名</strong><br>创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中</p>
<h4 id="2-创建HierarchyBuilder"><a href="#2-创建HierarchyBuilder" class="headerlink" title="2.创建HierarchyBuilder"></a>2.创建HierarchyBuilder</h4><pre><code>final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
</code></pre>
<p>HierarchyBuilder是什么？是用来定义在整个逻辑显示的根里面所需的一些Feature<br>HierarchyBuilder是在DisplayAreaPolicyBuilder中定义的<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>    /**
     *  Builder to define &#123;@link Feature&#125; and &#123;@link DisplayArea&#125; hierarchy under a
     * &#123;@link RootDisplayArea&#125;
     */
    static class HierarchyBuilder &#123;
        private static final int LEAF_TYPE_TASK_CONTAINERS = 1;
        private static final int LEAF_TYPE_IME_CONTAINERS = 2;
        private static final int LEAF_TYPE_TOKENS = 0;

        private final RootDisplayArea mRoot;
        private final ArrayList&lt;DisplayAreaPolicyBuilder.Feature&gt; mFeatures = new ArrayList&lt;&gt;();
        private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;();
        @Nullable
        private DisplayArea.Tokens mImeContainer;

        HierarchyBuilder(RootDisplayArea root) &#123;
            mRoot = root;
        &#125;
        ......
    &#125;
</code></pre>
<p>从代码中我们可以看出，HierarchyBuilder用来构建一个DisplayArea层级结构，该层级结构的根节点<br>其构造方法<code>HierarchyBuilder(RootDisplayArea root)</code>传入的是RootDisplayArea的对象。<br>结合前面的<code>configureSurfaces</code>方法中我们可以发现传入的是DisplayContent，即HierarchyBuilder以DisplayContent对象为根节点，生成一个DisplayArea层级结构。</p>
<h4 id="3-1添加ImeContainer到HierarchyBuilder"><a href="#3-1添加ImeContainer到HierarchyBuilder" class="headerlink" title="3.1添加ImeContainer到HierarchyBuilder"></a>3.1添加ImeContainer到HierarchyBuilder</h4><pre><code>rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
</code></pre>
<p>我们先看<code>setImeContainer(imeContainer)</code>部分。其中参数imeContainer是DisplayArea.Tokens的对象。</p>
<p>在DisplayContent中DisplayAreaPolicy初始化时，传递了一个<strong>mImeWindowsContainer</strong>对应我们这里的<strong>imeContainer</strong>形参，其是在DisplayContent中定义并初始化的<br>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    // Contains all IME window containers. Note that the z-ordering of the IME windows will depend
    // on the IME target. We mainly have this container grouping so we can keep track of all the IME
    // window containers together and move them in-sync if/when needed. We use a subclass of
    // WindowContainer which is omitted from screen magnification, as the IME is never magnified.
    // TODO(display-area): is &quot;no magnification&quot; in the comment still true?
    private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
</code></pre>
<p>ImeContainer就是输入法的容器，其继承在DisplayContent中DisplayArea.Tokens</p>
<pre><code>    /**
     * Container for IME windows.
     *
     * This has some special behaviors:
     * - layers assignment is ignored except if setNeedsLayer() has been called before (and no
     *   layer has been assigned since), to facilitate assigning the layer from the IME target, or
     *   fall back if there is no target.
     * - the container doesn&#39;t always participate in window traversal, according to
     *   &#123;@link #skipImeWindowsDuringTraversal()&#125;
     */
    private static class ImeContainer extends DisplayArea.Tokens &#123;
</code></pre>
<p>HierarchyBuilder的setImeContainer方法<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>        private DisplayArea.Tokens mImeContainer;
        
        /** Sets IME container as a child of this hierarchy root. */
        HierarchyBuilder setImeContainer(DisplayArea.Tokens imeContainer) &#123;
            mImeContainer = imeContainer;
            return this;
        &#125;
</code></pre>
<p>从代码中可以看出，就是将<strong>DisplayContent的mImeWindowsContainer</strong>保存到了<strong>HierarchyBuilder的mImeContainer</strong>成员变量中，后续创建DisplayArea层级结构时可以直接拿来使用。</p>
<h4 id="3-2添加TaskDisplayArea到HierarchyBuilder"><a href="#3-2添加TaskDisplayArea到HierarchyBuilder" class="headerlink" title="3.2添加TaskDisplayArea到HierarchyBuilder"></a>3.2添加TaskDisplayArea到HierarchyBuilder</h4><pre><code>rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
</code></pre>
<p>这里我们看<code>setTaskDisplayAreas(tdaList)</code>部分，第一步【1.初始化TaskDisplayArea】的时候，就已经把名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到tdaList中，</p>
<pre><code>        private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;();

       /**
         * Sets &#123;@link TaskDisplayArea&#125; that are children of this hierarchy root.
         * &#123;@link DisplayArea&#125; group must have at least one &#123;@link TaskDisplayArea&#125;.
         */
        HierarchyBuilder setTaskDisplayAreas(List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;
            mTaskDisplayAreas.clear();
            mTaskDisplayAreas.addAll(taskDisplayAreas);
            return this;
        &#125;
</code></pre>
<p>虽然TaskDisplayArea是支持嵌套的，并且这里也采用了一个ArrayList来管理TaskDisplayArea，但是目前TaskDisplayArea只在这里被创建，即目前一个DisplayContent只有一个名为“DefaultTaskDisplayArea”的TaskDisplayArea。从dumpsys activity containers 中我们也可以看到,整个文件也只有一个“DefaultTaskDisplayArea”</p>
<h4 id="4-为HierarchyBuilder添加Feature"><a href="#4-为HierarchyBuilder添加Feature" class="headerlink" title="4.为HierarchyBuilder添加Feature"></a>4.为HierarchyBuilder添加Feature</h4><pre><code>// Only trusted display can have system decorations.
configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
</code></pre>
<p><code>configureTrustedHierarchyBuilder</code>这个方法就在DisplayAreaPolicy.DefaultProvider内部</p>
<pre><code>private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
                WindowManagerService wmService, DisplayContent content) &#123;
            // WindowedMagnification should be on the top so that there is only one surface
            // to be magnified.
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                    FEATURE_WINDOWED_MAGNIFICATION)
                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                    // Make the DA dimmable so that the magnify window also mirrors the dim layer.
                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                    .build());
            if (content.isDefaultDisplay) &#123;
                // Only default display can have cutout.
                // See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked.
                rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                        FEATURE_HIDE_DISPLAY_CUTOUT)
                        .all()
                        .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                                TYPE_NOTIFICATION_SHADE)
                        .build())
                        .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                                FEATURE_ONE_HANDED)
                                .all()
                                .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                        TYPE_SECURE_SYSTEM_OVERLAY)
                                .build());
            &#125;
            rootHierarchy
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                            FEATURE_FULLSCREEN_MAGNIFICATION)
                            .all()
                            .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                    TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                    TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                            .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                            FEATURE_IME_PLACEHOLDER)
                            .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                            .build());
        &#125;
    &#125;
</code></pre>
<p>从代码中可以看到五大的Feature：WindowedMagnification、HideDisplayCutout、OneHanded、FullscreenMagnification、ImePlaceholder，这些Feature其实也就是我们在dumpsys中看到那些，还有一些关键方法all()、and()、except()、upto()、build()等<br>在我们正式开始聊这个几个Feature添加之前，我们先来看看，Feature是怎么定义的</p>
<h5 id="4-1-Feature的定义"><a href="#4-1-Feature的定义" class="headerlink" title="4.1 Feature的定义"></a>4.1 Feature的定义</h5><p>从HierarchyBuilder的addFeature方法跟踪发现，Feature是在DisplayAreaPolicyBuilder中定义的</p>
<pre><code>        HierarchyBuilder addFeature(DisplayAreaPolicyBuilder.Feature feature) &#123;
            mFeatures.add(feature);
            return this;
        &#125;
</code></pre>
<p>Feature的定义<br>代码路径&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>    /**
     * A feature that requires &#123;@link DisplayArea DisplayArea(s)&#125;.
     */
    static class Feature &#123;
        private final String mName;
        private final int mId;
        private final boolean[] mWindowLayers;
        private final NewDisplayAreaSupplier mNewDisplayAreaSupplier;

        private Feature(String name, int id, boolean[] windowLayers,
                NewDisplayAreaSupplier newDisplayAreaSupplier) &#123;
            mName = name;
            mId = id;
            mWindowLayers = windowLayers;
            mNewDisplayAreaSupplier = newDisplayAreaSupplier;
        &#125;
        ......
    &#125;
</code></pre>
<p>首先Feature代表的是DisplayArea的一个特征，可以根据Feature来对不同的DisplayArea进行划分。</p>
<ul>
<li>mName：这个Feature的名字，如上面的“WindowedMagnification”，“HideDisplayCutout”之类的，后续DisplayArea层级结构建立起来后，每个DisplayArea的名字用的就是当前DisplayArea对应的那个Feature的名字。</li>
<li>mId：Feature的ID，如上面的FEATURE_WINDOWED_MAGNIFICATION和FEATURE_HIDE_DISPLAY_CUTOUT，虽说是Feature的ID，因为Feature又是DisplayArea的特征</li>
<li>mWindowLayers：代表了这个DisplayArea可以包含哪些层级对应的窗口</li>
<li>mNewDisplayAreaSupplier：只是一个接口，内部定义一个create方法。</li>
</ul>
<p>关键是其Feature内部定义Builder类以及其build()方法</p>
<h6 id="Feature-Builder和Feature-Builder-build"><a href="#Feature-Builder和Feature-Builder-build" class="headerlink" title="Feature.Builder和Feature.Builder.build()"></a>Feature.Builder和Feature.Builder.build()</h6><pre><code>static class Builder &#123;
            private final WindowManagerPolicy mPolicy;
            private final String mName;
            private final int mId;
            private final boolean[] mLayers;
            private NewDisplayAreaSupplier mNewDisplayAreaSupplier = DisplayArea::new;
            private boolean mExcludeRoundedCorner = true;

            /**
             * Builds a new feature that applies to a set of window types as specified by the
             * builder methods.
             *
             * &lt;p&gt;The set of types is updated iteratively in the order of the method invocations.
             * For example, &#123;@code all().except(TYPE_STATUS_BAR)&#125; expresses that a feature should
             * apply to all types except TYPE_STATUS_BAR.
             *
             * &lt;p&gt;The builder starts out with the feature not applying to any types.
             *
             * @param name the name of the feature.
             * @param id of the feature. &#123;@see Feature#getId&#125;
             */
            Builder(WindowManagerPolicy policy, String name, int id) &#123;
                mPolicy = policy;
                mName = name;
                mId = id;
                mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1];
            &#125;
            ......
            Feature build() &#123;
                if (mExcludeRoundedCorner) &#123;
                    // Always put the rounded corner layer to the top most layer.
                    mLayers[mPolicy.getMaxWindowLayer()] = false;
                &#125;
                return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);
            &#125;
</code></pre>
<p>通过一套适用于具体的窗口类型构建方法来构建新Feature<br>其中<code>mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1];</code> mPolicy.getMaxWindowLayer()返回的是窗口最大层数。</p>
<pre><code>    /**
     * Returns the max window layer.
     * &lt;p&gt;Note that the max window layer should be higher that the maximum value which reported
     * by &#123;@link #getWindowLayerFromTypeLw(int, boolean)&#125; to contain rounded corner overlay.&lt;/p&gt;
     *
     * @see WindowManager.LayoutParams#PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY
     */
    default int getMaxWindowLayer() &#123;
        return 36;
    &#125;
</code></pre>
<p>1.代码中最大层数是36，这里+1，则也就是<code>mLayers = new boolean[37]</code>，即窗口层级区间为<code>[0,36]</code><br>2.在看看<code>build()</code>方法中的 <code>mLayers[mPolicy.getMaxWindowLayer()] = false;</code>，则表示<code>mLayers[36]</code> &#x3D; false，即第36层在build时会置为false（注：mExcludeRoundedCorner这个变量的值一直是true，没有改动）<br>3.<code>return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);</code><br>其中<strong>mLayers</strong>对应的就是<strong>Feature中的mWindowLayers</strong>，即<code>mLayers.clone()</code>就是把<strong>Feature.mWindowLayer</strong>的值复制给<strong>Feature.Builder.mLayer</strong>。</p>
<p>下面我们来说说构建Feature的关键星魂</p>
<h5 id="4-2-构建Feature的核心方法"><a href="#4-2-构建Feature的核心方法" class="headerlink" title="4.2 构建Feature的核心方法"></a>4.2 构建Feature的核心方法</h5><p>以下代码均在DisplayAreaPolicyBuilder.Feature.Builder中</p>
<h6 id="Feature-Builder第一星魂：all"><a href="#Feature-Builder第一星魂：all" class="headerlink" title="Feature.Builder第一星魂：all()"></a>Feature.Builder第一星魂：all()</h6><pre><code>        /**
         * Set that the feature applies to all window types.
         */
        Builder all() &#123;
            Arrays.fill(mLayers, true);
            return this;
        &#125;
</code></pre>
<p>将mLayers数组中的所有元素都设置为true，表示当前DisplayArea可以包含所有类型的窗口。<br><strong>简述，all()就是把所有类型窗口置为true（添加）</strong></p>
<h6 id="Feature-Builder第二星魂：and"><a href="#Feature-Builder第二星魂：and" class="headerlink" title="Feature.Builder第二星魂：and()"></a>Feature.Builder第二星魂：and()</h6><pre><code>        /**
         * Set that the feature applies to the given window types.
         */
        Builder and(int... types) &#123;
            for (int i = 0; i &lt; types.length; i++) &#123;
                int type = types[i];
                set(type, true);
            &#125;
            return this;
        &#125;
</code></pre>
<p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为true，表示该DisplayArea可以包含传入的窗口类型对应的窗口。<br><strong>简述，and就是把你传入的所有参数（窗口类型）置为true（添加）</strong></p>
<h6 id="Feature-Builder第三星魂：except"><a href="#Feature-Builder第三星魂：except" class="headerlink" title="Feature.Builder第三星魂：except()"></a>Feature.Builder第三星魂：except()</h6><pre><code>        /**
         * Set that the feature does not apply to the given window types.
         */
        Builder except(int... types) &#123;
            for (int i = 0; i &lt; types.length; i++) &#123;
                int type = types[i];
                set(type, false);
            &#125;
            return this;
        &#125;
</code></pre>
<p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为false，表示该DisplayArea不再包含传入的窗口类型对应的窗口。<br><strong>简述，except就是你传入的所有参数（窗口类型）置为false（不添加）</strong></p>
<h6 id="Feature-Builder第四星魂（必点）：upTo"><a href="#Feature-Builder第四星魂（必点）：upTo" class="headerlink" title="Feature.Builder第四星魂（必点）：upTo()"></a>Feature.Builder第四星魂（必点）：upTo()</h6><pre><code>        /**
         * Set that the feature applies window types that are layerd at or below the layer of
         * the given window type.
         */
        Builder upTo(int typeInclusive) &#123;
            final int max = layerFromType(typeInclusive, false);
            for (int i = 0; i &lt; max; i++) &#123;
                mLayers[i] = true;
            &#125;
            set(typeInclusive, true);
            return this;
        &#125;
</code></pre>
<p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的的元素之前的所有元素（包含该元素）设置为true，表示当前DisplayArea可以包含比传入的窗口类型层级值低的所有窗口。<br><strong>简述，upTo把就是[0,typeInclusive]区间内的所有类型窗口置为true（添加）。</strong><br>其中layerFromType方法非常重要，我们一起看看</p>
<pre><code>            private int layerFromType(int type, boolean internalWindows) &#123;
                return mPolicy.getWindowLayerFromTypeLw(type, internalWindows);
            &#125;
</code></pre>
<p>调用的了WindowManagerPolicy.getWindowLayerFromTypeLw方法</p>
<h6 id="WindowManagerPolicy-getWindowLayerFromTypeLw"><a href="#WindowManagerPolicy-getWindowLayerFromTypeLw" class="headerlink" title="WindowManagerPolicy.getWindowLayerFromTypeLw"></a>WindowManagerPolicy.getWindowLayerFromTypeLw</h6><pre><code>  /**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.
     */
    default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;
        return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow,
                false /* roundedCornerOverlay */);
    &#125;

    /**
     * Returns the layer assignment for the window type. Allows you to control how different
     * kinds of windows are ordered on-screen.
     *
     * @param type The type of window being assigned.
     * @param canAddInternalSystemWindow If the owner window associated with the type we are
     *        evaluating can add internal system windows. I.e they have
     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window
     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;
     *        can be assigned layers greater than the layer for
     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their
     *        layers would be lesser.
     * @param roundedCornerOverlay 
</code></pre>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/1.窗口层级 _容器类" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/">WMSAMS</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> 窗口在App端是以PhoneWindow的形式存在，承载了一个Activity的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=View%E5%B1%82&spm=1001.2101.3001.7020">View层</a>级结构。这里我们探讨一下WMS端窗口的形式。<br>可以通过<code>adb shell dumpsys activity containers</code> 来看窗口显示的层级</p>
<h2 id="窗口容器类-——-WindowContainer类"><a href="#窗口容器类-——-WindowContainer类" class="headerlink" title="窗口容器类 —— WindowContainer类"></a>窗口容器类 —— WindowContainer类</h2><pre><code>/**
 * Defines common functionality for classes that can hold windows directly or through their
 * children in a hierarchy form.
 * The test class is &#123;@link WindowContainerTests&#125; which must be kept up-to-date and ran anytime
 * changes are made to this class.
 */
class WindowContainer&lt;E extends WindowContainer&gt; extends ConfigurationContainer&lt;E&gt;
        implements Comparable&lt;WindowContainer&gt;, Animatable, SurfaceFreezer.Freezable,
        InsetsControlTarget &#123;
    ......
         /**
     * The parent of this window container.
     * For removing or setting new parent &#123;@link #setParent&#125; should be used, because it also
     * performs configuration updates based on new parent&#39;s settings.
     */
    private WindowContainer&lt;WindowContainer&gt; mParent = null;
    ......
    // List of children for this window container. List is in z-order as the children appear on
    // screen with the top-most window container at the tail of the list.
    protected final WindowList&lt;E&gt; mChildren = new WindowList&lt;E&gt;();
</code></pre>
<p>WindowContainer注释中开头就说明了其作用，即给可以直接持有窗口的自己或它的孩子定义了一些公共的方法和属性。<br>WindowContainer定义了能够直接或者间接以层级结构的形式持有窗口的类的通用功能。<br>从类的定义和名称，可以看到WindowContainer是一个容器类，可以容纳WindowContainer及其子类对象。如果另外一个容器类作为WindowState的容器，那么这个容器类需要继承WindowContainer或其子类。</p>
<p>其中mParent和mChildren，一个代表父节点一个代表子节点，而且子节点的list顺序代表就是z轴的层级显示顺序，list尾巴在比list的头的z轴层级要高。<br>1）mParent是WindowContainer类型成员变量，保存的是当前WindowContainer的父容器的引用。<br>2）mChildren是WindowList类型的成员变量，保存的则是当前WindowContainer持有的所有子容器。并且列表的顺序也就是子容器出现在屏幕上的顺序，最顶层的子容器位于队尾。</p>
<h2 id="根窗口容器-——-RootWindowContainer"><a href="#根窗口容器-——-RootWindowContainer" class="headerlink" title="根窗口容器 —— RootWindowContainer"></a>根窗口容器 —— RootWindowContainer</h2><pre><code>/** Root &#123;@link WindowContainer&#125; for the device. */
public class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt;
</code></pre>
<p>根窗口容器，树的根是它。通过它遍历寻找，可以找到窗口树上的窗口。它的孩子是DisplayContent。</p>
<h2 id="屏幕-——-DisplayContent"><a href="#屏幕-——-DisplayContent" class="headerlink" title="屏幕 —— DisplayContent"></a>屏幕 —— DisplayContent</h2><pre><code>/**
 * Utility class for keeping track of the WindowStates and other pertinent contents of a
 * particular Display.
 */
class DisplayContent extends RootDisplayArea implements WindowManagerPolicy.DisplayContentInfo &#123;
</code></pre>
<p>该类是对应着显示屏幕的，Android是支持多屏幕的，所以可能存在多个DisplayContent对象。上图只画了一个对象的结构，其他对象的结构也是和画的对象的结构是相似的。</p>
<hr>
<p>RootWindowContainer代表dumpsys containers中<code>ROOT</code> ，DisplayContentdumpsys containers中<code>Display</code>，0表示当前显示的屏幕<br><img src="/../../../../../images/00ddc5bdfa14495ab9c20a27c55b16d0.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="窗口-——-WindowState类"><a href="#窗口-——-WindowState类" class="headerlink" title="窗口 —— WindowState类"></a>窗口 —— WindowState类</h2><pre><code>/** A window in the window manager. */
class WindowState extends WindowContainer&lt;WindowState&gt; implements WindowManagerPolicy.WindowState,
        InsetsControlTarget, InputTarget &#123;
</code></pre>
<p>在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=WMS&spm=1001.2101.3001.7020">WMS</a>窗口体系中，<strong>一个WindowState对象就代表了一个窗口</strong>，其继承WindowContainer，这就说明<strong>WindowState同样可以作为其他窗口的父容器</strong>，例如我们常见的PopupWindow<br><img src="/../../../../../images/5c82982f2b99427db095ee1ec5f3ccac.png" alt="在这里插入图片描述"></p>
<h2 id="WindowState的容器"><a href="#WindowState的容器" class="headerlink" title="WindowState的容器"></a>WindowState的容器</h2><p>可直接持有WindowState的容器即WindowToken和ActivityRecord，WallpaperWindowToken也可以持有WindowState，而其是继承WindowToken的</p>
<h3 id="WindowToken类"><a href="#WindowToken类" class="headerlink" title="WindowToken类"></a>WindowToken类</h3><pre><code>/**
 * Container of a set of related windows in the window manager. Often this is an AppWindowToken,
 * which is the handle for an Activity that it uses to display windows. For nested windows, there is
 * a WindowToken created for the parent window to manage its children.
 */
class WindowToken extends WindowContainer&lt;WindowState&gt; &#123;
</code></pre>
<p>这个注释的意思大概是说：窗口管理器中一组相关窗口的容器。这通常是一个AppWindowToken，它是用于显示窗口的“活动”的句柄。对于嵌套窗口，会为父窗口创建一个WindowToken来管理其子窗口。<br>总而言之就是用WindowToken来管理WindowState<br><img src="/../../../../../images/6d37fa0437ed4007824c795d34425adf.png" alt="在这里插入图片描述"></p>
<h3 id="WallpaperWindowToken类"><a href="#WallpaperWindowToken类" class="headerlink" title="WallpaperWindowToken类"></a>WallpaperWindowToken类</h3><pre><code>/**
 * A token that represents a set of wallpaper windows.
 */
class WallpaperWindowToken extends WindowToken &#123;
</code></pre>
<p>WallpaperWindowToken继承WindowToken，是用来存放和Wallpaper相关的窗口。<br><img src="/../../../../../images/d149ce4f628f4a1daef28b9fa64d2c47.png" alt="在这里插入图片描述"></p>
<h3 id="ActivityRecord类"><a href="#ActivityRecord类" class="headerlink" title="ActivityRecord类"></a>ActivityRecord类</h3><pre><code>/**
 * An entry in the history task, representing an activity.
 */
public final class ActivityRecord extends WindowToken implements WindowManagerService.AppFreezeListener &#123;
</code></pre>
<p>ActivityRecord是WindowToken的子类，在WMS中<strong>一个ActivityRecord对象就代表一个Activity对象</strong>。</p>
<p><img src="/../../../../../images/34b57f50600048a09e562f6a1f6a5c64.png" alt="在这里插入图片描述"></p>
<hr>
<p>一般来说，一个窗口的父容器是WindowToken还是ActivityRecord，是否主动使用ViewManager.addView来添加一个窗口<br>父容器为WindowToken的情况：APP（含系统应用）主动调用添加窗口方法来添加窗口，如StatusBar、浮窗等。即非Activity窗口<br>父容器为ActivityRecord的情况：系统侧调用添加窗口方法来添加窗口，如在桌面启动一个应用等。即Activity窗口</p>
<p>从层级角度将窗口划分为：<br>App之上的窗口，父容器为WindowToken，如StatusBar和NavigationBar。<br>App窗口，父容器为ActivityRecord，如Launcher。<br>App之下的窗口，父容器为WallpaperWindowToken，如ImageWallpaper窗口</p>
<hr>
<h2 id="WindowToken的容器-——-DisplayArea-Tokens"><a href="#WindowToken的容器-——-DisplayArea-Tokens" class="headerlink" title="WindowToken的容器 —— DisplayArea.Tokens"></a>WindowToken的容器 —— DisplayArea.Tokens</h2><pre><code>    /**
     * DisplayArea that contains WindowTokens, and orders them according to their type.
     */
    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;
</code></pre>
<p>包含WindowTokens的容器Tokens，并根据其类型对其进行排序。</p>
<h2 id="ActivityRecord的容器-——-Task"><a href="#ActivityRecord的容器-——-Task" class="headerlink" title="ActivityRecord的容器 —— Task"></a>ActivityRecord的容器 —— Task</h2><pre><code>/**
 * &#123;@link Task&#125; is a TaskFragment that can contain a group of activities to perform a certain job.
 * Activities of the same task affinities usually group in the same &#123;@link Task&#125;. A &#123;@link Task&#125;
 * can also be an entity that showing in the Recents Screen for a job that user interacted with.
 * A &#123;@link Task&#125; can also contain other &#123;@link Task&#125;s.
 */
class Task extends TaskFragment &#123;
</code></pre>
<p>Task继承TaskFragment，<strong>它的孩子可以是Task，也可以是ActivityRecord类型</strong>。是一个TaskFragment，它可以包含一组执行特定作业的Activity。具有相同任务相似性的Activity通常在同一任务中分组。任务也可以是显示在用户交互的作业的最近屏幕中的实体。任务还可以包含其他任务。</p>
<pre><code>/**
 * A basic container that can be used to contain activities or other &#123;@link TaskFragment&#125;, which
 * also able to manage the activity lifecycle and updates the visibilities of the activities in it.
 */
class TaskFragment extends WindowContainer&lt;WindowContainer&gt; &#123;
</code></pre>
<p>一个基本容器，可用于包含Activity或其他TaskFragment，它还能够管理Activity生命周期并更新其中活动的可见性。</p>
<h2 id="Task的容器-——-TaskDisplayArea"><a href="#Task的容器-——-TaskDisplayArea" class="headerlink" title="Task的容器 —— TaskDisplayArea"></a>Task的容器 —— TaskDisplayArea</h2><pre><code>/**
 * &#123;@link DisplayArea&#125; that represents a section of a screen that contains app window containers.
 *
 * The children can be either &#123;@link Task&#125; or &#123;@link TaskDisplayArea&#125;.
 */
final class TaskDisplayArea extends DisplayArea&lt;WindowContainer&gt; &#123;
</code></pre>
<p>TaskDisplayArea，代表了屏幕上一块专门用来存放App窗口的区域。<br>它的子容器可能是Task或者是TaskDisplayArea。</p>
<hr>
<p><img src="/../../../../../images/0436a0559b31465ab39915cd84880d30.png" alt="在这里插入图片描述">DefaultTaskDisplay是TaskDisplayArea的别名，在代码中有体现，后面说明<br>从这个dump中我们可以看到TaskDisplayArea下面就是Task，Task下面就是ActivityRecord且有多个，而ActivityRecord下面的a9a1d8b和c4b2818是各自的WindowState</p>
<hr>
<h2 id="DisplayArea类"><a href="#DisplayArea类" class="headerlink" title="DisplayArea类"></a>DisplayArea类</h2><pre><code>/**
 * Container for grouping WindowContainer below DisplayContent.
 *
 * DisplayAreas are managed by a &#123;@link DisplayAreaPolicy&#125;, and can override configurations and
 * can be leashed.
 *
 * DisplayAreas can contain nested DisplayAreas.
 *
 * DisplayAreas come in three flavors, to ensure that windows have the right Z-Order:
 * - BELOW_TASKS: Can only contain BELOW_TASK DisplayAreas and WindowTokens that go below tasks.
 * - ABOVE_TASKS: Can only contain ABOVE_TASK DisplayAreas and WindowTokens that go above tasks.
 * - ANY: Can contain any kind of DisplayArea, and any kind of WindowToken or the Task container.
 *
 * @param &lt;T&gt; type of the children of the DisplayArea.
 */
public class DisplayArea&lt;T extends WindowContainer&gt; extends WindowContainer&lt;T&gt; &#123;
</code></pre>
<p>用于将WindowContainer分组到DisplayContent下方的容器。<br>DisplayArea由｛@link DisplayAreaPolicy｝管理，能够复写<strong>Configuration</strong>和被绑定到<strong>leash</strong>上。<br>DisplayArea可以包含嵌套的DisplayArea。<br>DisplayAreas有三种风格，以确保窗口具有正确的Z顺序：</p>
<ul>
<li>BELOW_TASKS:只能包含位于任务下方的BELLOW_TASK显示区域和WindowToken。</li>
<li>ABOVE_TASKS:只能包含位于任务上方的ABOVE_TASK显示区域和WindowToken。</li>
<li>ANY：可以包含任何类型的DisplayArea，以及任何类型的WindowToken或Task容器。</li>
</ul>
<p>@param＜T＞DisplayArea的子项的类型。</p>
<p>DisplayArea有三个直接子类，TaskDisplayArea，DisplayArea.Tokens和DisplayArea.Tokens</p>
<h3 id="Task的容器-——-TaskDisplayArea-1"><a href="#Task的容器-——-TaskDisplayArea-1" class="headerlink" title="Task的容器 —— TaskDisplayArea"></a>Task的容器 —— TaskDisplayArea</h3><pre><code>/**
 * &#123;@link DisplayArea&#125; that represents a section of a screen that contains app window containers.
 *
 * The children can be either &#123;@link Task&#125; or &#123;@link TaskDisplayArea&#125;.
 */
final class TaskDisplayArea extends DisplayArea&lt;WindowContainer&gt; &#123;
</code></pre>
<p>TaskDisplayArea为DisplayContent的孩子，对应着窗口层次的第2层。第2层作为应用层，看它的定义：int APPLICATION_LAYER &#x3D; 2，应用层的窗口是处于第2层。<br>TaskDisplayArea代表了屏幕上的一个包含App类型的WindowContainer的区域。它的子节点可以是Task，或者是TaskDisplayArea。</p>
<pre><code>public DisplayAreaPolicy instantiate(WindowManagerService wmService,
                DisplayContent content, RootDisplayArea root,
                DisplayArea.Tokens imeContainer) &#123;
        Inject.ResultOne&lt;TaskDisplayArea&gt; result = new Inject.ResultOne&lt;&gt;(new TaskDisplayArea(content, wmService,
                    &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER));
</code></pre>
<p>在DisplayAreaPolicy.java中有创建，并更名为<strong>DefaultTaskDisplayArea</strong></p>
<h3 id="WindowTokens的容器-——-DisplayArea-Tokens"><a href="#WindowTokens的容器-——-DisplayArea-Tokens" class="headerlink" title="WindowTokens的容器 —— DisplayArea.Tokens"></a>WindowTokens的容器 —— DisplayArea.Tokens</h3><pre><code>    /**
     * DisplayArea that contains WindowTokens, and orders them according to their type.
     */
    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;
</code></pre>
<p>Tokens为DisplayArea的内部类，且继承DisplayArea。<br>即Tokens代表专门包含WindowTokens的容器，它的孩子是WindowToken，而WindowToken的孩子则为WindowState对象。WindowState是对应着一个窗口的。</p>
<h4 id="输入法的容器-——-ImeContainer"><a href="#输入法的容器-——-ImeContainer" class="headerlink" title="输入法的容器 —— ImeContainer"></a>输入法的容器 —— ImeContainer</h4><pre><code>    /**
     * Container for IME windows.
     *
     * This has some special behaviors:
     * - layers assignment is ignored except if setNeedsLayer() has been called before (and no
     *   layer has been assigned since), to facilitate assigning the layer from the IME target, or
     *   fall back if there is no target.
     * - the container doesn&#39;t always participate in window traversal, according to
     *   &#123;@link #skipImeWindowsDuringTraversal()&#125;
     */
    private static class ImeContainer extends DisplayArea.Tokens &#123;
</code></pre>
<p>ImeContainer为DisplayContent.java的内部类，且继承DisplayArea.Tokens，即同样是一个WindowToken的容器，它的孩子是WindowToken类型。WindowToken的孩子为WindowState类型，而WindowState类型则对应着输入法窗口。<br><img src="/../../../../../images/de8424323b554406b8f257566a8b5f5e.png" alt="在这里插入图片描述"></p>
<h3 id="模糊效果-——-DisplayArea-Dimmable"><a href="#模糊效果-——-DisplayArea-Dimmable" class="headerlink" title="模糊效果 —— DisplayArea.Dimmable"></a>模糊效果 —— DisplayArea.Dimmable</h3><pre><code>    /**
     * DisplayArea that can be dimmed.
     */
    static class Dimmable extends DisplayArea&lt;DisplayArea&gt; &#123;
        private final Dimmer mDimmer = new Dimmer(this);
</code></pre>
<p>Dimmable也是DisplayArea的内部类，从名字可以看出，这类的DisplayArea可以添加模糊效果，并且Dimmable也是一个DisplayArea类型的DisplayArea容器。<br>可以通过Dimmer对象mDimmer施加模糊效果，模糊图层可以插入到以该Dimmable对象为根节点的层级结构之下的任意两个图层之间。<br>且它有一个直接子类，RootDisplayArea。</p>
<h4 id="DisplayArea层级结构的根节点-——-RootDisplayArea"><a href="#DisplayArea层级结构的根节点-——-RootDisplayArea" class="headerlink" title="DisplayArea层级结构的根节点 —— RootDisplayArea"></a>DisplayArea层级结构的根节点 —— RootDisplayArea</h4><pre><code>/**
 * Root of a &#123;@link DisplayArea&#125; hierarchy. It can be either the &#123;@link DisplayContent&#125; as the root
 * of the whole logical display, or a &#123;@link DisplayAreaGroup&#125; as the root of a partition of the
 * logical display.
 */
class RootDisplayArea extends DisplayArea.Dimmable &#123;
</code></pre>
<p>｛@link DisplayArea｝层次结构的根。它可以是作为整个逻辑显示的根的{@link DisplayContent}，也可以是作为逻辑显示的分区的根的｛@link DisplayAreaGroup}。<br>即：<br>DisplayContent，作为整个屏幕的DisplayArea层级结构根节点。<br>DisplayAreaGroup，作为屏幕上部分区域对应的DisplayArea层级结构的根节点</p>
<h5 id="屏幕-——-DisplayContent-1"><a href="#屏幕-——-DisplayContent-1" class="headerlink" title="屏幕 —— DisplayContent"></a>屏幕 —— DisplayContent</h5><pre><code>/**
 * Utility class for keeping track of the WindowStates and other pertinent contents of a
 * particular Display.
 */
class DisplayContent extends RootDisplayArea implements WindowManagerPolicy.DisplayContentInfo &#123;
</code></pre>
<p>用于跟踪特定显示器的WindowStates和其他相关内容的实用程序类，总而言之就是代表一个屏幕。<br>隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每一个DisplayContent都对应着唯一ID</p>
<h5 id="DisplayAreaGroup"><a href="#DisplayAreaGroup" class="headerlink" title="DisplayAreaGroup"></a>DisplayAreaGroup</h5><pre><code>/** The root of a partition of the logical display. */
class DisplayAreaGroup extends RootDisplayArea &#123;
</code></pre>
<p>逻辑显示分区的根</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android Application/Android工具类/判断当前应用是否退到后台" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-Application/">Android Application</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android工具类</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp extends MultiDexApplication &#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    @Override</span><br><span class="line">     public void onCreate() &#123;</span><br><span class="line">     		 initActivityLifecycle();</span><br><span class="line">     &#125;</span><br><span class="line">      private void initActivityLifecycle() &#123;</span><br><span class="line">        registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityCreated(Activity activity, Bundle bundle) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStarted(Activity activity) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityResumed(Activity activity) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityPaused(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStopped(Activity activity) &#123;</span><br><span class="line">                if(count &gt; 0) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                boolean isBackground = isBackground();</span><br><span class="line">                Log.e(&quot;tyl&quot;,&quot;isBackground=&quot;+isBackground);</span><br><span class="line">                if(isBackground)&#123;</span><br><span class="line">                 //app已经切入到后台</span><br><span class="line">                    //System.exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivitySaveInstanceState(Activity activity, Bundle bundle) &#123;</span><br><span class="line">							</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityDestroyed(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 判断app是否在后台</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isBackground()&#123;</span><br><span class="line">        if(count &lt;= 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
        </nav>
    
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>