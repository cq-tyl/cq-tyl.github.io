<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>TYL</title>
    
    
        <meta name="keywords" content="TYL" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="4.WMS窗口相关流程一、介绍什么是窗口窗口即是屏幕上的一块用于绘制各种UI元素并可以响应用户输入的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。Window是个抽象类其实现类为PhoneWindow。本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。其他建议：可以先学习层级结构树相关内容，有助">
<meta property="og:type" content="article">
<meta property="og:title" content="TYL">
<meta property="og:url" content="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="4.WMS窗口相关流程一、介绍什么是窗口窗口即是屏幕上的一块用于绘制各种UI元素并可以响应用户输入的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。Window是个抽象类其实现类为PhoneWindow。本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。其他建议：可以先学习层级结构树相关内容，有助">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/9bac0587c3614e088e376a948ffb45cb.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/7817e0249e55462596f58e9a66e68ac9.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/f032b7cd5a8c470baec7a233a96571a1.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/5b2dfebaa2fa466bbc667e9140ea7150.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/72554e9137594c86972bb0cda59bae86.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/0251fd28a86a46fea1e29a81b2f55897.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/c9cf74cf9cbd45bfb3476c07e3f990b3.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/45182f6e931246bda89e986fff0005f6.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/aa5261464c984b56830d1931ec67e207.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/8d84cc58579d4e5cb0c2e924ce3f8afc.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/9e5c8036f3504e6f84c1a9f80070bdfa.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/a2c46436037a4a3da9af6fa7c12d1b47.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/cae5471da1f24847b7e954bd0827ad11.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/97725b2413d74debb25621deab0c5c62.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/ad8fdb698a23430a942bcfd773fcba80.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/e778248cfd7e4dd5a3fa856039013d62.png">
<meta property="og:image" content="https://cq_tyl.gitee.io/images/0b16f1c79359438783f3ed8e5f94ce84.png">
<meta property="article:published_time" content="2024-01-15T01:54:22.172Z">
<meta property="article:modified_time" content="2024-01-15T01:55:45.566Z">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cq_tyl.gitee.io/images/9bac0587c3614e088e376a948ffb45cb.png">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">Android事件分发</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/">Android自定义View</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file active"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ADB%E5%92%8CMonkey%E6%B5%8B%E8%AF%95/">ADB和Monkey测试</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/">0.jetpack合集</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.1.leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">3.1.leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.0.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96&ANR/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/">0.app性能优化集合</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/">MVC、MVP、MVVM架构</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  <li class="file"><a href="/wiki/C++/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            QT
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            我的简历
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E6%AD%A3%E5%BC%8F%E7%AE%80%E5%8E%86/"></a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">完整项目经历</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Android FrameWork/Framework源码分析/Android 13/WMSAMS/4.WMS窗口相关流程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <hr>
<h2 id="4-WMS窗口相关流程"><a href="#4-WMS窗口相关流程" class="headerlink" title="4.WMS窗口相关流程"></a>4.WMS窗口相关流程</h2><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>什么是窗口<br>窗口即是屏幕上的一块用于绘制各种UI元素并可以响应<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5&spm=1001.2101.3001.7020">用户输入</a>的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。<br>Window是个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&spm=1001.2101.3001.7020">抽象类</a>其实现类为PhoneWindow。<br>本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。<br>其他建议：可以先学习<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树相关内容，有助于对窗口模块的理解<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132174913">Android T 窗口层级其一 —— 容器类</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132213111">Android T 窗口层级其二 —— 层级结构树的构建</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/132722735">Android T 窗口层级其三 —— 层级结构树添加窗口</a></p>
<h2 id="二、流程简述"><a href="#二、流程简述" class="headerlink" title="二、流程简述"></a>二、流程简述</h2><p>当Activity.onResume()被调用之后，客户端会与WMS进行通信将我们的布局显示在屏幕上。其中主要涉及以下几个过程：<br>客户端通知WMS创建一个窗口，并添加到WindowToken。即addToDisplayAsUser阶段。<br>客户端通知WMS创建Surface，并计算窗口尺寸大小。即relayoutWindow阶段。<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度。即performMeasure阶段。<br>客户端确定该窗口下View的尺寸和位置。即performLayout阶段。<br>确定好View的尺寸大小位置之后，便对View进行绘制。即performDraw阶段。<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来。即reportDrawFinished阶段。<br><img src="/../../../../../images/9bac0587c3614e088e376a948ffb45cb.png" alt="在这里插入图片描述"><br>这里以Activity.onResume()被调用之后为起点</p>
<h3 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h3><p>WindowManager：是一个接口类，负责窗口的管理（增、删、改）。</p>
<p>WindowManagerImpl：WindowManager的实现类，但是他把对于窗口的具体管理操作交给WindowManagerGlobal来处理。</p>
<p>WindowManagerGlobal：是一个单例类，实现了窗口的添加、删除、更新的逻辑，但是</p>
<p>ViewRootImpl：通过IWindowSession与WMS进行通信。其内部类W实现了WMS与ViewRootImpl的通信。<br><img src="/../../../../../images/7817e0249e55462596f58e9a66e68ac9.png" alt="在这里插入图片描述"></p>
<p>ActivityThread.java</p>
<ul>
<li>handleResumeActivity<br>通过WindowManager接口添加view，即<code>wm.addView(decor, l);</code>，wm为ViewManager对象，即<code>ViewManager wm = a.getWindowManager();</code></li>
</ul>
<p>WindowManagerImpl.java</p>
<ul>
<li>addView<br><code>mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,mContext.getUserId());</code>mGlobal为WindowManagerGlobal对象。</li>
</ul>
<p>WindowManagerGlobal.java</p>
<ul>
<li>addView<br><code>root.setView(view, wparams, panelParentView, userId);</code>root为ViewRootImpl对象。<br><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>parentWindow为Window（Window为抽象类，PhoneWindow继承于Window），即在Window中调用adjustLayoutParamsForSubWindow，用于赋值参数布局的token以及title</li>
</ul>
<p>ViewRootImpl.java</p>
<ul>
<li>setView<br>1.addToDisplayAsUser<br>客户端通知WMS创建一个窗口，并添加到WindowToken<br><code>res = mWindowSession.addToDisplayAsUser(mWindow,mWindowAttributes,getHostVisibility(), mDisplay.getDisplayId(), userId,mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,mTempControls);</code><br>2.requestLayout<br>在添加到窗口管理器之前安排第一个布局，以确保我们在从系统接收任何其他事件之前进行重新布局<br>scheduleTraversals-&gt;doTraversal-&gt;performTraversals<br>performTraversals中调用了五个关键方法：<br>relayoutWindow<br>客户端通知WMS创建Surface，并计算窗口尺寸大小<br>performMeasure<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度<br>performLayout<br>客户端确定该窗口下View的尺寸和位置<br>performDraw<br>确定好View的尺寸大小位置之后，便对View进行绘制<br>createSyncIfNeeded-&gt;reportDrawFinished<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来</li>
</ul>
<h3 id="2-通信方式"><a href="#2-通信方式" class="headerlink" title="2. 通信方式"></a>2. 通信方式</h3><p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p>
<ul>
<li><p>IWindowSession.aidl<br>ViewRootImpl中通过此接口调用服务端<br>1.addToDisplayAsUser<br>2.relayout<br>3.finishDrawing</p>
</li>
<li><p>Session.java<br>IWindowSession的实现在这里，最终调用到WMS中<br>1.addToDisplayAsUser-&gt;addWindow<br>2.relayout-&gt;relayoutWindow<br>3.finishDrawing-&gt;finishDrawingWindow</p>
</li>
</ul>
<h3 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3. 服务端"></a>3. 服务端</h3><p>WindowManagerService：负责为Activity对应的窗口分配Surface，管理Surface的显示顺序以及位置尺寸，控制窗口动画，并且还是输入系统的一个重要中转站。</p>
<p>WindowState：和客户端窗口一一对应，在向WMS添加一个窗口时，WMS会为其创建一个WindowState，来表示窗口的所有属性，WindowState相当于属性窗口管理（比如对外提供操作接口，属于层级结构中最底部的容器），窗口画面相关都剥离给了WindowStateAnimator，WindowState也是WMS中事实上的窗口。</p>
<p>WindowStateAnimator：主要用于管理WindowState相关画面surface，通过mDrawState参数来描述Surface所处的状态。</p>
<p>WindowToken：保存了所有具有同一个token的WindowState，将属于同一个activity的窗口组织在一起，activity在需要更新窗口时，必须向WMS提供WindowToken以表名自己的身份，并且窗口的类型必须与所持有的的WindowToken类型一致。<br>补充：一个WindowToken可以对应多个WindowState。 WindowToken是一个用于表示窗口层次结构中的窗口的标识符。每个Window具有一个与之关联的WindowToken，它用于帮助系统管理窗口的显示和交互。<br>一个WindowToken可以有多个WindowState表示与之相关的窗口。这是因为在Android系统中，可能会存在一些特殊情况，例如PopupWindow、Dialog等，它们属于同一个WindowToken，但是显示在不同的窗口上。<br>因此，一个WindowToken可以与多个WindowState关联，这样可以实现多个窗口的操作和管理。</p>
<p>WindowSurfaceController：用来创建SurfaceControl。</p>
<p>DisplayContent：即代表的是单个屏幕。隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每个DisplayContent都对应着一个唯一的id，在添加窗口时可以通过指定这个ID决定将其显示在哪个屏幕中。</p>
<p>WindowSurfacePlacer：整个窗口层次结构刷新的入口。</p>
<p>RootWindowContainer：是窗口容器的顶层容器，其直接管理DisplayContent。</p>
<p><strong>WindowManagerService.java</strong></p>
<h4 id="3-1-addWindow"><a href="#3-1-addWindow" class="headerlink" title="3.1.addWindow"></a>3.1.addWindow</h4><p><img src="/../../../../../images/f032b7cd5a8c470baec7a233a96571a1.png" alt="在这里插入图片描述"><br>1.根据客户端传来的token获取WindowToken或创建WindowToken，并将其挂载到对应的层级节点上<br><code>WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);</code><br>判断WindowToken是否有父亲,即parentWindow 是否不为空<br><code>final boolean hasParent = parentWindow != null;</code><br>注：前面代码有判断是否是子窗口，是则会给parentWindow 赋值；否则parentWindow仍为初始值，即为空<br><img src="/../../../../../images/5b2dfebaa2fa466bbc667e9140ea7150.png" alt="在这里插入图片描述"><br>关于窗口类型，见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/130442487">窗口常见参数汇总</a><br>Activity启动时会在ActivityRecord的构造方法中new Token()。<br><strong>应用侧直接通过addView的方式添加窗口不会有ActivityRecord,因此不会在ActivityRecord的构造方法中new Token()。</strong><br><strong>系统侧直接添加的窗口（状态栏、导航栏等），是通过new WindowToken.Builder的方式添加</strong><br><strong>即主动使用ViewManager.addView来添加一个窗口则不会在ActivityRecord的构造方法中new Token()，否则通过new WindowToken.Builder的方式添加。</strong><br>attrs.token这个参数一可以在应用端设置，应用没有设置token那么就为空，token为IBinder类型对象，默认值为空<code>public IBinder token = null;</code><br>例如：<br>在应用侧可通过mLayoutParams.token的方式设置值<br><code>private WindowManager.LayoutParams mLayoutParams;</code><br><code>mLayoutParams.token = null;</code></p>
<p>后面会继续判断token是否为空,最终会到最后的else中创建token<br><img src="/../../../../../images/72554e9137594c86972bb0cda59bae86.png" alt="在这里插入图片描述"><br>2.创建WindowState<br><code>final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId,session.mCanAddInternalSystemWindow);</code><br>3.验证当前窗口是否可以添加到WMS<br><code>res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</code><br>该方法会对窗口TYPE,FLAG等多方面判断。只有返回ADD_OKAY时表示允许当前窗口的添加，反之则不允许添加该窗口。假如想禁止某些应用做添加窗口操作时，可以在里面通过应用的包名过滤该应用，也可以直接在WindowManagerGlobal.java的addView()方法中直接对应用想要添加的窗口进行过滤。<br>注：<code>ADD_OKAY</code>在WindowManagerGlobal中定义，这个类里面还有一些其他的返回值，所有返回给<code>res</code>的常量最终会在ViewRootImpl的setView方法中判断<br>4.调用openInputChannel，初始化input相关通路（本文不做讨论）<br><code>final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);</code><br><code>if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125;</code><br>5.将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WMS窗口添加之后，还没有创建Surface，此时mDrawState状态为NO_SURFACE</p>
<h4 id="3-2-relayoutWindow"><a href="#3-2-relayoutWindow" class="headerlink" title="3.2 relayoutWindow"></a>3.2 relayoutWindow</h4><p><img src="/../../../../../images/0251fd28a86a46fea1e29a81b2f55897.png" alt="在这里插入图片描述"><br>1.根据客户端传递过来的IWindow的mWindowMap获取窗口添加阶段创建的WindowState<br><code>final WindowState win = windowForClientLocked(session, client, false);</code><br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br><code>win.setDisplayLayoutNeeded();</code>win为WindowState对象，该方法实际操作在DisplayContent中<br><code>final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;(win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || win.mActivityRecord.isClientVisible());</code><br>3.创建SurfaceControl<br>在layoutWindow()调用了createSurfaceControl方法创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code>该方法的实现仍然在WMS中<br>这里以createSurfaceControl方法为起点<br><img src="/../../../../../images/c9cf74cf9cbd45bfb3476c07e3f990b3.png" alt="在这里插入图片描述"><br>在createSurfaceControl()中调用WindowStateAnimator执行具体的SurfaceControl的创建 <code>surfaceController = winAnimator.createSurfaceLocked();</code><br>创建Surface后，Surface还未进行绘制，此时mDrawState状态为DRAW_PENDING<br>将创建的SurfaceControl赋值给客户端的outSurfaceControl<br><code>surfaceController.getSurfaceControl(outSurfaceControl);</code><br>4.窗口尺寸的计算以及Surface状态更新<br>在layoutWindow()调用了performSurfacePlacement<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code>mWindowPlacerLocked为WindowSurfacePlacer对象，因此这里以WindowSurfacePlacer的performSurfacePlacement()为起点<br><img src="/../../../../../images/45182f6e931246bda89e986fff0005f6.png" alt="在这里插入图片描述"><br>处理窗口布局循环<br>WindowSurfacePlacer.performSurfacePlacementLoop()<br>处理Surface的状态更变，以及调用LayoutWindowLw的流程<br>RootWindowContainer.performSurfacePlacementNoTrace()<br>计算窗口位置大小<br>DisplayPolicy.layoutWindowLw()</p>
<h4 id="3-3-finishDrawingWindow"><a href="#3-3-finishDrawingWindow" class="headerlink" title="3.3 finishDrawingWindow"></a>3.3 finishDrawingWindow</h4><p><img src="/../../../../../images/aa5261464c984b56830d1931ec67e207.png" alt="在这里插入图片描述"><br><img src="/../../../../../images/8d84cc58579d4e5cb0c2e924ce3f8afc.png" alt="在这里插入图片描述"></p>
<p>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PEDING<code>win.finishDrawing(postDrawTransaction, seqId)</code>,并请求窗口布局<code>mWindowPlacerLocked.requestTraversal();</code><br>2.通过mApplySurfaceChangesTransaction的callback，</p>
<p><img src="/../../../../../images/9e5c8036f3504e6f84c1a9f80070bdfa.png" alt="在这里插入图片描述"><br>调用commitFinishDrawingLocked()<img src="/../../../../../images/a2c46436037a4a3da9af6fa7c12d1b47.png" alt="在这里插入图片描述"><br>改变mDrawState状态将mDrawState更新为READY_TO_SHOW,<br>最终mDrawState更新为HAS_DRAW后，再次请求窗口布局<br><img src="/../../../../../images/cae5471da1f24847b7e954bd0827ad11.png" alt="在这里插入图片描述"><br>3.执行show Surface<br><code>showSurfaceRobustlyLocked(t)</code><br>注：WindowStateAnimator的commitFinishDrawingLocked()方法中，如果是<strong>应用通过WindowManager中的addView的方式创建窗口，则不会有ActivityRecord</strong>，或者该窗口类型为启动窗口，则直接调用<code>result = mWin.performShowLocked();</code>，即WindowState的performShowLocked()方法改变窗口状态为HAS_DRAW，否则会从RootWindowContainer的checkAppTransitionReady方法逐步调用到performShowLocked()<br><img src="/../../../../../images/97725b2413d74debb25621deab0c5c62.png" alt="在这里插入图片描述"></p>
<h3 id="4-窗口状态变化总结"><a href="#4-窗口状态变化总结" class="headerlink" title="4.窗口状态变化总结"></a>4.窗口状态变化总结</h3><p>WMS为了管理窗口的显示进度，在WindowStateAnimator中定义了mDrawState来描述Surface所处的状态。主要有如下五种状态：<br>NO_SURFACE:WMS添加窗口,即调用addWindow之后，还没有创建Surface，mDrawState处于该状态。<br>DRAW_PENDING:app调用relayoutWindow创建Surface后，但是Surface还没有进行绘制，mDrawState处于该状态。<br>COMMIT_DRAW_PENDING:app完成Surface的绘制，调用finishDrawing，将mDrawState设置为该状态。<br>READY_TO_SHOW:在performSurfacePlacement过程中会将所有处于COMMIT_DRAW_PENDING状态的mDrawState变更为READY_TO_SHOW。<br>HAS_DRAW:若准备显示窗口，WMS执行performShowLocked，将mDrawState设置为该状态<br><img src="/../../../../../images/ad8fdb698a23430a942bcfd773fcba80.png" alt="在这里插入图片描述"></p>
<p>窗口显示相关方法</p>
<p>工作内容解释</p>
<p>addWindow</p>
<p>App向WMS请求添加窗口记录，会在WMS里新建WindowState(NO_SURFACE)</p>
<p>relayoutWindow</p>
<p>App向WMS申请surface用于绘制，执行后window拥有了surface(NO_SURFACE-&gt;DRAW_PENDING)</p>
<p>finishDrawingWindow</p>
<p>App在surface上完成绘制后，通知WMS(DRAW_PENDING-&gt;COMMIT_DRAW_PENDING)</p>
<p>commitFinishDrawingLocked</p>
<p>WMS遍历window，对于完成绘制的window(COMMIT_DRAW_PENDING-&gt;READY_TO_SHOW)</p>
<p>performShowLocked</p>
<p>判断系统是否允许窗口显示isReadyForDisplay(READY_TO_SHOW-&gt;HAS_DRAWN)</p>
<p>showSurfaceRobustlyLocked</p>
<p>对HAS_DRAWN状态的窗口，用SurfaceControl通知SurfaceFlinger显示出来</p>
<h3 id="5-移除流程简述"><a href="#5-移除流程简述" class="headerlink" title="5.移除流程简述"></a>5.移除流程简述</h3><p>窗口移除从App端发起，当Activity执行destroy(),即以handleDestroyActivity()为起点，执行wm.removeViewImmediate()开启；<br><strong>通过WindowManagerGlobal–&gt;ViewRootImpl–&gt;Session–&gt;WindowManagerService的removeWindow()，调用到WindowState的removeIfPossible()–&gt;removeImmediately()，接着调用到WindowStateAnimator的destroySurfaceLocked()–&gt;destroySurface(),逐步调用改变绘制状态为NO_SURFACE–&gt;WindowSurfaceController的destroy()最终调用到SurfaceControl的remove()来通知SurfaceFlinger来移除layer</strong>；</p>
<h2 id="三、代码流程详解"><a href="#三、代码流程详解" class="headerlink" title="三、代码流程详解"></a>三、代码流程详解</h2><h3 id="1-客户端-1"><a href="#1-客户端-1" class="headerlink" title="1.客户端"></a>1.客户端</h3><h4 id="1-1-Activity走到onresume后"><a href="#1-1-Activity走到onresume后" class="headerlink" title="1.1 Activity走到onresume后"></a>1.1 Activity走到onresume后</h4><p>从ActivityThread.handleResumeActivity方法看起<br>1.调用performResumeActivity，执行onResume。<br>2.获取WindowManager的实现类WindowManagerImpl的实例。<br>3.调用WindowManagerImpl.addView传入DecorView和当前布局参数WindowManager.LayoutParams。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p>
<pre><code>@Override
    public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,
            boolean isForward, String reason) &#123;
            ......
        // TODO Push resumeArgs into the activity for consideration
        // skip below steps for double-resume and r.mFinish = true case.
        /*1.执行onResume*/
        if (!performResumeActivity(r, finalStateRequest, reason)) &#123;
            return;
        &#125;
        ......
        //获取Activity实例
        final Activity a = r.activity;
        ......
        // If the window hasn&#39;t yet been added to the window manager,
        // and this guy didn&#39;t finish itself or start another activity,
        // then go ahead and add the window.
        //mStartedActivity在performLaunchActivity和performResumeActivity方法中被置为false
        boolean willBeVisible = !a.mStartedActivity;
        ......
        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;
            //获取当前Activity的PhoneWindow
            r.window = r.activity.getWindow();
            //从PhoneWindow中获取DecorView
            View decor = r.window.getDecorView();
            //将view的可见性状态设置为INVISIBLE,view不可见但是仍然占用布局空间
            decor.setVisibility(View.INVISIBLE);
            /*2.获取WindowManager的实现类WindowManagerImpl的实例*/
            ViewManager wm = a.getWindowManager();
            //获取布局参数
            WindowManager.LayoutParams l = r.window.getAttributes();
            //将phoneWindow的DecorView赋值给mDecor
            a.mDecor = decor;
            //设置窗口类型为TYPE_BASE_APPLICATION
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (r.mPreserveWindow) &#123;
                a.mWindowAdded = true;
                r.mPreserveWindow = false;
                // Normally the ViewRoot sets up callbacks with the Activity
                // in addView-&gt;ViewRootImpl#setView. If we are instead reusing
                // the decor view we have to notify the view root that the
                // callbacks may have changed.
                ViewRootImpl impl = decor.getViewRootImpl();
                if (impl != null) &#123;
                    impl.notifyChildRebuilt();
                &#125;
            &#125;
            if (a.mVisibleFromClient) &#123;
                if (!a.mWindowAdded) &#123;
                    a.mWindowAdded = true;
                    /*3.传入DecorView和当前布局参数WindowManager.LayoutParams*/
                    wm.addView(decor, l);
                &#125; else &#123;
                    // The activity will get a callback for this &#123;@link LayoutParams&#125; change
                    // earlier. However, at that time the decor will not be set (this is set
                    // in this method), so no action will be taken. This call ensures the
                    // callback occurs with the decor set.
                    a.onWindowAttributesChanged(l);
                &#125;
            &#125;
        &#125;
        ......
    &#125;
</code></pre>
<p><code>wm.addView(decor, l);</code>WindowManager接口的实现是WindowManagerImpl，即实际调用的是WindowManagerImpl中的addView方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerImpl.java</p>
<pre><code>    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;
        applyTokens(params);
        //转交给windowManagerGlobal，添加view
        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
                mContext.getUserId());
    &#125;
</code></pre>
<p>WindowManagerImpl对窗口的管理交给WindowManagerGlobal，调用WindowManagerGlobal的addView方法<br>WindowManagerGlobal中对窗口的处理主要如下几个步骤：<br>1.对WindowManagerImpl传进来的参数进行检查。<br>2.设置WindowManager.LayoutParams中的token、title等相关属性。查看“【<strong>1.2 Token的创建与传递</strong>】”。<br>3.创建ViewRootImpl对象，并获取客户端与WMS通信的Session。查看“【<strong>1.3 ViewRootImpl的创建</strong>】”。<br>4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。<br>5.调用ViewRootImpl，与WMS通信添加窗口。查看“【<strong>1.4 ViewRootImpl与WMS的通信</strong>】”。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p>
<pre><code>    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow, int userId) &#123;
        /*1.对WindowManagerImpl传进来的参数进行检查*/
        if (view == null) &#123;
            throw new IllegalArgumentException(&quot;view must not be null&quot;);
        &#125;
        if (display == null) &#123;
            throw new IllegalArgumentException(&quot;display must not be null&quot;);
        &#125;
        if (!(params instanceof WindowManager.LayoutParams)) &#123;
            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);
        &#125;

        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
        //此处的ParentWindow即当Activity的PhoneWindow
        if (parentWindow != null) &#123;
            /*2.为wparams的token进行赋值*/
            parentWindow.adjustLayoutParamsForSubWindow(wparams);
        &#125; else &#123;
            ......
        &#125;

        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) &#123;
            ......
            IWindowSession windowlessSession = null;
            ......
            if (windowlessSession == null) &#123;
                   /*3.新建ViewRootImpl，在新建时会通过WindowManagerGlobal获取session*/
                root = new ViewRootImpl(view.getContext(), display);
            &#125; else &#123;
                root = new ViewRootImpl(view.getContext(), display,
                        windowlessSession);
            &#125;

            view.setLayoutParams(wparams);
            /*4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。*/
            //当前view加入到view列表中
            mViews.add(view);
            //将新建的viewRootImpl加入到root列表中
            mRoots.add(root);
            //将当前布局参数加入到布局参数列表中
            mParams.add(wparams);

            // do this last because it fires off messages to start doing things
            try &#123;
                /*5.调用ViewRootImpl，设置view，panelParentView为null，与WMS通信添加窗口*/
                root.setView(view, wparams, panelParentView, userId);
            &#125; catch (RuntimeException e) &#123;
                // BadTokenException or InvalidDisplayException, clean up.
                if (index &gt;= 0) &#123;
                    removeViewLocked(index, true);
                &#125;
                throw e;
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="1-2-Token的创建与传递"><a href="#1-2-Token的创建与传递" class="headerlink" title="1.2 Token的创建与传递"></a>1.2 Token的创建与传递</h4><p><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>调用Window的adjustLayoutParamsForSubWindow()方法<br>在adjustLayoutParamsForSubWindow中会分别对WindowManager.LayoutParams中的token以及title进行赋值。<br>1.首先针对子窗口、系统窗口以及应用窗口做了不同的处理，此处我们只关注应用窗口的处理。<br>2.其次将当前PhoneWindow.mAppToken赋值给WindowManager.LayoutParams.token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p>
<pre><code>    void adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123;
        CharSequence curTitle = wp.getTitle();
        if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;
                wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;
                //对子窗口的Token以及Title赋值
                ......
        &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp;
                wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;
                //对子窗口的Token以及Title赋值
                ......
        &#125; else &#123;
            //对应用窗口的Token以及Title赋值
            if (wp.token == null) &#123;
                //将当前PhoneWindow的mAppToken赋值给wp.Token
                wp.token = mContainer == null ? mAppToken : mContainer.mAppToken;
            &#125;
            //将Title设置为mAppName
            if ((curTitle == null || curTitle.length() == 0)
                    &amp;&amp; mAppName != null) &#123;
                wp.setTitle(mAppName);
            &#125;
        &#125;
        //设置为packageName 
        if (wp.packageName == null) &#123;
            wp.packageName = mContext.getPackageName();
        &#125;
        ......
    &#125;
</code></pre>
<p>此处的mAppToken便是在Activity启动时，在ATMS端创建的Token。<br>接下来我们看看Token是如何从ATMS端传递过来，并赋值给PhoneWindow.mAppToken的<br><img src="/../../../../../images/e778248cfd7e4dd5a3fa856039013d62.png" alt="在这里插入图片描述"></p>
<p>1.在ATMS端新建ActivityRecord时，便新建了Token。并赋值给ActivityRecord.token<br>ActivityRecord继承WindowToken<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p>
<pre><code> private ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,
            int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage,
            @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType,
            ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,
            String _resultWho, int _reqCode, boolean _componentSpecified,
            boolean _rootVoiceInteraction, ActivityTaskSupervisor supervisor,
            ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState,
            TaskDescription _taskDescription, long _createTime) &#123;
        //新建Token
        super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
                null /* displayContent */, false /* ownerCanManageAppTokens */);
        ......
&#125;
</code></pre>
<p>2.将ActivityRecord.token封装在clientTransaction中，并将这个传递到客户端<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskSupervisor.java</p>
<pre><code>    boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
            boolean andResume, boolean checkConfig) throws RemoteException &#123;
        ......
        final Task task = r.getTask();
        final Task rootTask = task.getRootTask();
        ......

        try &#123;
            ......

            try &#123;
                ......
                // Create activity launch transaction.
                /*将ActivityRecord.token封装在clientTransaction中*/
                final ClientTransaction clientTransaction = ClientTransaction.obtain(
                        proc.getThread(), r.token);

                final boolean isTransitionForward = r.isTransitionForward();
                final IBinder fragmentToken = r.getTaskFragment().getFragmentToken();
                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
                        System.identityHashCode(r), r.info,
                        // TODO: Have this take the merged configuration instead of separate global
                        // and override configs.
                        mergedConfiguration.getGlobalConfiguration(),
                        mergedConfiguration.getOverrideConfiguration(), r.compat,
                        r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor,
                        proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(),
                        results, newIntents, r.takeOptions(), isTransitionForward,
                        proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController,
                        r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken));
                ......

                // Schedule transaction.
                /*将clientTransaction传递给客户端*/
                mService.getLifecycleManager().scheduleTransaction(clientTransaction);
                ......

            &#125; catch (RemoteException e) &#123;
                ......
            &#125;
        &#125; finally &#123;
            ......
        &#125;
        ......
        return true;
    &#125;
</code></pre>
<p><code>final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.token);</code><br>在ClientTransaction中调用obtain方法，把ActivityRecord.token存到mActivityToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;ClientTransaction.java</p>
<pre><code>    /** Obtain an instance initialized with provided params. */
    public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123;
        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);
        if (instance == null) &#123;
        //创建ClientTransaction
            instance = new ClientTransaction();
        &#125;
        instance.mClient = client;
        /*把ActivityRecord.token存到mActivityToken*/
        //private IBinder mActivityToken;
        instance.mActivityToken = activityToken;

        return instance;
    &#125;
</code></pre>
<p>3.客户端从ClientTransaction中获取ATMS端传来的Token，并传递到LaunchActivityItem中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;TransactionExecutor.java</p>
<pre><code>   /** Cycle through all states requested by callbacks and execute them at proper times. */
    @VisibleForTesting
    public void executeCallbacks(ClientTransaction transaction) &#123;
        final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();
        ......
        /*从ClientTransaction中获取ATMS端传来的Token*/
        final IBinder token = transaction.getActivityToken();
        ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
        ......

        final int size = callbacks.size();
        for (int i = 0; i &lt; size; ++i) &#123;
            final ClientTransactionItem item = callbacks.get(i);
            ......
            /*将Token传递到LaunchActivityItem中*/
            item.execute(mTransactionHandler, token, mPendingActions);
            item.postExecute(mTransactionHandler, token, mPendingActions);
            ......
        &#125;
    &#125;
</code></pre>
<p>4.在LaunchActivityItem中将客户端传过来的Token保存在ActivityClientRecord.token中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;LaunchActivityItem.java</p>
<pre><code>    @Override
    public void execute(ClientTransactionHandler client, IBinder token,
            PendingTransactionActions pendingActions) &#123;
        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
        //将客户端传过来的Token保存在ActivityClientRecord的token中
        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,
                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,
                mPendingResults, mPendingNewIntents, mActivityOptions, mIsForward, mProfilerInfo,
                client, mAssistToken, mShareableActivityToken, mLaunchedFromBubble,
                mTaskFragmentToken);
        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);
        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
    &#125;
</code></pre>
<p><code>client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</code>ClientTransactionHandler调用handleLaunchActivity方法，ClientTransactionHandler为抽象类，其子类为ActivityThread，即实际调用的是该类中的handleLaunchActivity()，有从该方法中调用到了performLaunchActivity()<br>5.客户端ActivityThread将ActivityClientRecord以及其对应的token保存在ActivityThread.mActivities数组中，并调用Activity.attach将Token传给Activity。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p>
<pre><code>    /**  Core implementation of activity launch. */
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;
        ......
        try &#123;
            Application app = r.packageInfo.makeApplicationInner(false, mInstrumentation);
            ......
            synchronized (mResourcesManager) &#123;
                /*将ActivityClientRecord以及其对应的Token保存在mActivities中*/
                //mActivities的类型为ArrayMap&lt;IBinder, ActivityClientRecord&gt;
                mActivities.put(r.token, r);
            &#125;

            if (activity != null) &#123;
                ......
                /*将Token赋值给Activity.mToken*/
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.activityConfigCallback,
                        r.assistToken, r.shareableActivityToken);
                ......

        &#125; catch (SuperNotCalledException e) &#123;
            throw e;

        &#125; catch (Exception e) &#123;
            ......
        &#125;

        return activity;
    &#125;
</code></pre>
<p>6.在Activity中将客户端传来的Token赋值给Activity.mToken。此外在该方法中还新建了PhoneWindow,并将PhoneWindow.mAppToken也设置为客户端传过来的Token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Activity.java</p>
<pre><code>    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,
            IBinder shareableActivityToken) &#123;
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);
        /*新建PhoneWindow*/
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        ......
        /*将客户端传过来的Token赋值给mToken*/
        mToken = token;
        ......
        /*PhoneWindow.mAppToken设置为当前客户端传递过来的Token*/
        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        ......
    &#125;
</code></pre>
<p>PhoneWindow继承Window，setWindowManager实际调用的是其父类方法，把mAppToken设置为当前客户端传递过来的mToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p>
<pre><code>    /**
     * Set the window manager for use by this Window to, for example,
     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the
     * Window itself -- that must be done by the client.
     *
     * @param wm The window manager for adding new windows.
     */
    public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123;
        //传递客户端的mToken给appToken
        setWindowManager(wm, appToken, appName, false);
    &#125;

    /**
     * Set the window manager for use by this Window to, for example,
     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the
     * Window itself -- that must be done by the client.
     *
     * @param wm The window manager for adding new windows.
     */
    public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) &#123;
        /*把appToken赋值给mAppToken*/
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated;
        if (wm == null) &#123;
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        &#125;
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    &#125;
</code></pre>
<h4 id="1-3-ViewRootImpl的创建"><a href="#1-3-ViewRootImpl的创建" class="headerlink" title="1.3 ViewRootImpl的创建"></a>1.3 ViewRootImpl的创建</h4><p><code>root = new ViewRootImpl(view.getContext(), display);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用创建ViewRootImpl，这里我们看下ViewRootImpl的构造方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</p>
<pre><code>    public ViewRootImpl(Context context, Display display) &#123;
        this(context, display, WindowManagerGlobal.getWindowSession(),
                false /* useSfChoreographer */);
    &#125;

    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) &#123;
        this(context, display, session, false /* useSfChoreographer */);
    &#125;

    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
            boolean useSfChoreographer) &#123;
        mContext = context;
        mWindowSession = session;
        ......
    &#125;
</code></pre>
<p>从这个构造方法中我们可以看出，通过WindowManagerGlobal.getWindowSession获取到客户端与WMS沟通的桥梁IWindowSession，并将其赋值给ViewRootImpl.mWindowSession。</p>
<p>下面我们查看WindowManagerGlobal中是如何获取Session的。<br>1.通过getWindowManagerService获取IWindowManager，而WindowManagerService则实现了这个Binder接口。<br>2.调用IWindowManager.openSession方法即WMS.openSession，在WMS端便会新建Session。至此客户端与WMS通信的桥梁便已经搭建好了<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p>
<pre><code>    @UnsupportedAppUsage
    public static IWindowSession getWindowSession() &#123;
        synchronized (WindowManagerGlobal.class) &#123;
            if (sWindowSession == null) &#123;
                try &#123;
                    // Emulate the legacy behavior.  The global instance of InputMethodManager
                    // was instantiated here.
                    // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage
                    InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();
                    /*1.获取Binder*/
                    IWindowManager windowManager = getWindowManagerService();
                    /*2.调用WMS的openSession*/
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() &#123;
                                @Override
                                public void onAnimatorScaleChanged(float scale) &#123;
                                    ValueAnimator.setDurationScale(scale);
                                &#125;
                            &#125;);
                &#125; catch (RemoteException e) &#123;
                    throw e.rethrowFromSystemServer();
                &#125;
            &#125;
            return sWindowSession;
        &#125;
    &#125;
</code></pre>
<p>从代码中可以看出如果sWindowSession不为空则直接返回，sWindowSession为当前WindowManagerGlobal属性，且WindowManagerGloba又是单例的，所以客户端一个进程中只有一个IWindowSession与WMS通信。如果sWindowSession为空，则会创建IWindowSession。</p>
<p>调用WindowManagerService中的openSession，新建Session<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    @Override
    public IWindowSession openSession(IWindowSessionCallback callback) &#123;
        /*新建Session*/
        return new Session(this, callback);
    &#125;
</code></pre>
<h4 id="1-4-ViewRootImpl与WMS的通信"><a href="#1-4-ViewRootImpl与WMS的通信" class="headerlink" title="1.4 ViewRootImpl与WMS的通信"></a>1.4 ViewRootImpl与WMS的通信</h4><p><code>root.setView(view, wparams, panelParentView, userId);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用ViewRootImpl与WMS的通信，继续看看<br>当前方法是与WMS进行通信添加窗口的入口，在此处我们只关注两点:<br>1.requestLayout()该方法会调用到doTraversal()，之后调用performTraversals()，最终调用到relayoutWindow()和reportDrawFinished()流程，在通过Session与服务端通信<br>2.mWindowSession.addToDisplayAsUser，与服务端进行Binder通信，调用Session的addToDisplayAsUser方法。</p>
<pre><code>   /**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;
        setView(view, attrs, panelParentView, UserHandle.myUserId());
    &#125;

    /**
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
            int userId) &#123;
        synchronized (this) &#123;
            if (mView == null) &#123;
                mView = view;
                ......
                //将布局参数拷贝纸mWindowAttributes
                mWindowAttributes.copyFrom(attrs);
                //设置包名
                if (mWindowAttributes.packageName == null) &#123;
                    mWindowAttributes.packageName = mBasePackageName;
                &#125;
                mWindowAttributes.privateFlags |=
                        WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;

                attrs = mWindowAttributes;
                ......
                // Keep track of the actual window flags supplied by the client.
                //获取当前布局的flags
                mClientWindowLayoutFlags = attrs.flags;
                ......
                int res; /* = WindowManagerImpl.ADD_OKAY; */

                // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                /*请求布局，对应服务端layoutWindow流程*/
                requestLayout();
                InputChannel inputChannel = null;
                if ((mWindowAttributes.inputFeatures
                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;
                    inputChannel = new InputChannel();
                &#125;
                ......

                try &#123;
                    ......
                    /*与服务端进行Binder通信，调用Session的addToDisplayAsUser方法*/
                    //执行addWindow的相关流程
                    res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(), userId,
                            mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                            mTempControls);
                    ......
                &#125; catch (RemoteException e) &#123;
                    ......
                &#125; finally &#123;
                    if (restore) &#123;
                        attrs.restore();
                    &#125;
                &#125;
                ......
                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow);
                if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;
                    mAttachInfo.mRootView = null;
                    mAdded = false;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    switch (res) &#123;
                        case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                        case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- token &quot; + attrs.token
                                    + &quot; is not valid; is your activity running?&quot;);
                        case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- token &quot; + attrs.token
                                    + &quot; is not for an application&quot;);
                        case WindowManagerGlobal.ADD_APP_EXITING:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- app for token &quot; + attrs.token
                                    + &quot; is exiting&quot;);
                        case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                            throw new WindowManager.BadTokenException(
                                    &quot;Unable to add window -- window &quot; + mWindow
                                    + &quot; has already been added&quot;);
                        case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                            // Silently ignore -- we would have just removed it
                            // right away, anyway.
                            return;
                        case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- another window of type &quot;
                                    + mWindowAttributes.type + &quot; already exists&quot;);
                        case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- permission denied for window type &quot;
                                    + mWindowAttributes.type);
                        case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- the specified display can not be found&quot;);
                        case WindowManagerGlobal.ADD_INVALID_TYPE:
                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;
                                    + mWindow + &quot; -- the specified window type &quot;
                                    + mWindowAttributes.type + &quot; is not valid&quot;);
                        case WindowManagerGlobal.ADD_INVALID_USER:
                            throw new WindowManager.BadTokenException(&quot;Unable to add Window &quot;
                                    + mWindow + &quot; -- requested userId is not valid&quot;);
                    &#125;
                    throw new RuntimeException(
                            &quot;Unable to add window -- unknown error code &quot; + res);
                &#125;
                ......
            &#125;
        &#125;
    &#125;
</code></pre>
<p>其中关键的添加代码为</p>
<pre><code>res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
        getHostVisibility(), mDisplay.getDisplayId(), userId,
        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
        mTempControls);
</code></pre>
<p><code>addToDisplayAsUser()</code>方法最终会走到WindowManagerService.java的addWindow方法，addWindow方法的返回值最后会返回给<code>res</code>，之后回看ViewRootImpl的setView方法，返回值如果满足<code>if (res &lt; WindowManagerGlobal.ADD_OKAY)</code>条件，那么会根据<code>switch (res)</code>中对应的case抛出异常。<br>至此，客户端流程结束，后面进入服务端流程。</p>
<h3 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h3><h4 id="2-1-窗口添加"><a href="#2-1-窗口添加" class="headerlink" title="2.1 窗口添加"></a>2.1 窗口添加</h4><p>WMS通过Session接受客户端添加窗口的请求，因此WMS会新建WindowState、将WindowState加入到WindowToken，并更新WindowToken下所有WindowState的z-order。<br>客户端通过Binder通信调用WMS端的Session.addToDisplayAsUser进入addWindow的流程。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.WindowState初始化<br>3.WindowState加入到WIndowToken</p>
<h5 id="2-1-1-接收客户端请求"><a href="#2-1-1-接收客户端请求" class="headerlink" title="2.1.1 接收客户端请求"></a>2.1.1 接收客户端请求</h5><p>客户端传递给Session的参数<br>IWindow window:是WMS与客户端通信的句柄。<br>WindowManager.LayoutParams arrts：窗口布局参数。<br>viewVisibility：附着在窗口的rootView的可见性。<br>displayId：顾名思义，display id表示的是DisplayContent即屏幕的id。<br>InsetsVisibilities requestedVisibilities:当前对象的mVisibilities记录了insets的可见性。<br>InputChannel outInputChannel：InputDispatcher接收InputReader读取到的事件，分发给对应窗口，InputDispatcher属于system_server进程和各个应用不在同一进程，它们之间的联系靠的就是InputChannel。<br>InsetsState outInsetsState：用来保存系统中所有Insets的状态，该对象只是在客户端创建，内部属性需要在WMS端赋值。<br>InsetsSourceControl[] outActiveControls：InSetsSourceControl数组。该对象也是只在客户端创建，内部属性需要在WMS端赋值。<br>Session调用<strong>WindowManagerService.addWindow</strong> 将客户端传入的参数传递给WindowManagerService。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public int addToDisplayAsUser(IWindow window, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, int userId, InsetsVisibilities requestedVisibilities,
            InputChannel outInputChannel, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls) &#123;
        return mService.addWindow(this, window, attrs, viewVisibility, displayId, userId,
                requestedVisibilities, outInputChannel, outInsetsState, outActiveControls);
    &#125;
</code></pre>
<h5 id="2-1-2-addWindow"><a href="#2-1-2-addWindow" class="headerlink" title="2.1.2 addWindow"></a>2.1.2 addWindow</h5><p>添加窗口的主要逻辑均在WMS.addWindow执行，该方法主要实现以下功能：<br>1.首先进行权限验证以及各种条件判断。<br>2.根据客户端传来的token获取windowToken。<br>3.借助客户端传来的参数，创建WindowState实例，并将其加入到WMS. mWindowMap中。<br>4.将新建的WindowState加入到相应的WindowToken，并为每个窗口赋值一个z-order。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility,
            int displayId, int requestUserId, InsetsVisibilities requestedVisibilities,
            InputChannel outInputChannel, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls) &#123;
        ......
        
        /*1.进行权限验证以及各种条件判断*/
        //判断调用者是否有权限add window
        int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,
                appOp);
        if (res != ADD_OKAY) &#123;
            return res;
        &#125;

        WindowState parentWindow = null;
        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();
        //获取将要添加的窗口类型
        final int type = attrs.type;

        synchronized (mGlobalLock) &#123;
            ......
            //根据displayId以及客户端传过来的token获取相应的displayContent
            final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
            ......
            //判断mWindowMap中是否已经存在当前客户端的key,如果有则已经将当前客户端的window添加了，无需重复添加
            if (mWindowMap.containsKey(client.asBinder())) &#123;
                ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client);
                return WindowManagerGlobal.ADD_DUPLICATE_ADD;
            &#125;
            //判断是否是子窗口
            if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;
                parentWindow = windowForClientLocked(null, attrs.token, false);
                if (parentWindow == null) &#123;
                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is not a window: &quot;
                            + &quot;%s.  Aborting.&quot;, attrs.token);
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                &#125;
                if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW
                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;
                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is a sub-window: &quot;
                            + &quot;%s.  Aborting.&quot;, attrs.token);
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                &#125;
            &#125;
            //判断当前DisplayContent是否是私有的，只拥有该display或者display已经的应用才可以在其上创建
            if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) &#123;
                ProtoLog.w(WM_ERROR,
                        &quot;Attempted to add private presentation window to a non-private display.  &quot;
                                + &quot;Aborting.&quot;);
                return WindowManagerGlobal.ADD_PERMISSION_DENIED;
            &#125;
            ......
            ActivityRecord activity = null;
            //设置是否有父窗口的标志位
            final boolean hasParent = parentWindow != null;
            // Use existing parent window token for child windows since they go in the same token
            // as there parent window so we can apply the same policy on them.
           
             /*2.根据客户端传来的token获取windowToken*/
            //attrs.token去DisplayContent.mTokenMap中去取WindowToken
            //那么WindowToken是什么时候加入到mTokenMap中的呢
            	//这就要追溯到Activity的启动时，加入到DisplayContent中
            //在ActivityStarter.startActivityInner中调用addOrReparentStartingActivity通过addChild一步步调用到WindowContainert中。
            //在调用setParent,最终通过onDisplayChanged将ActivityRecord加入到DisplayContent.mTokenMap中
            WindowToken token = displayContent.getWindowToken(
                    hasParent ? parentWindow.mAttrs.token : attrs.token);
            // If this is a child window, we want to apply the same type checking rules as the
            // parent window type.
            final int rootType = hasParent ? parentWindow.mAttrs.type : type;

            boolean addToastWindowRequiresToken = false;

            final IBinder windowContextToken = attrs.mWindowContextToken;

            if (token == null) &#123;
            ......
             &#125;else if (rootType &gt;= FIRST_APPLICATION_WINDOW
                    &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;
                //当前窗口为应用窗口，通过token，获取ActivityRecord
                activity = token.asActivityRecord();
            ......
            &#125; else if (token.asActivityRecord() != null) &#123;
                ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;,
                        rootType);
                // It is not valid to use an app token with other system types; we will
                // instead make a new token for it (as if null had been passed in for the token).
                attrs.token = null;
                token = new WindowToken.Builder(this, client.asBinder(), type)
                        .setDisplayContent(displayContent)
                        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)
                        .build();
            &#125;
            /*3.创建WindowState*/
            final WindowState win = new WindowState(this, session, client, token, parentWindow,
                    appOp[0], attrs, viewVisibility, session.mUid, userId,
                    session.mCanAddInternalSystemWindow);
            //将客户端传过来的Insets可见性赋值给WindowState的requestedVisibilities
            win.setRequestedVisibilities(requestedVisibilities);
            //验证当前窗口是否可以添加到WMS
            res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);
            if (res != ADD_OKAY) &#123;
                return res;
            &#125;
            //调用openInputChannel，初始化input相关通路
            final boolean openInputChannels = (outInputChannel != null
                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);
            if  (openInputChannels) &#123;
                win.openInputChannel(outInputChannel);
            &#125;
            //创建SufaceSession用于SurfaceFlinger通信
            win.attach();
            //将客户端与WindowState加入到mWindowMap中
            mWindowMap.put(client.asBinder(), win);
            win.initAppOpsState();
            ......
            /*4.将WindowState加入到WindowToken*/
            win.mToken.addWindow(win);
            ......
        return res;
    &#125;
</code></pre>
<p><strong>mWindowMap保存了每个WindowState和客户端窗口的映射关系，客户端应用请求窗口操作时，通过mWindowMap查询到对应的WindowState</strong></p>
<h5 id="2-1-3-WindowToken的创建"><a href="#2-1-3-WindowToken的创建" class="headerlink" title="2.1.3 WindowToken的创建"></a>2.1.3 WindowToken的创建</h5><pre><code>token = new WindowToken.Builder(this, client.asBinder(), type)
        .setDisplayContent(displayContent)
        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)
        .build();
</code></pre>
<p>这里调用的是其WindowToken自身的build方法创建<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p>
<pre><code>WindowToken build() &#123;
    return new WindowToken(mService, mToken, mType, mPersistOnEmpty, mDisplayContent,
            mOwnerCanManageAppTokens, mRoundedCornerOverlay, mFromClientToken, mOptions);
&#125;

protected WindowToken(WindowManagerService service, IBinder _token, int type,
        boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens,
        boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123;
    super(service);
    token = _token;
    windowType = type;
    mOptions = options;
    mPersistOnEmpty = persistOnEmpty;
    mOwnerCanManageAppTokens = ownerCanManageAppTokens;
    mRoundedCornerOverlay = roundedCornerOverlay;
    mFromClientToken = fromClientToken;
    if (dc != null) &#123;
        dc.addWindowToken(token, this);
    &#125;
&#125;
</code></pre>
<p><code>dc.addWindowToken(token, this);</code>在WindowToken构造方法中，调用DisplayContent.addWindowToken将WindowToken添加到以DisplayContent为根节点的WindowContainer层级结构中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    void addWindowToken(IBinder binder, WindowToken token) &#123;
        final DisplayContent dc = mWmService.mRoot.getWindowTokenDisplay(token);
        if (dc != null) &#123;
            // We currently don&#39;t support adding a window token to the display if the display
            // already has the binder mapped to another token. If there is a use case for supporting
            // this moving forward we will either need to merge the WindowTokens some how or have
            // the binder map to a list of window tokens.
            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;
                    + getName() + &quot; already mapped to display=&quot; + dc + &quot; tokens=&quot; + dc.mTokenMap);
        &#125;
        if (binder == null) &#123;
            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;
                    + getName() + &quot; binder is null&quot;);
        &#125;
        if (token == null) &#123;
            throw new IllegalArgumentException(&quot;Can&#39;t map null token to display=&quot;
                    + getName() + &quot; binder=&quot; + binder);
        &#125;

        mTokenMap.put(binder, token);

        if (token.asActivityRecord() == null) &#123;
            // Set displayContent for non-app token to prevent same token will add twice after
            // onDisplayChanged.
            // TODO: Check if it&#39;s fine that super.onDisplayChanged of WindowToken
            //  (WindowsContainer#onDisplayChanged) may skipped when token.mDisplayContent assigned.
            token.mDisplayContent = this;
            // Add non-app token to container hierarchy on the display. App tokens are added through
            // the parent container managing them (e.g. Tasks).
            //1.调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。
            final DisplayArea.Tokens da = findAreaForToken(token).asTokens();
            //2.将WindowToken添加到父容器中。
            da.addChild(token);
        &#125;
    &#125;
</code></pre>
<p>这里我们分两步看<br>1.<code>final DisplayArea.Tokens da = findAreaForToken(token).asTokens();</code>调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。</p>
<pre><code>    /**
     * Finds the &#123;@link DisplayArea&#125; for the &#123;@link WindowToken&#125; to attach to.
     * &lt;p&gt;
     * Note that the differences between this API and
     * &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; is that this API finds a
     * &#123;@link DisplayArea&#125; in &#123;@link DisplayContent&#125; level, which may find a &#123;@link DisplayArea&#125;
     * from multiple &#123;@link RootDisplayArea RootDisplayAreas&#125; under this &#123;@link DisplayContent&#125;&#39;s
     * hierarchy, while &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; finds a
     * &#123;@link DisplayArea.Tokens&#125; from a &#123;@link DisplayArea.Tokens&#125; list mapped to window layers.
     * &lt;/p&gt;
     *
     * @see DisplayContent#findAreaForTokenInLayer(WindowToken)
     */
    DisplayArea findAreaForToken(WindowToken windowToken) &#123;
        return findAreaForWindowType(windowToken.getWindowType(), windowToken.mOptions,
                windowToken.mOwnerCanManageAppTokens, windowToken.mRoundedCornerOverlay);
    &#125;
</code></pre>
<p>​    </p>
<p>为传入的WindowToken找到一个DisplayArea对象来添加进去。</p>
<pre><code>    DisplayArea findAreaForWindowType(int windowType, Bundle options,
            boolean ownerCanManageAppToken, boolean roundedCornerOverlay) &#123;
        // TODO(b/159767464): figure out how to find an appropriate TDA.
        //1.如果是App窗口，那么返回默认的TaskDisplayArea对象。
        if (windowType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; windowType &lt;= LAST_APPLICATION_WINDOW) &#123;
            return getDefaultTaskDisplayArea();
        &#125;

        // Return IME container here because it could be in one of sub RootDisplayAreas depending on
        // the focused edit text. Also, the RootDisplayArea choosing strategy is implemented by
        // the server side, but not mSelectRootForWindowFunc customized by OEM.
        //2.如果是输入法窗口，那么返回ImeContainer。
        if (windowType == TYPE_INPUT_METHOD || windowType == TYPE_INPUT_METHOD_DIALOG) &#123;
            return getImeContainer();
        &#125;
        //3.如果是其他类型，继续寻找。
        return mDisplayAreaPolicy.findAreaForWindowType(windowType, options,
                ownerCanManageAppToken, roundedCornerOverlay);
    &#125;
</code></pre>
<p>如果是App窗口，那么返回默认的TaskDisplayArea对象。<br>如果是输入法窗口，那么返回ImeContainer。<br>如果是其他类型，继续寻找。<br><code>mDisplayAreaPolicy.findAreaForWindowType(windowType, options, ownerCanManageAppToken, roundedCornerOverlay);</code>调用的是DisplayAreaPolicy中的findAreaForWindowType方法，DisplayAreaPolicy为抽象类,DisplayAreaPolicyBuilder中的Result继承了该类<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p>
<pre><code>static class Result extends DisplayAreaPolicy &#123;
    ......
       @Override
       public DisplayArea.Tokens findAreaForWindowType(int type, Bundle options,
               boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123;
           return mSelectRootForWindowFunc.apply(type, options).findAreaForWindowTypeInLayer(type,
                   ownerCanManageAppTokens, roundedCornerOverlay);
       &#125;
       ......
</code></pre>
<p>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootDisplayArea.java</p>
<pre><code>  DisplayArea.Tokens findAreaForWindowTypeInLayer(int windowType, boolean ownerCanManageAppTokens,
           boolean roundedCornerOverlay) &#123;
       //通过getWindowLayerFromTypeLw方法获取对应的窗口类型
       int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,
               ownerCanManageAppTokens, roundedCornerOverlay);
       if (windowLayerFromType == APPLICATION_LAYER) &#123;
           throw new IllegalArgumentException(
                   &quot;There shouldn&#39;t be WindowToken on APPLICATION_LAYER&quot;);
       &#125;
       return mAreaForLayer[windowLayerFromType];
   &#125;
</code></pre>
<p>通过getWindowLayerFromTypeLw方法计算出该窗口的类型对应的层级值windowLayerFromType，然后从mAreaForLayer数组中，找到windowLayerFromType对应的那个DisplayArea.Tokens对象。<br>2. <code>da.addChild(token);</code>将WindowToken添加到父容器（叶子节点）中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayArea.java</p>
<pre><code>    /**
     * DisplayArea that contains WindowTokens, and orders them according to their type.
     */
    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;
        ......
        void addChild(WindowToken token) &#123;
            addChild(token, mWindowComparator);
        &#125;
        ......
</code></pre>
<p><code>addChild(token, mWindowComparator);</code>最终调用到WindowContainer.addChild方法添加WindowToken到叶子节点</p>
<h5 id="2-1-4-WindowState初始化"><a href="#2-1-4-WindowState初始化" class="headerlink" title="2.1.4 WindowState初始化"></a>2.1.4 WindowState初始化</h5><p>在addWindow中初始化WindowState</p>
<pre><code>final WindowState win = new WindowState(this, session, client, token, parentWindow,
        appOp[0], attrs, viewVisibility, session.mUid, userId,
        session.mCanAddInternalSystemWindow);
</code></pre>
<p>下面我们看一下在WindowState的实例化过程中，都做了什么。<br>1.根据客户端传过来的参数，对相关属性进行赋值。<br>2.根据当前窗口的类型获取mBaseLayer,当将WindowState加入到WindowToken时，该值用来确定加入窗口在WindowToken数组中的位置。<br>3.实例化WindowStateAnimator，该类会跟踪当前WIndowState的动画以及surface操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,
            WindowState parentWindow, int appOp, WindowManager.LayoutParams a, int viewVisibility,
            int ownerId, int showUserId, boolean ownerCanAddInternalSystemWindow,
            PowerManagerWrapper powerManagerWrapper) &#123;
        /*1.根据客户端传递过来的参数，对相关属性进行赋值*/
        //调用WindowState的父类WindowContainer构造方法，将WMS赋值给其父类属性mWmService
        super(service);
        //获取事务
        mTmpTransaction = service.mTransactionFactory.get();
        //将Session赋值给mSession
        mSession = s;
        //将与客户端通信的Binder赋值给mClient
        mClient = c;
        mAppOp = appOp;
        //将当前activity的token赋值给mToken
        mToken = token;
        //通过token，获取当前窗口对的ActivityRecord
        mActivityRecord = mToken.asActivityRecord();
        //赋值id
        mOwnerUid = ownerId;
        mShowUserId = showUserId;
        //是否可以添加系统窗口的标志位
        mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;
        mWindowId = new WindowId(this);
        //布局参数赋值给mAttrs
        mAttrs.copyFrom(a);
        //将surfaceInsets赋值给mLastSurfaceInsets
        mLastSurfaceInsets.set(mAttrs.surfaceInsets);
        //将窗口可见性赋值给mViewVisibility 
        mViewVisibility = viewVisibility;
        //将窗口WindowManagerPolicy赋值给mPolicy 
        mPolicy = mWmService.mPolicy;
        mContext = mWmService.mContext;
        ......
        /*2.获取当前窗口的BaseLayer*/
        if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;
            ......
        &#125; else &#123;
            // The multiplier here is to reserve space for multiple
            // windows in the same type layer.
            //当前为应用窗口所以mPolicy.getWindowLayerLw(this)获取值为2，即应用层级
            //TYPE_LAYER_MULTIPLIER为同一类型的多窗口保留空间
            //TYPE_LAYER_OFFSET将同一组窗口移动到同一层中其他窗口的上方或者下方
            mBaseLayer = mPolicy.getWindowLayerLw(this)
                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
            mSubLayer = 0;
            mIsChildWindow = false;
            mLayoutAttached = false;
            mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD
                    || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;
            mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;
        &#125;
        ......
        /*3.新建windowStateAnimator，该类会跟踪当前WindowState的动画以及surface操作*/
        mWinAnimator = new WindowStateAnimator(this);
        //将透明度alpha赋值给mAlpha 
        mWinAnimator.mAlpha = a.alpha;
        ......
    &#125;
</code></pre>
<h5 id="2-1-5-将WindowState加入到WindowToken"><a href="#2-1-5-将WindowState加入到WindowToken" class="headerlink" title="2.1.5 将WindowState加入到WindowToken"></a>2.1.5 将WindowState加入到WindowToken</h5><p>在addWindow中将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WindowState加入到WindowToken中的具体过程：<br>1.将要加入的WindowState.mBaseLayer与WindowToken中现有的WindowState.mBaseLayer相比，按照mBaseLayer有小到大存放到数组中，若mBaseLayer相等，则后加入的WindowState放在数组后面。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p>
<pre><code> void addWindow(final WindowState win) &#123;
        ProtoLog.d(WM_DEBUG_FOCUS,
                &quot;addWindow: win=%s Callers=%s&quot;, win, Debug.getCallers(5));

        if (win.isChildWindow()) &#123;
            // Child windows are added to their parent windows.
            //如果是子窗口直接返回
            return;
        &#125;
        // This token is created from WindowContext and the client requests to addView now, create a
        // surface for this token.
        if (mSurfaceControl == null) &#123;
            createSurfaceControl(true /* force */);

            // Layers could have been assigned before the surface was created, update them again
            reassignLayer(getSyncTransaction());
        &#125;
        if (!mChildren.contains(win)) &#123;
            ProtoLog.v(WM_DEBUG_ADD_REMOVE, &quot;Adding %s to %s&quot;, win, this);
            //调用WindowContainer.addChild方法
            addChild(win, mWindowComparator);
            mWmService.mWindowsChanged = true;
            // TODO: Should we also be setting layout needed here and other places?
        &#125;
    &#125;
 /**
   * Compares two child window of this token and returns -1 if the first is lesser than the
   * second in terms of z-order and 1 otherwise.
   */
  private final Comparator&lt;WindowState&gt; mWindowComparator =
          (WindowState newWindow, WindowState existingWindow) -&gt; &#123;
      final WindowToken token = WindowToken.this;
      ......
      //如果新窗口的mBaseLayer 不小于（大于等于）已经存在的WindowState的BaseLayer，则返回1，否则返回-1
      return isFirstChildWindowGreaterThanSecond(newWindow, existingWindow) ? 1 : -1;
  &#125;;
    /**
     * Returns true if the new window is considered greater than the existing window in terms of
     * z-order.
     */
    protected boolean isFirstChildWindowGreaterThanSecond(WindowState newWindow,
            WindowState existingWindow) &#123;
        // New window is considered greater if it has a higher or equal base layer.
        //此处可以发现比较的是两个窗口的mBaseLayer
        return newWindow.mBaseLayer &gt;= existingWindow.mBaseLayer;
    &#125;
</code></pre>
<p>我们看看WindowContainer.addChild方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>   /**
     * Adds the input window container has a child of this container in order based on the input
     * comparator.
     * @param child The window container to add as a child of this window container.
     * @param comparator Comparator to use in determining the position the child should be added to.
     *                   If null, the child will be added to the top.
     */
    @CallSuper
    protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123;
        ......
        //记录插入数组的位置，若为-1则将windowState加入到后面
        int positionToAdd = -1;
        if (comparator != null) &#123;
            //判断当前WindowToken中WindowState的数量
            //依次比较将要加入的窗口与已经存在的WindowState的BaseLayer
            //mChildren越大放到数组最前面WindowToken
            final int count = mChildren.size();
            for (int i = 0; i &lt; count; i++) &#123;
                //比较baseLayer，如果child大于列表中已经存在的，则需要返回1，否则返回-1
                //新加入的的child大于mChildren.get(i)则返回1，小于则返回-1
                //注：comparator比较器的逻辑见上面代码的mWindowComparator 
                if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123;
                    //记录当前要插入的位置
                    positionToAdd = i;
                    break;
                &#125;
            &#125;
        &#125;
        //如果新加入的窗口大于现在所有窗口
        if (positionToAdd == -1) &#123;
            //将该窗口加入到列表最后
            mChildren.add(child);
        &#125; else &#123;
            mChildren.add(positionToAdd, child);
        &#125;

        // Set the parent after we&#39;ve actually added a child in case a subclass depends on this.
        //此处将child的mParent设置为this
        child.setParent(this);
    &#125;
</code></pre>
<p>2.将WindowState的mParent置为刚才的WindowToken，并更新其Parent的mTreeWeight。mTreeWeight记录了其子节点的数量。<br>继续查看WindowState的父类WindowContainer.setParent</p>
<pre><code>    final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123;
        //将当前WindowState的mParent设置为相应的WindowToken
        final WindowContainer oldParent = mParent;
        mParent = parent;

        if (mParent != null) &#123;
            //更新parent中的mTreeWeight属性
            //mTreeWeight代表以parent的根节点的子树中的元素的数量
            mParent.onChildAdded(this);
        &#125; else if (mSurfaceAnimator.hasLeash()) &#123;
            mSurfaceAnimator.cancelAnimation();
        &#125;
        if (!mReparenting) &#123;
            onSyncReparent(oldParent, mParent);
            if (mParent != null &amp;&amp; mParent.mDisplayContent != null
                    &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;
                onDisplayChanged(mParent.mDisplayContent);
            &#125;
            //计算显示layer
            onParentChanged(mParent, oldParent);
        &#125;
    &#125;
</code></pre>
<p>3.将WindowState加入到WindowToken之后，调用parent的assignChildLayers方法，调整其所有child的z-order。主要经历以下步骤：<br>初始化layer&#x3D;0，代表着z-order。<br>遍历mChildren数组，判断Children是否需要提高到顶部（判断标志位mNeedsZBoost）。如果不需要则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果需要则执行下一遍循环。<br>再次遍历mChildren数组，判断Children是否需要提高到顶部。如果需要则则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果不需要则执行下一次循环。<br>注：<strong>Z-order</strong>也被称为深度顺序（depth order）或Z轴顺序，它用于确定图层（Layers）在屏幕上的堆叠顺序。简单来说，<strong>Z-order</strong>就是图层在Z轴上的位置，Z轴位置越低，图层越在底层，Z轴位置越高，图层越在顶层。<br>继续看onParentChanged方法</p>
<pre><code>/**
     * Callback that is triggered when @link WindowContainer#setParent(WindowContainer)&#125; was called.
     * Supposed to be overridden and contain actions that should be executed after parent was set.
     */
    @Override
    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123;
        onParentChanged(newParent, oldParent, null);
    &#125;

    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent,
            PreAssignChildLayersCallback callback) &#123;
        ......
        if (mSurfaceControl == null) &#123;
            // If we don&#39;t yet have a surface, but we now have a parent, we should
            // build a surface.
            //创建一个SurfaceControl来调整窗口的z-order
            createSurfaceControl(false /*force*/);
        &#125; else &#123;
               ......
        &#125;
        ......
        // Either way we need to ask the parent to assign us a Z-order.
        //进入WindowToken的父类WindowContainer中，调整窗口的z-order
        mParent.assignChildLayers();
        scheduleAnimation();
    &#125;
    
    void assignChildLayers() &#123;
        assignChildLayers(getSyncTransaction());
        scheduleAnimation();
    &#125;
    
    void assignChildLayers(Transaction t) &#123;
    //分配给当前窗口的z-order，初始化为0
        int layer = 0;

        // We use two passes as a way to promote children which
        // need Z-boosting to the end of the list.
        //此处会以parent为根节点向下遍历到子节点，再从下到上依次进行处理
        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;
            final WindowContainer wc = mChildren.get(j);
            wc.assignChildLayers(t);
            //needsZBoot是用来判断当前窗口是否应该提升到容器的顶部
            //若不需要提升到容器的顶部
            if (!wc.needsZBoost()) &#123;
                //调用WindowState的父类WindowContainer中的assignLayer
                wc.assignLayer(t, layer++);
            &#125;
        &#125;
        //处理需要提升到容器顶部的窗口
        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;
            final WindowContainer wc = mChildren.get(j);
            if (wc.needsZBoost()) &#123;
                wc.assignLayer(t, layer++);
            &#125;
        &#125;
        if (mOverlayHost != null) &#123;
            mOverlayHost.setLayer(t, layer++);
        &#125;
    &#125;
</code></pre>
<p>4.在Children的assignLayer中会首先判断此次要调整的layer与自己上次layer是否相等，不相等则最终会调用nativeSetLayer来调整自己的z-order。</p>
<pre><code>    void assignLayer(Transaction t, int layer) &#123;
        // Don&#39;t assign layers while a transition animation is playing
        // TODO(b/173528115): establish robust best-practices around z-order fighting.
        //如果正在执行Transaction，则不需要进行assignLayer
        if (mTransitionController.isPlaying()) return;
        //layer为此次要调整的z-order
        final boolean changed = layer != mLastLayer || mLastRelativeToLayer != null;
        //如果需要调整
        if (mSurfaceControl != null &amp;&amp; changed) &#123;
            //调用setLayer调整窗口的z-order
            setLayer(t, layer);
            //将mLastLayer调整为新的z-order
            mLastLayer = layer;
            mLastRelativeToLayer = null;
        &#125;
    &#125;
    
    protected void setLayer(Transaction t, int layer) &#123;
        if (mSurfaceFreezer.hasLeash()) &#123;
               ......
        &#125; else &#123;
            // Route through surface animator to accommodate that our surface control might be
            // attached to the leash, and leash is attached to parent container.
            //调用SurfaceAnimator中的setLayer
            mSurfaceAnimator.setLayer(t, layer);
        &#125;
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;SurfaceAnimator.java</p>
<pre><code>    /**
     * Sets the layer of the surface.
     * &lt;p&gt;
     * When the layer of the surface needs to be adjusted, we need to set it on the leash if the
     * surface is reparented to the leash. This method takes care of that.
     */
    void setLayer(Transaction t, int layer) &#123;
          //调用SurfaceControl中的setlayer方法
        t.setLayer(mLeash != null ? mLeash : mAnimatable.getSurfaceControl(), layer);
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>        /**
         * Set the Z-order for a given SurfaceControl, relative to it&#39;s siblings.
         * If two siblings share the same Z order the ordering is undefined. Surfaces
         * with a negative Z will be placed below the parent surface.
         *
         * @param sc The SurfaceControl to set the Z order on
         * @param z The Z-order
         * @return This Transaction.
         */
        @NonNull
        public Transaction setLayer(@NonNull SurfaceControl sc,
                @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z) &#123;
            //调用调整layer
            checkPreconditions(sc);
            nativeSetLayer(mNativeObject, sc.mNativeObject, z);
            return this;
        &#125;
</code></pre>
<h4 id="2-2-窗口位置和大小计算"><a href="#2-2-窗口位置和大小计算" class="headerlink" title="2.2 窗口位置和大小计算"></a>2.2 窗口位置和大小计算</h4><p>当WindowState加入到WindowToken并调整z-order之后，客户端会再次调用<strong>WindowManagerService.relayoutWindow</strong>执行窗口布局。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.创建SurfaceControl<br>3.窗口位置和大小计算</p>
<h5 id="2-2-1-接收客户端请求"><a href="#2-2-1-接收客户端请求" class="headerlink" title="2.2.1 接收客户端请求"></a>2.2.1 接收客户端请求</h5><p>与addWindow流程的调用过程类似，WindowManagerService.relayoutWindow也是由客户端通过Session来调用的。<br>首先我们来看一下客户端给我们传递了哪些参数吧。<br>window：是WMS与客户端通信的Binder。<br>attrs：窗口的布局属性，根据attrs提供的属性来布局窗口。<br>requestWidth、requestHeight：客户端请求的窗口尺寸。<br>viewFlags：窗口的可见性。包括VISIBLE（0，view可见），INVISIBLE（4，view不可见，但是仍然占用布局空间）GONE（8，view不可见，不占用布局空间）<br>flags：定义一些布局行为。<br>outFrames：返回给客户端的，保存了重新布局之后的位置与大小。<br>mergedConfiguration:相关配置信息。<br>outSurfaceControl:返回给客户端的surfaceControl。<br>outInsetsState：用来保存系统中所有Insets的状态。<br>outActiveControls：InSetsSourceControl数组。<br>outSyncSeqIdBundle：与布局同步有关。<br>Session调用WMS.relayoutWindow将客户端传入的参数传递给WMS。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public int relayout(IWindow window, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags, int flags,
            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Bundle outSyncSeqIdBundle) &#123;
        if (false) Slog.d(TAG_WM, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot;
                + Binder.getCallingPid());
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, mRelayoutTag);
        int res = mService.relayoutWindow(this, window, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrames, mergedConfiguration, outSurfaceControl, outInsetsState,
                outActiveControls, outSyncSeqIdBundle);
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        if (false) Slog.d(TAG_WM, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot;
                + Binder.getCallingPid());
        return res;
    &#125;
</code></pre>
<h5 id="2-2-2-relayoutWindow"><a href="#2-2-2-relayoutWindow" class="headerlink" title="2.2.2 relayoutWindow"></a>2.2.2 relayoutWindow</h5><p>在WMS.relayoutWindow中主要做了以下事情：<br>1.根据客户端传过来的IWindow在mWindowMap获取窗口添加阶段创建的WindowState。<br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br>3.Surface的创建流程。<br>4.窗口尺寸的计算以及Surface的状态变更。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    public int relayoutWindow(Session session, IWindow client, LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility, int flags,
            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle) &#123;
        ......
        synchronized (mGlobalLock) &#123;
            /*1.根据客户端传过来的Iwindow从mWindowMap中获取对应的WindowState*/
            final WindowState win = windowForClientLocked(session, client, false);
            if (win == null) &#123;
                return 0;
            &#125;
            //获取DisplayContent、DisplayPolicy以及WindowStateAnimator 
            final DisplayContent displayContent = win.getDisplayContent();
            final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();

            WindowStateAnimator winAnimator = win.mWinAnimator;
            if (viewVisibility != View.GONE) &#123;
                //根据客户端请求的窗口大小设置WindowState的requestedWidth, requestedHeight
                //并设置WindowState.mLayoutNeeded为true
                win.setRequestedSize(requestedWidth, requestedHeight);
            &#125;
            ......
            //根据请求的宽带和高度窗口缩放比例
            win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);
            ......
            //获取原来window的可见性，此时为INVISIBLE
            final int oldVisibility = win.mViewVisibility;
            ......
            //代表现在没有surface但应该很快就有标志位
            win.mRelayoutCalled = true;
            win.mInRelayout = true;
            //将当前窗口的可见性有原来的INVISIBLE调整为VISIBLE
            win.setViewVisibility(viewVisibility);
            ProtoLog.i(WM_DEBUG_SCREEN_ON,
                    &quot;Relayout %s: oldVis=%d newVis=%d. %s&quot;, win, oldVisibility,
                            viewVisibility, new RuntimeException().fillInStackTrace());
            /*2.1.将displayContent中的布局标志为mLayoutNeeded置为true*/
            win.setDisplayLayoutNeeded();
            win.mGivenInsetsPending = (flags &amp; WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;

            // We should only relayout if the view is visible, it is a starting window, or the
            // associated appToken is not hidden.
            /*2.2.判断是否允许relayout，此时为true*/
            //判断条件：view可见且（activityRecord不为空，或者布局类型为TYPE_APPLICATION_STARTING，或者窗口已经告诉客户端可以显示）
            final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING
                            || win.mActivityRecord.isClientVisible());
            ......
            // Create surfaceControl before surface placement otherwise layout will be skipped
            // (because WS.isGoneForLayout() is true when there is no surface.
            /*3.surface的创建流程*/
            if (shouldRelayout) &#123;
                try &#123;
                    //进入creatSurfaceControl开始创建SurfaceControl
                    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);
                &#125; catch (Exception e) &#123;
                    ......
                    return 0;
                &#125;
            &#125;

            // We may be deferring layout passes at the moment, but since the client is interested
            // in the new out values right now we need to force a layout.
            /*4.窗口尺寸的计算以及Surface的状态变更*/
            //WindowSurfacePlacer在WMS初始化的时候创建
            mWindowPlacerLocked.performSurfacePlacement(true /* force */);
            ......
            //填充计算好的frame返回给客户端，更新mergedConfiguration对象
            win.fillClientWindowFramesAndConfiguration(outFrames, mergedConfiguration,
                    false /* useLatestConfig */, shouldRelayout);

            // Set resize-handled here because the values are sent back to the client.
            win.onResizeHandled();
            ......
        &#125;

        Binder.restoreCallingIdentity(origId);
        //返回result
        return result;
    &#125;
</code></pre>
<h5 id="2-2-3-创建SurfaceControl"><a href="#2-2-3-创建SurfaceControl" class="headerlink" title="2.2.3 创建SurfaceControl"></a>2.2.3 创建SurfaceControl</h5><p>在relayoutWindow中创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code><br>关于SurfaceControl的创建在WMS中主要做两件事：<br>1.调用WindwoStateAnimator执行具体的SurfaceControl的创建。<br>2.将创建的SurfaceControl赋值给客户端的outSurfaceControl。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    private int createSurfaceControl(SurfaceControl outSurfaceControl, int result,
            WindowState win, WindowStateAnimator winAnimator) &#123;
        ......
        WindowSurfaceController surfaceController;
        try &#123;
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;createSurfaceControl&quot;);
            /*
             * WindowStateAnimator用来帮助WindowState管理animator和surface基本操作的
             * 1.WMS将创建的surfaceContorl的操作交给windowAnimator来处理
             */
            surfaceController = winAnimator.createSurfaceLocked();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
        if (surfaceController != null) &#123;
            /*2.将WMS的SurfaceControl赋值给客户端的outSurfaceControl*/
            surfaceController.getSurfaceControl(outSurfaceControl);
            ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot;OUT SURFACE %s: copied&quot;, outSurfaceControl);

        &#125; else &#123;
            // For some reason there isn&#39;t a surface.  Clear the
            // caller&#39;s object so they see the same state.
            ProtoLog.w(WM_ERROR, &quot;Failed to create surface control for %s&quot;, win);
            outSurfaceControl.release();
        &#125;

        return result;
    &#125;
</code></pre>
<p>在WindowStateAnimator中创建SurfaceControl主要经过以下三个步骤：<br>1.重置Surface标志位，变更mDrawState状态为DRAW_PENDING。<br>2.通过实例化WindowSurfaceController来创建SurfaceControl。<br>3.处理Surface标志位，将其置为true，标志着当前WindowState已经有surface了<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>   WindowSurfaceController createSurfaceLocked() &#123;
        final WindowState w = mWin;
        
        //首先判断是否存在mSurfaceController
        if (mSurfaceController != null) &#123;
            return mSurfaceController;
        &#125;
        /*1.1.设置WindowState的mHasSurface设置为false*/
        w.setHasSurface(false);

        ProtoLog.i(WM_DEBUG_ANIM, &quot;createSurface %s: mDrawState=DRAW_PENDING&quot;, this);
        /*1.2.将WindowStateAnimator中的DrawState设置为DRAW_PENDING*/
        resetDrawState();

        mService.makeWindowFreezingScreenIfNeededLocked(w);

        /*1.3.将surface创建flag设置为hidden*/
        int flags = SurfaceControl.HIDDEN;
        //获取windowState的布局参数
        final WindowManager.LayoutParams attrs = w.mAttrs;

        // Set up surface control with initial size.
        try &#123;
            	......
            	/*2.创建WindowSurfaceController*/
            	//attrs.getTitle().toString()为当前activity的全路径名
            	//format为位图格式
            	//flags为surface创建的标志位（如：HIDDED(0x04,surface创建为隐藏)，SKIP_SCREENSHOT(0x040，截屏时跳过此图层将不会包含在非主显示器上),SECURE(0X080,禁止复制表面的内容，屏幕截图和次要的非安全显示将呈现黑色内容而不是surface内容)等）
            	//attrs.type为窗口类型
            mSurfaceController = new WindowSurfaceController(attrs.getTitle().toString(), format,
                    flags, this, attrs.type);
            mSurfaceController.setColorSpaceAgnostic((attrs.privateFlags
                    &amp; WindowManager.LayoutParams.PRIVATE_FLAG_COLOR_SPACE_AGNOSTIC) != 0);

            /*3.将WindowState的hasSurface标志设置为true，标志着道歉WindowState已经有surface了*/
            w.setHasSurface(true);
            ......
        &#125; catch (OutOfResourcesException e) &#123;
            ......
        &#125; catch (Exception e) &#123;
            ......
        &#125;
        ......
        return mSurfaceController;
    &#125;
</code></pre>
<p>SurfaceControl的创建过程为典型的建造者模式<br>接下来看看WindowSurfaceController的构造方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p>
<pre><code>WindowSurfaceController(String name, int format, int flags, WindowStateAnimator animator,
            int windowType) &#123;
        //设置WindowStateAnimator
        mAnimator = animator;
        //窗口名
        title = name;
        //WMS对象
        mService = animator.mService;
        //WindowState对象
        final WindowState win = animator.mWin;
        //窗口类型
        mWindowType = windowType;
        //IWindowSession对象
        mWindowSession = win.mSession;

        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;new SurfaceControl&quot;);
        //makeSurface最终会调用到DisplayContent的makeChildSurface方法，返回SurfaceControl.Builder
        final SurfaceControl.Builder b = win.makeSurface()
                .setParent(win.getSurfaceControl())
                .setName(name)
                .setFormat(format)
                .setFlags(flags)
                .setMetadata(METADATA_WINDOW_TYPE, windowType)
                .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid)
                .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid)
                .setCallsite(&quot;WindowSurfaceController&quot;);
        ......
        //获取SurfaceControl实例对象
        mSurfaceControl = b.build();

        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    &#125;
</code></pre>
<p>两个关键方法win.makeSurface()和b.build()<br>1.<code>final SurfaceControl.Builder b = win.makeSurface()</code><br>我们先来看看win.makeSurface()，windowState中没有makeSurface()方法，因此调用其父类WindowContainer的makeSurface()方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>    SurfaceControl.Builder makeSurface() &#123;
        final WindowContainer p = getParent();
        return p.makeChildSurface(this);
    &#125;
        /**
     * @param child The WindowContainer this child surface is for, or null if the Surface
     *              is not assosciated with a WindowContainer (e.g. a surface used for Dimming).
     */
    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;
        final WindowContainer p = getParent();
        // Give the parent a chance to set properties. In hierarchy v1 we rely
        // on this to set full-screen dimensions on all our Surface-less Layers.
        return p.makeChildSurface(child)
                .setParent(mSurfaceControl);
    &#125;
</code></pre>
<p>最终会调用到DisplayContent的makeChildSurface<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    @Override
    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;
        //此时child为WindowState
        //获取SurfaceSession，SurfaceSession的创建在Session.windowAddedLocked中，其最开始调用在WindowManagerService.addWindow中win.attach()中创建
        SurfaceSession s = child != null ? child.getSession() : getSession();
        //返回SurfaceControl.Builder
        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(s).setContainerLayer();
        if (child == null) &#123;
            return b;
        &#125;
        //设置SurfaceControl.Builder的name以及parent
        return b.setName(child.getName())
                .setParent(mSurfaceControl);
    &#125;
</code></pre>
<p>2.<code>mSurfaceControl = b.build();</code><br>再来看看b.build()，调用SurfaceControl中的build<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>    /**
      * Construct a new &#123;@link SurfaceControl&#125; with the set parameters. The builder
      * remains valid.
      */
     @NonNull
     public SurfaceControl build() &#123;
     	//检查width以及height，初始都应该为0
         if (mWidth &lt; 0 || mHeight &lt; 0) &#123;
             throw new IllegalStateException(
                     &quot;width and height must be positive or unset&quot;);
         &#125;
         if ((mWidth &gt; 0 || mHeight &gt; 0) &amp;&amp; (isEffectLayer() || isContainerLayer())) &#123;
             throw new IllegalStateException(
                     &quot;Only buffer layers can set a valid buffer size.&quot;);
         &#125;
    
         if ((mFlags &amp; FX_SURFACE_MASK) == FX_SURFACE_NORMAL) &#123;
             setBLASTLayer();
         &#125;
    //创建SurfaceControl的实例
         return new SurfaceControl(
                 mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,
                 mLocalOwnerView, mCallsite);
     &#125;
    
   /**
    * @param session  The surface session, must not be null.
    * @param name     The surface name, must not be null.
    * @param w        The surface initial width.
    * @param h        The surface initial height.
    * @param flags    The surface creation flags.
    * @param metadata Initial metadata.
    * @param callsite String uniquely identifying callsite that created this object. Used for
    *                 leakage tracking.
    * @throws throws OutOfResourcesException If the SurfaceControl cannot be created.
    */
    private SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags,
         SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView,
         String callsite)
                 throws OutOfResourcesException, IllegalArgumentException &#123;
     if (name == null) &#123;
         throw new IllegalArgumentException(&quot;name must not be null&quot;);
     &#125;
    
     mName = name;
     mWidth = w;
     mHeight = h;
     mLocalOwnerView = localOwnerView;
     //创建Parcel用来传递数据
     Parcel metaParcel = Parcel.obtain();
     try &#123;
       	......
       	//调用native层
         mNativeObject = nativeCreate(session, name, w, h, format, flags,
                 parent != null ? parent.mNativeObject : 0, metaParcel);
     &#125; finally &#123;
         metaParcel.recycle();
     &#125;
     if (mNativeObject == 0) &#123;
         throw new OutOfResourcesException(
                 &quot;Couldn&#39;t allocate SurfaceControl native object&quot;);
     &#125;
     mNativeHandle = nativeGetHandle(mNativeObject);
     mCloseGuard.openWithCallSite(&quot;release&quot;, callsite);
    &#125;
</code></pre>
<p>​    </p>
<p>SurfaceControl的构造方法调用完成后，返回查看前面<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code></p>
<h5 id="2-2-4-计算窗口大小位置"><a href="#2-2-4-计算窗口大小位置" class="headerlink" title="2.2.4 计算窗口大小位置"></a>2.2.4 计算窗口大小位置</h5><p>在relayoutWindow中计算窗口大小位置<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code><br>该流程我们分为三部分介绍：<br>1.该部分处理有关窗口布局循环的逻辑。<br>2.该部分处理Surface的状态变更，以及调用layoutWindowLw的流程。<br>3.计算窗口位置大小。</p>
<h6 id="1-处理窗口布局循环"><a href="#1-处理窗口布局循环" class="headerlink" title="1.处理窗口布局循环"></a>1.处理窗口布局循环</h6><p>performSurfacePlacement是一个确定所有窗口的Surface的如何摆放，如何显示、显示在什么位置、显示区域多大的一个入口方法。<br>该方法主要设置了布局的循环条件，当mTraversalScheduled 标志位为true，且loopCount大于0。将会调用performSurfacePlacementLoop执行布局操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p>
<pre><code>    final void performSurfacePlacement(boolean force) &#123;
        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;
            mDeferredRequests++;
            return;
        &#125;
        //将循环的最大次数设置为6次
        int loopCount = 6;
        do &#123;
            //将该标志为设置为false
            mTraversalScheduled = false;
            //执行窗口布局操作
            performSurfacePlacementLoop();
            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);
            loopCount--;
        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局
        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);
        mService.mRoot.mWallpaperActionPending = false;
    &#125;
</code></pre>
<p>performSurfacePlacementLoop方法主要做两件事：<br>1.调用RootWindowContainer对所有窗口执行布局操作，<br>2.处理是否再次进行布局的逻辑。如果DisplayContent.mLayoutNeeded标志位为true且布局循环次数小于6次，则会将mTraversalScheduled标志位置为true，在performSurfacePlacement中会再次调用performSurfacePlacementLoop。</p>
<pre><code>    private void performSurfacePlacementLoop() &#123;
        //若当前已经进行布局操作，则无需重复调用直接返回
        if (mInLayout) &#123;
            ......
            return;
        &#125;
        ......
        //将该标志位置为true，表示正在处于布局过程中
        mInLayout = true;
        ......
        try &#123;
            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/
            mService.mRoot.performSurfacePlacement();

            mInLayout = false;

            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;

            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;
                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);
                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);
            &#125;
        &#125; catch (RuntimeException e) &#123;
            mInLayout = false;
            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);
        &#125;
    &#125;
</code></pre>
<h6 id="2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程"><a href="#2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程" class="headerlink" title="2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程"></a>2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程</h6><p><code>mService.mRoot.performSurfacePlacement();</code><br>上面说到在RootWindowContainer.performSurfacePlacement()中调用了performSurfaceNoTrace()方法，该方法为实际的处理布局的方法，主要处理以下流程：<br>1.如果有焦点变化，更新焦点。<br>2.执行窗口尺寸计算，surface状态变更等操作。<br>3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在finishdrawing()中再详细分析。<br>4.如果壁纸有变化，更新壁纸。<br>5.再次处理焦点变化。<br>6.如果过程中由size或者位置变化，则通知客户端重新relayout。<br>7.销毁不可见的窗口<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    void performSurfacePlacement() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);
        try &#123;
            //调用performSurfacePlacementNoTrace()
            performSurfacePlacementNoTrace();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;
    // TODO: Super long method that should be broken down...
    void performSurfacePlacementNoTrace() &#123;
        ......
        /*1.如果有焦点变化，更新焦点*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(
                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);
        &#125;
        ......
        
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);
        //开启事务，获取GlobalTransactionWrapper对象
        mWmService.openSurfaceTransaction();
        try &#123;
            /*2.执行窗口尺寸计算，surface状态变更等操作*/
            applySurfaceChangesTransaction();
        &#125; catch (RuntimeException e) &#123;
            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);
        &#125; finally &#123;
            //关闭事务
            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            if (SHOW_LIGHT_TRANSACTIONS) &#123;
                Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);
            &#125;
        &#125;
        ......
        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/
        checkAppTransitionReady(surfacePlacer);
        ......
        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/
        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;
            final DisplayContent displayContent = mChildren.get(displayNdx);
            //判断DisplayContent的壁纸是否需要改变
            if (displayContent.mWallpaperMayChange) &#123;
                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,
                            displayContent.pendingLayoutChanges);
                &#125;
            &#125;
        &#125;
        /*5.在此处理焦点变化*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
                    false /*updateInputWindows*/);
        &#125;
        ......
        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/
        handleResizingWindows();

        if (mWmService.mDisplayFrozen) &#123;
            ProtoLog.v(WM_DEBUG_ORIENTATION,
                    &quot;With display frozen, orientationChangeComplete=%b&quot;,
                    mOrientationChangeComplete);
        &#125;
        if (mOrientationChangeComplete) &#123;
            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;
                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;
                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
            &#125;
            mWmService.stopFreezingDisplayLocked();
        &#125;

        // Destroy the surface of any windows that are no longer visible.
        /*7.销毁不可见的窗口*/
        i = mWmService.mDestroySurface.size();
        if (i &gt; 0) &#123;
            do &#123;
                i--;
                WindowState win = mWmService.mDestroySurface.get(i);
                win.mDestroying = false;
                final DisplayContent displayContent = win.getDisplayContent();
                if (displayContent.mInputMethodWindow == win) &#123;
                    displayContent.setInputMethodWindowLocked(null);
                &#125;
                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;
                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                &#125;
                win.destroySurfaceUnchecked();
            &#125; while (i &gt; 0);
            mWmService.mDestroySurface.clear();
        &#125;
        ......
    &#125;
</code></pre>
<p>​    </p>
<p>在<code>applySurfaceChangesTransaction();</code>方法中其主要执行：<br>1.水印、StrictMode警告框以及模拟器显示的布局。<br>2.遍历所有DisplayContent执行其applySurfaceChangesTransaction<br>我们一起看看这个方法</p>
<pre><code>    private void applySurfaceChangesTransaction() &#123;
        mHoldScreenWindow = null;
        mObscuringWindow = null;

        // TODO(multi-display): Support these features on secondary screens.
        /*1.水印、StrictMode警告框以及模拟器显示的布局*/
        //获取手机默认DisplayContent的信息
        final DisplayContent defaultDc = mWmService.getDefaultDisplayContentLocked();
        final DisplayInfo defaultInfo = defaultDc.getDisplayInfo();
        final int defaultDw = defaultInfo.logicalWidth;
        final int defaultDh = defaultInfo.logicalHeight;
        //布局水印
        if (mWmService.mWatermark != null) &#123;
            mWmService.mWatermark.positionSurface(defaultDw, defaultDh, mDisplayTransaction);
        &#125;
        //布局StrictMode警告框
        if (mWmService.mStrictModeFlash != null) &#123;
            mWmService.mStrictModeFlash.positionSurface(defaultDw, defaultDh, mDisplayTransaction);
        &#125;
        //布局模拟器显示覆盖
        if (mWmService.mEmulatorDisplayOverlay != null) &#123;
            mWmService.mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh,
                    mWmService.getDefaultDisplayRotation(), mDisplayTransaction);
        &#125;
        /*2.遍历RootWindowContainer下所有DisplayContent执行其applySurfaceChangesTransaction()*/
        final int count = mChildren.size();
        for (int j = 0; j &lt; count; ++j) &#123;
            final DisplayContent dc = mChildren.get(j);
            dc.applySurfaceChangesTransaction();
        &#125;

        // Give the display manager a chance to adjust properties like display rotation if it needs
        // to.
        mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction);
        SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);
    &#125;
</code></pre>
<p>接下来继续跟踪<code>dc.applySurfaceChangesTransaction();</code><br>该方法主要<br>1.遍历所有窗口，计算窗口的布局大小，具体流程查看performLayoutNoTrace。（主要跟踪点）<br>2.surface的状态更改。（见“<strong>2.3.3mDrawState变更为HAS_DRAW”流程</strong>”）<br>3.处理surface的位置、大小以及显示等。（见“<strong>2.3.4 show Surface”流程</strong>”）<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    void applySurfaceChangesTransaction() &#123;
        //获取WindowSurfacePlacer 
        final WindowSurfacePlacer surfacePlacer = mWmService.mWindowPlacerLocked;
        ......
        // Perform a layout, if needed.
        /*1.执行布局，该方法最终会调用performLayoutNoTrace，计算窗口的布局参数*/
        performLayout(true /* initial */, false /* updateInputWindows */);
        ......
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applyWindowSurfaceChanges&quot;);
        try &#123;
            /*2.遍历所有窗口，主要是改变surface的状态。见“2.3.3mDrawState变更为HAS_DRAW”流程*/
            forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
        /*3.处理各个surface的位置、大小以及是否要在屏幕上显示等。后面finishDrawing()流程中再跟踪*/
        prepareSurfaces();
        ......
    &#125;
</code></pre>
<p>继续跟踪<code>performLayout(true /* initial */, false /* updateInputWindows */);</code><br>该方法主要就是调用performLayoutNoTrace()方法，首先判断布局标志位mLayoutNeeded，该标志位在WMS.relayoutWindow中被置为true。<br>false则直接返回不会进行布局操作。<br>true则分别遍历父窗口和子窗口进行布局，我们暂且只分析父窗口的布局操作，查看mPerformLayout。</p>
<pre><code>    void performLayout(boolean initial, boolean updateInputWindows) &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performLayout&quot;);
        try &#123;
            //调用performLayoutNoTrace
            performLayoutNoTrace(initial, updateInputWindows);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    private void performLayoutNoTrace(boolean initial, boolean updateInputWindows) &#123;
            /*1.判断是否需要布局，不需要则直接返回，即判断布局标志位mLayoutNeeded是否为true*/
        if (!isLayoutNeeded()) &#123;
            return;
        &#125;
        //将DisplayContent.mLayoutNeeded属性置为false
        clearLayoutNeeded();
        ......
        // First perform layout of any root windows (not attached to another window).
        /*2.对所有顶级窗口进行布局*/
        //最终会回调mPerformLayout
        forAllWindows(mPerformLayout, true /* traverseTopToBottom */);

        // Now perform layout of attached windows, which usually depend on the position of the
        // window they are attached to. XXX does not deal with windows that are attached to windows
        // that are themselves attached.
        /*3.处理子窗口的布局*/
        //最终会回调mPerformLayoutAttached
        forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);
        ......
    &#125;
</code></pre>
<p><code>forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);</code><br>当遍历到DisplayContent下的每个窗口时都会执行mPerformLayout，该方法会将WindowState.mLayoutNeeded标志位置false，并将具体的布局操作交给DisplayPolicy进行处理，见“<strong>3. 计算窗口位置大小</strong>“。</p>
<pre><code>    private final Consumer&lt;WindowState&gt; mPerformLayout = w -&gt; &#123;
        //如果当前窗口为子窗口则直接返回
        if (w.mLayoutAttached) &#123;
            return;
        &#125;

        // Don&#39;t do layout of a window if it is not visible, or soon won&#39;t be visible, to avoid
        // wasting time and funky changes while a window is animating away.
        //先判断当前窗口是否会不可见
        final boolean gone = w.isGoneForLayout();
        ......

        // If this view is GONE, then skip it -- keep the current frame, and let the caller know
        // so they can ignore it if they want.  (We do the normal layout for INVISIBLE windows,
        // since that means &quot;perform layout as normal, just don&#39;t display&quot;).
        if (!gone || !w.mHaveFrame || w.mLayoutNeeded) &#123;
            if (mTmpInitial) &#123;
                //设置窗口布局WindowFrames.mContentChanged为false
                w.resetContentChanged();
            &#125;
            //将mSurfacePlacementNeeded标志为置为true
            w.mSurfacePlacementNeeded = true;
            //将WindowState.mLayoutNeeded标志位置为false
            w.mLayoutNeeded = false;
            //判断当前窗口是否是第一次布局
            final boolean firstLayout = !w.isLaidOut();
            //调用DisplayPolicy.layoutWindowLw进行布局，根据DisplayFrames对象对WindowState.mWindowFrames中的各个Rect对象属性进行确定
            getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);
            w.mLayoutSeq = mLayoutSeq;

            // If this is the first layout, we need to initialize the last frames and inset values,
            // as otherwise we&#39;d immediately cause an unnecessary resize.
            if (firstLayout) &#123;
                // The client may compute its actual requested size according to the first layout,
                // so we still request the window to resize if the current frame is empty.
                if (!w.getFrame().isEmpty()) &#123;
                    w.updateLastFrames();
                &#125;
                w.onResizeHandled();
            &#125;

            if (DEBUG_LAYOUT) Slog.v(TAG, &quot;  LAYOUT: mFrame=&quot; + w.getFrame()
                    + &quot; mParentFrame=&quot; + w.getParentFrame()
                    + &quot; mDisplayFrame=&quot; + w.getDisplayFrame());
        &#125;
    &#125;;
</code></pre>
<p>当mLayoutNeeded标志被设置时，表示布局需要更新；mSurfacePlacementNeeded标志被设置时，表示需要更新surface位置的条件之一（WindowState.updateSurfacePosition方法中有判断）。</p>
<h6 id="3-计算窗口位置大小"><a href="#3-计算窗口位置大小" class="headerlink" title="3.计算窗口位置大小"></a>3.计算窗口位置大小</h6><p><code>getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);</code><br>layoutWindowLw主要做了以下三件事<br>1.首先会获DisplayFrames：DisplayContent新建时创建，内部数据由屏幕提供。<br>2.其次调用WindowLayout.computeFrames计算窗口布局大小。<br>3.最后调用WindowState.setFrames将计算的布局参数赋值给当前窗口的windowFrames。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayPolicy.java</p>
<pre><code>    /**
     * Called for each window attached to the window manager as layout is proceeding. The
     * implementation of this function must take care of setting the window&#39;s frame, either here or
     * in finishLayout().
     *
     * @param win The window being positioned.
     * @param attached For sub-windows, the window it is attached to; this
     *                 window will already have had layoutWindow() called on it
     *                 so you can use its Rect.  Otherwise null.
     * @param displayFrames The display frames.
     */
    public void layoutWindowLw(WindowState win, WindowState attached, DisplayFrames displayFrames) &#123;
        //判断是否需要跳过布局
        if (win.skipLayout()) &#123;
            return;
        &#125;

        // This window might be in the simulated environment.
        // We invoke this to get the proper DisplayFrames.
        /*1.获取DisplayFrames*/
        displayFrames = win.getDisplayFrames(displayFrames);
        //获取某个方向的窗口布局参数
        final WindowManager.LayoutParams attrs = win.getLayoutingAttrs(displayFrames.mRotation);
        //null
        final Rect attachedWindowFrame = attached != null ? attached.getFrame() : null;

        // If this window has different LayoutParams for rotations, we cannot trust its requested
        // size. Because it might have not sent its requested size for the new rotation.
        final boolean trustedSize = attrs == win.mAttrs;
        final int requestedWidth = trustedSize ? win.mRequestedWidth : UNSPECIFIED_LENGTH;
        final int requestedHeight = trustedSize ? win.mRequestedHeight : UNSPECIFIED_LENGTH;
        /*2.调用WindowLayout.computeFrames计算窗口布局大小*/
        mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,
                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,
                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,
                sTmpClientFrames);
        /*3.将计算的布局参数赋值给windowFrames*/
        win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);
    &#125;
</code></pre>
<p>先来看看computeFrames，计算窗口布局大小</p>
<pre><code>mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,
                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,
                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,
                sTmpClientFrames);
</code></pre>
<p>调用的是WindowLayout的computeFrames方法</p>
<pre><code>public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,
            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,
            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,
            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames)
</code></pre>
<p>入参说明：<br><code>attrs</code>：这些是窗口的布局参数。它们定义了窗口的位置、大小、堆叠顺序等属性。<br><code>state</code>：这个参数代表了窗口的边距状态。边距是窗口与设备边缘之间的空间，可能会被其他元素（如状态栏或导航栏）占据。<br><code>displayCutoutSafe</code>：这是一个矩形，表示在计算窗口大小时可以安全忽略的显示切边区域。这通常是为了防止应用程序内容与设备上的物理切边重叠。<br><code>windowBounds</code>：这是窗口的边界矩形，通常表示窗口在屏幕上的位置和大小。<br><code>windowingMode</code>：这个参数定义了窗口的窗口模式。例如，它可以是全屏、浮动等模式。<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br><code>requestedVisibilities</code>：请求的可见性。这定义了应用程序请求的边距可见性，例如状态栏或导航栏是否可见。<br><code>attachedWindowFrame</code>：附加窗口的边界。如果这个窗口是附加到另一个窗口的，这个参数表示它相对于其父窗口的位置和大小。<br><code>compatScale</code>：兼容性比例，一个缩放因子，用于调整窗口内容的显示大小以适应不同的屏幕尺寸或分辨率。<br><code>outFrames</code>：用于返回计算后的窗口信息。它包含了窗口的实际边界、边距等信息。<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowLayout.java</p>
<pre><code>    public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,
            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,
            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,
            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames) &#123;
        //传入的参数attrs中提取出窗口的类型（type）、标志（fl）、私有标志（pfl）和布局是否在屏幕内（layoutInScreen）
        final int type = attrs.type;
        final int fl = attrs.flags;
        final int pfl = attrs.privateFlags;
        final boolean layoutInScreen = (fl &amp; FLAG_LAYOUT_IN_SCREEN) == FLAG_LAYOUT_IN_SCREEN;
        //定义了用于存储结果的矩形变量，包含：显示边界（outDisplayFrame）、父边界（outParentFrame）和实际边界（outFrame）
        final Rect outDisplayFrame = outFrames.displayFrame;
        final Rect outParentFrame = outFrames.parentFrame;
        final Rect outFrame = outFrames.frame;

        // Compute bounds restricted by insets
        //计算窗口被Insets限制的边界。Insets是屏幕边缘的空间，用于放置状态栏、导航栏等。
        //这一步通过调用state.calculateInsets()方法完成，该方法需要窗口边界和窗口布局参数作为输入。
        final Insets insets = state.calculateInsets(windowBounds, attrs.getFitInsetsTypes(),
                attrs.isFitInsetsIgnoringVisibility());
        //代码根据Insets的边类型（LEFT、TOP、RIGHT、BOTTOM），从计算出的Insets中提取出相应的边距，
        //并将它们添加到窗口的原始边界上，得到显示边界。
        final @WindowInsets.Side.InsetsSide int sides = attrs.getFitInsetsSides();
        final int left = (sides &amp; WindowInsets.Side.LEFT) != 0 ? insets.left : 0;
        final int top = (sides &amp; WindowInsets.Side.TOP) != 0 ? insets.top : 0;
        final int right = (sides &amp; WindowInsets.Side.RIGHT) != 0 ? insets.right : 0;
        final int bottom = (sides &amp; WindowInsets.Side.BOTTOM) != 0 ? insets.bottom : 0;
        //代码将计算出的显示边界赋值给outDisplayFrame
        outDisplayFrame.set(windowBounds.left + left, windowBounds.top + top,
                windowBounds.right - right, windowBounds.bottom - bottom);

        //根据窗口的附加信息和布局属性来确定父边界的位置和大小。
        if (attachedWindowFrame == null) &#123;
            //将outParentFrame设置为与outDisplayFrame相同，这意味着父边界与显示边界相同
            outParentFrame.set(outDisplayFrame);
            //检查私有标志PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME是否被设置。
            //这个标志可能表示是否需要根据输入法窗口（IME）的位置来调整父边界。
            if ((pfl &amp; PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME) != 0) &#123;
                //从状态中获取输入法窗口的源（source）
                final InsetsSource source = state.peekSource(ITYPE_IME);
                if (source != null) &#123;
                    //如果输入法窗口的source存在，则使用该source来计算父边界的内边距（Insets）。
                    outParentFrame.inset(source.calculateInsets(
                            outParentFrame, false /* ignoreVisibility */));//这里忽略source的可见性。
                &#125;
            &#125;
        &#125; else &#123;
            //如果layoutInScreen为true，则将outParentFrame设置为与attachedWindowFrame相同。
            //这表示父边界是由附加窗口的边界决定的。
            //如果layoutInScreen为false，则将outParentFrame设置为与outDisplayFrame相同。
            //这表示父边界与显示边界相同。
            outParentFrame.set(!layoutInScreen ? attachedWindowFrame : outDisplayFrame);
        &#125;

        // Compute bounds restricted by display cutout
        //根据屏幕的显示切边和窗口的布局属性来计算窗口在屏幕上受到限制的位置和大小，确保窗口不会覆盖到显示切边区域
        final int cutoutMode = attrs.layoutInDisplayCutoutMode;//切边模式
        final DisplayCutout cutout = state.getDisplayCutout();//屏幕上的显示切边区域
        //将displayCutoutSafeExceptMaybeBars设置为与displayCutoutSafe相同，
        //这是一个临时矩形，用于稍后计算不受某些系统界面元素（如状态栏）影响的显示切边安全区域。
        final Rect displayCutoutSafeExceptMaybeBars = mTempDisplayCutoutSafeExceptMaybeBarsRect;
        displayCutoutSafeExceptMaybeBars.set(displayCutoutSafe);
        //将outFrames.isParentFrameClippedByDisplayCutout设置为false，表示父边界目前没有被显示切边裁剪
        outFrames.isParentFrameClippedByDisplayCutout = false;
        //如果layoutInDisplayCutoutMode不是ALWAYS并且显示切边不为空
        if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS &amp;&amp; !cutout.isEmpty()) &#123;
            // Ensure that windows with a non-ALWAYS display cutout mode are laid out in
            // the cutout safe zone.
            //获取屏幕的显示边界（displayFrame）
            final Rect displayFrame = state.getDisplayFrame();
            //获取状态的Source
            final InsetsSource statusBarSource = state.peekSource(ITYPE_STATUS_BAR);
            //检查状态栏源（statusBarSource）是否存在，并且如果displayCutoutSafe.top大于屏幕的顶部
            if (statusBarSource != null &amp;&amp; displayCutoutSafe.top &gt; displayFrame.top) &#123;
                // Make sure that the zone we&#39;re avoiding for the cutout is at least as tall as the
                // status bar; otherwise fullscreen apps will end up cutting halfway into the status
                // bar.
                //调整displayCutoutSafeExceptMaybeBars.top以确保切边避开的区域至少与状态栏一样高。
                displayCutoutSafeExceptMaybeBars.top =
                        Math.max(statusBarSource.getFrame().bottom, displayCutoutSafe.top);
            &#125;
            //如果layoutInDisplayCutoutMode是SHORT_EDGES
            if (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES) &#123;
                if (displayFrame.width() &lt; displayFrame.height()) &#123;
                    //如果屏幕的宽度小于高度，则将displayCutoutSafeExceptMaybeBars的顶部和底部设置为最大和最小整数值，
                    //这意味着不考虑这些方向上的显示切边。
                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125; else &#123;
                    //否则，将左侧和右侧设置为最大和最小整数值
                    //这意味着不考虑这些方向上的显示切边。
                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;
                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;
                &#125;
            &#125;
            //通过位运算检查attrs.flags中的FLAG_LAYOUT_INSET_DECOR标志是否被设置。如果被设置，则layoutInsetDecor为true
            // FLAG_LAYOUT_INSET_DECOR:使窗口的内容布局在DecorView（装饰视图）之内
            final boolean layoutInsetDecor = (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) != 0;
            //检查布局是否应在屏幕上进行且是否需要考虑显示切边
            //布局在屏幕上、DecorView之内 且 显示切边模式为默认或短边缘模式
            if (layoutInScreen &amp;&amp; layoutInsetDecor
                    &amp;&amp; (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
                    || cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)) &#123;
                //使用给定的displayFrame、系统栏类型和可见性请求来计算系统栏的插入
                //系统栏包含： STATUS_BARS | NAVIGATION_BARS | CAPTION_BAR
                final Insets systemBarsInsets = state.calculateInsets(
                        displayFrame, WindowInsets.Type.systemBars(), requestedVisibilities);
                //如果系统栏在左侧、顶部、右侧或底部的插入大于0，则调整displayCutoutSafeExceptMaybeBars的相应边界，
                //使其尽可能地远离屏幕边缘。这是为了确保窗口不会覆盖到这些系统栏。
                if (systemBarsInsets.left &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;
                &#125;
                if (systemBarsInsets.top &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;
                &#125;
                if (systemBarsInsets.right &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;
                &#125;
                if (systemBarsInsets.bottom &gt; 0) &#123;
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125;
            &#125;
            //如果窗口类型是输入法（IME）
            if (type == TYPE_INPUT_METHOD) &#123;
                //获取导航栏的Source
                final InsetsSource navSource = state.peekSource(ITYPE_NAVIGATION_BAR);
                //如果存在导航栏且其底部插入大于0
                if (navSource != null &amp;&amp; navSource.calculateInsets(displayFrame, true).bottom &gt; 0) &#123;
                    // The IME can always extend under the bottom cutout if the navbar is there.
                    //调整displayCutoutSafeExceptMaybeBars.bottom，允许IME窗口扩展到底部显示切边以下。
                    //这是为了确保IME可以正常显示在有导航栏的设备上。
                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;
                &#125;
            &#125;
            //如果窗口已附加到其父窗口并且不是全屏布局，则attachedInParent为true
            final boolean attachedInParent = attachedWindowFrame != null &amp;&amp; !layoutInScreen;

            // TYPE_BASE_APPLICATION windows are never considered floating here because they don&#39;t
            // get cropped / shifted to the displayFrame in WindowState.
            //判断窗口是否为浮窗
            //如果窗口不是全屏的、全屏布局的并且不是基础应用程序类型，那么它是一个浮动在屏幕上的窗口，简称浮窗。
            final boolean floatingInScreenWindow = !attrs.isFullscreen() &amp;&amp; layoutInScreen
                    &amp;&amp; type != TYPE_BASE_APPLICATION;

            // Windows that are attached to a parent and laid out in said parent already avoid
            // the cutout according to that parent and don&#39;t need to be further constrained.
            // Floating IN_SCREEN windows get what they ask for and lay out in the full screen.
            // They will later be cropped or shifted using the displayFrame in WindowState,
            // which prevents overlap with the DisplayCutout.
            //对于非附加到父窗口和非浮动在屏幕上的窗口，需要处理其与显示切边的交集。这是因为这些窗口需要避免与显示切边重叠。
            if (!attachedInParent &amp;&amp; !floatingInScreenWindow) &#123;
                mTempRect.set(outParentFrame); //临时存储父窗口的边界
                //将父窗口的边界设置为与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界
                outParentFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);
                //如果父窗口的边界交集后与原始边界不同，则表示父窗口的边界被切边裁剪了
                outFrames.isParentFrameClippedByDisplayCutout = !mTempRect.equals(outParentFrame);
            &#125;
            //将输出显示边界设置与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界
            outDisplayFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);
        &#125;

        //检查attrs.flags中的FLAG_LAYOUT_NO_LIMITS位是否被设置。
        //FLAG_LAYOUT_NO_LIMITS表示允许窗口布局到屏幕外侧。
        final boolean noLimits = (attrs.flags &amp; FLAG_LAYOUT_NO_LIMITS) != 0;
        //检查当前窗口是否处于多窗口模式
        final boolean inMultiWindowMode = WindowConfiguration.inMultiWindowMode(windowingMode);

        // TYPE_SYSTEM_ERROR is above the NavigationBar so it can&#39;t be allowed to extend over it.
        // Also, we don&#39;t allow windows in multi-window mode to extend out of the screen.
        //noLimits是否为true即允许窗口布局到屏幕外）  
        //type是否不等于TYPE_SYSTEM_ERROR（表示窗口类型不是系统错误）  
        //inMultiWindowMode是否为false（表示窗口不在多窗口模式下）
        if (noLimits &amp;&amp; type != TYPE_SYSTEM_ERROR &amp;&amp; !inMultiWindowMode) &#123;
            //设置输出显示的窗口边界
            //[left,top]为左上角左边，[right,bottom]为右上角坐标，两个坐标构成一个矩形
            //左上角左边设置为屏幕最小点，右下角坐标设置为屏幕最大点，即窗口将占据整个屏幕的边界
            outDisplayFrame.left = MIN_X;
            outDisplayFrame.top = MIN_Y;
            outDisplayFrame.right = MAX_X;
            outDisplayFrame.bottom = MAX_Y;
        &#125;

        //如果compatScale不等于1，则hasCompatScale为true。这意味着存在一个兼容的缩放因子。
        final boolean hasCompatScale = compatScale != 1f;
        //父窗口的宽度和高度
        final int pw = outParentFrame.width();
        final int ph = outParentFrame.height();
        //判断窗口的布局尺寸是否因为显示切边而扩展
        //某些设备可能具有物理上的切边（如刘海屏、水滴屏等），这些切边区域不能用于显示内容。
        //PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT作用就是为了确保应用程序的布局在具有切边的设备上仍然正确显示
        //设置这个标志时，窗口的实际尺寸将大于其请求的尺寸，以便在切边区域周围填充空间。
        final boolean extendedByCutout =
                (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != 0;
        //请求的窗口宽度和高度
        int rw = requestedWidth;
        int rh = requestedHeight;
        //窗口的位置坐标
        float x, y;
        //最终确定的窗口宽度和高度
        int w, h;

        // If the view hierarchy hasn&#39;t been measured, the requested width and height would be
        // UNSPECIFIED_LENGTH. This can happen in the first layout of a window or in the simulated
        // layout. If extendedByCutout is true, we cannot use the requested lengths. Otherwise,
        // the window frame might be extended again because the requested lengths may come from the
        // window frame.
        //如果请求的窗口宽度或高度，是UNSPECIFIED_LENGTH或者窗口因为显示切边而扩展，
        //那么其大于或等于0则使用attrs.width或attrs.height的值，否则使用父窗口的宽度和高度
        if (rw == UNSPECIFIED_LENGTH || extendedByCutout) &#123;
            rw = attrs.width &gt;= 0 ? attrs.width : pw;
        &#125;
        if (rh == UNSPECIFIED_LENGTH || extendedByCutout) &#123;
            rh = attrs.height &gt;= 0 ? attrs.height : ph;
        &#125;

        //如果设置了FLAG_SCALED标志，代码会根据是否应用兼容性缩放来调整窗口的宽度和高度。
        if ((attrs.flags &amp; FLAG_SCALED) != 0) &#123;
            if (attrs.width &lt; 0) &#123;
                w = pw;
            &#125; else if (hasCompatScale) &#123;
                w = (int) (attrs.width * compatScale + .5f);
            &#125; else &#123;
                w = attrs.width;
            &#125;
            if (attrs.height &lt; 0) &#123;
                h = ph;
            &#125; else if (hasCompatScale) &#123;
                h = (int) (attrs.height * compatScale + .5f);
            &#125; else &#123;
                h = attrs.height;
            &#125;
        &#125; else &#123;
            if (attrs.width == MATCH_PARENT) &#123;
                w = pw;
            &#125; else if (hasCompatScale) &#123;
                w = (int) (rw * compatScale + .5f);
            &#125; else &#123;
                w = rw;
            &#125;
            if (attrs.height == MATCH_PARENT) &#123;
                h = ph;
            &#125; else if (hasCompatScale) &#123;
                h = (int) (rh * compatScale + .5f);
            &#125; else &#123;
                h = rh;
            &#125;
        &#125;

        //如果存在兼容缩放因子，则调整窗口的x和y位置以考虑缩放。否则，直接使用原始的x和y位置。
        if (hasCompatScale) &#123;
            x = attrs.x * compatScale;
            y = attrs.y * compatScale;
        &#125; else &#123;
            x = attrs.x;
            y = attrs.y;
        &#125;
        
        //当前窗口是多窗口且设置PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME
        //PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME的作用是窗口应该根据其父窗口的边界来调整自己的大小和位置。
        //即控制子窗口在其父窗口内的布局行为，确保子窗口不会超出父窗口的边界。
        if (inMultiWindowMode
                &amp;&amp; (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME) == 0) &#123;
            // Make sure window fits in parent frame since it is in a non-fullscreen task as
            // required by &#123;@link Gravity#apply&#125; call.
            //将窗口的宽度和高度分别设置为它们与父窗口宽度和高度中的较小值。
            //这样做的目的是确保子窗口的大小不会超过其父窗口的大小。
            w = Math.min(w, pw);
            h = Math.min(h, ph);
        &#125;

        // We need to fit it to the display if either
        // a) The window is in a fullscreen container, or we don&#39;t have a task (we assume fullscreen
        // for the taskless windows)
        // b) If it&#39;s a secondary app window, we also need to fit it to the display unless
        // FLAG_LAYOUT_NO_LIMITS is set. This is so we place Popups, dialogs, and similar windows on
        // screen, but SurfaceViews want to be always at a specific location so we don&#39;t fit it to
        // the display.
    
        //如果窗口不在多窗口模式下，或者窗口类型不是基础应用程序类型并且noLimits标志未设置，那么窗口需要适应显示。
        final boolean fitToDisplay = !inMultiWindowMode
                || ((attrs.type != TYPE_BASE_APPLICATION) &amp;&amp; !noLimits);

        // Set mFrame
        //根据给定的重力属性、宽度、高度、父边界等，计算并设置outFrame。
        //这里主要是确定窗口的位置。
        Gravity.apply(attrs.gravity, w, h, outParentFrame,
                (int) (x + attrs.horizontalMargin * pw),
                (int) (y + attrs.verticalMargin * ph), outFrame);

        // Now make sure the window fits in the overall display frame.
        //如果窗口需要适应显示，那么使用Gravity.applyDisplay方法来调整outFrame(实际边界)的大小和位置在outDisplayFrame(显示边界)之内。
        if (fitToDisplay) &#123;
            Gravity.applyDisplay(attrs.gravity, outDisplayFrame, outFrame);
        &#125;

         //确保应用窗口的位置不会与设备的切边冲突。
         //如果窗口的布局因为切边的存在而进行了扩展，并且窗口的边界超出了安全区域，那么它会调整窗口的位置，使其位于安全区域内。
        if (extendedByCutout &amp;&amp; !displayCutoutSafe.contains(outFrame)) &#123;
            mTempRect.set(outFrame);

            // Move the frame into displayCutoutSafe.
            final int clipFlags = DISPLAY_CLIP_VERTICAL | DISPLAY_CLIP_HORIZONTAL;
            Gravity.applyDisplay(attrs.gravity &amp; ~clipFlags, displayCutoutSafe,
                    mTempRect);

            if (mTempRect.intersect(outDisplayFrame)) &#123;
                outFrame.union(mTempRect);
            &#125;
        &#125;

        if (DEBUG) Log.d(TAG, &quot;computeWindowFrames &quot; + attrs.getTitle()
                + &quot; outFrames=&quot; + outFrames
                + &quot; windowBounds=&quot; + windowBounds.toShortString()
                + &quot; attachedWindowFrame=&quot; + (attachedWindowFrame != null
                        ? attachedWindowFrame.toShortString()
                        : &quot;null&quot;)
                + &quot; requestedWidth=&quot; + requestedWidth
                + &quot; requestedHeight=&quot; + requestedHeight
                + &quot; compatScale=&quot; + compatScale
                + &quot; windowingMode=&quot; + WindowConfiguration.windowingModeToString(windowingMode)
                + &quot; displayCutoutSafe=&quot; + displayCutoutSafe
                + &quot; attrs=&quot; + attrs
                + &quot; state=&quot; + state
                + &quot; requestedVisibilities=&quot; + requestedVisibilities);
  &#125;
</code></pre>
<p>computeFrame方法是WindowState类中的一个重要方法，用于计算窗口的位置和大小。具体来说，它负责计算窗口的绘制区域，即窗口的内容在屏幕上实际显示的位置和大小。这个计算涉及到考虑窗口的位置、大小、布局参数以及可能的边界限制，确保窗口内容不会超出屏幕边界或被其他窗口遮挡。</p>
<p>在窗口管理器中，computeFrame方法通常会在以下情况被调用：</p>
<ul>
<li>当窗口第一次被创建时，需要计算其初始位置和大小。</li>
<li>当窗口的布局参数或内容发生变化时，需要重新计算窗口的位置和大小。</li>
<li>当屏幕旋转或大小变化等系统事件发生时，需要调整所有窗口的位置和大小。</li>
</ul>
<p>总之，computeFrame方法在Android窗口管理系统中起到了非常重要的作用，确保应用程序窗口能够正确地在屏幕上显示，并且适应不同的设备和系统事件, 为了计算小窗的位置，以及处理小窗内的View 的边界异常情况，</p>
<p>再来看看setFrames，更新窗口大小位置变化</p>
<pre><code> win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);
</code></pre>
<p>调用的是WindowState的setFrames方法<br>入参说明：<br><code>sTmpClientFrames</code>：在computeFrames方法计算后的值，用于传递的窗口位置大小相关信息<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    void setFrames(ClientWindowFrames clientWindowFrames, int requestedWidth, int requestedHeight) &#123;
        final WindowFrames windowFrames = mWindowFrames;
        //用mTmpRect存储windowFrames.mParentFrame
        mTmpRect.set(windowFrames.mParentFrame);
        
        //LOCAL_LAYOUTd的值取决于配置项persist.debug.local_layout的值
        if (LOCAL_LAYOUT) &#123;
            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。
            windowFrames.mCompatFrame.set(clientWindowFrames.frame);
            
            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。
            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。
            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。
            windowFrames.mFrame.set(clientWindowFrames.frame);
            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);
            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);
            if (hasCompatScale()) &#123;
                // The frames sent from the client need to be adjusted to the real coordinate space.
                //如果存在兼容比例（通过调用hasCompatScale()方法检查），则对windowFrames中的Frame进行缩放，以适应实际的坐标空间。
                //这里使用mGlobalScale作为缩放因子。
                windowFrames.mFrame.scale(mGlobalScale);
                windowFrames.mDisplayFrame.scale(mGlobalScale);
                windowFrames.mParentFrame.scale(mGlobalScale);
            &#125;
        &#125; else &#123;
            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。
            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。
            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。
            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);
            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);
            windowFrames.mFrame.set(clientWindowFrames.frame);

            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。
            windowFrames.mCompatFrame.set(windowFrames.mFrame);
            if (hasCompatScale()) &#123;
                // Also, the scaled frame that we report to the app needs to be adjusted to be in
                // its coordinate space.
                //仅对windowFrames.mCompatFrame缩放
                windowFrames.mCompatFrame.scale(mInvGlobalScale);
            &#125;
        &#125;
        //isParentFrameClippedByDisplayCutout是一个Boolean
        //如果为true，表示父窗口的边界被显示切边裁剪了；如果为false，表示父窗口的边界没有被显示切边裁剪。
        windowFrames.setParentFrameWasClippedByDisplayCutout(
                clientWindowFrames.isParentFrameClippedByDisplayCutout);

        // Calculate relative frame
        //将mRelFrame设置为与mFrame相同的值。这意味着mRelFrame现在存储了与mFrame相同的位置和尺寸信息。
        windowFrames.mRelFrame.set(windowFrames.mFrame);
        //获取当前窗口的父容器
        WindowContainer&lt;?&gt; parent = getParent();
        //初始化parentLeft和parentTop为0，表示父容器的左上角坐标
        int parentLeft = 0;
        int parentTop = 0; 
        if (mIsChildWindow) &#123;//如果当前窗口是一个子窗口
            //从父窗口的状态中获取其边界的位置信息。
            parentLeft = ((WindowState) parent).mWindowFrames.mFrame.left;
            parentTop = ((WindowState) parent).mWindowFrames.mFrame.top;
        &#125; else if (parent != null) &#123;//如果当前窗口不是子窗口，并且父容器不为空
            //获取父容器的边界位置
            final Rect parentBounds = parent.getBounds();
            parentLeft = parentBounds.left;
            parentTop = parentBounds.top;
        &#125;
        //调整mRelFrame的位置，使其相对于父容器的左上角有一个偏移
        windowFrames.mRelFrame.offsetTo(windowFrames.mFrame.left - parentLeft,
                windowFrames.mFrame.top - parentTop);

        //如果请求的宽度、高度或者父框架与上次不同
        if (requestedWidth != mLastRequestedWidth || requestedHeight != mLastRequestedHeight
                || !mTmpRect.equals(windowFrames.mParentFrame)) &#123;
            //更新最后请求的宽度和高度，并标记内容已更改
            mLastRequestedWidth = requestedWidth;
            mLastRequestedHeight = requestedHeight;
            windowFrames.setContentChanged(true);
        &#125;
        //如果窗口的类型是TYPE_DOCK_DIVIDER，并且边界的位置发生了变化，mMovedByResize标记为true。
        //在分屏的场合，YPE_DOCK_DIVIDER窗口类型用于绘制这个分隔栏，并处理用户的触摸事件以实现大小调整功能。
        if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;
            if (!windowFrames.mFrame.equals(windowFrames.mLastFrame)) &#123;
                mMovedByResize = true;
            &#125;
        &#125;
        
        //如果当前窗口是壁纸，并且框架的宽度或高度发生了变化，更新壁纸的位置。
        if (mIsWallpaper) &#123;
            final Rect lastFrame = windowFrames.mLastFrame;
            final Rect frame = windowFrames.mFrame;
            if (lastFrame.width() != frame.width() || lastFrame.height() != frame.height()) &#123;
                mDisplayContent.mWallpaperController.updateWallpaperOffset(this, false /* sync */);
            &#125;
        &#125;
        
        //更新windowFrames.mFrame
        updateSourceFrame(windowFrames.mFrame);

        //如果定义了LOCAL_LAYOUT，并且还没有边界，更新最后边界的位置。
        if (LOCAL_LAYOUT) &#123;
            if (!mHaveFrame) &#123;
                // The first frame should not be considered as moved.
                updateLastFrames();
            &#125;
        &#125;
        
        //如果存在活动记录，并且当前窗口不是子窗口
        if (mActivityRecord != null &amp;&amp; !mIsChildWindow) &#123;
            //调用mActivityRecord.layoutLetterbox(this);来填充空白区域。也就是Letterbox模式
            mActivityRecord.layoutLetterbox(this);
        &#125;
        //设置mSurfacePlacementNeeded为true。
        mSurfacePlacementNeeded = true;
        //设置mHaveFrame为true，表示已经设置了边界
        mHaveFrame = true;
    &#125;
</code></pre>
<p>其中WindowFrames 是一个表示窗口边框大小和位置的类。<br>WindowFrames 中有一些重要成员变量，用于描述不同的窗口区域。</p>
<p><code>mFrame</code>表示窗口在屏幕上的位置和大小，是窗口管理和界面绘制的基础依据。<br><code>mVisibleFrame</code>表示窗口可见区域的位置和大小，即除去状态栏和导航栏等系统 UI 元素后，窗口实际可以显示的区域。<br><code>mDecorFrame</code>表示窗口装饰区域的位置和大小，即窗口除去实际内容区域外，包含的标题栏、边框、按钮等 UI 元素所占用的空间。<br><code>mDisplayFrame</code>表示整个屏幕的可见区域的位置和大小，也就是说它包含了状态栏和导航栏等系统 UI 元素。</p>
<p>这些成员变量共同描述了窗口在屏幕中的位置和大小，并提供给其他模块使用，比如 WindowManager 和 View 系统。<br>在 Android Framework 中，WindowManagerService 会在每次窗口大小发生变化时，调用 WindowFrames 的 setFrames() 方法，更新这些成员变量的值。</p>
<h4 id="2-3-窗口状态刷新"><a href="#2-3-窗口状态刷新" class="headerlink" title="2.3 窗口状态刷新"></a>2.3 窗口状态刷新</h4><p>当应用端执行measure-layout-draw之后，便会调用<strong>WindowManagerService.finishDrawingWindow</strong>，处理Surface的状态变更并将Surface show出来。<br>首先还是看一下该阶段的流程图，对整个流程有个初步的了解。<br>将整个流程分为三部分：<br>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PENDING，并请求窗口布局。<br>2.mDrawState更新为HAS_DRAW，再次请求窗口布局。<br>3.执行show Surface。</p>
<h5 id="2-3-1-接受客户端请求"><a href="#2-3-1-接受客户端请求" class="headerlink" title="2.3.1 接受客户端请求"></a>2.3.1 接受客户端请求</h5><p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p>
<pre><code>    @Override
    public void finishDrawing(IWindow window,
            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;
        if (DEBUG) Slog.v(TAG_WM, &quot;IWindow finishDrawing called for &quot; + window);
        //调用WMS中的finishDrawingWindow处理
        mService.finishDrawingWindow(this, window, postDrawTransaction, seqId);
    &#125;
</code></pre>
<h5 id="2-3-2-finishDrawingWindow"><a href="#2-3-2-finishDrawingWindow" class="headerlink" title="2.3.2 finishDrawingWindow"></a>2.3.2 finishDrawingWindow</h5><p>1.在WMS中根据客户端的Binder在mWindowMap中获取对应的WindowState。<br>2.调用WindowState.finishDrawing执行mDrawState的状态变更。<br>3.将WindowState.mLayoutNeeded标志位置为true。<br>4.请求进行布局刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p>
<pre><code>    void finishDrawingWindow(Session session, IWindow client,
            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;
        if (postDrawTransaction != null) &#123;
            postDrawTransaction.sanitize();
        &#125;

        final long origId = Binder.clearCallingIdentity();
        try &#123;
            synchronized (mGlobalLock) &#123;
                /*1.根据客户端的Binder在mWindowMap中获取对应的WindowState*/
                WindowState win = windowForClientLocked(session, client, false);
                ProtoLog.d(WM_DEBUG_ADD_REMOVE, &quot;finishDrawingWindow: %s mDrawState=%s&quot;,
                        win, (win != null ? win.mWinAnimator.drawStateToString() : &quot;null&quot;));
                /*2.finishDrawing执行mDrawState的状态更变*/
                if (win != null &amp;&amp; win.finishDrawing(postDrawTransaction, seqId)) &#123;
                    if (win.hasWallpaper()) &#123;
                        win.getDisplayContent().pendingLayoutChanges |=
                                WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                    &#125;
                    /*3.将当前WindowState.mLayoutNeeded置为true*/
                    //该标志位是判断是否进行窗口大小尺寸计算的条件之一
                    win.setDisplayLayoutNeeded();
                    /*4.请求进行布局刷新*/
                    mWindowPlacerLocked.requestTraversal();
                &#125;
            &#125;
        &#125; finally &#123;
            Binder.restoreCallingIdentity(origId);
        &#125;
    &#125;
</code></pre>
<h6 id="1-mDrawState的状态更变"><a href="#1-mDrawState的状态更变" class="headerlink" title="1.mDrawState的状态更变"></a>1.mDrawState的状态更变</h6><p>在finishDrawingWindow中调用WindowState的finishDrawing方法<br><code>win.finishDrawing(postDrawTransaction, seqId)</code><br>这个方法主要调用了WindowStateAnimator的finishDrawingLocked进行状态更变<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>   boolean finishDrawing(SurfaceControl.Transaction postDrawTransaction, int syncSeqId) &#123;
           ......
           //调用WindowStateAnimator.finishDrawingLocked，会将mDrawState的状态更改为COMMIT_DRAW_PENDING
        final boolean layoutNeeded =
                mWinAnimator.finishDrawingLocked(postDrawTransaction, mClientWasDrawingForSync);
        mClientWasDrawingForSync = false;
        // We always want to force a traversal after a finish draw for blast sync.
        return !skipLayout &amp;&amp; (hasSyncHandlers || layoutNeeded);
    &#125;
</code></pre>
<p>我们继续看看WindowStateAnimator中的finishDrawingLocked()方法<br>首先判断mDrawState的状态是否为DRAW_PENDING，在我们创建SurfaceControl时，会将mDrawState状态更新为DRAW_PENDING。因此接下来将状态调整为COMMIT_DRAW_PENDING。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>    boolean finishDrawingLocked(SurfaceControl.Transaction postDrawTransaction,
            boolean forceApplyNow) &#123;
        ......
        boolean layoutNeeded = false;

        if (mDrawState == DRAW_PENDING) &#123;
            ......
            //如果当前状态为DRAW_PENDING，则将mDrawState更变为COMMIT_DRAW_PENDING
            mDrawState = COMMIT_DRAW_PENDING;
            layoutNeeded = true;
        &#125;
        ......
        return layoutNeeded;
    &#125;
</code></pre>
<h6 id="2-请求布局刷新"><a href="#2-请求布局刷新" class="headerlink" title="2.请求布局刷新"></a>2.请求布局刷新</h6><p>在finishDrawingWindow中请求布局刷新<br><code>mWindowPlacerLocked.requestTraversal();</code><br>requestTraversal中主要做了两件事：<br>1.首先将遍历标志为mTraversalSchedule置为true。<br>2.其次发送handle消息mPerformSurfacePlacement</p>
<pre><code>    void requestTraversal() &#123;
        //判断遍历标志mTraversalScheduled是否为true
        if (mTraversalScheduled) &#123;
            return;
        &#125;

        // Set as scheduled even the request will be deferred because mDeferredRequests is also
        // increased, then the end of deferring will perform the request.
        //将遍历标志位置为true
        mTraversalScheduled = true;
        if (mDeferDepth &gt; 0) &#123;
            mDeferredRequests++;
            if (DEBUG) Slog.i(TAG, &quot;Defer requestTraversal &quot; + Debug.getCallers(3));
            return;
        &#125;
        //发送handle消息，处理消息会调用mPerformSurfacePlacement
        mService.mAnimationHandler.post(mPerformSurfacePlacement);
    &#125;
</code></pre>
<p>mPerformSurfacePlacement会新建一个线程调用performSurfacePlacement。<br>performSurfacePlacement方法我们在讲relayoutWindow相关流程的时候讲过，这是执行遍历布局的入口。可以回看下【<strong>2.2.4 计算窗口大小位置中的“1.处理窗口布局循环”</strong>】</p>
<pre><code>    private class Traverser implements Runnable &#123;
        @Override
        public void run() &#123;
            synchronized (mService.mGlobalLock) &#123;
                //调用执行performSurfacePlacement
                performSurfacePlacement();
            &#125;
        &#125;
    &#125;

    private final Traverser mPerformSurfacePlacement = new Traverser();
    
    final void performSurfacePlacement(boolean force) &#123;
        //当mDeferDepth大于0且force为false时，则将延迟布局请求数+1，并直接返回
        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;
            mDeferredRequests++;
            return;
        &#125;
        //将循环的最大次数设置为6次
        int loopCount = 6;
        do &#123;
            //将该标志为设置为false
            mTraversalScheduled = false;
            //执行窗口布局操作
            performSurfacePlacementLoop();
            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);
            loopCount--;
        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局
        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);
        mService.mRoot.mWallpaperActionPending = false;
    &#125;

    private void performSurfacePlacementLoop() &#123;
        //若当前已经进行布局操作，则无需重复调用直接返回
        if (mInLayout) &#123;
            ......
            return;
        &#125;
        ......
        //将该标志位置为true，表示正在处于布局过程中
        mInLayout = true;
        ......
        try &#123;
            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/
            mService.mRoot.performSurfacePlacement();

            mInLayout = false;

            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;

            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;
                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);
                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);
            &#125;
        &#125; catch (RuntimeException e) &#123;
            mInLayout = false;
            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);
        &#125;
    &#125;
</code></pre>
<p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    void performSurfacePlacement() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);
        try &#123;
            //调用performSurfacePlacementNoTrace()
            performSurfacePlacementNoTrace();
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;

    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;
    // TODO: Super long method that should be broken down...
    void performSurfacePlacementNoTrace() &#123;
        ......
        /*1.如果有焦点变化，更新焦点*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(
                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);
        &#125;
        ......
        
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);
        //开启事务，获取GlobalTransactionWrapper对象
        mWmService.openSurfaceTransaction();
        try &#123;
            /*2.执行窗口尺寸计算，surface状态变更等操作*/
            applySurfaceChangesTransaction();
        &#125; catch (RuntimeException e) &#123;
            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);
        &#125; finally &#123;
            //关闭事务，把事务提交
            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
            if (SHOW_LIGHT_TRANSACTIONS) &#123;
                Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);
            &#125;
        &#125;
        ......
        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/
        checkAppTransitionReady(surfacePlacer);
        ......
        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/
        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;
            final DisplayContent displayContent = mChildren.get(displayNdx);
            //判断DisplayContent的壁纸是否需要改变
            if (displayContent.mWallpaperMayChange) &#123;
                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);
                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,
                            displayContent.pendingLayoutChanges);
                &#125;
            &#125;
        &#125;
        /*5.在此处理焦点变化*/
        if (mWmService.mFocusMayChange) &#123;
            mWmService.mFocusMayChange = false;
            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
                    false /*updateInputWindows*/);
        &#125;
        ......
        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/
        handleResizingWindows();

        if (mWmService.mDisplayFrozen) &#123;
            ProtoLog.v(WM_DEBUG_ORIENTATION,
                    &quot;With display frozen, orientationChangeComplete=%b&quot;,
                    mOrientationChangeComplete);
        &#125;
        if (mOrientationChangeComplete) &#123;
            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;
                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;
                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
            &#125;
            mWmService.stopFreezingDisplayLocked();
        &#125;

        // Destroy the surface of any windows that are no longer visible.
        /*7.销毁不可见的窗口*/
        i = mWmService.mDestroySurface.size();
        if (i &gt; 0) &#123;
            do &#123;
                i--;
                WindowState win = mWmService.mDestroySurface.get(i);
                win.mDestroying = false;
                final DisplayContent displayContent = win.getDisplayContent();
                if (displayContent.mInputMethodWindow == win) &#123;
                    displayContent.setInputMethodWindowLocked(null);
                &#125;
                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;
                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
                &#125;
                win.destroySurfaceUnchecked();
            &#125; while (i &gt; 0);
            mWmService.mDestroySurface.clear();
        &#125;
        ......
    &#125;
</code></pre>
<p>​    </p>
<p>这里我们主要关注<code>applySurfaceChangesTransaction();</code>和<code>checkAppTransitionReady(surfacePlacer);</code></p>
<h6 id="窗口位置计算与窗口状态刷新流程不同点"><a href="#窗口位置计算与窗口状态刷新流程不同点" class="headerlink" title="* 窗口位置计算与窗口状态刷新流程不同点"></a>* 窗口位置计算与窗口状态刷新流程不同点</h6><p>可以发现，窗口位置计算流程与窗口状态刷新流程都调用了performSurfacePlacement，两次调用的主要不同点在于：<br>1.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用mApplySurfaceChangesTransaction，处理mDrawState状态。<br>2.窗口状态刷新流程在RootWindowContainer.performSurfacePlacementNoTrace中调用checkAppTransitionReady，处理mDrawState状态变更为HAS_DRAWN，触发Activity过渡动画。<br>3.窗口状态刷新流程在WindowSurfacePlacementLoop.performSurfacePlacementLoop中会调用requestTraversal，请求再次布局。<br>4.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用prepareSurfaces()处理处理surface的位置、大小以及显示等。</p>
<h5 id="2-3-3-mDrawState变更为HAS-DRAW"><a href="#2-3-3-mDrawState变更为HAS-DRAW" class="headerlink" title="2.3.3 mDrawState变更为HAS_DRAW"></a>2.3.3 mDrawState变更为HAS_DRAW</h5><h6 id="1-mApplySurfaceChangesTransaction"><a href="#1-mApplySurfaceChangesTransaction" class="headerlink" title="1.mApplySurfaceChangesTransaction"></a>1.mApplySurfaceChangesTransaction</h6><p>RootWindowContainer的applySurfaceChangesTransaction()方法最终会调用到DisplayContent中调用的applySurfaceChangesTransaction()方法（【2.2.4 计算窗口大小位置】中讲过流程，不再赘述）<br>我们接着该方法中的mApplySurfaceChangesTransaction跟踪。<br><code>forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);</code><br>如果当前WindowState存在surfaceControl，则进入到WindowStateAnimator进行mDrawState的状态更变。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;
        ......
        //首先判断当前windowState的是否有surfaceControl
        if (w.mHasSurface) &#123;
            // Take care of the window being ready to display.
            //调用WindowStateAnimator的commitFinishDrawingLocked()方法
            final boolean committed = winAnimator.commitFinishDrawingLocked();
            ......
        &#125;
        ......
    &#125;;
</code></pre>
<p>继续看看WindowStateAnimator的commitFinishDrawingLocked()方法<br><code>final boolean committed = winAnimator.commitFinishDrawingLocked();</code><br>1.对mDrawState的状态进行过滤，非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回。<br>2.此时我们的mDrawState已经在“<strong>【2.3.2 finishDrawingWindow】</strong>”将状态更新为COMMIT_DRAW_PENDING，因此此处将其变更为READY_TO_SHOW。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>    // This must be called while inside a transaction.
    boolean commitFinishDrawingLocked() &#123;
        //非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回
        if (mDrawState != COMMIT_DRAW_PENDING &amp;&amp; mDrawState != READY_TO_SHOW) &#123;
            return false;
        &#125;
        ProtoLog.i(WM_DEBUG_ANIM, &quot;commitFinishDrawingLocked: mDrawState=READY_TO_SHOW %s&quot;,
                mSurfaceController);
        //将状态更变为READY_TO_SHOW
        mDrawState = READY_TO_SHOW;
        boolean result = false;
        final ActivityRecord activity = mWin.mActivityRecord;
        //直接进入到WindowState.performShowLocked()流程的三种情况
        //1.如果ActivityRecord为空，这种情况可以理解为不依赖Activity的窗口，比如常见的悬浮窗
        //2.或者canShowWindows()为true，这个方法大概是说：只有当所有窗口都已绘制完成，并且没有正在进行父级窗口的应用过渡动画，并且没有非默认颜色的窗口存在时，返回true
        //3.或者窗口类型为启动窗口，启动窗口就是StartingWindow，应用启动时出现的窗口，常见的就是Splash screen ，许多应用都会定义自己的SplashActivity
        //进入performShowLocked()流程后mDrawState更新HAS_DRAWN
        //由于非这三种情况最终也会调用到performShowLocked()，因此下面这种情况我们暂不讨论
        if (activity == null || activity.canShowWindows()
                || mWin.mAttrs.type == TYPE_APPLICATION_STARTING) &#123;
            result = mWin.performShowLocked();
        &#125;
        return result;
    &#125;
</code></pre>
<h6 id="2-checkAppTransitionReady"><a href="#2-checkAppTransitionReady" class="headerlink" title="2.checkAppTransitionReady()"></a>2.checkAppTransitionReady()</h6><p>这里我们继续跟踪RootWindowContainer.performSurfacePlacementNoTrace()方法中的checkAppTransitionReady()方法<br><code>checkAppTransitionReady(surfacePlacer);</code><br>该方法会遍历所有DisplayContent，处理activity的过滤动画，此处我们只有跟踪有关mDrawState状态更变的相关代码<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p>
<pre><code>    private void checkAppTransitionReady(WindowSurfacePlacer surfacePlacer) &#123;
        // Trace all displays app transition by Z-order for pending layout change.
        for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123;
            final DisplayContent curDisplay = mChildren.get(i);

            // If we are ready to perform an app transition, check through all of the app tokens
            // to be shown and see if they are ready to go.
            //检查所有要显示的app token，是否已经准备就绪
            if (curDisplay.mAppTransition.isReady()) &#123;
                // handleAppTransitionReady may modify curDisplay.pendingLayoutChanges.
                curDisplay.mAppTransitionController.handleAppTransitionReady();
                if (DEBUG_LAYOUT_REPEATS) &#123;
                    surfacePlacer.debugLayoutRepeats(&quot;after handleAppTransitionReady&quot;,
                            curDisplay.pendingLayoutChanges);
                &#125;
            &#125;
            ......
        &#125;
    &#125;
</code></pre>
<p>调用AppTransitionController的handleAppTransitionReady()方法，该方法主要做了以下事情<br>1.处理activity的过渡动画（远程动画）<br>2.分别调用 handleClosingApps以及handleOpeningApps对要关闭的和要打开的Activity进行可见性更新。<br>3.由于activity的可见性变更，将DisplayContent.mLayoutNeeded设置为true，该标志位在DisplayContent.performLayoutNoTrace中用来判断是否对当前DisplayContent下的所有窗口进行刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;AppTransitionController.java</p>
<pre><code>    /**
     * Handle application transition for given display.
     */
    void handleAppTransitionReady() &#123;
        ......
        try &#123;
            /*1.1应用app transition动画（远程动画）*/
            applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,
                    voiceInteraction);
            /*1.2处理closing activity可见性*/
            handleClosingApps();
            /*1.3处理opening actvity可见性*/
            handleOpeningApps();
            ......
        &#125; finally &#123;
            mService.mSurfaceAnimationRunner.continueStartingAnimations();
        &#125;
        ......

        // This has changed the visibility of windows, so perform
        // a new layout to get them all up-to-date.
        /*2.由于activity的可见性变更，将DisplayContent.mLayoutNeeded标志位置为true*/
        mDisplayContent.setLayoutNeeded();
        ......
    &#125;
</code></pre>
<p><strong>applyAnimations()</strong><br>基于一组ActivityRecord来应用动画，这些ActivityRecord表示正在进行切换的应用程序。<br><code>applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,voiceInteraction);</code></p>
<pre><code>    /**
     * Apply an app transition animation based on a set of &#123;@link ActivityRecord&#125;
     *
     * @param openingApps The list of opening apps to which an app transition animation applies.
     * @param closingApps The list of closing apps to which an app transition animation applies.
     * @param transit The current transition type.
     * @param animLp Layout parameters in which an app transition animation runs.
     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice
     *                         interaction session driving task.
     */
    private void applyAnimations(ArraySet&lt;ActivityRecord&gt; openingApps,
            ArraySet&lt;ActivityRecord&gt; closingApps, @TransitionOldType int transit,
            LayoutParams animLp, boolean voiceInteraction) &#123;
        //方法检查过渡类型是否未设置，或者打开和关闭的应用程序是否都为空。如果是，则方法直接返回，不执行任何动画。
        if (transit == WindowManager.TRANSIT_OLD_UNSET
                || (openingApps.isEmpty() &amp;&amp; closingApps.isEmpty())) &#123;
            return;
        &#125;

        //调用getAnimationTargets方法获取打开和关闭的窗口容器（WindowContainer）
        final ArraySet&lt;WindowContainer&gt; openingWcs = getAnimationTargets(
                openingApps, closingApps, true /* visible */);
        final ArraySet&lt;WindowContainer&gt; closingWcs = getAnimationTargets(
                openingApps, closingApps, false /* visible */);
        //打开和关闭的窗口应用动画。这是通过调重载的applyAnimations方法完成的，传递相应的参数，如动画的目标、过渡类型等。
        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,
                voiceInteraction);
        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,
                voiceInteraction);
        //如果存在最近任务动画控制器（RecentsAnimationController），则发送任务出现任务
        final RecentsAnimationController rac = mService.getRecentsAnimationController();
        if (rac != null) &#123;
            rac.sendTasksAppeared();
        &#125;

        //遍历打开和关闭的应用程序，并设置mOverrideTaskTransition为false
        for (int i = 0; i &lt; openingApps.size(); ++i) &#123;
            openingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;
        &#125;
        for (int i = 0; i &lt; closingApps.size(); ++i) &#123;
            closingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;
        &#125;

        //如果存在辅助功能控制器（AccessibilityController）且有回调，则调用其onAppWindowTransition方法。
        final AccessibilityController accessibilityController =
                mDisplayContent.mWmService.mAccessibilityController;
        if (accessibilityController.hasCallbacks()) &#123;
            accessibilityController.onAppWindowTransition(mDisplayContent.getDisplayId(), transit);
        &#125;
    &#125;
</code></pre>
<p>入参含义：<br><code>openingApps</code> 和 <code>closingApps</code>: 这两个参数是ActivityRecord类型的数组，分别表示正在打开和关闭的应用程序，即这些ActivityRecord表示正在进行切换的应用程序。<br><code>transit</code>: 这是一个整型参数，表示过渡类型。例如，WindowManager.TRANSIT_OLD_UNSET表示没有特定的过渡类型。<br><code>animLp</code>: 这是一个LayoutParams对象，用于定义窗口的布局参数。<br><code>voiceInteraction</code>: 一个布尔值，表示是否为语音交互。</p>
<p>总而言之，该方法主要负责处理应用程序窗口的打开和关闭动画。它确保应用程序在切换时有一个平滑的视觉效果，为用户提供更好的体验。最后还与辅助功能服务交互，确保辅助功能用户也能正确地感知应用程序窗口的切换。</p>
<p>再来说说其中调用的applyAnimations方法部分</p>
<pre><code>        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,
                voiceInteraction);
        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,
                voiceInteraction);
</code></pre>
<p>调用的是重载的applyAnimations方法</p>
<pre><code>      /**
     * Apply animation to the set of window containers.
     *
     * @param wcs The list of &#123;@link WindowContainer&#125;s to which an app transition animation applies.
     * @param apps The list of &#123;@link ActivityRecord&#125;s being transitioning.
     * @param transit The current transition type.
     * @param visible &#123;@code true&#125; if the apps becomes visible, &#123;@code false&#125; if the apps becomes
     *                invisible.
     * @param animLp Layout parameters in which an app transition animation runs.
     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice
     *                         interaction session driving task.
     */
    private void applyAnimations(ArraySet&lt;WindowContainer&gt; wcs, ArraySet&lt;ActivityRecord&gt; apps,
            @TransitionOldType int transit, boolean visible, LayoutParams animLp,
            boolean voiceInteraction) &#123;
        //获取窗口容器的数量
        final int wcsCount = wcs.size();
        //遍历每一个窗口容器
        for (int i = 0; i &lt; wcsCount; i++) &#123;
            final WindowContainer wc = wcs.valueAt(i);
            // If app transition animation target is promoted to higher level, SurfaceAnimator
            // triggers WC#onAnimationFinished only on the promoted target. So we need to take care
            // of triggering AR#onAnimationFinished on each ActivityRecord which is a part of the
            // app transition.
            //对于每一个窗口容器，检查正在进行切换的应用程序（apps）中哪些是该窗口容器的后代。
            //这些后代应用程序将被添加到一个列表中。
            final ArrayList&lt;ActivityRecord&gt; transitioningDescendants = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt; apps.size(); ++j) &#123;
                final ActivityRecord app = apps.valueAt(j);
                if (app.isDescendantOf(wc)) &#123;
                    transitioningDescendants.add(app);
                &#125;
            &#125;
            //调用每个窗口容器的applyAnimation方法，传入相应的参数（如动画的布局参数、过渡类型、是否可见等）以及后代应用程序的列表。
            wc.applyAnimation(animLp, transit, visible, voiceInteraction, transitioningDescendants);
        &#125;
    &#125;
</code></pre>
<p>入参含义：<br><code>wcs</code>: 一个WindowContainer对象的集合，这些对象是需要应用动画的窗口容器。<br><code>apps</code>: 一个ActivityRecord对象的集合，这些对象表示正在进行切换的应用程序。<br><code>transit</code>: 当前的过渡类型，例如淡入淡出、滑动等。<br><code>visible</code>: 一个布尔值，表示应用程序是否变为可见。<br><code>animLp</code>: 布局参数，定义了动画运行时的布局。<br><code>voiceInteraction</code>: 一个布尔值，表示是否有语音交互。</p>
<p>这部分远程动画流程，这里不做重点</p>
<p><strong>handleClosingApps()</strong><br>该方法中主要的作用就是将所有即将close的activity的mVisible标志设置为false。该标志位在后续prepareSurfaces中是判断是否show surface的条件之一。</p>
<pre><code>   private void handleClosingApps() &#123;
        final ArraySet&lt;ActivityRecord&gt; closingApps = mDisplayContent.mClosingApps;
        final int appsCount = closingApps.size();

        for (int i = 0; i &lt; appsCount; i++) &#123;
            final ActivityRecord app = closingApps.valueAt(i);
            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now closing app %s&quot;, app);
            //设置activity的可见性，将mVisible设置为false
            app.commitVisibility(false /* visible */, false /* performLayout */);
            app.updateReportedVisibilityLocked();
            // Force the allDrawn flag, because we want to start
            // this guy&#39;s animations regardless of whether it&#39;s
            // gotten drawn.
            //强制将allDrawn设置为true
            app.allDrawn = true;
            ......
        &#125;
    &#125;
</code></pre>
<p><strong>handleOpeningApps()</strong><br>该方法与handleClosingApps方法类似,主要处理两件事情：<br>1.将所有即将open的activity的mVisible标志位设置为true.<br>2.调用ActivityRecord.showAllWindowsLocked()，最终会调用到WindowState.performShowLocked() ，处理mDrawState的状态变更</p>
<pre><code>    private void handleOpeningApps() &#123;
        final ArraySet&lt;ActivityRecord&gt; openingApps = mDisplayContent.mOpeningApps;
        final int appsCount = openingApps.size();

        for (int i = 0; i &lt; appsCount; i++) &#123;
            final ActivityRecord app = openingApps.valueAt(i);
            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now opening app %s&quot;, app);
            /*1.设置activity的可见性，将mVisible设置为true*/
            app.commitVisibility(true /* visible */, false /* performLayout */);
            ......
            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
                    &quot;&gt;&gt;&gt; OPEN TRANSACTION handleAppTransitionReady()&quot;);
            //开启事务
            mService.openSurfaceTransaction();
            try &#123;
                /*2.此方法最终会调用到WindowState.performShowLocked*/
                app.showAllWindowsLocked();
            &#125; finally &#123;
            //关闭事务
            mService.closeSurfaceTransaction(&quot;handleAppTransitionReady&quot;);
                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION handleAppTransitionReady()&quot;);
            &#125;
            ......
        &#125;
    &#125;
</code></pre>
<p><code>app.showAllWindowsLocked();</code>先调用到ActivityRecord的showAllWindowsLocked()<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p>
<pre><code>    /**
     * This must be called while inside a transaction.
     */
    void showAllWindowsLocked() &#123;
        forAllWindows(windowState -&gt; &#123;
            if (DEBUG_VISIBILITY) Slog.v(TAG, &quot;performing show on: &quot; + windowState);
            windowState.performShowLocked();
        &#125;, false /* traverseTopToBottom */);
    &#125;
</code></pre>
<p><code>windowState.performShowLocked();</code>再调用到WindowState的performShowLocked()<br>将mDrawState的状态由READY_TO_SHOW变更为HAS_DRAW<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    // This must be called while inside a transaction.
    boolean performShowLocked() &#123;
        ......
        //获取WindowStateAnimator.mDrawState
        final int drawState = mWinAnimator.mDrawState;
        //这里判断（drawState 状态为HAS_DRAWN 或者READY_TO_SHOW）且ActivityRecord不为空
        if ((drawState == HAS_DRAWN || drawState == READY_TO_SHOW) &amp;&amp; mActivityRecord != null) &#123;
            //窗口类型不为启动窗口
            if (mAttrs.type != TYPE_APPLICATION_STARTING) &#123;
                mActivityRecord.onFirstWindowDrawn(this);
            &#125; else &#123;
                mActivityRecord.onStartingWindowDrawn();
            &#125;
        &#125;
        //如果当前mDrawState的状态不为READY_TO_SHOW ，则直接返回
        if (mWinAnimator.mDrawState != READY_TO_SHOW || !isReadyForDisplay()) &#123;
            return false;
        &#125;
        ......
        //走入窗口动画流程
        mWinAnimator.applyEnterAnimationLocked();
        
        // Force the show in the next prepareSurfaceLocked() call.
        mWinAnimator.mLastAlpha = -1;
        ProtoLog.v(WM_DEBUG_ANIM, &quot;performShowLocked: mDrawState=HAS_DRAWN in %s&quot;, this);
        //设置mDrawState的状态为HAS_DRAWN
        mWinAnimator.mDrawState = HAS_DRAWN;
        mWmService.scheduleAnimationLocked();
        ......
        return true;
    &#125;
</code></pre>
<p>添加窗口时，会调用这个<code>mWinAnimator.applyEnterAnimationLocked();</code>窗口动画的方法，然后调用到<code>applyAnimationLocked()</code>；窗口移除时，会直接调用<code>applyAnimationLocked()</code>显示动画。可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/yimelancholy/article/details/134289284?spm=1001.2014.3001.5502">Android T窗口动画显示和退出流程</a></p>
<h6 id="3-再次请求布局"><a href="#3-再次请求布局" class="headerlink" title="3.再次请求布局"></a>3.再次请求布局</h6><p>回到WindowSurfacePlacer中通过requestTraversals()，再次请求布局，该方法将mTraversalScheduled标志位设置为true的判断条件有两个：<br>1.遍历所有DisplayContent.mLayoutNeeded标志为是否为true。（由于AppTransitionController.handleAppTransitionReady阶段已经将mLayoutNeeded置为true，因此该条件为真）<br>2.重复布局的次数不能超过6次，该条件也为真。（因为当前还只是第一次布局)<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p>
<pre><code>    private void performSurfacePlacementLoop() &#123;
        ......
        try &#123;
            ......
            /*1.遍历所有DisplayContent.mLayoutNeeded标志位是否为true*/
            if (mService.mRoot.isLayoutNeeded()) &#123;
                /*2.如果需要布局，且布局次数小于6次，则需要再次请求布局*/
                if (++mLayoutRepeatCount &lt; 6) &#123;
                    //该方法中会将mTraversalScheduled标志位设置位true
                    requestTraversal();
                &#125; else &#123;
                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);
                    mLayoutRepeatCount = 0;
                &#125;
            &#125; else &#123;
                mLayoutRepeatCount = 0;
            &#125;
            ......
        &#125; catch (RuntimeException e) &#123;
        ......
        &#125;
    &#125;
</code></pre>
<p>接下来进入<strong>第二次布局循环</strong>，其主要目的是为了show surface</p>
<h5 id="2-3-4-show-Surface"><a href="#2-3-4-show-Surface" class="headerlink" title="2.3.4 show Surface"></a>2.3.4 show Surface</h5><p>在第二次循环中，我们主要关注DisplayContent中applySurfaceChangesTransaction()方法调用的prepareSurfaces()</p>
<p>该方法最终会调用到根容器WindowContainer，来遍历所有子容器中的prepareSurfaces。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p>
<pre><code>    @Override
    void prepareSurfaces() &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;prepareSurfaces&quot;);
        try &#123;
            //获取事务
            final Transaction transaction = getPendingTransaction();
            //调用其父类方法
            super.prepareSurfaces();

            // TODO: Once we totally eliminate global transaction we will pass transaction in here
            //       rather than merging to global.
            SurfaceControl.mergeToGlobalTransaction(transaction);
        &#125; finally &#123;
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        &#125;
    &#125;
</code></pre>
<p>调用其父类方法<code>super.prepareSurfaces();</code><br>DisplayContent的父类为WindowContainer<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p>
<pre><code>    void prepareSurfaces() &#123;
        // If a leash has been set when the transaction was committed, then the leash reparent has
        // been committed.
        mCommittedReparentToAnimationLeash = mSurfaceAnimator.hasLeash();
        //调用所有子容器中的prepareSurfaces
        for (int i = 0; i &lt; mChildren.size(); i++) &#123;
            mChildren.get(i).prepareSurfaces();
        &#125;
    &#125;
</code></pre>
<p><code>mChildren.get(i).prepareSurfaces();</code>在WindowState.prepareSurfaces中，主要做了两方面工作。<br>1.将mWindowFrames中计算出来的left以及top设置surface位置，并调整窗口比例。<br>2.控制surface的可见性，查看WindowStateAnimator.prepareSurfaceLocked<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p>
<pre><code>    void prepareSurfaces() &#123;
        mIsDimming = false;
        applyDims();
        //实际调用的是其父类WindowContainer的方法
        /*1.最终调用自身的updateSurfacePosition()（自身有重写该方法）计算surface的位置*/
        updateSurfacePositionNonOrganized();
        // Send information to SurfaceFlinger about the priority of the current window.
        updateFrameRateSelectionPriorityIfNeeded();
        //更新窗口比例
        updateScaleIfNeeded();

        /*2.控制surface的可见性，调用WindowStateAnimator的prepareSurfaceLocked()方法*/
        mWinAnimator.prepareSurfaceLocked(getSyncTransaction());
        super.prepareSurfaces();
    &#125;
    
    @Override
    @VisibleForTesting
    void updateSurfacePosition(Transaction t) &#123;
        if (mSurfaceControl == null) &#123;
            return;
        &#125;

        //这段代码首先检查布局是否被延迟（通过 isLayoutDeferred() 方法）
        //或者应用是否正在进行布局（通过 isGoneForLayout() 方法）。
        //如果满足这些条件并且 mSurfacePlacementNeeded 为 false，则方法返回，不执行后续操作。
        //这是因为当布局被延迟或应用正在进行布局时，界面的位置可能不是最新的，因此不执行updateSurfacePosition。
        if ((mWmService.mWindowPlacerLocked.isLayoutDeferred() || isGoneForLayout())
                &amp;&amp; !mSurfacePlacementNeeded) &#123;
            // Since this relies on mWindowFrames, changes made while layout is deferred are
            // likely to be invalid. Similarly, if it&#39;s goneForLayout, mWindowFrames may not be
            // up-to-date and thus can&#39;t be relied on.
            return;
        &#125;
        
        //将mSurfacePlacementNeeded设置为false
        mSurfacePlacementNeeded = false;
        //将mSurfacePosition的left以及top设置mWindowFrames中计算出来的left以及top，并根据parent进行偏移
        transformFrameToSurfacePosition(mWindowFrames.mFrame.left, mWindowFrames.mFrame.top,
                mSurfacePosition);
        //根据壁纸的比例对SurfacePosition进行调整
        if (mWallpaperScale != 1f) &#123;
            final Rect bounds = getLastReportedBounds();
            Matrix matrix = mTmpMatrix;
            matrix.setTranslate(mXOffset, mYOffset);
            matrix.postScale(mWallpaperScale, mWallpaperScale, bounds.exactCenterX(),
                    bounds.exactCenterY());
            matrix.getValues(mTmpMatrixArray);
            mSurfacePosition.offset(Math.round(mTmpMatrixArray[Matrix.MTRANS_X]),
                Math.round(mTmpMatrixArray[Matrix.MTRANS_Y]));
        &#125; else &#123;
            mSurfacePosition.offset(mXOffset, mYOffset);
        &#125;
        ......
    &#125;
</code></pre>
<p><code>mWinAnimator.prepareSurfaceLocked(getSyncTransaction());</code> 调用WindowStateAnimator的prepareSurfaceLocked()方法，该则真正的处理触发surface show的逻辑。主要分为两部分。<br>1.将计算的alpha应用于当前surface。<br>2.判断是否调用showSurfaceRobustlyLocked将surface show出来。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p>
<pre><code>   void prepareSurfaceLocked(SurfaceControl.Transaction t) &#123;
        final WindowState w = mWin;
        //首先判断是否有SurfaceControl
        if (!hasSurface()) &#123;
            ......
            return;
        &#125;
        //设置mShowAlpha
        computeShownFrameLocked();

        //判断parentWindow是否hidden，或者当前窗口是否on-screen
        if (w.isParentWindowHidden() || !w.isOnScreen()) &#123;
            ......
        &#125; else if (mLastAlpha != mShownAlpha
                || mLastHidden) &#123;
            mLastAlpha = mShownAlpha;
            ProtoLog.i(WM_SHOW_TRANSACTIONS,
                    &quot;SURFACE controller=%s alpha=%f HScale=%f, VScale=%f: %s&quot;,
                    mSurfaceController, mShownAlpha, w.mHScale, w.mVScale, w);
            /*1.设置surface的alpha*/
            boolean prepared =
                mSurfaceController.prepareToShowInTransaction(t, mShownAlpha);
            //如果当前状态为HAS_DRAWN
            if (prepared &amp;&amp; mDrawState == HAS_DRAWN) &#123;
                if (mLastHidden) &#123;
                /*2.触发show surface*/
                    if (showSurfaceRobustlyLocked(t)) &#123;
                        mAnimator.requestRemovalOfReplacedWindows(w);
                        //设置mLastHidden为false
                        mLastHidden = false;
                        .......
                    &#125; else &#123;
                        w.setOrientationChanging(false);
                    &#125;
                &#125;
            &#125;
        &#125; else &#123;
            if (mWin.isAnimating(TRANSITION | PARENTS)) &#123;
                ProtoLog.v(WM_DEBUG_ANIM, &quot;prepareSurface: No changes in animation for %s&quot;, this);
            &#125;
        &#125;

        ......
    &#125;
</code></pre>
<p>从上述代码中可以看出触发showSurfaceRobustlyLocked的判断条件有以下几点：<br>1.w.isParentWindowHidden判断其parent的mHidden是否为true，此时当前窗口没有parent直接返回false<br>2.w.isOnScreen，判断当前窗口是否在屏幕上，如果该窗口mVisible为true或者在不可见之前正在运行动画，判断为在屏幕上。我们在上次布局的AppTransitionController.handleAppTransitionReady阶段将当前窗口的mVisible置为了true，因此w.isOnScreen返回true。<br>3.mLastAlpha !&#x3D; mShownAlpha以及mLastHidden满足其一即可，此处我们分析mLastHidden，该标志位在创建SurfaceControl或者hide surface时会被置为true，因为当前窗口才刚刚被创建，因此mLastHidden为true。<br>经过以上判断可以得出我们顺利触发showSurfaceRobustlyLocked<br>后面通过WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController</p>
<pre><code>    /**
     * Have the surface flinger show a surface, robustly dealing with
     * error conditions.  In particular, if there is not enough memory
     * to show the surface, then we will try to get rid of other surfaces
     * in order to succeed.
     *
     * @return Returns true if the surface was successfully shown.
     */
    private boolean showSurfaceRobustlyLocked(SurfaceControl.Transaction t) &#123;
        //WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController
        //调用WindowSurfaceController的showRobustly方法
        boolean shown = mSurfaceController.showRobustly(t);
        //如果没有成功返回false
        if (!shown)
            return false;

        t.merge(mPostDrawTransaction);
        return true;
    &#125;
</code></pre>
<p>在WindowSurfaceController中，首先判断标志位mSurfaceShown，若为true则直接返回；若为false，则将mSurfaceShown置为true，并调用SurfaceControl.show。至此真正的绘图已经显示出来，但是否真正的被用户看见，还需要看其parent是否被show。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p>
<pre><code>    boolean showRobustly(SurfaceControl.Transaction t) &#123;
        ......

        //首先判断surface是否已经shown
        if (mSurfaceShown) &#123;
            return true;
        &#125;
        //将mSurfaceShown设置为true
        setShown(true);
        //调用SurfceControl中的show方法，将surface show出来
        t.show(mSurfaceControl);
        if (mAnimator.mIsWallpaper) &#123;
            EventLog.writeEvent(EventLogTags.WM_WALLPAPER_SURFACE,
                    mAnimator.mWin.getDisplayId(), 1 /* request shown */);
        &#125;
        return true;
    &#125;
</code></pre>
<p>从SurfaceControl的创建以及show的流程上看，可以发现WMS是通过WindowSurfaceController对SurfaceControl进行管理的。<br>最后我们看一下SurfaceControl中的show方法<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p>
<pre><code>        /**
         * Request that a given surface and it&#39;s sub-tree be shown.
         *
         * @param sc The surface to show.
         * @return This transaction.
         * @hide
         */
        @UnsupportedAppUsage
        public Transaction show(SurfaceControl sc) &#123;
            checkPreconditions(sc);
            nativeSetFlags(mNativeObject, sc.mNativeObject, 0, SURFACE_HIDDEN);
            return this;
        &#125;
</code></pre>
<h4 id="2-4-performSurfacePlacement-流程总结"><a href="#2-4-performSurfacePlacement-流程总结" class="headerlink" title="2.4 performSurfacePlacement()流程总结"></a>2.4 performSurfacePlacement()流程总结</h4><p><img src="/../../../../../images/0b16f1c79359438783f3ed8e5f94ce84.png" alt="在这里插入图片描述"><br>在“【<strong>2.2 窗口位置计算</strong>】”以及“【<strong>2.3 窗口状态刷新</strong>】”部分均调用了WindowSurfacePlacer.performSurfacePlacement()，实际上任何窗口属性变化都会触发该方法，但我们在performSurfacePlacement中只关注了窗口位置大小计算以及窗口状态变更的相关流程。此处再对该流程进行简单的梳理。<br>当调用到WindowSurfacePlacer.performSurfacePlacement()时首先会执行“<strong>1</strong>”更新所有窗口的大小以及状态信息，在执行“<strong>2</strong>”处理是否在此调用执行performSurfacePlacement。<br><strong>1.1.1</strong>：主要调用computeFrames，计算窗口的尺寸大小。<br><strong>1.1.2</strong>：主要处理mDrawState的状态变更，在commitFinishDrawingLocked中会将处于DRAW_PENDING状态的mDrawState更新为COMMIT_DRAW_PENDING。<br><strong>1.1.3</strong>：主要根据computerFrames中计算出来的窗口大小来设置Surface的位置，并调用SurfaceControl.show()将窗口show出来。<br><strong>1.2</strong>：将处于COMMIT_DRAW_PENDING状态的mDrawState更新为READY_TO_SHOW，并将DisplayContent.mLayoutNeeded设置为true。在“<strong>2</strong>”中会判断该标志位来处理是否再次调用performSurfacePlacement的操作。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
   
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>