<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>8.点击桌面APP图标，到APP界面显示流程分析(二) | TYL</title>
    
    
        <meta name="keywords" content="8.点击桌面APP图标，到APP界面显示流程分析(二)" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="八、绘制ViewRootImpl.performDraw先看CPU绘制： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586">
<meta property="og:type" content="article">
<meta property="og:title" content="8.点击桌面APP图标，到APP界面显示流程分析(二)">
<meta property="og:url" content="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="八、绘制ViewRootImpl.performDraw先看CPU绘制： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-01-12T01:21:10.250Z">
<meta property="article:modified_time" content="2024-01-19T02:31:53.703Z">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">Android事件分发</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/">Android自定义View</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file active"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ADB%E5%92%8CMonkey%E6%B5%8B%E8%AF%95/">ADB和Monkey测试</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">Leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  <li class="file"><a href="/wiki/C++/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            QT
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/win11%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA/">Win11自动关机</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/">我的简历</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/csdn%E6%96%87%E7%AB%A0%E5%AF%BC%E5%87%BAmarkdown/">Csdn文章导出到本地markdown</a></li>  </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Android FrameWork/Framework源码分析/Android 13/8.点击桌面APP图标，到APP界面显示流程分析(二)" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h3 id="八、绘制"><a href="#八、绘制" class="headerlink" title="八、绘制"></a>八、绘制</h3><h4 id="ViewRootImpl-performDraw"><a href="#ViewRootImpl-performDraw" class="headerlink" title="ViewRootImpl.performDraw"></a>ViewRootImpl.performDraw</h4><p>先看CPU绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ViewRootImpl.mTraversalRunnable.run()</span><br><span class="line">| doTraversal();</span><br><span class="line">  | performTraversals();</span><br><span class="line">    |	relayoutWindow   <span class="comment">//创建surface流程 + sf 创建layer流程</span></span><br><span class="line">	|	hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface);</span><br><span class="line">	|	mAttachInfo.mThreadedRenderer.allocateBuffers();<span class="comment">//硬件绘制，预分配内存    </span></span><br><span class="line">    |	performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      	|	mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">// measure 流程</span></span><br><span class="line">    |	performLayout(lp, mWidth, mHeight);</span><br><span class="line">      	|	mView.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight()); <span class="comment">// layout 流程</span></span><br><span class="line">    |	mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();<span class="comment">//分发OnGlobalLayout事件</span></span><br><span class="line">    | 	<span class="type">View</span> <span class="variable">focused</span> <span class="operator">=</span> mView.findFocus();  focused.restoreDefaultFocus(); <span class="comment">//插眼WYF，这块逻辑以后再看</span></span><br><span class="line">	<span class="comment">//	分发OnPreDraw事件</span></span><br><span class="line">    |	<span class="type">boolean</span> <span class="variable">cancelDraw</span> <span class="operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible; <span class="comment">//不拦截的话 cancelDraw = FALSE</span></span><br><span class="line">    |	performDraw();</span><br><span class="line">      	|	Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;draw&quot;</span>);</span><br><span class="line">      	|	<span class="type">boolean</span> <span class="variable">canUseAsync</span> <span class="operator">=</span> draw(fullRedrawNeeded);</span><br><span class="line">        	|   mAttachInfo.mTreeObserver.dispatchOnDraw();<span class="comment">// 分发OnDraw，回调OnDrawListener中的onDraw()方法。</span></span><br><span class="line">			<span class="comment">//  硬件绘制</span></span><br><span class="line">        	|   isHardwareEnabled()  </span><br><span class="line">          			| mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">			<span class="comment">//  如果未开启硬件绘制使用软件绘制：</span></span><br><span class="line">        	|   drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)</span><br><span class="line">          		|   <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> mSurface.lockCanvas(dirty);</span><br><span class="line">				<span class="comment">//	/frameworks/base/core/java/android/view/Surface.java</span></span><br><span class="line">				|--&gt;Canvas <span class="title function_">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span><br><span class="line">            	|	|	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Canvas</span> <span class="variable">mCanvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompatibleCanvas</span>(); <span class="comment">// 初始化 Canvas.mNativeCanvasWrapper</span></span><br><span class="line">					|	<span class="comment">// 把 native lock 的Surface地址保存到mLockedObject，这个mLockedObject通常情况和mNativeObject是一个地址</span></span><br><span class="line">            	|	|	mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">              	|	|	<span class="comment">// /frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line">                |   |--&gt;nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span><br><span class="line">                |    	|	<span class="comment">// 把Java层保存的地址转换为 native Surface</span></span><br><span class="line">                |    	|	sp&lt;Surface&gt; <span class="title function_">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>);</span><br><span class="line">				|		|	ANativeWindow_Buffer buffer;</span><br><span class="line">              	|		|	surface-&gt;lock(&amp;buffer, dirtyRectPtr);  </span><br><span class="line">						|--&gt;Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">							|	<span class="comment">// 1、需要先连接到SurfaceFlinger端的BufferQueueProducer，会返回宽高数据，SurfaceFlinger端的BufferQueueCore也会设置一些属性</span></span><br><span class="line">                            |	<span class="comment">// 注释说在调用dequeueBuffer前，必须先调用connect，是传入生产者监听，接收 onBufferReleased 回调。</span></span><br><span class="line">                            |	<span class="comment">// 但是软绘，传入的监听是StubProducerListener，onBufferReleased是个空函数</span></span><br><span class="line">							|	<span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> Surface::connect(NATIVE_WINDOW_API_CPU); </span><br><span class="line">                |			|	ANativeWindowBuffer* out;  </span><br><span class="line">							|	<span class="type">int</span> <span class="variable">fenceFd</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">                |			|	<span class="comment">// 2、调用dequeueBuffer获取 ANativeWindowBuffer 对象 和 fenceFd。 </span></span><br><span class="line">                |  			|	<span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> dequeueBuffer(&amp;out, &amp;fenceFd);    <span class="comment">// 【进入 dequeueBuffer 章节】</span></span><br><span class="line">                |			|	<span class="comment">// 3、使用ANativeWindowBuffer创建后台 GraphicBuffer 对象 </span></span><br><span class="line">                |  			|	sp&lt;GraphicBuffer&gt; <span class="title function_">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out)</span>); <span class="comment">// GraphicBuffer 继承 ANativeWindowBuffer</span></span><br><span class="line">							|	<span class="comment">// 4、获取前台buffer</span></span><br><span class="line">							|	const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); </span><br><span class="line">							|	<span class="comment">// 宽高格式都相同时，可以把前台的buffer的 Region 复制给后台buffer</span></span><br><span class="line">                            |	const <span class="type">bool</span> <span class="variable">canCopyBack</span> <span class="operator">=</span> (frontBuffer != nullptr &amp;&amp; backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;...);</span><br><span class="line">							|	<span class="comment">// 干净区域 = 上一次所重绘的区域减去接下来需要重绘的脏区域newDirtyRegion，</span></span><br><span class="line">                            |   <span class="comment">// copyBlt 把干净的区域从frontBuffer拷贝到backBuffer</span></span><br><span class="line">							|	<span class="keyword">if</span> (canCopyBack)	const Region <span class="title function_">copyback</span><span class="params">(mDirtyRegion.subtract(newDirtyRegion)</span>);copyBlt(...);</span><br><span class="line">							|	<span class="comment">// 5、锁定 GraphicBuffer，获取buffer地址</span></span><br><span class="line">                            |	<span class="keyword">void</span>* vaddr;  <span class="comment">// 这变量会携带图形buffer的地址回来，图形库，其实就是在这个地址上做像素操作 </span></span><br><span class="line">							|	<span class="comment">//	调用 GraphicBufferMapper::lockAsync</span></span><br><span class="line">							|	backBuffer-&gt;lockAsync(...,newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">							|	mLockedBuffer = backBuffer; <span class="comment">// 后台buffer变为已经lock的buffer，入队后变为 mPostedBuffer</span></span><br><span class="line">							|	<span class="comment">// 6、把获取到的这些信息，存储到	ANativeWindow_Buffer，函数返回后，会把这对象传给图形库</span></span><br><span class="line">							|	outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">							|	outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">							|	outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">							|	outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">							|	outBuffer-&gt;bits   = vaddr;  <span class="comment">// 把图形buffer的地址赋值给 ANativeWindow_Buffer.bits </span></span><br><span class="line">						|	<span class="comment">//	graphics::Canvas.mCanvas = native 层的 SkiaCanvas</span></span><br><span class="line">              	|		|	graphics::Canvas <span class="title function_">canvas</span><span class="params">(env, canvasObj)</span>;</span><br><span class="line">						|	<span class="comment">// 把图形缓存的地址，宽高格式啊这些，设置进图形库的 SkiaCanvas，有了这些，图形库就专注画图就行了</span></span><br><span class="line">						|	canvas.setBuffer(&amp;buffer, static_cast&lt;int32_t&gt;(surface-&gt;getBuffersDataSpace()));</span><br><span class="line">                    	|	sp&lt;Surface&gt; <span class="title function_">lockedSurface</span><span class="params">(surface)</span>;	<span class="comment">// 创建新的sp引用</span></span><br><span class="line">						|	lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);	<span class="comment">// 引用加一</span></span><br><span class="line">                    	|	<span class="keyword">return</span> (jlong) lockedSurface.get();		  <span class="comment">// 返回地址，传入Java 层的 mLockedObject</span></span><br><span class="line">            	|	|	<span class="keyword">return</span> mCanvas;</span><br><span class="line">          		|	mView.draw(canvas);  <span class="comment">//[View的绘制流程]</span></span><br><span class="line">          		|	surface.unlockCanvasAndPost(canvas);  <span class="comment">// queueBuffer流程起始</span></span><br><span class="line">					|	<span class="keyword">if</span> (mHwuiContext != <span class="literal">null</span>) mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">					|	<span class="keyword">else</span> unlockSwCanvasAndPost(canvas);</span><br><span class="line">						|	nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">						|--&gt;nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span><br><span class="line">                            |	sp&lt;Surface&gt; <span class="title function_">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>);	</span><br><span class="line">                            |	graphics::Canvas <span class="title function_">canvas</span><span class="params">(env, canvasObj)</span>;</span><br><span class="line">							|	canvas.setBuffer(nullptr, ADATASPACE_UNKNOWN);<span class="comment">// detach the canvas from the surface</span></span><br><span class="line">							|	<span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> surface-&gt;unlockAndPost();</span><br><span class="line">							|--&gt;Surface::unlockAndPost()</span><br><span class="line">                                |	<span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">								|	<span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line">								|	err = queueBuffer(mLockedBuffer.get(), fd);  <span class="comment">// 【进入 queueBuffer 章节】</span></span><br><span class="line">								|	mPostedBuffer = mLockedBuffer;  <span class="comment">// 把锁定状态的buffer转换为 已经入队的 buffer</span></span><br><span class="line">								|	mLockedBuffer = nullptr;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-connect–-gt-BBQBufferQueueProducer-connect"><a href="#Surface-connect–-gt-BBQBufferQueueProducer-connect" class="headerlink" title="Surface.connect–&gt;BBQBufferQueueProducer.connect"></a>Surface.connect–&gt;BBQBufferQueueProducer.connect</h4><ul>
<li>重点是注册生产者回调</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span>;</span><br><span class="line">|	<span class="keyword">if</span> (!mConnectedToCpu) <span class="comment">// 没调用过 connect 时，false</span></span><br><span class="line">    |	Surface::<span class="built_in">connect</span>(NATIVE_WINDOW_API_CPU);</span><br><span class="line">	|--&gt;Surface::<span class="built_in">connect</span>(<span class="type">int</span> api)</span><br><span class="line">        |	<span class="comment">// StubProducerListener 就是个虚假的实现,重载函数都为空函数	</span></span><br><span class="line">        |	<span class="type">static</span> sp&lt;IProducerListener&gt; listener = <span class="keyword">new</span> <span class="built_in">StubProducerListener</span>();</span><br><span class="line">		|	<span class="keyword">return</span> <span class="built_in">connect</span>(api, listener);</span><br><span class="line">		|--&gt;Surface::<span class="built_in">connect</span>(<span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener)</span><br><span class="line">            |	<span class="keyword">return</span> <span class="built_in">connect</span>(api, listener, <span class="literal">false</span>);</span><br><span class="line">			|	<span class="comment">//参数 reportBufferRemoval = false</span></span><br><span class="line">			|--&gt;Surface::<span class="built_in">connect</span>( <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener, <span class="type">bool</span> reportBufferRemoval)</span><br><span class="line">                |	IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">                |	mReportRemovedBuffers = reportBufferRemoval; <span class="comment">// false</span></span><br><span class="line">				|	<span class="comment">// mProducerControlledByApp = true; BBQSurface 创建时，传入的是 true</span></span><br><span class="line">				|	<span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">connect</span>(listener, api, mProducerControlledByApp, &amp;output);</span><br><span class="line">				|--&gt;BBQBufferQueueProducer.<span class="built_in">connect</span>(IProducerListener&amp; listener,<span class="type">int</span> api,<span class="type">bool</span> producerControlledByApp QueueBufferOutput* output)</span><br><span class="line">                    |	<span class="keyword">return</span> BufferQueueProducer::<span class="built_in">connect</span>(listener, api, producerControlledByApp, output);</span><br><span class="line">					|--&gt;BufferQueueProducer::<span class="built_in">connect</span>(IProducerListener&amp; listener,<span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput *output)</span><br><span class="line">                        |	mConsumerName = mCore-&gt;mConsumerName;<span class="comment">//mConsumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot;</span></span><br><span class="line">						|	<span class="comment">// 中间有一段代码，会依据擦混入的参数producerControlledByApp再调整一次 BufferQueueCore的 mFreeSlots mUnusedSlots</span></span><br><span class="line">                        |	<span class="comment">// 目前的参数为无效代码，不贴代码了</span></span><br><span class="line">                |       |	<span class="keyword">switch</span> (api) &#123;</span><br><span class="line">                                <span class="keyword">case</span> NATIVE_WINDOW_API_EGL:</span><br><span class="line">                        |       <span class="keyword">case</span> NATIVE_WINDOW_API_CPU:</span><br><span class="line">                |               <span class="keyword">case</span> NATIVE_WINDOW_API_MEDIA:</span><br><span class="line">                                <span class="keyword">case</span> NATIVE_WINDOW_API_CAMERA:</span><br><span class="line">                        |        	mCore-&gt;mConnectedApi = api;</span><br><span class="line">                                	<span class="comment">// 返回给 Surface 的属性</span></span><br><span class="line">                                	<span class="comment">// 这些值，在 BLASTBufferQueue.update 把SurfaceContrl的值传到BufferQueueCore，现在又从 BufferQueueCore 传回Surface</span></span><br><span class="line">                |                	output-&gt;width = mCore-&gt;mDefaultWidth;</span><br><span class="line">                        |        	output-&gt;height = mCore-&gt;mDefaultHeight;</span><br><span class="line">                                	<span class="comment">// 用于优化旋转。预旋转</span></span><br><span class="line">                |                	output-&gt;transformHint = mCore-&gt;mTransformHintInUse = mCore-&gt;mTransformHint;<span class="comment">//初始化时为 0</span></span><br><span class="line">                                	<span class="comment">// 返回当前 处于 QUEUEED 状态的 buffer 数量</span></span><br><span class="line">                        |        	output-&gt;numPendingBuffers = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>());</span><br><span class="line">                                	output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + <span class="number">1</span>;</span><br><span class="line">                |                	output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line">                                	output-&gt;maxBufferCount = mCore-&gt;mMaxBufferCount;</span><br><span class="line">                        |			<span class="comment">// 【注册生产者回调--onBufferReleased】</span></span><br><span class="line">                        |        	mCore-&gt;mConnectedProducerListener = listener;<span class="comment">// CPU绘制传入的 StubProducerListener,没啥用</span></span><br><span class="line">                                	<span class="comment">// 用于触发 onBufferReleased 回调, mBufferReleasedCbEnabled 为true的时候才能触发</span></span><br><span class="line">                |                	mCore-&gt;mBufferReleasedCbEnabled = listener-&gt;<span class="built_in">needsReleaseNotify</span>(); <span class="comment">// CPU 绘制返回false</span></span><br><span class="line">                        |	<span class="comment">// 再刷一遍 BufferQueueCore 的属性，其实这些属性 BufferQueueCore 初始化时设置的也是这些值  </span></span><br><span class="line">                        |	mCore-&gt;mConnectedPid = BufferQueueThreadState::<span class="built_in">getCallingPid</span>();</span><br><span class="line">                        |	mCore-&gt;mBufferHasBeenQueued = <span class="literal">false</span>;	mCore-&gt;mDequeueBufferCannotBlock = <span class="literal">false</span>;</span><br><span class="line">                |       |	mCore-&gt;mQueueBufferCanDrop = <span class="literal">false</span>;		mCore-&gt;mLegacyBufferDrop = <span class="literal">true</span>;</span><br><span class="line">                        |	mCore-&gt;mAllowAllocation = <span class="literal">true</span>;  <span class="comment">// 允许分配内存</span></span><br><span class="line">                |	<span class="comment">// 使用请求到的数据，设置 Surface 属性</span></span><br><span class="line">				|	mDefaultWidth = output.width;	mDefaultHeight = output.height;</span><br><span class="line">                |	mNextFrameNumber = output.nextFrameNumber;	mMaxBufferCount = output.maxBufferCount;</span><br><span class="line">               	|	mTransformHint = output.transformHint;<span class="comment">// 这只是一个提示，实际的转换可能会有所不同。被用来提高layer的系统性能</span></span><br><span class="line">                |	mConsumerRunningBehind = (output.numPendingBuffers &gt;= <span class="number">2</span>);</span><br><span class="line">                |	<span class="keyword">if</span> (!err &amp;&amp; api == NATIVE_WINDOW_API_CPU)	mConnectedToCpu = <span class="literal">true</span>;  <span class="comment">// CPU绘制</span></span><br><span class="line">                    <span class="keyword">else</span>	mDirtyRegion = Region::INVALID_REGION;</span><br></pre></td></tr></table></figure>

<ul>
<li>Surface继承 ANativeWindow<ul>
<li>ANativeWindow 图形库的各种函数</li>
</ul>
</li>
<li>ANativeWindow_Buffer     ANativeWindow_Buffer.bits  存储图形buffer的地址<ul>
<li>用于 Surface::lock 的参数，用于图形库。</li>
</ul>
</li>
<li>GraphicBuffer  继承 ANativeWindowBuffer<ul>
<li>封装图形内存分配接口 GraphicBufferMapper GraphicBufferAllocator ，以及进程间传递的序列化接口</li>
<li>ANativeWindowBuffer<ul>
<li>typedef  ANativeWindowBuffer	ANativeWindowBuffer_t</li>
<li>typedef  ANativeWindowBuffer_t    android_native_buffer_t;</li>
<li>内部有个成员 native_handle_t* handle;  <strong>存储buffer的fd</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Surface-dequeueBuffer–-gt-BufferQueueProducer-dequeueBuffer"><a href="#Surface-dequeueBuffer–-gt-BufferQueueProducer-dequeueBuffer" class="headerlink" title="Surface.dequeueBuffer–&gt;BufferQueueProducer.dequeueBuffer"></a>Surface.dequeueBuffer–&gt;BufferQueueProducer.dequeueBuffer</h4><p>BBQBufferQueueProducer 没有重载 BufferQueueProducer.dequeueBuffer</p>
<p>直接调用父类 BufferQueueProducer.dequeueBuffer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span>;</span><br><span class="line">|	<span class="keyword">if</span> (!mConnectedToCpu) <span class="comment">// 没调用过 connect 时，false</span></span><br><span class="line">    |	Surface::<span class="built_in">connect</span>(NATIVE_WINDOW_API_CPU);</span><br><span class="line">|	ANativeWindowBuffer* out; </span><br><span class="line">|	<span class="type">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">|	<span class="type">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);</span><br><span class="line">|--&gt;Surface::<span class="built_in">dequeueBuffer</span>(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd);</span><br><span class="line">|   |	<span class="built_in">getDequeueBufferInputLocked</span>(&amp;dqInput);</span><br><span class="line">	|--&gt;Surface::<span class="built_in">getDequeueBufferInputLocked</span>(IGraphicBufferProducer::DequeueBufferInput* dequeueInput)</span><br><span class="line">        |	<span class="comment">// Req 前缀表示 request，用于请求使用的参数，软绘应该全使用的默认值</span></span><br><span class="line">        |	dequeueInput-&gt;width = mReqWidth ? mReqWidth : mUserWidth;<span class="comment">// 默认 mReqWidth = mUserWidth = 0</span></span><br><span class="line">		|	dequeueInput-&gt;height = mReqHeight ? mReqHeight : mUserHeight;<span class="comment">// 默认 mReqHeight = mUserHeight = 0</span></span><br><span class="line">		|	dequeueInput-&gt;format = mReqFormat;<span class="comment">// 默认 0</span></span><br><span class="line">		|	dequeueInput-&gt;usage = mReqUsage;<span class="comment">// 默认 0</span></span><br><span class="line">		|	dequeueInput-&gt;usage = mReqUsage;<span class="comment">// mEnableFrameTimestamps 默认false</span></span><br><span class="line">		|	dequeueInput-&gt;getTimestamps = mEnableFrameTimestamps;<span class="comment">// mEnableFrameTimestamps 默认false</span></span><br><span class="line">	|	<span class="type">int</span> buf = <span class="number">-1</span>;</span><br><span class="line">	|	sp&lt;Fence&gt; fence;</span><br><span class="line">	|	<span class="type">nsecs_t</span> startTime = <span class="built_in">systemTime</span>();<span class="comment">// 当前时间</span></span><br><span class="line">	|	FrameEventHistoryDelta frameTimestamps;</span><br><span class="line">	|	<span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width,dqInput.height, dqInput.format,</span><br><span class="line">                                                                dqInput.usage, &amp;mBufferAge,dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">	|--&gt;BufferQueueProducer.<span class="built_in">dequeueBuffer</span>(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, </span><br><span class="line">                                          PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span><br><span class="line">        |	mConsumerName = mCore-&gt;mConsumerName; <span class="comment">// consumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot;</span></span><br><span class="line">		|	<span class="comment">//width、height 可以都为0，但是不能一个是0，一个非零。</span></span><br><span class="line">		|	<span class="keyword">if</span> ((width &amp;&amp; !height) || (!width &amp;&amp; height))	<span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">		|	<span class="keyword">if</span> (mCore-&gt;mFreeBuffers.<span class="built_in">empty</span>() &amp;&amp; mCore-&gt;mIsAllocating)	mCore-&gt;<span class="built_in">waitWhileAllocatingLocked</span>(lock);<span class="comment">//正在分配buffer，自旋等待</span></span><br><span class="line">		|	<span class="keyword">if</span> (format == <span class="number">0</span>)	format = mCore-&gt;mDefaultBufferFormat; <span class="comment">// mDefaultBufferFormat = PIXEL_FORMAT_RGBA_8888</span></span><br><span class="line">		|	<span class="comment">// mConsumerUsageBits 在BLASTBufferItemConsumer构造是赋值为 GraphicBuffer::USAGE_HW_COMPOSER |GraphicBuffer::USAGE_HW_TEXTURE</span></span><br><span class="line">		|	usage |= mCore-&gt;mConsumerUsageBits</span><br><span class="line">        |	<span class="type">const</span> <span class="type">bool</span> useDefaultSize = !width &amp;&amp; !height;	<span class="comment">// 宽高都为0，使用默认尺寸</span></span><br><span class="line">		|	<span class="keyword">if</span> (useDefaultSize)</span><br><span class="line">            |	<span class="comment">//默认宽高在 BLASTBufferQueue.update 把SurfaceContrl的宽高值传到BufferQueueCore</span></span><br><span class="line">            |	width = mCore-&gt;mDefaultWidth; height = mCore-&gt;mDefaultHeight;</span><br><span class="line">			|	<span class="keyword">if</span> (mCore-&gt;mAutoPrerotation &amp;&amp; (mCore-&gt;mTransformHintInUse &amp; NATIVE_WINDOW_TRANSFORM_ROT_90))</span><br><span class="line">                |	std::<span class="built_in">swap</span>(width, height); <span class="comment">// mAutoPrerotation自动预旋转默认false，mTransformHintInUse 90度时宽高互换</span></span><br><span class="line">		|	<span class="type">int</span> found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">		|	<span class="comment">//【获取可用的 BufferSlot 索引】</span></span><br><span class="line">        |   <span class="built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller::Dequeue, lock, &amp;found);</span><br><span class="line">		|--&gt;BufferQueueProducer::<span class="built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller caller, std::unique_lock&lt;std::mutex&gt;&amp; lock, <span class="type">int</span>* found)</span><br><span class="line">			|	<span class="type">bool</span> tryAgain = <span class="literal">true</span>;</span><br><span class="line">			|	<span class="keyword">while</span> (tryAgain)</span><br><span class="line">    			|	*found = BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">				|	<span class="comment">// 首先从list链表 BufferQueueCore-&gt;mFreeBuffers 拿 BufferSlot，如果集合是空的，会返回BufferQueueCore::INVALID_BUFFER_SLOT</span></span><br><span class="line">				|	<span class="type">int</span> slot = <span class="built_in">getFreeBufferLocked</span>();</span><br><span class="line">				|	<span class="keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT)</span><br><span class="line">        			|	*found = slot;</span><br><span class="line">				|	<span class="keyword">else</span> <span class="keyword">if</span> (mCore-&gt;mAllowAllocation)</span><br><span class="line">					|	<span class="comment">// mFreeBuffers没有，就从set集合 BufferQueueCore-&gt;mFreeSlots 拿 BufferSlot，如果集合是空的，返回BufferQueueCore::INVALID_BUFFER_SLOT</span></span><br><span class="line">        			|	*found = <span class="built_in">getFreeSlotLocked</span>();</span><br><span class="line">				|	tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) || tooManyBuffers;</span><br><span class="line">				|	<span class="comment">// 没有 buffer了，或者 queue 太多了(这个可能性不大，mFreeSlots 这个set就三个数据，dequeue不出来那么多，queue就更不可能)，</span></span><br><span class="line">    			|	<span class="keyword">if</span> (tryAgain)</span><br><span class="line">        			|	<span class="keyword">if</span> (mDequeueTimeout &gt;= <span class="number">0</span>)<span class="comment">//  BBQ 设置的mDequeueTimeout=int64.max</span></span><br><span class="line">            			|	<span class="comment">// 等待buffer(有可能是buffer被释放了，小概率因为mFreeSlots集合增加了)</span></span><br><span class="line">        				|	mCore-&gt;mDequeueCondition.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">nanoseconds</span>(mDequeueTimeout));</span><br><span class="line">		|	<span class="comment">//拿到可用的索引found对应的 BufferSlot 的 GraphicBuffer</span></span><br><span class="line">		|	<span class="function"><span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span></span>;</span><br><span class="line">		|	<span class="comment">//【把找到的buffer，插入到set集合 mActiveBuffers 中】	</span></span><br><span class="line">		|	mCore-&gt;mActiveBuffers.<span class="built_in">insert</span>(found);</span><br><span class="line">		|	<span class="comment">//把索引值返回</span></span><br><span class="line">		|	*outSlot = found;</span><br><span class="line">		|	<span class="comment">// 【把找到的 BufferSlot buffer状态转为 dequeue】</span></span><br><span class="line">		|	mSlots[found].mBufferState.<span class="built_in">dequeue</span>();</span><br><span class="line">		|	<span class="comment">//找到的 BufferSlot 没有关联GraphicBuffer，或者 GraphicBuffer 宽高，格式、usage、layerCount 和需求不相等的话，需要重新分配</span></span><br><span class="line">        |	<span class="keyword">if</span> ((buffer == <span class="literal">nullptr</span>) || buffer-&gt;<span class="built_in">needsReallocation</span>(width, height, format, BQ_LAYER_COUNT, usage))</span><br><span class="line">            |	mSlots[found].mAcquireCalled = <span class="literal">false</span>;	mSlots[found].mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">			|	mSlots[found].mRequestBufferCalled = <span class="literal">false</span>;	mSlots[found].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">			|	mSlots[found].mEglFence = EGL_NO_SYNC_KHR;	mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">			|	mCore-&gt;mBufferAge = <span class="number">0</span>;  	 <span class="comment">// 设置 mBufferAge 为0，新鲜的buffer啊，还没有被queue过</span></span><br><span class="line">			|	mCore-&gt;mIsAllocating = <span class="literal">true</span>; <span class="comment">// 设置为正在分配内存</span></span><br><span class="line">			|	<span class="comment">//【 添加 “需要重新分配buffer” flag】</span></span><br><span class="line">			|	returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">			|<span class="keyword">else</span> <span class="comment">// 计算buffer年龄</span></span><br><span class="line">            |	<span class="comment">// mBufferAge： [(自从当前的 BufferSlot 上次被 queueBuffer 后，又queue了多少个BufferSlot) + 1]    </span></span><br><span class="line">            |	mCore-&gt;mBufferAge = mCore-&gt;mFrameCounter + <span class="number">1</span> - mSlots[found].mFrameNumber;</span><br><span class="line">		|	<span class="comment">// 非共享内存模式下， 把当前的 buffer Fence ，传到外部参数 outFence</span></span><br><span class="line">		|	*outFence = (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == found) ? Fence::NO_FENCE : mSlots[found].mFence;</span><br><span class="line">		|	<span class="comment">// BufferSlot的Fence重新赋值为 NO_FENCE</span></span><br><span class="line">		|	mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">		|	mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">		|	<span class="comment">// 【需要重新分配buffer情况，分配新的buffer】</span></span><br><span class="line">		|	<span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) </span><br><span class="line">            |	<span class="comment">//GraphicBuffer构造函数中调用 GraphicBufferAllocator.allocate 分配图形buffer，并映射内存到当前进程</span></span><br><span class="line">            |	sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> <span class="built_in">GraphicBuffer</span>(width, height, format, BQ_LAYER_COUNT, usage,mConsumerName);</span><br><span class="line">			|	mCore-&gt;mIsAllocating = <span class="literal">false</span>;  <span class="comment">// 分配完了，要重新设置回 false 啊</span></span><br><span class="line">			|	mCore-&gt;mIsAllocatingCondition.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒那些因为 正在分配buffer 而等待的线程</span></span><br><span class="line">		|	<span class="comment">// 如果需要等待 eglFence 释放 Fence</span></span><br><span class="line">		|	<span class="keyword">if</span> (eglFence != EGL_NO_SYNC_KHR)</span><br><span class="line">            |	EGLint result = <span class="built_in">eglClientWaitSyncKHR</span>(eglDisplay, eglFence, <span class="number">0</span>,<span class="number">1000000000</span>);<span class="comment">// 等待B</span></span><br><span class="line">			|	<span class="built_in">eglDestroySyncKHR</span>(eglDisplay, eglFence);</span><br><span class="line">		|	*outBufferAge = mCore-&gt;mBufferAge; <span class="comment">// buffer年龄传到外部</span></span><br><span class="line">		|	<span class="built_in">addAndGetFrameTimestamps</span>(<span class="literal">nullptr</span>, outTimestamps);<span class="comment">// BBQ 没有实现这方法，是个空实现。只有 BufferQueue 在消费者进程里，才会被调用。</span></span><br><span class="line">		|	<span class="keyword">return</span> returnFlags;</span><br><span class="line">	|	<span class="comment">//继续 Surface::dequeueBuffer</span></span><br><span class="line">	|	mLastDequeueDuration = <span class="built_in">systemTime</span>() - startTime;<span class="comment">// 计算 dequeue 时间</span></span><br><span class="line">	|	mLastDequeueStartTime = startTime;<span class="comment">// 记录上次 dequeue 开始时间</span></span><br><span class="line">	|	<span class="comment">// 根据拿到的 slolt 下标,获取本地Surface自己的 GraphicBuffer</span></span><br><span class="line">	|	<span class="function">sp&lt;GraphicBuffer&gt;&amp; <span class="title">gbuf</span><span class="params">(mSlots[buf].buffer)</span></span>; </span><br><span class="line">	|	<span class="keyword">if</span> (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) <span class="built_in">freeAllBuffers</span>();</span><br><span class="line">	|	<span class="keyword">if</span> (dqInput.getTimestamps)	mFrameEventHistory-&gt;<span class="built_in">applyDelta</span>(frameTimestamps);</span><br><span class="line">	|	<span class="comment">// dequeueBuffer返回值 带有 BUFFER_NEEDS_REALLOCATION 标记，并且 gbuf == nullptr 的时候 进入此分支</span></span><br><span class="line">	|	<span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="literal">nullptr</span>)</span><br><span class="line">        |	<span class="comment">//【请求 GraphicBuffer】	</span></span><br><span class="line">        |	<span class="comment">// requestBuffer接口很简单，直接返回 dequeueBuffer时关联/创建的 GraphicBuffer对象。</span></span><br><span class="line">        |	<span class="comment">// S版本以前，需要跨进程传递GraphicBuffer对象，反序列化时，会调用GraphicBufferMapper.importBuffer映射内存</span></span><br><span class="line">        |	result = mGraphicBufferProducer-&gt;<span class="built_in">requestBuffer</span>(buf, &amp;gbuf);</span><br><span class="line">	|	<span class="keyword">if</span> (fence-&gt;<span class="built_in">isValid</span>()) *fenceFd = fence-&gt;<span class="built_in">dup</span>();</span><br><span class="line">	|	<span class="comment">// 赋值外部的 android_native_buffer_t** buffer</span></span><br><span class="line">	|	*buffer = gbuf.<span class="built_in">get</span>();</span><br><span class="line">	|	<span class="comment">//	std::unordered_set&lt;int&gt; mDequeuedSlots;</span></span><br><span class="line">	|	mDequeuedSlots.<span class="built_in">insert</span>(buf); <span class="comment">// Dequeued 的buffer的 下标 存入 mDequeuedSlots</span></span><br></pre></td></tr></table></figure>

<h4 id="Surface-queueBuffer"><a href="#Surface-queueBuffer" class="headerlink" title="Surface.queueBuffer"></a>Surface.queueBuffer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">// 前置流程：</span></span><br><span class="line">surface.<span class="built_in">unlockCanvasAndPost</span>(canvas);  <span class="comment">// queueBuffer</span></span><br><span class="line">|	<span class="keyword">if</span> (mHwuiContext != null) mHwuiContext.<span class="built_in">unlockAndPost</span>(canvas);</span><br><span class="line">|	<span class="keyword">else</span> <span class="built_in">unlockSwCanvasAndPost</span>(canvas);</span><br><span class="line">	|	<span class="built_in">nativeUnlockCanvasAndPost</span>(mLockedObject, canvas);</span><br><span class="line">	|--&gt;<span class="built_in">nativeUnlockCanvasAndPost</span>(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span><br><span class="line">        |	<span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;	</span><br><span class="line">        |	<span class="function">graphics::Canvas <span class="title">canvas</span><span class="params">(env, canvasObj)</span></span>;</span><br><span class="line">		|	canvas.<span class="built_in">setBuffer</span>(<span class="literal">nullptr</span>, ADATASPACE_UNKNOWN);<span class="comment">// detach the canvas from the surface</span></span><br><span class="line">		|	<span class="type">status_t</span> err = surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line">		|--&gt;Surface::<span class="built_in">unlockAndPost</span>()</span><br><span class="line">    |       |	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	|		|	<span class="type">status_t</span> err = mLockedBuffer-&gt;<span class="built_in">unlockAsync</span>(&amp;fd);</span><br><span class="line">				|	GraphicBuffer::<span class="built_in">getBufferMapper</span>().<span class="built_in">unlockAsync</span>(handle, fenceFd);</span><br><span class="line">	|		|	err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);  <span class="comment">// 进入【queueBuffer 章节】</span></span><br><span class="line">	|		|	mPostedBuffer = mLockedBuffer;  <span class="comment">// 把锁定的buffer转换为 已经入队的 buffer</span></span><br><span class="line">	|		|	mLockedBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">	|	<span class="built_in">nativeRelease</span>(mLockedObject);</span><br><span class="line">	|	mLockedObject = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【queueBuffer 章节】</span></span><br><span class="line">Surface::<span class="built_in">queueBuffer</span>(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd) </span><br><span class="line">|	<span class="type">int</span> i = <span class="built_in">getSlotFromBufferLocked</span>(buffer);</span><br><span class="line">|	<span class="comment">// 遍历 Surface.mSlots 数组，找到 GraphicBuffer.handle 相同的 BufferSlot 索引</span></span><br><span class="line">|--&gt;Surface::<span class="built_in">getSlotFromBufferLocked</span>(<span class="type">android_native_buffer_t</span>* buffer)</span><br><span class="line">    |	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_BUFFER_SLOTS; i++)</span><br><span class="line">        |	<span class="keyword">if</span> (mSlots[i].buffer != <span class="literal">nullptr</span> &amp;&amp; mSlots[i].buffer-&gt;handle == buffer-&gt;handle)</span><br><span class="line">            |	<span class="keyword">return</span> i;</span><br><span class="line">|	IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">|	IGraphicBufferProducer::QueueBufferInput input;</span><br><span class="line">|	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Surface.mTimestamp 使用默认的 NATIVE_WINDOW_TIMESTAMP_AUTO 时，</span></span><br><span class="line"><span class="comment">			QueueBufferInput.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span></span><br><span class="line"><span class="comment">			QueueBufferInput.isAutoTimestamp = true; // 这个参数标明是否在入队时，自动生成时间戳	</span></span><br><span class="line"><span class="comment">|	*/</span> </span><br><span class="line">|	<span class="built_in">getQueueBufferInputLocked</span>(buffer, fenceFd, mTimestamp, &amp;input);</span><br><span class="line">|	<span class="comment">// 一些 Gralloc 的元数据 mapper.setDataspace，HdrMetadata 设置</span></span><br><span class="line">|	<span class="built_in">applyGrallocMetadataLocked</span>(buffer, input);</span><br><span class="line">|	sp&lt;Fence&gt; fence = input.fence;</span><br><span class="line">|	<span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>();</span><br><span class="line">|	<span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line">|--&gt;BufferQueueProducer::<span class="built_in">queueBuffer</span>(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span><br><span class="line">    |	<span class="type">int64_t</span> requestedPresentTimestamp;	<span class="type">bool</span> isAutoTimestamp;	android_dataspace dataSpace;</span><br><span class="line">	|	<span class="function">Rect <span class="title">crop</span><span class="params">(Rect::EMPTY_RECT)</span></span>;	<span class="type">int</span> scalingMode;	<span class="type">uint32_t</span> transform;</span><br><span class="line">	|	<span class="type">uint32_t</span> stickyTransform;	sp&lt;Fence&gt; acquireFence;		<span class="type">bool</span> getFrameTimestamps = <span class="literal">false</span>;</span><br><span class="line">	|	<span class="comment">// 读取输入参数的数据</span></span><br><span class="line">	|	input.<span class="built_in">deflate</span>(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace,</span><br><span class="line">                      &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform, &amp;getFrameTimestamps);</span><br><span class="line">	|	<span class="type">const</span> Region&amp; surfaceDamage = input.<span class="built_in">getSurfaceDamage</span>();</span><br><span class="line">	|	<span class="type">const</span> HdrMetadata&amp; hdrMetadata = input.<span class="built_in">getHdrMetadata</span>();</span><br><span class="line">	|	sp&lt;IConsumerListener&gt; frameAvailableListener;<span class="comment">// buffer 可用通知</span></span><br><span class="line">	|	sp&lt;IConsumerListener&gt; frameReplacedListener;<span class="comment">//buffer被替换通知</span></span><br><span class="line">	|	BufferItem item; <span class="comment">// 创建 BufferItem</span></span><br><span class="line">	|	<span class="comment">// 拿到 slot 对应的 GraphicBuffer </span></span><br><span class="line">	|	<span class="function"><span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">graphicBuffer</span><span class="params">(mSlots[slot].mGraphicBuffer)</span></span>;</span><br><span class="line">	|	<span class="comment">// 裁剪区域</span></span><br><span class="line">	|	<span class="function">Rect <span class="title">bufferRect</span><span class="params">(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight())</span></span>;</span><br><span class="line">	|	<span class="function">Rect <span class="title">croppedRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">	|	<span class="comment">// crop 和 bufferRect 的交集，结果存入  croppedRect</span></span><br><span class="line">	|	crop.<span class="built_in">intersect</span>(bufferRect, &amp;croppedRect);</span><br><span class="line">	|	mSlots[slot].mFence = acquireFence;</span><br><span class="line">	|	<span class="comment">//【设置为 QUEUED 状态】</span></span><br><span class="line">	|	mSlots[slot].mBufferState.<span class="built_in">queue</span>();</span><br><span class="line">	|	++mCore-&gt;mFrameCounter;<span class="comment">// 每次 queueBuffer 都+1</span></span><br><span class="line">	|	currentFrameNumber = mCore-&gt;mFrameCounter;</span><br><span class="line">	|	mSlots[slot].mFrameNumber = currentFrameNumber;<span class="comment">//存储当前BufferSlot的帧号</span></span><br><span class="line">	|	<span class="comment">// 封装 BufferItem 信息</span></span><br><span class="line">    |	item.mAcquireCalled = mSlots[slot].mAcquireCalled;</span><br><span class="line">	|	item.mGraphicBuffer = mSlots[slot].mGraphicBuffer; <span class="comment">//图形buffer</span></span><br><span class="line">	|	item.mCrop = crop;<span class="comment">//裁切矩形</span></span><br><span class="line">	|	item.mTransform = transform &amp; ~<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<span class="comment">// 旋转变换 </span></span><br><span class="line">	|	item.mTransformToDisplayInverse = (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="number">0</span>;</span><br><span class="line">	|	item.mScalingMode = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(scalingMode);<span class="comment">//缩放模式</span></span><br><span class="line">	|	item.mTimestamp = requestedPresentTimestamp;<span class="comment">//时间戳</span></span><br><span class="line">	|	item.mIsAutoTimestamp = isAutoTimestamp;<span class="comment">// 是否在入队时，自动生成时间戳，默认情况下 true</span></span><br><span class="line">	|	item.mDataSpace = dataSpace;<span class="comment">// 描述图像内容，依赖于图像格式</span></span><br><span class="line">	|	item.mHdrMetadata = hdrMetadata;<span class="comment">//  HDR metadata 不懂</span></span><br><span class="line">	|	item.mFrameNumber = currentFrameNumber;<span class="comment">//帧号</span></span><br><span class="line">	|	item.mSlot = slot;<span class="comment">/*索引*/</span> item.mFence = acquireFence;<span class="comment">/*fence*/</span> item.mFenceTime = acquireFenceTime;<span class="comment">/*FenceTime*/</span></span><br><span class="line">	|	<span class="comment">// mIsDroppable 如果为true，则 queuebuffer 时，可以替换旧的buffer。</span></span><br><span class="line">	|	item.mIsDroppable = mCore-&gt;mAsyncMode || ...;<span class="comment">// 当前 mIsDroppable = false</span></span><br><span class="line">	|	item.mSurfaceDamage = surfaceDamage;<span class="comment">//已经被修改的区域</span></span><br><span class="line">	|	item.mQueuedBuffer = <span class="literal">true</span>;<span class="comment">// 标明buffer已经被生产者 queued，acquireBuffer后设置为false</span></span><br><span class="line">	|	item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<span class="comment">// 仅仅在共享buffer下有用，标明消费者应该尽快 acquire 下一帧</span></span><br><span class="line">	|	item.mApi = mCore-&gt;mConnectedApi;<span class="comment">//表明是 CPU还是GPU queue的buffer</span></span><br><span class="line">	|	output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line">	|	<span class="comment">//【BufferItem入队】</span></span><br><span class="line">	|	mCore-&gt;mQueue.<span class="built_in">push_back</span>(item);</span><br><span class="line">	|	<span class="comment">// BufferQueueCore.mConsumerListener = ConsumerBase(BLASTBufferItemConsumer的父类)</span></span><br><span class="line">	|	frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">	|	mCore-&gt;mBufferHasBeenQueued = <span class="literal">true</span>;<span class="comment">// 每次queueBuffer后都设置为true</span></span><br><span class="line">	|	mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒等待的线程</span></span><br><span class="line">	|	mCore-&gt;mLastQueuedSlot = slot;<span class="comment">//  赋值最新queue的 BufferSlot 索引</span></span><br><span class="line">	|	<span class="comment">// 返回给Surface的数据</span></span><br><span class="line">    |	output-&gt;width = mCore-&gt;mDefaultWidth;	output-&gt;height = mCore-&gt;mDefaultHeight;</span><br><span class="line">	|	output-&gt;transformHint = mCore-&gt;mTransformHintInUse = mCore-&gt;mTransformHint;</span><br><span class="line">	|	output-&gt;numPendingBuffers = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>());<span class="comment">// 返回当前已经Queue的数量，代表还未被消费的数量</span></span><br><span class="line">	|	output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + <span class="number">1</span>;<span class="comment">// 返回下一帧的帧号</span></span><br><span class="line">	|	<span class="comment">// atrace 记录 mQueue 大小</span></span><br><span class="line">    |   <span class="built_in">ATRACE_INT</span>(mCore-&gt;mConsumerName.<span class="built_in">string</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>()));</span><br><span class="line">	|	<span class="comment">// BBQ生产者构造函数设置 mConsumerIsSurfaceFlinger = false</span></span><br><span class="line">	|	<span class="keyword">if</span> (!mConsumerIsSurfaceFlinger)	</span><br><span class="line">        |	<span class="comment">// 清理 GraphicBuffer 指针【TODO：这里的一些比较重要联动细节待研究】</span></span><br><span class="line">        |	item.mGraphicBuffer.<span class="built_in">clear</span>();</span><br><span class="line">	|	<span class="type">int</span> connectedApi = mCore-&gt;mConnectedApi;</span><br><span class="line">	|	sp&lt;Fence&gt; lastQueuedFence = std::<span class="built_in">move</span>(mLastQueueBufferFence);</span><br><span class="line">	|	mLastQueueBufferFence = std::<span class="built_in">move</span>(acquireFence);</span><br><span class="line">	|	<span class="comment">//【消费者回调】</span></span><br><span class="line">    |	<span class="comment">// 回调到 ConsumerBase.onFrameAvailable ，再回调到 BLASTBufferQueue.onFrameAvailable</span></span><br><span class="line">	|	frameAvailableListener-&gt;<span class="built_in">onFrameAvailable</span>(item);<span class="comment">//【转入“BufferQueueConsumer::acquireBuffer”章节】</span></span><br><span class="line">	|	<span class="comment">// 如果是 GPU 绘制，最多queueBuffer两个buffer，第二个buffer没有绘制完成，就需要等待 fence</span></span><br><span class="line">	|	<span class="keyword">if</span> (connectedApi == NATIVE_WINDOW_API_EGL)	</span><br><span class="line">        |	lastQueuedFence-&gt;<span class="built_in">waitForever</span>(<span class="string">&quot;Throttling EGL Production&quot;</span>);</span><br><span class="line">|	mLastQueueDuration = <span class="built_in">systemTime</span>() - now; <span class="comment">// 记录 queueBuffer 时间</span></span><br><span class="line">|	<span class="comment">// 更新Surface的一些成员属性</span></span><br><span class="line">|	<span class="built_in">onBufferQueuedLocked</span>(i, fence, output);</span><br></pre></td></tr></table></figure>

<h4 id="BufferQueueConsumer-acquireBuffer"><a href="#BufferQueueConsumer-acquireBuffer" class="headerlink" title="BufferQueueConsumer::acquireBuffer"></a>BufferQueueConsumer::acquireBuffer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码BLASTBufferQueue::<span class="built_in">onFrameAvailable</span>(<span class="type">const</span> BufferItem&amp; item)</span><br><span class="line">|	<span class="built_in">acquireNextBufferLocked</span>(std::<span class="literal">nullopt</span>);</span><br><span class="line">|--&gt;BLASTBufferQueue::<span class="built_in">acquireNextBufferLocked</span>(<span class="type">const</span> std::optional&lt;SurfaceComposerClient::Transaction*&gt; transaction)</span><br><span class="line">    |	<span class="comment">// 参数 transaction = nullopt</span></span><br><span class="line">    |	<span class="type">const</span> <span class="type">bool</span> includeExtraAcquire = !transaction;<span class="comment">// includeExtraAcquire = true</span></span><br><span class="line">	|	<span class="comment">// 判断 mNumAcquired 是否大于等于 mMaxAcquiredBuffers + (includeExtraAcquire ? 2 : 1) </span></span><br><span class="line">	|	<span class="type">const</span> <span class="type">bool</span> maxAcquired = <span class="built_in">maxBuffersAcquired</span>(includeExtraAcquire);</span><br><span class="line">	|	<span class="comment">// Transaction 一个事务里边会填充各种需要执行的业务和业务数据，最终传递到 SurfaceFlinger，SF对事务解析的结果通常是设置Layer的各种属性</span></span><br><span class="line">    |	<span class="comment">// 每设置一种数据，都会存到ComposerState中，并添加对应的flag，SF端根据flag解析数据</span></span><br><span class="line">	|	SurfaceComposerClient::Transaction localTransaction;</span><br><span class="line">	|	<span class="type">bool</span> applyTransaction = <span class="literal">true</span>;</span><br><span class="line">	|	SurfaceComposerClient::Transaction* t = &amp;localTransaction;</span><br><span class="line">	|	BufferItem bufferItem; <span class="comment">// 创建一个未填充数据的的栈对象 BufferItem</span></span><br><span class="line">	|	<span class="comment">//【acquireBuffer流程!!!!!!!!!!!!!!!!】</span></span><br><span class="line">	|	<span class="type">status_t</span> status = mBufferItemConsumer-&gt;<span class="built_in">acquireBuffer</span>(&amp;bufferItem, <span class="number">0</span> <span class="comment">/* expectedPresent */</span>, <span class="literal">false</span>);</span><br><span class="line">	|--&gt;BufferItemConsumer::<span class="built_in">acquireBuffer</span>(BufferItem *item, <span class="type">nsecs_t</span> presentWhen, <span class="type">bool</span> waitForFence)</span><br><span class="line">        |	<span class="built_in">acquireBufferLocked</span>(item, presentWhen); <span class="comment">// presentWhen = 0</span></span><br><span class="line">		|--&gt;ConsumerBase::<span class="built_in">acquireBufferLocked</span>(BufferItem *item, <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber)</span><br><span class="line">            |	<span class="comment">// 调用消费者的 acquireBuffer, mConsumer 为 BufferQueueConsumer</span></span><br><span class="line">            |	mConsumer-&gt;<span class="built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);</span><br><span class="line">			|--&gt;BufferQueueConsumer::<span class="built_in">acquireBuffer</span>(BufferItem* outBuffer, <span class="type">nsecs_t</span> expectedPresent, <span class="type">uint64_t</span> maxFrameNumber)</span><br><span class="line">            |	<span class="comment">// 参数： outBuffer 是个需要带回数据的指针; expectedPresent = 0; maxFrameNumber = 0</span></span><br><span class="line">                |	<span class="comment">// 拿到队列的迭代指针</span></span><br><span class="line">                |	BufferQueueCore::<span class="function">Fifo::iterator <span class="title">front</span><span class="params">(mCore-&gt;mQueue.begin())</span></span>;</span><br><span class="line">				|	<span class="comment">// 忽略一大段不执行的分支：作用就是丢弃buffer的操作、共享buffer</span></span><br><span class="line">                |	<span class="type">int</span> slot = front-&gt;mSlot; <span class="comment">// 把 mQueue 队列里的第一个 BufferItem 的mSlot，赋值给 slot</span></span><br><span class="line">				|	<span class="comment">// 【把拿到的 BufferItem 通过指针参数带回】</span></span><br><span class="line">				|	*outBuffer = *front; </span><br><span class="line">				|	<span class="built_in">ATRACE_BUFFER_INDEX</span>(slot);<span class="comment">// trace 记录 BufferSlot 的索引值</span></span><br><span class="line">				|	<span class="keyword">if</span> (!outBuffer-&gt;mIsStale) <span class="comment">// 如果buffer没有过时</span></span><br><span class="line">                    |	mSlots[slot].mAcquireCalled = <span class="literal">true</span>;<span class="comment">// 设置状态为已经被acquire过了</span></span><br><span class="line">					|	<span class="comment">// 【切换状态为 acquired 状态】</span></span><br><span class="line">					|	mSlots[slot].mBufferState.<span class="built_in">acquire</span>();</span><br><span class="line">					|	mSlots[slot].mFence = Fence::NO_FENCE;  <span class="comment">// 设置为 NO_FENCE</span></span><br><span class="line">					|	<span class="keyword">if</span> (outBuffer-&gt;mAcquireCalled) <span class="comment">// 已经被消费过了，需要设置 GraphicBuffer 为 nullptr，避免 remapping</span></span><br><span class="line">                        |	outBuffer-&gt;mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">					|	<span class="comment">//【把 BufferItem 从队queued列中移除】</span></span><br><span class="line">					|	mCore-&gt;mQueue.<span class="built_in">erase</span>(front);</span><br><span class="line">					|	mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒等待的线程</span></span><br><span class="line">					|	<span class="comment">// atrace 记录此时的队列长度</span></span><br><span class="line">					|	<span class="built_in">ATRACE_INT</span>(mCore-&gt;mConsumerName.<span class="built_in">string</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>()));</span><br><span class="line">			|	<span class="comment">//返回到 ConsumerBase::acquireBufferLocked</span></span><br><span class="line">			|	<span class="comment">//BBQ生产者 BufferQueueProducer::queueBuffer 时，把 mGraphicBuffer 指针清空了，这个分支不走的</span></span><br><span class="line">			|	<span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">                |	<span class="keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">                    |	<span class="built_in">freeBufferLocked</span>(item-&gt;mSlot);</span><br><span class="line">				|	mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;</span><br><span class="line">			|	<span class="comment">// 这里的 BufferItemConsumer.mSlots 和 BufferQueueConsumer.mSlots 不是同一个对象</span></span><br><span class="line">			|	mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;<span class="comment">// 帧号存到 BufferItemConsumer.mSlots 里</span></span><br><span class="line">			|	mSlots[item-&gt;mSlot].mFence = item-&gt;mFence; <span class="comment">// Fence存到 BufferItemConsumer.mSlots 里</span></span><br><span class="line">		|	<span class="comment">//返回到 BufferItemConsumer::acquireBuffer</span></span><br><span class="line">		|	<span class="keyword">if</span> (waitForFence) <span class="comment">// waitForFence = false ,无需等待fence</span></span><br><span class="line">            |	item-&gt;mFence-&gt;<span class="built_in">waitForever</span>(<span class="string">&quot;BufferItemConsumer::acquireBuffer&quot;</span>);</span><br><span class="line">		|	<span class="comment">// 返回的 GraphicBuffer 为 BLASTBufferItemConsumer.mSlots 的 GraphicBuffer</span></span><br><span class="line">		|	item-&gt;mGraphicBuffer = mSlots[item-&gt;mSlot].mGraphicBuffer;</span><br><span class="line">	|	<span class="comment">//返回到BLASTBufferQueue::acquireNextBufferLocked</span></span><br><span class="line">    |	<span class="keyword">auto</span> buffer = bufferItem.mGraphicBuffer; </span><br><span class="line">	|	mNumFrameAvailable--;</span><br><span class="line">	|	<span class="keyword">if</span> (buffer == <span class="literal">nullptr</span>) <span class="comment">//TODO：流程上，应该是进入了此分支，现实是不可能，这里看了好几遍也没找到问题出哪里了，以后再重新分析一下吧</span></span><br><span class="line">        |	mBufferItemConsumer-&gt;<span class="built_in">releaseBuffer</span>(bufferItem, Fence::NO_FENCE);</span><br><span class="line">        |	<span class="keyword">return</span>;</span><br><span class="line">	|	<span class="comment">// 如果buffer的尺寸不匹配，直接释放buffer，请求下一个</span></span><br><span class="line">	|	<span class="keyword">if</span> (<span class="built_in">rejectBuffer</span>(bufferItem))</span><br><span class="line">        |	mBufferItemConsumer-&gt;<span class="built_in">releaseBuffer</span>(bufferItem, Fence::NO_FENCE);</span><br><span class="line">		|	<span class="built_in">acquireNextBufferLocked</span>(transaction);</span><br><span class="line">		|	<span class="keyword">return</span>;</span><br><span class="line">	|	mNumAcquired++; <span class="comment">// Acquired数量加一，release 时减一</span></span><br><span class="line">	|	mLastAcquiredFrameNumber = bufferItem.mFrameNumber;<span class="comment">// 记录当前的帧号</span></span><br><span class="line">	|	<span class="comment">// 创建 ReleaseCallbackId ，加入到map mSubmitted，SurfaceFlinger 释放buffer，回调回来时会通过ReleaseCallbackId查找BufferItem</span></span><br><span class="line">    |	<span class="function">ReleaseCallbackId <span class="title">releaseCallbackId</span><span class="params">(buffer-&gt;getId(), mLastAcquiredFrameNumber)</span></span>;</span><br><span class="line">	|	mSubmitted[releaseCallbackId] = bufferItem;</span><br><span class="line">	|	mSize = mRequestedSize;</span><br><span class="line">	|	Rect crop = <span class="built_in">computeCrop</span>(bufferItem);<span class="comment">// 裁剪矩形</span></span><br><span class="line">	|	<span class="comment">//【 releaseBuffer 回调函数 !!!!!!!!!!!!!!!!】,SurfaceFlinger合成完后，就是回调的 releaseBufferCallbackThunk函数</span></span><br><span class="line">	|	<span class="keyword">auto</span> releaseBufferCallback = std::<span class="built_in">bind</span>(releaseBufferCallbackThunk, <span class="built_in">wp</span>&lt;BLASTBufferQueue&gt;(<span class="keyword">this</span>),...);</span><br><span class="line">	|	sp&lt;Fence&gt; fence = bufferItem.mFence ? <span class="keyword">new</span> <span class="built_in">Fence</span>(bufferItem.mFence-&gt;<span class="built_in">dup</span>()) : Fence::NO_FENCE;<span class="comment">//GPU绘制的fence</span></span><br><span class="line">	|	<span class="comment">//【把buffer、fence、释放buffer的回调函数 都传入事务，通过事务传递给SurfaceFlinger】</span></span><br><span class="line">	|	t-&gt;<span class="built_in">setBuffer</span>(mSurfaceControl, buffer, fence, bufferItem.mFrameNumber, releaseBufferCallback);</span><br><span class="line">	|	<span class="comment">// 使用 bufferItem中的数据，填充事务的其他各种数据...</span></span><br><span class="line">	|	t-&gt;<span class="built_in">setDataspace</span>(mSurfaceControl, <span class="built_in">static_cast</span>&lt;ui::Dataspace&gt;(bufferItem.mDataSpace));</span><br><span class="line">	|	t-&gt;<span class="built_in">setHdrMetadata</span>(mSurfaceControl, bufferItem.mHdrMetadata);</span><br><span class="line">	|	t-&gt;<span class="built_in">setBufferCrop</span>(mSurfaceControl, crop);</span><br><span class="line">	|	t-&gt;<span class="built_in">setAutoRefresh</span>(mSurfaceControl, bufferItem.mAutoRefresh);</span><br><span class="line">	|	t-&gt;<span class="built_in">setSurfaceDamageRegion</span>(mSurfaceControl, bufferItem.mSurfaceDamage);</span><br><span class="line">	|	<span class="comment">//....</span></span><br><span class="line">    |	<span class="comment">// 最后调用apply，把事务传递到SurfaceFlinger</span></span><br><span class="line">    |	t-&gt;<span class="built_in">setApplyToken</span>(mApplyToken).<span class="built_in">apply</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	|	SurfaceComposerClient::Transaction::<span class="built_in">apply</span>(<span class="type">bool</span> synchronous, <span class="type">bool</span> oneWay)</span><br><span class="line">        |	<span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">		|	sf-&gt;<span class="built_in">setTransactionState</span>(mFrameTimelineInfo, composerStates, displayStates, flags, applyToken,...)</span><br></pre></td></tr></table></figure>

<h3 id="九、SurfaceFlinger-合成—-Android-13-Android-T"><a href="#九、SurfaceFlinger-合成—-Android-13-Android-T" class="headerlink" title="九、SurfaceFlinger 合成— Android 13 (Android T)"></a>九、SurfaceFlinger 合成— Android 13 (Android T)</h3><p><strong>相对于Android 12，Android13在架构上做了微调</strong></p>
<ul>
<li><p>SurfaceFlinger::onMessageInvalidate 对应于 SurfaceFlinger::commit，但是结构上做了大量的调整</p>
<p>一些函数像 handleMessageTransaction、handleTransaction、handleMessageInvalidate、handlePageFlip 这些都不见了</p>
</li>
<li><p>SurfaceFlinger::onMessageRefresh 对应于 SurfaceFlinger::composite</p>
</li>
</ul>
<p><strong>然后Android13 还做了GPU合成的优化</strong></p>
<ul>
<li>对GPU合成进行预测，如果有GPU合成，那么 chooseCompositionStrategy 和 GPU合成 并行执行。用以节约时间。</li>
</ul>
<h4 id="SurfaceComposerClient-Transaction-apply–-gt-SurfaceFlinger-setTransactionState"><a href="#SurfaceComposerClient-Transaction-apply–-gt-SurfaceFlinger-setTransactionState" class="headerlink" title="SurfaceComposerClient::Transaction::apply–&gt;SurfaceFlinger::setTransactionState"></a>SurfaceComposerClient::Transaction::apply–&gt;SurfaceFlinger::setTransactionState</h4><ul>
<li>事务入队。加入到队列  SurfaceFlinger.mTransactionQueue</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//	frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line">SurfaceComposerClient::Transaction::<span class="built_in">apply</span>(<span class="type">bool</span> synchronous, <span class="type">bool</span> oneWay)</span><br><span class="line">|   <span class="comment">// applyToken 来源于 BLASTBufferQueue.h </span></span><br><span class="line">|   <span class="comment">// const sp&lt;IBinder&gt; mApplyToken GUARDED_BY(mMutex) = new BBinder();</span></span><br><span class="line">|	sf-&gt;<span class="built_in">setTransactionState</span>(mFrameTimelineInfo, composerStates, displayStates, flags, applyToken,</span><br><span class="line">                            mInputWindowCommands, mDesiredPresentTime, mIsAutoTimestamp,</span><br><span class="line">                            &#123;&#125; <span class="comment">/*uncacheBuffer - only set in doUncacheBufferTransaction*/</span>,</span><br><span class="line">                            hasListenerCallbacks, listenerCallbacks, mId);</span><br><span class="line"><span class="comment">//进入 SurfaceFlinger 进程</span></span><br><span class="line"><span class="comment">//	frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line">SurfaceFlinger::<span class="built_in">setTransactionState</span>(<span class="type">const</span> FrameTimelineInfo&amp; frameTimelineInfo, <span class="type">const</span> Vector&lt;ComposerState&gt;&amp; states,</span><br><span class="line">                                    <span class="type">const</span> Vector&lt;DisplayState&gt;&amp; displays, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; applyToken,</span><br><span class="line">                                    <span class="type">const</span> InputWindowCommands&amp; inputWindowCommands, <span class="type">int64_t</span> desiredPresentTime,</span><br><span class="line">                                    <span class="type">bool</span> isAutoTimestamp, <span class="type">const</span> <span class="type">client_cache_t</span>&amp; uncacheBuffer, <span class="type">bool</span> hasListenerCallbacks,</span><br><span class="line">                                    <span class="type">const</span> std::vector&lt;ListenerCallbacks&gt;&amp; listenerCallbacks, <span class="type">uint64_t</span> transactionId)</span><br><span class="line">|	<span class="comment">//...</span></span><br><span class="line">|	<span class="type">const</span> <span class="type">int64_t</span> postTime = <span class="built_in">systemTime</span>();</span><br><span class="line">|	IPCThreadState* ipc = IPCThreadState::<span class="built_in">self</span>();</span><br><span class="line">|	<span class="type">const</span> <span class="type">int</span> originPid = ipc-&gt;<span class="built_in">getCallingPid</span>();</span><br><span class="line">|	<span class="type">const</span> <span class="type">int</span> originUid = ipc-&gt;<span class="built_in">getCallingUid</span>();</span><br><span class="line">|	<span class="comment">// 主要逻辑就是把这个 TransactionState 对象入队。然后请求 SF-vsync </span></span><br><span class="line">|	TransactionState state&#123;frameTimelineInfo, states, displays, flags, applyToken, inputWindowCommands, </span><br><span class="line">                           desiredPresentTime, isAutoTimestamp, uncacheBuffer, postTime, permissions,</span><br><span class="line">                           hasListenerCallbacks,listenerCallbacks, originPid, originUid, transactionId&#125;;</span><br><span class="line">|	<span class="comment">//...</span></span><br><span class="line">|	<span class="built_in">queueTransaction</span>(state);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">queueTransaction</span>(TransactionState&amp; state)</span><br><span class="line">    |	state.queueTime = <span class="built_in">systemTime</span>();</span><br><span class="line">	|	<span class="comment">//	std::deque&lt;TransactionState&gt; mTransactionQueue;	双端队列</span></span><br><span class="line">    |	<span class="comment">//【把 TransactionState 入队】</span></span><br><span class="line">    |	<span class="comment">// 在 SurfaceFlinger::flushTransactions() 函数中会出队    </span></span><br><span class="line">	|	mTransactionQueue.<span class="built_in">emplace_back</span>(state);</span><br><span class="line">	|	<span class="built_in">ATRACE_INT</span>(<span class="string">&quot;TransactionQueue&quot;</span>, mTransactionQueue.<span class="built_in">size</span>());</span><br><span class="line">	|	<span class="type">const</span> <span class="keyword">auto</span> schedule = ...;</span><br><span class="line">	|	<span class="type">const</span> <span class="keyword">auto</span> frameHint = state.<span class="built_in">isFrameActive</span>() ? FrameHint::kActive : FrameHint::kNone;</span><br><span class="line">	|	<span class="comment">// 传入的事务flag是枚举类型 eTransactionFlushNeeded = 0x10;</span></span><br><span class="line">	|	<span class="built_in">setTransactionFlags</span>(eTransactionFlushNeeded, schedule, state.applyToken, frameHint);</span><br><span class="line">	|--&gt;SurfaceFlinger::<span class="built_in">setTransactionFlags</span>(<span class="type">uint32_t</span> mask, TransactionSchedule schedule, IBinder&amp; applyToken, FrameHint frameHint)</span><br><span class="line">        |	<span class="comment">// 调整vsync一些时间配置</span></span><br><span class="line">        |	<span class="built_in">modulateVsync</span>(&amp;VsyncModulator::setTransactionSchedule, schedule, applyToken);</span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    			1、mTransactionFlags 添加 eTransactionFlushNeeded 标记</span></span><br><span class="line"><span class="comment">    			2、mTransactionFlags原值 同 mask 相与， 表示原先有没有这个标记。并把结果存储 scheduled</span></span><br><span class="line"><span class="comment">    			3、!scheduled 取非，表示如果原先没有这个标记，就进入此分支，执行 scheduleCommit</span></span><br><span class="line"><span class="comment">    		*/</span> </span><br><span class="line">		|	<span class="keyword">if</span> (<span class="type">const</span> <span class="type">bool</span> scheduled = mTransactionFlags.<span class="built_in">fetch_or</span>(mask) &amp; mask; !scheduled)</span><br><span class="line">            |	<span class="built_in">scheduleCommit</span>(frameHint);</span><br><span class="line">			|--&gt;SurfaceFlinger::<span class="built_in">scheduleCommit</span>(FrameHint hint)</span><br><span class="line">                |	<span class="keyword">if</span> (hint == FrameHint::kActive)</span><br><span class="line">                    |	mScheduler-&gt;<span class="built_in">resetIdleTimer</span>();</span><br><span class="line">				|	mPowerAdvisor-&gt;<span class="built_in">notifyDisplayUpdateImminent</span>();</span><br><span class="line">				|	<span class="comment">// 这个函数的调用链很长，知道这个代码是请求 SurfaceFlinger 的 vsync 就行了</span></span><br><span class="line">				|	mScheduler-&gt;<span class="built_in">scheduleFrame</span>();</span><br></pre></td></tr></table></figure>

<h4 id="MessageQueue-scheduleFrame-—-请求vsync"><a href="#MessageQueue-scheduleFrame-—-请求vsync" class="headerlink" title="MessageQueue::scheduleFrame() — 请求vsync"></a>MessageQueue::scheduleFrame() — 请求vsync</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码MessageQueue::<span class="built_in">scheduleFrame</span>()</span><br><span class="line">|	mVsync.registration-&gt;<span class="built_in">schedule</span>(&#123;.workDuration = mVsync.workDuration.<span class="built_in">get</span>().<span class="built_in">count</span>(),</span><br><span class="line">                                   .readyDuration = <span class="number">0</span>,</span><br><span class="line">                                   .earliestVsync = mVsync.lastCallbackTime.<span class="built_in">count</span>()&#125;);</span><br><span class="line">|--&gt;VSyncCallbackRegistration::<span class="built_in">schedule</span>(VSyncDispatch::ScheduleTiming scheduleTiming)</span><br><span class="line">    |	<span class="keyword">if</span> (!mValidToken)	<span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">	|	<span class="comment">// mDispatch 是 VSyncDispatchTimerQueue</span></span><br><span class="line">    |	<span class="keyword">return</span> mDispatch.<span class="built_in">get</span>().<span class="built_in">schedule</span>(mToken, scheduleTiming);</span><br><span class="line">	|	VSyncDispatchTimerQueue::<span class="built_in">schedule</span>(CallbackToken token, ScheduleTiming scheduleTiming)</span><br><span class="line">        |	ScheduleResult result;</span><br><span class="line">		|	<span class="comment">// VSyncCallbackRegistration 构造的时候，调用registerCallback生成了一个 token ，这个token存储到了 map 对象 mCallbacks</span></span><br><span class="line">        |   <span class="comment">// 现在拿出来</span></span><br><span class="line">        |	<span class="keyword">auto</span> it = mCallbacks.<span class="built_in">find</span>(token);</span><br><span class="line">		|	<span class="keyword">auto</span>&amp; callback = it-&gt;second;  <span class="comment">// map 迭代器 second 中存储 VSyncDispatchTimerQueueEntry</span></span><br><span class="line">		|	<span class="comment">// VSyncDispatchTimerQueueEntry 中存储真正的回调函数 MessageQueue::vsyncCallback</span></span><br><span class="line">		|	result = callback-&gt;<span class="built_in">schedule</span>(scheduleTiming, mTracker, now);</span><br><span class="line">		|	<span class="comment">// 这里步骤还很多。大概是更新vsync的时间配置啥的</span></span><br><span class="line">		|--&gt;VSyncDispatchTimerQueueEntry::<span class="built_in">schedule</span>(VSyncDispatch::ScheduleTiming timing, VSyncTracker&amp; tracker, <span class="type">nsecs_t</span> now)</span><br><span class="line">            |	<span class="comment">//省略VSyncDispatchTimerQueueEntry函数内XXXX，太长了。抽空再研究</span></span><br><span class="line">            |	<span class="comment">//.........</span></span><br><span class="line">        |	<span class="keyword">if</span> (callback-&gt;<span class="built_in">wakeupTime</span>() &lt; mIntendedWakeupTime - mTimerSlack) </span><br><span class="line">            |	<span class="comment">// 启动vsync的定时器</span></span><br><span class="line">            |	<span class="built_in">rearmTimerSkippingUpdateFor</span>(now, it);</span><br><span class="line">		|	<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h4 id="sf-vsync事件分发流程"><a href="#sf-vsync事件分发流程" class="headerlink" title="sf-vsync事件分发流程"></a>sf-vsync事件分发流程</h4><ul>
<li>Android 13 把用了好多年的 onMessageInvalidate()、onMessageRefresh 体系给改了</li>
<li>变成了 SurfaceFlinger::commit 和 SurfaceFlinger::composite ，中间不post消息了，直接无缝切换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//	frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></span><br><span class="line">MessageQueue::<span class="built_in">vsyncCallback</span>(<span class="type">nsecs_t</span> vsyncTime, <span class="type">nsecs_t</span> targetWakeupTime, <span class="type">nsecs_t</span> readyTime)</span><br><span class="line">|	mHandler-&gt;<span class="built_in">dispatchFrame</span>(vsyncId, vsyncTime);</span><br><span class="line">|--&gt;MessageQueue::Handler::<span class="built_in">dispatchFrame</span>(<span class="type">int64_t</span> vsyncId, <span class="type">nsecs_t</span> expectedVsyncTime)</span><br><span class="line">    |	mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>())</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp;) &#123;</span><br><span class="line">    mFramePending.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> frameTime = <span class="built_in">systemTime</span>();</span><br><span class="line">    <span class="comment">// mQueue  类型android::impl::MessageQueue</span></span><br><span class="line">    <span class="comment">// android::impl::MessageQueue.mCompositor 类型 ICompositor</span></span><br><span class="line">    <span class="comment">// SurfaceFlinger 继承 ICompositor</span></span><br><span class="line">    <span class="comment">// mQueue.mCompositor 其实就是 SurfaceFlinger </span></span><br><span class="line">    <span class="keyword">auto</span>&amp; compositor = mQueue.mCompositor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//	【流程1，返回false的话，直接返回，不会执行后面的合成流程composite】</span></span><br><span class="line">    <span class="keyword">if</span> (!compositor.<span class="built_in">commit</span>(frameTime, mVsyncId, mExpectedVsyncTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//	【流程2，合成】</span></span><br><span class="line">    compositor.<span class="built_in">composite</span>(frameTime, mVsyncId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过RegionSamplingThread对合成帧进行采样</span></span><br><span class="line">    compositor.<span class="built_in">sample</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-commit-流程"><a href="#SurfaceFlinger-commit-流程" class="headerlink" title="SurfaceFlinger::commit 流程"></a>SurfaceFlinger::commit 流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//	frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line">SurfaceFlinger::<span class="built_in">commit</span>(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId, <span class="type">nsecs_t</span> expectedVsyncTime)</span><br><span class="line">|	<span class="comment">// 返回 SurfaceFlinger.mTransactionFlags 是否携带 eTransactionFlushNeeded 标记。同时清除这个标记</span></span><br><span class="line">|	<span class="comment">//	eTransactionFlushNeeded 是由 queueTransaction 流程中设置的</span></span><br><span class="line">|	<span class="keyword">if</span> (<span class="built_in">clearTransactionFlags</span>(eTransactionFlushNeeded))</span><br><span class="line">    |	<span class="comment">//【1】、flushTransactions()，核心是获取所有的TransactionState，之后将作为 applyTransactions流程 的参数】</span></span><br><span class="line">    |	<span class="comment">// 把 Transaction::apply 流程中，加入 mTransactionQueue 队列的 TransactionState 出队</span></span><br><span class="line">    |	std::vector&lt;TransactionState&gt; transactions = <span class="built_in">flushTransactions</span>();</span><br><span class="line">	|	<span class="comment">// 这个函数核心就是把 mTransactionQueue 队列的数据转移到一个 vector 中返回</span></span><br><span class="line">        <span class="comment">// 中间处理一些还没有处理完的事务。具体代码待研究</span></span><br><span class="line">	|--&gt;SurfaceFlinger::<span class="built_in">flushTransactions</span>()</span><br><span class="line">        |	std::vector&lt;TransactionState&gt; transactions;</span><br><span class="line">        |	<span class="keyword">while</span> (!mTransactionQueue.<span class="built_in">empty</span>())<span class="comment">// 【取出setTransactionState流程中入队的所有事务】</span></span><br><span class="line">            |	<span class="keyword">auto</span>&amp; transaction = mTransactionQueue.<span class="built_in">front</span>();</span><br><span class="line">			|	<span class="comment">// 省略 X 行代码</span></span><br><span class="line">            |	transactions.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(transaction));<span class="comment">// 把事务转入向量集合 vector&lt;TransactionState&gt; transactions</span></span><br><span class="line">			|	mTransactionQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">			|	<span class="built_in">ATRACE_INT</span>(<span class="string">&quot;TransactionQueue&quot;</span>, mTransactionQueue.<span class="built_in">size</span>());</span><br><span class="line">		|	<span class="keyword">return</span> transactions;	</span><br><span class="line">	|	<span class="comment">// 【2】、处理以前创建的layer，核心就是把新创建的layer加入到Z轴排序集合体系 mCurrentState.layersSortedByZ 】</span></span><br><span class="line">    |	<span class="comment">// Android12以前layersSortedByZ不是在这里添加的。或许谷歌以后想仅仅通过事务的接口创建layer？？</span></span><br><span class="line">    |	needsTraversal |= <span class="built_in">commitCreatedLayers</span>();</span><br><span class="line">	|--&gt;SurfaceFlinger::<span class="built_in">commitCreatedLayers</span>()</span><br><span class="line">        |	std::vector&lt;LayerCreatedState&gt; createdLayers;</span><br><span class="line">			<span class="comment">/* mCreatedLayers： 创建layer流程中，通过 SurfaceFlinger::addClientLayer 把layer添加到了 mCreatedLayers 这个vector中</span></span><br><span class="line"><span class="comment">			   现在开始拿来使用了 */</span></span><br><span class="line">		|	createdLayers = std::<span class="built_in">move</span>(mCreatedLayers); <span class="comment">//数据转移到新的对象createdLayers中</span></span><br><span class="line">		|	mCreatedLayers.<span class="built_in">clear</span>();<span class="comment">//清除mCreatedLayers所有的数据</span></span><br><span class="line">		|	<span class="keyword">if</span> (createdLayers.<span class="built_in">size</span>() == <span class="number">0</span>)  </span><br><span class="line">            |	<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有新增的Layer，直接返回，那么 mLayersAdded 就不会被设置为 true</span></span><br><span class="line">		|	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; createdLayer : createdLayers)</span><br><span class="line">            |	<span class="built_in">handleLayerCreatedLocked</span>(createdLayer);</span><br><span class="line">			|--&gt;SurfaceFlinger::<span class="built_in">handleLayerCreatedLocked</span>(<span class="type">const</span> LayerCreatedState&amp; state)</span><br><span class="line">                |	sp&lt;Layer&gt; layer = state.layer.<span class="built_in">promote</span>();</span><br><span class="line">				|	<span class="type">bool</span> addToRoot = state.addToRoot;</span><br><span class="line">				|	sp&lt;Layer&gt; parent = state.initialParent.<span class="built_in">promote</span>();</span><br><span class="line">				|	<span class="comment">// 如果没有父layer的话，执行以下代码。</span></span><br><span class="line">                |	<span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToRoot)</span><br><span class="line">					|	layer-&gt;<span class="built_in">setIsAtRoot</span>(<span class="literal">true</span>);</span><br><span class="line">					|	<span class="comment">//【添加到 mCurrentState.layersSortedByZ 这个以Z轴排序的集合中】</span></span><br><span class="line">					|	mCurrentState.layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line">				|	<span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>)</span><br><span class="line">                    |	layer-&gt;<span class="built_in">onRemovedFromCurrentState</span>();<span class="comment">// Layer删除处理</span></span><br><span class="line">				|	<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>())</span><br><span class="line">                    |	parent-&gt;<span class="built_in">addChild</span>(layer);</span><br><span class="line">					|	layer-&gt;<span class="built_in">onRemovedFromCurrentState</span>();<span class="comment">// Layer删除处理</span></span><br><span class="line">				|	<span class="keyword">else</span><span class="comment">// <span class="doctag">TODO:</span> 待验证 parent 为 ContainerLayer， addToRoot=true</span></span><br><span class="line">                    |	parent-&gt;<span class="built_in">addChild</span>(layer);<span class="comment">// BufferStateLayer 应该走这里。添加到 Layer.mCurrentChildren 集合中</span></span><br><span class="line">				|	layer-&gt;<span class="built_in">updateTransformHint</span>(mActiveDisplayTransformHint);</span><br><span class="line">				|	mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line">		|	<span class="comment">// 在之后的流程 commitTransactionsLocked 函数中会设置回 false</span></span><br><span class="line">		|	mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">		|	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果有新创建的layer，需要执行合成步骤 SurfaceFlinger.composite 函数</span></span><br><span class="line">	|	needsTraversal |= <span class="built_in">applyTransactions</span>(transactions, vsyncId);</span><br><span class="line">	|	<span class="comment">// 因图形buffer更新放到事务中来了，所以事务这里重点关注 eBufferChanged </span></span><br><span class="line">	|	<span class="comment">//【3】、applyTransactions流程: 把事务中的对于flag的数据存入Layer.mDrawingState对应的属性</span></span><br><span class="line">    |	<span class="comment">// 对于Layer删除、调整Z轴，则是把相关数据存入 SurfaceFlinger.mCurrentState.layersSortedByZ</span></span><br><span class="line">    |	<span class="comment">// 对于图形buffer更新而言，核心就是赋值 mDrawingState.buffer</span></span><br><span class="line">	|--&gt;SurfaceFlinger::<span class="built_in">applyTransactions</span>(std::vector&lt;TransactionState&gt;&amp; transactions,<span class="type">int64_t</span> vsyncId)</span><br><span class="line">        |	<span class="keyword">return</span> <span class="built_in">applyTransactionsLocked</span>(transactions, vsyncId);</span><br><span class="line">		|--&gt;SurfaceFlinger::<span class="built_in">applyTransactionsLocked</span>(std::vector&lt;TransactionState&gt;&amp; transactions, <span class="type">int64_t</span> vsyncId)</span><br><span class="line">            |	<span class="type">bool</span> needsTraversal = <span class="literal">false</span>;</span><br><span class="line">			|	<span class="comment">// 【遍历步骤1中flushTransactions()返回的 transactions】	</span></span><br><span class="line">			|	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; transaction : transactions)</span><br><span class="line">                |	needsTraversal |= <span class="built_in">applyTransactionState</span>(...)</span><br><span class="line">                |--&gt;SurfaceFlinger::<span class="built_in">applyTransactionState</span>(..)</span><br><span class="line">                	|	<span class="type">uint32_t</span> transactionFlags = <span class="number">0</span>;</span><br><span class="line">					|	<span class="type">uint32_t</span> clientStateFlags = <span class="number">0</span>;</span><br><span class="line">                	|	<span class="comment">// 省略一大堆内容</span></span><br><span class="line">                	|	clientStateFlags = <span class="built_in">setClientStateLocked</span>(frameTimelineInfo, state, desiredPresentTime,isAutoTimestamp, postTime, permissions);</span><br><span class="line">					|--&gt;SurfaceFlinger::<span class="built_in">setClientStateLocked</span>(<span class="type">const</span> FrameTimelineInfo&amp; frameTimelineInfo,ComposerState&amp; composerState,...)</span><br><span class="line">                        |	<span class="comment">//省略一大堆内容</span></span><br><span class="line">                        |	<span class="type">layer_state_t</span>&amp; s = composerState.state;</span><br><span class="line">                        |	<span class="comment">// BLASTBufferQueue 传递buffer到SF的时候，调用Transaction::setBuffer 添加 eBufferChanged 标记</span></span><br><span class="line">						|	<span class="keyword">if</span> (what &amp; <span class="type">layer_state_t</span>::eBufferChanged)</span><br><span class="line">                            |	layer-&gt;<span class="built_in">setBuffer</span>(buffer, *s.bufferData, postTime, desiredPresentTime, </span><br><span class="line">                                                     isAutoTimestamp, dequeueBufferTimestamp, frameTimelineInfo)</span><br><span class="line">                            |	<span class="comment">// 只有 BufferStateLayer 覆写了setBuffer，其他layer使用父类Layer.setBuffer,父类的函数直接返回false</span></span><br><span class="line">                            |--&gt;BufferStateLayer::<span class="built_in">setBuffer</span>(std::shared_ptr&lt;renderengine::ExternalTexture&gt;&amp; buffer,<span class="type">const</span> BufferData&amp; bufferData,...)</span><br><span class="line">                            	|	<span class="comment">// 省略一大堆</span></span><br><span class="line">                            	|	<span class="comment">// 这里的 mDrawingState 是 Layer 的，和SurfaceFlinger的 mDrawingState 不是一个类</span></span><br><span class="line">                            	|	<span class="comment">// 以前 Layer也有一个 mCurrentState 对象，现在没有了</span></span><br><span class="line">                            	|	mDrawingState.frameNumber = frameNumber;</span><br><span class="line">								|	mDrawingState.releaseBufferListener = bufferData.releaseBufferListener;</span><br><span class="line">								|	mDrawingState.buffer = std::<span class="built_in">move</span>(buffer);<span class="comment">//【把buffer给到 mDrawingState.buffer】</span></span><br><span class="line">								|	mDrawingState.acquireFence =  ... bufferData.acquireFence;</span><br><span class="line">                                |	mDrawingState.modified = <span class="literal">true</span>; <span class="comment">// 表示是否有状态被修改，几乎所有Layer事务都会设置这个变量为true</span></span><br><span class="line">								|	mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setPostTime</span>(layerId, mDrawingState.frameNumber, <span class="built_in">getName</span>().<span class="built_in">c_str</span>(),mOwnerUid, postTime,...);</span><br><span class="line">                                |	mDrawingState.isAutoTimestamp = isAutoTimestamp;</span><br><span class="line">								|	mDrawingState.releaseBufferEndpoint = bufferData.releaseBufferEndpoint;</span><br><span class="line">						|	<span class="comment">// 每次vsync事件都会伴随生成一个 vsyncId。<span class="doctag">TODO:</span>通常情况可能没有 frameTimelineInfo,，没找到赋值过程，待研究 </span></span><br><span class="line">						|	<span class="keyword">else</span> <span class="keyword">if</span> (frameTimelineInfo.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID)</span><br><span class="line">                            |	layer-&gt;<span class="built_in">setFrameTimelineVsyncForBufferlessTransaction</span>(frameTimelineInfo, postTime);</span><br><span class="line">					|	transactionFlags |= clientStateFlags;<span class="comment">// 添加 setClientStateLocked 返回的flag</span></span><br><span class="line">					|	<span class="type">bool</span> needsTraversal = <span class="literal">false</span>;</span><br><span class="line">					|	<span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) </span><br><span class="line">                        |	transactionFlags = transactionFlags &amp; (~eTraversalNeeded);</span><br><span class="line">						|	needsTraversal = <span class="literal">true</span>;</span><br><span class="line">					|	<span class="keyword">if</span> (transactionFlags)	<span class="built_in">setTransactionFlags</span>(transactionFlags); <span class="comment">//如果还有eTraversalNeeded以外的flag，请求vsync</span></span><br><span class="line">					|	<span class="keyword">return</span> needsTraversal;</span><br><span class="line">            |	<span class="keyword">if</span> (mTransactionTracing) </span><br><span class="line">                |	mTransactionTracing-&gt;<span class="built_in">addCommittedTransactions</span>(transactions, vsyncId);</span><br><span class="line">			|	<span class="keyword">return</span> needsTraversal;<span class="comment">//返回最终的 needsTraversal，这个为true的话，会执行 commitTransactions、composite</span></span><br><span class="line">|	<span class="comment">// 是否需要执行事务提交。【提交的核心就是把 mCurrentState 赋值给 mDrawingState】</span></span><br><span class="line">|	<span class="comment">// mCurrentState 保存APP传来的数据，mDrawingState 用于合成</span></span><br><span class="line">|	<span class="type">const</span> <span class="type">bool</span> shouldCommit =  (<span class="built_in">getTransactionFlags</span>() &amp; ~eTransactionFlushNeeded) || needsTraversal;</span><br><span class="line">|	<span class="comment">//【4】、commitTransactions()流程：核心是把mCurrentState转移到 mDrawingState</span></span><br><span class="line">|	<span class="keyword">if</span>(shouldCommit) </span><br><span class="line">    |	<span class="built_in">commitTransactions</span>();</span><br><span class="line">	|--&gt;SurfaceFlinger:::<span class="built_in">commitTransactions</span>()</span><br><span class="line">    	|	<span class="function">State <span class="title">drawingState</span><span class="params">(mDrawingState)</span></span>;</span><br><span class="line">		|	mDebugInTransaction = <span class="built_in">systemTime</span>();</span><br><span class="line">		|	<span class="built_in">modulateVsync</span>(&amp;VsyncModulator::onTransactionCommit);</span><br><span class="line">		|	<span class="built_in">commitTransactionsLocked</span>(<span class="built_in">clearTransactionFlags</span>(eTransactionMask));</span><br><span class="line">		|--&gt;SurfaceFlinger::<span class="built_in">commitTransactionsLocked</span>(<span class="type">uint32_t</span> transactionFlags);</span><br><span class="line">			|	<span class="comment">// 屏幕的热插拔SurfaceFlinger::onComposerHalHotplug会调用 setTransactionFlags(eDisplayTransactionNeeded)，然后到这里处理</span></span><br><span class="line">            |	<span class="comment">// <span class="doctag">TODO:</span>主线程中接收到的热插拔，不会走到这里。这里处理的可能是非主屏的热插拔，待验证。   </span></span><br><span class="line">			|	<span class="type">const</span> <span class="type">bool</span> displayTransactionNeeded = transactionFlags &amp; eDisplayTransactionNeeded;</span><br><span class="line">			|	<span class="comment">// 处理显示器的事务，显示屏幕增删，显示器的尺寸变化</span></span><br><span class="line">			|	<span class="keyword">if</span> (displayTransactionNeeded)</span><br><span class="line">                |	<span class="built_in">processDisplayChangesLocked</span>();</span><br><span class="line">				|	<span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line">        	|	mCurrentState.<span class="built_in">traverse</span>(...) </span><br><span class="line">            	|	layer-&gt;<span class="built_in">updateTransformHint</span>(hintDisplay-&gt;<span class="built_in">getTransformHint</span>());<span class="comment">//更新旋转提示</span></span><br><span class="line">			|	<span class="keyword">if</span> (mLayersAdded) <span class="comment">// 在此之前的步骤[2] commitCreatedLayers 中设置的 true</span></span><br><span class="line">				|	mLayersAdded = <span class="literal">false</span>;</span><br><span class="line">				|	mVisibleRegionsDirty = <span class="literal">true</span>;<span class="comment">//有脏区域，【用于步骤6计算脏区域】</span></span><br><span class="line">			|	<span class="keyword">if</span> (mLayersRemoved)<span class="comment">// 处理被移除的Layer</span></span><br><span class="line">                |	mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">				|	mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">				|	mDrawingState.<span class="built_in">traverseInZOrder</span>(...)</span><br><span class="line">                    |	Region visibleReg;</span><br><span class="line">					|	visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">					|	<span class="built_in">invalidateLayerStack</span>(layer, visibleReg);<span class="comment">//更新DisplayDevice中原有的可视脏区</span></span><br><span class="line">			|	<span class="comment">//把Layer的添加以及删除从Current状态转为Drawing状态</span></span><br><span class="line">        	|	<span class="built_in">doCommitTransactions</span>();</span><br><span class="line">        	|--&gt;SurfaceFlinger::<span class="built_in">doCommitTransactions</span>()</span><br><span class="line">                |	<span class="comment">// 处理以及被移除的layer集合 mLayersPendingRemoval。释放buffer，从layersSortedByZ移除，加入到mOffscreenLayers</span></span><br><span class="line">                |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; l : mLayersPendingRemoval)</span><br><span class="line">                    |	l-&gt;<span class="built_in">latchAndReleaseBuffer</span>();</span><br><span class="line">                    |	mCurrentState.layersSortedByZ.<span class="built_in">remove</span>(l);</span><br><span class="line">					|	mOffscreenLayers.<span class="built_in">emplace</span>(l.<span class="built_in">get</span>());</span><br><span class="line">				|	mLayersPendingRemoval.<span class="built_in">clear</span>();</span><br><span class="line">                |	<span class="comment">//【核心步骤】</span></span><br><span class="line">            	|	mDrawingState = mCurrentState;</span><br><span class="line">				|	mCurrentState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line">				|	<span class="keyword">if</span> (mVisibleRegionsDirty)</span><br><span class="line">                    |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; rootLayer : mDrawingState.layersSortedByZ)</span><br><span class="line">                        |	<span class="comment">// 遍历所有的根layer，把所有子Layer的mCurrentChildren赋值给mDrawingChildren</span></span><br><span class="line">                        |	rootLayer-&gt;<span class="built_in">commitChildList</span>();</span><br><span class="line">							|	mDrawingChildren = mCurrentChildren;</span><br><span class="line">							|	mDrawingParent = mCurrentParent;</span><br><span class="line">	|	mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">|	<span class="comment">// 如果还有待处理的事务，请求下一个SF vsync</span></span><br><span class="line">|	<span class="keyword">if</span> (<span class="built_in">transactionFlushNeeded</span>())</span><br><span class="line">    |	<span class="built_in">setTransactionFlags</span>(eTransactionFlushNeeded);</span><br><span class="line">|	mustComposite |= shouldCommit;</span><br><span class="line">|	<span class="comment">//【5】、latchBuffers 相当于以前的handlePageFlip 流程</span></span><br><span class="line">|   <span class="comment">//【如果有新的buffer的layer大于0，并且拿到了buffer，SurfaceFlinger::latchBuffers()函数返回true，执行 SurfaceFlinger::composite 】</span></span><br><span class="line">|	mustComposite |= <span class="built_in">latchBuffers</span>();</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">latchBuffers</span>() <span class="comment">//【详细内容，见 latchBuffers() 章节】</span></span><br><span class="line">    |	layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime, expectedPresentTime)</span><br><span class="line">    |	<span class="comment">//父类Layer的 latchBuffer 返回 false, 子类只有 BufferLayer 重载了 latchBuffer </span></span><br><span class="line">    |--&gt;BufferLayer.<span class="built_in">latchBuffer</span>(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> <span class="comment">/*latchTime*/</span>, <span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span><br><span class="line">    	|	<span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime, expectedPresentTime);</span><br><span class="line">		|--&gt;BufferStateLayer::<span class="built_in">updateTexImage</span>(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> latchTime,<span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span><br><span class="line">|	<span class="comment">//【6】、计算边界、脏区域</span></span><br><span class="line">|	<span class="built_in">updateLayerGeometry</span>();</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">updateLayerGeometry</span>()</span><br><span class="line">    |	<span class="keyword">if</span> (mVisibleRegionsDirty) <span class="comment">//【mVisibleRegionsDirty在有新的Layer增加时设置为 true 】</span></span><br><span class="line">        |	<span class="comment">/* 调用每个Layer的 computeBounds 方法</span></span><br><span class="line"><span class="comment">        	   计算每个Layer的以下边界：</span></span><br><span class="line"><span class="comment">        		mSourceBounds  应用任何变换之前以及由其父对象裁剪之前的Layer边界。</span></span><br><span class="line"><span class="comment">        		mBounds		   Layer空间中的Layer边界。mSourceBounds 和 Layer的裁剪矩形的交集，再和其父空间交集</span></span><br><span class="line"><span class="comment">        		mScreenBounds  Layer在屏幕上的空间。由 mBounds transform转换而来 */</span></span><br><span class="line">        |	<span class="built_in">computeLayerBounds</span>();</span><br><span class="line">		|--&gt;SurfaceFlinger::<span class="built_in">computeLayerBounds</span>()</span><br><span class="line">            |	<span class="type">const</span> FloatRect maxBounds = <span class="built_in">getMaxDisplayBounds</span>();</span><br><span class="line">			|	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : mDrawingState.layersSortedByZ)</span><br><span class="line">                    |	layer-&gt;<span class="built_in">computeBounds</span>(maxBounds, ui::<span class="built_in">Transform</span>(), <span class="number">0.f</span> <span class="comment">/* shadowRadius */</span>);</span><br><span class="line">	|	<span class="comment">// mLayersPendingRefresh 参见步骤[5] latchBuffers()</span></span><br><span class="line">	|	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh)<span class="comment">// mLayersPendingRefresh 存储中能拿到 buffer的layer</span></span><br><span class="line">        |	Region visibleReg;</span><br><span class="line">		|	visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">		|	<span class="comment">// 对每个包含当前layer的显示器的脏区域初始化为 Layer.mScreenBounds</span></span><br><span class="line">		|	<span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">	|	<span class="comment">// mLayersPendingRefresh这个集合表示有新的buffer更新，并且能拿到buffer的layer。</span></span><br><span class="line">    |	<span class="comment">// 在 SurfaceFlinger::latchBuffers()流程中添加，此时清空此集合</span></span><br><span class="line">	|	mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">|	<span class="comment">// 非开机阶段，mustComposite==true情况下将执行合成步骤 SurfaceFlinger::composite</span></span><br><span class="line">|	<span class="keyword">return</span> mustComposite &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER);</span><br></pre></td></tr></table></figure>

<h5 id="latchBuffers"><a href="#latchBuffers" class="headerlink" title="latchBuffers()"></a>latchBuffers()</h5><ul>
<li>因为使用 BufferStateLayer + BBQ ， latchBuffer 流程相比Android12以前逻辑要少很多</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">// SurfaceFlinger.mLayersWithQueuedFrames 存储有新buffer的layer</span></span><br><span class="line"><span class="comment">// SurfaceFlinger.mLayersPendingRefresh 存储mLayersWithQueuedFrames中能拿到 buffer的layer。用于更新显示设备的脏区域</span></span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">latchBuffers</span>()</span><br><span class="line">    |	<span class="type">const</span> <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();<span class="comment">// perfetto 会记录这个时间</span></span><br><span class="line">	|	<span class="type">bool</span> visibleRegions = <span class="literal">false</span>;<span class="comment">// 用于 latchBuffer 的参数</span></span><br><span class="line">	|	<span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line">    |	<span class="comment">// 【1、核心逻辑是把 有buffer更新的layer存储到set集合 mLayersWithQueuedFrames】</span></span><br><span class="line">    |	mDrawingState.<span class="built_in">traverse</span>(...)</span><br><span class="line">    	|	<span class="comment">// layer 各种属性变化后都会设置 eTransactionNeeded 这个flag，比如尺寸，背景，位置，inputInfo、刷新率等等，几乎所有的变化都会设置eTransactionNeeded。</span></span><br><span class="line">    	|	<span class="keyword">if</span> (layer-&gt;<span class="built_in">clearTransactionFlags</span>(eTransactionNeeded) || mForceTransactionDisplayChange)</span><br><span class="line">            |	<span class="comment">//	赋值 mDrawingState.transform</span></span><br><span class="line">            |	<span class="comment">//	mDrawingStateModified = mDrawingState.modified;	mDrawingState.modified = false;</span></span><br><span class="line">            |	<span class="type">const</span> <span class="type">uint32_t</span> flags = layer-&gt;<span class="built_in">doTransaction</span>(<span class="number">0</span>);</span><br><span class="line">			|	<span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)	</span><br><span class="line">                |	mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">		|	<span class="comment">// layer有新buffer时，hasReadyFrame() 返回true</span></span><br><span class="line">		|	<span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>())</span><br><span class="line">			|	<span class="comment">// shouldPresentNow函数，对于 BufferStateLayer 而言，有buffer的来了，就返回true</span></span><br><span class="line">            |	<span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime))</span><br><span class="line">                |	<span class="comment">//【2、把有新buffer的layer，加入set集合 mLayersWithQueuedFrames】</span></span><br><span class="line">                |	mLayersWithQueuedFrames.<span class="built_in">emplace</span>(layer);</span><br><span class="line">	|	mForceTransactionDisplayChange = <span class="literal">false</span>;</span><br><span class="line">	|	<span class="comment">// 【3、mLayersWithQueuedFrames不为空，则调用集合中每个layer的 latchBuffer 函数】</span></span><br><span class="line">	|	<span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>())</span><br><span class="line">        |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames)</span><br><span class="line">            |	<span class="comment">// latchBuffer 判断是否需要重新计算显示区域，由参数visibleRegions带回结果</span></span><br><span class="line">            |	<span class="comment">//【4、获取buffer，并把 Layer.mDrawingState 中的属性变量转移到 BufferLayer.mBufferInfo 】</span></span><br><span class="line">            |	<span class="comment">// mBufferInfo 用于 Layer中获取各种buffer信息相关的get方法</span></span><br><span class="line">            |	<span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime, expectedPresentTime))</span><br><span class="line">                |--&gt;BufferLayer::<span class="built_in">latchBuffer</span>(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime, <span class="type">nsecs_t</span> expectedPresentTime)</span><br><span class="line">                	|	<span class="keyword">if</span> (!<span class="built_in">fenceHasSignaled</span>())</span><br><span class="line">                        |	<span class="comment">// 【如果Fence还没有发送信号，请求 SF-vsync，并且函数返回，等一下次的vsync再处理这个buffer】</span></span><br><span class="line">                        |	mFlinger-&gt;<span class="built_in">onLayerUpdate</span>();</span><br><span class="line">						|	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">					|	BufferInfo oldBufferInfo = mBufferInfo;</span><br><span class="line">					|	<span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime, expectedPresentTime);</span><br><span class="line">					|	<span class="comment">// BufferStateLayer 和 以前使用的 BufferQueueLayer 是完全不同的步骤。大部分内容是debug用的</span></span><br><span class="line">					|--&gt;BufferStateLayer::<span class="built_in">updateTexImage</span>(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> latchTime, <span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span><br><span class="line">                        |	<span class="type">const</span> <span class="type">int32_t</span> layerId = <span class="built_in">getSequence</span>();<span class="comment">// sequence，每个layer唯一，是个递增int</span></span><br><span class="line">                        |	<span class="comment">//把 acquireFence 存储到 mFlinger-&gt;mTimeStats-&gt;mTimeStatsTracker[layerId].timeRecords[layerRecord.waitData].acquireFence</span></span><br><span class="line">                        |	mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setAcquireFence</span>(layerId, frameNumber, acquireFence);</span><br><span class="line">						|	mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setLatchTime</span>(layerId, frameNumber, latchTime);</span><br><span class="line">						|	<span class="comment">//  perfetto 相应的数据源配置启用的情况下，记录 Fence 和 latchTime</span></span><br><span class="line">						|	mFlinger-&gt;mFrameTracer-&gt;<span class="built_in">traceFence</span>(...);</span><br><span class="line">                        |	mFlinger-&gt;mFrameTracer-&gt;<span class="built_in">traceTimestamp</span>(...);</span><br><span class="line">                        |	mDrawingStateModified = <span class="literal">false</span>;<span class="comment">// 修改为false，对应于步骤1中 Layer.doTransaction</span></span><br><span class="line">					|	<span class="built_in">updateActiveBuffer</span>();</span><br><span class="line">					|--&gt;BufferStateLayer::<span class="built_in">updateActiveBuffer</span>()</span><br><span class="line">                        |	<span class="function"><span class="type">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">                        |	<span class="comment">//mPendingBufferTransactions--</span></span><br><span class="line">                        |	<span class="comment">// 调用到 latchBuffer 阶段，setBuffer 的事务就算处理完了，待处理的buffer数量计数器 mPendingBufferTransactions要减一</span></span><br><span class="line">                        |	<span class="comment">//这里对应于SurfaceFlinger::setTransactionState函数中：mBufferCountTracker.increment(state.surface-&gt;localBinder());</span></span><br><span class="line">                        |	<span class="comment">// mBufferCountTracker.increment 函数使 mPendingBufferTransactions 自增1</span></span><br><span class="line">                        |	<span class="built_in">decrementPendingBufferCount</span>();</span><br><span class="line">						|	<span class="comment">// 把 mDrawingState 中的buffer、acquireFence、frameNumber 转移到 mBufferInfo</span></span><br><span class="line">						|	mBufferInfo.mBuffer = s.buffer;</span><br><span class="line">						|	mBufferInfo.mFence = s.acquireFence;</span><br><span class="line">						|	mBufferInfo.mFrameNumber = s.frameNumber;</span><br><span class="line">					|	<span class="comment">// mCurrentFrameNumber = mDrawingState.frameNumber; mPreviousFrameNumber = mCurrentFrameNumber;</span></span><br><span class="line">					|	<span class="built_in">updateFrameNumber</span>();</span><br><span class="line">					|--&gt;BufferStateLayer::<span class="built_in">updateFrameNumber</span>()</span><br><span class="line">                        |	mPreviousFrameNumber = mCurrentFrameNumber;</span><br><span class="line">                        |	mCurrentFrameNumber = mDrawingState.frameNumber;	<span class="keyword">return</span> NO_ERROR;</span><br><span class="line">					|	<span class="comment">// 这个函数就是把 mDrawingState 中buffer相关信息的各种变量转移到 mBufferInfo 中</span></span><br><span class="line">                    |	<span class="comment">// mBufferInfo.mDesiredPresentTime、mFenceTime、mFence、mTransform、mDataspace、mCrop、mScaleMode、mSurfaceDamage</span></span><br><span class="line">                    |	<span class="comment">// mHdrMetadata、mApi、mTransformToDisplayInverse、mBufferSlot等等赋值    </span></span><br><span class="line">					|	<span class="built_in">gatherBufferInfo</span>();</span><br><span class="line">					|--&gt;BufferStateLayer::<span class="built_in">gatherBufferInfo</span>()</span><br><span class="line">                        |	BufferLayer::<span class="built_in">gatherBufferInfo</span>();</span><br><span class="line">						|	<span class="function"><span class="type">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">						|	mBufferInfo.mFence = s.acquireFence;</span><br><span class="line">						|	mBufferInfo.mCrop = <span class="built_in">computeBufferCrop</span>(s);</span><br><span class="line">						|	mBufferInfo.mScaleMode = NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW;</span><br><span class="line">						|	mBufferInfo.mBufferSlot = mHwcSlotGenerator-&gt;<span class="built_in">getHwcCacheSlot</span>(s.clientCacheId);</span><br><span class="line">						|	<span class="comment">//....</span></span><br><span class="line">					|	<span class="comment">// 后边的代码是判断 是否需要重新计算显示区域</span></span><br><span class="line">                    |	<span class="comment">// 大致情况是：当前是第一个buffer、裁剪区域变化了，旋转变了，缩放变了，宽高变了，透明度变了，mTransformToDisplayInverse变了</span></span><br><span class="line">                    |	<span class="comment">// 以上情况都需要重新计算显示区域    </span></span><br><span class="line">                    |	<span class="keyword">if</span>(oldBufferInfo.mBuffer == <span class="literal">nullptr</span> || mBufferInfo.mCrop != oldBufferInfo.mCrop ....)</span><br><span class="line">					|	|	recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">					|	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                |	<span class="comment">//【5、如果 latchBuffer 返回true，把layer加入向量集合 mLayersPendingRefresh 】</span></span><br><span class="line">                |	<span class="comment">// 依据 latchBuffer 逻辑，latchBuffer 返回false，通常是由于 Fence 还没有发送信号。当然还有其他细节原因，这里未贴出代码。</span></span><br><span class="line">                |	<span class="comment">//【可以说，mLayersPendingRefresh 保存了GPU绘制已经完成的layer】    </span></span><br><span class="line">                |	mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">				|	newDataLatched = <span class="literal">true</span>;</span><br><span class="line">			|	<span class="comment">// Layer.surfaceDamageRegion = mBufferInfo.mSurfaceDamage;	</span></span><br><span class="line">			|	layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">	|	<span class="comment">//回到 SurfaceFlinger::latchBuffers() 函数</span></span><br><span class="line">    |	<span class="comment">// latchBuffer 函数，由参数 visibleRegions 返回 是否需要重新计算显示区域</span></span><br><span class="line">    |	<span class="comment">// 这里把结果添加到 mVisibleRegionsDirty 变量中</span></span><br><span class="line">	|	mVisibleRegionsDirty |= visibleRegions; </span><br><span class="line">	|	<span class="comment">// 如果有新的buffer的layer大于0，并且 拿到了buffer，</span></span><br><span class="line">    |   <span class="comment">// 那么SurfaceFlinger::latchBuffers()函数返回true，表示需要执行合成步骤 SurfaceFlinger::composite </span></span><br><span class="line">    |	<span class="comment">//【6、如果有新的buffer的layer数量大于0，并且 拿到了buffer，SurfaceFlinger::latchBuffers()函数返回true，执行 SurfaceFlinger::composite 】</span></span><br><span class="line">	|	<span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-composite"><a href="#SurfaceFlinger-composite" class="headerlink" title="SurfaceFlinger::composite"></a>SurfaceFlinger::composite</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码SurfaceFlinger::<span class="built_in">composite</span>(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId)</span><br><span class="line">|	<span class="comment">// 【1】准备合成的参数    </span></span><br><span class="line">|	compositionengine::CompositionRefreshArgs refreshArgs;</span><br><span class="line">|	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    SmallMap&lt;IBinder, DisplayDevice&gt; mDisplays;</span></span><br><span class="line"><span class="comment">    合成是以 mDisplays 元素中的顺序去合成的</span></span><br><span class="line"><span class="comment">    内置的显示器，是在开机的时候加入的，因此按照顺序合成的话，内置显示器要优先于 外部显示器 和 虚拟显示器</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">|   <span class="type">const</span> <span class="keyword">auto</span>&amp; displays = <span class="built_in">FTL_FAKE_GUARD</span>(mStateLock, mDisplays);</span><br><span class="line">|	<span class="comment">// outputs 为Output的vector</span></span><br><span class="line">|	refreshArgs.outputs.<span class="built_in">reserve</span>(displays.<span class="built_in">size</span>());<span class="comment">// 增加容器的大小为显示屏的大小</span></span><br><span class="line">|	<span class="comment">// 遍历显示设备</span></span><br><span class="line">|	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, display] : displays)</span><br><span class="line">    |	<span class="comment">// DisplayDevice.mCompositionDisplay 类型 android::compositionengine::Display，继承 Output</span></span><br><span class="line">    |	<span class="comment">// outputs 代表所有需要合成的显示器</span></span><br><span class="line">    |	refreshArgs.outputs.<span class="built_in">push_back</span>(display-&gt;<span class="built_in">getCompositionDisplay</span>());<span class="comment">//【所有需要合成工作的显示设备】</span></span><br><span class="line">|	<span class="comment">// 遍历 mDrawingState.layersSortedByZ，这个 layersSortedByZ 存储了所有的的layer</span></span><br><span class="line">|	<span class="comment">// 以Z轴顺序遍历 mDrawingState.layersSortedByZ ，从底层开始遍历</span></span><br><span class="line">|	mDrawingState.<span class="built_in">traverseInZOrder</span>(...)</span><br><span class="line">    |	<span class="comment">//	并非所有种类的layer都能通过 Layer.getCompositionEngineLayerFE() 拿到LayerFE对象。是有显示界面的才有返回对象</span></span><br><span class="line">    |	<span class="comment">//	父类 Layer.getCompositionEngineLayerFE() 返回 nullptr</span></span><br><span class="line">    |	<span class="comment">//	只有 BufferLayer 和 EffectLayer 实现了这个方法</span></span><br><span class="line">    |	<span class="comment">// getCompositionEngineLayerFE 这个函数就是返回layer自身，并强转为Layer父类 compositionengine::LayerFE 类型</span></span><br><span class="line">    |	<span class="keyword">if</span> (<span class="keyword">auto</span> layerFE = layer-&gt;<span class="built_in">getCompositionEngineLayerFE</span>())</span><br><span class="line">        |	<span class="comment">// refreshArgs.layers 是 std::vector&lt;sp&lt;compositionengine::LayerFE&gt;&gt; 类型</span></span><br><span class="line">        |	<span class="comment">// 这个是以 Z 轴顺序添加到 layers 中的</span></span><br><span class="line">        |	refreshArgs.layers.<span class="built_in">push_back</span>(layerFE);<span class="comment">//【添加所有参与合成的layer】</span></span><br><span class="line">|	<span class="comment">//	mLayersWithQueuedFrames 是有新的帧数据的Layer</span></span><br><span class="line">|	<span class="comment">//  把有帧数据的Layer转移到 refreshArgs.layersWithQueuedFrames</span></span><br><span class="line">|	refreshArgs.layersWithQueuedFrames.<span class="built_in">reserve</span>(mLayersWithQueuedFrames.<span class="built_in">size</span>());</span><br><span class="line">|	mCompositionEngine-&gt;<span class="built_in">present</span>(refreshArgs);</span><br><span class="line">|	<span class="keyword">for</span> (<span class="keyword">auto</span> layer : mLayersWithQueuedFrames)</span><br><span class="line">    |	<span class="keyword">if</span> (<span class="keyword">auto</span> layerFE = layer-&gt;<span class="built_in">getCompositionEngineLayerFE</span>())</span><br><span class="line">        |	refreshArgs.layersWithQueuedFrames.<span class="built_in">push_back</span>(layerFE);</span><br><span class="line">|	<span class="comment">// 把准备好的合成的参数，传入 CompositionEngine 开始合成工作</span></span><br><span class="line">|	mCompositionEngine-&gt;<span class="built_in">present</span>(refreshArgs);</span><br><span class="line">|--&gt;CompositionEngine::<span class="built_in">present</span>(CompositionRefreshArgs&amp; args)</span><br><span class="line">    |	<span class="comment">// 【2】如果存在新的buffer处理，mNeedsAnotherUpdate设置为true，</span></span><br><span class="line">	|	<span class="built_in">preComposition</span>(args);</span><br><span class="line">	|	<span class="comment">// LayerFESet 是 unordered_set 类型</span></span><br><span class="line">	|	LayerFESet latchedLayers; <span class="comment">// using LayerFESet = std::unordered_set&lt;sp&lt;LayerFE&gt;, LayerFESpHash&gt;; </span></span><br><span class="line">	|	<span class="comment">// 【3】遍历所有需要合成输出的显示设备  【核心是把显示区域相关数据转存到 OutputLayer 的mState对象】</span></span><br><span class="line">	|	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs)<span class="comment">// 第一层循环，遍历所有的显示设备</span></span><br><span class="line">        |	<span class="comment">// 调用每个显示设备的 prepare 方法</span></span><br><span class="line">        |	output-&gt;<span class="built_in">prepare</span>(args, latchedLayers);</span><br><span class="line">		|--&gt;Output::<span class="built_in">prepare</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs, LayerFESet&amp; geomSnapshots)</span><br><span class="line">            |	<span class="built_in">rebuildLayerStacks</span>(refreshArgs, geomSnapshots);</span><br><span class="line">			|--&gt;Output::<span class="built_in">rebuildLayerStacks</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs, LayerFESet&amp; layerFESet)</span><br><span class="line">                |	<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();<span class="comment">// editState() 返回 OutputCompositionState 类型的  Output.mState;</span></span><br><span class="line">				|	compositionengine::Output::CoverageState coverage&#123;layerFESet&#125;;</span><br><span class="line">				|	<span class="comment">// 1、从顶层到底层遍历所有参与合成的Layer，累积计算 覆盖区域、完全不透明区域、脏区域</span></span><br><span class="line">                |	<span class="comment">// 2、存储当前层的显示区域、排除透明区域的显示区域、被覆盖区域、显示器空间显示区域、阴影区域等到 当前显示设备上的OutputLayer的mState对象</span></span><br><span class="line">				|	<span class="built_in">collectVisibleLayers</span>(refreshArgs, coverage);</span><br><span class="line">				|--&gt;Output::<span class="built_in">collectVisibleLayers</span>(CompositionRefreshArgs&amp; refreshArgs,Output::CoverageState&amp; coverage)</span><br><span class="line">                    |	<span class="comment">// 从顶层到底层开始遍历所有Layer，以便于计算哪些可以显示。 这个过程中，每层的显示区域是不断减少的，相反，覆盖区域是不断增大的</span></span><br><span class="line">                    |	<span class="keyword">for</span> (<span class="keyword">auto</span> layer : <span class="built_in">reversed</span>(refreshArgs.layers))</span><br><span class="line">                        |	<span class="comment">// 1、从顶层到底层遍历所有参与合成的Layer，累积计算 覆盖区域、完全不透明区域、脏区域</span></span><br><span class="line">                        |	<span class="comment">// 2、【如果显示设备没有对应的 OutputLayer，创建 OutputLayer 同时创建 HWCLayer，并作为 OutputLayer.mState 的成员】</span></span><br><span class="line">                        |	<span class="comment">// 3、存储当前层的显示区域、排除透明区域的显示区域、被覆盖区域、显示器空间显示区域、阴影区域等到 当前显示设备上的 OutputLayer 的mState对象</span></span><br><span class="line">                        |	<span class="comment">//OutputLayer.mState.visibleRegion、visibleNonTransparentRegion、coveredRegion、outputSpaceVisibleRegion、shadowRegion</span></span><br><span class="line">                        |	<span class="comment">//outputSpaceBlockingRegionHint</span></span><br><span class="line">                        |	<span class="comment">// 4、Output.mPendingOutputLayersOrderedByZ.emplace_back(std::move(outputLayer));</span></span><br><span class="line">                        |	<span class="built_in">ensureOutputLayerIfVisible</span>(layer, coverage);</span><br><span class="line">                    |	<span class="comment">// setReleasedLayers 函数会遍历 Output.mCurrentOutputLayersOrderedByZ</span></span><br><span class="line">                    |	<span class="comment">// 此时 Output.mCurrentOutputLayersOrderedByZ 中会在当前vsync显示的layer都转移到了mPendingOutputLayersOrderedByZ</span></span><br><span class="line">					|	<span class="comment">// 这里会把mCurrentOutputLayersOrderedByZ余下的Layer中，在当前vsync，入队新的buffer的layer放入到 Output.mReleasedLayers 中</span></span><br><span class="line">                    |	<span class="comment">// 就是说，mReleasedLayers是一些即将移除的的layer，但是当前vsync还在生产帧数据的layer</span></span><br><span class="line">					|	<span class="built_in">setReleasedLayers</span>(refreshArgs);</span><br><span class="line">					|	<span class="comment">// 把 Output.mPendingOutputLayersOrderedByZ 转到 Output.mCurrentOutputLayersOrderedByZ //使用的move赋值</span></span><br><span class="line">                    |	<span class="comment">// 【每个vsync内，Output中存储的OutputLayer，都是最新即将要显示的Layer】</span></span><br><span class="line">					|	<span class="built_in">finalizePendingOutputLayers</span>();</span><br><span class="line">				|	<span class="type">const</span> ui::Transform&amp; tr = outputState.transform;</span><br><span class="line">				|	Region undefinedRegion&#123;outputState.displaySpace.<span class="built_in">getBoundsAsRect</span>()&#125;;</span><br><span class="line">				|	<span class="comment">// 整个显示空间 减去 所有Layer的不透明覆盖区域 为未定义的区域</span></span><br><span class="line">				|	undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(coverage.aboveOpaqueLayers));</span><br><span class="line">				|	outputState.undefinedRegion = undefinedRegion;</span><br><span class="line">				|	<span class="comment">// 把计算好的脏区域传入 outputState.dirtyRegion // Output::postFramebuffer() 中被清空</span></span><br><span class="line">				|	outputState.dirtyRegion.<span class="built_in">orSelf</span>(coverage.dirtyRegion);</span><br><span class="line">	|	<span class="comment">// 【4】把状态属性转移到 BufferLayer.mCompositionState。这个对象是 compositionengine::LayerFECompositionState 类型</span></span><br><span class="line">    |	<span class="comment">// 可以通过 LayerFE.getCompositionState() 获取合成状态对象。不算EffectLayer的话，其实就是就是获取 BufferLayer.mCompositionState</span></span><br><span class="line">	|	<span class="built_in">updateLayerStateFromFE</span>(args);</span><br><span class="line">	|--&gt;CompositionEngine::<span class="built_in">updateLayerStateFromFE</span>(CompositionRefreshArgs&amp; args)</span><br><span class="line">        |	<span class="comment">// 从前端layer中更新合成状态</span></span><br><span class="line">        |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs)</span><br><span class="line">            |	output-&gt;<span class="built_in">updateLayerStateFromFE</span>(args);</span><br><span class="line">			|--&gt;Output::<span class="built_in">updateLayerStateFromFE</span>(<span class="type">const</span> CompositionRefreshArgs&amp; args)</span><br><span class="line">                |	<span class="comment">// SurfaceFlinger.mVisibleRegionsDirty 为true时， args.updatingGeometryThisFrame=true</span></span><br><span class="line">                |	<span class="comment">// 有新的Layer增加时 mVisibleRegionsDirty 为true</span></span><br><span class="line">                |	layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">prepareCompositionState</span>(args.updatingGeometryThisFrame ? LayerFE::StateSubset::GeometryAndContent</span><br><span class="line">                                                                : LayerFE::StateSubset::Content);</span><br><span class="line">				|--&gt;Layer::<span class="built_in">prepareCompositionState</span>(compositionengine::LayerFE::StateSubset subset)</span><br><span class="line">                    |	<span class="comment">// 根据 StateSubset 的类型选择以下函数的几种组合去执行</span></span><br><span class="line">                    |	<span class="comment">/* prepareBasicGeometry更新BufferLayer状态对象LayerFECompositionState(mCompositionState)的以下属性:</span></span><br><span class="line"><span class="comment">                    		 outputFilter、isVisible、isOpaque、shadowRadius、contentDirty、geomLayerBounds、geomLayerTransform、</span></span><br><span class="line"><span class="comment">                    		 geomInverseLayerTransform、transparentRegionHint、blendMode、alpha、backgroundBlurRadius、blurRegions、stretchEffect </span></span><br><span class="line"><span class="comment">                    	   同时设置 Layer.contentDirty = false;*/</span></span><br><span class="line">                    |	<span class="built_in">prepareBasicGeometryCompositionState</span>();</span><br><span class="line">						<span class="comment">/*更新BufferLayer状态对象mCompositionState的以下属性:</span></span><br><span class="line"><span class="comment">							geomBufferSize、geomContentCrop、geomCrop、geomBufferTransform、</span></span><br><span class="line"><span class="comment">							geomBufferUsesDisplayInverseTransform|geomUsesSourceCrop、isSecure、metadata</span></span><br><span class="line"><span class="comment">						  就是集合图形相关的属性*/</span></span><br><span class="line">					|	<span class="built_in">prepareGeometryCompositionState</span>();</span><br><span class="line">						<span class="comment">/* preparePerFrameCompositionState更新BufferLayer状态对象mCompositionState的以下属性:</span></span><br><span class="line"><span class="comment">						      compositionType、hdrMetadata、compositionType、buffer、bufferSlot、acquireFence、frameNumber、sidebandStreamHasFrame</span></span><br><span class="line"><span class="comment">						      forceClientComposition、isColorspaceAgnostic、dataspace、colorTransform、colorTransformIsIdentity、surfaceDamage</span></span><br><span class="line"><span class="comment">						      hasProtectedContent、dimmingEnabled、isOpaque、stretchEffect、blurRegions、backgroundBlurRadius、fps</span></span><br><span class="line"><span class="comment">						   就是帧数据相关的属性*/</span></span><br><span class="line">					|	<span class="built_in">preparePerFrameCompositionState</span>();</span><br><span class="line">				|</span><br><span class="line">	|	<span class="comment">// 调用每个显示设备的 present 方法</span></span><br><span class="line">	|	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs)</span><br><span class="line">        |	output-&gt;<span class="built_in">present</span>(args);</span><br><span class="line">		|--&gt;Output::<span class="built_in">present</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line">            |	<span class="comment">// 2.4.1 更新Output合成状态对象OutputCompositionState</span></span><br><span class="line">            |	<span class="comment">// Output.mState的 colorMode、dataspace、renderIntent、targetDataspace 属性 </span></span><br><span class="line">            |	<span class="built_in">updateColorProfile</span>(refreshArgs);</span><br><span class="line">			|	<span class="comment">// 2.4.2 更新 OutputLayer.mState.forceClientComposition、displayFrame、sourceCrop、bufferTransform、dataspace</span></span><br><span class="line">            |	<span class="comment">// 【显示区域相关属性已经在rebuildLayerStacks阶段更新完成，至此OutputLayer.mState的属性基本全更新完了】   </span></span><br><span class="line">			|	<span class="built_in">updateCompositionState</span>(refreshArgs);</span><br><span class="line">			|--&gt;Output::<span class="built_in">updateCompositionState</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line">                |	<span class="comment">// 查找最顶层使用背景模糊的 OutputLayer</span></span><br><span class="line">                |	mLayerRequestingBackgroundBlur = <span class="built_in">findLayerRequestingBackgroundComposition</span>();</span><br><span class="line">				|	<span class="comment">// 如果有 OutputLayer 使用了背景模糊，则必须使用 GPU 合成</span></span><br><span class="line">                |	<span class="type">bool</span> forceClientComposition = mLayerRequestingBackgroundBlur != <span class="literal">nullptr</span>;</span><br><span class="line">				|	<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">        			|	<span class="comment">/* 更新每个OutputLayer OutputLayerState 的以下属性</span></span><br><span class="line"><span class="comment">        			|		forceClientComposition、displayFrame、sourceCrop、bufferTransform、bufferTransform、dataspace */</span></span><br><span class="line">                    |	layer-&gt;<span class="built_in">updateCompositionState</span>(refreshArgs.updatingGeometryThisFrame,refreshArgs.devOptForceClientComposition ||</span><br><span class="line">                    |                                  forceClientComposition, refreshArgs.internalDisplayRotationFlags)</span><br><span class="line">                    |	<span class="comment">// 到最顶层使用背景模糊的 OutputLayer 之前都强制使用 GPU 合成</span></span><br><span class="line">                    |	<span class="keyword">if</span> (mLayerRequestingBackgroundBlur == layer)</span><br><span class="line">                    |   |	forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">			|	<span class="comment">// 2.4.3</span></span><br><span class="line">			|	<span class="built_in">planComposition</span>();</span><br><span class="line">			|--&gt;Output::<span class="built_in">planComposition</span>()</span><br><span class="line">                |	<span class="comment">// 需要 ro.surface_flinger.enable_layer_caching 这个属性为true，mLayerCachingEnabled=true，然后才会启用 Planner</span></span><br><span class="line">                |	<span class="comment">// Planner 似乎还未启用，目前查几台机器都未启用</span></span><br><span class="line">                |	<span class="keyword">if</span> (!mPlanner || !<span class="built_in">getState</span>().isEnabled)</span><br><span class="line">                    |	<span class="keyword">return</span>;</span><br><span class="line">				|	<span class="comment">// 把Layer扁平化到数据结构  compositionengine::impl::OutputLayerCompositionState.overrideInfo</span></span><br><span class="line">                |	<span class="comment">// 缓存layer，扁平化到override中，下次再用其中的数据。TODO：似乎还未启用，暂时忽略    </span></span><br><span class="line">				|	mPlanner-&gt;<span class="built_in">plan</span>(<span class="built_in">getOutputLayersOrderedByZ</span>());</span><br><span class="line">			|	<span class="comment">// 2.4.4 把状态属性写入HWC待执行的缓存，等待执行</span></span><br><span class="line">			|	<span class="built_in">writeCompositionState</span>(refreshArgs);</span><br><span class="line">			|--&gt;Output::<span class="built_in">writeCompositionState</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line">                |	<span class="comment">// 遍历当前显示器的 OutputLayer</span></span><br><span class="line">                |	<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">                    |	<span class="comment">// 前边一大段是 透视图层 的处理</span></span><br><span class="line">                    |	<span class="comment">// 如果上一个Layer的buffer和当前的Layer的buffer一样，那么忽略当前Layer</span></span><br><span class="line">                    |	<span class="comment">// 下面直接看主逻辑</span></span><br><span class="line">                    |	layer-&gt;<span class="built_in">writeStateToHWC</span>(includeGeometry, skipLayer, z++, overrideZ, isPeekingThrough);</span><br><span class="line">					|--&gt;OutputLayer::<span class="built_in">writeStateToHWC</span>(<span class="type">bool</span> includeGeometry, <span class="type">bool</span> skipLayer, <span class="type">uint32_t</span> z,<span class="type">bool</span> zIsOverridden, <span class="type">bool</span> isPeekingThrough)</span><br><span class="line">                        |	<span class="type">const</span> <span class="keyword">auto</span>&amp; state = <span class="built_in">getState</span>();</span><br><span class="line">						|	<span class="keyword">if</span> (!state.hwc) <span class="keyword">return</span>;	<span class="comment">//如果没有HWC接口，直接返回</span></span><br><span class="line">						|	<span class="keyword">auto</span>&amp; hwcLayer = (*state.hwc).hwcLayer;</span><br><span class="line">						|	<span class="keyword">if</span> (!hwcLayer)	<span class="keyword">return</span>; <span class="comment">// 如果没有 hwcLayer 直接返回</span></span><br><span class="line">						|	<span class="comment">// 获取 Layer 的 LayerFECompositionState ，只有 BufferLayer和 EffectLayer 有</span></span><br><span class="line">						|	<span class="type">const</span> <span class="keyword">auto</span>* outputIndependentState = <span class="built_in">getLayerFE</span>().<span class="built_in">getCompositionState</span>();</span><br><span class="line">						|	<span class="keyword">if</span> (!outputIndependentState)	<span class="keyword">return</span>;</span><br><span class="line">						|	<span class="comment">// 合成类型</span></span><br><span class="line">						|	<span class="keyword">auto</span> requestedCompositionType = outputIndependentState-&gt;compositionType;</span><br><span class="line">						|	<span class="comment">// 有忽略的layer，新增的layer</span></span><br><span class="line">						|	<span class="keyword">if</span> (... skipLayer || includeGeometry)</span><br><span class="line">                            |	<span class="comment">// 写入HWC依赖显示设备的几何图形信息</span></span><br><span class="line">                            |	<span class="comment">// HWC2::Layer.setDisplayFrame、setSourceCrop、setZOrder、setTransform</span></span><br><span class="line">                            |	<span class="built_in">writeOutputDependentGeometryStateToHWC</span>(hwcLayer.<span class="built_in">get</span>(), requestedCompositionType, z);</span><br><span class="line">							|	<span class="comment">// 写入HWC不依赖显示设备的几何图形信息</span></span><br><span class="line">                            |	<span class="comment">// HWC2::Layer.setBlendMode、setPlaneAlpha、setLayerGenericMetadata</span></span><br><span class="line">                            |	<span class="comment">//	skipLayer 为true的话，alpha=0.0f 颜色设置为完全透明</span></span><br><span class="line">							|	<span class="built_in">writeOutputIndependentGeometryStateToHWC</span>(hwcLayer.<span class="built_in">get</span>(), *outputIndependentState, skipLayer);</span><br><span class="line">						|	<span class="comment">// 写入HWC依赖显示设备的每个帧状态 </span></span><br><span class="line">                        |	<span class="comment">// HWC2::Layer.etVisibleRegion、setBlockingRegion、setDataspace、setBrightness</span></span><br><span class="line">						|	<span class="built_in">writeOutputDependentPerFrameStateToHWC</span>(hwcLayer.<span class="built_in">get</span>());</span><br><span class="line">						|	<span class="comment">// 写入HWC不依赖显示设备的每帧状态</span></span><br><span class="line">                        |	<span class="comment">// HWC2::Layer.setColorTransform、setSurfaceDamage、setPerFrameMetadata、setBuffer</span></span><br><span class="line">						|	<span class="built_in">writeOutputIndependentPerFrameStateToHWC</span>(hwcLayer.<span class="built_in">get</span>(), *outputIndependentState, requestedCompositionType, skipLayer);</span><br><span class="line">						|	<span class="comment">// 写入合成类型  HWC2::Layer.setCompositionType</span></span><br><span class="line">						|	<span class="built_in">writeCompositionTypeToHWC</span>(hwcLayer.<span class="built_in">get</span>(), requestedCompositionType, isPeekingThrough, skipLayer);</span><br><span class="line">			|	<span class="comment">// 2.4.5 设置显示设备的颜色矩阵，做颜色变换，色盲、护眼模式等</span></span><br><span class="line">			|	<span class="built_in">setColorTransform</span>(refreshArgs);</span><br><span class="line">			|	<span class="comment">// 2.4.6 给虚拟显示屏用的。正常主屏使用 FramebufferSurface ，啥事也不做</span></span><br><span class="line">			|	<span class="built_in">beginFrame</span>();</span><br><span class="line">			|	GpuCompositionResult result;</span><br><span class="line">			|	<span class="comment">// 是否可以预测合成策略--Android 13 新增</span></span><br><span class="line">            |	<span class="comment">// 去掉一些小概率原因，总结：如果上次不全是硬件合成，且存在GPU合成Layer时，返回true    </span></span><br><span class="line">			|	<span class="type">const</span> <span class="type">bool</span> predictCompositionStrategy = <span class="built_in">canPredictCompositionStrategy</span>(refreshArgs);</span><br><span class="line">			|	<span class="keyword">if</span> (predictCompositionStrategy)</span><br><span class="line">                |	<span class="comment">// 异步执行 chooseCompositionStrategy --Android 13 新增</span></span><br><span class="line">                |	<span class="comment">// 就是 chooseCompositionStrategy 和 GPU合成 并行执行。用以节约时间</span></span><br><span class="line">                |	result = <span class="built_in">prepareFrameAsync</span>(refreshArgs);</span><br><span class="line">			|	<span class="keyword">else</span></span><br><span class="line">                |	<span class="comment">//核心逻辑还是确认使用 客户端合成 还是 使用硬件合成</span></span><br><span class="line">                |	<span class="built_in">prepareFrame</span>();<span class="comment">//【转“Output::prepareFrame()”章节】</span></span><br><span class="line">				|--&gt;Output::<span class="built_in">prepareFrame</span>()<span class="comment">// 详情参见：prepareFrame() 章节</span></span><br><span class="line">                    |	<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();</span><br><span class="line">                    |	std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt; changes;</span><br><span class="line">					|	<span class="type">bool</span> success = <span class="built_in">chooseCompositionStrategy</span>(&amp;changes);<span class="comment">//选择合成策略</span></span><br><span class="line">					|	<span class="built_in">resetCompositionStrategy</span>();<span class="comment">// 重置合成策略的变量</span></span><br><span class="line">					|	outputState.previousDeviceRequestedChanges = changes;</span><br><span class="line">					|	outputState.previousDeviceRequestedSuccess = success;</span><br><span class="line">					|	<span class="keyword">if</span> (success)</span><br><span class="line">                        |	<span class="built_in">applyCompositionStrategy</span>(changes);<span class="comment">//应用合成策略</span></span><br><span class="line">					|	<span class="built_in">finishPrepareFrame</span>();<span class="comment">// 用于虚拟屏</span></span><br><span class="line">			|	<span class="comment">//继续 Output::present(const compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span></span><br><span class="line">			|	<span class="built_in">devOptRepaintFlash</span>(refreshArgs);<span class="comment">// doDebugFlashRegions当打开开发者选项中的“显示Surface刷新”时，额外为产生变化的图层绘制闪烁动画</span></span><br><span class="line">			|	<span class="comment">// GPU 合成，新增了一些对 prepareFrameAsync 结果的处理逻辑</span></span><br><span class="line">			|	<span class="built_in">finishFrame</span>(refreshArgs, std::<span class="built_in">move</span>(result));<span class="comment">//【转“Output::finishFrame”章节】</span></span><br><span class="line">			|	<span class="comment">//【转“Output::postFramebuffer()”】</span></span><br><span class="line">			|	<span class="built_in">postFramebuffer</span>();<span class="comment">// postFramebuffer 函数就是告诉HWC开始做最后的合成了,并显示。获取释放fence，</span></span><br><span class="line">			|	<span class="comment">// 渲染最新的 cached sets，需要开启了Planner。TODO：渲染设置了预期显示时间的buffer？</span></span><br><span class="line">			|	<span class="built_in">renderCachedSets</span>(refreshArgs);</span><br><span class="line">|	<span class="built_in">postFrame</span>();<span class="comment">// 没啥东西输出log</span></span><br><span class="line">|	<span class="built_in">postComposition</span>();<span class="comment">// 杂七杂八的合成后处理，对于 BufferStateLayer 最终要的是 releasePendingBuffer</span></span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">postComposition</span>() </span><br><span class="line">    |	<span class="comment">// 省略一大段内容</span></span><br><span class="line">    |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer: mLayersWithQueuedFrames)</span><br><span class="line">        |	<span class="comment">// 都是更新 FrameTracker、TimeStats 这些</span></span><br><span class="line">        |	layer-&gt;<span class="built_in">onPostComposition</span>(display, glCompositionDoneFenceTime,mPreviousPresentFences[<span class="number">0</span>].fenceTime, compositorTiming);</span><br><span class="line">		|	layer-&gt;<span class="built_in">releasePendingBuffer</span>(<span class="comment">/*dequeueReadyTime*/</span> now);</span><br><span class="line">		|--&gt;BufferStateLayer::<span class="built_in">releasePendingBuffer</span>(<span class="type">nsecs_t</span> dequeueReadyTime)</span><br><span class="line">            |	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; handle : mDrawingState.callbackHandles)</span><br><span class="line">                |	<span class="keyword">if</span> (handle-&gt;releasePreviousBuffer &amp;&amp; mDrawingState.releaseBufferEndpoint == handle-&gt;listener)</span><br><span class="line">                    |	<span class="comment">// 这个 mPreviousReleaseCallbackId 在 BufferStateLayer::updateActiveBuffer() 赋值</span></span><br><span class="line">                    |	<span class="comment">// mPreviousReleaseCallbackId = &#123;getCurrentBufferId(), mBufferInfo.mFrameNumber&#125;;</span></span><br><span class="line">                    |	handle-&gt;previousReleaseCallbackId = mPreviousReleaseCallbackId;</span><br><span class="line">					|	<span class="keyword">break</span>;</span><br><span class="line">			|	<span class="comment">// 把 callback 加入 TransactionCallbackInvoker::mCompletedTransactions</span></span><br><span class="line">			|	mFlinger-&gt;<span class="built_in">getTransactionCallbackInvoker</span>().<span class="built_in">addCallbackHandles</span>(mDrawingState.callbackHandles, jankData);</span><br><span class="line">	|	<span class="comment">//【这里就是通过binder通信，回调到 APP 端BBQ执行 releaseBuffer 了】</span></span><br><span class="line">	|	mTransactionCallbackInvoker.<span class="built_in">sendCallbacks</span>(<span class="literal">false</span> <span class="comment">/* onCommitOnly */</span>);</span><br><span class="line">		|--&gt;BpTransactionCompletedListener::<span class="built_in">onTransactionCompleted</span>(android::ListenerStats)</span><br><span class="line">|	<span class="comment">// 如果还有新的buffer，需要请求新的vsync</span></span><br><span class="line">|	<span class="keyword">if</span> (mCompositionEngine-&gt;<span class="built_in">needsAnotherUpdate</span>())</span><br><span class="line">    |	<span class="built_in">scheduleCommit</span>(FrameHint::kNone)</span><br></pre></td></tr></table></figure>

<h5 id="Output-prepareFrame"><a href="#Output-prepareFrame" class="headerlink" title="Output::prepareFrame()"></a>Output::prepareFrame()</h5><ul>
<li>所谓 Client 合成，就是 HWC 的客户端 SurfaceFlinger 去合成，SurfaceFlinger 合成的话使用GPU合成，因此 Client 合成，即GPU合成</li>
<li>prepareFrame <strong>核心逻辑是确认使用 客户端合成 还是 使用硬件合成</strong></li>
<li>prepareFrame  函数中同  HWC服务 交互去确认是否有客户端合成，如果没有客户端合成，并可以忽略验证，那么会直接显示。流程到这里基本结束了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码CompositionEngine::<span class="built_in">present</span>(CompositionRefreshArgs&amp; args)</span><br><span class="line">|	<span class="comment">//....</span></span><br><span class="line">|--&gt;Output::<span class="built_in">prepareFrame</span>()</span><br><span class="line">|	<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();</span><br><span class="line">|	std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt; changes;</span><br><span class="line">|	<span class="type">bool</span> success = <span class="built_in">chooseCompositionStrategy</span>(&amp;changes);</span><br><span class="line">|--&gt;Display::<span class="built_in">chooseCompositionStrategy</span>(std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt;* outChanges)</span><br><span class="line">    |	<span class="comment">// 在最近的一次合成中如果有任意一个layer是 GPU 合成，则返回true</span></span><br><span class="line">    |	<span class="type">const</span> <span class="type">bool</span> requiresClientComposition = <span class="built_in">anyLayersRequireClientComposition</span>();</span><br><span class="line">	|	<span class="type">status_t</span> result = hwc.<span class="built_in">getDeviceCompositionChanges</span>(*halDisplayId, requiresClientComposition,...outChanges);</span><br><span class="line">    |--&gt;HWComposer::<span class="built_in">getDeviceCompositionChanges</span>(HalDisplayId displayId, <span class="type">bool</span> frameUsesClientComposition,...outChanges)</span><br><span class="line">        |	<span class="comment">// 如果有需要GPU合成的layer， canSkipValidate=false;</span></span><br><span class="line">        |	<span class="comment">// 没有需要GPU合成的layer，如果Composer支持获得预期的展示时间，canSkipValidate=true;</span></span><br><span class="line">        |	<span class="comment">// 没有需要GPU合成的layer，Composer 也不支持获得预期的当前时间，只有当我们知道我们不会提前呈现时，我们才能跳过验证。</span></span><br><span class="line">        |	<span class="type">const</span> <span class="type">bool</span> canSkipValidate = &#123;...&#125;;</span><br><span class="line">		|	<span class="keyword">if</span> (canSkipValidate)</span><br><span class="line">            |	sp&lt;Fence&gt; outPresentFence;</span><br><span class="line">            |	<span class="type">uint32_t</span> state = UINT32_MAX;</span><br><span class="line">			|	<span class="comment">//如果可以跳过验证，则直接在屏幕上显示内容,否则执行 validate(HWC 检查各个图层的状态，并确定如何进行合成)</span></span><br><span class="line">            |	<span class="comment">// numTypes返回合成类型需要变更的layer数量，numRequests 返回需要做getDisplayRequests请求的layer数量    </span></span><br><span class="line">            |	hwcDisplay-&gt;<span class="built_in">presentOrValidate</span>(expectedPresentTime, &amp;numTypes, &amp;numRequests, &amp;outPresentFence, &amp;state);</span><br><span class="line">			|	<span class="keyword">if</span> (state == <span class="number">1</span>)</span><br><span class="line">                |	<span class="comment">// 跳过了验证环节，直接显示了。这时直接返回</span></span><br><span class="line">                |	std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">				|	hwcDisplay-&gt;<span class="built_in">getReleaseFences</span>(&amp;releaseFences);<span class="comment">// 显示成功，会返回 Fence fd</span></span><br><span class="line">				|	displayData.releaseFences = std::<span class="built_in">move</span>(releaseFences);</span><br><span class="line">				|	displayData.lastPresentFence = outPresentFence;</span><br><span class="line">				|	displayData.validateWasSkipped = <span class="literal">true</span>;</span><br><span class="line">				|	displayData.presentError = error;</span><br><span class="line">				|	<span class="keyword">return</span> NO_ERROR;</span><br><span class="line">		|	<span class="keyword">else</span></span><br><span class="line">            |	<span class="comment">// HWC 检查各个图层的状态，并确定如何进行合成</span></span><br><span class="line">            |	<span class="comment">// numTypes返回合成类型需要变更的layer数量，numRequests 返回需要做getDisplayRequests请求的layer数量</span></span><br><span class="line">            |	hwcDisplay-&gt;<span class="built_in">validate</span>(expectedPresentTime, &amp;numTypes, &amp;numRequests);</span><br><span class="line">		|	<span class="comment">// composer3::Composition 为枚举类型：</span></span><br><span class="line">		|	<span class="comment">//&#123; INVALID = 0, CLIENT = 1,  DEVICE = 2,  SOLID_COLOR = 3,  CURSOR = 4,  SIDEBAND = 5,  DISPLAY_DECORATION = 6,&#125;; </span></span><br><span class="line">		|	std::unordered_map&lt;HWC2::Layer*, composer3::Composition&gt; changedTypes;</span><br><span class="line">		|	changedTypes.<span class="built_in">reserve</span>(numTypes);<span class="comment">// map扩容为numTypes</span></span><br><span class="line">		|	<span class="comment">// changedTypes 返回 map&lt;Layer，Composition&gt;  包含所有 与上次调用validateDisplay之前设置的合成类型不同的合成类型的Layer</span></span><br><span class="line">		|	hwcDisplay-&gt;<span class="built_in">getChangedCompositionTypes</span>(&amp;changedTypes);	</span><br><span class="line">		|	<span class="comment">// 枚举 hal::DisplayRequest&#123;FLIP_CLIENT_TARGET = 1u , WRITE_CLIENT_TARGET_TO_OUTPUT = 2u ,&#125;</span></span><br><span class="line">        |	<span class="comment">// 0 表示：指示客户端提供新的客户端目标缓冲区，即使没有为客户端合成标记任何layers。</span></span><br><span class="line">        |	<span class="comment">// 1 表示：指示客户端将客户端合成的结果直接写入虚拟显示输出缓冲区。</span></span><br><span class="line">		|	<span class="keyword">auto</span> displayRequests = <span class="built_in">static_cast</span>&lt;hal::DisplayRequest&gt;(<span class="number">0</span>);</span><br><span class="line">		|	<span class="comment">// 枚举 hal::LayerRequest&#123;CLEAR_CLIENT_TARGET = 1 &lt;&lt; 0,  &#125;</span></span><br><span class="line">        |	<span class="comment">// 1表示：客户端必须在该layer所在的位置使用透明像素清除其目标。如果必须混合该层，客户端可能会忽略此请求。    </span></span><br><span class="line">		|	std::unordered_map&lt;HWC2::Layer*, hal::LayerRequest&gt; layerRequests;</span><br><span class="line">		|	layerRequests.<span class="built_in">reserve</span>(numRequests); <span class="comment">// map扩容为 numRequests</span></span><br><span class="line">		|	<span class="comment">// 返回 hal::DisplayRequest 和 每个Layer的 hal::LayerRequest 类型，用于指导 SurfaceFlinger 的GPU合成</span></span><br><span class="line">		|	hwcDisplay-&gt;<span class="built_in">getRequests</span>(&amp;displayRequests, &amp;layerRequests);</span><br><span class="line">		|	<span class="comment">// 返回client target属性，这个新增的，目前可能仅仅实现了亮度、调光、数据格式、数据空间相关属性</span></span><br><span class="line">		|	DeviceRequestedChanges::ClientTargetProperty clientTargetProperty;</span><br><span class="line">		|	hwcDisplay-&gt;<span class="built_in">getClientTargetProperty</span>(&amp;clientTargetProperty);</span><br><span class="line">		|	<span class="comment">// 组合成 DeviceRequestedChanges 结构体，返回</span></span><br><span class="line">		|	outChanges-&gt;<span class="built_in">emplace</span>(DeviceRequestedChanges&#123;std::<span class="built_in">move</span>(changedTypes), std::<span class="built_in">move</span>(displayRequests),</span><br><span class="line">                                                       std::<span class="built_in">move</span>(layerRequests), std::<span class="built_in">move</span>(clientTargetProperty)&#125;);</span><br><span class="line">        |	<span class="comment">// 注释这么说的：此函数相当于从getChangedCompositionTypes请求更改后的类型，在相应的层上设置这些类型，然后再次调用validateDisplay。</span></span><br><span class="line">        |	<span class="comment">// 但是，看源码感觉注释说的不大对，这里仅仅是把这个成员设为true： DisplayCommand::acceptDisplayChanges = true</span></span><br><span class="line">        |	<span class="comment">// 注释说的应该是命令缓存发送到HWC后，执行的流程</span></span><br><span class="line">		|	hwcDisplay-&gt;<span class="built_in">acceptChanges</span>();</span><br><span class="line">    |	<span class="comment">//只有正常执行会返回 true，其他，显示设备未连接、没有硬件合成、getDeviceCompositionChanges返回false，那么会 return false; </span></span><br><span class="line">    |	<span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">|	<span class="built_in">resetCompositionStrategy</span>();</span><br><span class="line">|--&gt;Output::<span class="built_in">resetCompositionStrategy</span>()</span><br><span class="line">    |	<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();</span><br><span class="line">	|	<span class="comment">// 先重置这些变量，在后续的流程中会使用。相当于设置默认值，因为对基本的Output实现只能进行客户端合成</span></span><br><span class="line">	|	outputState.usesClientComposition = <span class="literal">true</span>;</span><br><span class="line">	|	outputState.usesDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">	|	outputState.reusedClientComposition = <span class="literal">false</span>;</span><br><span class="line">|	<span class="comment">// 这个previousDeviceRequestedChanges变量在 Output::canPredictCompositionStrategy 函数中用来判断是否预测合成策略</span></span><br><span class="line">|	outputState.previousDeviceRequestedChanges = changes;</span><br><span class="line">|	outputState.previousDeviceRequestedSuccess = success;</span><br><span class="line">|	<span class="keyword">if</span> (success)<span class="comment">// HWComposer::getDeviceCompositionChanges 执行错误，不会进入到这里。比如IComposer任意一接口调用失败</span></span><br><span class="line">	|	<span class="built_in">applyCompositionStrategy</span>(changes);</span><br><span class="line">	|--&gt;Display::<span class="built_in">applyCompositionStrategy</span>(<span class="type">const</span> std::optional&lt;DeviceRequestedChanges&gt;&amp; changes)</span><br><span class="line">        |	<span class="keyword">if</span> (changes)</span><br><span class="line">            |	<span class="comment">// 对每个 OutputLayer 应用HWC设备要求的合成类型更改</span></span><br><span class="line">        	|	<span class="built_in">applyChangedTypesToLayers</span>(changes-&gt;changedTypes);</span><br><span class="line">			|--&gt;Display::<span class="built_in">applyChangedTypesToLayers</span>(<span class="type">const</span> ChangedTypes&amp; changedTypes)</span><br><span class="line">                |	<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">                    |	<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>();<span class="comment">// 获取 OutputLayer中存储的 HWC::Layer</span></span><br><span class="line">                    |	<span class="keyword">auto</span> it = changedTypes.<span class="built_in">find</span>(hwcLayer);	</span><br><span class="line">					|	<span class="keyword">if</span> (it == changedTypes.<span class="built_in">end</span>())	<span class="keyword">continue</span>;</span><br><span class="line">                    |	layer-&gt;<span class="built_in">applyDeviceCompositionTypeChange</span>(</span><br><span class="line">                    			<span class="built_in">static_cast</span>&lt;aidl::android::hardware::graphics::composer3::Composition&gt;(it-&gt;second));</span><br><span class="line">					|	<span class="comment">// 应用HWC设备要求的合成类型更改</span></span><br><span class="line">					|--&gt;OutputLayer::<span class="built_in">applyDeviceCompositionTypeChange</span>(Composition compositionType)</span><br><span class="line">                        |	<span class="keyword">auto</span>&amp; state = <span class="built_in">editState</span>();</span><br><span class="line">						|	<span class="keyword">auto</span>&amp; hwcState = *state.hwc;	</span><br><span class="line">						|	<span class="comment">// 这个 OutputLayerCompositionState::Hwc.hwcCompositionType 用于预测合成策略 Output::canPredictCompositionStrategy</span></span><br><span class="line">                        |	hwcState.hwcCompositionType = compositionType;<span class="comment">//这个代表最近使用的合成类型</span></span><br><span class="line">			|	<span class="built_in">applyDisplayRequests</span>(changes-&gt;displayRequests);</span><br><span class="line">			|--&gt;Display::<span class="built_in">applyDisplayRequests</span>(<span class="type">const</span> DisplayRequests&amp; displayRequests)</span><br><span class="line">                |	<span class="keyword">auto</span>&amp; state = <span class="built_in">editState</span>();</span><br><span class="line">                |	<span class="comment">// 如果 displayRequests 包含flag FLIP_CLIENT_TARGET，则 flipClientTarget=true</span></span><br><span class="line">                |	<span class="comment">// 如果为true，则在执行客户端合成时应提供新的客户端目标(client target)缓冲区</span></span><br><span class="line">				|	state.flipClientTarget = (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(displayRequests) </span><br><span class="line">                                              &amp; <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(hal::DisplayRequest::FLIP_CLIENT_TARGET)) != <span class="number">0</span>;</span><br><span class="line">			|	<span class="built_in">applyLayerRequestsToLayers</span>(changes-&gt;layerRequests);</span><br><span class="line">			|--&gt;Display::<span class="built_in">applyLayerRequestsToLayers</span>(<span class="type">const</span> LayerRequests&amp; layerRequests)</span><br><span class="line">                |	<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">                    |	<span class="comment">// OutputLayer.editState().clearClientTarget = false;</span></span><br><span class="line">                    |	layer-&gt;<span class="built_in">prepareForDeviceLayerRequests</span>();</span><br><span class="line">					|	<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>();</span><br><span class="line">					|	<span class="keyword">if</span> (<span class="keyword">auto</span> it = layerRequests.<span class="built_in">find</span>(hwcLayer); it != layerRequests.<span class="built_in">end</span>())</span><br><span class="line">                        |	<span class="comment">// 应用HWC的layer请求</span></span><br><span class="line">                        |	layer-&gt;<span class="built_in">applyDeviceLayerRequest</span>(<span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::LayerRequest&gt;(it-&gt;second));</span><br><span class="line">						|--&gt;OutputLayer::<span class="built_in">applyDeviceLayerRequest</span>(hal::LayerRequest request)</span><br><span class="line">                            |	<span class="keyword">if</span>(request== hal::LayerRequest::CLEAR_CLIENT_TARGET:)</span><br><span class="line">                                |	<span class="comment">// 客户端合成时，该layer所在的位置使用透明像素清除其目标</span></span><br><span class="line">                                |	<span class="built_in">editState</span>().clearClientTarget = <span class="literal">true</span>;</span><br><span class="line">			|	<span class="built_in">applyClientTargetRequests</span>(changes-&gt;clientTargetProperty);</span><br><span class="line">			|--&gt;Display::<span class="built_in">applyClientTargetRequests</span>(<span class="type">const</span> ClientTargetProperty&amp; clientTargetProperty)</span><br><span class="line">                |	<span class="built_in">editState</span>().dataspace = <span class="built_in">static_cast</span>&lt;ui::Dataspace&gt;(clientTargetProperty.clientTargetProperty.dataspace);</span><br><span class="line">				|	<span class="built_in">editState</span>().clientTargetBrightness = clientTargetProperty.brightness;</span><br><span class="line">				|	<span class="built_in">editState</span>().clientTargetDimmingStage = clientTargetProperty.dimmingStage;</span><br><span class="line">				|	<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">setBufferDataspace</span>(<span class="built_in">editState</span>().dataspace);</span><br><span class="line">				|	<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">setBufferPixelFormat</span>(<span class="built_in">static_cast</span>&lt;ui::PixelFormat&gt;(clientTargetProperty.clientTargetProperty.pixelFormat));</span><br><span class="line">		|	<span class="keyword">auto</span>&amp; state = <span class="built_in">editState</span>();</span><br><span class="line">		|	<span class="comment">// anyLayersRequireClientComposition:</span></span><br><span class="line">		|	<span class="comment">// Output 中有任意一个 OutputLayer 状态对象的 hwc-&gt;hwcCompositionType 为 Composition::CLIENT，则返回true</span></span><br><span class="line">		|	<span class="comment">// 就是 OutputLayer.getState().hwc-&gt;hwcCompositionType == Composition::CLIENT</span></span><br><span class="line">        |	<span class="comment">// 即，当前显示设备中有任意一个Layer的合成为 客户端合成，则 Output.getState().usesClientComposition = true; </span></span><br><span class="line">		|	state.usesClientComposition = <span class="built_in">anyLayersRequireClientComposition</span>();<span class="comment">// true表示有使用客户端合成</span></span><br><span class="line">		|	<span class="comment">// 当前显示设备的当前帧中，不是全部使用了客户端合成，则 usesDeviceComposition = true;</span></span><br><span class="line">        |	<span class="comment">// 表示当前显示设备的当前帧可能完使用硬件合成，也可能是两者都有</span></span><br><span class="line">		|	state.usesDeviceComposition = !<span class="built_in">allLayersRequireClientComposition</span>();<span class="comment">// true表示有使用硬件合成</span></span><br><span class="line">		|	<span class="comment">// 以上两个变量将用于接下来的 Output::finishPrepareFrame()流程，虚拟屏的prepareFrame方法 和 finishFrame 流程</span></span><br><span class="line">|	<span class="built_in">finishPrepareFrame</span>();</span><br><span class="line">|	<span class="comment">// 用于虚拟屏</span></span><br><span class="line">|--&gt;Output::<span class="built_in">finishPrepareFrame</span>()</span><br><span class="line">    |	<span class="type">const</span> <span class="keyword">auto</span>&amp; state = <span class="built_in">getState</span>();</span><br><span class="line">	|	<span class="keyword">if</span> (mPlanner)</span><br><span class="line">        |	mPlanner-&gt;<span class="built_in">reportFinalPlan</span>(<span class="built_in">getOutputLayersOrderedByZ</span>());</span><br><span class="line">	|	<span class="comment">// 准备帧进行渲染----这里只有 虚拟屏幕 实现了prepareFrame，其他什么也不做</span></span><br><span class="line">    |	mRenderSurface-&gt;<span class="built_in">prepareFrame</span>(state.usesClientComposition, state.usesDeviceComposition);</span><br></pre></td></tr></table></figure>

<h5 id="Output-finishFrame"><a href="#Output-finishFrame" class="headerlink" title="Output::finishFrame"></a>Output::finishFrame</h5><ul>
<li>处理Client合成(GPU合成)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码Output::<span class="built_in">present</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">finishFrame</span>(refreshArgs, std::<span class="built_in">move</span>(result));<span class="comment">// GPU 合成</span></span><br><span class="line"><span class="comment">// result 为 prepareFrameAsync 的执行结果</span></span><br><span class="line">|--&gt;Output::<span class="built_in">finishFrame</span>(<span class="type">const</span> CompositionRefreshArgs&amp; refreshArgs, GpuCompositionResult&amp;&amp; result)</span><br><span class="line">    |	<span class="type">const</span> <span class="keyword">auto</span>&amp; outputState = <span class="built_in">getState</span>();</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	outputState.strategyPrediction </span></span><br><span class="line"><span class="comment">    		走 prepareFrame() 为 DISABLED，表示不使用预测合成策略</span></span><br><span class="line"><span class="comment">    		走 prepareFrameAsync() 为 SUCCESS 或者 FAIL  表示合预测成功或者失败</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">	|	<span class="keyword">if</span> (outputState.strategyPrediction == CompositionStrategyPredictionState::SUCCESS)</span><br><span class="line">        |	<span class="comment">//如果预测成功，则已经执行完 GPU 合成了，不必再dequeueRenderBuffer了</span></span><br><span class="line">        |	optReadyFence = std::<span class="built_in">move</span>(result.fence);</span><br><span class="line">	|	<span class="keyword">else</span> <span class="comment">// prepareFrameAsync 中预测失败了</span></span><br><span class="line">        |	<span class="comment">// 虽然预测失败了，但是已经dequeued的buffer，会通过GpuCompositionResult传送过来，拿来复用</span></span><br><span class="line">        |	<span class="keyword">if</span> (result.<span class="built_in">bufferAvailable</span>())</span><br><span class="line">            |	buffer = std::<span class="built_in">move</span>(result.buffer);</span><br><span class="line">			|	bufferFence = std::<span class="built_in">move</span>(result.fence);</span><br><span class="line">		|	<span class="keyword">else</span> <span class="comment">// dequeueRenderBuffer失败，连dequeued的buffer都没有，那就重走一遍 prepareFrameAsync GPU 合成的那块逻辑。当然，也可能就没有执行 prepareFrameAsync</span></span><br><span class="line">            |	<span class="comment">// BufferQueue熟悉的配方 dequeueBuffer</span></span><br><span class="line">            |	<span class="built_in">dequeueRenderBuffer</span>(&amp;bufferFence, &amp;buffer))</span><br><span class="line">            |--&gt;Output::<span class="built_in">dequeueRenderBuffer</span>(unique_fd* bufferFence, std::shared_ptr&lt;ExternalTexture&gt;* tex)</span><br><span class="line">            	|	<span class="type">const</span> <span class="keyword">auto</span>&amp; outputState = <span class="built_in">getState</span>();</span><br><span class="line">            	|	<span class="comment">// 有使用客户端合成 或者 设置了 flipClientTarget 都需要进行 GPU 合成</span></span><br><span class="line">            	|	<span class="keyword">if</span> (outputState.usesClientComposition || outputState.flipClientTarget)</span><br><span class="line">                    |	<span class="comment">//【dequeueBuffer，然后把dequeue的Buffer包装为 ExternalTexture】</span></span><br><span class="line">                    |	*tex = mRenderSurface-&gt;<span class="built_in">dequeueBuffer</span>(bufferFence);</span><br><span class="line">					|--&gt;RenderSurface::<span class="built_in">dequeueBuffer</span>(base::unique_fd* bufferFence)</span><br><span class="line">                        |	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">						|	ANativeWindowBuffer* buffer = <span class="literal">nullptr</span>;</span><br><span class="line">                        |	<span class="comment">// 调用 Surface.dequeueBuffer</span></span><br><span class="line">                        |	mNativeWindow-&gt;<span class="built_in">dequeueBuffer</span>(mNativeWindow.<span class="built_in">get</span>(), &amp;buffer, &amp;fd);</span><br><span class="line">						|	<span class="comment">// GraphicBuffer 继承 ANativeWindowBuffer</span></span><br><span class="line">						|	<span class="comment">// GraphicBuffer::from 把父类ANativeWindowBuffer强制转换为子类 GraphicBuffer</span></span><br><span class="line">						|	sp&lt;GraphicBuffer&gt; newBuffer = GraphicBuffer::<span class="built_in">from</span>(buffer);</span><br><span class="line">						|	<span class="comment">// ExternalTexture 使用 RenderEngine 代表客户端管理GPU图像资源。</span></span><br><span class="line">                        |	<span class="comment">// 渲染引擎不是GLES的话，在 ExternalTexture 构造函数中把GraphicBuffer映射到RenderEngine所需的GPU资源中。</span></span><br><span class="line">						|	mTexture = <span class="keyword">new</span> <span class="built_in">ExternalTexture</span>(newBuffer,mCompositionEngine.<span class="built_in">getRenderEngine</span>(),WRITEABLE)</span><br><span class="line">                        |	*bufferFence = base::<span class="built_in">unique_fd</span>(fd);<span class="comment">//返回fence fd</span></span><br><span class="line">						|	<span class="keyword">return</span> mTexture;<span class="comment">// 返回纹理类</span></span><br><span class="line">		|	<span class="comment">// 执行GPU合成</span></span><br><span class="line">		|	optReadyFence = <span class="built_in">composeSurfaces</span>(Region::INVALID_REGION, refreshArgs, buffer, bufferFence);</span><br><span class="line">	|	<span class="comment">// BufferQueue熟悉的配方 queueBuffer</span></span><br><span class="line">	|	mRenderSurface-&gt;<span class="built_in">queueBuffer</span>(std::<span class="built_in">move</span>(*optReadyFence));</span><br><span class="line">	|--&gt;RenderSurface::<span class="built_in">queueBuffer</span>(base::unique_fd readyFence)</span><br><span class="line">        |	<span class="comment">// 调用 Surface.queueBuffer</span></span><br><span class="line">        |	mNativeWindow-&gt;<span class="built_in">queueBuffer</span>(mNativeWindow.<span class="built_in">get</span>(),mTexture-&gt;<span class="built_in">getBuffer</span>()-&gt;<span class="built_in">getNativeBuffer</span>(),<span class="built_in">dup</span>(readyFence));</span><br><span class="line">		|	<span class="comment">// mDisplaySurface:</span></span><br><span class="line">        |	<span class="comment">// 对于非虚拟屏是 FramebufferSurface，其包装消费者、继承 DisplaySurface；对于虚拟屏是 VirtualDisplaySurface</span></span><br><span class="line">		|	mDisplaySurface-&gt;<span class="built_in">advanceFrame</span>();</span><br><span class="line">		|--&gt;FramebufferSurface::<span class="built_in">advanceFrame</span>()<span class="comment">//就是调用 FramebufferSurface::nextBuffer</span></span><br><span class="line">            |	<span class="type">uint32_t</span> slot = <span class="number">0</span>;</span><br><span class="line">			|	sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">			|	<span class="function">sp&lt;Fence&gt; <span class="title">acquireFence</span><span class="params">(Fence::NO_FENCE)</span></span>;</span><br><span class="line">			|	Dataspace dataspace = Dataspace::UNKNOWN;</span><br><span class="line">            |	<span class="built_in">nextBuffer</span>(slot, buf, acquireFence, dataspace);</span><br><span class="line">			|	<span class="comment">// 这里核心是调用 setClientTarget ，把 客户端合成输出的缓冲区句柄 传递给 HWC。</span></span><br><span class="line">            |	<span class="comment">// 当然，目前还未真正传递到HWC，只是写到命令缓冲区。需要等待执行 present 才执行传递</span></span><br><span class="line">			|--&gt;FramebufferSurface::<span class="built_in">nextBuffer</span>(<span class="type">uint32_t</span>&amp; outSlot,sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence,Dataspace&amp; outDataspace)</span><br><span class="line">				|	mHwc.<span class="built_in">setClientTarget</span>(mDisplayId, outSlot, outFence, outBuffer, outDataspace);</span><br></pre></td></tr></table></figure>

<h5 id="Output-postFramebuffer"><a href="#Output-postFramebuffer" class="headerlink" title="Output::postFramebuffer()"></a>Output::postFramebuffer()</h5><ul>
<li><strong>送显 + 获取 Layer releaseFence</strong></li>
<li>这个 releaseFence 并不是当前送显的fence，是上一帧的</li>
<li>Layer releaseFence 会合并 GPU合成的fence<ul>
<li>就是说APP dequeuebuffer拿到新buffer后，需要等待GPU合成完成 + HWC使用当前Layer buffer替换上一个buffer(app dequque的buffer)后，才能在这个新buffer上填充数据</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//先看下结构体 FrameFences</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct FrameFences &#123;</span></span><br><span class="line"><span class="comment">    	// 这个fence，在当前帧在屏幕上显现，或者发送到面板内存时，会发送信号</span></span><br><span class="line"><span class="comment">        sp&lt;Fence&gt; presentFence&#123;Fence::NO_FENCE&#125;;</span></span><br><span class="line"><span class="comment">        // GPU 合成的buffer的消费者 acquire fence；代表GPU合成是否完成；(注：GPU绘制的acquire fence，在latchBuffer阶段已经判断了。)</span></span><br><span class="line"><span class="comment">        sp&lt;Fence&gt; clientTargetAcquireFence&#123;Fence::NO_FENCE&#125;;</span></span><br><span class="line"><span class="comment">        // 所有Layer的fence；在先前呈现的buffer被读取完成后发送信息；HWC生成</span></span><br><span class="line"><span class="comment">        std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; layerFences;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Output::<span class="built_in">postFramebuffer</span>()</span><br><span class="line">|	<span class="keyword">auto</span> frame = <span class="built_in">presentAndGetFrameFences</span>();</span><br><span class="line">|--&gt;Display::<span class="built_in">presentAndGetFrameFences</span>()</span><br><span class="line">    |	<span class="comment">// 【1】这里就是赋值 FrameFences.clientTargetAcquireFence</span></span><br><span class="line">    |	<span class="keyword">auto</span> fences = impl::Output::<span class="built_in">presentAndGetFrameFences</span>();</span><br><span class="line">	|--&gt;Output::<span class="built_in">presentAndGetFrameFences</span>() </span><br><span class="line">        |	<span class="keyword">if</span> (<span class="built_in">getState</span>().usesClientComposition)</span><br><span class="line">            |	result.clientTargetAcquireFence = mRenderSurface-&gt;<span class="built_in">getClientTargetAcquireFence</span>();</span><br><span class="line">	|	<span class="comment">// 1、【在屏幕上呈现当前显示内容（如果是虚拟显示，则显示到输出缓冲区中）】</span></span><br><span class="line">	|	<span class="comment">// 2、获取device上所有layer的 ReleaseFence</span></span><br><span class="line">	|	hwc.<span class="built_in">presentAndGetReleaseFences</span>(*halDisplayIdOpt, <span class="built_in">getState</span>().earliestPresentTime, <span class="built_in">getState</span>().previousPresentFence);</span><br><span class="line">	|	<span class="comment">// getPresentFence返回 HWComposer.mDisplayData.at(displayId).lastPresentFence;</span></span><br><span class="line">    |	<span class="comment">// 这个fence，在当前帧在屏幕上显现，或者发送到面板内存时，会发送信号</span></span><br><span class="line">    |	<span class="comment">//	【2】赋值 FrameFences.presentFence</span></span><br><span class="line">	|	fences.presentFence = hwc.<span class="built_in">getPresentFence</span>(*halDisplayIdOpt);</span><br><span class="line">	|	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">        |	<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>();</span><br><span class="line">		|	<span class="comment">// 从HWC显示设备上所有Layer的fence</span></span><br><span class="line">		|	<span class="comment">//	【3】赋值 FrameFences.layerFences</span></span><br><span class="line">        |	fences.layerFences.<span class="built_in">emplace</span>(hwcLayer, hwc.<span class="built_in">getLayerReleaseFence</span>(*halDisplayIdOpt, hwcLayer));</span><br><span class="line">|	<span class="comment">// 释放GPU合成使用的buffer</span></span><br><span class="line">|	mRenderSurface-&gt;<span class="built_in">onPresentDisplayCompleted</span>();</span><br><span class="line">|	<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">    |	sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE;</span><br><span class="line">	|	<span class="comment">// 获取HWC每个layer的releaseFence</span></span><br><span class="line">	|	<span class="keyword">if</span> (<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>())</span><br><span class="line">        |	<span class="keyword">if</span> (<span class="keyword">auto</span> f = frame.layerFences.<span class="built_in">find</span>(hwcLayer); f != frame.layerFences.<span class="built_in">end</span>())</span><br><span class="line">            |	releaseFence = f-&gt;second;</span><br><span class="line">	|	<span class="comment">// 如果有客户端合成，merge GPUbuffer的fence</span></span><br><span class="line">    |	<span class="keyword">if</span> (outputState.usesClientComposition)</span><br><span class="line">        |	releaseFence = Fence::<span class="built_in">merge</span>(<span class="string">&quot;LayerRelease&quot;</span>, releaseFence, frame.clientTargetAcquireFence);</span><br><span class="line">	|	<span class="comment">//同步Fence到Layer中</span></span><br><span class="line">    |	<span class="comment">// 如果是 BufferQueueLayer	设置 mSlots[slot].mFence; </span></span><br><span class="line">    |	<span class="comment">// 如果是 BufferStateLayer	把fence关联到回调类中</span></span><br><span class="line">	|	layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">onLayerDisplayed</span>(ftl::<span class="built_in">yield</span>&lt;FenceResult&gt;(std::<span class="built_in">move</span>(releaseFence)).<span class="built_in">share</span>());</span><br><span class="line">|	<span class="comment">// mReleasedLayers是一些即将移除的的layer，但是当前vsync还在生产帧数据的layer</span></span><br><span class="line">|	<span class="comment">// 把presentFence传给这些layer使用，毕竟他们不参与合成了</span></span><br><span class="line">|	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; weakLayer : mReleasedLayers)</span><br><span class="line">    |	<span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> layer = weakLayer.<span class="built_in">promote</span>())</span><br><span class="line">        |	layer-&gt;<span class="built_in">onLayerDisplayed</span>(ftl::<span class="built_in">yield</span>&lt;FenceResult&gt;(frame.presentFence).<span class="built_in">share</span>());</span><br><span class="line">|	mReleasedLayers.<span class="built_in">clear</span>();<span class="comment">//清空 mReleasedLayers</span></span><br></pre></td></tr></table></figure>

<h4 id="再回到APP进程端-releaseBuffer"><a href="#再回到APP进程端-releaseBuffer" class="headerlink" title="再回到APP进程端 releaseBuffer"></a>再回到APP进程端 releaseBuffer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码|--&gt;SurfaceFlinger::<span class="built_in">postComposition</span>() </span><br><span class="line">    |	<span class="comment">// 省略一大段内容</span></span><br><span class="line">    |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer: mLayersWithQueuedFrames)</span><br><span class="line">        |	<span class="comment">// 更新FrameTracker、TimeStats这些</span></span><br><span class="line">        |	layer-&gt;<span class="built_in">onPostComposition</span>(display, glCompositionDoneFenceTime,mPreviousPresentFences[<span class="number">0</span>].fenceTime, compositorTiming);</span><br><span class="line">		|	layer-&gt;<span class="built_in">releasePendingBuffer</span>(<span class="comment">/*dequeueReadyTime*/</span> now);</span><br><span class="line">		|--&gt;BufferStateLayer::<span class="built_in">releasePendingBuffer</span>(<span class="type">nsecs_t</span> dequeueReadyTime)</span><br><span class="line">            |	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; handle : mDrawingState.callbackHandles)</span><br><span class="line">                |	<span class="keyword">if</span> (handle-&gt;releasePreviousBuffer &amp;&amp; mDrawingState.releaseBufferEndpoint == handle-&gt;listener)</span><br><span class="line">                    |	<span class="comment">// 这个 mPreviousReleaseCallbackId 在 BufferStateLayer::updateActiveBuffer() 赋值</span></span><br><span class="line">                    |	<span class="comment">// mPreviousReleaseCallbackId = &#123;getCurrentBufferId(), mBufferInfo.mFrameNumber&#125;;</span></span><br><span class="line">                    |	handle-&gt;previousReleaseCallbackId = mPreviousReleaseCallbackId;</span><br><span class="line">					|	<span class="keyword">break</span>;</span><br><span class="line">			|	<span class="comment">// 把 callback 加入 TransactionCallbackInvoker::mCompletedTransactions</span></span><br><span class="line">			|	mFlinger-&gt;<span class="built_in">getTransactionCallbackInvoker</span>().<span class="built_in">addCallbackHandles</span>(mDrawingState.callbackHandles, jankData);</span><br><span class="line">	|	<span class="comment">//【这里就是通过binder通信，回调到 APP 端BBQ执行 releaseBuffer 了】</span></span><br><span class="line">	|	mTransactionCallbackInvoker.<span class="built_in">sendCallbacks</span>(<span class="literal">false</span> <span class="comment">/* onCommitOnly */</span>);</span><br><span class="line">		|--&gt;BpTransactionCompletedListener::<span class="built_in">onTransactionCompleted</span>(android::ListenerStats)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 跨进程进入到APP端</span></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/BLASTBufferQueue.cpp</span></span><br><span class="line"><span class="built_in">releaseBufferCallbackThunk</span>(wp&lt;BLASTBufferQueue&gt; context, ReleaseCallbackId&amp; id,Fence&amp; releaseFence, <span class="type">uint32_t</span> currentMaxAcquiredBufferCount)</span><br><span class="line">|	sp&lt;BLASTBufferQueue&gt; blastBufferQueue = context.<span class="built_in">promote</span>();</span><br><span class="line">|	blastBufferQueue-&gt;<span class="built_in">releaseBufferCallback</span>(id, releaseFence, currentMaxAcquiredBufferCount);</span><br><span class="line">|--&gt;BLASTBufferQueue::<span class="built_in">releaseBufferCallback</span>(<span class="type">const</span> ReleaseCallbackId&amp; id,Fence&amp; releaseFence,<span class="type">uint32_t</span> currentMaxAcquiredBufferCount)</span><br><span class="line">    |	<span class="built_in">releaseBufferCallbackLocked</span>(id, releaseFence, currentMaxAcquiredBufferCount,<span class="literal">false</span> <span class="comment">/* fakeRelease */</span>);</span><br><span class="line">	|--&gt;BLASTBufferQueue::<span class="built_in">releaseBufferCallbackLocked</span>(ReleaseCallbackId&amp; id,Fence&amp; releaseFence,<span class="type">uint32_t</span> currentMaxAcquiredBufferCount, <span class="type">bool</span> fakeRelease)</span><br><span class="line">        |	<span class="comment">//	ReleaseCallbackId 是个包含 bufferId 和 帧号 的Parcelable, ReleasedBuffer结构体又把 releaseFence 包含进来</span></span><br><span class="line">        |	<span class="keyword">auto</span> rb = ReleasedBuffer&#123;id, releaseFence&#125;;</span><br><span class="line">		|	<span class="keyword">if</span> (std::<span class="built_in">find</span>(mPendingRelease.<span class="built_in">begin</span>(), mPendingRelease.<span class="built_in">end</span>(), rb) == mPendingRelease.<span class="built_in">end</span>())</span><br><span class="line">            |	<span class="comment">// 队列里边没有的话，就加入队列</span></span><br><span class="line">            |	mPendingRelease.<span class="built_in">emplace_back</span>(rb);<span class="comment">//  mPendingRelease 是个 std::deque</span></span><br><span class="line">		|	<span class="keyword">while</span> (mPendingRelease.<span class="built_in">size</span>() &gt; numPendingBuffersToHold) <span class="comment">// numPendingBuffersToHold 是需要保留的buffer数量</span></span><br><span class="line">            |	<span class="type">const</span> <span class="keyword">auto</span> releasedBuffer = mPendingRelease.<span class="built_in">front</span>();</span><br><span class="line">			|	mPendingRelease.<span class="built_in">pop_front</span>();</span><br><span class="line">			|	<span class="built_in">releaseBuffer</span>(releasedBuffer.callbackId, releasedBuffer.releaseFence);</span><br><span class="line">			|--&gt;BLASTBufferQueue::<span class="built_in">releaseBuffer</span>(<span class="type">const</span> ReleaseCallbackId&amp; callbackId,<span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span><br><span class="line">            	|	<span class="comment">// mSubmitted 是个map&lt;ReleaseCallbackId, BufferItem&gt;，从这个map中查找对应的 BufferItem</span></span><br><span class="line">            	|	<span class="keyword">auto</span> it = mSubmitted.<span class="built_in">find</span>(callbackId);</span><br><span class="line">				|	mNumAcquired--;</span><br><span class="line">				|	mBufferItemConsumer-&gt;<span class="built_in">releaseBuffer</span>(it-&gt;second, releaseFence);</span><br><span class="line">				|--&gt;BufferItemConsumer::<span class="built_in">releaseBuffer</span>(<span class="type">const</span> BufferItem &amp;item, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span><br><span class="line">                    |	<span class="comment">// mSlots[slot].mFence = fence; 赋值releaseFence，并处理 Fence 合并情况</span></span><br><span class="line">                    |	<span class="built_in">addReleaseFenceLocked</span>(item.mSlot, item.mGraphicBuffer, releaseFence);</span><br><span class="line">					|	<span class="built_in">releaseBufferLocked</span>(item.mSlot, item.mGraphicBuffer, EGL_NO_DISPLAY, EGL_NO_SYNC_KHR);</span><br><span class="line">					|--&gt;ConsumerBase::<span class="built_in">releaseBufferLocked</span>(<span class="type">int</span> slot, <span class="type">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,  EGLDisplay display, EGLSyncKHR eglFence)</span><br><span class="line">                        |	<span class="comment">// 调用消费者的 releaseBuffer 方法</span></span><br><span class="line">                        |	<span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">releaseBuffer</span>(slot, mSlots[slot].mFrameNumber, display, eglFence, mSlots[slot].mFence);</span><br><span class="line">						|--&gt;BufferQueueConsumer::<span class="built_in">releaseBuffer</span>(<span class="type">int</span> slot, <span class="type">uint64_t</span> frameNumber, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence,...)</span><br><span class="line">                            |	<span class="comment">// 忽略一些容错处理</span></span><br><span class="line">                            |	sp&lt;IProducerListener&gt; listener;</span><br><span class="line">                            |	mSlots[slot].mEglDisplay = eglDisplay; <span class="comment">// display = EGL_NO_DISPLAY;</span></span><br><span class="line">							|	mSlots[slot].mEglFence = eglFence;  <span class="comment">// EGLSyncKHR eglFence = EGL_NO_SYNC_KHR</span></span><br><span class="line">							|	mSlots[slot].mFence = releaseFence; <span class="comment">// SurfaceFlinger 传递过来的 releaseFence</span></span><br><span class="line">							|	mSlots[slot].mBufferState.<span class="built_in">release</span>(); <span class="comment">// 状态转为 released</span></span><br><span class="line">							|	mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(slot);<span class="comment">// 从激活状态set中删除</span></span><br><span class="line">							|	mCore-&gt;mFreeBuffers.<span class="built_in">push_back</span>(slot); <span class="comment">// 放回 Free list 中</span></span><br><span class="line">							|	<span class="keyword">if</span> (mCore-&gt;mBufferReleasedCbEnabled)</span><br><span class="line">                                |	<span class="comment">// mConnectedProducerListener 是 BufferQueueProducer::connect 时传入的</span></span><br><span class="line">                                |	<span class="comment">// CPU绘制传入的 StubProducerListener,没啥用</span></span><br><span class="line">                                |	listener = mCore-&gt;mConnectedProducerListener;</span><br><span class="line">							|	<span class="comment">// 如果有阻塞在dequeuebuffer的线程，此时会被唤醒，有新的buffer可以 Dequeue 了</span></span><br><span class="line">							|	mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">							|	<span class="keyword">if</span> (listener != <span class="literal">nullptr</span>)</span><br><span class="line">                                |	listener-&gt;<span class="built_in">onBufferReleased</span>();<span class="comment">// 对于CPU绘制，这个是空函数没啥</span></span><br><span class="line">						|	<span class="comment">// 如果返回 buffer过时了，需要清空这个slot的 GraphicBuffer</span></span><br><span class="line">						|	<span class="keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) </span><br><span class="line">                            |	mSlots[slotIndex].mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">							|	mSlots[slotIndex].mFence = Fence::NO_FENCE;</span><br><span class="line">							|	mSlots[slotIndex].mFrameNumber = <span class="number">0</span>;</span><br><span class="line">						|	mPrevFinalReleaseFence = mSlots[slot].mFence;</span><br><span class="line">						|	<span class="comment">// 这里的mSlots是BufferItem的，和 BufferQueue 的不是一个变量</span></span><br><span class="line">						|	<span class="comment">// BufferItem 的Fence设置为 NO_FENCE</span></span><br><span class="line">						|	mSlots[slot].mFence = Fence::NO_FENCE;</span><br><span class="line">				|	mSubmitted.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure>

<p><strong>后记：</strong></p>
<p>对于 Android 13 的 SurfaceFlinger 而言，参考资料真的是非常有限。</p>
<p>从 Android P<del>Android Q小更新，Android Q</del>Android R 大的架构更新，</p>
<p>Android R~Android S 机制上的更新(BBQ+BufferStateLayer)，Android S ~ Android T 又是大的架构更新，</p>
<p>Google还不断使用最新的c++标准去重构代码，从c11又更新到c20。更新的XX都不认识了。</p>
<p>最后导致能参考的资料基本失效了，只能一个个变量去查，并且都没类注释，要命的工作量啊。</p>
<p>最后不感谢CCTV，感谢 cs.android.com 吧，多亏了这个源码网站强大的检索能力。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
   
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>