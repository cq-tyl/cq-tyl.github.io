<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>7.点击桌面APP图标，到APP界面显示流程分析 | TYL</title>
    
    
        <meta name="keywords" content="7.点击桌面APP图标，到APP界面显示流程分析" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="一、点击桌面App图标事件分发 systemserver进程启动时，会启动 inputflinger 服务： native层的 InputManager InputManager 启动时，启动 InputDispatcher 线程和 InputReader 线程 InputReader 线程循环调用 EventHub 的 getEvents 方法，linux设备节点&#x2F;dev&#x2F;i">
<meta property="og:type" content="article">
<meta property="og:title" content="7.点击桌面APP图标，到APP界面显示流程分析">
<meta property="og:url" content="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="一、点击桌面App图标事件分发 systemserver进程启动时，会启动 inputflinger 服务： native层的 InputManager InputManager 启动时，启动 InputDispatcher 线程和 InputReader 线程 InputReader 线程循环调用 EventHub 的 getEvents 方法，linux设备节点&#x2F;dev&#x2F;i">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-01-12T01:04:50.784Z">
<meta property="article:modified_time" content="2024-01-19T02:26:57.734Z">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">Android事件分发</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/">Android自定义View</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file active"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ADB%E5%92%8CMonkey%E6%B5%8B%E8%AF%95/">ADB和Monkey测试</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/">0.jetpack合集</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.1.leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">3.1.leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.0.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96&ANR/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/">0.app性能优化集合</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/">MVC、MVP、MVVM架构</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  <li class="file"><a href="/wiki/C++/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            QT
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            我的简历
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E6%AD%A3%E5%BC%8F%E7%AE%80%E5%8E%86/">我的简历</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">完整项目经历</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Android FrameWork/Framework源码分析/Android 13/7.点击桌面APP图标，到APP界面显示流程分析(一)" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h3 id="一、点击桌面App图标事件分发"><a href="#一、点击桌面App图标事件分发" class="headerlink" title="一、点击桌面App图标事件分发"></a>一、点击桌面App图标事件分发</h3><ul>
<li>systemserver进程启动时，会启动 inputflinger 服务： native层的 InputManager</li>
<li>InputManager 启动时，启动 InputDispatcher 线程和 InputReader 线程</li>
<li>InputReader 线程循环调用 EventHub 的 getEvents 方法，linux设备节点&#x2F;dev&#x2F;input文件夹下的event读取事件</li>
<li>InputReader 读取到事件后，放到 InputDispatcher.mInboundQueue 队列中，并通知 InputDispatcher 线程读取数据</li>
<li>InputDispatcher 线程唤醒后，从 mInboundQueue 队列中取出事件，按事件类型进行分发。</li>
<li>对于触屏事件，会寻找屏幕触控事件的焦点窗口，找到后把事件放入 Connection.outboundQueue 队列中<ul>
<li>Connection是在窗口添加时在 WindowState.openInputChannel 调用过程中创建的，</li>
<li>一个 Connection有一个服务端的InputChannel，一个InputChannel有一个socketpair服务端socket的fd，</li>
<li>同时 socketpair客户端的fd会被发送到App进程，并加入epoll监听</li>
<li>因此Connection就代表同App端的socket连接(或者说是管道)</li>
</ul>
</li>
<li>最后通过 Connection 中的 socket 把事件发送到 App</li>
</ul>
<h4 id="InputDispatcher分发流程"><a href="#InputDispatcher分发流程" class="headerlink" title="InputDispatcher分发流程"></a>InputDispatcher分发流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">c复制代码InputDispatcher::start();<span class="comment">// 这个start是SystemServer进程启动过程调用的</span></span><br><span class="line"><span class="comment">//  启动线程。循环执行 dispatchOnce()</span></span><br><span class="line">|	mThread = <span class="built_in">std</span>::make_unique&lt;InputThread&gt;( <span class="string">&quot;InputDispatcher&quot;</span>, [this]() &#123; dispatchOnce(); &#125;, [this]() &#123; mLooper-&gt;wake(); &#125;);</span><br><span class="line">|--&gt;InputDispatcher::dispatchOnce();</span><br><span class="line">    |	dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">		<span class="comment">//	取出队列第一个数据， mPendingEvent 作为成员变量，表示待处理事件，一次循环处理一个待处理事件</span></span><br><span class="line">		|	mPendingEvent = mInboundQueue.front();</span><br><span class="line">		<span class="comment">//	取出后，移除第一个数据</span></span><br><span class="line">		|	mInboundQueue.pop_front();</span><br><span class="line">		<span class="comment">//	根据事件类别，分别调用不同的事件分发函数，比如，按键事件调用 dispatchKeyLocked</span></span><br><span class="line">		|	<span class="keyword">switch</span> (mPendingEvent-&gt;type) </span><br><span class="line">            <span class="comment">//	以屏幕触控事件为例</span></span><br><span class="line">            |	<span class="keyword">case</span> EventEntry::Type::MOTION:</span><br><span class="line">				|	<span class="comment">// 分发屏幕触控事件 </span></span><br><span class="line">				|	done = dispatchMotionLocked(currentTime, motionEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">						<span class="comment">//	寻找屏幕触控事件的焦点窗口，把所有接收当前输入事件的窗口的InputChannel封装到InputTarget，并添加到集合inputTargets</span></span><br><span class="line">						|	findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">						|	dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">							<span class="comment">//	遍历集合 inputTargets</span></span><br><span class="line">							|	<span class="keyword">for</span> (<span class="type">const</span> InputTarget&amp; inputTarget : inputTargets) </span><br><span class="line">                                <span class="comment">// 根据 token 拿到 Connection 【见：addToDisplayAsUser 章节】</span></span><br><span class="line">        						<span class="comment">// 从map类型数据 mConnectionsByToken 依据key InputChannel.mToken 查找 Connection</span></span><br><span class="line">        						<span class="comment">// std::unordered_map&lt;sp&lt;IBinder&gt;, sp&lt;Connection&gt;&gt; mConnectionsByToken</span></span><br><span class="line">        						<span class="comment">// mConnectionsByToken 中的数据是 createInputChannel 是添加的</span></span><br><span class="line">        						<span class="comment">// createInputChannel 是添加窗口时在 WindowState.openInputChannel 调用过程中调用。</span></span><br><span class="line">                                <span class="comment">// 一个 Connection有一个服务端的InputChannel，一个InputChannel有一个socketpair服务端socket的fd</span></span><br><span class="line">                                <span class="comment">// 因此Connection就代表同App端的socket连接(或者说是管道)</span></span><br><span class="line">                                |	sp&lt;Connection&gt; connection = getConnectionLocked(inputTarget.inputChannel-&gt;getConnectionToken());</span><br><span class="line">								|	prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">									| enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">									  | enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, FLAG_DISPATCH_AS_IS);</span><br><span class="line">										<span class="comment">//	把需要分发的事件加入到对于窗口的Connection.outboundQueue队列中</span></span><br><span class="line">										|	connection-&gt;outboundQueue.push_back(dispatchEntry.release());</span><br><span class="line">									  <span class="comment">// 开始循环分发事件	</span></span><br><span class="line">									  | startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">										<span class="comment">// outboundQueue 队列不为空就一直循环处理</span></span><br><span class="line">										| <span class="keyword">while</span> (!connection-&gt;outboundQueue.empty())</span><br><span class="line">                                            | connection-&gt;inputPublisher.publishMotionEvent(...)</span><br><span class="line">                                            	| mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">													<span class="comment">// 通过socket把事件发生给客户端</span></span><br><span class="line">													|	::send(getFd(), &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">                                            <span class="comment">// 删除outboundQueue队列中已发送的事件</span></span><br><span class="line">                                            | connection-&gt;outboundQueue.erase(<span class="built_in">std</span>::remove(connection-&gt;outboundQueue.begin(),</span><br><span class="line">                                                    connection-&gt;outboundQueue.end(),</span><br><span class="line">                                                    dispatchEntry));</span><br><span class="line">											<span class="comment">// 已发送的事件加入Connection的 waitQueue</span></span><br><span class="line">											<span class="comment">// App端处理完事件后，会回调回来删除waitQueue中的事件</span></span><br><span class="line">											<span class="comment">// AMR 检查时，waitQueue 中的事件超时未回调，会触发ANR</span></span><br><span class="line">											| connection-&gt;waitQueue.push_back(dispatchEntry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	处理ANR</span></span><br><span class="line">	|	<span class="type">const</span> <span class="type">nsecs_t</span> nextAnrCheck = processAnrsLocked();</span><br><span class="line">	|	mLooper-&gt;pollOnce(timeoutMillis);</span><br></pre></td></tr></table></figure>

<h4 id="App进程事件分发"><a href="#App进程事件分发" class="headerlink" title="App进程事件分发"></a>App进程事件分发</h4><ul>
<li><p>looper epoll监听 <code>SocketPair</code> 的fd 【这个fd的来源见：addToDisplayAsUser 章节】</p>
</li>
<li><p>socket来数据后，回调 NativeInputEventReceiver::handleEvent</p>
<ul>
<li><p>android::NativeInputEventReceiver.consumeEvent</p>
</li>
<li><p>native 反射调用Java层 InputEventReceiver.deliverInputEvent</p>
</li>
<li><p>WindowInputEventReceiver.onInputEvent</p>
</li>
<li><p>ViewRootImpl.enqueueInputEvent&#x2F;&#x2F;<strong>执行入队操作—PendingInputEventQueue</strong></p>
</li>
<li><p>doProcessInputEvents()</p>
</li>
<li><p>deliverInputEvent(q);&#x2F;&#x2F;<strong>这里会在systrace显示 deliverInputEvent块</strong></p>
<ul>
<li><p>经过若干步骤后</p>
</li>
<li><p>mView.dispatchPointerEvent(event);&#x2F;&#x2F;<strong>进入view的事件分发流程</strong></p>
<p>然后 view 再处理各自的touch事件。</p>
<p>比如ScrollView，在touch事件中，会调整view的坐标，然后调用 invalidate 函数，函数最终会调用 requestNextVsync 触发 vsync ，vsync 回调doframe中绘制流程中，ScrollView根据新的坐标绘制界面，然后就看到了界面滚动。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>事件分发到桌面图标的view后，view自身的点击事件中调用 startActivity 启动App。</p>
<h3 id="二、APP创建进程"><a href="#二、APP创建进程" class="headerlink" title="二、APP创建进程"></a>二、APP创建进程</h3><h4 id="App到systemserver进程"><a href="#App到systemserver进程" class="headerlink" title="App到systemserver进程"></a>App到systemserver进程</h4><p>Activity 的 startActivity 函数会调用到 ActivityTaskManagerService 的 startActivityAsUser 或者其他几个 start 方法</p>
<ul>
<li><p>ActivityTaskManagerService.startActivityAsUser</p>
</li>
<li><p>—&gt;ActivityStarter.execute</p>
</li>
<li><p>—&gt;ActivityStarter.executeRequest</p>
<ul>
<li>内部创建ActivityRecord ： ActivityRecord r &#x3D; new ActivityRecord.Builder(mService)<ul>
<li>ActivityRecord 继承 WindowToken</li>
<li>Android 12 构造函数中 appToken &#x3D;  new Token<ul>
<li>Token extends IApplicationToken.Stub</li>
</ul>
</li>
<li>token，这个东西Android 11，Android12，Android13 这里的代码都不一样。</li>
<li>Android 13   Token extends Binder<ul>
<li>ActivityRecord  没有 appToken 变量了，也是new Token，然后传递到 父类 WindowToken 中</li>
</ul>
</li>
<li>由于构造函数中传递的DisplayContent为null，新创建的 ActivityRecord 还不会加入 DisplayContent 的HashMap对象 mTokenMap</li>
</ul>
</li>
</ul>
</li>
<li><p>—&gt;ActivityStarter.startActivityUnchecked</p>
</li>
<li><p>—&gt;ActivityStarter.startActivityInner</p>
<ul>
<li><p>setNewTask</p>
<p>–&gt;addOrReparentStartingActivity(task, “setTaskFromReuseOrCreateNewTask”);   把 ActivityRecord 添加到任务栈</p>
<ul>
<li>给 ActivityRecord 添加 parent : parent.addChild(mStartActivity);   ActivityRecord.getTask 返回的就是这个 targetTask</li>
<li><strong>addOrReparentStartingActivity 最终会把 ActivityRecord 加入到 DisplayContent .mTokenMap</strong></li>
</ul>
</li>
<li><p>mTargetRootTask.startActivityLocked</p>
<ul>
<li>判断当前 activity 是否需要为其新建 Task，将 ActivityRecord 加入到对应的 Task 栈顶中</li>
<li>ActivityRecord.showStartingWindow  启动过度界面</li>
</ul>
</li>
<li><p>mTargetRootTask.moveToFront</p>
</li>
<li><p>RootWindowContainer.resumeFocusedTasksTopActivities&#x3D;&#x3D;&#x3D;&gt;转Task.resumeFocusedTasksTopActivities</p>
</li>
<li><p>mSupervisor.mRecentTasks.add(mStartActivity.getTask())</p>
</li>
<li><p>其他任务栈相关的处理</p>
</li>
</ul>
</li>
<li><p>—&gt; Task.resumeFocusedTasksTopActivities</p>
</li>
<li><p>—&gt; Task.resumeTopActivityUncheckedLocked</p>
</li>
<li><p>—&gt; Task.resumeTopActivityInnerLocked  &#x2F;&#x2F; 这里写是的Android12的流程，Android 13 这里不一样了</p>
<ul>
<li>ActivityRecord next &#x3D; topRunningActivity(true &#x2F;* focusableOnly *&#x2F;);</li>
<li>—&gt;如果有关联的进程，则直接调度生命周期：mAtmService.getLifecycleManager().scheduleTransaction(transaction);</li>
<li>—&gt;如果是新的activity【mTaskSupervisor.startSpecificActivity(next, true, true)】，事务添加 LaunchActivityItem Callback，用于app进程创建activity。如果没有进程还会创建进程</li>
</ul>
</li>
<li><p>—&gt;ActivityTaskSupervisor.startSpecificActivity</p>
<ul>
<li>—&gt; 如果已有进程调用 realStartActivityLocked</li>
<li>—&gt;没有进程，创建进程流程：mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? “top-activity” : “activity”);</li>
</ul>
</li>
<li><p>–&gt;ATMS.startProcessAsync</p>
<ul>
<li>startProcessAsync 只是把任务post给AMS，调用 AMS.startProcess</li>
</ul>
</li>
<li><p>–&gt;ActivityManagerInternal.startProcess</p>
<ul>
<li>ActivityManagerInternal.startProcess 是个抽象方法，实现是 ActivityManagerService.LocalService.startProcess</li>
</ul>
</li>
<li><p>–&gt;ActivityManagerService.LocalService.startProcessLocked</p>
<ul>
<li>创建 HostingRecord ，并作为参数传给下一步</li>
<li>HostingRecord .mHostingZygote 属性用于选择 zygote 类型</li>
<li>HostingRecord 构造函数未传入 hostingZygote 参数，使用默认的 REGULAR_ZYGOTE ，即常规孵化器</li>
</ul>
</li>
<li><p>ActivityManagerService.startProcessLocked  没啥内容，直接调用 ProcessList.startProcessLocked</p>
</li>
<li><p>–&gt;16参数的ProcessList.startProcessLocked</p>
<ul>
<li>处理 badProcess，连续崩溃超过2次会变成badProcess，后台禁止启动badProcess</li>
<li>处理隔离进程</li>
<li>处理不同App在同一个进程情况，App正在启动情况<ul>
<li>正在启动的话，直接返回</li>
</ul>
</li>
<li>处理App已经死亡，但是死亡通知还未到来的情况</li>
<li>处理系统还未启动完成情况，先把App存起来，之后处理</li>
</ul>
</li>
<li><p>–&gt;4参数的ProcessList.startProcessLocked  直接转发到6参数的 startProcessLocked</p>
</li>
<li><p>–&gt;6参数的ProcessList.startProcessLocked  代码很多主要是设置启动参数</p>
<ul>
<li>进程正在启动中，返回</li>
<li>记录启动开始的时间</li>
<li>清理参与的 死亡通知信息</li>
<li>清理mProcessesOnHold用于保存那些在系统还没有准备好就提前请求启动的ProcessRecord</li>
<li>更新 Profiler 信息</li>
<li>设置外存储挂载模式、设置App权限：gids</li>
<li>处理 manifest中设置了android:debuggable 信息，添加debug启动参数</li>
<li>设置 ABI、设置指令集、设置 selinux</li>
<li>设置App进程的启动入口为 “<strong>android.app.ActivityThread</strong>“</li>
</ul>
</li>
<li><p>–&gt;ProcessList.startProcess</p>
<ul>
<li>启动准备</li>
<li>设置一些正在启动的标志</li>
<li>异步启动和同步启动，默认使用异步启动</li>
</ul>
</li>
<li><p>–&gt;ProcessList.handleProcessStart  <strong>异步启动</strong></p>
<ul>
<li>如果上一个App还没有死亡通知，则延迟启动，延迟时间最长默认 10 秒</li>
<li>正常情况直接调用 ProcessList.startProcess</li>
</ul>
</li>
<li><p>–&gt;ProcessList.startProcess</p>
<ul>
<li>处理存储目录</li>
<li><strong>选择创建App进程的孵化器</strong>，由于HostingRecord .mHostingZygote 为 REGULAR_ZYGOTE ，因此调用 Process.start</li>
</ul>
</li>
<li><p>–&gt;Process.start 没啥内容，直接调用 ZygoteProcess.start</p>
</li>
<li><p>–&gt;ZygoteProcess.start</p>
<ul>
<li>处理usap，usap启用的话，预创建APP进程，最大创建10个线程</li>
<li>Android 13 由属性 dalvik.vm.usap_pool_enabled 决定是否启用usap，这个属性默认为false</li>
<li>之后调用 ZygoteProcess.startViaZygote</li>
</ul>
</li>
<li><p>–&gt;ZygoteProcess.startViaZygote  把参数封装成字符串</p>
</li>
<li><p>–&gt;ZygoteProcess.zygoteSendArgsAndGetResult  处理一些字符串异常，并加入数据大小</p>
<ul>
<li>调用 openZygoteSocketIfNeeded(abi) 连接  ZygoteServer ，根据ABI确定连接 zygote(zygote64) 还是 zygote_secondary(zygote32)</li>
</ul>
</li>
<li><p>–&gt;ZygoteProcess.attemptZygoteSendArgsAndGetResult  写完socket，接着后读socket –&gt;zygoteWriter.write(msgStr);<br> –&gt;使用socket 数据传输到 ZygoteServer</p>
</li>
</ul>
<h4 id="ZygoteServer进程"><a href="#ZygoteServer进程" class="headerlink" title="ZygoteServer进程"></a>ZygoteServer进程</h4><p>从Zygote启动讲起</p>
<p>ZygoteInit.main   &#x2F;&#x2F; Zygote 有两种启动方式，一种是启动system_server 一种启动App</p>
<ul>
<li>main函数<ul>
<li>1、非懒加载情况下，预加载资源：jar，图形库，drawable、字体</li>
<li>2、创建zygote进程的socket server服务端对象 ZygoteServer</li>
<li>3、调用 ZygoteServer.runSelectLoop 进入死循环，等待 AMS 创建进程的socket消息(也会处理其他消息)</li>
<li>4、调用 runSelectLoop 返回的 Runnable.run 方法</li>
</ul>
</li>
<li>ZygoteServer.runSelectLoop</li>
<li>ZygoteServer.acceptCommandPeer &#x2F;&#x2F; 得到一个请求连接封装对象ZygoteConnection</li>
<li>ZygoteConnection.processCommand  &#x2F;&#x2F;处理AMS客户端请求</li>
<li>Zygote.forkSimpleApps   &#x2F;&#x2F; fork创建应用子进程，<ul>
<li>ZygoteCommandBuffer.forkRepeatedly &#x2F;&#x2F; 进入native层后，调用 fork()</li>
<li>Zygote.childMain<ul>
<li>ZygoteInit.zygoteInit  &#x2F;&#x2F;  开启 binder 消息监听 ,设置异常处理函数</li>
<li>RuntimeInit.applicationInit</li>
<li>RuntimeInit.findStaticMain<ul>
<li>return new MethodAndArgsCaller(m, argv);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>MethodAndArgsCaller 对象不再继承Exception，仅仅继承Runnable，</p>
<p>MethodAndArgsCaller经过层层 return 后，返回 ZygoteInit.main ，</p>
<p>最后调用 MethodAndArgsCaller.run 方法 <strong>通过反射创建<code>ActivityThread</code>对象并调用其“<code>main</code>”入口方法。</strong></p>
<h5 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ZygoteInit.main(String[] argv);</span><br><span class="line">|	<span class="type">ZygoteServer</span> <span class="variable">zygoteServer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">|	Runnable caller;    </span><br><span class="line"><span class="comment">// 非懒加载情况下，预加载资源</span></span><br><span class="line">|--&gt;<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span>;</span><br><span class="line">	|	preloadClasses(); <span class="comment">// 加载 /system/etc/preloaded-classes </span></span><br><span class="line">	<span class="comment">//  加载非启动使用的类：</span></span><br><span class="line">	<span class="comment">//	/system/framework/android.hidl.base-V1.0-java.jar </span></span><br><span class="line">	<span class="comment">//	/system/framework/android.hidl.manager-V1.0-java.jar</span></span><br><span class="line">	<span class="comment">//	/system/framework/android.test.base.jar</span></span><br><span class="line">    |	cacheNonBootClasspathClassLoaders();</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       com.android.internal.R.array.preloaded_drawables</span></span><br><span class="line"><span class="comment">       com.android.internal.R.array.preloaded_color_state_lists</span></span><br><span class="line"><span class="comment">       com.android.internal.R.array.preloaded_freeform_multi_window_drawables</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">	|	preloadResources();</span><br><span class="line">	<span class="comment">// 预加载图形缓存map库</span></span><br><span class="line">	<span class="comment">// Gralloc4Mapper::preload();Gralloc3Mapper::preload();Gralloc2Mapper::preload();</span></span><br><span class="line">	|	nativePreloadAppProcessHALs();</span><br><span class="line">	<span class="comment">/* GL driver 或者 Vulkan driver 预加载 */</span></span><br><span class="line">	|	maybePreloadGraphicsDriver();</span><br><span class="line">	<span class="comment">//	加载共享库：libandroid.so libcompiler_rt.so libjnigraphics.so</span></span><br><span class="line">	|	preloadSharedLibraries();</span><br><span class="line">	<span class="comment">//	TextView.preloadFontCache();  加载字体</span></span><br><span class="line">	|	preloadTextResources();</span><br><span class="line">	|	WebViewFactory.prepareWebViewInZygote();</span><br><span class="line"><span class="comment">// native层获取socket fd; 命名空间mount rootfs; selinux_android_seapp_context_init();</span></span><br><span class="line">|	Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"><span class="comment">//如果是主Zygote，Zygote 64位，创建地址名为 zygote 的socket服务端，以及usap socket服务 usap_pool_primary</span></span><br><span class="line"><span class="comment">//如果是次Zygote，Zygote 32位，创建地址名为 zygote_secondary 的socket服务端，以及usap socket服务 usap_pool_secondary</span></span><br><span class="line">|	zygoteServer = <span class="keyword">new</span> <span class="title class_">ZygoteServer</span>(isPrimaryZygote);</span><br><span class="line"><span class="comment">//	如果argv参数中有 &quot;start-system-server&quot; 则fork SystemServer 进程</span></span><br><span class="line">|	<span class="keyword">if</span> (startSystemServer)</span><br><span class="line">    |	<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line">	|	r.run();</span><br><span class="line">	|	<span class="keyword">return</span>;  <span class="comment">// for SystemServer 进程 后直接返回,退出进程</span></span><br><span class="line"><span class="comment">//	默认情况，运行 runSelectLoop ，开启 zygoteServer 循环，等待 AMS 创建进程的socket消息</span></span><br><span class="line">|	caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">|	<span class="keyword">if</span> (caller != <span class="literal">null</span>)  <span class="comment">// fork 完成的子进程，会从runSelectLoop无线循环中跳出，会进入到这里</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果是子进程的话，这里返回的是 MethodAndArgsCaller，MethodAndArgsCaller 继承Runnable</span></span><br><span class="line"><span class="comment">    这里不像以前那样抛出异常清理栈帧，就是回退到 ZygoteInit.main，通过 MethodAndArgsCaller.run调用 android.app.ActivityThread.main</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    |	caller.run();</span><br></pre></td></tr></table></figure>

<h5 id="ZygoteServer-runSelectLoop"><a href="#ZygoteServer-runSelectLoop" class="headerlink" title="ZygoteServer.runSelectLoop"></a>ZygoteServer.runSelectLoop</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Runnable <span class="title function_">runSelectLoop</span><span class="params">(String abiList)</span>;</span><br><span class="line"><span class="comment">//	socketFDs[0] 为 ZygoteServer 的fd，之后的数据为 连接客户端的 socket fd</span></span><br><span class="line">|	ArrayList&lt;FileDescriptor&gt; socketFDs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">|	ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">|	socketFDs.add(mZygoteSocket.getFileDescriptor());<span class="comment">// ZygoteServer 的fd</span></span><br><span class="line">|	peers.add(<span class="literal">null</span>);<span class="comment">// 先add了一个null，用于和 socketFDs 共用一个下标变量 pollIndex </span></span><br><span class="line">|	<span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    |	StructPollfd[] pollFDs;</span><br><span class="line">    <span class="comment">//	循环起始先把 socketFDs 的fd加入到数组 pollFDs </span></span><br><span class="line">	<span class="comment">//	之后再把 usapPool 的 fd 加入到 pollFDs</span></span><br><span class="line">    <span class="comment">//	usapPoolEventFDIndex 记录 usapPool 起始索引</span></span><br><span class="line">    <span class="comment">//	poll监听 socketFDs 中的文件描述符</span></span><br><span class="line">    |	Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">	|	<span class="keyword">while</span> (--pollIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        |	<span class="keyword">if</span> (pollIndex == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//	pollIndex == 0 表示 ZygoteServer socket 事件</span></span><br><span class="line">            |	<span class="type">ZygoteConnection</span> <span class="variable">newPeer</span> <span class="operator">=</span> acceptCommandPeer(abiList); <span class="comment">// 拿到连接客户端的socket</span></span><br><span class="line">			|	peers.add(newPeer);</span><br><span class="line">			<span class="comment">//	把客户端的fd放到数组，下一次循环，一起加入到poll监听</span></span><br><span class="line">			|	socketFDs.add(newPeer.getFileDescriptor());</span><br><span class="line">		|	<span class="keyword">else</span> <span class="keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) </span><br><span class="line">            <span class="comment">//	AMS 创建进程的客户端 socket 事件</span></span><br><span class="line">            |	<span class="type">ZygoteConnection</span> <span class="variable">connection</span> <span class="operator">=</span> peers.get(pollIndex);</span><br><span class="line">			<span class="comment">//	读取socket连接的数据，并处理</span></span><br><span class="line">			|	<span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> connection.processCommand(<span class="built_in">this</span>, multipleForksOK);</span><br><span class="line">			<span class="comment">//	//默认值为false，在子进程时，会调用 setForkChild 设置为 true</span></span><br><span class="line">			|	<span class="keyword">if</span> (mIsForkChild)</span><br><span class="line">                <span class="comment">//	子进程返回的是 继承Runnable的 MethodAndArgsCaller 对象</span></span><br><span class="line">                |	<span class="keyword">return</span> command; <span class="comment">// 子进程直接返回 command ，并结束 runSelectLoop 循环</span></span><br></pre></td></tr></table></figure>

<h5 id="ZygoteConnection-processCommand"><a href="#ZygoteConnection-processCommand" class="headerlink" title="ZygoteConnection.processCommand"></a>ZygoteConnection.processCommand</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Runnable <span class="title function_">processCommand</span><span class="params">(ZygoteServer zygoteServer, <span class="type">boolean</span> multipleOK)</span>;</span><br><span class="line"><span class="comment">// 创建 native 层对象 NativeCommandBuffer，用于读socket数据 </span></span><br><span class="line">|	<span class="type">ZygoteCommandBuffer</span> <span class="variable">argBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZygoteCommandBuffer</span>(mSocket);</span><br><span class="line"><span class="comment">// 把 ZygoteCommandBuffer 传入ZygoteArguments</span></span><br><span class="line"><span class="comment">// 并调用 ZygoteArguments.parseArgs(ZygoteCommandBuffer args, int argCount)</span></span><br><span class="line"><span class="comment">// parseArgs 读取socket，并解析数据</span></span><br><span class="line">|	parsedArgs = ZygoteArguments.getInstance(argBuffer);</span><br><span class="line">|	<span class="keyword">if</span> (parsedArgs.mPreloadPackage != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 如果是 WebViewZygote，预加载 WebView 的库</span></span><br><span class="line">    |	handlePreloadPackage(...);</span><br><span class="line">|	<span class="keyword">if</span> (canPreloadApp() &amp;&amp; parsedArgs.mPreloadApp != <span class="literal">null</span>) </span><br><span class="line">    <span class="comment">// 如果是AppZygoteServer，会预加载apk</span></span><br><span class="line">    |	handlePreloadApp(...);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mInvokeWith InvokeWith  DEBUG 使用， wrap.sh 脚本相关</span></span><br><span class="line"><span class="comment">mStartChildZygote 创建子zygote进程</span></span><br><span class="line"><span class="comment">multipleOK = true</span></span><br><span class="line"><span class="comment">非系统进程（systemserver、系统App），ATMS就是 SYSTEM_UID </span></span><br><span class="line"><span class="comment">符合以上条件调用 Zygote.forkAndSpecialize，这个和以前也不一样了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">|	<span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="literal">null</span> || parsedArgs.mStartChildZygote || !multipleOK || peer.getUid() != Process.SYSTEM_UID)</span><br><span class="line">	|	pid = Zygote.forkAndSpecialize(...); <span class="comment">// 以前用这个，现在不用了</span></span><br><span class="line">    |<span class="keyword">else</span>  <span class="comment">// 通常情况是走 else 分支，调用 Zygote.forkSimpleApps</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">result</span> <span class="operator">=</span> Zygote.forkSimpleApps(...);</span><br><span class="line">		|--&gt;<span class="keyword">static</span> <span class="meta">@Nullable</span> Runnable <span class="title function_">forkSimpleApps</span><span class="params">(...)</span>;</span><br><span class="line">			|	<span class="type">boolean</span> <span class="variable">in_child</span> <span class="operator">=</span> argBuffer.forkRepeatedly(...);</span><br><span class="line">				|	<span class="keyword">return</span> nativeForkRepeatedly(...);</span><br><span class="line">					| com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(...);</span><br><span class="line">					  | NativeCommandBuffer.readAllLines;</span><br><span class="line">					  | <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> zygote::forkApp(...); <span class="comment">// fd 的处理</span></span><br><span class="line">						| 	zygote::ForkCommon(...);</span><br><span class="line">							|	<span class="type">pid_t</span> <span class="variable">pid</span> <span class="operator">=</span> fork(); <span class="comment">// 真正fork进程的地方</span></span><br><span class="line">							<span class="comment">//处于子进程时，pid=0，处理分配内存的设置等等</span></span><br><span class="line">							|	<span class="keyword">return</span> pid;</span><br><span class="line">					  |<span class="comment">//如果pid为0，处于子进程，return true;</span></span><br><span class="line">			|	<span class="keyword">if</span> (in_child) <span class="comment">// 如果是子进程，调用 childMain</span></span><br><span class="line">                |	<span class="keyword">return</span> childMain(argBuffer, <span class="comment">/*usapPoolSocket=*/</span><span class="literal">null</span>, <span class="comment">/*writePipe=*/</span><span class="literal">null</span>);</span><br><span class="line">				|<span class="keyword">else</span><span class="comment">// 如果是 Zygote 进程，return null;</span></span><br><span class="line">        |<span class="comment">// 子进程返回时，result不为null，return result;    </span></span><br></pre></td></tr></table></figure>

<h5 id="子进程调用-Zygote-childMain"><a href="#子进程调用-Zygote-childMain" class="headerlink" title="子进程调用 Zygote.childMain"></a>子进程调用 Zygote.childMain</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// frameworks/base/core/java/com/android/internal/os/Zygote.java</span></span><br><span class="line">Zygote.forkSimpleApps(...);</span><br><span class="line">|	childMain(argBuffer, <span class="comment">/*usapPoolSocket=*/</span><span class="literal">null</span>, <span class="comment">/*writePipe=*/</span><span class="literal">null</span>);</span><br><span class="line">|--&gt;<span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">childMain</span><span class="params">(ZygoteCommandBuffer argBuffer,LocalServerSocket usapPoolSocket,FileDescriptor writePipe)</span>;</span><br><span class="line">|	specializeAppProcess(...);</span><br><span class="line">	| nativeSpecializeAppProcess(...);</span><br><span class="line">	| com_android_internal_os_Zygote_nativeSpecializeAppProcess();</span><br><span class="line">		<span class="comment">//	设置命名空间的存储目录挂载</span></span><br><span class="line">		<span class="comment">//	设置调度策略，selinux，调试模式，SetGids，内存分配模式 等等</span></span><br><span class="line">	    |	SpecializeCommon(...);</span><br><span class="line">	| Thread.currentThread().setPriority(Thread.NORM_PRIORITY); <span class="comment">//设置进程优先级</span></span><br><span class="line">|	<span class="keyword">return</span> ZygoteInit.zygoteInit(args.mTargetSdkVersion,args.mDisabledCompatChanges,args.mRemainingArgs,<span class="literal">null</span>);</span><br><span class="line">			|	RuntimeInit.commonInit();</span><br><span class="line">				<span class="comment">//	设置异常处理</span></span><br><span class="line">				|	RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">				|	Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">KillApplicationHandler</span>(loggingHandler));</span><br><span class="line">			|	ZygoteInit.nativeZygoteInit(); <span class="comment">//  开启 binder 消息监听</span></span><br><span class="line">				|--&gt; com_android_internal_os_ZygoteInit_nativeZygoteInit</span><br><span class="line">                    |--&gt; gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">						|--&gt; frameworks/base/cmds/app_process/app_main.cpp</span><br><span class="line">                        |--&gt; onZygoteInit();</span><br><span class="line">							|	sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">							|	proc-&gt;startThreadPool();</span><br><span class="line">			|	<span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);</span><br><span class="line">				|	<span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">					|	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAndArgsCaller</span>(m, argv); <span class="comment">// MethodAndArgsCaller 是个 Runnable, [见：附]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 层层 return 回退到 ZygoteInit.main，通过 MethodAndArgsCaller.run 调用 android.app.ActivityThread.main </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附：MethodAndArgsCaller</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mMethod.invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; mArgs &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、android-app-ActivityThread-main"><a href="#三、android-app-ActivityThread-main" class="headerlink" title="三、android.app.ActivityThread.main"></a>三、android.app.ActivityThread.main</h3><h4 id="1、ActivityThread-main-到-AMS-流程"><a href="#1、ActivityThread-main-到-AMS-流程" class="headerlink" title="1、ActivityThread.main  到 AMS 流程"></a>1、ActivityThread.main  到 AMS 流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ActivityThread.main</span><br><span class="line">  <span class="comment">// 1.创建主线程的 Looper 对象。 main函数最后调用 Looper.loop();启动无线循环。</span></span><br><span class="line">  | Looper.prepareMainLooper();  </span><br><span class="line">  <span class="comment">// 2.创建 ActivityThread 对象</span></span><br><span class="line">  | <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();  </span><br><span class="line">		<span class="comment">// 在类成员中直接创建 ApplicationThread，ApplicationThread 继承 IApplicationThread.Stub </span></span><br><span class="line">		<span class="comment">// IApplicationThread 是 APP 同 AMS 交互的接口 </span></span><br><span class="line">	|	<span class="keyword">final</span> <span class="type">ApplicationThread</span> <span class="variable">mAppThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationThread</span>();			</span><br><span class="line">  <span class="comment">// 3. 调用 ActivityThread .attach 方法</span></span><br><span class="line">  | thread.attach(<span class="literal">false</span>, startSeq);   </span><br><span class="line">    | <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">	<span class="comment">// mAppThread 是 ApplicationThread 	</span></span><br><span class="line">	<span class="comment">// 通过binder调用AMS的attachApplication接口将 ApplicationThread 注册到AMS中</span></span><br><span class="line">    | mgr.attachApplication(mAppThread, startSeq);  </span><br><span class="line">	  <span class="comment">// 进入systemserver进程 的 AMS </span></span><br><span class="line">      | AMS.attachApplicationLocked <span class="comment">//直接转到 attachApplicationLocked</span></span><br><span class="line">        |  ProcessRecord app;  </span><br><span class="line">        | 【<span class="number">1</span>】thread.bindApplication(...); <span class="comment">//binder跨进程 回调 ApplicationThread bindApplication</span></span><br><span class="line">          <span class="comment">// bindApplication流程：</span></span><br><span class="line">          <span class="comment">/*app进程 ApplicationThread .handleBindApplication</span></span><br><span class="line"><span class="comment">            Dex文件的加载和Resource资源的加载</span></span><br><span class="line"><span class="comment">            创建应用的LoadedApk对象、创建Application的Context</span></span><br><span class="line"><span class="comment">            加载应用APK的Dex文件到内存中，加载APK的Resource资源</span></span><br><span class="line"><span class="comment">            调用LoadedApk.makeApplication函数，创建应用的Application对象</span></span><br><span class="line"><span class="comment">            执行应用 Application.onCreate 生命周期函数*/</span></span><br><span class="line">        <span class="comment">// 设置 ProcessRecord.mThread = IApplicationThread(thread)</span></span><br><span class="line">        <span class="comment">// 设置 ProcessRecord.mWindowProcessController.mThread = IApplicationThread(thread)      </span></span><br><span class="line">        | app.makeActive(thread, mProcessStats);  </span><br><span class="line">        <span class="comment">//启动应用 Activity的 流程      </span></span><br><span class="line">        | 【<span class="number">2</span>】mAtmInternal.attachApplication(app.getWindowProcessController()); </span><br><span class="line">          | mRootWindowContainer.attachApplication(wpc);</span><br><span class="line">            | RootWindowContainer::startActivityForAttachedApplicationIfNeeded<span class="comment">//这里Android 13 版本有些变化</span></span><br><span class="line">              | mStackSupervisor.realStartActivityLocked(ActivityRecord r,WindowProcessController proc,<span class="type">boolean</span> andResume,...)</span><br><span class="line">                |	r.startFreezingScreenLocked(proc, <span class="number">0</span>); <span class="comment">// 冻结屏幕</span></span><br><span class="line">				|	r.setProcess(proc);  <span class="comment">// ActivityRecord 关联 WindowProcessController</span></span><br><span class="line">				<span class="comment">//	创建 ClientTransaction </span></span><br><span class="line">				<span class="comment">//	ClientTransaction.mClient = WindowProcessController.getThread() 是 App 端的 ApplicationThread</span></span><br><span class="line">				<span class="comment">//	使用 ActivityRecord.token 赋值 ClientTransaction.mActivityToken</span></span><br><span class="line">				<span class="comment">//	ClientTransaction.mActivityToken 会传入 客户端app进程</span></span><br><span class="line">				<span class="comment">// 注：Android12 用的 ActivityRecord.appToken, Android 12 ActivityRecord.appToken=ActivityRecord.token</span></span><br><span class="line">				|	<span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">clientTransaction</span> <span class="operator">=</span> ClientTransaction.obtain(proc.getThread(), r.token); </span><br><span class="line">				<span class="comment">//  添加 LaunchActivityItem 回调，App进程会执行其execute方法，内部执行 handleLaunchActivity</span></span><br><span class="line">				|	clientTransaction.addCallback(LaunchActivityItem.obtain(...))</span><br><span class="line">                |	lifecycleItem = ResumeActivityItem.obtain(isTransitionForward, r.shouldSendCompatFakeFocus()); </span><br><span class="line">				<span class="comment">//	App进程会执行 ResumeActivityItem.execute方法 ,内部调用 handleResumeActivity</span></span><br><span class="line">				|	clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">                <span class="comment">//	传递Launch和Resume生命周期事务</span></span><br><span class="line">                | 	mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">  <span class="comment">// 4. 启动loop无线循环</span></span><br><span class="line">  |  Looper.loop();</span><br></pre></td></tr></table></figure>

<h4 id="2、scheduleTransaction-跨进程调用，把事务传递到-APP进程"><a href="#2、scheduleTransaction-跨进程调用，把事务传递到-APP进程" class="headerlink" title="2、scheduleTransaction 跨进程调用，把事务传递到 APP进程"></a>2、scheduleTransaction 跨进程调用，把事务传递到 APP进程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ClientLifecycleManager.scheduleTransaction(ClientTransaction transaction);</span><br><span class="line">|	transaction.schedule();</span><br><span class="line">|--&gt;ClientTransaction.schedule();</span><br><span class="line">	<span class="comment">// IApplicationThread mClient; </span></span><br><span class="line">	|	mClient.scheduleTransaction(<span class="built_in">this</span>) <span class="comment">//ApplicationThread 继承 IApplicationThread</span></span><br><span class="line">	|--&gt;ApplicationThread.scheduleTransaction(ClientTransaction transaction);</span><br><span class="line">		|	ActivityThread.<span class="built_in">this</span>.scheduleTransaction(transaction);</span><br><span class="line">		<span class="comment">//	ActivityThread.scheduleTransaction 继承 ClientTransactionHandler.scheduleTransaction</span></span><br><span class="line">		|--&gt;ClientTransactionHandler.scheduleTransaction(ClientTransaction transaction);</span><br><span class="line">			<span class="comment">//	调用 LaunchActivityItem.preExecute 预处理工作</span></span><br><span class="line">			|	transaction.preExecute(<span class="built_in">this</span>); </span><br><span class="line">			|	sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); <span class="comment">//post到主线程去处理</span></span><br><span class="line">				|--&gt;ActivityThread.H.handleMessage(Message msg);</span><br><span class="line">					|	mTransactionExecutor.execute(transaction);	</span><br><span class="line">						|	executeCallbacks(transaction);</span><br><span class="line">							<span class="comment">//	取出	ClientTransaction.mActivityToken 作为参数传入 LaunchActivityItem.execute</span></span><br><span class="line">							|	<span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> transaction.getActivityToken();</span><br><span class="line">							<span class="comment">//	这个 token = ActivityRecord.appToken</span></span><br><span class="line">							|	LaunchActivityItem.execute(ClientTransactionHandler client, IBinder token,...);</span><br><span class="line">								<span class="comment">//	创建 ActivityClientRecord  ActivityClientRecord.token = token;</span></span><br><span class="line">								<span class="comment">//	Android 12 是在 preExecute 中创建，Android 13 变更到了execute 中</span></span><br><span class="line">								|	<span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityClientRecord</span>(token, mIntent, mIdent, mInfo,...);</span><br><span class="line">								<span class="comment">// 执行 ActivityThread.handleLaunchActivity</span></span><br><span class="line">								|	client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">						|	executeLifecycleState(transaction);</span><br><span class="line">							|	ResumeActivityItem.execute(ClientTransactionHandler client, ActivityClientRecord r,...);</span><br><span class="line">								<span class="comment">//	执行 ActivityThread.handleResumeActivity</span></span><br><span class="line">                                |	client.handleResumeActivity(r, <span class="literal">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,...);</span><br></pre></td></tr></table></figure>

<p>ActivityClientRecord.token &#x3D; ClientTransaction.mActivityToken &#x3D; ActivityRecord.token</p>
<p>经过一系列的 事务，生命周期管理相关的代码后 调用 handleLaunchActivity 和 handleResumeActivity</p>
<h4 id="3、handleLaunchActivity"><a href="#3、handleLaunchActivity" class="headerlink" title="3、handleLaunchActivity"></a>3、handleLaunchActivity</h4><ul>
<li>执行 Launch 生命周期</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">//	frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</span></span><br><span class="line">client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line">ActivityThread.handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent);</span><br><span class="line">|	performLaunchActivity(ActivityClientRecord r, Intent customIntent)</span><br><span class="line">    <span class="comment">//	1.创建Activity的Context，Activity虽然也是Context，但是其真正的Context是Activity.mBase 成员    </span></span><br><span class="line">    |	<span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> createBaseContextForActivity(r);</span><br><span class="line">    <span class="comment">//	2.调用 mInstrumentation.newActivity,通过反射创建Activity</span></span><br><span class="line">    |	java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> appContext.getClassLoader();</span><br><span class="line">	|	activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);</span><br><span class="line">	<span class="comment">//  把 ActivityClientRecord 存入 mActivities</span></span><br><span class="line">	<span class="comment">//	ActivityClientRecord.activity 存储 Activity 对象</span></span><br><span class="line">	|	mActivities.put(r.token, r);</span><br><span class="line">    <span class="comment">//  3.调用 activity.attach 方法</span></span><br><span class="line">	|	activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo,...);</span><br><span class="line">		<span class="comment">//	把 performLaunchActivity 创建的 context 设置到 Activity.mBase</span></span><br><span class="line">		|	attachBaseContext(context);</span><br><span class="line">		<span class="comment">//  创建 PhoneWindow 对象</span></span><br><span class="line">		|	mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window, activityConfigCallback);</span><br><span class="line">			|	mWindowAttributes = <span class="keyword">new</span> <span class="title class_">WindowManager</span>.LayoutParams();</span><br><span class="line">				<span class="comment">// 这个 type 在后边 Window.adjustLayoutParamsForSubWindow 会用到</span></span><br><span class="line">				|	type = TYPE_APPLICATION;	</span><br><span class="line">		<span class="comment">//	设置Activity key dispatching， panels and menus 等回调。用于拦截点击触摸事件等等</span></span><br><span class="line">		|	mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//至此：</span></span><br><span class="line"><span class="comment">//	activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line">		|	mToken = token;</span><br><span class="line">		|	mApplication = application;</span><br><span class="line">		<span class="comment">//	给 PhoneWindow 对象，设置 WindowManager 对象</span></span><br><span class="line">        |	mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, ...);</span><br><span class="line">		<span class="comment">//	SystemServiceRegistry 静态代码中创建 getSystemService 接口的 WindowManager 实例：</span></span><br><span class="line">			|	<span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(ctx);</span><br><span class="line">				<span class="comment">// SystemServiceRegistry 创建的WindowManagerImpl的成员 mParentWindow=null; mWindowContextToken=null;</span></span><br><span class="line">				|	<span class="built_in">this</span>(context, <span class="literal">null</span> <span class="comment">/* parentWindow */</span>, <span class="literal">null</span> <span class="comment">/* clientToken */</span>);</span><br><span class="line">		|--&gt;Window.setWindowManager(WindowManager wm, IBinder appToken, String appName,<span class="type">boolean</span> hardwareAccelerated);</span><br><span class="line"><span class="comment">//至此：</span></span><br><span class="line"><span class="comment">//PhoneWindow.mAppToken=activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line">			|	mAppToken = appToken;</span><br><span class="line">			|	mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="built_in">this</span>);<span class="comment">// 参数传入 PhoneWindow</span></span><br><span class="line">			|--&gt;WindowManagerImpl <span class="title function_">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span><br><span class="line">				|	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(mContext, parentWindow, mWindowContextToken);</span><br><span class="line">					|	mContext = context;</span><br><span class="line">					|	mParentWindow = parentWindow; <span class="comment">// 这个传入的是 PhoneWindow</span></span><br><span class="line">					|	mWindowContextToken = windowContextToken; <span class="comment">// 这个是 null</span></span><br><span class="line">            | 	这个 mWindowManager 对象时<span class="keyword">new</span>的 WindowManagerImpl</span><br><span class="line">            <span class="comment">// 	也就是说Activity中的 mWindowManager 对象，获取的window管理器是 WindowManagerImpl</span></span><br><span class="line">        |	mWindowManager = mWindow.getWindowManager(); </span><br><span class="line">	|	r.activity = activity;	<span class="comment">//	ActivityClientRecord 关联 activity</span></span><br><span class="line">	<span class="comment">//	4.Instrumentation.callActivityOnCreate---&gt;Activity.onCreate	</span></span><br><span class="line">    |	mInstrumentation.callActivityOnCreate</span><br><span class="line">          <span class="comment">// 执行Activity的onCreate生命周期函数</span></span><br><span class="line">          <span class="comment">// 在 setContentView 调用installDecor创建 DecorView 对象</span></span><br><span class="line">          <span class="comment">// 并设置 DecorView 的window对象为 PhoneWindow </span></span><br><span class="line">		|	Activity.performCreate</span><br><span class="line">      		|	Activity.onCreate</span><br><span class="line">        		|	Activity.setContentView(R.layout.activity_main);</span><br><span class="line">          			|	getWindow().setContentView</span><br><span class="line">            			|	PhoneWindow.installDecor()</span><br><span class="line">                    		|	mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">								|	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecorView</span>(context, featureId, <span class="built_in">this</span>, getAttributes());</span><br><span class="line">								|--&gt;DecorView(Context context,..., PhoneWindow window,WindowManager.LayoutParams params)</span><br><span class="line">									|	setWindow(window);</span><br><span class="line">										|	mWindow = window; <span class="comment">//PhoneWindow;		</span></span><br></pre></td></tr></table></figure>

<h4 id="4、handleResumeActivity"><a href="#4、handleResumeActivity" class="headerlink" title="4、handleResumeActivity"></a>4、handleResumeActivity</h4><ul>
<li>执行Resume生命周期</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">//	frameworks/base/core/java/android/app/servertransaction/ResumeActivityItem.java</span></span><br><span class="line">client.handleResumeActivity(r, <span class="literal">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward, mShouldSendCompatFakeFocus, <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="comment">// 执行应用Activity的onResume生命周期函数</span></span><br><span class="line">ActivityThread.handleResumeActivity(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,<span class="type">boolean</span> isForward, ...) </span><br><span class="line">  |	  performResumeActivity(r, finalStateRequest, reason);</span><br><span class="line">	  | 执行应用Activity的onResume生命周期函数</span><br><span class="line">      | r.activity.performResume(r.startsNotResumed, reason); </span><br><span class="line">			|	mInstrumentation.callActivityOnResume(<span class="built_in">this</span>);</span><br><span class="line">	  			|	activity.onResume();	</span><br><span class="line">  <span class="comment">//  handleResumeActivity中执行完毕performResumeActivity后，继续执行以下代码：</span></span><br><span class="line">  |   <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line">  |	  r.window = r.activity.getWindow(); <span class="comment">// 赋值 ActivityClientRecord.window</span></span><br><span class="line">  |	  <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">  |	  decor.setVisibility(View.INVISIBLE);</span><br><span class="line">  |   <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager(); <span class="comment">//activity.attach 中创建的 WindowManagerImpl 对象  </span></span><br><span class="line">  <span class="comment">//  返回的是  Window.mWindowAttributes，即 l = 	PhoneWindow.mWindowAttributes</span></span><br><span class="line">  |   WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">  |	  wm.addView(decor, l);</span><br><span class="line">  |--&gt;WindowManagerImpl.addView(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span><br><span class="line">      |	  applyTokens(params); <span class="comment">// 这里虽然看上去是设置 WindowManager.LayoutParams.token 但分析下来不是，还要在后边</span></span><br><span class="line">		  |	  <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">		  |	  <span class="keyword">if</span>(mDefaultToken != <span class="literal">null</span> )	wparams.token = mDefaultToken; <span class="comment">// 不进这个流程</span></span><br><span class="line">		  |   wparams.mWindowContextToken = mWindowContextToken;  <span class="comment">// 目前为止还是 null</span></span><br><span class="line">	  |   mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId());</span><br><span class="line">	  |--&gt;WindowManagerGlobal.addView(View view, ViewGroup.LayoutParams params, Window parentWindow, ...)</span><br><span class="line">          |   <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;	</span><br><span class="line">		  <span class="comment">//  设置 WindowManager.LayoutParams 的 token、title、packageName、flags 属性	</span></span><br><span class="line">          |	  parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">		  |--&gt;Window.adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp)</span><br><span class="line">              	<span class="comment">//  wp.type = TYPE_APPLICATION =2; 如果是startingwindow，这里 wp.type = 3 (startingwindow的flag)</span></span><br><span class="line">				|	wp.token = mContainer == <span class="literal">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class="line">				<span class="comment">//	因为 mContainer 是 null, 所以 wp.token = mAppToken 	</span></span><br><span class="line"><span class="comment">/*至此：</span></span><br><span class="line"><span class="comment">PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line"><span class="comment">PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken */</span></span><br><span class="line">  		  |	  <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display); <span class="comment">//创建ViewRootImpl对象</span></span><br><span class="line">		  <span class="comment">//  ViewRootImpl构造函数	</span></span><br><span class="line">		  |--&gt;ViewRootImpl(Context context, Display display);</span><br><span class="line">				|	构造函数中创建IWindowSession  对象，用于同 wms 通信</span><br><span class="line">                |	<span class="built_in">this</span>(context, display, WindowManagerGlobal.getWindowSession(), <span class="literal">false</span> <span class="comment">/* useSfChoreographer */</span>); </span><br><span class="line">					|	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">IWindowSession</span> <span class="variable">sWindowSession</span> <span class="operator">=</span> windowManager.openSession(...)</span><br><span class="line">                    |	mWindowSession = sWindowSession	</span><br><span class="line">                    <span class="comment">//  W extends IWindow.Stub ，作为参数传递给WMS，用于同 WMS 通信    </span></span><br><span class="line">                    |	mWindow = <span class="keyword">new</span> <span class="title class_">W</span>(<span class="built_in">this</span>);    </span><br><span class="line">                    |	创建 Choreographer 对象	</span><br><span class="line">                    |	mChoreographer = useSfChoreographer ? Choreographer.getSfInstance() : Choreographer.getInstance();</span><br><span class="line">						|	mChoreographer = Choreographer.getInstance();<span class="comment">//以上代码简写</span></span><br><span class="line">		  |	  </span><br><span class="line">		  |	  view.setLayoutParams(wparams);</span><br><span class="line">      	  |	  mViews.add(view);</span><br><span class="line">		  |	  mRoots.add(root);</span><br><span class="line">  		  |	  mParams.add(wparams);</span><br><span class="line"> 		  <span class="comment">//  来到关键点  ViewRootImpl.setview</span></span><br><span class="line">		  |	  root.setView(view, wparams, panelParentView, userId);</span><br></pre></td></tr></table></figure>

<p>setview之后看surface创建流程</p>
<h3 id="四、ViewRootImpl-注册vsync回调"><a href="#四、ViewRootImpl-注册vsync回调" class="headerlink" title="四、ViewRootImpl 注册vsync回调"></a>四、ViewRootImpl 注册vsync回调</h3><h4 id="注册vsync回调流程：Choreographer"><a href="#注册vsync回调流程：Choreographer" class="headerlink" title="注册vsync回调流程：Choreographer"></a>注册vsync回调流程：Choreographer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java复制代码WindowManagerGlobal:: mGlobal.addView</span><br><span class="line">    |	<span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display); <span class="comment">//创建ViewRootImpl对象</span></span><br><span class="line">		|	构造函数中创建 IWindowSession  对象，用于同 wms 通信</span><br><span class="line">        |	 <span class="built_in">this</span>(context, display, WindowManagerGlobal.getWindowSession(), <span class="literal">false</span> <span class="comment">/* useSfChoreographer */</span>);</span><br><span class="line">			|	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">IWindowSession</span> <span class="variable">sWindowSession</span> <span class="operator">=</span> windowManager.openSession(...)</span><br><span class="line">            |	mWindowSession = sWindowSession;</span><br><span class="line">			|	创建 Choreographer 对象</span><br><span class="line">            |	mChoreographer = useSfChoreographer ? Choreographer.getSfInstance() : Choreographer.getInstance();</span><br><span class="line">				<span class="comment">//  以上代码简写:</span></span><br><span class="line">				|	mChoreographer = Choreographer.getInstance(); </span><br><span class="line">				|--&gt;Choreographer::Choreographer <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">					<span class="comment">//  获取当前线程的 Choreographer,如果当前线程没有，就调用ThreadLocal.initialValue()创建一个新的 Choreographer</span></span><br><span class="line">					|	<span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">						|	ThreadLocal.initialValue();</span><br><span class="line">							|	<span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper(); </span><br><span class="line">							|	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP); <span class="comment">// VSYNC_SOURCE_APP = 0;</span></span><br><span class="line">								<span class="comment">//	Choreographer 构造函数:</span></span><br><span class="line">								|	Choreographer(Looper looper, <span class="type">int</span> vsyncSource)</span><br><span class="line">                                    |	mLooper = looper;</span><br><span class="line">									|	mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">									<span class="comment">//  创建 FrameDisplayEventReceiver,内部创建 IDisplayEventConnection，并创建vsync的通信socket</span></span><br><span class="line">									|	mDisplayEventReceiver = <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource);</span><br><span class="line">									|	mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">									<span class="comment">//	CALLBACK_LAST = 4</span></span><br><span class="line">									|	mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];	</span><br><span class="line">									<span class="comment">//	创建 5 个CallbackQueue	</span></span><br><span class="line">									|	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++)</span><br><span class="line">                                        |	mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br></pre></td></tr></table></figure>

<h4 id="注册vsync回调流程：EventThread"><a href="#注册vsync回调流程：EventThread" class="headerlink" title="注册vsync回调流程：EventThread"></a>注册vsync回调流程：EventThread</h4><p>Choreographer 构造函数创建 FrameDisplayEventReceiver 时，会创建同SurfaceFlinger的EventThread线程通信的 IDisplayEventConnection</p>
<p>IDisplayEventConnection定义了以下接口：</p>
<ul>
<li>void stealReceiveChannel(out BitTube outChannel);获取socket通信管道</li>
<li>void setVsyncRate(in int count); 设置vsync分发速率。0，不调用requestNextVsync不分发；1，每次vsync事件都分发；其他，每N个vsync事件分发一次<ul>
<li>系统默认为 0 ，不调用requestNextVsync不分发</li>
</ul>
</li>
<li>oneway void requestNextVsync();  请求vsync</li>
<li>ParcelableVsyncEventData getLatestVsyncEventData(); 获取最新的</li>
</ul>
<p>获取到 IDisplayEventConnection 后，会立刻调用 stealReceiveChannel 获取socket通信管道</p>
<p><strong>从 FrameDisplayEventReceiver 构造函数开始：</strong></p>
<h5 id="注册vsync回调流程：APP进程端"><a href="#注册vsync回调流程：APP进程端" class="headerlink" title="注册vsync回调流程：APP进程端"></a>注册vsync回调流程：APP进程端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码Choreographer choreographer = <span class="keyword">new</span> <span class="built_in">Choreographer</span>(Looper.<span class="built_in">myLooper</span>(), VSYNC_SOURCE_APP);</span><br><span class="line">	|	<span class="comment">//	Choreographer 构造函数中 new FrameDisplayEventReceiver</span></span><br><span class="line">	|	mDisplayEventReceiver = <span class="keyword">new</span> <span class="built_in">FrameDisplayEventReceiver</span>(looper, vsyncSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FrameDisplayEventReceiver 构造函数：</span></span><br><span class="line"><span class="comment">//参数 looper：当前线程的looper;	vsyncSource = VSYNC_SOURCE_APP =0;</span></span><br><span class="line"><span class="built_in">FrameDisplayEventReceiver</span>(Looper looper, <span class="type">int</span> vsyncSource);</span><br><span class="line">|	<span class="built_in">super</span>(looper, vsyncSource, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//	FrameDisplayEventReceiver 继承 DisplayEventReceiver</span></span><br><span class="line">    |	<span class="built_in">DisplayEventReceiver</span>(Looper looper, <span class="type">int</span> vsyncSource, <span class="type">int</span> eventRegistration)；</span><br><span class="line">     	|	mMessageQueue = looper.<span class="built_in">getQueue</span>();</span><br><span class="line">		<span class="comment">//	创建 NativeDisplayEventReceiver，把对象地址存储到java层的 DisplayEventReceiver.mReceiverPtr 中</span></span><br><span class="line">		|	mReceiverPtr = <span class="built_in">nativeInit</span>(<span class="keyword">this</span>, mMessageQueue,vsyncSource, eventRegistration);</span><br><span class="line">			<span class="comment">//	frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</span></span><br><span class="line">			|	<span class="built_in">nativeInit</span>(..., jobject receiverWeak, jobject messageQueueObj,jint vsyncSource, jint eventRegistration)</span><br><span class="line">                |	sp&lt;NativeDisplayEventReceiver&gt; receiver = </span><br><span class="line">                |			<span class="keyword">new</span> <span class="built_in">NativeDisplayEventReceiver</span>(env, receiverWeak, messageQueue, vsyncSource, eventRegistration);</span><br><span class="line">					<span class="comment">//	NativeDisplayEventReceiver 构造函数继续调用父类 DisplayEventDispatcher 的构造函数</span></span><br><span class="line">					<span class="comment">//	DisplayEventDispatcher 构造函数中创建成员变量 DisplayEventReceiver mReceiver(vsyncSource, eventRegistration)</span></span><br><span class="line">					<span class="comment">//	DisplayEventReceiver 构造函数：</span></span><br><span class="line">					<span class="comment">//	frameworks/native/libs/gui/DisplayEventReceiver.cpp</span></span><br><span class="line">					|	<span class="built_in">DisplayEventReceiver</span>(ISurfaceComposer::VsyncSource vsyncSource,EventRegistrationFlags eventRegistration)</span><br><span class="line">                        <span class="comment">//	获取 SurfaceFlinger 服务</span></span><br><span class="line">                        |	<span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">						<span class="comment">//	获取 IDisplayEventConnection 存储到成员变量 mEventConnection</span></span><br><span class="line">						|	mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>(vsyncSource, eventRegistration);</span><br><span class="line">							<span class="comment">//进入 BpSurfaceComposer.createDisplayEventConnection 开始binder通信</span></span><br><span class="line">						|--&gt;<span class="built_in">createDisplayEventConnection</span>(VsyncSource vsyncSource, EventRegistrationFlags eventRegistration)</span><br><span class="line">                            <span class="comment">//  【见 “SurfaceFlinger进程端注册vsync流程” 章节】    </span></span><br><span class="line">                            |	<span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(BnSurfaceComposer::CREATE_DISPLAY_EVENT_CONNECTION,data, &amp;reply);</span><br><span class="line">							|	result = <span class="built_in">interface_cast</span>&lt;IDisplayEventConnection&gt;(reply.<span class="built_in">readStrongBinder</span>());</span><br><span class="line">							|	<span class="keyword">return</span> result;</span><br><span class="line">						|	mDataChannel = std::<span class="built_in">make_unique</span>&lt;gui::BitTube&gt;();</span><br><span class="line">						<span class="comment">//	获取进程间通讯 socket 管道，封装到 BitTube 中，存储到成员变量 mDataChannel</span></span><br><span class="line">						<span class="comment">//	【详情，见 “SurfaceFlinger进程端注册vsync流程” 章节】 </span></span><br><span class="line">						|	mEventConnection-&gt;<span class="built_in">stealReceiveChannel</span>(mDataChannel.<span class="built_in">get</span>());</span><br><span class="line">				|	receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">					|	DisplayEventDispatcher.<span class="built_in">initialize</span>()</span><br><span class="line">                    <span class="comment">//	把 socket 加入    </span></span><br><span class="line">                    |	mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);    </span><br><span class="line">				|	receiver-&gt;<span class="built_in">incStrong</span>(gDisplayEventReceiverClassInfo.clazz);</span><br><span class="line">				|	<span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<h5 id="注册vsync回调流程：SurfaceFlinger-进程端"><a href="#注册vsync回调流程：SurfaceFlinger-进程端" class="headerlink" title="注册vsync回调流程：SurfaceFlinger 进程端"></a>注册vsync回调流程：SurfaceFlinger 进程端</h5><p>BpSurfaceComposer.createDisplayEventConnection 跨进程进入 SurfaceFlinger 端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//	frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="comment">//	参数vsyncSource = VSYNC_SOURCE_APP = 0; eventRegistration = 0</span></span><br><span class="line">SurfaceFlinger.<span class="built_in">createDisplayEventConnection</span>(ISurfaceComposer::VsyncSource vsyncSource,EventRegistrationFlags eventRegistration);</span><br><span class="line">|	<span class="comment">//	eVsyncSourceSurfaceFlinger = 1</span></span><br><span class="line">|   <span class="comment">//	handle = mAppConnectionHandle    </span></span><br><span class="line">|	<span class="type">const</span> <span class="keyword">auto</span>&amp; handle = vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line">|	<span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, eventRegistration);</span><br><span class="line">|--&gt;Scheduler.<span class="built_in">createDisplayEventConnection</span>(ConnectionHandle handle, ISurfaceComposer::EventRegistrationFlags eventRegistration)	</span><br><span class="line">    <span class="comment">//	std::unordered_map&lt;ConnectionHandle, Connection&gt; mConnections;</span></span><br><span class="line">    <span class="comment">//	mConnections 存储的 Connection 是个结构体。仅含有两个成员变量 EventThreadConnection 和 EventThread  [参见：附]</span></span><br><span class="line">    <span class="comment">//	mConnections[handle].thread.get() 获取 SurfaceFlinger.mAppConnectionHandle 对应的 EventThread, App的EventThread线程</span></span><br><span class="line">	|	<span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle].thread.<span class="built_in">get</span>(), eventRegistration);</span><br><span class="line">	|--&gt;Scheduler.<span class="built_in">createConnectionInternal</span>( EventThread* eventThread, EventRegistrationFlags eventRegistration)</span><br><span class="line">		|	<span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>([&amp;] &#123; <span class="built_in">resync</span>(); &#125;, eventRegistration);</span><br><span class="line">		|--&gt;EventThread.<span class="built_in">createEventConnection</span>(ResyncCallback resyncCallback, EventRegistrationFlags eventRegistration)</span><br><span class="line">            <span class="comment">//	EventThreadConnection 继承 IDisplayEventConnection ，返回APP的IDisplayEventConnection 就是 EventThreadConnection</span></span><br><span class="line">            |	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="keyword">this</span>,IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>(),resyncCallback，eventRegistration）</span><br><span class="line">            <span class="comment">//	EventThreadConnection 构造函数：                                     </span></span><br><span class="line">            |--&gt;<span class="built_in">EventThreadConnection</span>(EventThread* eventThread, <span class="type">uid_t</span> callingUid, ResyncCallback resyncCallback,...)</span><br><span class="line">            	|	: <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">                |	<span class="built_in">mOwnerUid</span>(callingUid),</span><br><span class="line">                |   <span class="built_in">mEventRegistration</span>(eventRegistration),                             </span><br><span class="line">                |   <span class="built_in">mEventThread</span>(eventThread),   </span><br><span class="line">                <span class="comment">//	创建 BitTube，BitTube 构造函数中创建 socketpair                                 </span></span><br><span class="line">                |   <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize)&#123;&#125; </span><br><span class="line">                    <span class="comment">//	BitTube 构造函数                             </span></span><br><span class="line">					|	BitTube::<span class="built_in">BitTube</span>(<span class="type">size_t</span> bufsize)</span><br><span class="line">                        |	<span class="built_in">init</span>(bufsize, bufsize);</span><br><span class="line">                         	|	<span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">                            |	<span class="built_in">socketpair</span>(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets);	<span class="comment">// 创建 socketpair</span></span><br><span class="line">                            |	mReceiveFd.<span class="built_in">reset</span>(sockets[<span class="number">0</span>]); <span class="comment">// sockets[0] 赋值给 mReceiveFd ，未来会发送到 APP 进程端  </span></span><br><span class="line">                            |	mSendFd.<span class="built_in">reset</span>(sockets[<span class="number">1</span>]); </span><br><span class="line">            <span class="comment">//	EventThreadConnection 创建完成后，首次 sp 指针引用时调用 onFirstRef()</span></span><br><span class="line">            |	EventThreadConnection.<span class="built_in">onFirstRef</span>();</span><br><span class="line">                <span class="comment">//	注册 vsync 回调                                 </span></span><br><span class="line">                |	mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);                                 	</span><br><span class="line">                |--&gt;EventThread::<span class="built_in">registerDisplayEventConnection</span>(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection);</span><br><span class="line">                    |	<span class="comment">// 加入vector集合 mDisplayEventConnections</span></span><br><span class="line">                    | 	<span class="comment">// 这个集合 mDisplayEventConnection 会在 EventThread::threadMain 循环遍历                           </span></span><br><span class="line">                    |	mDisplayEventConnections.<span class="built_in">push_back</span>(connection);</span><br><span class="line">                    |	mCondition.<span class="built_in">notify_all</span>();  </span><br><span class="line"></span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line"><span class="comment">// App进程端获取到 IDisplayEventConnection 后，立即就调用了stealReceiveChannel 接口获取 socket fd：                                                  </span></span><br><span class="line">|--&gt;EventThreadConnection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel)</span><br><span class="line">    <span class="comment">//	把构造EventThreadConnection时，创建的 socketpair的fd 写到APP进程的 BitTube 中</span></span><br><span class="line">    |	outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">	|	outChannel-&gt;<span class="built_in">setSendFd</span>(base::<span class="built_in">unique_fd</span>(<span class="built_in">dup</span>(mChannel.<span class="built_in">getSendFd</span>())));                                                </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line"><span class="comment">// 附： Scheduler.Connection 结构体</span></span><br><span class="line">    <span class="keyword">struct</span> Connection &#123;</span><br><span class="line">        sp&lt;EventThreadConnection&gt; connection;</span><br><span class="line">        std::unique_ptr&lt;EventThread&gt; thread;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="五、ViewRootImpl-setView"><a href="#五、ViewRootImpl-setView" class="headerlink" title="五、ViewRootImpl.setView"></a>五、ViewRootImpl.setView</h3><ol>
<li><p>注册 vsync 回调 <strong>IDisplayEventConnection</strong></p>
</li>
<li><p>ViewRootImpl.setView 函数中调用 <strong>requestLayout 请求vsync流程</strong></p>
</li>
<li><p>ViewRootImpl.setView 函数中调用 WindowSession.</p>
<p>addToDisplayAsUser</p>
<p>​    **创建 ISurfaceComposerClient  **</p>
<ul>
<li>addToDisplayAsUser 还有个功能是 创建 InputChannel</li>
</ul>
</li>
</ol>
<p>​       	传入一个null的 inputChannel 对象到 addToDisplayAsUser，这个 inputChannel ，在wms端创建，并赋值到inputChannel ，实际就是 socketpair</p>
<ol>
<li>vsync回调回来后 调用ViewRootImpl.**relayoutWindow 创建 Surface **</li>
</ol>
<h4 id="ViewRootImpl-requestLayout-请求vsync流程"><a href="#ViewRootImpl-requestLayout-请求vsync流程" class="headerlink" title="ViewRootImpl.requestLayout 请求vsync流程"></a>ViewRootImpl.requestLayout 请求vsync流程</h4><p>衔接第三章的 setView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">//	frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></span><br><span class="line">root.setView(view, wparams, panelParentView, userId); <span class="comment">// 调用ViewRootImpl 的setview方法 关键方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line">ViewRootImpl.setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</span><br><span class="line"><span class="comment">//【一】、请求vsync：</span></span><br><span class="line">| requestLayout();  <span class="comment">//请求vsync ，vsync回调后，开启界面绘制流程======！！！！！！！！！！！！！**</span></span><br><span class="line">  | scheduleTraversals();</span><br><span class="line">    |	mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">    |--&gt;Choreographer.postCallback(<span class="type">int</span> callbackType, Runnable action, Object token)</span><br><span class="line">      	| postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">      	| postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">            <span class="comment">// 这里把 mTraversalRunnable 加入到 mCallbackQueues 数组</span></span><br><span class="line">            | mCallbackQueues[callbackType].**addCallbackLocked**(dueTime, action, token);</span><br><span class="line">      		| scheduleFrameLocked</span><br><span class="line">                | scheduleVsyncLocked();</span><br><span class="line">     		       |   mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">      			   |--&gt;DisplayEventReceiver.scheduleVsync();</span><br><span class="line">      					| nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">        					<span class="comment">// android_view_DisplayEventReceiver.cpp </span></span><br><span class="line">                            | nativeScheduleVsync()</span><br><span class="line">          						<span class="comment">// DisplayEventDispatcher.cpp</span></span><br><span class="line">                                | scheduleVsync()</span><br><span class="line">									<span class="comment">//IDisplayEventConnection mEventConnection=sf-&gt;createDisplayEventConnection</span></span><br><span class="line">          							| mReceiver.requestNextVsync();</span><br><span class="line">									<span class="comment">// 之后跨进程调用到 SurfaceFlinger 的 requestNextVsync 方法</span></span><br><span class="line">            						| DisplayEventReceiver.cpp--requestNextVsync(); </span><br><span class="line">              							| mEventConnection-&gt;requestNextVsync();</span><br><span class="line">              							| EventThreadConnection::requestNextVsync()</span><br><span class="line">              							| EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection)</span><br><span class="line">                							| mCondition.notify_all();<span class="comment">//唤醒 app EventThread 线程</span></span><br><span class="line">											<span class="comment">//sf 启动后 EventThread 线程会在 threadMain 循环</span></span><br><span class="line">                							| EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span><br><span class="line">                  								| mCondition.wait(lock);<span class="comment">// 从阻塞中唤醒</span></span><br><span class="line">                  								| mVSyncSource-&gt;setVSyncEnabled(<span class="literal">true</span>);</span><br><span class="line">                    								| DispSyncSource::setVSyncEnabled(bool enable)</span><br><span class="line">                    								| 又经过很多代码，最终：</span><br><span class="line">                    								| VSyncDispatchTimerQueue::setTimer(nsecs_t targetTime, nsecs_t <span class="comment">/*now*/</span>)</span><br><span class="line">                    								| Timer::alarmAt(std::function&lt;<span class="keyword">void</span>()&gt; const&amp; cb, nsecs_t time)</span><br><span class="line">                    								| 最终的最终调用“系统调用”，timerfd_settime 设置定时发送vsync</span><br><span class="line">                    								| timerfd_settime(mTimerFd, TFD_TIMER_ABSTIME, &amp;new_timer, &amp;old_timer)</span><br><span class="line"></span><br><span class="line">            | 之后就是异步代码了，之后很快就启动了vsync，之后vsync事件回调app进程的doFrame方法</span><br></pre></td></tr></table></figure>

<h4 id="IWindowSession-addToDisplayAsUser–-gt-WMS-addWindow"><a href="#IWindowSession-addToDisplayAsUser–-gt-WMS-addWindow" class="headerlink" title="IWindowSession.addToDisplayAsUser–&gt;WMS.addWindow"></a>IWindowSession.addToDisplayAsUser–&gt;WMS.addWindow</h4><ul>
<li>1、创建 WindowState</li>
<li>2、创建 InputChannel</li>
<li>3、创建同 SurfaceFlinger 的连接 ISurfaceComposerClient</li>
<li>4、更新焦点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">java复制代码root.setView(view, wparams, panelParentView, userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line">ViewRootImpl.setView(View view, WindowManager.LayoutParams attrs, View panelParentView);</span><br><span class="line">|	mView = view; <span class="comment">// 把 DecorView 存储到 mView </span></span><br><span class="line"><span class="comment">//	把 WindowManagerGlobal.addView 设置过 token 的wparams数据复制到 mWindowAttributes</span></span><br><span class="line">|	mWindowAttributes.copyFrom(attrs);</span><br><span class="line"><span class="comment">/*至此：</span></span><br><span class="line"><span class="comment">WindowToken.token 是 IBinder 类</span></span><br><span class="line"><span class="comment">ActivityRecord 继承 WindowToken</span></span><br><span class="line"><span class="comment">ActivityRecord 有个内部类 ActivityRecord.Token 继承 Binder</span></span><br><span class="line"><span class="comment">ActivityRecord.token 这个成员继承自 WindowToken，是内部类 ActivityRecord.Token 的实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line"><span class="comment">ViewRootImpl.mWindowAttributes.mToken = PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//	加入 PRIVATE_FLAG_USE_BLAST flag，这个flag在创建  SurfaceControl 时会用到 </span></span><br><span class="line">|	mWindowAttributes.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;</span><br><span class="line"><span class="comment">//	【一】、请求vsync</span></span><br><span class="line">|	requestLayout();</span><br><span class="line">|	<span class="type">InputChannel</span> <span class="variable">inputChannel</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 一个null的inputChannel，传递到WMS端赋值</span></span><br><span class="line"><span class="comment">//	【二】、创建 ISurfaceComposerClient</span></span><br><span class="line"><span class="comment">//  mWindow 参数为 [W extends IWindow.Stub]，作为参数传递给WMS，用于同 WMS 通信</span></span><br><span class="line">|	mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes..., userId,..., inputChannel, mTempInsets,...)</span><br><span class="line">    <span class="comment">//	参数 attrs.token = ActivityRecord.token</span></span><br><span class="line">	|--&gt;WindowManagerService.mService.addWindow(<span class="built_in">this</span>, window, attrs, viewVisibility, displayId, userId, equestedVisibility, outInputChannel, outInsetsState, outActiveControls);</span><br><span class="line">		<span class="comment">// 【1】、从 DisplayContent.mTokenMap 中检索token</span></span><br><span class="line">		<span class="comment">//  在 setNewTask 时，以ActivityRecord.token为键，已经把ActivityRecord加入了DisplayContent.mTokenMap</span></span><br><span class="line">		<span class="comment">//	所以能取到 token， 这个token不为 null</span></span><br><span class="line">		|   <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">		<span class="comment">//	如果 token为null，这里会走创建token流程：</span></span><br><span class="line">		<span class="comment">//	binder 为 ViewRootImpl.mWindowAttributes.mToken = ActivityRecord.token</span></span><br><span class="line">		|   <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();	</span><br><span class="line">		<span class="comment">//	WindowToken 构造函数中，传入的 DisplayContent 参数不为null时，加入 DisplayContent.mTokenMap</span></span><br><span class="line">		|   token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>.Builder(<span class="built_in">this</span>, binder, type).setDisplayContent(displayContent)....build();</span><br><span class="line">		|		<span class="comment">// WindowToken 构造函数：</span></span><br><span class="line">    	|		WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type...DisplayContent dc,...)</span><br><span class="line">        		|	token = _token;</span><br><span class="line">				|	<span class="keyword">if</span> (dc != <span class="literal">null</span>) dc.addWindowToken(token, <span class="built_in">this</span>); <span class="comment">// 加入 DisplayContent.mTokenMap</span></span><br><span class="line">		<span class="comment">// 【2】、创建 WindowState </span></span><br><span class="line">  		|   <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow, appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow);</span><br><span class="line">		<span class="comment">//  WindowState构造函数</span></span><br><span class="line">		|--&gt;WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,WindowState parentWindow...)</span><br><span class="line">        	|	mSession = s;</span><br><span class="line">			|	mClient = c;</span><br><span class="line">			|	mToken = token;</span><br><span class="line"><span class="comment">/*至此：</span></span><br><span class="line"><span class="comment">PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line"><span class="comment">参数attrs.token = ViewRootImpl.mWindowAttributes.mToken = PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken </span></span><br><span class="line"><span class="comment">WindowState.mToken = ActivityRecord */</span></span><br><span class="line">			|	mActivityRecord = mToken.asActivityRecord(); <span class="comment">// 把token转为 ActivityRecord</span></span><br><span class="line">			|	<span class="type">InputApplicationHandle</span> <span class="variable">tempIAHandle</span> <span class="operator">=</span> mActivityRecord.getInputApplicationHandle(<span class="literal">false</span>);</span><br><span class="line">            |--&gt;ActivityRecord.getInputApplicationHandle(<span class="type">boolean</span> update);</span><br><span class="line">            |	|	mInputApplicationHandle = <span class="keyword">new</span> <span class="title class_">InputApplicationHandle</span>(token, toString(),mInputDispatchingTimeoutMillis);</span><br><span class="line">			|		<span class="comment">//	InputApplicationHandle 构造函数：</span></span><br><span class="line">			|		|--&gt;InputApplicationHandle(<span class="meta">@NonNull</span> IBinder token, <span class="meta">@NonNull</span> String name,<span class="type">long</span> dispatchingTimeoutMillis);</span><br><span class="line">			|			|	<span class="built_in">this</span>.token = token;</span><br><span class="line">			|	|	<span class="keyword">return</span> mInputApplicationHandle;</span><br><span class="line">			|	<span class="comment">//创建 InputWindowHandleWrapper，包装为InputWindowHandle，用于输入输出，焦点更新等等，是wms，SurfaceFlinger，input 传递数据的对象</span></span><br><span class="line">			|	mInputWindowHandle = <span class="keyword">new</span> <span class="title class_">InputWindowHandleWrapper</span>(<span class="keyword">new</span> <span class="title class_">InputWindowHandle</span>(tempIAHandle, getDisplayId()))</span><br><span class="line">            |	<span class="comment">//	InputWindowHandle  构造函数： </span></span><br><span class="line">            |	|--&gt;InputWindowHandle(InputApplicationHandle inputApplicationHandle, <span class="type">int</span> displayId);</span><br><span class="line">            |    	|	<span class="built_in">this</span>.inputApplicationHandle = inputApplicationHandle;	</span><br><span class="line">            |	<span class="comment">//  InputWindowHandleWrapper 构造函数：  </span></span><br><span class="line">            |	|--&gt;InputWindowHandleWrapper(<span class="meta">@NonNull</span> InputWindowHandle handle);</span><br><span class="line">			|		<span class="comment">// WindowState.mInputWindowHandle.mHandle 为InputWindowHandle对象，这个对象会传到 SurfaceFlinger</span></span><br><span class="line">			|		<span class="comment">// WindowState.mInputWindowHandle.mHandle.inputApplicationHandle.token = ActivityRecord.token</span></span><br><span class="line">            |    	|	mHandle = handle;</span><br><span class="line">			|	mWinAnimator = <span class="keyword">new</span> <span class="title class_">WindowStateAnimator</span>(<span class="built_in">this</span>);<span class="comment">// 创建 WindowStateAnimator</span></span><br><span class="line">		<span class="comment">// 【3】、InputChannel 创建流程：</span></span><br><span class="line">		|   win.openInputChannel(outInputChannel);</span><br><span class="line">		|--&gt;WindowState.openInputChannel(InputChannel outInputChannel);</span><br><span class="line">			|	mInputChannel = mWmService.mInputManager.createInputChannel(name);</span><br><span class="line">				|--&gt;InputManagerService.createInputChannel(String name);</span><br><span class="line">                    |--&gt;NativeInputManagerService.createInputChannel(String name);</span><br><span class="line">                    	|--&gt;nativeCreateInputChannel(JNIEnv* env, jobject nativeImplObj, jstring nameObj);</span><br><span class="line">                    		|--&gt;NativeInputManager.createInputChannel(const std::string&amp; name);</span><br><span class="line">                    			|--&gt;InputDispatcher::createInputChannel(const std::string&amp; name);</span><br><span class="line">									|	std::unique_ptr&lt;InputChannel&gt; serverChannel;</span><br><span class="line">									|	std::unique_ptr&lt;InputChannel&gt; clientChannel;</span><br><span class="line">									<span class="comment">//	1、创建 socketpair	</span></span><br><span class="line">									|	InputChannel::openInputChannelPair(name, serverChannel, clientChannel);</span><br><span class="line">									|--&gt;InputChannel::openInputChannelPair(...InputChannel outServerChannel,outClientChannel)</span><br><span class="line">										|	<span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">										|	socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets);<span class="comment">// 创建 socketpair	</span></span><br><span class="line">                                        |	sp&lt;IBinder&gt; token = <span class="keyword">new</span> <span class="title class_">BBinder</span>(); <span class="comment">//  创建token</span></span><br><span class="line">										|	std::<span class="type">string</span> <span class="variable">serverChannelName</span> <span class="operator">=</span> name + <span class="string">&quot; (server)&quot;</span>;</span><br><span class="line">										|	outServerChannel = InputChannel::create(serverChannelName, sockets[<span class="number">0</span>], token);</span><br><span class="line">										|	std::<span class="type">string</span> <span class="variable">clientChannelName</span> <span class="operator">=</span> name + <span class="string">&quot; (client)&quot;</span>;</span><br><span class="line">										|	outClientChannel = InputChannel::create(clientChannelName, sockets[<span class="number">1</span>], token);</span><br><span class="line">									<span class="comment">//  获取InputChannel.mToken， 这个 token = new BBinder();</span></span><br><span class="line">                                    |	const sp&lt;IBinder&gt;&amp; token = serverChannel-&gt;getConnectionToken();</span><br><span class="line">									<span class="comment">//	2、使用 serverChannel 创建 connection</span></span><br><span class="line">									|	sp&lt;Connection&gt; connection = <span class="keyword">new</span> <span class="title class_">Connection</span>(std::move(serverChannel), <span class="literal">false</span> , ...);</span><br><span class="line">									<span class="comment">//	以token为键，把 connection 加入 mConnectionsByToken</span></span><br><span class="line">									<span class="comment">//	serverChannel 和 clientChannel 共用一个token，用来寻找彼此</span></span><br><span class="line">									<span class="comment">//	服务端加入mConnectionsByToken，一个返回到WMS，WMS再返回给App</span></span><br><span class="line">									|	mConnectionsByToken.emplace(token, connection);</span><br><span class="line">									<span class="comment">//	3、服务端的 socket fd 加入 epoll 监听</span></span><br><span class="line">									|	<span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> serverChannel-&gt;getFd();</span><br><span class="line">									|	mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, <span class="keyword">new</span> <span class="title class_">LooperEventCallback</span>(callback), nullptr);</span><br><span class="line">									|	mLooper-&gt;wake();</span><br><span class="line">									|	<span class="keyword">return</span> clientChannel; <span class="comment">// 返回客户端的 InputChannel </span></span><br><span class="line">			|	mInputChannelToken = mInputChannel.getToken(); <span class="comment">// 获取 native 创建的 token</span></span><br><span class="line">			<span class="comment">//	mInputWindowHandle.</span></span><br><span class="line">			|	mInputWindowHandle.setToken(mInputChannelToken);</span><br><span class="line">				<span class="comment">// WindowState.InputWindowHandleWrapper.InputWindowHandle.token = native层创建的 token</span></span><br><span class="line">				<span class="comment">//	InputWindowHandle.token 这个token 很重要，是 SurfaceFlinger，input 沟通用的令牌，比如焦点更新</span></span><br><span class="line">				<span class="comment">//	InputWindowHandle.InputApplicationHandle.token = ActivityRecord.token</span></span><br><span class="line">				<span class="comment">//	wms会透过 SurfaceTransition 把InputWindowHandle传递给 SurfaceFlinger 的 Layer.mDrawingState.inputInfo</span></span><br><span class="line">				<span class="comment">//	到这里 Inputms，wms，ams, SurfaceFlinger 就这么连接起来了。</span></span><br><span class="line">				|	mHandle.token = token;</span><br><span class="line">			<span class="comment">//	以 mInputChannelToken 为键，把 WindowState 存入WMS的 HashMap</span></span><br><span class="line">			|	mWmService.mInputToWindowMap.put(mInputChannelToken, <span class="built_in">this</span>);</span><br><span class="line">			<span class="comment">//	把 native 层创建的客户端InputChannel返回给 APP </span></span><br><span class="line">			|	mInputChannel.copyTo(outInputChannel);</span><br><span class="line">		|	res = ADD_OKAY;</span><br><span class="line">		|	<span class="comment">// mUseBLAST = (settings get global  use_blast_adapter_vr == 1)</span></span><br><span class="line">        |   <span class="comment">// global settings 中没有设置这个 use_blast_adapter_vr 值的话，默认值为 true</span></span><br><span class="line">		|	<span class="keyword">if</span> (mUseBLAST)	res |= WindowManagerGlobal.ADD_FLAG_USE_BLAST;</span><br><span class="line">		<span class="comment">// 【4】、 创建 SurfaceSession---&gt; 创建SurfaceFlinger的客户端 ISurfaceComposerClient</span></span><br><span class="line">  		|   win.attach();</span><br><span class="line">    		|	mSession.windowAddedLocked();</span><br><span class="line">				<span class="comment">//WindowState.mSession.mSurfaceSession.mNativeClient.mClient保存了用于SurfaceFlinger通信的 ISurfaceComposerClient</span></span><br><span class="line">      			|	Session.mSurfaceSession = <span class="keyword">new</span> <span class="title class_">SurfaceSession</span>();</span><br><span class="line">        			<span class="comment">//	SurfaceSession  内容很少，大概60行的代码。就是个 Native 的Java包装类</span></span><br><span class="line">					<span class="comment">//	SurfaceSession.mNativeClient 是个 SurfaceComposerClient 类</span></span><br><span class="line">					<span class="comment">//	SurfaceComposerClient.mClient 成员是个 ISurfaceComposerClient， 用于SurfaceFlinger通信</span></span><br><span class="line">        			|	SurfaceSession.mNativeClient = nativeCreate();</span><br><span class="line">          				<span class="comment">//	android_view_SurfaceSession.cpp </span></span><br><span class="line">          				|	android_view_SurfaceSession.nativeCreate</span><br><span class="line">            				|	SurfaceComposerClient* client = <span class="keyword">new</span> <span class="title class_">SurfaceComposerClient</span>();</span><br><span class="line">							<span class="comment">//  sp指针引用会调用 SurfaceComposerClient::onFirstRef() </span></span><br><span class="line">            				|	client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">              					|	SurfaceComposerClient::onFirstRef()</span><br><span class="line">                                    |	sp&lt;ISurfaceComposer&gt; <span class="title function_">sf</span><span class="params">(ComposerService::getComposerService()</span>);</span><br><span class="line">									<span class="comment">//	SurfaceComposerClient.mClient 是 ISurfaceComposerClient</span></span><br><span class="line">                					|	mClient = sf-&gt;createConnection();</span><br><span class="line">            				|	<span class="keyword">return</span> client;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//	以 IWindow 为键，把 WindowState 加入到 mWindowMap</span></span><br><span class="line">		| 	mWindowMap.put(client.asBinder(), win);</span><br><span class="line">		<span class="comment">//	把 WindowState 加入到  ActivityRecord.token ，成为其子节点</span></span><br><span class="line">		<span class="comment">//  ActivityRecord.mSurfaceControl  和  WindowState.mSurfaceControl 应该都会创建。</span></span><br><span class="line">		<span class="comment">//  这个流程会创建 WindowState.mSurfaceControl，继承的父类 WindowToken.mSurfaceControl</span></span><br><span class="line">		<span class="comment">//	<span class="doctag">TODO:</span> 这里的代码应该没这么简单，具体流程待研究。创建SurfaceControl，意味着创建Layer。这里应该是创建 ContainerLayer 和 EffectLayer 相关</span></span><br><span class="line">		| 	win.mToken.addWindow(win);</span><br><span class="line">		|--&gt;WindowToken.addWindow(<span class="keyword">final</span> WindowState win)</span><br><span class="line">            |	<span class="keyword">if</span> (mSurfaceControl == <span class="literal">null</span>)</span><br><span class="line">                |	createSurfaceControl(<span class="literal">true</span> <span class="comment">/* force */</span>);</span><br><span class="line">		<span class="comment">//	更新焦点</span></span><br><span class="line">		| 	updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,<span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);		</span><br></pre></td></tr></table></figure>

<h3 id="六、vsync-回调"><a href="#六、vsync-回调" class="headerlink" title="六、vsync 回调"></a>六、vsync 回调</h3><h4 id="1、SurfaceFlinger进程端：-vsync-事件分发"><a href="#1、SurfaceFlinger进程端：-vsync-事件分发" class="headerlink" title="1、SurfaceFlinger进程端： vsync 事件分发"></a>1、SurfaceFlinger进程端： vsync 事件分发</h4><p>这里简单写写吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码EventThread::<span class="built_in">onVSyncEvent</span>(<span class="type">nsecs_t</span> timestamp, VSyncSource::VSyncData vsyncData)</span><br><span class="line">|	mPendingEvents.<span class="built_in">push_back</span>(<span class="built_in">makeVSync</span>(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count,...);</span><br><span class="line">|	mCondition.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒 EventThread::threadMain 处wait代码</span></span><br><span class="line"></span><br><span class="line">EventThread::<span class="built_in">threadMain</span>(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span><br><span class="line">|	std::vector&lt;sp&lt;EventThreadConnection&gt;&gt; consumers;</span><br><span class="line">|	<span class="keyword">while</span> (mState != State::Quit) </span><br><span class="line">    |	std::optional&lt;DisplayEventReceiver::Event&gt; event;</span><br><span class="line">	|	<span class="comment">//...</span></span><br><span class="line">	|	<span class="keyword">if</span> (mState == State::Idle) &#123;<span class="comment">//	界面不动，进这里wait</span></span><br><span class="line">    	|	mCondition.<span class="built_in">wait</span>(lock);</span><br><span class="line">    |	<span class="comment">//...    </span></span><br><span class="line">	|	<span class="keyword">if</span> (!mPendingEvents.<span class="built_in">empty</span>()) <span class="comment">// 被唤醒后开始处理 mPendingEvents</span></span><br><span class="line">        |	event = mPendingEvents.<span class="built_in">front</span>();</span><br><span class="line">		|	mPendingEvents.<span class="built_in">pop_front</span>();</span><br><span class="line">	|	<span class="comment">//...</span></span><br><span class="line">    |	<span class="keyword">auto</span> it = mDisplayEventConnections.<span class="built_in">begin</span>();</span><br><span class="line">    |	<span class="comment">// mDisplayEventConnections是存储所有 EventThreadConnection 的 vector</span></span><br><span class="line">	|	<span class="keyword">while</span> (it != mDisplayEventConnections.<span class="built_in">end</span>())</span><br><span class="line">        |	<span class="comment">//  EventThreadConnection 为虚引用，这里 promote 提升为强引用</span></span><br><span class="line">        |	<span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> connection = it-&gt;<span class="built_in">promote</span>())</span><br><span class="line">            |	<span class="keyword">if</span> (event &amp;&amp; <span class="built_in">shouldConsumeEvent</span>(*event, connection))</span><br><span class="line">                |	<span class="comment">// 对于需要消费这个事件的EventThreadConnection存入入 vector 中</span></span><br><span class="line">            	|	consumers.<span class="built_in">push_back</span>(connection);</span><br><span class="line">			|	 ++it;</span><br><span class="line">		|	<span class="keyword">else</span></span><br><span class="line">            |	it = mDisplayEventConnections.<span class="built_in">erase</span>(it);<span class="comment">// 如果虚引用的对象销毁了，则从集合删除</span></span><br><span class="line">    |	<span class="keyword">if</span> (!consumers.<span class="built_in">empty</span>()) &#123;<span class="comment">//集合不为空，开始分发事件</span></span><br><span class="line">        |	<span class="built_in">dispatchEvent</span>(*event, consumers);</span><br><span class="line">        |--&gt;EventThread::<span class="built_in">dispatchEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event, <span class="type">const</span> DisplayEventConsumers&amp; consumers)</span><br><span class="line">            |	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; consumer : consumers)</span><br><span class="line">                |	DisplayEventReceiver::Event copy = event;</span><br><span class="line">                |	<span class="built_in">generateFrameTimeline</span>(copy.vsync.vsyncData,...);</span><br><span class="line">        		|	consumer-&gt;<span class="built_in">postEvent</span>(copy)</span><br><span class="line">                |--&gt;EventThreadConnection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span><br><span class="line">                    |	DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">        				|	gui::BitTube::<span class="built_in">sendObjects</span>(dataChannel, events, count);</span><br><span class="line">        					|	<span class="type">ssize_t</span> size = tube-&gt;<span class="built_in">write</span>(vaddr, count * objSize);</span><br><span class="line">        					|--&gt;BitTube::<span class="built_in">write</span>(<span class="type">void</span> <span class="type">const</span>* vaddr, <span class="type">size_t</span> size)</span><br><span class="line">                                |	<span class="comment">// mSendFd 是 socketpair 的fd</span></span><br><span class="line">                                |	len = ::<span class="built_in">send</span>(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br></pre></td></tr></table></figure>

<h4 id="2、APP进程端：接收vsync回调"><a href="#2、APP进程端：接收vsync回调" class="headerlink" title="2、APP进程端：接收vsync回调"></a>2、APP进程端：接收vsync回调</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java复制代码epoll回调</span><br><span class="line">| DisplayEventDispatcher::handleEvent</span><br><span class="line">  	| processPendingEvents 使用 socketpair 的BitTube 在d中取出 VSync 事件</span><br><span class="line">    	| DisplayEventReceiver::getEvents() </span><br><span class="line">    	| BitTube::recvObjects</span><br><span class="line">    	| linux 系统调用 ::recv</span><br><span class="line">  	| dispatchVsync</span><br><span class="line">    	<span class="comment">// env-&gt;CallVoidMethod 回到 JAVA 层的 DisplayEventReceiver.dispatchVsync() </span></span><br><span class="line">    	| DisplayEventReceiver.dispatchVsync()</span><br><span class="line">      	<span class="comment">// /frameworks/base/core/java/android/view/Choreographer.java</span></span><br><span class="line">      	| FrameDisplayEventReceiver.onVsync</span><br><span class="line">        		| <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);<span class="comment">//传入的回调是this，即FrameDisplayEventReceiver.run() ;</span></span><br><span class="line">        		| mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        		| 之后进入FrameDisplayEventReceiver.run()方法调用 doFrame </span><br><span class="line">          				| <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame, DisplayEventReceiver.VsyncEventData vsyncEventData)</span></span><br><span class="line">            					| doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos, frameIntervalNanos)</span><br><span class="line">            					| doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">            					| doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">            					| doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">              							| ViewRootImpl.mTraversalRunnable.run()</span><br><span class="line">                							| doTraversal();</span><br><span class="line">                  								| performTraversals();</span><br><span class="line">                    								|	relayoutWindow <span class="comment">//创建 Surface 流程</span></span><br><span class="line">            					| doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos, frameIntervalNanos);</span><br></pre></td></tr></table></figure>

<h4 id="3、ViewRootImpl-relayoutWindow-创建-Surface"><a href="#3、ViewRootImpl-relayoutWindow-创建-Surface" class="headerlink" title="3、ViewRootImpl.relayoutWindow 创建 Surface"></a>3、ViewRootImpl.relayoutWindow 创建 Surface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ViewRootImpl.mTraversalRunnable.run()</span><br><span class="line">| doTraversal();</span><br><span class="line">  | performTraversals(); </span><br><span class="line">	<span class="comment">// 如果是ViewRootImpl刚创建，还没执行过performTraversals，或者窗口需要resize，或者显示属性变化,需要执行 relayoutWindow</span></span><br><span class="line">    | relayoutWindow   <span class="comment">//创建surface流程 + sf 创建layer流程</span></span><br><span class="line"></span><br><span class="line">ViewRootImpl.relayoutWindow(WindowManager.LayoutParams params, <span class="type">int</span> viewVisibility,<span class="type">boolean</span> insetsPending);</span><br><span class="line">|	mWindowSession.relayout(mWindow, params,requestedWidth, requestedHeight,...mSurfaceControl, mTempInsets, mTempControls, mRelayoutBundle);</span><br><span class="line">	|	<span class="comment">// 【接口层：ViewRootImpl.mSurfaceControl 构造流程】</span></span><br><span class="line">	|	android.view.IWindowSession.Stub.Proxy.relayout(...android.view.SurfaceControl outSurfaceControl,...)</span><br><span class="line">        |	<span class="comment">// 调用 system_server 进程 Session.relayout  【转到： &quot;system_server 进程 Session.relayout&quot;】</span></span><br><span class="line">        |	<span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">			|	<span class="comment">//若干步骤太多了不写了QTNND...</span></span><br><span class="line">			|	IPCThreadState::transact(...);</span><br><span class="line">				|	IPCThreadState::waitForResponse(...);<span class="comment">//binder通信</span></span><br><span class="line">		|	<span class="comment">// 从 system_server 进程返回后，从 _reply 读取返回的 SurfaceControl 到 outSurfaceControl，即 ViewRootImpl.mSurfaceControl</span></span><br><span class="line">		|	outSurfaceControl.readFromParcel(_reply); </span><br><span class="line"></span><br><span class="line"><span class="comment">// system_server 进程 Session.relayout</span></span><br><span class="line">|--&gt;Session.relayout(IWindow window, WindowManager.LayoutParams attrs,...SurfaceControl outSurfaceControl,...)</span><br><span class="line">    <span class="comment">//进入system_server进程的 WMS</span></span><br><span class="line">  	|	mService.relayoutWindow(<span class="built_in">this</span>, window, attrs,requestedWidth, requestedHeight,... outSurfaceControl,...)</span><br><span class="line">    |--&gt;WindowManagerService.relayoutWindow(Session session, IWindow client, LayoutParams attrs,...SurfaceControl outSurfaceControl,...)</span><br><span class="line">    	|	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	|	<span class="comment">//从 WindowManagerService.mWindowMap 获取之前addToDisplayAsUser流程存储的 WindowState</span></span><br><span class="line">    	|	<span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> windowForClientLocked(session, client, <span class="literal">false</span>);</span><br><span class="line">		|	<span class="comment">// WindowState.mWinAnimator: WindowState构造函数中创建的</span></span><br><span class="line">		|	<span class="type">WindowStateAnimator</span> <span class="variable">winAnimator</span> <span class="operator">=</span> win.mWinAnimator;</span><br><span class="line">		|	result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</span><br><span class="line">    	|--&gt;WindowManagerService.createSurfaceControl(SurfaceControl outSurfaceControl, <span class="type">int</span> result,WindowState win, WindowStateAnimator winAnimator)</span><br><span class="line">            |	<span class="type">WindowSurfaceController</span> <span class="variable">surfaceController</span> <span class="operator">=</span> winAnimator.createSurfaceLocked();</span><br><span class="line">			|--&gt;WindowStateAnimator.createSurfaceLocked()</span><br><span class="line">                |	<span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">w</span> <span class="operator">=</span> mWin; <span class="comment">// WindowState构造函数中会把WindowState自身传入WindowStateAnimator.mWin</span></span><br><span class="line">				|	<span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">attrs</span> <span class="operator">=</span> w.mAttrs;</span><br><span class="line">				|	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">format</span> <span class="operator">=</span> isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;	</span><br><span class="line">				|	<span class="comment">// 1、创建 WindowSurfaceController，赋值到 WindowStateAnimator.mSurfaceController</span></span><br><span class="line">        |		|	mSurfaceController = <span class="keyword">new</span> <span class="title class_">WindowSurfaceController</span>(attrs.getTitle().toString(), format, flags, <span class="built_in">this</span>, attrs.type);</span><br><span class="line">				<span class="comment">//	WindowSurfaceController 构造函数</span></span><br><span class="line">				|--&gt;WindowSurfaceController(String name, <span class="type">int</span> format, <span class="type">int</span> flags, WindowStateAnimator animator,<span class="type">int</span> windowType)	</span><br><span class="line">                    |	mAnimator = animator; title = name; mService = animator.mService;</span><br><span class="line">					|	<span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> animator.mWin;</span><br><span class="line">					|	mWindowType = windowType;</span><br><span class="line">					|	mWindowSession = win.mSession;</span><br><span class="line">					|	<span class="comment">// 注意这里的 parent = WindowState.mSurfaceControl</span></span><br><span class="line">					|	SurfaceControl.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> win.makeSurface().setParent(win.getSurfaceControl()).setName(name).setFormat(format)</span><br><span class="line">                        .setFlags(flags).setMetadata(METADATA_WINDOW_TYPE, windowType).setMetadata(...mUid).setMetadata(...mPid)...;</span><br><span class="line">					|	<span class="comment">//mService.mUseBLAST = (settings get global  use_blast_adapter_vr == 1)</span></span><br><span class="line">                        <span class="comment">//global  settings 中没有设置这个 use_blast_adapter_vr 值的话，默认值为 true</span></span><br><span class="line">                        <span class="comment">//PRIVATE_FLAG_USE_BLAST 这个 flag 是在 ViewRootImpl.setview 设置的</span></span><br><span class="line">                        <span class="comment">//综上，useBLAST = true</span></span><br><span class="line">					|	<span class="type">boolean</span> <span class="variable">useBLAST</span> <span class="operator">=</span> mService.mUseBLAST &amp;&amp; ((win.getAttrs().privateFlags&amp; LayoutParams.PRIVATE_FLAG_USE_BLAST) != <span class="number">0</span>);</span><br><span class="line">					|	<span class="keyword">if</span> (useBLAST) b.setBLASTLayer();</span><br><span class="line">						|	<span class="comment">//	FX_SURFACE_BLAST = 0x00040000; 对应于  ISurfaceComposerClient.eFXSurfaceBufferState = 0x00040000</span></span><br><span class="line">						|--&gt;SurfaceControl.Builder.setFlags(FX_SURFACE_BLAST, FX_SURFACE_MASK); </span><br><span class="line">					|	<span class="comment">// 2、创建Java层的 SurfaceControl ，赋值到 WindowStateAnimator.mSurfaceController.mSurfaceControl</span></span><br><span class="line">        |  			|	mSurfaceControl = b.build();</span><br><span class="line">        |  		|		|	<span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,mLocalOwnerView, mCallsite);</span><br><span class="line">						|--&gt;SurfaceControl(SurfaceSession session, String name, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> format, <span class="type">int</span> flags, SurfaceControl parent...)</span><br><span class="line">					|		|	mName = name;mWidth = w;mHeight = h;mLocalOwnerView = localOwnerView;</span><br><span class="line">							|	<span class="comment">// 3、创建native层的 SurfaceControl，赋值到 WindowStateAnimator.mSurfaceController.mSurfaceControl.mNativeObject</span></span><br><span class="line">        |    				|   mNativeObject = nativeCreate(session, name, w, h, format, flags,... metaParcel);</span><br><span class="line">        |      	|	|		|   <span class="comment">// /frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line">        |                	|--&gt;nativeCreate(..., jobject sessionObj,jstring nameStr, jint w, jint h, jint format, jint flags, ...)</span><br><span class="line">                |				|   sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">								|	client = android_view_SurfaceSession_getClient(env, sessionObj);</span><br><span class="line">								|	sp&lt;SurfaceControl&gt; surface;<span class="comment">// surface 作为引用参数传入</span></span><br><span class="line">								|	client-&gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;surface,flags, parentHandle...);</span><br><span class="line">								|	<span class="comment">// /frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line">                				|   SurfaceComposerClient.createSurfaceChecked(const String8&amp; name,...,sp&lt;SurfaceControl&gt;* outSurface,...)</span><br><span class="line">                |                   |	sp&lt;IBinder&gt; handle;</span><br><span class="line">		|					|		|	sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">				|	|				|	<span class="type">int32_t</span> <span class="variable">id</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        |          					|	mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,... &amp;handle, &amp;gbp, &amp;id, &amp;transformHint);   </span><br><span class="line">                    					|	<span class="comment">//surfaceflinger/Client.cpp</span></span><br><span class="line">                |    		|			|	mFlinger-&gt;createLayer</span><br><span class="line">        |           |  						|	<span class="comment">// 进入SurfaceFlinger进程，创建layer流程 【转“SurfaceFlinger创建layer”章节】</span></span><br><span class="line">                      						|	SurfaceFlinger::createLayer(name, <span class="built_in">this</span>, w, h, format,... handle, gbp, parentHandle, outLayerId,...)  </span><br><span class="line">        |       |  					|	*outSurface = <span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(<span class="built_in">this</span>, handle, gbp, id, w, h, format,...flags);</span><br><span class="line">					|		|		|	<span class="comment">// 4、使用SurfaceFlinger创建的 handle，GraphicBufferProducer,layerId 构造native层的 SurfaceControl</span></span><br><span class="line">		|		|					|	<span class="comment">// GraphicBufferProducer 图形buffer的生产者，handle用于layer销毁时SurfaceFlinger端回调，和layer检索</span></span><br><span class="line">									|	SurfaceControl(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">                            |                          const sp&lt;IGraphicBufferProducer&gt;&amp; gbp, int32_t layerId,</span><br><span class="line">        |       |                                      uint32_t w, uint32_t h, PixelFormat format, uint32_t transform,uint32_t flags)</span><br><span class="line">                    |       |           |	: mClient(client), mHandle(handle), mGraphicBufferProducer(gbp), mTransformHint(transform) </span><br><span class="line">        |       |           |           |	  mWidth(w),mHeight(h),mFormat(format),mCreateFlags(flags) &#123;&#125;</span><br><span class="line">							|	|	<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());<span class="comment">// 返回native创建的 SurfaceControl </span></span><br><span class="line">							|   <span class="comment">// 如果native有 mBbqChild ，返回 mBbqChild.mHandle，否则直接返回native SurfaceControl.mHandle</span></span><br><span class="line">        |    	|	|	|	|	mNativeHandle = nativeGetHandle(mNativeObject);/</span><br><span class="line">				|	w.mInputWindowHandle.forceChange();	</span><br><span class="line">				|	<span class="keyword">return</span> mSurfaceController;</span><br><span class="line">      	|	|	surfaceController.getSurfaceControl(outSurfaceControl);<span class="comment">//====================!!!</span></span><br><span class="line">			|--&gt;WindowSurfaceController.getSurfaceControl(SurfaceControl outSurfaceControl)	</span><br><span class="line">                |	<span class="comment">// 传入的是 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl</span></span><br><span class="line">                |	<span class="comment">// 5、把AMS创建的 SurfaceControl 数据，复制给需要返回 App进程的对象 outSurfaceControl</span></span><br><span class="line">                |	outSurfaceControl.copyFrom(mSurfaceControl, <span class="string">&quot;WindowSurfaceController.getSurfaceControl&quot;</span>);</span><br><span class="line">				|--&gt;SurfaceControl.copyFrom(<span class="meta">@NonNull</span> SurfaceControl other, String callsite)</span><br><span class="line">                    |	<span class="comment">// 几个重要成员复制</span></span><br><span class="line">                    |	mName = other.mName; mLocalOwnerView = other.mLocalOwnerView;</span><br><span class="line">					|	mWidth = other.mWidth; mHeight = other.mHeight;</span><br><span class="line">					|	<span class="comment">// native层SurfaceControl复制， 以及 mNativeObject、mNativeHandle 复制</span></span><br><span class="line">					|	assignNativeObject(nativeCopyFromSurfaceControl(other.mNativeObject), callsite);</span><br><span class="line">						|--&gt;nativeCopyFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) </span><br><span class="line">                            |	sp&lt;SurfaceControl&gt; <span class="title function_">surface</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>);</span><br><span class="line">							|	<span class="comment">// native 层创建新的 SurfaceControl</span></span><br><span class="line">                                <span class="comment">// 把 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl.mNativeObject 数据复制到新的 SurfaceControl 对象</span></span><br><span class="line">							|	sp&lt;SurfaceControl&gt; newSurface = <span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(surface);</span><br><span class="line">								|--&gt;SurfaceControl::SurfaceControl(const sp&lt;SurfaceControl&gt;&amp; other)</span><br><span class="line">                                    |	mClient = other-&gt;mClient; mHandle = other-&gt;mHandle;</span><br><span class="line">									|	mGraphicBufferProducer = other-&gt;mGraphicBufferProducer;	</span><br><span class="line">									|	mTransformHint = other-&gt;mTransformHint;	 mLayerId = other-&gt;mLayerId;</span><br><span class="line">									|	mWidth = other-&gt;mWidth; mHeight = other-&gt;mHeight;</span><br><span class="line">									|	mFormat = other-&gt;mFormat; mCreateFlags = other-&gt;mCreateFlags;</span><br><span class="line">							|	<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(newSurface.get()); <span class="comment">// 返回新的SurfaceControl地址到Java层的 outSurfaceControl</span></span><br><span class="line">						|--&gt;SurfaceControl.assignNativeObject(<span class="type">long</span> nativeObject, String callsite)</span><br><span class="line">                            |	mNativeObject = nativeObject; <span class="comment">// 把native地址赋值到 SurfaceControl.mNativeObject</span></span><br><span class="line">							|	<span class="comment">//这里不展开了，没有mBbqChild，还是使用 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl.mNativeObject.mHandle</span></span><br><span class="line">							|	mNativeHandle = nativeGetHandle(nativeObject);</span><br><span class="line">			|	<span class="keyword">return</span> result; <span class="comment">// END  WindowManagerService.createSurfaceControl</span></span><br><span class="line">			|	</span><br><span class="line">		|	mWindowPlacerLocked.performSurfacePlacement(<span class="literal">true</span> <span class="comment">/* force */</span>); <span class="comment">// 执行 Surface 的摆放工作</span></span><br><span class="line">		|	<span class="comment">// 如果焦点变化了更新焦点</span></span><br><span class="line">		|	updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, <span class="literal">true</span> <span class="comment">/*updateInputWindows*/</span>)	</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 回到 APP进程端：ViewRootImpl.relayoutWindow            </span></span><br><span class="line"><span class="comment">//(1) 非 useBLAST 的情况：(Android12以后代码不会走这里)</span></span><br><span class="line">|	<span class="comment">//6、创建 Surface          </span></span><br><span class="line">|	mSurface.copyFrom(mSurfaceControl); </span><br><span class="line">|--&gt;Surface.copyFrom(SurfaceControl other)</span><br><span class="line">    |	<span class="type">long</span> <span class="variable">surfaceControlPtr</span> <span class="operator">=</span> other.mNativeObject;</span><br><span class="line">	|	<span class="comment">// 获取 native 层的 Surface 地址</span></span><br><span class="line">    |	<span class="type">long</span> <span class="variable">newNativeObject</span> <span class="operator">=</span> nativeGetFromSurfaceControl(mNativeObject, surfaceControlPtr);</span><br><span class="line">	|--&gt;nativeGetFromSurfaceControl(JNIEnv* env, jclass clazz,jlong nativeObject, jlong surfaceControlNativeObj)</span><br><span class="line">        |	sp&lt;SurfaceControl&gt; <span class="title function_">ctrl</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>);	</span><br><span class="line">		|	sp&lt;Surface&gt; <span class="title function_">surface</span><span class="params">(ctrl-&gt;getSurface()</span>);<span class="comment">// 创建native Surface</span></span><br><span class="line">		|--&gt;SurfaceControl.getSurface()</span><br><span class="line">			|	<span class="keyword">return</span> generateSurfaceLocked(); </span><br><span class="line">			|--&gt;SurfaceControl.generateSurfaceLocked()</span><br><span class="line">				|	<span class="comment">// Android 11版本以前，这个函数内部直接创建 Surface 返回：new Surface(mGraphicBufferProducer, false);</span></span><br><span class="line">                |	<span class="comment">// Android 12 这里使用 BBQ ，还从这里连接 SurfaceFlinger 创建layer。ViewRootImpl不走这里，目前这里的流程不知道给谁用的</span></span><br><span class="line">				|	mBbqChild = mClient-&gt;createSurface(String8(<span class="string">&quot;bbq-wrapper&quot;</span>), <span class="number">0</span>, <span class="number">0</span>, mFormat,flags, mHandle, &#123;&#125;, &amp;ignore);</span><br><span class="line">                |	<span class="comment">// 以下流程展开参考【创建Surface：useBLAST】章节   </span></span><br><span class="line">				|	mBbq = sp&lt;BLASTBufferQueue&gt;::make(<span class="string">&quot;bbq-adapter&quot;</span>, mBbqChild, mWidth, mHeight, mFormat);</span><br><span class="line">				|	mSurfaceData = mBbq-&gt;getSurface(<span class="literal">true</span>); <span class="comment">// 返回 new BBQSurface</span></span><br><span class="line">				|	<span class="keyword">return</span> mSurfaceData;</span><br><span class="line">		|	surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">		|	<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());<span class="comment">//返回 native 的 Surface 地址</span></span><br><span class="line">    |	updateNativeObject(newNativeObject)</span><br><span class="line">	|--&gt;updateNativeObject(<span class="type">long</span> newNativeObject)	</span><br><span class="line">		|	setNativeObjectLocked(newNativeObject);</span><br><span class="line">		|--&gt;setNativeObjectLocked(<span class="type">long</span> ptr)</span><br><span class="line">			|	mNativeObject = ptr;<span class="comment">// 把新的native的Surface地址存储到 Surface.mNativeObject</span></span><br><span class="line"><span class="comment">//(2)	useBLAST 的情况：(Android13 代码走这里，在Android12的基础上稍微变化了一下)</span></span><br><span class="line">|	updateBlastSurfaceIfNeeded(); </span><br><span class="line">	|	mBlastBufferQueue = <span class="keyword">new</span> <span class="title class_">BLASTBufferQueue</span>(mTag, mSurfaceControl, mSurfaceSize.x, mSurfaceSize.y, mWindowAttributes.format);</span><br><span class="line">	|	mBlastBufferQueue.setTransactionHangCallback(sTransactionHangCallback);</span><br><span class="line">	|	<span class="type">Surface</span> <span class="variable">blastSurface</span> <span class="operator">=</span> mBlastBufferQueue.createSurface();</span><br><span class="line">	|	mSurface.transferFrom(blastSurface);</span><br></pre></td></tr></table></figure>

<h5 id="创建Surface：useBLAST-BBQ"><a href="#创建Surface：useBLAST-BBQ" class="headerlink" title="创建Surface：useBLAST (BBQ)"></a>创建Surface：useBLAST (BBQ)</h5><p>接续上一章节“useBLAST 的情况”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="comment">// useBLAST 函数：</span></span><br><span class="line">	<span class="comment">/*	</span></span><br><span class="line"><span class="comment">	mForceDisableBLAST 使用默认值false</span></span><br><span class="line"><span class="comment">	mUseBLASTAdapter：如果 WMS.addWindow 返回值带有flag WindowManagerGlobal.ADD_FLAG_USE_BLAST ，则为 true。[见：IWindowSession.addToDisplayAsUser]</span></span><br><span class="line"><span class="comment">	Android 12 后有这个flag	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useBLAST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mUseBLASTAdapter &amp;&amp; !mForceDisableBLAST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 useBLAST() 返回 true，则调用 updateBlastSurfaceIfNeeded(); </span></span><br><span class="line"><span class="comment">// 接续上一章节“useBLAST 的情况”</span></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line">updateBlastSurfaceIfNeeded(); </span><br><span class="line">|	<span class="comment">// 【1】创建 BLASTBufferQueue</span></span><br><span class="line">|	<span class="comment">// 参数：mSurfaceControl 是在 ViewRootImpl.mWindowSession.relayout 的接口层调用 mSurfaceControl.readFromParcel 填充的数据</span></span><br><span class="line">|	mBlastBufferQueue = <span class="keyword">new</span> <span class="title class_">BLASTBufferQueue</span>(mTag, mSurfaceControl, mSurfaceSize.x, mSurfaceSize.y, mWindowAttributes.format);</span><br><span class="line">|	<span class="comment">// Java层 BLASTBufferQueue 构造</span></span><br><span class="line">|--&gt;BLASTBufferQueue (String name, SurfaceControl sc, <span class="type">int</span> width, <span class="type">int</span> height, <span class="meta">@PixelFormat</span>.Format <span class="type">int</span> format)</span><br><span class="line">    |	mNativeObject = nativeCreate(name, <span class="literal">true</span>);<span class="comment">// 创建 native 层 BLASTBufferQueue，返回的地址存储到 mNativeObject</span></span><br><span class="line">	|	<span class="comment">//【2】创建 native BLASTBufferQueue</span></span><br><span class="line">    |	<span class="comment">//frameworks/base/core/jni/android_graphics_BLASTBufferQueue.cpp </span></span><br><span class="line">	|--&gt;nativeCreate(JNIEnv* env, jclass clazz, jstring jName, jboolean updateDestinationFrame)</span><br><span class="line">        |	sp&lt;BLASTBufferQueue&gt; queue = <span class="keyword">new</span> <span class="title class_">BLASTBufferQueue</span>(name.c_str(), updateDestinationFrame);</span><br><span class="line">		|	<span class="comment">// native 层 BLASTBufferQueue 构造，Android 13的构造函数相比 Android 12 少了一部分内容，那部分内容放到了 BLASTBufferQueue::update</span></span><br><span class="line">		|--&gt;BLASTBufferQueue::BLASTBufferQueue(const std::string&amp; name, bool updateDestinationFrame)</span><br><span class="line">            |	: mSurfaceControl(nullptr),mSize(<span class="number">1</span>, <span class="number">1</span>),mRequestedSize(mSize),mFormat(PIXEL_FORMAT_RGBA_8888),</span><br><span class="line">			|		mTransactionReadyCallback(nullptr),mSyncTransaction(nullptr),mUpdateDestinationFrame(updateDestinationFrame)&#123;</span><br><span class="line">            |	<span class="comment">// 【3】创建 BufferQueueCore、BBQBufferQueueProducer、BufferQueueConsumer     </span></span><br><span class="line">            |	createBufferQueue(&amp;mProducer, &amp;mConsumer); <span class="comment">//[转 BLASTBufferQueue::createBufferQueue  章节]</span></span><br><span class="line">                <span class="comment">// BufferQueueProducer.mDequeueTimeout = int64.max</span></span><br><span class="line">            |	mProducer-&gt;setDequeueTimeout(std::numeric_limits&lt;int64_t&gt;::max());    </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                BufferQueueCore:</span></span><br><span class="line"><span class="comment">    				std::set&lt;int&gt; mFreeSlots;  	  // 初始添加 2个int</span></span><br><span class="line"><span class="comment">    				std::list&lt;int&gt; mUnusedSlots;  // 初始添加 64 int值</span></span><br><span class="line"><span class="comment">    				</span></span><br><span class="line"><span class="comment">                setMaxDequeuedBufferCount(2)的结果：</span></span><br><span class="line"><span class="comment">                	1)从 BufferQueueCore.mUnusedSlots 中取出 1 个并删除，然后插入 BufferQueueCore.mFreeSlots;</span></span><br><span class="line"><span class="comment">                	   mUnusedSlots 长度变为 63，mFreeSlots长度变为 3</span></span><br><span class="line"><span class="comment">                       (mFreeSlots，是dequeuebuffer数据来源，其长度代表最大可dequeue的数量，当前为3，表示三级缓存)</span></span><br><span class="line"><span class="comment">                	2)BufferQueueCore.mMaxDequeuedBufferCount = 2; BufferQueueCore.mMaxAcquiredBufferCount = 1;</span></span><br><span class="line"><span class="comment">                	3)调整完毕mMaxDequeuedBufferCount后,如果 dequeueBuffer 处于等待buffer状态，会被唤醒拿取buffer</span></span><br><span class="line"><span class="comment">                函数调用完成后，如果调用 getMaxBufferCountLocked，在同步模式下：</span></span><br><span class="line"><span class="comment">                	BufferQueueCore.getMaxBufferCountLocked() = mMaxDequeuedBufferCount + mMaxAcquiredBufferCount = 3 (三级缓存)</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            |	mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);  </span><br><span class="line">            |	<span class="comment">// 【4】创建 BLASTBufferItemConsumer 并设置生产者消费者监听   </span></span><br><span class="line">            |	mBufferItemConsumer = <span class="keyword">new</span> <span class="title class_">BLASTBufferItemConsumer</span>(mConsumer,USAGE_HW_COMPOSER|USAGE_HW_TEXTURE, <span class="number">1</span>, <span class="literal">false</span>, <span class="built_in">this</span>);</span><br><span class="line">            |--&gt;BLASTBufferItemConsumer(IGBConsumer&amp; consumer,uint64_t consumerUsage,<span class="type">int</span> bufferCount, bool controlledByApp, wp&lt;BLASTBufferQueue&gt; bbq)</span><br><span class="line">                	: BufferItemConsumer(consumer, consumerUsage, bufferCount, controlledByApp),<span class="comment">//构造父类BufferItemConsumer</span></span><br><span class="line">                	  mBLASTBufferQueue(std::move(bbq)),<span class="comment">/* 存储 BBQ*/</span>mCurrentlyConnected(<span class="literal">false</span>),mPreviouslyConnected(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">                |--&gt;:BufferItemConsumer(sp&lt;IGraphicBufferConsumer&gt;&amp; consumer,uint64_t consumerUsage,<span class="type">int</span> bufferCount, bool controlledByApp)</span><br><span class="line">                    	: ConsumerBase(consumer, controlledByApp)&#123;</span><br><span class="line">                            <span class="comment">// BufferQueueCore.mConsumerUsageBits = GraphicBuffer::USAGE_HW_COMPOSER |GraphicBuffer::USAGE_HW_TEXTURE;</span></span><br><span class="line">                            mConsumer-&gt;setConsumerUsageBits(consumerUsage);</span><br><span class="line">                            <span class="comment">// 默认 BufferQueueCore-&gt;mMaxAcquiredBufferCount = 1，bufferCount=1, 所以这里无用功</span></span><br><span class="line">                            mConsumer-&gt;setMaxAcquiredBufferCount(bufferCount);</span><br><span class="line">                        &#125;</span><br><span class="line">                	|--&gt;ConsumerBase.ConsumerBase(const sp&lt;IGraphicBufferConsumer&gt;&amp; bufferQueue, bool controlledByApp)</span><br><span class="line">                        	: mAbandoned(<span class="literal">false</span>),mConsumer(bufferQueue),mPrevFinalReleaseFence(Fence::NO_FENCE)&#123;</span><br><span class="line">                                <span class="comment">// 创建未命令的名字，这里的名字会被之后 BLASTBufferQueue 构造函数的代码覆盖</span></span><br><span class="line">                                mName = String8::format(<span class="string">&quot;unnamed-%d-%d&quot;</span>, getpid(), createProcessUniqueId());</span><br><span class="line">                                wp&lt;ConsumerListener&gt; listener = static_cast&lt;ConsumerListener*&gt;(<span class="built_in">this</span>);</span><br><span class="line">                                sp&lt;IConsumerListener&gt; proxy = <span class="keyword">new</span> <span class="title class_">BufferQueue</span>::ProxyConsumerListener(listener);</span><br><span class="line">                                <span class="comment">//【5】调用消费者的 connect 函数，这里的代码执行结果：</span></span><br><span class="line">                                <span class="comment">// 1、赋值 BufferQueueCore 的消费者监听: BufferQueueCore.mConsumerListener = ConsumerBase</span></span><br><span class="line">                                <span class="comment">// 2、BufferQueueCore.mConsumerControlledByApp = false</span></span><br><span class="line">                                <span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> mConsumer-&gt;consumerConnect(proxy, controlledByApp);</span><br><span class="line">                                mConsumer-&gt;setConsumerName(mName);<span class="comment">// 名字传给 BufferQueueConsumer、BufferQueueCore</span></span><br><span class="line">                            &#125;</span><br><span class="line">            <span class="comment">//	consumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot;    </span></span><br><span class="line">            <span class="comment">//BufferQueueCore.mConsumerName = BufferQueueConsumer.mConsumerName = BufferItemConsumer父类ConsumerBase.mName = consumerName;    </span></span><br><span class="line">            |	mBufferItemConsumer-&gt;setName(String8(consumerName.c_str()));    </span><br><span class="line">                <span class="comment">//	ConsumerBase.mFrameAvailableListener =  BLASTBufferQueue</span></span><br><span class="line">            |	mBufferItemConsumer-&gt;setFrameAvailableListener(<span class="built_in">this</span>); <span class="comment">// queuebuffer后，通知消费者的监听</span></span><br><span class="line">                <span class="comment">//	BufferItemConsumer.mBufferFreedListener =  BLASTBufferQueue</span></span><br><span class="line">            |	mBufferItemConsumer-&gt;setBufferFreedListener(<span class="built_in">this</span>);    <span class="comment">// 通知生产者的的监听</span></span><br><span class="line">            |	ComposerService::getComposerService()-&gt;getMaxAcquiredBufferCount(&amp;mMaxAcquiredBuffers);<span class="comment">// 从是sf获取MaxAcquiredBufferCount</span></span><br><span class="line">                <span class="comment">// 赋值 sf 的MaxAcquiredBufferCount</span></span><br><span class="line">            |	mBufferItemConsumer-&gt;setMaxAcquiredBufferCount(mMaxAcquiredBuffers);</span><br><span class="line">            |	mCurrentMaxAcquiredBufferCount = mMaxAcquiredBuffers;    </span><br><span class="line">            |&#125;	</span><br><span class="line">		|	<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(queue.get());<span class="comment">// 返回 native BLASTBufferQueue 地址</span></span><br><span class="line">	|	nativeUpdate(mNativeObject, sc.mNativeObject, width, height, format);</span><br><span class="line">	|--&gt;nativeUpdate(JNIEnv* env, jclass clazz, jlong ptr, jlong surfaceControl, jlong width,jlong height, jint format)</span><br><span class="line">        |	sp&lt;BLASTBufferQueue&gt; queue = reinterpret_cast&lt;BLASTBufferQueue*&gt;(ptr);</span><br><span class="line">		|	queue-&gt;update(reinterpret_cast&lt;SurfaceControl*&gt;(surfaceControl), width, height, format);</span><br><span class="line">		|--&gt;BLASTBufferQueue.update(const sp&lt;SurfaceControl&gt;&amp; surface, uint32_t width, uint32_t height,int32_t format)</span><br><span class="line">            |	<span class="comment">// 这些值，在 BufferQueueProducer::connect 函数中，会再返回 Surface</span></span><br><span class="line">            |	mFormat = format;										BufferQueueCore-&gt;mDefaultBufferFormat = mFormat;</span><br><span class="line">			|	mSurfaceControl = surface;</span><br><span class="line">			|	mTransformHint = mSurfaceControl-&gt;getTransformHint();	BufferQueueCore-&gt;mTransformHint = mTransformHint;</span><br><span class="line">			|	<span class="comment">// 这里的宽高，来源是 ViewRootImpl.relayout 后通过 WindowLayout::computeSurfaceSize 计算的宽高</span></span><br><span class="line">			|	mRequestedSize = newSize(width, height);</span><br><span class="line">			|	mSize = mRequestedSize;	</span><br><span class="line">			|	BufferQueueCore-&gt;mDefaultWidth = mRequestedSize.width;	BufferQueueCore-&gt;mDefaultHeight = mRequestedSize.height;</span><br><span class="line">			|	<span class="comment">//之后再把 宽高 通过事务传递到sf</span></span><br><span class="line">            |	SurfaceComposerClient::Transaction.setApplyToken(mApplyToken).apply(<span class="literal">false</span>, <span class="literal">true</span>);    </span><br><span class="line">|	mBlastBufferQueue.setTransactionHangCallback(sTransactionHangCallback);<span class="comment">// GPU hang 回调	</span></span><br><span class="line">|	<span class="type">Surface</span> <span class="variable">blastSurface</span> <span class="operator">=</span> mBlastBufferQueue.createSurface();</span><br><span class="line">|	|	BlastBufferQueue.nativeGetSurface(mNativeObject, <span class="literal">false</span> <span class="comment">/* includeSurfaceControlHandle */</span>);</span><br><span class="line">	|	<span class="comment">//frameworks/base/core/jni/android_graphics_BLASTBufferQueue.cpp</span></span><br><span class="line">	|--&gt;nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr, jboolean includeSurfaceControlHandle)</span><br><span class="line">        |	sp&lt;BLASTBufferQueue&gt; queue = reinterpret_cast&lt;BLASTBufferQueue*&gt;(ptr); <span class="comment">// 地址转为 native BLASTBufferQueue 对象</span></span><br><span class="line">		|	<span class="keyword">return</span> android_view_Surface_createFromSurface(env,queue-&gt;getSurface(includeSurfaceControlHandle));</span><br><span class="line">			|	<span class="comment">//	【6】创建 BBQSurface</span></span><br><span class="line">			|	<span class="comment">//frameworks/native/libs/gui/BLASTBufferQueue.cpp</span></span><br><span class="line">            |--&gt;BLASTBufferQueue.getSurface(bool includeSurfaceControlHandle) </span><br><span class="line">                |	sp&lt;IBinder&gt; scHandle = nullptr;</span><br><span class="line">				|	<span class="keyword">if</span> (includeSurfaceControlHandle &amp;&amp; mSurfaceControl)<span class="comment">// includeSurfaceControlHandle = false</span></span><br><span class="line">                    |	scHandle = mSurfaceControl-&gt;getHandle();</span><br><span class="line">                |	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BBQSurface</span>(mProducer, <span class="literal">true</span>, scHandle, <span class="built_in">this</span>);</span><br><span class="line">				|	<span class="comment">//创建 BBQSurface，比较重要的是重载了 allocateBuffers </span></span><br><span class="line">				|--&gt;BBQSurface(const sp&lt;IGraphicBufferProducer&gt;&amp; igbp, bool controlledByApp,</span><br><span class="line">               			const sp&lt;IBinder&gt;&amp; scHandle, const sp&lt;BLASTBufferQueue&gt;&amp; bbq)</span><br><span class="line">          				: Surface(igbp, controlledByApp, scHandle), mBbq(bbq) &#123;&#125;	</span><br><span class="line">					|	<span class="comment">//Surface 的构造函数内容太多了不写了</span></span><br><span class="line">                    |--&gt;Surface::Surface(const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp,...)</span><br><span class="line">                        : mGraphicBufferProducer(bufferProducer) <span class="comment">// 最关键的就是传入了 生产者</span></span><br><span class="line">                            |	mProducerControlledByApp = controlledByApp; <span class="comment">// true</span></span><br><span class="line">			|	<span class="comment">// 【7】创建Java层的 Surface，并把 BBQSurface 的地址存入Surface.mNativeObject,(这一步就是创建个java的Surface，临时存储native的BBQSurface)</span></span><br><span class="line">			|	<span class="comment">//frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line">            |--&gt;android_view_Surface_createFromSurface(JNIEnv* env, const sp&lt;Surface&gt;&amp; surface)</span><br><span class="line">                |	<span class="comment">// 在 JNI new Java 层的 Surface 	</span></span><br><span class="line">                |	<span class="type">jobject</span> <span class="variable">surfaceObj</span> <span class="operator">=</span> env-&gt;NewObject(gSurfaceClassInfo.clazz, gSurfaceClassInfo.ctor, (jlong)surface.get());</span><br><span class="line">				|	<span class="comment">// 调用Java层，参数为 long 的构造函数：</span></span><br><span class="line">				|--&gt;Surface(<span class="type">long</span> nativeObject)</span><br><span class="line">                    |	setNativeObjectLocked(nativeObject);</span><br><span class="line">						|	mNativeObject = nativeObject;</span><br><span class="line">				|	<span class="keyword">return</span> surfaceObj;	<span class="comment">// 返回java层的对象</span></span><br><span class="line">|	<span class="comment">//【8】把返回的BBQSurface地址 Surface.mNativeObject 转存入 ViewRootImpl.mSurface.mNativeObject</span></span><br><span class="line">|	mSurface.transferFrom(blastSurface); <span class="comment">// mSurface.mNativeObject = blastSurface.mNativeObject</span></span><br></pre></td></tr></table></figure>

<h4 id="4、BLASTBufferQueue-createBufferQueue-生产者-消费者-BufferQueueCore"><a href="#4、BLASTBufferQueue-createBufferQueue-生产者-消费者-BufferQueueCore" class="headerlink" title="4、BLASTBufferQueue::createBufferQueue  生产者-消费者-BufferQueueCore"></a>4、BLASTBufferQueue::createBufferQueue  生产者-消费者-BufferQueueCore</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//	frameworks/native/libs/gui/BLASTBufferQueue.cpp</span></span><br><span class="line">BLASTBufferQueue::<span class="built_in">createBufferQueue</span>(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer)</span><br><span class="line">|	<span class="comment">// 1、创建 BufferQueueCore</span></span><br><span class="line">|	<span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore())</span></span>;</span><br><span class="line">	|	<span class="comment">// BufferQueueCore 构造函数：</span></span><br><span class="line">	|--&gt;BufferQueueCore::<span class="built_in">BufferQueueCore</span>()</span><br><span class="line">          : <span class="built_in">mMutex</span>(), <span class="built_in">mConsumerControlledByApp</span>(<span class="literal">false</span>), </span><br><span class="line">		    <span class="built_in">mSlots</span>(),	    <span class="comment">// BufferSlot[64] mSlots; 创建 Slots</span></span><br><span class="line">		    <span class="built_in">mQueue</span>(),	    <span class="comment">// Vector&lt;BufferItem&gt;  mQueue;   queuebuffer 后存储到这个变量里</span></span><br><span class="line">			<span class="comment">// FREE 状态，没有GraphicBuffer的放到mFreeSlots里</span></span><br><span class="line">			<span class="built_in">mFreeSlots</span>(),   <span class="comment">// std::set&lt;int&gt; mFreeSlots;  初始化为 2个int, mUnusedSlots 每减一个，对应的 mFreeSlots 加入一个</span></span><br><span class="line">			<span class="comment">// FREE 状态，但是有buffer attached</span></span><br><span class="line">			<span class="built_in">mFreeBuffers</span>(), <span class="comment">// std::list&lt;int&gt; mFreeBuffers;</span></span><br><span class="line">			<span class="comment">// 未被使用的 Slot ，起始长度为64，64 + 2个mFreeSlots的元素 其实代表了 Slot 的总数</span></span><br><span class="line">			<span class="comment">// 依据 adjustAvailableSlotsLocked函数，可以得出 mUnusedSlots 每减一个，对应的 mFreeSlots 加入一个(加入的就是mUnusedSlots减去的那个)</span></span><br><span class="line">			<span class="built_in">mUnusedSlots</span>(), <span class="comment">// std::list&lt;int&gt; mUnusedSlots;</span></span><br><span class="line">			<span class="comment">// 当应用申请走一个Slot时，该Slot状态会切换到DEQUEUED状态，该Slot会被放入mActiveBuffers队列</span></span><br><span class="line">			<span class="built_in">mActiveBuffers</span>(),<span class="comment">//std::set&lt;int&gt; mActiveBuffers;</span></span><br><span class="line">			<span class="comment">// mutable std::condition_variable mDequeueCondition;</span></span><br><span class="line">			<span class="built_in">mDequeueCondition</span>(), <span class="comment">// dequeueBuffer 没slot时，调用 mDequeueCondition.wait 等待</span></span><br><span class="line">			<span class="built_in">mDequeueBufferCannotBlock</span>(<span class="literal">false</span>), <span class="comment">// bool mDequeueBufferCannotBlock = false; dequeueBuffer 时 阻塞</span></span><br><span class="line">			<span class="built_in">mQueueBufferCanDrop</span>(<span class="literal">false</span>), <span class="built_in">mLegacyBufferDrop</span>(<span class="literal">true</span>), <span class="built_in">mDefaultBufferFormat</span>(PIXEL_FORMAT_RGBA_8888),<span class="comment">/*默认使用的格式*/</span></span><br><span class="line">			<span class="built_in">mDefaultWidth</span>(<span class="number">1</span>), <span class="built_in">mDefaultHeight</span>(<span class="number">1</span>), <span class="built_in">mDefaultBufferDataSpace</span>(HAL_DATASPACE_UNKNOWN),</span><br><span class="line">			<span class="built_in">mMaxBufferCount</span>(BufferQueueDefs::NUM_BUFFER_SLOTS), <span class="comment">// NUM_BUFFER_SLOTS = 64; 这个值64，设置这么大其实用多少</span></span><br><span class="line">			<span class="built_in">mMaxAcquiredBufferCount</span>(<span class="number">1</span>),  <span class="built_in">mMaxDequeuedBufferCount</span>(<span class="number">1</span>),...</span><br><span class="line">            <span class="built_in">mTransformHint</span>(<span class="number">0</span>)<span class="comment">/*优化屏幕旋转*/</span>,<span class="built_in">mIsAllocating</span>(<span class="literal">false</span>)<span class="comment">/*是否正在分配内存*/</span>,<span class="built_in">mIsAllocatingCondition</span>(),</span><br><span class="line">			<span class="built_in">mAllowAllocation</span>(<span class="literal">true</span>),  <span class="comment">/*允许分配新buffer， BufferQueueProducer::connect时，设置为true*/</span></span><br><span class="line">            <span class="built_in">mBufferAge</span>(<span class="number">0</span>),<span class="comment">/*当前的 BufferSlot 自从上次 queueBuffer 后，又queue了多少个BufferSlot*/</span></span><br><span class="line">            <span class="built_in">mAsyncMode</span>(<span class="literal">false</span>),<span class="comment">/*同步模式*/</span> <span class="built_in">mSharedBufferMode</span>(<span class="literal">false</span>),...</span><br><span class="line">            <span class="built_in">mUniqueId</span>(<span class="built_in">getUniqueId</span>()),<span class="built_in">mAutoPrerotation</span>(<span class="literal">false</span>)<span class="comment">/*自动预旋转*/</span>,<span class="built_in">mTransformHintInUse</span>(<span class="number">0</span>)<span class="comment">/*自动预旋转的方向，90度时宽高互换*/</span>&#123;</span><br><span class="line">                <span class="type">int</span> numStartingBuffers = <span class="built_in">getMaxBufferCountLocked</span>(); <span class="comment">//numStartingBuffers  = 2</span></span><br><span class="line">                <span class="comment">// 构造函数中 set&lt;int&gt; mFreeSlots 插入两个int</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">                    mFreeSlots.<span class="built_in">insert</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 构造函数中 std::list&lt;int&gt; mUnusedSlots 插入 64 个int</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; <span class="comment">// NUM_BUFFER_SLOTS = 64</span></span><br><span class="line">                    mUnusedSlots.<span class="built_in">push_front</span>(s); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">|	<span class="comment">// 2、创建生产者</span></span><br><span class="line">|	<span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BBQBufferQueueProducer(core, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">	|	<span class="comment">// BBQBufferQueueProducer 没多少内容，就是重载了 connect、setMaxDequeuedBufferCount、query</span></span><br><span class="line">	|--&gt;<span class="built_in">BBQBufferQueueProducer</span>(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core, wp&lt;BLASTBufferQueue&gt; bbq)</span><br><span class="line">        <span class="comment">// mConsumerIsSurfaceFlinger 入队后，GraphicBuffer 在BufferItem 中的指针是否应该被清除</span></span><br><span class="line">        : <span class="built_in">BufferQueueProducer</span>(core, <span class="literal">false</span> <span class="comment">/* consumerIsSurfaceFlinger*/</span>),<span class="built_in">mBLASTBufferQueue</span>(std::<span class="built_in">move</span>(bbq)) &#123;&#125;	</span><br><span class="line">		|--&gt;BufferQueueProducer::<span class="built_in">BufferQueueProducer</span>(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core, <span class="type">bool</span> consumerIsSurfaceFlinger) </span><br><span class="line">            : <span class="built_in">mCore</span>(core), <span class="built_in">mSlots</span>(core-&gt;mSlots), <span class="built_in">mConsumerName</span>(),<span class="built_in">mStickyTransform</span>(<span class="number">0</span>),</span><br><span class="line">			  <span class="built_in">mConsumerIsSurfaceFlinger</span>(consumerIsSurfaceFlinger<span class="comment">/*false*/</span>),<span class="built_in">mLastQueueBufferFence</span>(Fence::NO_FENCE),<span class="built_in">mLastQueuedTransform</span>(<span class="number">0</span>),</span><br><span class="line">			  <span class="built_in">mCallbackMutex</span>(),<span class="built_in">mNextCallbackTicket</span>(<span class="number">0</span>),<span class="built_in">mCurrentCallbackTicket</span>(<span class="number">0</span>),<span class="built_in">mCallbackCondition</span>(),</span><br><span class="line">			  <span class="built_in">mDequeueTimeout</span>(<span class="number">-1</span>),<span class="built_in">mDequeueWaitingForAllocation</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">|	<span class="comment">// 3、创建消费者</span></span><br><span class="line">|	<span class="function">sp&lt;BufferQueueConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">	|--&gt;BufferQueueConsumer::<span class="built_in">BufferQueueConsumer</span>(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core)</span><br><span class="line">        : <span class="built_in">mCore</span>(core), <span class="built_in">mSlots</span>(core-&gt;mSlots), <span class="built_in">mConsumerName</span>() &#123;&#125;</span><br><span class="line">|	<span class="comment">// 4、生产消费者赋值到 BLASTBufferQueue成员变量 mProducer 和 mConsumer</span></span><br><span class="line">|	*outProducer = producer;</span><br><span class="line">|	*outConsumer = consumer;</span><br></pre></td></tr></table></figure>

<h3 id="七、SurfaceFlinger创建layer"><a href="#七、SurfaceFlinger创建layer" class="headerlink" title="七、SurfaceFlinger创建layer"></a>七、SurfaceFlinger创建layer</h3><h4 id="Android-11-以及以前的版本简述："><a href="#Android-11-以及以前的版本简述：" class="headerlink" title="Android 11 以及以前的版本简述："></a>Android 11 以及以前的版本简述：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码SurfaceFlinger::createLayer</span><br><span class="line"></span><br><span class="line">| SurfaceFlinger::<span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, metadata, format, handle, gbp, &amp;layer);</span><br><span class="line">  | sp&lt;BufferQueueLayer&gt; layer;</span><br><span class="line">  | layer = <span class="built_in">getFactory</span>().<span class="built_in">createBufferQueueLayer</span>(args);</span><br><span class="line">    | BufferQueueLayer 对象创建完成后，在首次sp指针引用时调用 BufferQueueLayer::<span class="built_in">onFirstRef</span>()</span><br><span class="line">      | onFirstRef函数中会创建 生产者，消费者，生产者会传入到客户端</span><br><span class="line">      | sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">      | sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">      | 设置生产者的三级缓冲</span><br><span class="line">      | mProducer-&gt;<span class="built_in">setMaxDequeuedBufferCount</span>(<span class="number">2</span>);</span><br><span class="line">  | 赋值client端的参数 </span><br><span class="line">  | sp&lt;IBinder&gt; *handle = layer-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">  | sp&lt;IGraphicBufferProducer&gt; *gbp = layer-&gt;<span class="built_in">getProducer</span>(); <span class="comment">//获取生产者</span></span><br><span class="line">  | sp&lt;Layer&gt; *outLayer = layer; <span class="comment">//这个layer保存在 SurfaceComposerClient对象中，wms并未赋值，wms对应的是SurfaceControl</span></span><br><span class="line">| addClientLayer</span><br><span class="line">  | 调用 addClientLayer，把layer按照Z轴顺序存入 layersSortedByZ</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-createLayer-Android-13"><a href="#SurfaceFlinger-createLayer-Android-13" class="headerlink" title="SurfaceFlinger::createLayer  Android 13"></a>SurfaceFlinger::createLayer  Android 13</h4><ul>
<li>Android 12 以后因为BBQ都在APP进程，所以 createLayer 大大简化了，内容不多。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码【接续“ViewRootImpl.relayoutWindow 创建 Surface” 章节中的 “SurfaceComposerClient.createSurfaceChecked”】</span><br><span class="line">SurfaceFlinger::<span class="built_in">createLayer</span>(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* outHandle,sp&lt;IBinder&gt;&amp; parentHandle, <span class="type">int32_t</span>* outLayerId, sp&lt;Layer&gt;&amp; parentLayer, <span class="type">uint32_t</span>* outTransformHint)</span><br><span class="line">|	sp&lt;Layer&gt; layer;    </span><br><span class="line">|	<span class="keyword">switch</span> (args.flags &amp; ISurfaceComposerClient::eFXSurfaceMask)&#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         eFXSurfaceBufferState = 0x00040000</span></span><br><span class="line"><span class="comment">         WindowManagerService.createSurfaceControl 流程中 </span></span><br><span class="line"><span class="comment">         	if (useBLAST) b.setBLASTLayer(); 这个函数设置的flag FX_SURFACE_BLAST = 0x00040000;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState:</span><br><span class="line">        	result = <span class="built_in">createBufferStateLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        	|	<span class="built_in">createBufferStateLayer</span>(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* handle, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">                |	*outLayer = <span class="built_in">getFactory</span>().<span class="built_in">createBufferStateLayer</span>(args); <span class="comment">// 创建的 layer </span></span><br><span class="line">        			|--&gt;BufferStateLayer::<span class="built_in">BufferStateLayer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">                        |	: <span class="built_in">BufferLayer</span>(args), <span class="built_in">mHwcSlotGenerator</span>(<span class="keyword">new</span> <span class="built_in">HwcSlotGenerator</span>())</span><br><span class="line">                        |   mDrawingState.dataspace = ui::Dataspace::V0_SRGB;</span><br><span class="line">        					|--&gt;BufferLayer::<span class="built_in">BufferLayer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">                                	: <span class="built_in">Layer</span>(args), <span class="built_in">mTextureName</span>(args.textureName),</span><br><span class="line">        						|	mCompositionState&#123;mFlinger-&gt;<span class="built_in">getCompositionEngine</span>().<span class="built_in">createLayerFECompositionState</span>()&#125; </span><br><span class="line">        						|--&gt;Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">                                    	: <span class="built_in">sequence</span>(args.sequence.<span class="built_in">value_or</span>(sSequence++)),</span><br><span class="line">        								  <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">        								  <span class="built_in">mName</span>(base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;%s#%d&quot;</span>, args.name.<span class="built_in">c_str</span>(), sequence)),</span><br><span class="line">        								  <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">        								  <span class="built_in">mWindowType</span>(<span class="built_in">static_cast</span>&lt;WindowInfo::Type&gt;(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>))),</span><br><span class="line">        								  <span class="built_in">mLayerCreationFlags</span>(args.flags)</span><br><span class="line">                                         <span class="comment">// 然后是一堆 mDrawingState 成员属性的初始化     	</span></span><br><span class="line">        		|	*handle = (*outLayer)-&gt;<span class="built_in">getHandle</span>(); <span class="comment">// 把创建的 handle 传入外部，最终会返回到APP进程端，用于创建 SurfaceControl</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceEffect: <span class="comment">// 这里是 Task、DefaultTaskDisplayArea</span></span><br><span class="line">        	result = <span class="built_in">createEffectLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceContainer:<span class="comment">//这里是 ActivityRecord、WindowState 等等</span></span><br><span class="line">        	result = <span class="built_in">createContainerLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        	result = BAD_VALUE;</span><br><span class="line">        <span class="keyword">break</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">|		</span><br><span class="line">|	result = <span class="built_in">addClientLayer</span>(args.client, *outHandle, layer, parent, addToRoot, outTransformHint);</span><br><span class="line">|--&gt;SurfaceFlinger.<span class="built_in">addClientLayer</span>(<span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> sp&lt;IBinder&gt;&amp; handle,<span class="type">const</span> sp&lt;Layer&gt;&amp; layer, <span class="type">const</span> wp&lt;Layer&gt;&amp; parent,...)</span><br><span class="line">    |	<span class="comment">//	std::vector&lt;LayerCreatedState&gt; mCreatedLayers  加入到数组</span></span><br><span class="line">    |	mCreatedLayers.<span class="built_in">emplace_back</span>(layer, parent, addToRoot);</span><br><span class="line">	|	<span class="comment">//	缓存到 Client.mLayers 集合中 //frameworks/native/services/surfaceflinger/Client.h</span></span><br><span class="line">	|	client-&gt;<span class="built_in">attachLayer</span>(handle, layer);</span><br><span class="line">    |	<span class="comment">// 请求 sf-vsync,这里的代码和 SurfaceFlinger::commitCreatedLayers() 以及 mCreatedLayers 是相关联的，具体见 SurfaceFlinger 章节</span></span><br><span class="line">	|	<span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">|	*outLayerId = layer-&gt;sequence;</span><br><span class="line">|	<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
   
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>