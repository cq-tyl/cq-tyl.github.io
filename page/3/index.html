<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>TYL</title>
    
    
        <meta name="keywords" content="TYL" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="cq_tyl的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="TYL">
<meta property="og:url" content="https://cq_tyl.gitee.io/page/3/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="cq_tyl的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            启动流程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/">2.自定义系统服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/3.%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8ALauncher%E7%9B%B8%E5%85%B3/">3.环境安装及启动相关</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/3.1Launcher%E7%BC%96%E8%AF%91%E4%B9%8BAidegen/"></a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/WatchDog%20%E8%AF%A6%E8%A7%A3/">WatchDog 详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/">0.jetpack合集</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.1.leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">3.1.leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.0.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96&ANR/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/">0.app性能优化集合</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/">MVC、MVP、MVVM架构</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IDE工具相关
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用命令汇总</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            命令相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/ADB_Monkey%E6%B5%8B%E8%AF%95/">ADB_Monkey测试</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            我的简历
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/Framework%E7%AE%80%E5%8E%86/">Framework简历</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">完整项目经历</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main">
        <article id="post-其他笔记/IDE工具相关/ASFP (android studio for platform)使用" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/IDE%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/">IDE工具相关</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> Android Studio for Platform 这个是最新的google开发的阅读aosp源码的工具，特别适合做原生系统开发。具体官方介绍如下地址：<br>参考链接：<a target="_blank" rel="noopener" href="http://developer.android.google.cn/studio/platform">http://developer.android.google.cn/studio/platform</a></p>
<h3 id="1、android-studio-for-platform工具介绍"><a href="#1、android-studio-for-platform工具介绍" class="headerlink" title="1、android studio for platform工具介绍"></a>1、android studio for platform工具介绍</h3><p><img src="/../../../images/6661ce941ec8464c8f324f785d8b16c3.png" alt="在这里插入图片描述"><br>可以直接点击下载（提示目前只有ubuntu可以哈，语言切换到英文，中文发现无法下载)</p>
<p>看看相关的官方介绍：</p>
<p>Android Studio for Platform (ASfP) is the version of the Android Studio IDE for Android Open Source Project (AOSP) platform developers who build with the Soong build system. ASfP includes the following features:</p>
<pre><code>language
Multi-language Support
Edit C++, Kotlin, and Java programming languages in the same IDE.
settings
Project Setup Wizard
Configure your lunch target and platform modules.
</code></pre>
<p>官方的介绍就以上一小段文字，总结如下：<br>ASfP是专门用于开发aosp的ide工具，有着 Soong build system.，主要有以下几个特点<br>语言支持部分：<br>同时支持：C++, Kotlin, and Java 同时使用在ide中编程<br>设置部分：<br>可以配置你的编译target和具体的模块</p>
<h3 id="2、android-studio-for-platform痛点解决"><a href="#2、android-studio-for-platform痛点解决" class="headerlink" title="2、android studio for platform痛点解决"></a>2、android studio for platform痛点解决</h3><p>这里最吸引我们的还是他居然支持多语言，c++，java，kotlin同时都支持。<br>以前我们开发aosp时候，其实java部分使用android studio的体验还是相当好，但是android studio没办法支持c++等native代码的跳转和代码提示，所以不得不使用vscode工具，这个vscode工具相关看c++等代码也是比较方便，基本上的代码也是可以跳转的，但是毕竟有时候需要两个工具相互切快捷键等还是有一点点不方便，虽然不太影响。</p>
<p>所以开发aosp之前的选择就是：<br>java相关代码使用android studio<br>c++相关代码使用vscode</p>
<p>目前ASfP工具出现真的是我们framework开发者的一个巨大福音，解决了android studio无法跳转c++代码的这个巨大痛点。</p>
<h3 id="3、android-studio-for-platform使用体验"><a href="#3、android-studio-for-platform使用体验" class="headerlink" title="3、android studio for platform使用体验"></a>3、android studio for platform使用体验</h3><p>官方使用介绍：</p>
<pre><code>Get started with ASfP

    If you haven&#39;t already installed repo, follow the instructions at Installing Repo.
    If you haven&#39;t already initialized and synced your Repo checkout, follow the instructions at Initializing a Repo client.
    Download ASfP.
    Install ASfP: sudo dpkg -i /path/to/asfp-2023.1.1.19-linux.deb.
    Open ASfP from the command line: /opt/android-studio-for-platform/bin/studio.sh.
    Import your project by pointing to your repo checkout directory, specifying a lunch target, and selecting which modules you want to build.
    Click Finish and your project will begin syncing.
    Request to join our external group for user support.
</code></pre>
<p>这里我们就直接自己转化把<br>1、下载好工具，安装好即可以（限制在ubuntu）<br><img src="/../../../images/b20e0607028843e986a19dcae913e668.png" alt="在这里插入图片描述"><br><img src="/../../../images/7fa95deacf934894baf36342705913fd.png" alt="在这里插入图片描述"><br>可以直接点击安装的</p>
<p>2、启动工具<br>在terminator下面输入如下命令：<br>&#x2F;opt&#x2F;android-studio-for-platform&#x2F;bin&#x2F;studio.sh<br>就会启动工具</p>
<p>3、导入需要模块<br><img src="/../../../images/8539626963a04c35bea4bcb88c11561b.png" alt="导入AOSP选项"><br>这里导入了Launcher和framework<br><img src="/../../../images/5cf8b014d4a04e3fa98f5a8605a97db3.png" alt="在这里插入图片描述"><br><img src="/../../../images/6eae4bc3e37a4d40a56e2b68fe5d7d5b.png" alt="在这里插入图片描述"></p>
<p>同步完成就一切都好了即可以查看相关代码和跳转。</p>
<h3 id="ps使用的注意点："><a href="#ps使用的注意点：" class="headerlink" title="ps使用的注意点："></a>ps使用的注意点：</h3><p>1、跳转framework的类时候会跳到对应jar包的class文件，不是java文件，解决如下<br><img src="/../../../images/cf63f456bca348f291be71bfa3c7466b.png" alt="在这里插入图片描述"></p>
<p>2、KeyMap如果习惯eclipse的可以切换</p>
<p>3、如果导入c++相关开发建议以下3个文件夹：<br>frameworks<br>system<br>packages</p>
<p>导入越多整体就慢</p>
<h3 id="总结体验："><a href="#总结体验：" class="headerlink" title="总结体验："></a>总结体验：</h3><p>整体体验和以前android studio没有大的差别<br>1、不过说实话单独java部分的代码开发的话，体验还不如以前的android studio轻量，反而依赖的东西太多，对于跳转等，查找代码还没有以前方便，针对java部分的话，这个建议可以先观望等更多版本更新稳定</p>
<p>2、c++部分的native代码，来说简直就利器，非常好用，跳转准确，非常值的推荐</p>
<p>google官方教学视频教程地址：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UV411P7nf/?vd_source=a8c604ee3ce4999324264828f8fd99d8">https://www.bilibili.com/video/BV1UV411P7nf/?vd_source&#x3D;a8c604ee3ce4999324264828f8fd99d8</a></p>
<p><strong>生成桌面图标</strong></p>
<img src="../../../images/e5702cee47164cd5818f3f5e164c5005.png" alt="生成桌面图标" style="zoom:67%;" />

<p><strong>修改配置文件</strong></p>
<img src="../../../images/8daa5801b6d8469b9281a30b655801ff.png" alt="修改配置文件后进行sync" style="zoom:67%;" />
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/启动流程/5.Android13启动流程之SystemServer内部逻辑分析" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <blockquote>
<p>主要分析一下SystemServer启动过后的内部逻辑，特别说明一下<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AMS&spm=1001.2101.3001.7020">AMS</a>,WMS都属于SystemServer进程，属于同一个进程</p>
</blockquote>
<h2 id="一-SystemServer进程启动流程"><a href="#一-SystemServer进程启动流程" class="headerlink" title="一. SystemServer进程启动流程"></a>一. SystemServer进程启动流程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128782204">基于Android13的系统启动流程分析（五）之Zygote和SystemServer启动流程</a>这篇文章有详细讲解，这里再简单的过一下如何启动的SystemServer</p>
<p>在zygote进程创建过后，会调用<code>forkSystemServer()</code>来孵化出SystemServer进程，当前该进程创建成功后会反射调用到SystemServer.java的main函数，从而启动完成SystemServer</p>
<h2 id="二-SystemServer主函数分析"><a href="#二-SystemServer主函数分析" class="headerlink" title="二. SystemServer主函数分析"></a>二. SystemServer主函数分析</h2><p>main函数会被ZygoteInit的子方法<code>handleSystemServerProcess</code>反射调用到<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</p>
<pre><code>public static void main(String[] args) &#123;
        new SystemServer().run();
&#125;
</code></pre>
<p>继续看看run方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">      		...</span><br><span class="line">           <span class="comment">// 设置系统语言，国家，时区相关</span></span><br><span class="line">           <span class="keyword">if</span> (!SystemProperties.<span class="built_in">get</span>(<span class="string">&quot;persist.sys.language&quot;</span>).<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">               <span class="keyword">final</span> String languageTag = Locale.<span class="built_in">getDefault</span>().<span class="built_in">toLanguageTag</span>();</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.locale&quot;</span>, languageTag);</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.language&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.country&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.localevar&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">		...</span><br><span class="line">           <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">           <span class="comment">// 设置main线程的优先级，有此可得主线程就是：SystemServer进程下的其中线程</span></span><br><span class="line">           android.os.Process.<span class="built_in">setThreadPriority</span>(</span><br><span class="line">                   android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">           android.os.Process.<span class="built_in">setCanSelfBackground</span>(<span class="literal">false</span>);</span><br><span class="line">           <span class="comment">// 开始主线程的运行，和Looper.loop配对使用</span></span><br><span class="line">           <span class="comment">// 运行在 Looper.prepareMainLooper()～Looper.loop()</span></span><br><span class="line">           <span class="comment">// 之间的就是运行在主线程中</span></span><br><span class="line">           Looper.<span class="built_in">prepareMainLooper</span>();</span><br><span class="line">           Looper.<span class="built_in">getMainLooper</span>().<span class="built_in">setSlowLogThresholdMs</span>(</span><br><span class="line">                   SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">// 初始化native services,加载android_servers库（libandroid_servers.so）</span></span><br><span class="line">           System.<span class="built_in">loadLibrary</span>(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">		...</span><br><span class="line">           <span class="comment">// 通过ActivityThread来创建system上下文</span></span><br><span class="line">           <span class="built_in">createSystemContext</span>();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">           <span class="comment">// 初始化ActivityThread</span></span><br><span class="line">           <span class="comment">// 创建TelephonyServiceManager，StatsServiceManager，MediaServiceManager</span></span><br><span class="line">           ActivityThread.<span class="built_in">initializeMainlineModules</span>();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将SystemServer加入ServiceManager（binder线程池）</span></span><br><span class="line">           <span class="comment">// 每个继承自SystemServer 或属于SystemServer进程的服务都将加入到</span></span><br><span class="line">           <span class="comment">// ServiceManager中的线程池中</span></span><br><span class="line">           ServiceManager.<span class="built_in">addService</span>(<span class="string">&quot;system_server_dumper&quot;</span>, mDumper);</span><br><span class="line">           mDumper.<span class="built_in">addDumpable</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 每个server基本上对应了一个manager,对外提供的API也是只能获取到manager</span></span><br><span class="line">           <span class="comment">// 创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理，启动系统的各种服务</span></span><br><span class="line">           mSystemServiceManager = <span class="keyword">new</span> <span class="built_in">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">           mSystemServiceManager.<span class="built_in">setStartInfo</span>(mRuntimeRestart,</span><br><span class="line">                   mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">           mDumper.<span class="built_in">addDumpable</span>(mSystemServiceManager);</span><br><span class="line">           <span class="comment">// LocalServices是system_server进程中各个服务提供的本地服务</span></span><br><span class="line">           <span class="comment">// system_server进程中每个服务都可以往LocalServices放对象</span></span><br><span class="line">           <span class="comment">// 有些核心服务是继承自SystemServer,LocalServices是公开缓存池目的是：解耦</span></span><br><span class="line">           LocalServices.<span class="built_in">addService</span>(SystemServiceManager.<span class="keyword">class</span>, mSystemServiceManager);</span><br><span class="line">           ...</span><br><span class="line">       <span class="comment">// Start services.</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">           <span class="comment">// 启动系统启动所需的一系列关键服务：AMS,P(power/package)MS,SensorService,DisplayManagerService,LightService等</span></span><br><span class="line">           <span class="built_in">startBootstrapServices</span>(t);</span><br><span class="line">           <span class="comment">// 启动核心服务：BatteryService，GpuService等</span></span><br><span class="line">           <span class="built_in">startCoreServices</span>(t);</span><br><span class="line">           <span class="comment">// 启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等</span></span><br><span class="line">           <span class="built_in">startOtherServices</span>(t);</span><br><span class="line">           <span class="comment">// 以上的所有服务都由mSystemServiceManager来启动，所以都是继承自SystemServer</span></span><br><span class="line">           <span class="comment">// 分别是引导服务、核心服务和其他服务</span></span><br><span class="line">           <span class="comment">// [引导服务]</span></span><br><span class="line">           <span class="comment">// Installer 	系统安装apk时的一个服务类，启动完成Installer服务之后才能启动其他的系统服务</span></span><br><span class="line">           <span class="comment">//ActivityManagerService 	负责四大组件的启动、切换、调度。</span></span><br><span class="line">           <span class="comment">//PowerManagerService 	计算系统中和Power相关的计算，然后决策系统应该如何反应</span></span><br><span class="line">           <span class="comment">//LightsService 	管理和显示背光LED</span></span><br><span class="line">           <span class="comment">//DisplayManagerService 	用来管理所有显示设备</span></span><br><span class="line">           <span class="comment">//UserManagerService 	多用户模式管理</span></span><br><span class="line">           <span class="comment">//SensorService 	为系统提供各种感应器服务</span></span><br><span class="line">           <span class="comment">//PackageManagerService 	用来对apk进行安装、解析、删除、卸载等等操作</span></span><br><span class="line">           <span class="comment">// [核心服务]</span></span><br><span class="line">           <span class="comment">//BatteryService 	管理电池相关的服务</span></span><br><span class="line">           <span class="comment">//UsageStatsService 	收集用户使用每一个APP的频率、使用时常</span></span><br><span class="line">           <span class="comment">//WebViewUpdateService 	WebView更新服务</span></span><br><span class="line">           <span class="comment">// [其他服务]</span></span><br><span class="line">           <span class="comment">//CameraService 	摄像头相关服务</span></span><br><span class="line">           <span class="comment">//AlarmManagerService 	全局定时器管理服务</span></span><br><span class="line">           <span class="comment">//InputManagerService 	管理输入事件</span></span><br><span class="line">           <span class="comment">//WindowManagerService 	窗口管理服务</span></span><br><span class="line">           <span class="comment">//VrManagerService 	VR模式管理服务</span></span><br><span class="line">           <span class="comment">//BluetoothService 	蓝牙管理服务</span></span><br><span class="line">           <span class="comment">//NotificationManagerService 	通知管理服务</span></span><br><span class="line">           <span class="comment">//DeviceStorageMonitorService 	存储相关管理服务</span></span><br><span class="line">           <span class="comment">//LocationManagerService 	定位管理服务</span></span><br><span class="line">           <span class="comment">//AudioService 	音频相关管理服务</span></span><br><span class="line">       &#125; <span class="built_in">catch</span> (Throwable ex) &#123;</span><br><span class="line">          ...</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">      ...</span><br><span class="line">       Looper.<span class="built_in">loop</span>();<span class="comment">// 主线程</span></span><br><span class="line">       <span class="comment">// 若执行到这里说明主线程意外退出了</span></span><br><span class="line">       <span class="comment">// 主线程：Looper.prepareMainlooper~ Looper.loop之间</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>以上方法可以看出来关于其他服务的启动都是运行在主线程中的Looper.prepareMainlooper~ Looper.loop之间，每个SystemServer中的服务都有一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=binder&spm=1001.2101.3001.7020">binder</a>,会加入到ServiceManager的binder线程池中统一管理，这样拿到全局的ServiceManager,根据AIDL 获取到每Service了</p>
<ul>
<li>startBootstrapServices(t)<br>启动系统启动所需的一系列关键服务：<br>AMS,P(power&#x2F;package)MS,SensorService,DisplayManagerService,LightService等</li>
<li>startCoreServices(t)<br>启动核心服务：BatteryService，GpuService等</li>
<li>startOtherServices(t)<br>启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等</li>
</ul>
<blockquote>
<p>在这些启动的服务里（调用了onStart启动服务），都会将服务存入ServiceManager 用来管理系统中的各种Service，用于系统C&#x2F;S架构中的Binder机制通信：Client端要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通讯通路，这样Client端就可以使用Service了</p>
</blockquote>
<p><img src="/../../../../images/image-20231129172417054.png" alt="image-20231129172417054"></p>
<p><img src="/../../../../images/image-20231129172431908.png" alt="image-20231129172431908"></p>
<h4 id="1-startBootstrapServices"><a href="#1-startBootstrapServices" class="headerlink" title="1. startBootstrapServices"></a>1. startBootstrapServices</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">startBootstrapServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 尽早启动看门狗，以便在早期启动过程中出现死锁时使系统服务器崩溃</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartWatchdog&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动看门狗，看门狗需要定时喂狗，若喂狗超时则会触发重启，以便知道进程和服务是否正常运行</span></span><br><span class="line">      <span class="keyword">final</span> Watchdog watchdog = Watchdog.<span class="built_in">getInstance</span>();</span><br><span class="line">      watchdog.<span class="built_in">start</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartInstaller&quot;</span>);</span><br><span class="line">      <span class="comment">// 通过mSystemServiceManager来启动Installer服务,管理应用的安装与卸载</span></span><br><span class="line">      Installer installer = mSystemServiceManager.<span class="built_in">startService</span>(Installer.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 通过mSystemServiceManager来启动UriGrantsManagerService，管理Uri</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;UriGrantsManagerService&quot;</span>);</span><br><span class="line">mSystemServiceManager.<span class="built_in">startService</span>(UriGrantsManagerService.Lifecycle.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过mSystemServiceManager来启动PowerStatsService，管理电源状态</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartPowerStatsService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(PowerStatsService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">      <span class="comment">// 通过mSystemServiceManager来启动ActivityTaskManagerService，管理Activity任务栈</span></span><br><span class="line">      ActivityTaskManagerService atm = mSystemServiceManager.<span class="built_in">startService</span>(</span><br><span class="line">              ActivityTaskManagerService.Lifecycle.<span class="keyword">class</span>).<span class="built_in">getService</span>();</span><br><span class="line">      <span class="comment">// 启动ActivityManagerService,管理Activity等</span></span><br><span class="line">      mActivityManagerService = ActivityManagerService.Lifecycle.<span class="built_in">startService</span>(</span><br><span class="line">              mSystemServiceManager, atm);</span><br><span class="line">      <span class="comment">// 让ActivityManagerService拿到systemServer,例如可以通过mSystemServiceManager来判断系统是否启动完成</span></span><br><span class="line">      mActivityManagerService.<span class="built_in">setSystemServiceManager</span>(mSystemServiceManager);</span><br><span class="line">      mActivityManagerService.<span class="built_in">setInstaller</span>(installer);</span><br><span class="line">      mWindowManagerGlobalLock = atm.<span class="built_in">getGlobalLock</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// 启用PowerManagerService服务，电源管理服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartPowerManager&quot;</span>);</span><br><span class="line">      mPowerManagerService = mSystemServiceManager.<span class="built_in">startService</span>(PowerManagerService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 启动屏幕亮度服务，比如亮度调整</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartLightsService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(LightsService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动屏幕显示服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartDisplayManager&quot;</span>);</span><br><span class="line">      mDisplayManagerService = mSystemServiceManager.<span class="built_in">startService</span>(DisplayManagerService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">          <span class="comment">// 启动PMS,包管理服务</span></span><br><span class="line">          mPackageManagerService = PackageManagerService.<span class="built_in">main</span>(mSystemContext, installer,</span><br><span class="line">                  domainVerificationService, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF,</span><br><span class="line">                  mOnlyCore);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          Watchdog.<span class="built_in">getInstance</span>().<span class="built_in">resumeWatchingCurrentThread</span>(<span class="string">&quot;packagemanagermain&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">       <span class="comment">// 启动传感器服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartSensorService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(SensorService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>(); <span class="comment">// startBootstrapServices</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到大多数服务都是通过<code>mSystemServiceManager.startService</code>来启动，核心服务和其他服务都是一样的，就不过多分析了<br>可以先看看startService方法内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> String name = serviceClass.<span class="built_in">getName</span>();</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">final</span> T service;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 反射拿到该java类</span></span><br><span class="line">               Constructor&lt;T&gt; constructor = serviceClass.<span class="built_in">getConstructor</span>(Context.<span class="keyword">class</span>);</span><br><span class="line">               service = constructor.<span class="built_in">newInstance</span>(mContext);</span><br><span class="line">           &#125; ...</span><br><span class="line">           <span class="comment">// 将当前服务（java类）加入SystemService服务队列中，统一管理</span></span><br><span class="line">           <span class="built_in">startService</span>(service);</span><br><span class="line">           <span class="keyword">return</span> service;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Trace.<span class="built_in">traceEnd</span>(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将当前服务加入mServices队列中</span></span><br><span class="line">       mServices.<span class="built_in">add</span>(service);</span><br><span class="line">       <span class="comment">// Start it.</span></span><br><span class="line">       <span class="type">long</span> time = SystemClock.<span class="built_in">elapsedRealtime</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 调用当前服务的onStart来启动服务</span></span><br><span class="line">           service.<span class="built_in">onStart</span>();</span><br><span class="line">       &#125; <span class="built_in">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">warnIfTooLong</span>(SystemClock.<span class="built_in">elapsedRealtime</span>() - time, service, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>可以看到startService方法就是反射拿到服务类，然后加入队列中，调用其onStart方法进行启动</p>
<h4 id="2-ServiceManager服务管理"><a href="#2-ServiceManager服务管理" class="headerlink" title="2. ServiceManager服务管理"></a>2. ServiceManager服务管理</h4><p>每个属于SystemServer的服务都将加入到ServiceManager的binder线程池中，以供后续直接获取和管理<br>就拿BatteryService服务来讲解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.<span class="built_in">startService</span>(BatteryService.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>


<p>已知startService后会调用BatteryService服务的onStart方法，继续看看onStart内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">Override</span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="type">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">       mBinderService = <span class="keyword">new</span> <span class="built_in">BinderService</span>();</span><br><span class="line">       <span class="comment">// 将BinderService服务加入ServiceManager中</span></span><br><span class="line">       <span class="built_in">publishBinderService</span>(<span class="string">&quot;battery&quot;</span>, mBinderService);</span><br><span class="line">       mBatteryPropertiesRegistrar = <span class="keyword">new</span> <span class="built_in">BatteryPropertiesRegistrar</span>();</span><br><span class="line">       <span class="comment">// 将batteryproperties服务加入ServiceManager中</span></span><br><span class="line">       <span class="built_in">publishBinderService</span>(<span class="string">&quot;batteryproperties&quot;</span>, mBatteryPropertiesRegistrar);</span><br><span class="line">       <span class="comment">// 将BinderService服务加入到LocalServices中</span></span><br><span class="line">       <span class="built_in">publishLocalService</span>(BatteryManagerInternal.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="built_in">LocalService</span>());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>继续看看<code>mBinderService</code>具体是什么，又是如何加入到ServiceManager中的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BinderService</span> extends Binder &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>可以看到<code>mBinderService</code>就是一个Binder,然后调用<code>publishBinderService</code>加入到ServiceManager中的binder线程池中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">void</span> <span class="title">publishBinderService</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ServiceManager.<span class="built_in">addService</span>(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>调用<code>ServiceManager.addService</code>加入到binder线程池中（ServiceManager暂不深究，只知其内部维护了binder线程池），而ServiceManager服务早就在rc文件中作为核心服务启动了，所以具体实现都是c++代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">core</span> animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart apexd</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart class_restart main</span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>


<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>其实SystemServer是通过init fork出来的，父进程就是zygote,而zygote父进程就是init进程。<br>SystemServer内部逻辑主要就是创建了核心服务，引导服务，其他服务，例如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=WMS&spm=1001.2101.3001.7020">WMS</a>,PMS,电池服务，蓝牙服务等。这些服务都不是单独的进程，而是都属于SystemServer进程，启动这些服务过后会将这些服务加入ServiceManager的binder线程池中，因为这些服务内部都创建了Binder实例，再加入到了ServiceManager的binder线程池中，以便与随时获取服务与只通信</p>
<p>参考文章：<a target="_blank" rel="noopener" href="http://liuwangshu.cn/framework/booting/3-syetemserver.html">Android系统启动流程（三）解析SyetemServer进程启动过程</a></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/启动流程/4.Android13启动流程之Zygote和SystemServer启动流程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>##一. Android系统启动流程</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128637218">基于Android13的系统启动流程分析（一）之SeLinux权限介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128652348">基于Android13的系统启动流程分析（三）之FirstStageMain阶段</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128759108">基于Android13的系统启动流程分析（四）之SecondStageMain阶段</a></li>
<li>基于SecondStageMain阶段解析rc文件后会启动zygote进程</li>
<li>zygote进程启动过后会通过JNI方式回调到上层再调回到底层的fork函数创建出SystemServer</li>
</ol>
<h2 id="二-Zygote服务创建源码分析"><a href="#二-Zygote服务创建源码分析" class="headerlink" title="二. Zygote服务创建源码分析"></a>二. Zygote服务创建源码分析</h2><p>在init.rc文件中会执行<code>class_start main</code>来启动zygote,代码如下</p>
<pre><code># 启动zygote
on nonencrypted
    class_start main
    class_start late_start
</code></pre>
<p>这个main就是zygote,可以通过init.{zygote64}.rc来查看，代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="meta"># class : 给服务指定一个类属</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">    priority <span class="number">-20</span></span><br><span class="line">    <span class="meta"># user 在执行此服务之前先切换用户名。当前默认为root.</span></span><br><span class="line">    user root</span><br><span class="line">    # 切换组名</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程</span><br><span class="line">    # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为<span class="number">0</span></span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    socket usap_pool_primary stream <span class="number">660</span> root system</span><br><span class="line">    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line">    <span class="meta"># oneshot : 当此服务退出时不会自动重启.</span></span><br><span class="line">    <span class="meta"># disabled:服务不会自动运行，必须显式地通过服务器来启动</span></span><br><span class="line">    # 据设备相关的关键服务，如果在<span class="number">4</span>分钟内，此服务重复启动了<span class="number">4</span>次，那么设备将会重启进入还原模式。</span><br><span class="line">    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal</span><br></pre></td></tr></table></figure>

<p>第二个参数就是服务进程的名称，通过class指定函数入口，并且位于：<code>/system/bin/app_process64</code>,可以看到<code>audioserver</code>，<code>cameraserver</code>，<code>media</code>，<code>netd</code>，<code>wificond</code>这些进程都隶属于zygote进程中，那就代表着</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果zygote挂了，这些进程将一起died</span><br><span class="line">2.如果这些进程挂了，并不会影响zygote died</span><br></pre></td></tr></table></figure>

<p>如果zygote挂了将会捕获到进程异常信号，将zygote进程进行重启，zygote main入口位置：  <code>frameworks/base/cmds/app_process/app_main.cpp</code></p>
<h4 id="1-app-main-cpp源码分析"><a href="#1-app-main-cpp源码分析" class="headerlink" title="1. app_main.cpp源码分析"></a>1. app_main.cpp源码分析</h4><pre><code>int main(int argc, char* const argv[])
&#123;
    ...
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    ...

    // 如果zygote为true则代表即将创建该进程
    // 如果startSystemServer为true则代表创建zygote时也会创建SystemServer
    // 系统正常启动都会将这两个bool默认给到true
    // 因为rc启动main后携带了--zygote和--start-system-server两个参数
    bool zygote = false;
    bool startSystemServer = false;
    bool application = false;
    String8 niceName;
    String8 className;
            
    ++i;  // Skip unused &quot;parent dir&quot; argument.
    while (i &lt; argc) &#123;
        const char* arg = argv[i++];
        if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;// zygote将为true,名称就叫：zygote
            zygote = true;
            niceName = ZYGOTE_NICE_NAME;
        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;// startSystemServer将为true
            startSystemServer = true;
        &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;
            application = true;
        &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;
            niceName.setTo(arg + 12);
        &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;
            className.setTo(arg);
            break;
        &#125; else &#123;
            --i;
            break;
        &#125;
    &#125;

    Vector&lt;String8&gt; args;
    if (!className.isEmpty()) &#123;
       ...
    &#125; else &#123;
        // 进入创建zygote模式
        // 创建/data/dalvik-cache，为后续会创建Dalvik虚拟机做准备
        maybeCreateDalvikCache();

        // 如果startSystemServer为true的话(默认为true)
        // 将”start-system-server”放入启动的参数args
        if (startSystemServer) &#123;
            args.add(String8(&quot;start-system-server&quot;));
        &#125;

        char prop[PROP_VALUE_MAX];
        ...
        // 将所有剩余参数传递给args，例如application或tool或start-system-server或abi
        // 这些启动参数将会传递到其他进程中，后续取出参数决定是否启动systemServer等操作
        for (; i &lt; argc; ++i) &#123;
            args.add(String8(argv[i]));
        &#125;
    &#125;
    ...

    // zygote为真，将创建zygote，该args启动参数会包含start-system-server
    // 调用runtime(AppRuntime)的start来启动zygote，将args传入，因为args包含了启动SystemServer的标志
    if (zygote) &#123;
        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);
    &#125; else if (className) &#123;
        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);
    &#125; else &#123;
        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);
        app_usage();
        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);
    &#125;
&#125;
</code></pre>
<p>以上代码就是启动zygote和将start-system-server放入启动参数，后续会读取参数启动SystemServer,继续分析一下runtime.start的<code>com.android.internal.os.ZygoteInit&quot;</code>进程，位于：<code>frameworks/base/core/jni/AndroidRuntime.cpp</code></p>
<h4 id="2-AndroidRuntime-cpp源码分析"><a href="#2-AndroidRuntime-cpp源码分析" class="headerlink" title="2. AndroidRuntime.cpp源码分析"></a>2. AndroidRuntime.cpp源码分析</h4><p>Vector&lt;**String8**&gt;&amp; options就是包含了start-system-server的启动参数，通过app_main传递过来的</p>
<pre><code>//frameworks/base/core/jni/AndroidRuntime.cpp
void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)
&#123;
    ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;,
            className != NULL ? className : &quot;(unknown)&quot;, getuid());
    // 默认会启动SystemServer
    static const String8 startSystemServer(&quot;start-system-server&quot;);
    // 是否私有，如果SystemServer会被创建时，将会设置为私有
    bool primary_zygote = false;
            
    for (size_t i = 0; i &lt; options.size(); ++i) &#123;
        // options就是传递过来的args,默认是包含了start-system-server
        if (options[i] == startSystemServer) &#123;
            primary_zygote = true;
           ...
        &#125;
    &#125;

    // 获取环境变量，这里第一次执行时默认为空，所以rootDir不存在
    // = 将直接拿到/system作为rootDir并设置环境变量
    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);
    if (rootDir == NULL) &#123;
        rootDir = &quot;/system&quot;;
        if (!hasDir(&quot;/system&quot;)) &#123;
            LOG_FATAL(&quot;No root directory specified, and /system does not exist.&quot;);
            return;
        &#125;
        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);
    &#125;
    ...

    /* start the virtual machine */
    // 这里就开始启动虚拟机了
    // JNI功能初始化
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    // 创建Dalvik虚拟机(这里--&gt;DVM==JavaVM)
    if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123;
        return;
    &#125;
    onVmCreated(env);

    // 调用startReg函数用来为DVM注册JNI
    if (startReg(env) &lt; 0) &#123;
        ALOGE(&quot;Unable to register all android natives\n&quot;);
        return;
    &#125;

    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;
    // 通过反射拿到String类型
    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);
    assert(stringClass != NULL);
    //options就是app_main.cpp传递过来的args,包含了start-system-server
    // 将options转换为array list对象
    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    //从app_main的main函数得知className为com.android.internal.os.ZygoteInit
    classNameStr = env-&gt;NewStringUTF(className);
    assert(classNameStr != NULL);
    // 将数据转换给java类型的array 数组
    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i &lt; options.size(); ++i) &#123;
        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);
    &#125;

    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.
     */
     // 启动com.android.internal.os.ZygoteInit，该线程成为JVM的主进程，在VM退出之前不会返回
    char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;);
    jclass startClass = env-&gt;FindClass(slashClassName);
    if (startClass == NULL) &#123;
       ...
    &#125; else &#123;
        // 通过反射的方式，找到ZygoteInit的main函数
        // 若获取到内容则执行else
        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,
            &quot;([Ljava/lang/String;)V&quot;);
        if (startMeth == NULL) &#123;
            ALOGE(&quot;JavaVM unable to find main() in &#39;%s&#39;\n&quot;, className);
            /* keep going */
        &#125; else &#123;
            // 通过JNI调用ZygoteInit的main函数,将args(strArray)传递到java层
            // 因为ZygoteInit的main函数是Java编写的，因此需要通过JNI调用
            // 所以这里继续跟到java层面:ZygoteInit.java
            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);
            ...
        &#125;
    &#125;
    // 若执行到这里，则会结束zygote创建，关闭jvm
    free(slashClassName);
    ALOGD(&quot;Shutting down VM\n&quot;);
    if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)
        ALOGW(&quot;Warning: unable to detach main thread\n&quot;);
    if (mJavaVM-&gt;DestroyJavaVM() != 0)
        ALOGW(&quot;Warning: VM did not shut down cleanly\n&quot;);
&#125;
</code></pre>
<p>可以看到以上的代码主要就是初始化了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JNI&spm=1001.2101.3001.7020">JNI</a>（c++与Java交互）功能并创建并启动了JVM虚拟机，通过反射的方式去启动ZygoteInit.java的main方法，并将args参数（包含了是否启动SystemServer的参数）传递过去。<br>而<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JVM%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">JVM虚拟机</a>进程就是：com.android.internal.os.ZygoteInit,而ZygoteInit进程位于：<br><em><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit.java</strong></em></p>
<h4 id="3-ZygoteInit-java源码分析"><a href="#3-ZygoteInit-java源码分析" class="headerlink" title="3. ZygoteInit.java源码分析"></a>3. ZygoteInit.java源码分析</h4><pre><code> public static void main(String[] argv) &#123;
        ZygoteServer zygoteServer = null;
        // 标记zygote开始了
        ZygoteHooks.startZygoteNoThreadCreation();
        // 设置zygote自己的用户组pid
        try &#123;
            Os.setpgid(0, 0);
        &#125; catch (ErrnoException ex) &#123;
            throw new RuntimeException(&quot;Failed to setpgid(0,0)&quot;, ex);
        &#125;

        Runnable caller;
        try &#123;
           // 读取系统是否已经启动完成
            final long startTime = SystemClock.elapsedRealtime();
            final boolean isRuntimeRestarted = &quot;1&quot;.equals(
                    SystemProperties.get(&quot;sys.boot_completed&quot;));

            // 将行为写入trace log 标记目前正处于ZygoteInit阶段
            String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;;
            TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag,
                    Trace.TRACE_TAG_DALVIK);
            bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;);
            RuntimeInit.preForkInit();

            boolean startSystemServer = false;
            // zygote进程就是一个socket,名称就叫zygote
            String zygoteSocketName = &quot;zygote&quot;;
            String abiList = null;
            boolean enableLazyPreload = false;
            for (int i = 1; i &lt; argv.length; i++) &#123;
                // 从AndroidRuntime.cpp中传递上来，已经包含了start-system-server
                // 所以startSystemServer = true
                if (&quot;start-system-server&quot;.equals(argv[i])) &#123;
                    startSystemServer = true;
                &#125; ...
            &#125;
            // 为true，是私有zygote
            final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);
            ...
            // 记录的trace log，只记录到这个地方
            bootTimingsTraceLog.traceEnd(); // ZygoteInit
            // 初始化socket,从环境中获取套接字FD(ANDROID_SOCKET_zygote)
            // 若获取不到则创建一个用于和systemServer通信的socket，当systemServer fork出来后socket进程将关闭
            Zygote.initNativeState(isPrimaryZygote);
              ...

            // 根据环境变量（LocalServerSocket）获取zygote文件描述符并重新创建一个socket,可以从这里看到zygote其实就是一个socket
            // 这个name为”zygote”的Socket用来等待ActivityManagerService来请求Zygote来fork出新的应用程序进程
            // 所以ActivityManagerService里启动应用程序（APP），都是由该zygote socket进行处理并fork出的子进程
            zygoteServer = new ZygoteServer(isPrimaryZygote);
            // 默认为true,将启动systemServer
            if (startSystemServer) &#123;
                // zygote就是一个孵化器，所以这里直接fork（分叉，派生）出来SystemServer
                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);
                ...
                // 让SystemServer子进程运行起来
                if (r != null) &#123;
                    r.run();
                    return;
                &#125;
            &#125;

            Log.i(TAG, &quot;Accepting command socket connections&quot;);

            // 让zygote socket（注意不是systemServer zygote）循环运行
            // 等待client进程来请求调用，请求创建子进程（fork出子进程（例如等待AMS的请求））
            caller = zygoteServer.runSelectLoop(abiList);
        &#125; catch (Throwable ex) &#123;
           ...
        &#125; finally &#123;
            if (zygoteServer != null) &#123;
                // 停止关于systemServer的socket,保留和AMS通信的socket
                // 在initNativeState阶段创建了一个和systemServer通信的socket
                // 接着拿到systemServer socket文件描述符重新创建了一个可以和AMS通信的socket（/dev/socket/zygote）
                zygoteServer.closeServerSocket();
            &#125;
        &#125;
        ...
    &#125;
</code></pre>
<ul>
<li>以上代码讲述了SystemServer socket的创建，将行为写入到trace log日志系统中，并通过JNI调用到底层的fork函数，孵化出SystemServer进程，如果SystemServer创建成功并已经运行了就会将当前socket进行close</li>
<li>期间会创建一个zygote socket,用于等待其他子进程来连接，例如等待AMS(activity manager service)来连接该socket,然后继续fork出子进程（也就是应用程序，所以应用程序就是通过zygote来fork出来的）</li>
<li>创建了2个socket,一个是systemServer socket（Zygote.initNativeState(isPrimaryZygote)来创建）,一个是zygote socket（new ZygoteServer来创建），注意区分</li>
</ul>
<p>继续来看一下<code>zygoteServer = new ZygoteServer(isPrimaryZygote);</code></p>
<h6 id="3-1-ZygoteInit-java-ZygoteServer（zygote-socket）分析"><a href="#3-1-ZygoteInit-java-ZygoteServer（zygote-socket）分析" class="headerlink" title="3.1 ZygoteInit.java#ZygoteServer（zygote socket）分析"></a>3.1 ZygoteInit.java#ZygoteServer（zygote socket）分析</h6><pre><code> //frameworks/base/core/java/com/android/internal/os/ZygoteServer.java
 ZygoteServer(boolean isPrimaryZygote) &#123;
        mUsapPoolEventFD = Zygote.getUsapPoolEventFD();

        // 创建socket，名称为zygote,路径：/dev/sockets/zygote
        if (isPrimaryZygote) &#123;
            mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);
           ...
        &#125;
        ...
    &#125;
    
static LocalServerSocket createManagedSocketFromInitSocket(String socketName) &#123;
        //文件描述符通过ANDROID_socket_&lt;socketName&gt;环境变量共享
        int fileDesc;
        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;

        try &#123;
            String env = System.getenv(fullSocketName);
            // 拿到文件描述符内容
            fileDesc = Integer.parseInt(env);
        &#125; catch (RuntimeException ex) &#123;
            throw new RuntimeException(&quot;Socket unset or invalid: &quot; + fullSocketName, ex);
        &#125;

 try &#123;
            // 生成文件描述符
            FileDescriptor fd = new FileDescriptor();
            fd.setInt$(fileDesc);
            return new LocalServerSocket(fd);  //frameworks/base/core/java/android/net/LocalServerSocket.java
        &#125; catch (IOException ex) &#123;
            throw new RuntimeException(
                &quot;Error building socket from file descriptor: &quot; + fileDesc, ex);
        &#125;
    &#125;
    
public LocalServerSocket(FileDescriptor fd) throws IOException
    &#123;
        // 创建socket并持续监听（等待client来调用）
        impl = new LocalSocketImpl(fd);
        impl.listen(LISTEN_BACKLOG);
        localAddress = impl.getSockAddress();
    &#125;
</code></pre>
<p>简单点来说就是创建了一个zygoye socket ，位于&#x2F;dev&#x2F;sockets&#x2F;zygote,并调用了runSelectLoop让其循环运行，等待新进程发来的请求并进行连接<code>zygoteServer.runSelectLoop(abiList)</code>然后fork出子应用程序进程</p>
<pre><code> Runnable runSelectLoop(String abiList) &#123;
        ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;&gt;();
        ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;&gt;();

        // 拿到socket的文件描述符
        socketFDs.add(mZygoteSocket.getFileDescriptor());
        ...
        while (true) &#123;
            ...
            if (pollReturnValue == 0) &#123;
            ...
            &#125; else &#123;
                boolean usapPoolFDRead = false;

                while (--pollIndex &gt;= 0) &#123;
                    if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123;
                        continue;
                    &#125;

                    if (pollIndex == 0) &#123;
                        // Zygote server socket
                        // acceptCommandPeer函数得到ZygoteConnection类并添加到Socket连接列表peers中，
                        // 接着将该ZygoteConnection的文件描述符添加到fd列表fds中，以便可以接收到ActivityManagerService发送过来的请求
                        ZygoteConnection newPeer = acceptCommandPeer(abiList);
                        peers.add(newPeer);
                        socketFDs.add(newPeer.getFileDescriptor());
                    &#125; 
               ...
            &#125;
        &#125;
    &#125;
</code></pre>
<p>zygoteServer.runSelectLoop(abiList)持续等待进程来请求连接并fork出应用。</p>
<blockquote>
<p>至此zygote socket已经启动完毕了，该socket会等待AMS进程发来的应用程序进程fork</p>
</blockquote>
<p>继续看看systemServer是怎么被fork出来的<br><code>forkSystemServer(abiList, zygoteSocketName, zygoteServer);</code></p>
<h6 id="3-2-ZygoteInit-java-forkSystemServer分析"><a href="#3-2-ZygoteInit-java-forkSystemServer分析" class="headerlink" title="3.2 ZygoteInit.java#forkSystemServer分析"></a>3.2 ZygoteInit.java#forkSystemServer分析</h6><pre><code> private static Runnable forkSystemServer(String abiList, String socketName,
            ZygoteServer zygoteServer) &#123;
        ...
        // 创建args数组，这个数组用来保存启动SystemServer的启动参数，其中可以看出SystemServer进程的用户id和用户组id被设
        //置为1000；
        // 并且拥有用户组10011010，1018、1021、1032、30013010的权限；进程名为system_server；
        // 启动的类名为com.android.server.SystemServer
        String[] args = &#123;
                &quot;--setuid=1000&quot;,
                &quot;--setgid=1000&quot;,
                &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot;
                        + &quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011,3012&quot;,
                &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
                &quot;--nice-name=system_server&quot;,
                &quot;--runtime-args&quot;,
                &quot;--target-sdk-version=&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,
                &quot;com.android.server.SystemServer&quot;,
        &#125;;
        ZygoteArguments parsedArgs;

        int pid;
        try &#123;
            ...
            // 通过JNI形式去调用init进程下的fork函数，派生出systemServer进程
            pid = Zygote.forkSystemServer(
                    parsedArgs.mUid, parsedArgs.mGid,
                    parsedArgs.mGids,
                    parsedArgs.mRuntimeFlags,
                    null,
                    parsedArgs.mPermittedCapabilities,
                    parsedArgs.mEffectiveCapabilities);
        &#125; catch (IllegalArgumentException ex) &#123;
            throw new RuntimeException(ex);
        &#125;

        // pid == 0代表已经运行在子进程(SystemServer)上了
        // 代表SystemServer创建成功，创建成功后会关闭该socket
        if (pid == 0) &#123;
            ...
            // 销毁zygoteServer,保留和AMS通信的socket（runSelectLoop）
            // 当SystemServer创建过后，zygoteServerSocket就没有用处了，进行关闭
            zygoteServer.closeServerSocket();
            // 处理 system server 进程初始化工作并启动SystemServer进程
            // 并启动了一个 binder 线程池供system server 进程和其他进程通信使用
            // 最后调用 RuntimeInit.applicationInit() 执行进程启动自身初始化工作
            // applicationInit()最后是通过反射调用了 SystemServer.java 中的 main() 方法
            return handleSystemServerProcess(parsedArgs);
        &#125;
        return null;
    &#125;
</code></pre>
<p><code>Zygote.forkSystemServer</code>就是调用了底层的fork函数，不再进一步分析了。以上代码已知SystemServer子进程已经创建成功，将调用<code>handleSystemServerProcess</code>来启动SystemServer.java的入口<br>handleSystemServerProcess会一直调用到RuntimeInit.java#findStaticMain方法中</p>
<pre><code>    protected static Runnable findStaticMain(String className, String[] argv,
            ClassLoader classLoader) &#123;
        Class&lt;?&gt; cl;

        try &#123;
            // className:com.android.server.SystemServer
            // 反射拿到SystemServer类
            cl = Class.forName(className, true, classLoader);
        &#125; catch (ClassNotFoundException ex) &#123;
           ...
        &#125;

        Method m;
        try &#123;
            // 反射拿到SystemServer.java的main函数，并启动
            m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);
        &#125; catch (NoSuchMethodException ex) &#123;
           ...
        &#125; catch (SecurityException ex) &#123;
           ...
        &#125;
        ...
        return new MethodAndArgsCaller(m, argv);
    &#125;
</code></pre>
<p>可以看到handleSystemServerProcess下面的子方法去调用了com.android.server.SystemServer的main方法，至此SystemServer就创建和启动完毕了</p>
<blockquote>
<p>至此SystemServer 已经创建并启动完毕了，那么SystemServer socket就会销毁并关闭</p>
</blockquote>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>可以知道zygote是从rc中启动的，zygote本质上就是一个socket,不会关闭和销毁，而创建zygote时携带的StartSystemServer参数（必须携带此参数），会启动SystemServer子进程，SystemServer也是通过fork出来的，而底层和上层的交互是通过JNI实现的，SystemServer的启动是由zygoteInit通过反射的方式启动SystemServer的main方法</p>
<blockquote>
<p>zygote启动时创建了服务端socket,用于SystemServer的创建，当SystemServer创建完成后则会关闭连接，期间已经调用了runSelectLoop来循环等待AMS及其他进程来请求连接，从而fork出应用程序的socket<br>服务端 socket会在SystemServer进程创建完毕后就会关闭，已经没有用处了，等待AMS发来连接将采用runSelectLoop方法进行循环等待</p>
</blockquote>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/启动流程/3.Android13启动流程之SecondStageMain阶段" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="一-Android系统启动基本介绍"><a href="#一-Android系统启动基本介绍" class="headerlink" title="一. Android系统启动基本介绍"></a>一. Android系统启动基本介绍</h2><p>在<a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128652348">基于Android13的系统启动流程分析（三）之FirstStageMain阶段</a>已经讲解过android系统启动的基本介绍了，这里不再单独介绍了</p>
<h2 id="二-SecondStageMain源码分析"><a href="#二-SecondStageMain源码分析" class="headerlink" title="二. SecondStageMain源码分析"></a>二. SecondStageMain源码分析</h2><p>我们先看是怎么进入该阶段的，仍然是由用户空间层main.cpp调用，先简单的说一下第二阶段主要是干什么的：</p>
<ol>
<li><p>设置init进程优先级并创建<code>/dev/.booting</code>设备块代表init正在初始化执行中</p>
</li>
<li><p>初始化属性服务，也就是会读取property_contexts文件内容以及读取build.prop内容通过MMAP映射到全局内存中，也就是对所有进程共享该资源</p>
</li>
<li><p>启动属性服务并创建socket_service,等待新链接去更新或新增属性值</p>
</li>
<li><p>挂载&#x2F;apex,vendor_overlay等其他分区</p>
</li>
<li><p>检查设备是否被unlock解锁</p>
</li>
<li><p>持续监控&#x2F;proc&#x2F;mounts设备文件，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等。将解析内容生成实体类追加到要挂载的mounts_中并进行挂载</p>
</li>
<li><p>将根目录下所有的目录设置为全局共享，例如对&#x2F;data设置为根目录下的全局共享</p>
</li>
<li><p>解析init.rc以及其他import了的rc文件，主要解析rc中的：service，on（action）,Import,而zygote进程正是从解析rc文件中创建的，然后根据zygote（本质上就是一个socket），通过JNI调用到上层代码，再fork出systemServer.java</p>
</li>
<li><p>让init进程无限循环，因为主进程不能退出，退出即代表发生异常</p>
</li>
<li><p>处理sm（ServiceList）中服务超时重启相关（init.rc中的service），若rc中启动的服务启动超时则会让其服务重新启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">       ...</span><br><span class="line">        if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123;</span><br><span class="line">            return SecondStageMain(argc, argv);//第二阶段执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return FirstStageMain(argc, argv); //第一阶段执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-int-SecondStageMain-int-argc-char-argv-分析"><a href="#1-int-SecondStageMain-int-argc-char-argv-分析" class="headerlink" title="1. int SecondStageMain(int argc, char** argv)分析"></a>1. int SecondStageMain(int argc, char** argv)分析</h4><p>位于<code>/system/core/init/init.cpp</code>，直接上代码，代码注释中分步骤来分析</p>
<pre><code>int SecondStageMain(int argc, char** argv) &#123;
    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;
        // 针对产生异常的进程进行信号处理,确保子进程能重启，如果主进程pid=1发生异常则触发crash
        // 已经在上个文章分析过该函数
        InstallRebootSignalHandlers();
    &#125;
     ...
    // 初始化kernel log,所有的kernel log均输出在/dev/kmsg设备节点上
    SetStdioToDevNull(argv);
    InitKernelLogging(argv);
    LOG(INFO) &lt;&lt; &quot;init second stage started!&quot;;
    ...
    // Init不应该因为依赖于任何其他进程而崩溃，因此我们忽略主进程的信号管道信息
    // 但我们不想忽略子进程的SIGPIPE（信号管道），因此我们为信号处理程序设置了一个no op函数
    // SIGPIPE信号产生的场景举例
    // ① 初始时，C、S连接建立，若某一时刻，C端进程宕机或者被KILL而终止（终止的C端进程将会关闭打开的文件描述符，即向S端发送FIN段），S端收到FIN后，响应ACK
    // ② 假设此时，S端仍然向C端发送数据：当第一次写数据后，S端将会收到RST分节； 当收到RST分节后，第二次写数据后，S端将收到SIGPIPE信号（S端进程被终止）
    &#123;
        struct sigaction action = &#123;.sa_flags = SA_RESTART&#125;;
        action.sa_handler = [](int) &#123;&#125;;
        // sigaction是一个函数，可以用来查询或设置信号处理方式
        sigaction(SIGPIPE, &amp;action, nullptr);
    &#125;

    //  MIN_OOM_SCORE_ADJUST = -1000;
    //  MAX_OOM_SCORE_ADJUST = 1000;
    //  设置进程的优先级，例如APK优先级是AMS计算出来并下发到/proc/1/oom_score_adj
    //  统一由init进程设置/proc/**/oom_score_adj为-1000优先级
    if (auto result =
                WriteFile(&quot;/proc/1/oom_score_adj&quot;, StringPrintf(&quot;%d&quot;, DEFAULT_OOM_SCORE_ADJUST));
        !result.ok()) &#123;
        LOG(ERROR) &lt;&lt; &quot;Unable to write &quot; &lt;&lt; DEFAULT_OOM_SCORE_ADJUST
                   &lt;&lt; &quot; to /proc/1/oom_score_adj: &quot; &lt;&lt; result.error();
    &#125;

      ...
    // 创建 /dev/.booting 文件，就是个标记，表示booting进行中
    // is_booting()函数会依靠空文件&quot;.booting&quot;来判断是否进程处于初始化中，初始化结束后，这个文件会被删除
    close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));
    
    // 当设备解锁时，允许adb root
    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限,这一点在第一阶段已经完成了
    // 并设置了INIT_FORCE_DEBUGGABLE环境变量，这里只是根据环境变量获取第一阶段的内容
    const char* force_debuggable_env = getenv(&quot;INIT_FORCE_DEBUGGABLE&quot;);
    bool load_debug_prop = false;
    if (force_debuggable_env &amp;&amp; AvbHandle::IsDeviceUnlocked()) &#123;
        load_debug_prop = &quot;true&quot;s == force_debuggable_env;
    &#125;
    unsetenv(&quot;INIT_FORCE_DEBUGGABLE&quot;);
    
    // 如果设备未unlock，则卸载关于debug版本的/debug_ramdisk
    // 让属性值读取/ramdisk而不是/debug_ramdisk，因为非unlock,不需要debug ramdisk
    if (!load_debug_prop) &#123;
        // setup 1
        UmountDebugRamdisk();
    &#125;

    // 初始化属性服务
    // 获取system/build.prop,vendor/build.prop,/odm/build.prop,/product/build.prop,等其他build.prop并加载到properties map结构中
    // 然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值
    // 注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖
    // setup 2
    PropertyInit();

    // Umount second stage resources after property service has read the .prop files.
    // 在属性服务读取.prop文件后，将卸载/second_stage_resources，因为已经用不到了，已经将属性值加载到内存当中了
    UmountSecondStageRes();

    // Umount the debug ramdisk after property service has read the .prop files when it means to.
    // 若是debug版本，已经获取了属性值过后，也将卸载/debug_ramdisk
    if (load_debug_prop) &#123;
        UmountDebugRamdisk();
    &#125;

    // 挂载第二阶段（该阶段）的文件系统,第一阶段已经挂载了很多基本的文件系统了以及重要的分区
    // 挂载/apex：简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题
    // setup 3
    MountExtraFilesystems();
    ...
    // 之前初始化了属性服务，这里将开始属性服务，其实它就是一个socket
    // 创建socket,处理客户端发来的请求，决定是更新属性值还是新增属性值
    // setup 4
    StartPropertyService(&amp;property_fd);
    ...
    // 根据ro.vndk.version 版本号，将/system/vendor_overlay和/product/vendor_overlay挂载在vendor上
    // 也就是会覆盖vendor分区内容
    // setup 5
    fs_mgr_vendor_overlay_mount_all();
    // 根据ro.oem_unlock_supported属性值来决定是否可以对设备进行unlock（解锁）
    // 若ro.oem_unlock_supported：「1」则代表 设备支持刷写unlock,若不支持该值为0
    // 如果设备支持刷写解锁，ro.boot.verifiedbootstate则会为orange，根据orange状态，把androidboot.flash.locked设置为1
    // 如果设备不支持刷新解锁，ro.boot.verifiedbootstate则会为green，根据orange状态，把androidboot.flash.locked设置为0
    // androidboot.flash.locked在系统启动完成后会形成属性值
    // （或 /firmware/android/flash.locked DT 属性）设置为“1”（如果已锁定）或“0”（如果已解锁）来指示锁定状态。
    export_oem_lock_status();
    // 持续监控/proc/mounts 节点(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;)),主要是解析该文件
    // 解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等(空格分割/dev/block/dm-33 /mnt/pass_through/0/emulated ext4 rw)
    // 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息
    // setup 6
    MountHandler mount_handler(&amp;epoll);
    ...
    // 将根目录下所有的目录设置为全局共享
    // 将根目录/&#123;分区&#125;类型设置为共享，以便默认情况下所有进程都可以看到任何装载事件（例如/data）
    if (!SetupMountNamespaces()) &#123;
        PLOG(FATAL) &lt;&lt; &quot;SetupMountNamespaces failed&quot;;
    &#125;

    ...
    // setup 7
    // 创建ActionManager对象和ServiceList对象
    ActionManager&amp; am = ActionManager::GetInstance();
    ServiceList&amp; sm = ServiceList::GetInstance();
    // 加载rc文件，保存到action manager和service list中
    // rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析
    // 主要解析rc中的：service，on,Import,包含了zygote.rc,路径：/system/bin/app_process64
    // 在文件系统挂载的第一阶段，system/vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载
    // 后面主要分析一下on early-init和on init和zygote
    LoadBootScripts(am, sm);
    ...
    // setup 8
    // 构建action和触发器(on early-init)，放到event_queue，等待执行函数
    am.QueueBuiltinAction(SetupCgroupsAction, &quot;SetupCgroups&quot;);
    am.QueueBuiltinAction(SetKptrRestrictAction, &quot;SetKptrRestrict&quot;);
    am.QueueBuiltinAction(TestPerfEventSelinuxAction, &quot;TestPerfEventSelinux&quot;);
    am.QueueEventTrigger(&quot;early-init&quot;);

    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...
    am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);
    // ... so that we can start queuing up actions that require stuff from /dev.
    am.QueueBuiltinAction(SetMmapRndBitsAction, &quot;SetMmapRndBits&quot;);
    Keychords keychords;
    am.QueueBuiltinAction(
            [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123;
                for (const auto&amp; svc : ServiceList::GetInstance()) &#123;
                    keychords.Register(svc-&gt;keycodes());
                &#125;
                keychords.Start(&amp;epoll, HandleKeychord);
                return &#123;&#125;;
            &#125;,
            &quot;KeychordInit&quot;);

    // Trigger all the boot actions to get us started.
    // 构建action和触发器(on init)，放到event_queue，等待执行函数
    am.QueueEventTrigger(&quot;init&quot;);

    // Don&#39;t mount filesystems or start core system services in charger mode.
    // 如果是充电模式则不需要挂载文件系统和不要启动核心服务
    std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;);
    if (bootmode == &quot;charger&quot;) &#123;
        am.QueueEventTrigger(&quot;charger&quot;);
    &#125; else &#123;
        am.QueueEventTrigger(&quot;late-init&quot;);
    &#125;

    // Run all property triggers based on current state of the properties.
    // 运行所有属性触发器(action)，例如 on property
    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);

    // Restore prio before main loop
    // 设置进程优先级，主进程不能被销毁和退出，循环处理rc中的服务相关
    setpriority(PRIO_PROCESS, 0, 0);
    while (true) &#123;
        // By default, sleep until something happens.
        auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;;

        auto shutdown_command = shutdown_state.CheckShutdown();
        if (shutdown_command) &#123;
            LOG(INFO) &lt;&lt; &quot;Got shutdown_command &#39;&quot; &lt;&lt; *shutdown_command
                      &lt;&lt; &quot;&#39; Calling HandlePowerctlMessage()&quot;;
            HandlePowerctlMessage(*shutdown_command);
            shutdown_state.set_do_shutdown(false);
        &#125;

        if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;
            // 执行队列中的action
            // 队列中依次执行每个action中携带command对应的执行函数
            am.ExecuteOneCommand();
        &#125;
        if (!IsShuttingDown()) &#123;
            // 处理sm（ServiceList）中服务超时重启相关（init.rc中的service）
            auto next_process_action_time = HandleProcessActions();
            if (next_process_action_time) &#123;
                epoll_timeout = std::chrono::ceil&lt;std::chrono::milliseconds&gt;(
                        *next_process_action_time - boot_clock::now());
                if (*epoll_timeout &lt; 0ms) epoll_timeout = 0ms;
            &#125;
        &#125;
...

    return 0;
&#125;
</code></pre>
<h4 id="2-SecondStageMain-int-argc-char-argv-—–-gt-setup-1步骤"><a href="#2-SecondStageMain-int-argc-char-argv-—–-gt-setup-1步骤" class="headerlink" title="2. SecondStageMain(int argc, char** argv)—–&gt;setup 1步骤"></a>2. SecondStageMain(int argc, char** argv)—–&gt;setup 1步骤</h4><p>先贴一下setup 1的代码块，主要分析<code>UmountDebugRamdisk</code>函数</p>
<pre><code>    if (!load_debug_prop) &#123;
        // setup 1
        UmountDebugRamdisk();
    &#125;
    
static void UmountDebugRamdisk() &#123;
    if (umount(&quot;/debug_ramdisk&quot;) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Failed to umount /debug_ramdisk&quot;;
    &#125;
&#125;    
</code></pre>
<p>如果设备未unlock，则卸载关于debug版本的&#x2F;debug_ramdisk,让属性值读取&#x2F;ramdisk而不是&#x2F;debug_ramdisk</p>
<h4 id="3-SecondStageMain-int-argc-char-argv-—–-gt-setup-2步骤"><a href="#3-SecondStageMain-int-argc-char-argv-—–-gt-setup-2步骤" class="headerlink" title="3. SecondStageMain(int argc, char** argv)—–&gt;setup 2步骤"></a>3. SecondStageMain(int argc, char** argv)—–&gt;setup 2步骤</h4><p>该步骤主要作用是初始化属性值服务，这里只是一个初始化的动作</p>
<pre><code>    // setup 2
    PropertyInit();
</code></pre>
<ul>
<li><p>初始化属性服务，获取<code>system/build.prop</code>,<code>vendor/build.prop</code>,<code>/odm/build.prop</code>,<code>/product/build.prop</code>,等其他build.prop并加载到properties map结构中，然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值，注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖</p>
</li>
<li><p><code>PropertyInit</code>位于<code>/system/core/init/property_service.cpp</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void PropertyInit() &#123;</span><br><span class="line">   ...</span><br><span class="line">    // 建立属性服务设备文件（linux思想，万物皆文件系统）</span><br><span class="line">    mkdir(&quot;/dev/__properties__&quot;, S_IRWXU | S_IXGRP | S_IXOTH);</span><br><span class="line">    // 创建序列化过后的propertyInfo实体，主要就是读取property_contexts文件</span><br><span class="line">    CreateSerializedPropertyInfo();</span><br><span class="line">    // 这里主要步骤是：通过mmap映射，将文件（/dev/__properties__/&#123;..&#125;）映射进内存（初始化属性内存映射文件）</span><br><span class="line">    // 这里将文件映射进内存，用于后续对__prooerties__目录（也可以说是文件，将代码块映射为file类型）进行内存共享</span><br><span class="line">    if (__system_property_area_init()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Failed to initialize property area&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 加载/dev/__properties__/property_info，此文件是序列化过的，无法直接查看内容</span><br><span class="line">    if (!property_info_area.LoadDefaultPath()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Failed to load serialized property info file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取/proc/device-tree/firmware/android/目录下的文件，生成ro.boot.xxx属性值</span><br><span class="line">    // 这三个函数主要就是生成ro.boot.xx属性值，这里不详细研究</span><br><span class="line">    ProcessKernelDt();</span><br><span class="line">    ProcessKernelCmdline();</span><br><span class="line">    ProcessBootconfig();</span><br><span class="line"></span><br><span class="line">    // 初始化ro.xx,将ro.boot.xx的属性值复制给ro.xxx</span><br><span class="line">    // &#123; &quot;ro.boot.serialno&quot;,   &quot;ro.serialno&quot;,   UNSET, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.mode&quot;,       &quot;ro.bootmode&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.baseband&quot;,   &quot;ro.baseband&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.bootloader&quot;, &quot;ro.bootloader&quot;, &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.hardware&quot;,   &quot;ro.hardware&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.revision&quot;,   &quot;ro.revision&quot;,   &quot;0&quot;, &#125;,</span><br><span class="line">    ExportKernelBootProps();</span><br><span class="line"></span><br><span class="line">    // 读取&#123;system/vendor/odm/product&#125;/build.prop等...</span><br><span class="line">    // 将build.prop通过MMAP映射到全局内存中，供所有进程访问 </span><br><span class="line">    PropertyLoadBootDefaults();</span><br></pre></td></tr></table></figure>

<p>调用<code>__system_property_area_init</code>通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=mmap&spm=1001.2101.3001.7020">mmap</a>映射，将文件（&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;{包含了上下文和propertys_info实体：保存了property_contexts文件内容}）映射进内存（初始化属性内存映射文件）， 这里将文件映射进内存，用于后续对__prooerties__目录（也可以说是文件，将代码块映射为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=file%E7%B1%BB&spm=1001.2101.3001.7020">file类</a>型）进行内存共享</p>
</li>
<li><p>CreateSerializedPropertyInfo：</p>
<p>创建序列化过后的属性值信息（既然序列化了，那肯定是要跨进程通信）<br>(1).读取{system_ext，vendor,product,odm,system}_property_contexts属性值安全上下文并赋值给：property_infos<br>(2).property_infos属于容器类型，读取不同的property_contexts将会追加到末尾，而不是覆盖原本内容<br>(3).将property_infos实体序列化，使其可以跨进程传递消息<br>(4).将property_infos实体写入&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;property_info驱动节点中</p>
</li>
<li><p>PropertyLoadBootDefaults<br>这里会将属性值全部写入build.prop里，分为：system&#x2F;build.prop,vendor&#x2F;build.prop,&#x2F;odm&#x2F;build.prop,&#x2F;product&#x2F;build.prop，注意是有优先级顺序的，按先后顺序覆盖,获取build.prop分别是直接从指定文件里获取和从指定分区中获取，这两个方式作用都一样，只不过第二种需要区分出分区里是否存在<code>&#123;partition&#125;/&#123;etc&#125;/build.prop</code>,有的分区是不存在<code>&#123;partition&#125;/etc/build.prop</code>这个文件，而是直接存在于<code>&#123;partition&#125;/build.prop</code></p>
</li>
</ul>
<p>一切都写到了注释里，继续分析比较重要的2个函数<code>CreateSerializedPropertyInfo</code>和<code>PropertyLoadBootDefaults</code></p>
<h6 id="3-1-CreateSerializedPropertyInfo"><a href="#3-1-CreateSerializedPropertyInfo" class="headerlink" title="3.1 CreateSerializedPropertyInfo"></a>3.1 CreateSerializedPropertyInfo</h6><pre><code>void CreateSerializedPropertyInfo() &#123;
    auto property_infos = std::vector&lt;PropertyInfoEntry&gt;();
    //判断文件是否存在，并判断文件是否可写(属性服务的安全上下文，之前有提过设备节点，服务，属性值都要遵守selinux规则)
    if (access(&quot;/system/etc/selinux/plat_property_contexts&quot;, R_OK) != -1) &#123;
        // 加载property_contexts文件，该文件内容都是配置的属性值上下文，属于selinux相关知识
        // 通过ParsePropertyInfoFile解析该文件，得到property_infos
        if (!LoadPropertyInfoFromFile(&quot;/system/etc/selinux/plat_property_contexts&quot;,
                                      &amp;property_infos)) &#123;
            return;
        &#125;
        // 如果这里system_ext/vendor/product没有挂载上（例如在恢复的情况下，vendor分区将不会安装），则无法继续加载该上下文，该分区会在第一阶段挂载
        // 从下面的代码可以看出来，property_infos的是容器类型vector&lt;PropertyInfoEntry&gt;()
        // 所以这里并没有优先级也没有以哪个property_contexts为准，而是根据是否存在对应的分区而append加载
        // 也就是在对应后面追加内容，而不是覆盖：property_infos-&gt;emplace_back(property_info_entry);
        if (access(&quot;/system_ext/etc/selinux/system_ext_property_contexts&quot;, R_OK) != -1) &#123;
            LoadPropertyInfoFromFile(&quot;/system_ext/etc/selinux/system_ext_property_contexts&quot;,
                                     &amp;property_infos);
        &#125;
        if (!LoadPropertyInfoFromFile(&quot;/vendor/etc/selinux/vendor_property_contexts&quot;,
                                      &amp;property_infos)) &#123;
            // Fallback to nonplat_* if vendor_* doesn&#39;t exist.
            LoadPropertyInfoFromFile(&quot;/vendor/etc/selinux/nonplat_property_contexts&quot;,
                                     &amp;property_infos);
        &#125;
        if (access(&quot;/product/etc/selinux/product_property_contexts&quot;, R_OK) != -1) &#123;
            LoadPropertyInfoFromFile(&quot;/product/etc/selinux/product_property_contexts&quot;,
                                     &amp;property_infos);
        &#125;
        if (access(&quot;/odm/etc/selinux/odm_property_contexts&quot;, R_OK) != -1) &#123;
            LoadPropertyInfoFromFile(&quot;/odm/etc/selinux/odm_property_contexts&quot;, &amp;property_infos);
        &#125;
     // 若/system/etc/selinux/plat_property_contexts无法读取，则else
    &#125; else &#123;
        // 由于system下的安全上下文未创建，则可能是system出现异常未挂载上，或者供应商修改过plat_property_contexts
        // 一般供应商都是复写，而不会直接更改文件名称
        // 若找不到该文件，则加载根目录下的这些属性值安全上下文
        if (!LoadPropertyInfoFromFile(&quot;/plat_property_contexts&quot;, &amp;property_infos)) &#123;
            return;
        &#125;
        LoadPropertyInfoFromFile(&quot;/system_ext_property_contexts&quot;, &amp;property_infos);
        if (!LoadPropertyInfoFromFile(&quot;/vendor_property_contexts&quot;, &amp;property_infos)) &#123;
            // Fallback to nonplat_* if vendor_* doesn&#39;t exist.
            LoadPropertyInfoFromFile(&quot;/nonplat_property_contexts&quot;, &amp;property_infos);
        &#125;
        LoadPropertyInfoFromFile(&quot;/product_property_contexts&quot;, &amp;property_infos);
        LoadPropertyInfoFromFile(&quot;/odm_property_contexts&quot;, &amp;property_infos);
    &#125;

    // 序列化property_infos实体，使其可以跨进程传递
    auto serialized_contexts = std::string();
    auto error = std::string();
    if (!BuildTrie(property_infos, &quot;u:object_r:default_prop:s0&quot;, &quot;string&quot;, &amp;serialized_contexts,
                   &amp;error)) &#123;
        LOG(ERROR) &lt;&lt; &quot;Unable to serialize property contexts: &quot; &lt;&lt; error;
        return;
    &#125;
</code></pre>
<p>​<br>​        &#x2F;&#x2F; 将property_infos写入&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;property_info设备文件中<br>​        constexpr static const char kPropertyInfosPath[] &#x3D; “&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;property_info”;<br>​        if (!WriteStringToFile(serialized_contexts, kPropertyInfosPath, 0444, 0, 0, false)) {<br>​            PLOG(ERROR) &lt;&lt; “Unable to write serialized property infos to file”;<br>​        }<br>​        selinux_android_restorecon(kPropertyInfosPath, 0);<br>​    }</p>
<p>  以上的步骤都是对property_infos变量进行赋值，数据就是property_contexts文件内容，而property_infos是属于vector&lt;**PropertyInfoEntry**&gt;()容器类型,而每次加载property_infos时都是调用的<code>property_infos-&gt;emplace_back(property_info_entry);</code>在容器后面追加数据，不会覆盖原有的数据</p>
<blockquote>
<p>读取property_contexts文件内容，将内容传递给property_infos实体</p>
</blockquote>
<h6 id="3-2-PropertyLoadBootDefaults"><a href="#3-2-PropertyLoadBootDefaults" class="headerlink" title="3.2 PropertyLoadBootDefaults"></a>3.2 PropertyLoadBootDefaults</h6><pre><code>void PropertyLoadBootDefaults() &#123;
    std::map&lt;std::string, std::string&gt; properties;
    // 如果是恢复模式则加载/prop.default
    if (IsRecoveryMode()) &#123;
        load_properties_from_file(&quot;/prop.default&quot;, nullptr, &amp;properties);
    &#125;

    // 这里还没执行，只是一个未执行的代码块，从分区里读取build.prop文件
    const auto load_properties_from_partition = [&amp;properties](const std::string&amp; partition,
                                                              int support_legacy_path_until) &#123;
        // 加载&#123;system_ext,product等分区&#125;/etc/build.prop文件
        // 以后代码上获取的属性值就是从该文件中获取的
        auto path = &quot;/&quot; + partition + &quot;/etc/build.prop&quot;;
        if (load_properties_from_file(path.c_str(), nullptr, &amp;properties)) &#123;
            return;
        &#125;
        ...
    &#125;
    // 获取第一阶段生成的second_stage_resources/system/etc/ramdisk/build.prop
    // 并追加到properties中（这里是map结构，注意会覆盖内容）
    LoadPropertiesFromSecondStageRes(&amp;properties);
    // 先读取的/system/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/system/build.prop&quot;, nullptr, &amp;properties);
    // 获取/system_ext分区下的build.prop/default.prop，赋值给然后赋值给propertiess（这里是map结构，注意会覆盖内容）
    load_properties_from_partition(&quot;system_ext&quot;, /* support_legacy_path_until */ 30);
     // 继续读取的/vendor/default.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/vendor/default.prop&quot;, nullptr, &amp;properties);
    // &#125;
    // 继续读取的/vendor/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/vendor/build.prop&quot;, nullptr, &amp;properties);
    // 继续读取的/vendor_dlkm/etc/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/vendor_dlkm/etc/build.prop&quot;, nullptr, &amp;properties);
    // 继续读取的/odm_dlkm/etc/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/odm_dlkm/etc/build.prop&quot;, nullptr, &amp;properties);
    // 获取/&#123;odm,product&#125;.prop/default.prop，赋值给然后赋值给propertiess（这里是map结构，注意会覆盖内容）
    load_properties_from_partition(&quot;odm&quot;, /* support_legacy_path_until */ 28);
    load_properties_from_partition(&quot;product&quot;, /* support_legacy_path_until */ 30);
    // 因为propertiess是map结构，如果key一样则会覆盖内容,所以以上代码的顺序不能调换，优先级最高的是/product下的build.prop
    // /system-&gt;/system_ext-&gt;/vendor-&gt;/omd-&gt;/product

    // 如果&quot;/debug_ramdisk/adb_debug.prop&quot;存在，说明设备已经unlock过了，则加载unlock过后的属性值，例如ro.debugger=1,则是开启了调试模式
    if (access(kDebugRamdiskProp, R_OK) == 0) &#123;
        LOG(INFO) &lt;&lt; &quot;Loading &quot; &lt;&lt; kDebugRamdiskProp;
        load_properties_from_file(kDebugRamdiskProp, nullptr, &amp;properties);
    &#125;

    // 将从build.prop,default.prop获取的properties，循环设置属性值
    // 这里是把.prop文件里的属性值通过mmap映射到内存中，使得所有进程可以访问（全局）
    for (const auto&amp; [name, value] : properties) &#123;
        std::string error;
        // 如果是ro则是只读，只能设置一次，再次设置会无效，如果存在相同的key,则会调用update更新
        if (PropertySet(name, value, &amp;error) != PROP_SUCCESS) &#123;
            LOG(ERROR) &lt;&lt; &quot;Could not set &#39;&quot; &lt;&lt; name &lt;&lt; &quot;&#39; to &#39;&quot; &lt;&lt; value
                       &lt;&lt; &quot;&#39; while loading .prop files&quot; &lt;&lt; error;
        &#125;
    &#125;
    ...
    // 设置persist.sys.usb.config属性值来决定是否开启调试模式（adb或none）
    update_sys_usb_config();
&#125;
</code></pre>
<p>以上代码主要做的一个动作：读取各个分区里的build.prop或直接从指定目录下读取build.prop并调用<code>PropertySet</code>设置到全局内存中，让所有进程访问</p>
<p>主要的两个函数：<code>load_properties_from_partition</code>和<code>load_properties_from_file</code>，分别从分区里读取和从指定文件读取，为什么这么做呢？因为有的分区下是没有&#x2F;etc目录的，无法直接指定文件位置，所以通过调用 <code>&quot;/&quot; + partition + &quot;/etc/build.prop&quot;</code>来读取，若不存在该文件则直接return。<br>注意这里读取了{system,system_ext,vendor,vendor_dlkm,odm_dlkm,odm,product}&#x2F;build.prop,由于properties属于map结构，如果key相同是会覆盖原有的值，所以这里是有优先级排序的：</p>
<ol>
<li>&#x2F;system&#x2F;build.prop</li>
<li>&#x2F;system_ext&#x2F;{etc}&#x2F;build.prop</li>
<li>&#x2F;vendor&#x2F;default.prop</li>
<li>&#x2F;vendor&#x2F;build.prop</li>
<li>&#x2F;vendor_dlkm&#x2F;etc&#x2F;build.prop</li>
<li>&#x2F;odm_dlkm&#x2F;etc&#x2F;build.prop</li>
<li>&#x2F;odm&#x2F;{etc}&#x2F;build.prop</li>
<li>&#x2F;product&#x2F;{etc}&#x2F;build.prop</li>
</ol>
<blockquote>
<p>如果在system中自定义了属性值，又在product自定义了一样的属性值，那么是以product为准</p>
</blockquote>
<p>这里只是init初始化过程，读取build.prop并解析出来每一行属性值并调用<code>PropertySet</code>设置到全局内存中</p>
<p>继续分析一下<code>PropertySet</code>函数，该函数比较简单</p>
<pre><code>static uint32_t PropertySet(const std::string&amp; name, const std::string&amp; value, std::string* error) &#123;
    ...
    // 找到该属性值
    prop_info* pi = (prop_info*) __system_property_find(name.c_str());
    if (pi != nullptr) &#123;
        // 如果是以ro开头则代表只读，禁止写入，返回error
        if (StartsWith(name, &quot;ro.&quot;)) &#123;
            *error = &quot;Read-only property was already set&quot;;
            return PROP_ERROR_READ_ONLY_PROPERTY;
        &#125;
        // 若存在该属性值且非ro 则更新属性值
        __system_property_update(pi, value.c_str(), valuelen);
    &#125; else &#123;
        // 若找不到该属性值则新增
        int rc = __system_property_add(name.c_str(), name.size(), value.c_str(), valuelen);
        if (rc &lt; 0) &#123;
            *error = &quot;__system_property_add failed&quot;;
            return PROP_ERROR_SET_FAILED;
        &#125;
    &#125;

    // 如果是以persist.开头，则会全部写进/data/property/persistent_properties
    // 属于一个缓存机制
    // std::string persistent_property_filename = &quot;/data/property/persistent_properties&quot;;
    if (persistent_properties_loaded &amp;&amp; StartsWith(name, &quot;persist.&quot;)) &#123;
        WritePersistentProperty(name, value);
    &#125;
    ...
    return PROP_SUCCESS;
&#125;
</code></pre>
<p>以上代码就是若存在属性值则更新，若不存在则新增。如果是ro开头的属性值则代表只读，只能初始化的时候给默认值，后续不允许修改值，如果是persist开头的则会全部缓存进<code>/data/property/persistent_properties</code>，persist开头的属性值是可改的，如果用户修改过了persist开头的属性值相当于修改了<code>/data/property/persistent_properties</code>里的属性值，那么重启后仍然生效，并不会还原默认值。这样即不影响属性值的原子性（原有的属性值），又给了开发者&#x2F;用户操作的空间，如果是刷机或恢复出厂则会还原</p>
<p>如果是系统开发者自定义了属性值，但是发现默认定义的时候属性值无法写入，则可能是property_contexts安全上下文影响，可以直接修改这里的代码，<code>__system_property_add</code>强行调用该方法即可</p>
<h4 id="4-SecondStageMain-int-argc-char-argv-—–-gt-setup-3步骤"><a href="#4-SecondStageMain-int-argc-char-argv-—–-gt-setup-3步骤" class="headerlink" title="4. SecondStageMain(int argc, char** argv)—–&gt;setup 3步骤"></a>4. SecondStageMain(int argc, char** argv)—–&gt;setup 3步骤</h4><pre><code>setup 4
MountExtraFilesystems();

static void MountExtraFilesystems() &#123;
#define CHECKCALL(x) \
    if ((x) != 0) PLOG(FATAL) &lt;&lt; #x &quot; failed.&quot;;

    // /apex is used to mount APEXes
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/apex&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));

    // /linkerconfig is used to keep generated linker configuration
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/linkerconfig&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));
#undef CHECKCALL
&#125;
</code></pre>
<p>可以看到<code>MountExtraFilesystems</code>主要就挂载了&#x2F;apex和&#x2F;linkerconfig并归属于tmpfs文件系统（运行在内存的文件系统，运行速度较快）,这里主要探讨一下APEX.<br>应用程序可以通过更新APK来升级，供应商客制化系统后可以通过OTA进行系统升级，而针对google 开发者来修复原生的系统bug该如何更新呢？那就是通过google发布的安全patch和更新manline以及apex来解决</p>
<ul>
<li>简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题</li>
<li>apex可以将系统内部的各个功能打包成模块，然后针对这些模块单独升级</li>
<li>apk是应用程序的载体，对应用开发者而言，可以apk方式对应用功能进行升级</li>
<li>apex是系统功能的载体，对系统开发者（目前看主要是谷歌）而言，可以apex方式对系统功能进行升级</li>
<li>一般是google开发者通过playstore发布，然后供我们下载更新，而对应ODM第三方供应商，则需要通过OTA升级</li>
<li>apex相当于对系统功能进行了更细粒度的划分，可以独立升级这些功能，可以把apex看成是一个一个的系统升级包</li>
</ul>
<h4 id="5-SecondStageMain-int-argc-char-argv-—–-gt-setup-4步骤"><a href="#5-SecondStageMain-int-argc-char-argv-—–-gt-setup-4步骤" class="headerlink" title="5. SecondStageMain(int argc, char** argv)—–&gt;setup 4步骤"></a>5. SecondStageMain(int argc, char** argv)—–&gt;setup 4步骤</h4><pre><code>    // setup 4
    StartPropertyService(&amp;property_fd);
</code></pre>
<p>在setup2中初始化了property,获取了build.prop和property_contexts并设置为内存中全局共享</p>
<pre><code>void StartPropertyService(int* epoll_socket) &#123;
    // 在init阶段version=1,这里已经升级到2了
    InitPropertySet(&quot;ro.property_service.version&quot;, &quot;2&quot;);

    // 创建sockets,套接字,可以用于网络通信，也可以用于本机内的进程通信
    // socketpair()函数用于创建一对无名的,相互连接的套接字
    // 如果函数创建成功,则返回0,创建好的套接字分别是sv[0]和sv[1];否则返回-1
    int sockets[2];
    // 参数1：表示协议族AF_UNIX
    // 参数2：表示协议，SOCK_SEQPACKET提供连续可靠的数据包连接
    // SOCK_CLOEXEC：当文件描述符设置了O_CLOEXEC属性后，在调用exec函数族时，文件描述符就会自动关闭，无需手动关闭
    // 而SOCK_DGRAM是基于UDP的
    // 参数3：表示类型，只能为0
    // 参数4：套节字柄，该两个句柄作用相同，均能进行读写双向操作
    if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sockets) != 0) &#123;
        PLOG(FATAL) &lt;&lt; &quot;Failed to socketpair() between property_service and init&quot;;
    &#125;
    ...
    // PROP_SERVICE_NAME：/dev/socket/property_service，创建socket
    if (auto result = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
                                   false, 0666, 0, 0, &#123;&#125;);
        result.ok()) &#123;
        property_set_fd = *result;
    &#125; else &#123;
        LOG(FATAL) &lt;&lt; &quot;start_property_service socket creation failed: &quot; &lt;&lt; result.error();
    &#125;

    // 监听socket:/dev/socket/property_service,最大连接：8
    listen(property_set_fd, 8);

    // 开启线程处理socket
    auto new_thread = std::thread&#123;PropertyServiceThread&#125;;
    property_service_thread.swap(new_thread);
&#125;
</code></pre>
<p>这里就是创建了socket,而属性值服务的本质就是一个socket（&#x2F;dev&#x2F;socket&#x2F;property_service）,最大连接为：8，持续等待连接,连接成功后决定是更新还是新增属性值，仍然是调用的<code>PropertySet</code>，继续分析一下<code>PropertyServiceThread</code>，该函数里调用了<code>handle_property_set_fd</code>函数，来看看具体实现</p>
<pre><code>static void handle_property_set_fd() &#123;
    // 设置超时:2s
    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */

    // 可以设置四个参数，所以用的是accept4,而当启用了SOCK_CLOEXEC参数后，进程在调用exec函数族时，文件描述符就会自动关闭，无需手动关闭
    int s = accept4(property_set_fd, nullptr, nullptr, SOCK_CLOEXEC);
    if (s == -1) &#123;
        return;
    &#125;
    ...
    
    switch (cmd) &#123;
    case PROP_MSG_SETPROP: &#123;
        char prop_name[PROP_NAME_MAX];
        char prop_value[PROP_VALUE_MAX];
        ...
        prop_name[PROP_NAME_MAX-1] = 0;
        prop_value[PROP_VALUE_MAX-1] = 0;
        ...
        // 当收到客户端发来的请求，去更新或新增属性值时会调用HandlePropertySet去处理
        const auto&amp; cr = socket.cred();
        std::string error;
        uint32_t result =
                HandlePropertySet(prop_name, prop_value, source_context, cr, nullptr, &amp;error);
        if (result != PROP_SUCCESS) &#123;
            LOG(ERROR) &lt;&lt; &quot;Unable to set property &#39;&quot; &lt;&lt; prop_name &lt;&lt; &quot;&#39; from uid:&quot; &lt;&lt; cr.uid
                       &lt;&lt; &quot; gid:&quot; &lt;&lt; cr.gid &lt;&lt; &quot; pid:&quot; &lt;&lt; cr.pid &lt;&lt; &quot;: &quot; &lt;&lt; error;
        &#125;

        break;
      &#125;
     ...
    &#125;
&#125;
</code></pre>
<p>可以看到设置了连接超时时间为2000ms,执行 <code>case PROP_MSG_SETPROP</code>，获取属性值的名称和值，调用<code>HandlePropertySet</code>里的<code>PropertySet</code>进行更新属性值或新增。<code>PropertySet</code>已经分析过了</p>
<blockquote>
<p>至此属性值相关就分析完毕了，简单的来说就是读取build.prop属性值共享到全局内存中让所有进程获取，然后创建属性值服务（socket），持续监听客户端（哪个进程去调用更新属性值就是当前客户端）发来的请求，最大只能同时受理8个来自客户端的请求，若有客户端请求则去更新属性值或新增属性值</p>
</blockquote>
<h4 id="6-SecondStageMain-int-argc-char-argv-—–-gt-setup-5步骤"><a href="#6-SecondStageMain-int-argc-char-argv-—–-gt-setup-5步骤" class="headerlink" title="6. SecondStageMain(int argc, char** argv)—–&gt;setup 5步骤"></a>6. SecondStageMain(int argc, char** argv)—–&gt;setup 5步骤</h4><pre><code>    // setup 5
    fs_mgr_vendor_overlay_mount_all();
</code></pre>
<p>这里的代码只要是针对如果有vendor_overlay分区，则覆盖&#x2F;vendor分区，主要看供应商的客制化</p>
<pre><code>const std::vector&lt;const std::string&gt; kVendorOverlaySourceDirs = &#123;
        &quot;/system/vendor_overlay/&quot;,
        &quot;/product/vendor_overlay/&quot;,
&#125;;

bool fs_mgr_vendor_overlay_mount_all() &#123;
    ...
    // 获取 &quot;/system/vendor_overlay/&quot;,&quot;/product/vendor_overlay/&quot;下的所有子目录
    // 将vendor_overlay挂载到vendor上，若存在该覆盖分区则会覆盖之前的vendor分区
    const auto vendor_overlay_dirs = fs_mgr_get_vendor_overlay_dirs(vndk_version);
    if (vendor_overlay_dirs.empty()) return true;
    if (fs_mgr_overlayfs_valid() == OverlayfsValidResult::kNotSupported) &#123;
        LINFO &lt;&lt; &quot;vendor overlay: kernel does not support overlayfs&quot;;
        return false;
    &#125;

    // Mount each directory in /(system|product)/vendor_overlay/&lt;ver&gt; on /vendor
    // 挂载vendor_overlay到/vendor分区上
    auto ret = true;
    for (const auto&amp; vendor_overlay_dir : vendor_overlay_dirs) &#123;
        if (!fs_mgr_vendor_overlay_mount(vendor_overlay_dir)) &#123;
            ret = false;
        &#125;
    &#125;
    return ret;
&#125;
</code></pre>
<h4 id="7-SecondStageMain-int-argc-char-argv-—–-gt-setup-6步骤"><a href="#7-SecondStageMain-int-argc-char-argv-—–-gt-setup-6步骤" class="headerlink" title="7. SecondStageMain(int argc, char** argv)—–&gt;setup 6步骤"></a>7. SecondStageMain(int argc, char** argv)—–&gt;setup 6步骤</h4><pre><code>    // setup 6
    MountHandler mount_handler(&amp;epoll);
</code></pre>
<p>该函数主要功能：持续监控<code>/proc/mounts</code> 节点<code>(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;))</code>,主要是解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等， 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息，挂载mounts信息里的分区<br>位置：&#x2F;system&#x2F;core&#x2F;init&#x2F;mount_handler.cpp</p>
<pre><code>MountHandler::MountHandler(Epoll* epoll) : epoll_(epoll), fp_(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;), fclose) &#123;
    if (!fp_) PLOG(FATAL) &lt;&lt; &quot;Could not open /proc/mounts&quot;;
    auto result = epoll-&gt;RegisterHandler(
            fileno(fp_.get()), [this]() &#123; this-&gt;MountHandlerFunction(); &#125;, EPOLLERR | EPOLLPRI);
    if (!result.ok()) LOG(FATAL) &lt;&lt; result.error();
&#125;
</code></pre>
<p>继续看一下<code>MountHandlerFunction</code>函数</p>
<pre><code>void MountHandler::MountHandlerFunction() &#123;
    rewind(fp_.get());
    std::vector&lt;MountHandlerEntry&gt; touched;
    auto untouched = mounts_; //容器类型
    char* buf = nullptr;
    size_t len = 0;
    // 循环读取文件内容中的每一行
    while (getline(&amp;buf, &amp;len, fp_.get()) != -1) &#123;
        auto buf_string = std::string(buf);
        // /proc/mounts文件下存在一系列代码
        // 若读取到/0/emulated则跳过
        if (buf_string.find(&quot;/emulated&quot;) != std::string::npos) &#123;
            continue;
        &#125;
        // 根据读取的文件内容，来解析分区以及device path,type等
        auto entry = ParseMount(buf_string);
        auto match = untouched.find(entry);
        // 若这一行解析到底了仍然没有匹配的信息，则这一条记录追加到touched中
        // entry：举例---&gt;对文件内容/dev/block/dm-33 /data_mirror/data_ce/null ext4 解析过后的实体
        if (match == untouched.end()) &#123;
            touched.emplace_back(std::move(entry));
        &#125; else &#123;
            // 若找到了匹配的信息则移除
            untouched.erase(match);
        &#125;
    &#125;
    free(buf);
    // 将匹配到的entry进行移除，并记录Mount属性值
    for (auto&amp; entry : untouched) &#123;
        SetMountProperty(entry, false);
        mounts_.erase(entry);
    &#125;
    // 将未匹配到的entry追加到mounts_，并记录Mount属性值
    for (auto&amp; entry : touched) &#123;
        SetMountProperty(entry, true);
        // emplace是更具有性能的 更新或追加
        mounts_.emplace(std::move(entry));
    &#125;
&#125;
</code></pre>
<ol>
<li>读取&#x2F;proc&#x2F;mounts，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等</li>
<li>若解析到&#x2F;0&#x2F;emulated则跳过,不处理</li>
<li>根据mounts_，当entry（解析后的内容）可以在其中找到则移除</li>
<li>若entry未在mounts_找到，则追加到mounts_中</li>
<li>相当于移除旧的entry，将新的entry追加到mounts_</li>
</ol>
<p>再看看是如何解析文件内容的<code>auto entry = ParseMount(buf_string)</code>，解析文件内容</p>
<pre><code>MountHandlerEntry ParseMount(const std::string&amp; line) &#123;
    auto fields = android::base::Split(line, &quot; &quot;);
    while (fields.size() &lt; 3) fields.emplace_back(&quot;&quot;);
    if (fields[0] == &quot;/dev/root&quot;) &#123;
        auto&amp; dm = dm::DeviceMapper::Instance();
        std::string path;
        // 根据名称获取system分区目录路径，若根据名称找不到则直接获取根目录/
        // 若找到根目录则继续找/system,若找到则拿到device path
        // 例如/system就是挂载在/dev/block/dm-1上，那么获取的就是这个玩意
        // /dev/block/dm-3 /vendor ext4 ro,seclabel,relatime 0 0
        if (dm.GetDmDevicePathByName(&quot;system&quot;, &amp;path) || dm.GetDmDevicePathByName(&quot;vroot&quot;, &amp;path)) &#123;
            fields[0] = path;
        &#125; else if (android::fs_mgr::Fstab fstab; android::fs_mgr::ReadDefaultFstab(&amp;fstab)) &#123;
            auto entry = GetEntryForMountPoint(&amp;fstab, &quot;/&quot;);
            if (entry || (entry = GetEntryForMountPoint(&amp;fstab, &quot;/system&quot;))) &#123;
                fields[0] = entry-&gt;blk_device;
            &#125;
        &#125;
    &#125;
    // 获取所有/dev目录下的device
    // readlink 是Linux系统中的一个常用命令，主要用来找出符号链接所指向的位置
    // 也就是找到devcie path：/dev/block/dm-33
    if (android::base::StartsWith(fields[0], &quot;/dev/&quot;)) &#123;
        if (std::string link; android::base::Readlink(fields[0], &amp;link)) &#123;
            fields[0] = link;
        &#125;
    &#125;
    // fields0：/dev/block/dm-33（blk_device）
    // fields1:挂载在device上的分区/文件路径：/data_mirror/cur_profiles（mount_point）
    // fields2:该分区的type类型，例如可能是ext4（fs_type）
    return MountHandlerEntry(fields[0], fields[1], fields[2]);
&#125;
</code></pre>
<p>让我们再来看看这个文件内容<br><img src="/../../../images/3bc2180a2fae46178ec412f8b01cfdce.png" alt="在这里插入图片描述">可以看出来第一列是分区挂载的位置，第二列是哪个分区，第三列属于分区格式</p>
<h4 id="8-SecondStageMain-int-argc-char-argv-—–-gt-setup-7步骤"><a href="#8-SecondStageMain-int-argc-char-argv-—–-gt-setup-7步骤" class="headerlink" title="8. SecondStageMain(int argc, char** argv)—–&gt;setup 7步骤"></a>8. SecondStageMain(int argc, char** argv)—–&gt;setup 7步骤</h4><pre><code>    // setup 7
    // 创建ActionManager对象和ServiceList对象
    ActionManager&amp; am = ActionManager::GetInstance();
    ServiceList&amp; sm = ServiceList::GetInstance();
    // 解析rc文件
    LoadBootScripts(am, sm);
</code></pre>
<ul>
<li><p>加载rc文件，保存到action manager和service list中</p>
</li>
<li><p>rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析</p>
</li>
<li><p>主要解析rc中的：service，on,Import,包含了zygote.rc,路径：&#x2F;system&#x2F;bin&#x2F;app_process64</p>
</li>
<li><p>在文件系统挂载的第一阶段，system&#x2F;vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载</p>
</li>
<li><p>rc中action的执行顺序：<code>on early-init</code>，<code>on init</code>，<code>on late-init</code>，<code>on property</code></p>
<p>static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) {<br>&#x2F;&#x2F; 创建解析器,只解析init.rc文件中的service，on,Import类型<br>&#x2F;&#x2F; action 使用 ActionParser，而 service 使用 ServiceParser 解析<br>Parser parser &#x3D; CreateParser(action_manager, service_list);<br>&#x2F;&#x2F; 获取ro.boot.init_rc属性值,此时该属性值应该是空的<br>std::string bootscript &#x3D; GetProperty(“ro.boot.init_rc”, “”);<br>if (bootscript.empty()) {<br>    &#x2F;&#x2F; 解析&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc<br>    &#x2F;&#x2F; 这里的路径就是将&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc 拷贝到out目录下<br>    parser.ParseConfig(“&#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.rc”);<br>    …<br>} else {<br>    parser.ParseConfig(bootscript);<br>}<br>}</p>
<p>Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) {<br>Parser parser;<br><br>parser.AddSectionParser(“service”, std::make_unique<ServiceParser>(<br>                                           &amp;service_list, GetSubcontext(), std::nullopt));<br>parser.AddSectionParser(“on”, std::make_unique<ActionParser>(&amp;action_manager, GetSubcontext()));<br>parser.AddSectionParser(“import”, std::make_unique<ImportParser>(&amp;parser));<br><br>return parser;<br>}</p>
</li>
</ul>
<p>可以看到只需要解析init.rc文件中的service,on,import类型</p>
<h4 id="9-SecondStageMain-int-argc-char-argv-—–-gt-setup-8步骤"><a href="#9-SecondStageMain-int-argc-char-argv-—–-gt-setup-8步骤" class="headerlink" title="9. SecondStageMain(int argc, char** argv)—–&gt;setup 8步骤"></a>9. SecondStageMain(int argc, char** argv)—–&gt;setup 8步骤</h4><pre><code>    // setup 8
    // 构建action和触发器(on early-init)，放到event_queue，等待执行函数
   ...
    am.QueueEventTrigger(&quot;early-init&quot;);
    // 构建action和触发器(on init)，放到event_queue，等待执行函数
    am.QueueEventTrigger(&quot;init&quot;);
    // 如果是充电模式则不需要挂载文件系统和不要启动核心服务
    std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;);
    if (bootmode == &quot;charger&quot;) &#123;
        am.QueueEventTrigger(&quot;charger&quot;);
    &#125; else &#123;
        am.QueueEventTrigger(&quot;late-init&quot;);
    &#125;
    // 运行所有属性触发器(action)，例如 on property
    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);
</code></pre>
<p>把action加入队列中按顺序依次执行，继续一下rc文件中做了什么动作， rc中action的执行顺序：<code>on early-init</code>，<code>on init</code>，<code>on late-init</code>，<code>on nonencrypted（启动zygote）</code>，<code>on property</code></p>
<h6 id="9-1-on-early-init"><a href="#9-1-on-early-init" class="headerlink" title="9.1. on early-init"></a>9.1. on early-init</h6><pre><code>on early-init
   ...
    mkdir /acct/uid
    # 挂载linkerconfig（动态链接器）
    mount none /linkerconfig/bootstrap /linkerconfig bind rec
    # 启动ueventd(位于/system/bin/ueventd),ueventd是init启动的第一个进程
    start ueventd
    # memory.pressure_level used by lmkd
    chown root system /dev/memcg/memory.pressure_level
    chmod 0040 /dev/memcg/memory.pressure_level
    # app mem cgroups, used by activity manager, lmkd and zygote
    mkdir /dev/memcg/apps/ 0755 system system
    mkdir /dev/memcg/system 0550 system system
    mkdir /dev/net 0755 root root
    symlink ../tun /dev/net/tun
    ...
    # 挂载tracefs，可以通过指定方式到处trace日志，分析CPU和内存相关等问题
    mount tracefs tracefs /sys/kernel/tracing gid=3012

    # create sys dirctory
    # 创建/sys目录并指定权限
    mkdir /dev/sys 0755 system system
    mkdir /dev/sys/fs 0755 system system
    mkdir /dev/sys/block 0755 system system
</code></pre>
<p>可以看到针对<code>lmkd（Low Memory Killer Daemon）</code>以及app 创建用户组，创建目录，挂载tracefs：可以通过指定方式到处trace日志，分析CPU和内存相关等问题。<br>第一个启动的核心服务是：<code>start ueventd</code>，位于&#x2F;system&#x2F;bin&#x2F;ueventd,ueventd是init启动的第一个服务进程</p>
<h6 id="9-2-on-init"><a href="#9-2-on-init" class="headerlink" title="9.2. on init"></a>9.2. on init</h6><pre><code>on init
    ...
    chmod 0775 /dev/cpuset/system-background
    chmod 0664 /dev/cpuset/foreground/tasks
    chmod 0664 /dev/cpuset/background/tasks
    chmod 0664 /dev/cpuset/system-background/tasks
    chmod 0664 /dev/cpuset/top-app/tasks
    chmod 0664 /dev/cpuset/restricted/tasks
    chmod 0664 /dev/cpuset/tasks
    chmod 0664 /dev/cpuset/camera-daemon/tasks
    # 挂载bpf
    mount bpf bpf /sys/fs/bpf nodev noexec nosuid
    mkdir /dev/fscklogs 0770 root system    
    ...
    # 允许system组读写电源状态
    chown system system /sys/power/state
    chown system system /sys/power/wakeup_count
    chmod 0660 /sys/power/state
    ...
    # 在运行其他进程之前需要先启动log服务，说明init中启动的服务，第一个启动的进程是ueventd
    start logd
    # 启用 Low Memory Killer Daemon（lmkd）
    # 1.基于Memory的CGroup进行进程的回收；2.作为frameworks与kernel的沟通桥梁传递参数与信息
    # Start lmkd before any other services run so that it can register them
    chown root system /sys/module/lowmemorykiller/parameters/adj
    chmod 0664 /sys/module/lowmemorykiller/parameters/adj
    chown root system /sys/module/lowmemorykiller/parameters/minfree
    chmod 0664 /sys/module/lowmemorykiller/parameters/minfree
    start lmkd

    # Start essential services.
    # 启用ServiceManager,管理各个服务，非常重要
    start servicemanager
    start hwservicemanager
    start vndservicemanager
</code></pre>
<p>可以看到第二个启动的核心服务是：<code>start logd</code>，日志系统。<br>第三个核心服务是：<code>start lmkd</code>，Low Memory Killer Daemon<br><strong>作用</strong>：基于Memory的CGroup进行进程的回收，作为frameworks与kernel的沟通桥梁传递参数与信息。<br>接着启动了：<code>servicemanager</code>，<code>hwservicemanager</code>，<code>vndservicemanager</code>，这些都属于核心服务<br>若核心服务未启动成功，那么其他服务将无法启动，系统将无法启动，其他服务必须依赖核心服务</p>
<h6 id="9-3-on-late-init"><a href="#9-3-on-late-init" class="headerlink" title="9.3. on late-init"></a>9.3. on late-init</h6><pre><code># 装载文件系统并启动核心系统服务
on late-init
    trigger early-fs
    # 触发on fs和on post-fs
    trigger fs
    trigger post-fs
    trigger late-fs
    trigger post-fs-data
    trigger load_persist_props_action
    trigger load_bpf_programs
    trigger zygote-start
    trigger firmware_mounts_complete
    trigger early-boot
    trigger boot
</code></pre>
<p>可以看到调用顺序为：启动系统on late-init会先执行，然后继续触发on fs，on post-fs ，on late-fs，on zygote-start ，on boot等，在调用<code>on zygote-start</code>后会解析zygote服务并指定class 名称，然后加入服务管理队列，后续等待调用<code>on nonencrypted</code>来启动zygote服务</p>
<h6 id="9-4-on-nonencrypted"><a href="#9-4-on-nonencrypted" class="headerlink" title="9.4. on nonencrypted"></a>9.4. on nonencrypted</h6><pre><code>on nonencrypted
    class_start main
    class_start late_start

目录：/system/core/rootdir/init.zygote64.rc
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    # class : 给服务指定一个类属
    class main
    priority -20
    # user 在执行此服务之前先切换用户名。当前默认为root.
    user root
    # 切换组名
    group root readproc reserved_disk
    # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程
    # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为0
    socket zygote stream 660 root system
    socket usap_pool_primary stream 660 root system
    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
    # oneshot : 当此服务退出时不会自动重启.
    # disabled:服务不会自动运行，必须显式地通过服务器来启动
    # 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。
    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal
</code></pre>
<p>可以看到通过class_start main来启动主函数main,位于：frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</p>
<pre><code>int main(int argc, char* const argv[])
&#123;
    ...
    if (zygote) &#123;
        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);
    &#125; else if (className) &#123;
        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);
    &#125; else &#123;
        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);
        app_usage();
        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);
    &#125;
&#125;
</code></pre>
<p>这里启动了zygote,并且携带参数启动了systemServer，关于zygote这里就不再详细分析了</p>
<h2 id="二-附录"><a href="#二-附录" class="headerlink" title="二. 附录"></a>二. 附录</h2><p>rc文件中的command以及触发器，action等，对应的关系如下：</p>
<pre><code>static const BuiltinFunctionMap builtin_functions = &#123;
        &#123;&quot;bootchart&quot;,               &#123;1,     1,    &#123;false,  do_bootchart&#125;&#125;&#125;,
        &#123;&quot;chmod&quot;,                   &#123;2,     2,    &#123;true,   do_chmod&#125;&#125;&#125;,
        &#123;&quot;chown&quot;,                   &#123;2,     3,    &#123;true,   do_chown&#125;&#125;&#125;,
        &#123;&quot;class_reset&quot;,             &#123;1,     1,    &#123;false,  do_class_reset&#125;&#125;&#125;,
        &#123;&quot;class_reset_post_data&quot;,   &#123;1,     1,    &#123;false,  do_class_reset_post_data&#125;&#125;&#125;,
        &#123;&quot;class_restart&quot;,           &#123;1,     1,    &#123;false,  do_class_restart&#125;&#125;&#125;,
        &#123;&quot;class_start&quot;,             &#123;1,     1,    &#123;false,  do_class_start&#125;&#125;&#125;,
        &#123;&quot;class_start_post_data&quot;,   &#123;1,     1,    &#123;false,  do_class_start_post_data&#125;&#125;&#125;,
        &#123;&quot;class_stop&quot;,              &#123;1,     1,    &#123;false,  do_class_stop&#125;&#125;&#125;,
        &#123;&quot;copy&quot;,                    &#123;2,     2,    &#123;true,   do_copy&#125;&#125;&#125;,
        &#123;&quot;copy_per_line&quot;,           &#123;2,     2,    &#123;true,   do_copy_per_line&#125;&#125;&#125;,
        &#123;&quot;domainname&quot;,              &#123;1,     1,    &#123;true,   do_domainname&#125;&#125;&#125;,
        &#123;&quot;enable&quot;,                  &#123;1,     1,    &#123;false,  do_enable&#125;&#125;&#125;,
        &#123;&quot;exec&quot;,                    &#123;1,     kMax, &#123;false,  do_exec&#125;&#125;&#125;,
        &#123;&quot;exec_background&quot;,         &#123;1,     kMax, &#123;false,  do_exec_background&#125;&#125;&#125;,
        &#123;&quot;exec_start&quot;,              &#123;1,     1,    &#123;false,  do_exec_start&#125;&#125;&#125;,
        &#123;&quot;export&quot;,                  &#123;2,     2,    &#123;false,  do_export&#125;&#125;&#125;,
        &#123;&quot;hostname&quot;,                &#123;1,     1,    &#123;true,   do_hostname&#125;&#125;&#125;,
        &#123;&quot;ifup&quot;,                    &#123;1,     1,    &#123;true,   do_ifup&#125;&#125;&#125;,
        &#123;&quot;init_user0&quot;,              &#123;0,     0,    &#123;false,  do_init_user0&#125;&#125;&#125;,
        &#123;&quot;insmod&quot;,                  &#123;1,     kMax, &#123;true,   do_insmod&#125;&#125;&#125;,
        &#123;&quot;installkey&quot;,              &#123;1,     1,    &#123;false,  do_installkey&#125;&#125;&#125;,
        &#123;&quot;interface_restart&quot;,       &#123;1,     1,    &#123;false,  do_interface_restart&#125;&#125;&#125;,
        &#123;&quot;interface_start&quot;,         &#123;1,     1,    &#123;false,  do_interface_start&#125;&#125;&#125;,
        &#123;&quot;interface_stop&quot;,          &#123;1,     1,    &#123;false,  do_interface_stop&#125;&#125;&#125;,
        &#123;&quot;load_exports&quot;,            &#123;1,     1,    &#123;false,  do_load_exports&#125;&#125;&#125;,
        &#123;&quot;load_persist_props&quot;,      &#123;0,     0,    &#123;false,  do_load_persist_props&#125;&#125;&#125;,
        &#123;&quot;load_system_props&quot;,       &#123;0,     0,    &#123;false,  do_load_system_props&#125;&#125;&#125;,
        &#123;&quot;loglevel&quot;,                &#123;1,     1,    &#123;false,  do_loglevel&#125;&#125;&#125;,
        &#123;&quot;mark_post_data&quot;,          &#123;0,     0,    &#123;false,  do_mark_post_data&#125;&#125;&#125;,
        &#123;&quot;mkdir&quot;,                   &#123;1,     6,    &#123;true,   do_mkdir&#125;&#125;&#125;,
        // TODO: Do mount operations in vendor_init.
        // mount_all is currently too complex to run in vendor_init as it queues action triggers,
        // imports rc scripts, etc.  It should be simplified and run in vendor_init context.
        // mount and umount are run in the same context as mount_all for symmetry.
        &#123;&quot;mount_all&quot;,               &#123;0,     kMax, &#123;false,  do_mount_all&#125;&#125;&#125;,
        &#123;&quot;mount&quot;,                   &#123;3,     kMax, &#123;false,  do_mount&#125;&#125;&#125;,
        &#123;&quot;perform_apex_config&quot;,     &#123;0,     0,    &#123;false,  do_perform_apex_config&#125;&#125;&#125;,
        &#123;&quot;umount&quot;,                  &#123;1,     1,    &#123;false,  do_umount&#125;&#125;&#125;,
        &#123;&quot;umount_all&quot;,              &#123;0,     1,    &#123;false,  do_umount_all&#125;&#125;&#125;,
        &#123;&quot;update_linker_config&quot;,    &#123;0,     0,    &#123;false,  do_update_linker_config&#125;&#125;&#125;,
        &#123;&quot;readahead&quot;,               &#123;1,     2,    &#123;true,   do_readahead&#125;&#125;&#125;,
        &#123;&quot;remount_userdata&quot;,        &#123;0,     0,    &#123;false,  do_remount_userdata&#125;&#125;&#125;,
        &#123;&quot;restart&quot;,                 &#123;1,     1,    &#123;false,  do_restart&#125;&#125;&#125;,
        &#123;&quot;restorecon&quot;,              &#123;1,     kMax, &#123;true,   do_restorecon&#125;&#125;&#125;,
        &#123;&quot;restorecon_recursive&quot;,    &#123;1,     kMax, &#123;true,   do_restorecon_recursive&#125;&#125;&#125;,
        &#123;&quot;rm&quot;,                      &#123;1,     1,    &#123;true,   do_rm&#125;&#125;&#125;,
        &#123;&quot;rmdir&quot;,                   &#123;1,     1,    &#123;true,   do_rmdir&#125;&#125;&#125;,
        &#123;&quot;setprop&quot;,                 &#123;2,     2,    &#123;true,   do_setprop&#125;&#125;&#125;,
        &#123;&quot;setrlimit&quot;,               &#123;3,     3,    &#123;false,  do_setrlimit&#125;&#125;&#125;,
        &#123;&quot;start&quot;,                   &#123;1,     1,    &#123;false,  do_start&#125;&#125;&#125;,
        &#123;&quot;stop&quot;,                    &#123;1,     1,    &#123;false,  do_stop&#125;&#125;&#125;,
        &#123;&quot;swapon_all&quot;,              &#123;0,     1,    &#123;false,  do_swapon_all&#125;&#125;&#125;,
        &#123;&quot;enter_default_mount_ns&quot;,  &#123;0,     0,    &#123;false,  do_enter_default_mount_ns&#125;&#125;&#125;,
        &#123;&quot;symlink&quot;,                 &#123;2,     2,    &#123;true,   do_symlink&#125;&#125;&#125;,
        &#123;&quot;sysclktz&quot;,                &#123;1,     1,    &#123;false,  do_sysclktz&#125;&#125;&#125;,
        &#123;&quot;trigger&quot;,                 &#123;1,     1,    &#123;false,  do_trigger&#125;&#125;&#125;,
        &#123;&quot;verity_update_state&quot;,     &#123;0,     0,    &#123;false,  do_verity_update_state&#125;&#125;&#125;,
        &#123;&quot;wait&quot;,                    &#123;1,     2,    &#123;true,   do_wait&#125;&#125;&#125;,
        &#123;&quot;wait_for_prop&quot;,           &#123;2,     2,    &#123;false,  do_wait_for_prop&#125;&#125;&#125;,
        &#123;&quot;write&quot;,                   &#123;2,     2,    &#123;true,   do_write&#125;&#125;&#125;,
    &#125;;
</code></pre>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>至此第二阶段就分析完毕了，一句话来总结：<code>优先保证init进程的存活率（拉高优先级），处理设备是否unlock,决定是否卸载一些分区以及调整selinux规则和权限，创建并启动属性服务（实质上就是把属性值映射到全局内存中供所有进程访问，然后在创建socket等待进程来连接 实现更新和新增属性值），继续决定是否把vendor_overlay覆盖到/vendor分区中，然后持续监控/proc/mounts,如果有分区信息加入到该文件中则挂载此分区，接着解析rc文件（创建目录，修改权限，挂载分区，启动服务进程等），根据调用顺序启动核心服务（adbd,ueventd等）以及主服务(zygote)和其他服务</code></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/启动流程/2.Android13启动流程之FirstStageMain阶段" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="一-Android系统启动基本介绍"><a href="#一-Android系统启动基本介绍" class="headerlink" title="一. Android系统启动基本介绍"></a>一. Android系统启动基本介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服</span><br><span class="line">务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init</span><br></pre></td></tr></table></figure>

<p><strong>1. Bootloader 引导</strong></p>
<p>当按下设备电源键时，最先运行的就是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=bootloader&spm=1001.2101.3001.7020">bootloader</a>（固化在ROM的程序），bootloader 的主要作用就是硬件设备（如 CPU、flash、内存）的初始化并加载到RAM，通过建立内存空间映射，为装载 Linux 内核做好准备,。如果 bootloader 在运行期间，按下预定义的组合按键，可以进入系统fastboot模式 或者 Receiver 模式。</p>
<p><strong>2. 装载和启动 Linux 内核</strong></p>
<p>在编译完<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AOSP&spm=1001.2101.3001.7020">AOSP</a>时会生成boot.img或者boot_debug.img，该镜像就是 Linux 内核和根文件系统，bootloader 会把该镜像装载到内存中，然后 linux 内核会执行整个系统的初始化，完成后装载根文件系统，最后启动 init 进程。</p>
<p><strong>3. 启动 Init 进程</strong></p>
<p>Linux 内核加载完毕后，会从kernel内核层调用到用户空间层，则会首先启动 init 进程，init 进程是系统的第一个进程，在 init 进程的启动过程中会解析最主要的 init.rc 脚本，根据 init.rc 文件的描述，系统会创建文件及目录以及权限的赋予，初始化属性和启动 Android 系统重要的守护进程。</p>
<p><strong>4. 启动 ServiceManager</strong></p>
<p>ServiceManager 由 init 进程启动。它的主要作用是管理 Binder 服务，service 服务的注册和查找，如 AMS、PMS， 都是通过 ServiceManger 来管理。</p>
<p><strong>5. 启动 MediaServer</strong></p>
<p>MediaServer 是由 init 进程启动，它包含了一些多媒体 binder 服务，包括 CameraService、MediaPlayerService、AudioPolicyService 等等</p>
<blockquote>
<p>onrestart restart audioserver<br>onrestart restart cameraserver<br>onrestart restart media<br>onrestart restart media.tuner<br>onrestart restart netd<br>onrestart restart wificond</p>
</blockquote>
<p><strong>6. 启动 Zygote 进程</strong></p>
<p>init 进程初始化结束后，会启动 Zygote 进程。在 Android 系统中所有的应用程序进程和系统服务进程都是通过Zygote 进程 fork 出来的。预装载系统的资源文件，所有从 Zygote 进程 fork 出的子进程都会共享这些资源，节省了资源加载的时间，提高的应用的启动速度。Zygote 启动结束后也会变为守护进程，负责响应启动 APK 的请求。</p>
<p><strong>7. 启动 SystemServer</strong></p>
<p>SystemServer 是跟随Zygote创建出来的第一个子进程，同时也是整个 Android 系统的核心。在系统中运行的大部分系统服务都是有 SystemServer 创建，接着会启动 AMS、WMS、PMS 等。阅读过源码可以发现大部分服务会继承自systemServer</p>
<pre><code>PD2183:/ $ ps --pid 1                                  
USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME  
root             1     0 13133644  8264 0                   0 S init
</code></pre>
<p>init进程由init_task进程fork而来，在kernel初始化完成后init_task便化身为idle进程，可以看到init的进程pid为：1<br>而init_task进程是Linux中第一个进程，也即0号进程(PID为0)，这里不进一步分析linux内核层。</p>
<h2 id="二-FirstStageMain阶段分析"><a href="#二-FirstStageMain阶段分析" class="headerlink" title="二. FirstStageMain阶段分析"></a>二. FirstStageMain阶段分析</h2><p><img src="/../../../images/image-20231129165729682.png" alt="image-20231129165729682"></p>
<p>针对super分区，在开机init的first stage第一阶段运行期间，会解析并验证metadata元数据并创建虚拟block设备来表示每个子分区，super分区头部信息就是metadata元数据，用于映射（mapping）出虚拟block设备，这里盗用一张大佬的图来看一下super结构</p>
<p><img src="/../../../images/8acb8a5c6d73423ea8c487a5f1dfffda-17012480993077.png" alt="super镜像">super分区除了包含<code>system\product\vendor</code>，在头部信息包含了描述分区布局的<code>metadata</code>，系统加载动态分区时读取metadata，对其进行解析。</p>
<p>Metadata中的信息会被转换成device mapper中的映射表Mapping Table，基于这个映射表，super分区对应设备<code>/dev/block/by-name/super</code>的不同部分被映射成多个虚拟设备，如<code>/dev/block/mapper/system_a</code> ，<code>/dev/block/mapper/vendor_a</code>等</p>
<h4 id="1-用户空间层main-cpp"><a href="#1-用户空间层main-cpp" class="headerlink" title="1. 用户空间层main.cpp"></a>1. 用户空间层main.cpp</h4><pre><code>using namespace android::init;

int main(int argc/*1*/, char** argv/*init*/) &#123; // 内核层传过来的，argc：1,argv：init
#if __has_feature(address_sanitizer)
    __asan_set_error_report_callback(AsanReportCallback);
#elif __has_feature(hwaddress_sanitizer)
    __hwasan_set_error_report_callback(AsanReportCallback);
#endif
    // Boost prio which will be restored later
    setpriority(PRIO_PROCESS, 0, -20); // 设置进程最高优先级 -20最高，20最低
    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;
        return ueventd_main(argc, argv);
    &#125;

    if (argc &gt; 1) &#123;
        if (!strcmp(argv[1], &quot;subcontext&quot;)) &#123;
            android::base::InitLogging(argv, &amp;android::base::KernelLogger);
            const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();

            return SubcontextMain(argc, argv, &amp;function_map);
        &#125;

        if (!strcmp(argv[1], &quot;selinux_setup&quot;)) &#123;
            return SetupSelinux(argv);
        &#125;

        if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123;
            return SecondStageMain(argc, argv);
        &#125;
    &#125;

    return FirstStageMain(argc, argv); //第一阶段执行
&#125;
</code></pre>
<p>内核层传过来的参数：argc：1,argv：init，所以第一阶段仍然是调用<code>return FirstStageMain(argc, argv);</code> 这里不详细介绍subcontext,ueventd，只关注FirstStageMain阶段即可，调用顺序如下</p>
<ul>
<li>FirstStageMain：主要创建和挂载基本的文件系统，挂载特定分区，启用log等</li>
<li>SetupSelinux：挂载并启用selinux权限系统，之前文章有讲过关于权限问题;</li>
<li>SecondStageMain：主要解析ini.rc文件，创建zygote孵化器，fork 进程等</li>
</ul>
<h4 id="2-FirstStageMain-int-argc-char-argv-解析"><a href="#2-FirstStageMain-int-argc-char-argv-解析" class="headerlink" title="2. FirstStageMain(int argc, char** argv)解析"></a>2. FirstStageMain(int argc, char** argv)解析</h4><p>该阶段所挂载的文件系统都属于ramdisk，运行在虚拟内存上</p>
<pre><code>//system/core/init/first_stage_init.cpp
int FirstStageMain(int argc, char** argv) &#123;
    // init阶段的启动引导加载程序（bootLoader），若发生异常重启也会再次执行，主要处理init || fork的子进程进程异常行为
    // init信号处理器，调试版本当init crash，默认重启到 bootLoader
    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;
        InstallRebootSignalHandlers();// setup1
    &#125;
    // 用来设置创建目录或文件时所应该赋予权限的掩码
    // Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755
    // 在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高
    umask(0);

    // 第一次执行时清除环境变量，reset path
    CHECKCALL(clearenv());
    CHECKCALL(setenv(&quot;PATH&quot;, _PATH_DEFPATH, 1));
    // setup 2
    // 设置linux最基本的文件系统并且挂载到 / 目录(init ram disk)上,
    // 并给0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限），后续会通过rc文件处理一些分区权限和进程
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); //将/dev设置为tmpfs并挂载，设置0755权限，tmpfs是在内存上建立的文件系统（Filesystem）
    CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//tmpfs文件系统类型
    CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));
    CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//tmpfs文件系统类型
    CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));
    // setup 3
     CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));
#undef MAKE_STR
    // 修改 「保存操作系统的启动参数」 的权限：0440，
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数
    CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));
    std::string cmdline;
    // 读取操作系统的启动参数
    android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程
    // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    chmod(&quot;/proc/bootconfig&quot;, 0440);
    std::string bootconfig;
    // 读取系统启动参数配置
    android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig);
    gid_t groups[] = &#123;AID_READPROC&#125;;
    CHECKCALL(setgroups(arraysize(groups), groups));
    // setup 4
    // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。
    // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中
    // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息
    CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL));
    CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL));
    CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11)));
    if constexpr (WORLD_WRITABLE_KMSG) &#123;
        CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11)));
    &#125;
    // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数
    CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8)));
    CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9)));
    
    // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。
    CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2)));
    CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3)));
    
    // setup 5
    // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载
    // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理
    // tmpfs之前说过了，是运作在RAM的文件系统
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=1000&quot;));
    CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755));
    CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755));
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));
    // 创建selinux驱动节点，类型属于：tmpfs
    CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744));
    // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的
    SetStdioToDevNull(argv);
    InitKernelLogging(argv);
    // log可以使用了，第一阶段正式开始 创建设备
    LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;;
    // setup 6
    // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统
    auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;;
    // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量
    // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成
    if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    // 加载kernel模块且是非正常的启动模式
    // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)，并加载kernel模块且处于非正常的启动模式
    // 再根据want_console来决定是否打开串口日志
    if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console,
                           want_parallel, module_count)) &#123;
        if (want_console != FirstStageConsoleParam::DISABLED) &#123;
            LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;;
        &#125; else &#123;
            LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;;
        &#125;
    &#125;
    // 继续根据是否打开串口日志来创建devices
    // want_console == 1
    if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;
         // 非恢复模式下进行，在 recovery 模式下不允许创建设备
        if (!IsRecoveryMode()) &#123;
            // 在创建逻辑分区之前挂载 /metadata
            // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问
            // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区
            created_devices = DoCreateDevices();
            if (!created_devices) &#123;
                LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;;
            &#125;
        &#125;
        StartConsole(cmdline);
    &#125;
    // setup 7
    // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop
    // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下
    if (access(kBootImageRamdiskProp, F_OK) == 0) &#123;
        // 获取/second_stage_resources/system/etc/ramdisk/build.prop
        // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建
        std::string dest = GetRamdiskPropForSecondStage();
         // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk
        std::string dir = android::base::Dirname(dest);
        std::error_code ec;
        if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message();
        &#125;
        // 生成 /second_stage_resources/system/etc/ramdisk/build.prop
        if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot;
                       &lt;&lt; ec.message();
        &#125;
        LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest;
    &#125;
    // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root
    // /userdebug_plat_sepolicy.cil属于selinux策略里的规则
    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限
    if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123;
        constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;;
        constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;;
        ...
        setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1);
    &#125;
    // setup 8
    // 如果内核命令行中存在 androidboot.force_normal_boot=1，则设备会正常启动，即正常启动时
    if (ForceNormalBoot(cmdline, bootconfig)) &#123;
        // 创建第一阶段ramdisk目录 /first_stage_ramdisk
        mkdir(&quot;/first_stage_ramdisk&quot;, 0755);
        // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;;
        PrepareSwitchRoot();
        if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123;
            PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;;
        &#125;
        // 将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk
        SwitchRoot(&quot;/first_stage_ramdisk&quot;);
    &#125;
    
    // 挂载 system、vendor 、product等系统分区
    if (!DoFirstStageMount(!created_devices)) &#123;
        LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;;
    &#125;
    // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root
    // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等
    struct stat new_root_info;
    if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    // 根目录发生变化，则释放old ramdisk，用new ramdisk
    if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123;
        FreeRamdisk(old_root_dir.get(), old_root_info.st_dev);
    &#125;
    // setup 8 主要内容:将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk
    // setup 9
    //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。
    // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root）,
    // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：bootloader，boot.img，system.img。
    // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过
    SetInitAvbVersionInRecovery();
    // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了
    // init程序的二进制文件目录
    const char* path = &quot;/system/bin/init&quot;;
    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux
    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区
    // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp
    execv(path, const_cast&lt;char**&gt;(args));
&#125;
</code></pre>
<p>​    具体信息可以看注释，这里我分为了11个步骤来分析，也就是对应的setup 1~10</p>
<h4 id="2-FirstStageMain-int-argc-char-argv-—–-gt-setup-1步骤"><a href="#2-FirstStageMain-int-argc-char-argv-—–-gt-setup-1步骤" class="headerlink" title="2. FirstStageMain(int argc, char** argv)—–&gt;setup 1步骤"></a>2. FirstStageMain(int argc, char** argv)—–&gt;setup 1步骤</h4><p>主要分析<code>InstallRebootSignalHandlers();// setup1</code>其关键作用：主要加载引导程序以及init阶段crash的进程处理，也就是异常处理</p>
<pre><code>// 主要加载引导程序以及init阶段crash的进程处理
//system/core/init/reboot_utils.cpp
void InstallRebootSignalHandlers() &#123;
    struct sigaction action;
    // memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作
    memset(&amp;action, 0, sizeof(action));
    // sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里即将所有的信号标志位置为1。
    // 成功返回0,反之返回1
    sigfillset(&amp;action.sa_mask);
    // 对于从init派生的进程（init进程对操作系统的意义在于，其他所有的用户进程都直接或者间接派生自init进程,例如解析init.rc出来的进程zygote）
    // 这些信号处理程序也会被捕获，但是我们不希望它们触发重新启动，所以我们在这里直接为子进程调用_exit（）
    // 针对加载引导程序或init crash后加载引导程序，不应该restart,而是直接退出 再次启动系统时重新start
    action.sa_handler = [](int signal) &#123;
        if (getpid() != 1) &#123;
            _exit(signal);
        &#125;
        // 由于init fatal || crash执行重启（所以有些机器故障会无限卡logo重启），这里执行了重启或是强制关机
        InitFatalReboot(signal); //1
    &#125;;
    action.sa_flags = SA_RESTART;
    // 设置信号处理器
    sigaction(SIGABRT, &amp;action, nullptr);
    sigaction(SIGBUS, &amp;action, nullptr);
    sigaction(SIGFPE, &amp;action, nullptr);
    sigaction(SIGILL, &amp;action, nullptr);
    sigaction(SIGSEGV, &amp;action, nullptr);
#if defined(SIGSTKFLT)
    sigaction(SIGSTKFLT, &amp;action, nullptr);
#endif
    sigaction(SIGSYS, &amp;action, nullptr);
    sigaction(SIGTRAP, &amp;action, nullptr);
&#125;
</code></pre>
<p>以上代码块的逻辑大概就是收集进程信号集，将这些异常的信号集进行特殊处理（关机或重启 触发循环卡logo等），并把这些信号标志为1，针对init进程（Pid&#x3D;1）派生出来的子进程（例如zygote）而是选择直接退出 不进一步处理，因为如果init进程重新启动后将会重新派生出原来的子进程。这里继续分析一下<code>InitFatalReboot(signal); //1</code></p>
<h5 id="2-1-InitFatalReboot-signal"><a href="#2-1-InitFatalReboot-signal" class="headerlink" title="2.1 InitFatalReboot(signal)"></a>2.1 InitFatalReboot(signal)</h5><pre><code>void __attribute__((noreturn)) InitFatalReboot(int signal_number) &#123;
    // 派生出子进程，pid == -1则代表fork进程失败
    auto pid = fork();

    // Init 是Android OS中第一个user space process（用户态或用户空间pid = 1），守护进程（在后台运行的守护进程，其一作用于执行启动的系统任务）
    // Init 进程是所有用户进程的鼻祖，Init 进程会孵化（fork，派生）出 ueventd、logd、healthd、installd、adbd、lmkd 等用户守护进程
    if (pid == -1) &#123; // 当pid==1时说明fork失败，立即执行bootloader重启，可能会重新执行到pid == 0
        // Couldn&#39;t fork, don&#39;t even try to backtrace, just reboot.
        RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target);
    &#125; else if (pid == 0) &#123; //fork成功，说明现在运行在子进程上，并且子进程需确保能重启
        sleep(5);
        RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target);
    &#125;

    // 当关机时，尝试在父进程（pid = 1，即init）中获取back trace日志
    LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: signal &quot; &lt;&lt; signal_number;
    std::unique_ptr&lt;Backtrace&gt; backtrace(
            Backtrace::Create(BACKTRACE_CURRENT_PROCESS, BACKTRACE_CURRENT_THREAD));
    if (!backtrace-&gt;Unwind(0)) &#123;
        LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Failed to unwind callstack.&quot;;
    &#125;
    for (size_t i = 0; i &lt; backtrace-&gt;NumFrames(); i++) &#123;
        LOG(ERROR) &lt;&lt; backtrace-&gt;FormatFrameData(i);
    &#125;
    // 判断init（主）进程是否被标记为异常（例如init主进程都退出了），决定是否需要重启bootLoader（正常步骤会执行到重启，异常则直接sysdump）
    // 启动内核时出现panic的几种情况：出现init进程被异常杀死，则直接触发崩溃，即进入sysdump
    if (init_fatal_panic) &#123;
        LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Trigger crash&quot;;
        // 通过#define PROC_SYSRQ &quot;/proc/sysrq-trigger&quot; 写值触发系统崩溃
        // echo b &gt; /proc/sysrq-trigger --&gt;立即重启
        // echo o &gt; /proc/sysrq-trigger --&gt;立即关机
        // echo c &gt; /proc/sysrq-trigger --&gt;立即让系统崩溃
        // echo t &gt; /proc/sysrq-trigger --&gt;导出线程状态信息
        // echo u &gt; /proc/sysrq-trigger --&gt;立即重新挂载所有的文件系统为只读
        android::base::WriteStringToFile(&quot;c&quot;, PROC_SYSRQ);
        LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Sys-Rq failed to crash the system; fallback to exit().&quot;;
        _exit(signal_number);
    &#125;
    // 在init进程上重启
    RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target);
&#125;
</code></pre>
<p>以上代码块主要作用于确保子进程，如果fork成功则代表目前运行在子进程上，目的就是一个：确保子进程能重启，如果init进程（主进程）被标记为致命异常，则会立即执行<code>android::base::WriteStringToFile(&quot;c&quot;, PROC_SYSRQ);</code>，触发死机</p>
<p><img src="/../../../images/image-20231129165843941.png" alt="image-20231129165843941"></p>
<p>至此setup 1就分析完了，总结一句话：针对异常的进程进行特殊的处理，例如让子进程确保能重启，检查init进程是否退出或产生异常，若主进程异常则直接对设备进行强制死机，进入sysdump</p>
<h4 id="3-FirstStageMain-int-argc-char-argv-—–-gt-setup-2步骤"><a href="#3-FirstStageMain-int-argc-char-argv-—–-gt-setup-2步骤" class="headerlink" title="3. FirstStageMain(int argc, char** argv)—–&gt;setup 2步骤"></a>3. FirstStageMain(int argc, char** argv)—–&gt;setup 2步骤</h4><p>setup 2主要就是初始化文件系统，我这里单独在贴一下代码：</p>
<pre><code>    // setup 2
    //将/dev设置为tmpfs文件系统并挂载，设置0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限）
    // 后续会通过rc文件处理一些分区权限和进程，tmpfs是在内存上建立的文件系统（Filesystem）
    // tmpfs文件系统是一种基于内存的文件系统，可以运行在RAM上，所以/dev都属于tmpfs文件系统
     CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); 
    CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//1
    // 关于/dev/socket目录
    // 0. tmpfs文件系统类型，例如zygote就保存到该位置（/dev/socket）
    // 1. zygote 开始循环监听 /dev/socket/zygote，system_server 与zygote 达成首次通信
    // 2. 之后AMS会且连接 /dev/socket/zygote 的socket，进行通信
    CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));//2
    CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//3
    CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));
</code></pre>
<p>这里主要初始化了基本的文件系统tmpfs，既然基于RAM，那肯定有易失性，特点如下：</p>
<ul>
<li>基于内存的文件系统</li>
<li>能够动态地使用虚拟内存</li>
<li>不需要格式化文件系统</li>
<li>tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的,其优点是读写速度很快，但存在掉电丢失的风险(ramfs与tmpfs有着对比性)，这也许就是它叫tmpfs的原故</li>
<li>由于tmpfs基于RAM，运行在内存上，因此它比硬盘的速度肯定要快，因此我们可以利用这个优点使用它来提升机器的性能（小伙伴们可以试着把tmpfs改为基于disk的文件系统试试），tmpfs 的另一个主要的好处是它闪电般的速度，因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的</li>
<li>tmpfs使用了虚拟内存的机制，它会进行swap，用例：达到空间上限时继续写入 结果：提示错误信息并终止，且tmpfs是有上限的，超过时会提示错误信息并终止 所以相比ramfs是比较安全的</li>
</ul>
<p>tmpfs和ramfs有着对比性，tmpfs是相对安全的，因为 达到空间上限时仍继续写入数据，那么提示错误信息并终止<br>而ramfs没有空间上限，会持续写入尚未分配的空间（占用其他未分配的内存）。因此tmpfs是固定大小，ramfs不固定其大小。<br>可以通过命令来查看手机系统使用的是tmpfs还是ramfs，以及他们的信息<br><code>adb shell mount | grep -E &quot;(tmpfs|ramfs)&quot;</code><br><img src="/../../../images/d30141674ffd4f67872de7ebb20587ce-17012480993079.png" alt="info">可以看到该设备使用的是tmpfs文件系统，以及可以看到属于tmpfs文件系统的分区，大小信息等,还有一个命令也可以查看，比较简约<br><code>adb shell df -h | grep -E &quot;(tmpfs|ramfs)&quot;</code><br><img src="/../../../images/cf2077e430a1481aa6d427caa4ecda63-170124809930711.png" alt="info"><br>可以看到使用的大小，&#x2F;dev &#x2F;mnt &#x2F;apex都属于tmpfs文件系统，代码里提到过关于&#x2F;dev&#x2F;socket目录，是一个比较重要的知识点，具体看注释即可</p>
<h4 id="4-FirstStageMain-int-argc-char-argv-—–-gt-setup-3步骤"><a href="#4-FirstStageMain-int-argc-char-argv-—–-gt-setup-3步骤" class="headerlink" title="4. FirstStageMain(int argc, char** argv)—–&gt;setup 3步骤"></a>4. FirstStageMain(int argc, char** argv)—–&gt;setup 3步骤</h4><p>继续贴上FirstStageMain函数里面的setup 3的代码，</p>
<pre><code>// 挂载proc文件系统（驻留在RAM中），Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种虚拟文件系统
CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));// 1
#undef MAKE_STR
    // 修改 「保存操作系统的启动参数」 的权限：0440，
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数
    CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));
    std::string cmdline;
    // 读取操作系统的启动参数
    android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程
    // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    chmod(&quot;/proc/bootconfig&quot;, 0440);
    std::string bootconfig;
    // 读取系统启动参数配置
    android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig);
    gid_t groups[] = &#123;AID_READPROC&#125;;
    CHECKCALL(setgroups(arraysize(groups), groups));
</code></pre>
<p>这里主要解释一下注释的第一点</p>
<blockquote>
<p>该目录下保存的并不是真正的文件和目录（虚拟文件系统），而是一些【运行时】的信息，如 CPU 信息、负载信息、系统内存信息、磁盘 IO 信息等。<br>存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系的硬件及当前【正在运行进程的信息】，甚至可以通过更改其中某些文件来改变内核的运行状态</p>
</blockquote>
<pre><code>/proc/cmdline         # 保存操作系统的启动参数,/proc/cmdline中保存bootloader 启动linux kernel 时 的参数
/proc/cpuinfo         # 保存CPU的相关信息。对应lscpu命令。
/proc/devices         # 系统已经加载的所有块设备和字符设备的信息。
/proc/diskstats       # 统计磁盘设备的I/O信息。
/proc/filesystems     # 保存当前系统支持的文件系统。
/proc/kcore	          # 物理内存的镜像。该文件大小是已使用的物理内存加上4K。
/proc/loadavg	      # 保存最近1分钟、5分钟、15分钟的系统平均负载。
/proc/meminfo	      # 保存当前内存使用情况。对应free命令
/proc/mounts -&gt; self/mounts	# 系统中当前挂载的所有文件系统。mount命令。
                            # mounts文件是链接到self/mounts。
/proc/partitions      # 每个分区的主设备号（major）、次设备号（minor）、包含的块（block）数目。
/proc/uptime          # 系统自上次启动后的运行时间。
/proc/version         # 当前系统的内核版本号
/proc/vmstat          # 当前系统虚拟内存的统计数据
</code></pre>
<p>所以该步骤的代码块主要代码：<code>CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));</code>和<code>android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);</code>，指定权限，若权限改变则无法正常读取，可以防止强行改变权限为a+x或777而带来的非法操作，然后读取cmdline，读取操作系统的启动参数</p>
<h4 id="4-FirstStageMain-int-argc-char-argv-—–-gt-setup-4步骤"><a href="#4-FirstStageMain-int-argc-char-argv-—–-gt-setup-4步骤" class="headerlink" title="4. FirstStageMain(int argc, char** argv)—–&gt;setup 4步骤"></a>4. FirstStageMain(int argc, char** argv)—–&gt;setup 4步骤</h4><pre><code>    // setup 4
    // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。
    // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中
    // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息
    CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL));
    // 挂载/sys/fs/selinux文件系统，也属于/sys
    // /sys/fs/selinux ： selinux机制，也就是处理selinux权限机制文件存放的位置，判断是否开启严格模式等
    CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL));
     // 创建处理日志的设备文件
    // Linux内核通过printk打印的log信息,这些log写入到了/dev/kmsg文件中,
    // 也就是kernel log,在展锐平台上可以通过python解析ylog来看到kernel log
    // 也可以在 Shell终端可以通过dmesg /dev/kmsg 命令查看这些log信息
    CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11)));
    // 如果是ud版本则继续创建kmsg_debug设备文件
    // WORLD_WRITABLE_KMSG = 1 则是ud,为0即user
    if constexpr (WORLD_WRITABLE_KMSG) &#123;
        CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11)));
    &#125;
    // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数
    // 随机数在计算中很重要。 TCP/IP 序列号、密码盐和 DNS 源端口号都依赖于随机数。
    // 在密码学中，随机性无处不在，从密钥的生成到加密系统，甚至密码系统受到攻击的方式。没有随机性，所有加密操作都是可预测的，因此不安全
    CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8)));
    CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9)));

    // This is needed for log wrapper, which gets called before ueventd runs.
    // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。
    CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2)));
    CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3)));
</code></pre>
<ol>
<li><p>上面的代码比较简单，主要就是创建随机数设备文件，所以上层可以调用random获取随机数，随机数在计算中很重要，TCP&#x2F;IP 序列号、密码盐和 DNS 源端口号都依赖于随机数，也例如加密机制，都需要用到随机数。</p>
</li>
<li><p>同时也创建了&#x2F;dev&#x2F;null设备文件，dev&#x2F;null 在Linux中是一个空设备文件，它于其他普通的设备文件不同，当往null写入数据时会被丢弃掉，它不能够被执行，所以不能使用管道符去操作它，只能通过文件重定向（&gt;,&gt;&gt;），我们可以通过把命令的输出重定向到 &#x2F;dev&#x2F;null 来丢弃脚本的全部输出</p>
</li>
<li><p>也创建了&#x2F;dev&#x2F;kmsg设备文件，主要存储日志，Shell终端可以通过dmesg &#x2F;dev&#x2F;kmsg 命令查看这些log信息<br><img src="/../../../images/74ae09adda2541acad5d9318c1de064d.png" alt="log"></p>
</li>
<li><p>在介绍一下&#x2F;sys文件系统，sysfs（常驻于RAM中）是一个伪文件系统，不占有任何磁盘空间的虚拟文件系统</p>
</li>
</ol>
<blockquote>
<p>&#x2F;sys下存放的都是设备驱动，网络环境，偏硬件的文件<br>1.&#x2F;sys&#x2F;firmware ： 固件 文件目录<br>2.&#x2F;sys&#x2F;kernel : 内核文件目录<br>3.&#x2F;sys&#x2F;module ： 内核驱动模块<br>4.&#x2F;sys&#x2F;power ： 电源相关模块<br>5.&#x2F;sys&#x2F;bus ： 驱动总线文件目录<br>6.&#x2F;sys&#x2F;block ： 块设备目录（映射的&#x2F;sys&#x2F;devices目录）<br>7.&#x2F;sys&#x2F;devices ： 设备目录（也有虚拟设备目录），例如：sys&#x2F;devices&#x2F;virtual&#x2F;block&#x2F;dm-28<br>8.&#x2F;sys&#x2F;fs&#x2F;selinux ： selinux机制，也就是处理selinux权限机制文件存放的位置，判断是否开启严格模式等</p>
</blockquote>
<h4 id="5-FirstStageMain-int-argc-char-argv-—–-gt-setup-5步骤"><a href="#5-FirstStageMain-int-argc-char-argv-—–-gt-setup-5步骤" class="headerlink" title="5. FirstStageMain(int argc, char** argv)—–&gt;setup 5步骤"></a>5. FirstStageMain(int argc, char** argv)—–&gt;setup 5步骤</h4><pre><code>    // setup 5
    // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载
    // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理
    // tmpfs之前说过了，是运作在RAM的文件系统
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=1000&quot;));
    CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755));
    CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755));
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));
    // 创建selinux驱动节点，类型属于：tmpfs
    CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744));
    // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的
    SetStdioToDevNull(argv);
    InitKernelLogging(argv);
    // log可以使用了，第一阶段正式开始 创建设备
    LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;;
</code></pre>
<p>这里的代码也比较简单，主要创建比较重要的分区，注意这里只是创建并没有挂载，&#x2F;mnt&#x2F;{vendor,product}，然后初始化kernel log,LOG日志可以正常使用和输出。</p>
<ul>
<li>vendor： 用于存放odm供应商开发的文件，例如MTK自带节点 &#x2F;mnt&#x2F;vendor&#x2F;protect_f&#x2F; 可存储恢复出厂+刷机不丢失数据</li>
<li>product：根据不同的项目，存放项目中不同的内容，例如APK位置等</li>
<li>mnt ： 此目录主要是作为挂载点使用，例如挂载&#x2F;mnt&#x2F;sdcard</li>
</ul>
<h4 id="6-FirstStageMain-int-argc-char-argv-—–-gt-setup-6步骤"><a href="#6-FirstStageMain-int-argc-char-argv-—–-gt-setup-6步骤" class="headerlink" title="6. FirstStageMain(int argc, char** argv)—–&gt;setup 6步骤"></a>6. FirstStageMain(int argc, char** argv)—–&gt;setup 6步骤</h4><pre><code>   // setup 6
    // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统
    auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;;
    // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量
    // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成
    if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)，
    // 并加载kernel模块且处于非正常的启动模式，根据want_console来决定是否打开串口日志
    if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console,
                           want_parallel, module_count)) &#123;
        if (want_console != FirstStageConsoleParam::DISABLED) &#123;
            LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;;
        &#125; else &#123;
            LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;;
        &#125;
    &#125;
    // 继续根据是否打开串口日志来创建devices
    // want_console == 1
    if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;
         // 非恢复模式下进行，在 recovery 模式下不允许创建设备
        if (!IsRecoveryMode()) &#123;
            // 在创建逻辑分区之前挂载 /metadata
            // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问
            // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区
            created_devices = DoCreateDevices();// 1
            if (!created_devices) &#123;
                LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;;
            &#125;
        &#125;
        StartConsole(cmdline);
    &#125;
</code></pre>
<p>这里的代码主要是打开串口log（可选），在手机无法开机的情况下会抓串口log来分析问题。这里挂载了&#x2F;metadata,metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问，在文章开头也提到过metadata分区，这里会挂载和创建metadata里的设备文件，感兴趣的可以进一步去了解，挂载&#x2F;metadata的前提条件是必须有根目录“&#x2F;” 或 &#x2F;system，否则，切换根目录后无法访问ramdisk（后续会把old ramdisk切换到new ramdisk,切换后的新根目录会还原默认权限）</p>
<h4 id="7-FirstStageMain-int-argc-char-argv-—–-gt-setup-7步骤"><a href="#7-FirstStageMain-int-argc-char-argv-—–-gt-setup-7步骤" class="headerlink" title="7. FirstStageMain(int argc, char** argv)—–&gt;setup 7步骤"></a>7. FirstStageMain(int argc, char** argv)—–&gt;setup 7步骤</h4><pre><code>    // setup 7
    // 判断文件是否存在，并判断文件是否可写:/system/etc/ramdisk/build.prop
    // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop
    // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下
    if (access(kBootImageRamdiskProp, F_OK) == 0) &#123;
        // 获取/second_stage_resources/system/etc/ramdisk/build.prop
        // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建
        std::string dest = GetRamdiskPropForSecondStage();
        // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk
        std::string dir = android::base::Dirname(dest);
        std::error_code ec;
         // 创建/second_stage_resources/system/etc/ramdisk目录
        if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message();
        &#125;
         // 拷贝 /system/etc/ramdisk/build.prop文件到 /second_stage_resources/system/etc/ramdisk
        // 生成 /second_stage_resources/system/etc/ramdisk/build.prop
        if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot;
                       &lt;&lt; ec.message();
        &#125;
        LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest;
    &#125;
    // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root
    // /userdebug_plat_sepolicy.cil属于selinux策略里的规则
    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限
    if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123;
        constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;;
        constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;;
        ...
        setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1);
    &#125;
</code></pre>
<p><img src="/../../../images/1bd0359ac89b4091a7c8ba09d1377dc8.png" alt="img"><br>setup7的代码片段主要讲解了获取ramdis下的prop属性值，为了第二阶段做准备，一句话来说就是创建了second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk目录文件，然后把&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop复制到上面的目录下，得到：&#x2F;second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop。<br>针对已经unlock了的设备加载特定的selinux规则，以放大权限，使得只读分区可以写入数据</p>
<h4 id="8-FirstStageMain-int-argc-char-argv-—–-gt-setup-8步骤"><a href="#8-FirstStageMain-int-argc-char-argv-—–-gt-setup-8步骤" class="headerlink" title="8. FirstStageMain(int argc, char** argv)—–&gt;setup 8步骤"></a>8. FirstStageMain(int argc, char** argv)—–&gt;setup 8步骤</h4><pre><code>    // setup 8
    // 如果是正常启动模式则创建 /first_stage_ramdisk目录作为根目录，把之前的根目录切换掉
    // 因为之前都是基于根目录创建文件系统，放大了权限，将old根目录切换到first_stage_ramdisk后
    // 将会在first_stage_ramdisk根目录把权限恢复到默认，例如old根目录部分文件系统是777权限，切换到first_stage_ramdisk根目录后
    // 权限会放低，会给一个安全的权限，判断是否是正常启动可以通过该属性值判断：androidboot.force_normal_boot
    if (ForceNormalBoot(cmdline, bootconfig)) &#123;
        // 创建第一阶段ramdisk目录 /first_stage_ramdisk
        mkdir(&quot;/first_stage_ramdisk&quot;, 0755);
        // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;;
        PrepareSwitchRoot();
        // 挂载/first_stage_ramdisk目录
        if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123;
            PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;;
        &#125;
        // 将根目录（/）切换为 (/first_stage_ramdisk) 
        // 将根切换到 first_stage_ramdisk
        SwitchRoot(&quot;/first_stage_ramdisk&quot;);
    &#125;
    
    // 挂载 system、vendor 、product等系统分区，1
    if (!DoFirstStageMount(!created_devices)) &#123;
        LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;;
    &#125;
    
    // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root
    // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等
    struct stat new_root_info;
    if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    
    // 如果新的根目录已经创建，则释放old ramdisk，用new ramdisk
    if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123;
        FreeRamdisk(old_root_dir.get(), old_root_info.st_dev);
    &#125;
</code></pre>
<p>如果是正常启动模式则创建 &#x2F;first_stage_ramdisk目录作为根目录，把之前的根目录切换掉，因为之前都是基于根目录创建文件系统，放大了权限，将old根目录切换到first_stage_ramdisk后，将会把first_stage_ramdisk根目录把权限恢复到默认（相对较低的权限），假设old根目录部分文件系统是777权限，切换到<code>/first_stage_ramdisk</code>根目录后，权限会放低（0755），会给一个安全的权限，如果文件权限给太高，是非常危险的，此后会将system、vendor 、product等系统分区挂载到新根目录上。</p>
<blockquote>
<p>必须执行的一步：如果新的根目录已经创建，则释放old ramdisk，用new ramdisk，再将system、vendor 、product等系统分区挂载到&#x2F;first_stage_ramdisk上</p>
</blockquote>
<p>这里再跟一下DoFirstStageMount函数</p>
<h5 id="8-1-DoFirstStageMount"><a href="#8-1-DoFirstStageMount" class="headerlink" title="8.1 DoFirstStageMount"></a>8.1 DoFirstStageMount</h5><p>该方法位于&#x2F;system&#x2F;core&#x2F;init&#x2F;first_stage_mount.cpp#DoFirstStageMount</p>
<pre><code>// 装载设备树中fstab指定的分区
bool DoFirstStageMount(bool create_devices) &#123;
    // 如果处于恢复模式，则跳过第一阶段装载
    if (IsRecoveryMode()) &#123;
        LOG(INFO) &lt;&lt; &quot;First stage mount skipped (recovery mode)&quot;;
        return true;
    &#125;

    auto fsm = FirstStageMount::Create();// 1
    if (!fsm.ok()) &#123;
        LOG(ERROR) &lt;&lt; &quot;Failed to create FirstStageMount &quot; &lt;&lt; fsm.error();
        return false;
    &#125;

    if (create_devices) &#123;
        if (!(*fsm)-&gt;DoCreateDevices()) return false;// 2
    &#125;

    return (*fsm)-&gt;DoFirstStageMount();
&#125;
</code></pre>
<p>先看第一点 <code>auto fsm = FirstStageMount::Create();</code>，该方法主要用于AVB校验，AVB校验可以去看看google文档</p>
<pre><code>Result&lt;std::unique_ptr&lt;FirstStageMount&gt;&gt; FirstStageMount::Create() &#123;
        // 读取fstab,file system table,里面包含了要挂载的逻辑分区
    auto fstab = ReadFirstStageFstab();
    if (!fstab.ok()) &#123;
        return fstab.error();
    &#125;
    // 判断device tree（fstabl）中是否有vbmeta/compatible结构，值是android,vbmeta
    // 创建FirstStageMountVBootV1或者FirstStageMountVBootV2实例，取决于	
    // IsDtVbmetaCompatible(fstab)的返回值，如果支持vbmeta，则使用FirstStageMountVBootV2,反之FirstStageMountVBootV1
    if (IsDtVbmetaCompatible(*fstab)) &#123;
        return std::make_unique&lt;FirstStageMountVBootV2&gt;(std::move(*fstab));
    &#125; else &#123;
        return std::make_unique&lt;FirstStageMountVBootV1&gt;(std::move(*fstab));
    &#125;
&#125;
</code></pre>
<p>以上主要是创建V1或者V2版本的AVB校验，AVB校验主要是针对分区进行校验，对于要启动的 Android 版本中包含的所有可执行代码和数据，启动时验证均要求在使用前以加密形式对其进行验证。包括内核（从 boot 分区加载）、设备树（从 dtbo 分区加载）、system 分区和 vendor 分区等</p>
<ul>
<li>对于 boot 和 dtbo 这类仅读取一次的小分区，通常是通过将整个内容加载到内存中，然后计算其哈希值来进行验证</li>
<li>内存装不下的较大分区（如文件系统）可能会使用哈希树；</li>
<li>如果在某个时刻计算出的根哈希值与预期根哈希值不一致，系统便不会使用相应数据，无法启动Android</li>
<li>在工作上遇到过开发者模式下OEM无法打开的情况，跟代码才发现开启OEM时会把persist分区文件里的指定位置上写入值（忘记值是多少了），通过解析该分区文件，写入的数据会以十六进制保持到指定位置上。但是瞬间就会把OEM的开关站位信息给擦除了，通过log看该分区文件是启用了RPMB分区安全保护机制</li>
</ul>
<p>我们继续看第二点<code>if (!(*fsm)-&gt;DoCreateDevices()) return false;</code></p>
<pre><code>bool FirstStageMount::DoFirstStageMount() &#123;
    // 如果fstab(设备树)为空则不执行挂载动作
    // Fstab是内核在启动时用来挂载文件系统的文件系统表
    if (!IsDmLinearEnabled() &amp;&amp; fstab_.empty()) &#123;
        // Nothing to mount.
        LOG(INFO) &lt;&lt; &quot;First stage mount skipped (missing/incompatible/empty fstab in device tree)&quot;;
        return true;
    &#125;

    // 挂载分区详细步骤
    if (!MountPartitions()) return false;

    return true;
&#125;
</code></pre>
<p>详细逻辑都在<code>MountPartitions</code>里面，继续跟着看看，该内容比较长</p>
<pre><code>bool FirstStageMount::MountPartitions() &#123;
    // 将system分区挂载到设备的“/”根目录
    if (!TrySwitchSystemAsRoot()) return false;
    
    if (!SkipMountingPartitions(&amp;fstab_, true /* verbose */)) return false;
    
    // 读取fstab（设备树，product,vendor等逻辑分区），并把其中的逻辑分区进行挂载
    for (auto current = fstab_.begin(); current != fstab_.end();) &#123;
        // 跳过/system,因为已经挂载上了
        if (current-&gt;mount_point == &quot;/system&quot;) &#123;
            ++current;
            continue;
        &#125;
        // 跳过overlay，稍后后挂载它，OverlayFS是新引入的机制，感兴趣的自行了解
        // 当我们adb remount分区时，本来是可以直接把vendor改rw权限，但是引入overlayfs后仍然时只读权限
        // 因为分为了2层，能读写的始终在第一层，第二层仍然保留了原始的权限，保留其原子性
        if (current-&gt;fs_type == &quot;overlay&quot;) &#123;
            ++current;
            continue;
        &#125;
        
        // flash相关，不太清楚
        if (current-&gt;fs_type == &quot;emmc&quot;) &#123;
            ++current;
            continue;
        &#125;

        // 挂载fstab里的所有逻辑分区（例如：system，system_ext,vendor,product）
        Fstab::iterator end;
        if (!MountPartition(current, false /* erase_same_mounts */, &amp;end)) &#123;
            if (current-&gt;fs_mgr_flags.no_fail) &#123;
                LOG(INFO) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point
                          &lt;&lt; &quot;, ignoring mount for no_fail partition&quot;;
            &#125; else if (current-&gt;fs_mgr_flags.formattable) &#123;
                LOG(INFO) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point
                          &lt;&lt; &quot;, ignoring mount for formattable partition&quot;;
            &#125; else &#123;
                PLOG(ERROR) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point;
                return false;
            &#125;
        &#125;
        current = end;
    &#125;
    ...
    // 如果在fstab中没有看到/system或/，那么我们需要为overlayfs创建一个根目录/system或“/”
    if (!GetEntryForMountPoint(&amp;fstab_, &quot;/system&quot;) &amp;&amp; !GetEntryForMountPoint(&amp;fstab_, &quot;/&quot;)) &#123;
        FstabEntry root_entry;
        if (GetRootEntry(&amp;root_entry)) &#123;
            fstab_.emplace_back(std::move(root_entry));
        &#125;
    &#125;

    // 为overlayfs实例化设备文件,将vendor,product,data分区等实例化到该设备文件中
    // 例如/dev/block/dm-33设备文件上挂载的是/data，此时会有dm-verity来验证数据，比如root后更改了设备文件，那校验则会不通过，造成无法开机
    // dm-verity 是一个虚拟块设备，专门用于文件系统的校验，fs直接交互的设备是dm-verity，dm-verity调用真正的块驱动去读取对应的块（dm-verity读取dm-xxx）
    //   /dev/block/dm-3                94M  94M  300K 100% /vendor
    //   /dev/block/dm-2               1.5G 1.5G  4.8M 100% /product
    //   /dev/block/dm-1               166M 165M  508K 100% /system_ext
    //   /dev/block/dm-33              5.8G 609M  5.2G  11% /data
    auto init_devices = [this](std::set&lt;std::string&gt; devices) -&gt; bool &#123;
        for (auto iter = devices.begin(); iter != devices.end();) &#123;
            if (android::base::StartsWith(*iter, &quot;/dev/block/dm-&quot;)) &#123;
                if (!block_dev_init_.InitDmDevice(*iter)) &#123;
                    return false;
                &#125;
                iter = devices.erase(iter);
            &#125; else &#123;
                iter++;
            &#125;
        &#125;
        return InitRequiredDevices(std::move(devices));
    &#125;;
    MapScratchPartitionIfNeeded(&amp;fstab_, init_devices);

    // 再次挂载fstab_里面的全部逻辑分区，也就是overlayfs机制（adb remount也是靠这个机制实现的）
    // 再次声明将只读分区修改为可读写后，写入修改后的分区内容会保存到upperdir上，而不是直接修改其底层分区数据
    // 以保证overlayfs文件操作原子性，这里再次挂载了fstab里的所有逻辑分区，那岂不是重复了？其实这里再次挂载只是一个merged（合并）操作
    fs_mgr_overlayfs_mount_all(&amp;fstab_);

    return true;
&#125;
</code></pre>
<p>以上主要挂载了fstab(设备树)下的所有逻辑分区并实例化到对应的&#x2F;dev&#x2F;block&#x2F;dm-xx设备文件上，例如挂载了：system,system_ext,vendor,product，还有挂载了overlay，overlay机制是用于保护分区原子性和分区安全而存在，具体可以自行了解一下，注释里也解释了一些，代码里两次挂载了fstab下的逻辑分区，第二次挂载是因为overlay机制的影响，是为了合并两个名称相同的分区，这里上一张图片来观察分区挂载的设备文件和位置<br><img src="/../../../images/9fe6c0c9d9d140f68110e5043127eedf.png" alt="img">可以观察到vendor.img镜像被挂载到了&#x2F;vendor分区上，使用的设备文件是<code>/dev/block/dm-3</code></p>
<h4 id="9-FirstStageMain-int-argc-char-argv-—–-gt-setup-9-x2F-10步骤"><a href="#9-FirstStageMain-int-argc-char-argv-—–-gt-setup-9-x2F-10步骤" class="headerlink" title="9. FirstStageMain(int argc, char** argv)—–&gt;setup 9&#x2F;10步骤"></a>9. FirstStageMain(int argc, char** argv)—–&gt;setup 9&#x2F;10步骤</h4><pre><code>        // setup 9
    //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。
    // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root，则会被dm-verity检测到）,
    // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：boot![]()loader，boot.img，system.img。
    // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过
    SetInitAvbVersionInRecovery();
    // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了
    // init程序的二进制文件目录
    const char* path = &quot;/system/bin/init&quot;;
    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux
    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区
    // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp
    execv(path, const_cast&lt;char**&gt;(args));
</code></pre>
<p><code>SetInitAvbVersionInRecovery</code>里的步骤也是读取fstab，然后根据<code>IsDtVbmetaCompatible</code>是否支持AVB2.0,来进行处理，setup 10就是进入下一个阶段了（SetupSelinux）</p>
<h2 id="三-FirstStageMain阶段总结"><a href="#三-FirstStageMain阶段总结" class="headerlink" title="三. FirstStageMain阶段总结"></a>三. FirstStageMain阶段总结</h2><p>以上所有的代码和步骤：根据main.cpp来启用第一阶段<code>FirstStageMain</code>，挂载最基本的文件系统，该文件系统是运行于RAM上的，优点是相比disk磁盘来说运行速度快，不占存储空间，特点是易失性，断电即丢失，挂载上最基本的文件系统后会根据根目录”&#x2F;“来挂载&#x2F;mnt&#x2F;{vendor,product}等重要的分区，其他不重要的文件挂载在第二阶段rc中处理，生成 &#x2F;second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop,该文件会在第二阶段使用，在第一阶段并开启kernel log，挂载&#x2F;first_stage_ramdisk新的根目录，根据设备树（fstab）来创建逻辑分区system，system_ext,vendor,product并挂载到&#x2F;first_stage_ramdisk根目录上，然后将old 根目录切换到&#x2F;first_stage_ramdisk 根目录，释放old根目录，&#x2F;first_stage_ramdisk根目录将赋予较为安全的权限，创建AVB数据校验，启用overlayfs机制来保护分区原子性，初始化恢复模式下的AVB校验方案，然后调用<code>&quot;/system/bin/init&quot;</code>进入下一个阶段：selinux_setup </p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/启动流程/1.android13启动流程之SeLinux权限介绍" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">启动流程</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> 本章讲解的方向和你将收获的知识：</p>
<ul>
<li>什么是SeLinux系统，SeLinux的简介和介绍</li>
<li>SeLinux系统的主要作用和存在的意义，是基于哪个版本开始推行该方案的</li>
<li>如果遇到了SeLinux权限问题该如何解决，有几种解决方案</li>
<li>SeLinux详细内容知识分解，你将了解宽松模式和严格模式</li>
</ul>
<h3 id="一-SeLinux介绍"><a href="#一-SeLinux介绍" class="headerlink" title="一. SeLinux介绍"></a>一. SeLinux介绍</h3><ol>
<li><p>SeLinux 全称 Security-Enhanced Linux 即安全增强型 Linux，基于MAC机制的一种实现，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统，这不是android特有的特性，而是由Linux衍生过来的SEAndroid。</p>
</li>
<li><p>在Android Q版本上就开始推行SeLinux机制且强行执行此机制（沙盒机制，只能获取到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AOSP&spm=1001.2101.3001.7020">AOSP</a>指定的对外的接口去获取），所以在之前很多应用在Android Q上会产生很多权限相关的问题。</p>
</li>
<li><p>如果在<strong>Android Q或以上的版本遇到权限问题</strong>，尝试命令：<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020">adb</a> shell logcat | grep avc，如果有对应的avc log输出则大概率是受SeLinux权限影响</p>
<blockquote>
<p>avc: denied { <strong>read</strong> } for pid&#x3D;1834 comm&#x3D;“gps_location” name&#x3D;“mmcblk0p17” dev&#x3D;“tmpfs”<br>scontext&#x3D;u:r:gps_location:s0 tcontext&#x3D;u:object_r:block_device:s0 tclass&#x3D;blk_file permissive&#x3D;0</p>
</blockquote>
</li>
<li><p><strong>SeLinux关键字介绍</strong><br>MAC和DAC都隶属于访问控制类，分为自主和强制两种方式<br><img src="/../../../../images/image-20240122103754370.png" alt="image-20240122103754370"></p>
</li>
<li><p>4.1 <strong>访问控制</strong><br>Linux 内核资源访问控制分为 DAC（Discretionary Access Control，自主访问控制）和 MAC（Mandatory<br>Access Control，强制访问控制)两类<br>4.2 <strong>DAC</strong><br>这是基于用户-用户组的读、写、执行的权限检查，该管理过于宽松，如果获得 root 权限，可以在 Linux 系统内做任何事情<br>4.3 <strong>MAC</strong><br>SELinux是 MAC 机制的一种实现，基于安全上下文和安全策略的安全机制，用于补充 DAC 检查。访问系统资源时，会先进行 DAC 检查，DAC 检查通过，才能进行 MAC 检查，如果 MAC 检查通过，才能获得访问权限</p>
</li>
</ol>
<h3 id="二-SeLinux基础知识"><a href="#二-SeLinux基础知识" class="headerlink" title="二. SeLinux基础知识"></a>二. SeLinux基础知识</h3><blockquote>
<p><strong>SELinux 分为 Permissive 和 Enforcing 两种模式</strong></p>
</blockquote>
<ol>
<li><p>Permissive 宽容模式<br>宽容模式，代表 SELinux 运作中，违反 SELinux 规则时只会有警告讯息（avc denied），而不会实际限制的访问.<br>在 Permissive 模式中，SELinux 被启用，但安全策略规则并没有被强制执行。当安全策略规则应该拒绝访问时，访问仍然被允许。然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝（avc）.</p>
</li>
<li><p>Enforcing 严格模式<br>在 Enforcing 模式中， SELinux 被启动，并强制执行所有的安全策略规则，代表 SELinux 运作中，违反 SELinux 规则的行为将被阻止并记录到日志中(avc)</p>
</li>
<li><p>查看当前SELinux模式<br>（1）通过adb命令行来查看：adb shell getenforce，输出结果—&gt;Enforcing 或者 Permissive<br>（2）通过adb logcat命令行来观察：adb logcat | grep avc</p>
<blockquote>
<p>avc:denied {write setter} for path&#x3D;”&#x2F;dev&#x2F;…” dev&#x3D;”tmpfs”<br>scontext&#x3D;u:r:system_server:s0 tcontext&#x3D;u:object_r:file:s0 <em><strong>permissive&#x3D;1</strong></em><br>(permissive&#x3D;1，说明是 Permissive 模式。permissive&#x3D;0，说明是 Enforcing 模式)</p>
</blockquote>
</li>
<li><p>avc权限语法介绍</p>
<blockquote>
<p>avc: denied { read } for pid&#x3D;1834 comm&#x3D;“system_server” name&#x3D;“mmcblk0p17” dev&#x3D;“tmpfs” ino&#x3D;10268 <strong>[scontext&#x3D;u:r:system_server:s0]</strong> <strong>[tcontext&#x3D;u:object_r:block_device:s0]</strong> tclass&#x3D;blk_file permissive&#x3D;0</p>
</blockquote>
<p>（此 AVC log 说明 system_server（进程）缺少对标签为 block_device、类型为 blk_file 和名称为 mmcblk0p17 文件的 read 权限）<br>(1). avc: denied：表示当前操作被拒绝。<br>(2). { read }：表示被拒绝的操作，{ }中含有实际尝试的操作。<br>(3). for pid&#x3D;1834：当前发生 avc: denied 进程的 ID。<br>(4). comm&#x3D;“system_server”：当前发生 avc: denied 进程的名称，即主体进程名称。<br>(5). name&#x3D;“mmcblk0p17”：操作尝试的目标文件或目录的路径，即客体资源名称。<br>(6). dev&#x3D;“tmpfs”：含有这个文件系统的设备节点，客体资源在该文件系统中。<br>(7). ino&#x3D;10268：目标文件或目录的节点号。<br>(8). scontext&#x3D;u:r:system_server:s0：主体进程的安全上下文。<br>(9). tcontext&#x3D;u:object_r:block_device:s0：客体资源的安全上下文。<br>(10). tclass&#x3D;blk_file：访问资源所属类别。<br>(11). permissive&#x3D;0：当前是 Enforcing 模式，permissive&#x3D;1 时为 Permissive 模式</p>
</li>
</ol>
<h3 id="三-解决SeLinux权限问题"><a href="#三-解决SeLinux权限问题" class="headerlink" title="三. 解决SeLinux权限问题"></a>三. 解决SeLinux权限问题</h3><p>1.命令行修改权限模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root;   </span><br><span class="line">adb shell setenforce <span class="number">0</span> ---&gt;设置为Permissive宽松模式，临时关闭SELinux，机器重启以后还是会恢复的</span><br></pre></td></tr></table></figure>

<p>2.AndroidManifest.xml配置开关<br>需要注意targetSdkVersion 需要小于 30</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于控制应用在Android 10及更高版本上的外部存储行为</span></span><br><span class="line">android:requestLegacyExternalStorage=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>3.修改init启动过程中的代码<br>这种方式比较简单—&gt;修改 system&#x2F;core&#x2F;init&#x2F;selinux.cpp 文件里的 IsEnforcing()函数,直接让它返回false即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEnforcing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ALLOW_PERMISSIVE_SELINUX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">StatusFromProperty</span>() == SELINUX_ENFORCING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelinuxSetEnforcement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getenforce获取Enforcing模式</span></span><br><span class="line">    <span class="type">bool</span> kernel_enforcing = (<span class="built_in">security_getenforce</span>() == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 直接让is_enforcing返回false即关闭严格模式</span></span><br><span class="line">    <span class="type">bool</span> is_enforcing = <span class="built_in">IsEnforcing</span>();</span><br><span class="line">    <span class="keyword">if</span> (kernel_enforcing != is_enforcing) &#123;</span><br><span class="line">        <span class="comment">// 调用security_setenforce(false)设置为Permissive宽容模式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">security_setenforce</span>(is_enforcing)) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;security_setenforce(&quot;</span> &lt;&lt; (is_enforcing ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>)</span><br><span class="line">                        &lt;&lt; <span class="string">&quot;) failed&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">WriteFile</span>(<span class="string">&quot;/sys/fs/selinux/checkreqprot&quot;</span>, <span class="string">&quot;0&quot;</span>); !result.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Unable to write to /sys/fs/selinux/checkreqprot: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.根据报错的权限添加SELinux权限<br>由于缺少 SELinux 权限导致如下“avc: denied”，需要根据 AVC log 信息添加相应权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avc: denied &#123; read write &#125; <span class="keyword">for</span> pid=<span class="number">3483</span> comm=“batteryTest” name=“rtc0” </span><br><span class="line">dev=“tmpfs” scontext=u:r:system_server:s0 tcontext=u:object_r:custom_battery_device:s0 </span><br><span class="line">tclass=chr_file permissive=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>system_server（进程）缺少对标签为 custom_battery_device、类型为 chr_file 和名称为 rtc0 文件节点的读写权限。<br>根据上面缺少的avc添加所需的读写权限：<br>(1). 打开&#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;{scontext.te}(system_server.te)文件<br>(2). 添加如下代码：<code>和上面的标签对应上：&#123;allow scontext tcontext:tclass permission &#125;</code><br>(3). 例如<code>allow system_server custom_battery_device:chr_file &#123;read write&#125;</code> ,编译源码并进行烧录即可</p>
<h3 id="四-Neverallow问题"><a href="#四-Neverallow问题" class="headerlink" title="四. Neverallow问题"></a>四. Neverallow问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">添加了selinux权限后，代码进行编译时，编译失败并报 neverallow 错误，例如添加`allow system_app sysfs:file &#123;write&#125;;`权限后</span><br><span class="line">  编译报错</span><br><span class="line"></span><br><span class="line">原因是 Google 不允许应用进程写 sysfs 类型的文件，这是Google规范，安全考虑，部分权限不允许给，</span><br><span class="line">当然也可以修改domain.te来修改Google的规范，虽然可以解决问题，但是这是不被允许的，在送测的时候会导致GMS测试失败。</span><br><span class="line"></span><br><span class="line">例如domain.te拥有以下代码：</span><br><span class="line">neverallow &#123; appdomain -bluetooth -nfc &#125;sysfs:dir_file_class_set write</span><br><span class="line">那么则不允许给dir_file_class_set标签赋予write权限。</span><br><span class="line"></span><br><span class="line">那又必须要这个权限怎么办？那就可以客制化SELiunx权限。</span><br></pre></td></tr></table></figure>

<h3 id="五-SELinux权限客制化（自定义权限）"><a href="#五-SELinux权限客制化（自定义权限）" class="headerlink" title="五. SELinux权限客制化（自定义权限）"></a>五. SELinux权限客制化（自定义权限）</h3><p>根据上面所说，Google规则需遵守，部分权限不允许通过，所以需要自定义权限规则.</p>
<ul>
<li><p>type定义<br>type分为了<code>property.te</code>、<code>file.te</code>、<code>system.te</code>，有很多类型，不止这三种，使用哪个文件取决于avc权限中的tclass属性，目前只用file.te举例，打开file.te添加如下type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/system/sepolicy/<span class="keyword">private</span>/file.te</span><br><span class="line"># &#123;parameter1，parameter2，parameter3&#125;</span><br><span class="line"><span class="meta"># type固定格式，custom_battery_file自定义的名称，file_type定义为文件类型</span></span><br><span class="line"># 逗号分割，后面可以继续跟类型 例如：data_file_type</span><br><span class="line">type custom_battery_file, file_type;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置安全上下文<br>安全上下文分为了 <code>genfs_contexts</code>、<code>file_contexts</code>、<code>property_contexts</code> ，当然不止这几种，例举了一些常用的<br>打开 &#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;file_contexts 文件，打开哪个文件取决于avc权限中的tclass属性<br>（三个xxx_contexts，需要自行判断缺少的权限的客体资源是目录还是文件 或是 属性值）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/system/sepolicy/<span class="keyword">private</span>/file_contexts</span><br><span class="line"># 添加如下代码</span><br><span class="line"># 第一个参数写文件节点（读取这个文件节点没权限，就添加这个节点）</span><br><span class="line"># 第二个参数固定写法u:object_r:custom_battery_file（这里写file.te里定义的类型）:s0（这些参数不做详细解释）</span><br><span class="line">/vendor/custom/product/battery	u:object_r:custom_battery_file:s0</span><br></pre></td></tr></table></figure>


<p>&#x2F;xxx&#x2F;xxx (目标文件路径或文件) u:object_r:file.te里面自定义的名称:s0</p>
</li>
<li><p>配置原进程访问权限<br>根据avc log中的scontext（主体进程）的值来决定在哪个文件下添加访问权限<br>例如 <code>scontext=u:r:system_server:s0</code>，那则打开system_server.te即可</p>
<pre><code>/system/sepolicy/private/system_server.te
# 1.allow固定格式 
# 2.system_server固定格式取决于scontext的值  
# 3.custom_battery_file（file.te里自定义的类型）
# 4.冒号后面的file，取决于avc log中的tclass类型是什么（例如tclass=file）
# 5.&#123;要给的权限类型&#125;
allow system_server custom_battery_file:file &#123;read open&#125;;
</code></pre>
<p>这样就客制化好了一个节点的写权限</p>
</li>
</ul>
<h3 id="六-补充知识（mls规则）"><a href="#六-补充知识（mls规则）" class="headerlink" title="六. 补充知识（mls规则）"></a>六. 补充知识（mls规则）</h3><p>终端中查看安全上下文的方法<br>在终端中，可通过如下指令查看文件安全上下文：ls -lZ<br>在终端中，可通过如下指令查看属性安全上下文：getprop -Z<br>在终端中，可通过如下指令查看进程安全上下文：ps -Z</p>
<blockquote>
<p>如果 te 文件已经添加 SELinux 权限，但没有生效，查看 AVC log 信息出现“s0:c512,c768”字眼，则可判<br>断是由于 mls 规则导致。说明主体和客体安全级别不同，<br>举例：已经在 platform_app.te 中添加了 SELinux 权限，但 log 中依然有如下报错：<br>avc: denied { write } for pid&#x3D;2002 comm&#x3D;“lightness”<br><strong>scontext&#x3D;u:r:platform_app:s0(主体):c512,c768</strong> <strong>tcontext&#x3D;u:r:custom_device_lightness:s0(客体资源)</strong> <strong>tclass&#x3D;char_file(file类型，读取的文件节点属于file类型)</strong> permissive&#x3D;0</p>
</blockquote>
<p><strong>主体：</strong> scontext&#x3D;u:r:【platform_app】<br><strong>客体：</strong> tcontext&#x3D;u:r:【custom_device_lightness】<br>这是因为 Google 在文件 system&#x2F;sepolicy&#x2F;private&#x2F;mls 中进行了安全级的限制，代码如下：<br><code>【mlsconstrain cahr_file &#123; write &#125; (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);】</code><br>l1需要l2相等，或者l1等于mlstrustedsubject l2等于mlstrustedsubject ，才能允许SELiunx权限。</p>
<p>这种情况需要主体进程或者客体进程中的一个是 mlstrustedsubject，这里 platform_app（主体） 最好不要修改，所以要修改客体 slogmodem（客体）。</p>
<p>具体修改方法如下：</p>
<pre><code>/system/sepolicy/private/platform_app.te(取决于主体进程)文件
添加如下代码：
type custom_device_lightness, domain, mlstrustedsubject;
</code></pre>
<h3 id="七-代码修改后烧录"><a href="#七-代码修改后烧录" class="headerlink" title="七. 代码修改后烧录"></a>七. 代码修改后烧录</h3><p>1.如果只是修改 selinux 相关文件–通过编译命令：<br>（1）lunch 项目<br>（2）cd system&#x2F;sepolicy<br>（3）mma<br>将编译产物 out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;system&#x2F;etc&#x2F;selinux 和 out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;vendor&#x2F;etc&#x2F;selinux 拷贝出来，推入手机查看是否生效，执行指令如下：<br>（1）cd out&#x2F;target&#x2F;product&#x2F;xxx<br>（2）adb root<br>（3）adb remount<br>（4）adb push system&#x2F;etc&#x2F;selinux &#x2F;system&#x2F;etc&#x2F;<br>（5）adb push vendor&#x2F;etc&#x2F;selinux &#x2F;vendor&#x2F;etc&#x2F;<br>如果手机不能root &amp;&amp; remount，可以考虑通过编译烧录的方式去验证</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>至此SELinux权限系统基本上介绍完毕，如何解决权限问题，如何关闭权限和切换权限，自定义权限，配置权限，皆已教学完毕。不为别的，为了留下工作上的脚印</p>
</blockquote>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/rc文件语法规则" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h3 id="解析init-rc脚本"><a href="#解析init-rc脚本" class="headerlink" title="解析init.rc脚本"></a>解析init.rc脚本</h3><h3 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h3><p>rc文件，是用Android Init Language编写的特殊文件。用这种语法编写的文件，统一用”.rc”后缀</p>
<p>它的语法说明可以在aosp源码<code>system/core/init/README.md</code>中找到:</p>
<p>system&#x2F;core&#x2F;init&#x2F;README.md原文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br></pre></td><td class="code"><pre><span class="line">Android Init Language</span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line">The Android Init Language consists of five broad classes of statements:</span><br><span class="line">Actions, Commands, Services, Options, and Imports.</span><br><span class="line"></span><br><span class="line">All of these are line-oriented, consisting of tokens separated by</span><br><span class="line">whitespace.  The c-style backslash escapes may be used to insert</span><br><span class="line">whitespace into a token.  Double quotes may also be used to prevent</span><br><span class="line">whitespace from breaking text into multiple tokens.  The backslash,</span><br><span class="line">when it is the last character on a line, may be used for line-folding.</span><br><span class="line"></span><br><span class="line">Lines which start with a `#` (leading whitespace allowed) are comments.</span><br><span class="line"></span><br><span class="line">System properties can be expanded using the syntax</span><br><span class="line">`$&#123;property.name&#125;`. This also works in contexts where concatenation is</span><br><span class="line">required, such as `import /init.recovery.$&#123;ro.hardware&#125;.rc`.</span><br><span class="line"></span><br><span class="line">Actions and Services implicitly declare a new section.  All commands</span><br><span class="line">or options belong to the section most recently declared.  Commands</span><br><span class="line">or options before the first section are ignored.</span><br><span class="line"></span><br><span class="line">Services have unique names.  If a second Service is defined</span><br><span class="line">with the same name as an existing one, it is ignored and an error</span><br><span class="line">message is logged.</span><br><span class="line"></span><br><span class="line">Init .rc Files</span><br><span class="line">--------------</span><br><span class="line">The init language is used in plain text files that take the .rc file</span><br><span class="line">extension.  There are typically multiple of these in multiple</span><br><span class="line">locations on the system, described below.</span><br><span class="line"></span><br><span class="line">`/system/etc/init/hw/init.rc` is the primary .rc file and is loaded by the init executable at the</span><br><span class="line">beginning of its execution.  It is responsible for the initial set up of the system.</span><br><span class="line"></span><br><span class="line">Init loads all of the files contained within the</span><br><span class="line">`/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/` directories immediately after loading</span><br><span class="line">the primary `/system/etc/init/hw/init.rc`.  This is explained in more details in the</span><br><span class="line">[Imports](#imports) section of this file.</span><br><span class="line"></span><br><span class="line">Legacy devices without the first stage mount mechanism previously were</span><br><span class="line">able to import init scripts during mount_all, however that is deprecated</span><br><span class="line">and not allowed for devices launching after Q.</span><br><span class="line"></span><br><span class="line">The intention of these directories is:</span><br><span class="line"></span><br><span class="line">   1. /system/etc/init/ is for core system items such as</span><br><span class="line">      SurfaceFlinger, MediaService, and logd.</span><br><span class="line">   2. /vendor/etc/init/ is for SoC vendor items such as actions or</span><br><span class="line">      daemons needed for core SoC functionality.</span><br><span class="line">   3. /odm/etc/init/ is for device manufacturer items such as</span><br><span class="line">      actions or daemons needed for motion sensor or other peripheral</span><br><span class="line">      functionality.</span><br><span class="line"></span><br><span class="line">All services whose binaries reside on the system, vendor, or odm</span><br><span class="line">partitions should have their service entries placed into a</span><br><span class="line">corresponding init .rc file, located in the /etc/init/</span><br><span class="line">directory of the partition where they reside.  There is a build</span><br><span class="line">system macro, LOCAL\_INIT\_RC, that handles this for developers.  Each</span><br><span class="line">init .rc file should additionally contain any actions associated with</span><br><span class="line">its service.</span><br><span class="line"></span><br><span class="line">An example is the userdebug logcatd.rc and Android.mk files located in the</span><br><span class="line">system/core/logcat directory.  The LOCAL\_INIT\_RC macro in the</span><br><span class="line">Android.mk file places logcatd.rc in /system/etc/init/ during the</span><br><span class="line">build process.  Init loads logcatd.rc during the mount\_all command and</span><br><span class="line">allows the service to be run and the action to be queued when</span><br><span class="line">appropriate.</span><br><span class="line"></span><br><span class="line">This break up of init .rc files according to their daemon is preferred</span><br><span class="line">to the previously used monolithic init .rc files.  This approach</span><br><span class="line">ensures that the only service entries that init reads and the only</span><br><span class="line">actions that init performs correspond to services whose binaries are in</span><br><span class="line">fact present on the file system, which was not the case with the</span><br><span class="line">monolithic init .rc files.  This additionally will aid in merge</span><br><span class="line">conflict resolution when multiple services are added to the system, as</span><br><span class="line">each one will go into a separate file.</span><br><span class="line"></span><br><span class="line">Versioned RC files within APEXs</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">With the arrival of mainline on Android Q, the individual mainline</span><br><span class="line">modules carry their own init.rc files within their boundaries. Init</span><br><span class="line">processes these files according to the naming pattern `/apex/*/etc/*rc`.</span><br><span class="line"></span><br><span class="line">Because APEX modules must run on more than one release of Android,</span><br><span class="line">they may require different parameters as part of the services they</span><br><span class="line">define. This is achieved, starting in Android T, by incorporating</span><br><span class="line">the SDK version information in the name of the init file.  The suffix</span><br><span class="line">is changed from `.rc` to `.#rc` where # is the first SDK where that</span><br><span class="line">RC file is accepted. An init file specific to SDK=31 might be named</span><br><span class="line">`init.31rc`. With this scheme, an APEX may include multiple init files. An</span><br><span class="line">example is appropriate.</span><br><span class="line"></span><br><span class="line">For an APEX module with the following files in /apex/sample-module/apex/etc/:</span><br><span class="line"></span><br><span class="line">   1. init.rc</span><br><span class="line">   2. init.32rc</span><br><span class="line">   4. init.35rc</span><br><span class="line"></span><br><span class="line">The selection rule chooses the highest `.#rc` value that does not</span><br><span class="line">exceed the SDK of the currently running system. The unadorned `.rc`</span><br><span class="line">is interpreted as sdk=0.</span><br><span class="line"></span><br><span class="line">When this APEX is installed on a device with SDK &lt;=31, the system will</span><br><span class="line">process init.rc.  When installed on a device running SDK 32, 33, or 34,</span><br><span class="line">it will use init.32rc.  When installed on a device running SDKs &gt;= 35,</span><br><span class="line">it will choose init.35rc</span><br><span class="line"></span><br><span class="line">This versioning scheme is used only for the init files within APEX</span><br><span class="line">modules; it does not apply to the init files stored in /system/etc/init,</span><br><span class="line">/vendor/etc/init, or other directories.</span><br><span class="line"></span><br><span class="line">This naming scheme is available after Android S.</span><br><span class="line"></span><br><span class="line">Actions</span><br><span class="line">-------</span><br><span class="line">Actions are named sequences of commands.  Actions have a trigger which</span><br><span class="line">is used to determine when the action is executed.  When an event</span><br><span class="line">occurs which matches an action&#x27;s trigger, that action is added to</span><br><span class="line">the tail of a to-be-executed queue (unless it is already on the</span><br><span class="line">queue).</span><br><span class="line"></span><br><span class="line">Each action in the queue is dequeued in sequence and each command in</span><br><span class="line">that action is executed in sequence.  Init handles other activities</span><br><span class="line">(device creation/destruction, property setting, process restarting)</span><br><span class="line">&quot;between&quot; the execution of the commands in activities.</span><br><span class="line"></span><br><span class="line">Actions take the form of:</span><br><span class="line"></span><br><span class="line">    on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*</span><br><span class="line">       &lt;command&gt;</span><br><span class="line">       &lt;command&gt;</span><br><span class="line">       &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Actions are added to the queue and executed based on the order that</span><br><span class="line">the file that contains them was parsed (see the Imports section), then</span><br><span class="line">sequentially within an individual file.</span><br><span class="line"></span><br><span class="line">For example if a file contains:</span><br><span class="line"></span><br><span class="line">    on boot</span><br><span class="line">       setprop a 1</span><br><span class="line">       setprop b 2</span><br><span class="line"></span><br><span class="line">    on boot &amp;&amp; property:true=true</span><br><span class="line">       setprop c 1</span><br><span class="line">       setprop d 2</span><br><span class="line"></span><br><span class="line">    on boot</span><br><span class="line">       setprop e 1</span><br><span class="line">       setprop f 2</span><br><span class="line"></span><br><span class="line">Then when the `boot` trigger occurs and assuming the property `true`</span><br><span class="line">equals `true`, then the order of the commands executed will be:</span><br><span class="line"></span><br><span class="line">    setprop a 1</span><br><span class="line">    setprop b 2</span><br><span class="line">    setprop c 1</span><br><span class="line">    setprop d 2</span><br><span class="line">    setprop e 1</span><br><span class="line">    setprop f 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Services</span><br><span class="line">--------</span><br><span class="line">Services are programs which init launches and (optionally) restarts</span><br><span class="line">when they exit.  Services take the form of:</span><br><span class="line"></span><br><span class="line">    service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">       &lt;option&gt;</span><br><span class="line">       &lt;option&gt;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">-------</span><br><span class="line">Options are modifiers to services.  They affect how and when init</span><br><span class="line">runs the service.</span><br><span class="line"></span><br><span class="line">`capabilities [ &lt;capability&gt;\* ]`</span><br><span class="line">&gt; Set capabilities when exec&#x27;ing this service. &#x27;capability&#x27; should be a Linux</span><br><span class="line">  capability without the &quot;CAP\_&quot; prefix, like &quot;NET\_ADMIN&quot; or &quot;SETPCAP&quot;. See</span><br><span class="line">  http://man7.org/linux/man-pages/man7/capabilities.7.html for a list of Linux</span><br><span class="line">  capabilities.</span><br><span class="line">  If no capabilities are provided, then all capabilities are removed from this service, even if it</span><br><span class="line">  runs as root.</span><br><span class="line"></span><br><span class="line">`class &lt;name&gt; [ &lt;name&gt;\* ]`</span><br><span class="line">&gt; Specify class names for the service.  All services in a</span><br><span class="line">  named class may be started or stopped together.  A service</span><br><span class="line">  is in the class &quot;default&quot; if one is not specified via the</span><br><span class="line">  class option. Additional classnames beyond the (required) first</span><br><span class="line">  one are used to group services.</span><br><span class="line">  The `animation` class should include all services necessary for both</span><br><span class="line">  boot animation and shutdown animation. As these services can be</span><br><span class="line">  launched very early during bootup and can run until the last stage</span><br><span class="line">  of shutdown, access to /data partition is not guaranteed. These</span><br><span class="line">  services can check files under /data but it should not keep files opened</span><br><span class="line">  and should work when /data is not available.</span><br><span class="line"></span><br><span class="line">`console [&lt;console&gt;]`</span><br><span class="line">&gt; This service needs a console. The optional second parameter chooses a</span><br><span class="line">  specific console instead of the default. The default &quot;/dev/console&quot; can</span><br><span class="line">  be changed by setting the &quot;androidboot.console&quot; kernel parameter. In</span><br><span class="line">  all cases the leading &quot;/dev/&quot; should be omitted, so &quot;/dev/tty0&quot; would be</span><br><span class="line">  specified as just &quot;console tty0&quot;.</span><br><span class="line">  This option connects stdin, stdout, and stderr to the console. It is mutually exclusive with the</span><br><span class="line">  stdio_to_kmsg option, which only connects stdout and stderr to kmsg.</span><br><span class="line"></span><br><span class="line">`critical [window=&lt;fatal crash window mins&gt;] [target=&lt;fatal reboot target&gt;]`</span><br><span class="line">&gt; This is a device-critical service. If it exits more than four times in</span><br><span class="line">  _fatal crash window mins_ minutes or before boot completes, the device</span><br><span class="line">  will reboot into _fatal reboot target_.</span><br><span class="line">  The default value of _fatal crash window mins_ is 4, and default value</span><br><span class="line">  of _fatal reboot target_ is &#x27;bootloader&#x27;.</span><br><span class="line">  For tests, the fatal reboot can be skipped by setting property</span><br><span class="line">  `init.svc_debug.no_fatal.&lt;service-name&gt;` to `true` for specified critical service.</span><br><span class="line"></span><br><span class="line">`disabled`</span><br><span class="line">&gt; This service will not automatically start with its class.</span><br><span class="line">  It must be explicitly started by name or by interface name.</span><br><span class="line"></span><br><span class="line">`enter_namespace &lt;type&gt; &lt;path&gt;`</span><br><span class="line">&gt; Enters the namespace of type _type_ located at _path_. Only network namespaces are supported with</span><br><span class="line">  _type_ set to &quot;net&quot;. Note that only one namespace of a given _type_ may be entered.</span><br><span class="line"></span><br><span class="line">`file &lt;path&gt; &lt;type&gt;`</span><br><span class="line">&gt; Open a file path and pass its fd to the launched process. _type_ must be</span><br><span class="line">  &quot;r&quot;, &quot;w&quot; or &quot;rw&quot;.  For native executables see libcutils</span><br><span class="line">  android\_get\_control\_file().</span><br><span class="line"></span><br><span class="line">`group &lt;groupname&gt; [ &lt;groupname&gt;\* ]`</span><br><span class="line">&gt; Change to &#x27;groupname&#x27; before exec&#x27;ing this service.  Additional</span><br><span class="line">  groupnames beyond the (required) first one are used to set the</span><br><span class="line">  supplemental groups of the process (via setgroups()).</span><br><span class="line">  Currently defaults to root.  (??? probably should default to nobody)</span><br><span class="line"></span><br><span class="line">`interface &lt;interface name&gt; &lt;instance name&gt;`</span><br><span class="line">&gt; Associates this service with a list of the AIDL or HIDL services that it provides. The interface</span><br><span class="line">  name must be a fully-qualified name and not a value name. For instance, this is used to allow</span><br><span class="line">  servicemanager or hwservicemanager to lazily start services. When multiple interfaces are served,</span><br><span class="line">  this tag should be used multiple times. An example of an entry for a HIDL</span><br><span class="line">  interface is `interface vendor.foo.bar@1.0::IBaz default`. For an AIDL interface, use</span><br><span class="line">  `interface aidl &lt;instance name&gt;`. The instance name for an AIDL interface is</span><br><span class="line">  whatever is registered with servicemanager, and these can be listed with `adb</span><br><span class="line">  shell dumpsys -l`.</span><br><span class="line"></span><br><span class="line">`ioprio &lt;class&gt; &lt;priority&gt;`</span><br><span class="line">&gt; Sets the IO priority and IO priority class for this service via the SYS_ioprio_set syscall.</span><br><span class="line">  _class_ must be one of &quot;rt&quot;, &quot;be&quot;, or &quot;idle&quot;. _priority_ must be an integer in the range 0 - 7.</span><br><span class="line"></span><br><span class="line">`keycodes &lt;keycode&gt; [ &lt;keycode&gt;\* ]`</span><br><span class="line">&gt; Sets the keycodes that will trigger this service. If all of the keys corresponding to the passed</span><br><span class="line">  keycodes are pressed at once, the service will start. This is typically used to start the</span><br><span class="line">  bugreport service.</span><br><span class="line"></span><br><span class="line">&gt; This option may take a property instead of a list of keycodes. In this case, only one option is</span><br><span class="line">  provided: the property name in the typical property expansion format. The property must contain</span><br><span class="line">  a comma separated list of keycode values or the text &#x27;none&#x27; to indicate that</span><br><span class="line">  this service does not respond to keycodes.</span><br><span class="line"></span><br><span class="line">&gt; For example, `keycodes $&#123;some.property.name:-none&#125;` where some.property.name expands</span><br><span class="line">  to &quot;123,124,125&quot;. Since keycodes are handled very early in init,</span><br><span class="line">  only PRODUCT_DEFAULT_PROPERTY_OVERRIDES properties can be used.</span><br><span class="line"></span><br><span class="line">`memcg.limit_in_bytes &lt;value&gt;` and `memcg.limit_percent &lt;value&gt;`</span><br><span class="line">&gt; Sets the child&#x27;s memory.limit_in_bytes to the minimum of `limit_in_bytes`</span><br><span class="line">  bytes and `limit_percent` which is interpreted as a percentage of the size</span><br><span class="line">  of the device&#x27;s physical memory (only if memcg is mounted).</span><br><span class="line">  Values must be equal or greater than 0.</span><br><span class="line"></span><br><span class="line">`memcg.limit_property &lt;value&gt;`</span><br><span class="line">&gt; Sets the child&#x27;s memory.limit_in_bytes to the value of the specified property</span><br><span class="line">  (only if memcg is mounted). This property will override the values specified</span><br><span class="line">  via `memcg.limit_in_bytes` and `memcg.limit_percent`.</span><br><span class="line"></span><br><span class="line">`memcg.soft_limit_in_bytes &lt;value&gt;`</span><br><span class="line">&gt; Sets the child&#x27;s memory.soft_limit_in_bytes to the specified value (only if memcg is mounted),</span><br><span class="line">  which must be equal or greater than 0.</span><br><span class="line"></span><br><span class="line">`memcg.swappiness &lt;value&gt;`</span><br><span class="line">&gt; Sets the child&#x27;s memory.swappiness to the specified value (only if memcg is mounted),</span><br><span class="line">  which must be equal or greater than 0.</span><br><span class="line"></span><br><span class="line">`namespace &lt;pid|mnt&gt;`</span><br><span class="line">&gt; Enter a new PID or mount namespace when forking the service.</span><br><span class="line"></span><br><span class="line">`oneshot`</span><br><span class="line">&gt; Do not restart the service when it exits.</span><br><span class="line"></span><br><span class="line">`onrestart`</span><br><span class="line">&gt; Execute a Command (see below) when service restarts.</span><br><span class="line"></span><br><span class="line">`oom_score_adjust &lt;value&gt;`</span><br><span class="line">&gt; Sets the child&#x27;s /proc/self/oom\_score\_adj to the specified value,</span><br><span class="line">  which must range from -1000 to 1000.</span><br><span class="line"></span><br><span class="line">`override`</span><br><span class="line">&gt; Indicates that this service definition is meant to override a previous definition for a service</span><br><span class="line">  with the same name. This is typically meant for services on /odm to override those defined on</span><br><span class="line">  /vendor. The last service definition that init parses with this keyword is the service definition</span><br><span class="line">  will use for this service. Pay close attention to the order in which init.rc files are parsed,</span><br><span class="line">  since it has some peculiarities for backwards compatibility reasons. The &#x27;imports&#x27; section of</span><br><span class="line">  this file has more details on the order.</span><br><span class="line"></span><br><span class="line">`priority &lt;priority&gt;`</span><br><span class="line">&gt; Scheduling priority of the service process. This value has to be in range</span><br><span class="line">  -20 to 19. Default priority is 0. Priority is set via setpriority().</span><br><span class="line"></span><br><span class="line">`reboot_on_failure &lt;target&gt;`</span><br><span class="line">&gt; If this process cannot be started or if the process terminates with an exit code other than</span><br><span class="line">  CLD_EXITED or an status other than &#x27;0&#x27;, reboot the system with the target specified in</span><br><span class="line">  _target_. _target_ takes the same format as the parameter to sys.powerctl. This is particularly</span><br><span class="line">  intended to be used with the `exec_start` builtin for any must-have checks during boot.</span><br><span class="line"></span><br><span class="line">`restart_period &lt;seconds&gt;`</span><br><span class="line">&gt; If a non-oneshot service exits, it will be restarted at its start time plus</span><br><span class="line">  this period. It defaults to 5s to rate limit crashing services.</span><br><span class="line">  This can be increased for services that are meant to run periodically. For</span><br><span class="line">  example, it may be set to 3600 to indicate that the service should run every hour</span><br><span class="line">  or 86400 to indicate that the service should run every day.</span><br><span class="line"></span><br><span class="line">`rlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;`</span><br><span class="line">&gt; This applies the given rlimit to the service. rlimits are inherited by child</span><br><span class="line">  processes, so this effectively applies the given rlimit to the process tree</span><br><span class="line">  started by this service.</span><br><span class="line">  It is parsed similarly to the setrlimit command specified below.</span><br><span class="line"></span><br><span class="line">`seclabel &lt;seclabel&gt;`</span><br><span class="line">&gt; Change to &#x27;seclabel&#x27; before exec&#x27;ing this service.</span><br><span class="line">  Primarily for use by services run from the rootfs, e.g. ueventd, adbd.</span><br><span class="line">  Services on the system partition can instead use policy-defined transitions</span><br><span class="line">  based on their file security context.</span><br><span class="line">  If not specified and no transition is defined in policy, defaults to the init context.</span><br><span class="line"></span><br><span class="line">`setenv &lt;name&gt; &lt;value&gt;`</span><br><span class="line">&gt; Set the environment variable _name_ to _value_ in the launched process.</span><br><span class="line"></span><br><span class="line">`shutdown &lt;shutdown_behavior&gt;`</span><br><span class="line">&gt; Set shutdown behavior of the service process. When this is not specified,</span><br><span class="line">  the service is killed during shutdown process by using SIGTERM and SIGKILL.</span><br><span class="line">  The service with shutdown_behavior of &quot;critical&quot; is not killed during shutdown</span><br><span class="line">  until shutdown times out. When shutdown times out, even services tagged with</span><br><span class="line">  &quot;shutdown critical&quot; will be killed. When the service tagged with &quot;shutdown critical&quot;</span><br><span class="line">  is not running when shut down starts, it will be started.</span><br><span class="line"></span><br><span class="line">`sigstop`</span><br><span class="line">&gt; Send SIGSTOP to the service immediately before exec is called. This is intended for debugging.</span><br><span class="line">  See the below section on debugging for how this can be used.</span><br><span class="line"></span><br><span class="line">`socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]`</span><br><span class="line">&gt; Create a UNIX domain socket named /dev/socket/_name_ and pass its fd to the</span><br><span class="line">  launched process.  _type_ must be &quot;dgram&quot;, &quot;stream&quot; or &quot;seqpacket&quot;.  _type_</span><br><span class="line">  may end with &quot;+passcred&quot; to enable SO_PASSCRED on the socket. User and</span><br><span class="line">  group default to 0.  &#x27;seclabel&#x27; is the SELinux security context for the</span><br><span class="line">  socket.  It defaults to the service security context, as specified by</span><br><span class="line">  seclabel or computed based on the service executable file security context.</span><br><span class="line">  For native executables see libcutils android\_get\_control\_socket().</span><br><span class="line"></span><br><span class="line">`stdio_to_kmsg`</span><br><span class="line">&gt; Redirect stdout and stderr to /dev/kmsg_debug. This is useful for services that do not use native</span><br><span class="line">  Android logging during early boot and whose logs messages we want to capture. This is only enabled</span><br><span class="line">  when /dev/kmsg_debug is enabled, which is only enabled on userdebug and eng builds.</span><br><span class="line">  This is mutually exclusive with the console option, which additionally connects stdin to the</span><br><span class="line">  given console.</span><br><span class="line"></span><br><span class="line">`task_profiles &lt;profile&gt; [ &lt;profile&gt;\* ]`</span><br><span class="line">&gt; Set task profiles for the process when it forks. This is designed to replace the use of</span><br><span class="line">  writepid option for moving a process into a cgroup.</span><br><span class="line"></span><br><span class="line">`timeout_period &lt;seconds&gt;`</span><br><span class="line">&gt; Provide a timeout after which point the service will be killed. The oneshot keyword is respected</span><br><span class="line">  here, so oneshot services do not automatically restart, however all other services will.</span><br><span class="line">  This is particularly useful for creating a periodic service combined with the restart_period</span><br><span class="line">  option described above.</span><br><span class="line"></span><br><span class="line">`updatable`</span><br><span class="line">&gt; Mark that the service can be overridden (via the &#x27;override&#x27; option) later in</span><br><span class="line">  the boot sequence by APEXes. When a service with updatable option is started</span><br><span class="line">  before APEXes are all activated, the execution is delayed until the activation</span><br><span class="line">  is finished. A service that is not marked as updatable cannot be overridden by</span><br><span class="line">  APEXes.</span><br><span class="line"></span><br><span class="line">`user &lt;username&gt;`</span><br><span class="line">&gt; Change to &#x27;username&#x27; before exec&#x27;ing this service.</span><br><span class="line">  Currently defaults to root.  (??? probably should default to nobody)</span><br><span class="line">  As of Android M, processes should use this option even if they</span><br><span class="line">  require Linux capabilities.  Previously, to acquire Linux</span><br><span class="line">  capabilities, a process would need to run as root, request the</span><br><span class="line">  capabilities, then drop to its desired uid.  There is a new</span><br><span class="line">  mechanism through fs\_config that allows device manufacturers to add</span><br><span class="line">  Linux capabilities to specific binaries on a file system that should</span><br><span class="line">  be used instead. This mechanism is described on</span><br><span class="line">  &lt;http://source.android.com/devices/tech/config/filesystem.html&gt;.  When</span><br><span class="line">  using this new mechanism, processes can use the user option to</span><br><span class="line">  select their desired uid without ever running as root.</span><br><span class="line">  As of Android O, processes can also request capabilities directly in their .rc</span><br><span class="line">  files. See the &quot;capabilities&quot; option below.</span><br><span class="line"></span><br><span class="line">`writepid &lt;file&gt; [ &lt;file&gt;\* ]`</span><br><span class="line">&gt; Write the child&#x27;s pid to the given files when it forks. Meant for</span><br><span class="line">  cgroup/cpuset usage. If no files under /dev/cpuset/ are specified, but the</span><br><span class="line">  system property &#x27;ro.cpuset.default&#x27; is set to a non-empty cpuset name (e.g.</span><br><span class="line">  &#x27;/foreground&#x27;), then the pid is written to file /dev/cpuset/_cpuset\_name_/tasks.</span><br><span class="line">  The use of this option for moving a process into a cgroup is obsolete. Please</span><br><span class="line">  use task_profiles option instead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Triggers</span><br><span class="line">--------</span><br><span class="line">Triggers are strings which can be used to match certain kinds of</span><br><span class="line">events and used to cause an action to occur.</span><br><span class="line"></span><br><span class="line">Triggers are subdivided into event triggers and property triggers.</span><br><span class="line"></span><br><span class="line">Event triggers are strings triggered by the &#x27;trigger&#x27; command or by</span><br><span class="line">the QueueEventTrigger() function within the init executable.  These</span><br><span class="line">take the form of a simple string such as &#x27;boot&#x27; or &#x27;late-init&#x27;.</span><br><span class="line"></span><br><span class="line">Property triggers are strings triggered when a named property changes</span><br><span class="line">value to a given new value or when a named property changes value to</span><br><span class="line">any new value.  These take the form of &#x27;property:&lt;name&gt;=&lt;value&gt;&#x27; and</span><br><span class="line">&#x27;property:&lt;name&gt;=\*&#x27; respectively.  Property triggers are additionally</span><br><span class="line">evaluated and triggered accordingly during the initial boot phase of</span><br><span class="line">init.</span><br><span class="line"></span><br><span class="line">An Action can have multiple property triggers but may only have one</span><br><span class="line">event trigger.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">`on boot &amp;&amp; property:a=b` defines an action that is only executed when</span><br><span class="line">the &#x27;boot&#x27; event trigger happens and the property a equals b.</span><br><span class="line"></span><br><span class="line">`on property:a=b &amp;&amp; property:c=d` defines an action that is executed</span><br><span class="line">at three times:</span><br><span class="line"></span><br><span class="line">   1. During initial boot if property a=b and property c=d.</span><br><span class="line">   2. Any time that property a transitions to value b, while property c already equals d.</span><br><span class="line">   3. Any time that property c transitions to value d, while property a already equals b.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Trigger Sequence</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">Init uses the following sequence of triggers during early boot. These are the</span><br><span class="line">built-in triggers defined in init.cpp.</span><br><span class="line"></span><br><span class="line">   1. `early-init` - The first in the sequence, triggered after cgroups has been configured</span><br><span class="line">      but before ueventd&#x27;s coldboot is complete.</span><br><span class="line">   2. `init` - Triggered after coldboot is complete.</span><br><span class="line">   3. `charger` - Triggered if `ro.bootmode == &quot;charger&quot;`.</span><br><span class="line">   4. `late-init` - Triggered if `ro.bootmode != &quot;charger&quot;`, or via healthd triggering a boot</span><br><span class="line">      from charging mode.</span><br><span class="line"></span><br><span class="line">Remaining triggers are configured in `init.rc` and are not built-in. The default sequence for</span><br><span class="line">these is specified under the &quot;on late-init&quot; event in `init.rc`. Actions internal to `init.rc`</span><br><span class="line">have been omitted.</span><br><span class="line"></span><br><span class="line">   1. `early-fs` - Start vold.</span><br><span class="line">   2. `fs` - Vold is up. Mount partitions not marked as first-stage or latemounted.</span><br><span class="line">   3. `post-fs` - Configure anything dependent on early mounts.</span><br><span class="line">   4. `late-fs` - Mount partitions marked as latemounted.</span><br><span class="line">   5. `post-fs-data` - Mount and configure `/data`; set up encryption. `/metadata` is</span><br><span class="line">      reformatted here if it couldn&#x27;t mount in first-stage init.</span><br><span class="line">   6. `zygote-start` - Start the zygote.</span><br><span class="line">   7. `early-boot` - After zygote has started.</span><br><span class="line">   8. `boot` - After `early-boot` actions have completed.</span><br><span class="line"></span><br><span class="line">Commands</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">`bootchart [start|stop]`</span><br><span class="line">&gt; Start/stop bootcharting. These are present in the default init.rc files,</span><br><span class="line">  but bootcharting is only active if the file /data/bootchart/enabled exists;</span><br><span class="line">  otherwise bootchart start/stop are no-ops.</span><br><span class="line"></span><br><span class="line">`chmod &lt;octal-mode&gt; &lt;path&gt;`</span><br><span class="line">&gt; Change file access permissions.</span><br><span class="line"></span><br><span class="line">`chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;`</span><br><span class="line">&gt; Change file owner and group.</span><br><span class="line"></span><br><span class="line">`class_start &lt;serviceclass&gt;`</span><br><span class="line">&gt; Start all services of the specified class if they are</span><br><span class="line">  not already running.  See the start entry for more information on</span><br><span class="line">  starting services.</span><br><span class="line"></span><br><span class="line">`class_stop &lt;serviceclass&gt;`</span><br><span class="line">&gt; Stop and disable all services of the specified class if they are</span><br><span class="line">  currently running.</span><br><span class="line"></span><br><span class="line">`class_reset &lt;serviceclass&gt;`</span><br><span class="line">&gt; Stop all services of the specified class if they are</span><br><span class="line">  currently running, without disabling them. They can be restarted</span><br><span class="line">  later using `class_start`.</span><br><span class="line"></span><br><span class="line">`class_restart [--only-enabled] &lt;serviceclass&gt;`</span><br><span class="line">&gt; Restarts all services of the specified class. If `--only-enabled` is</span><br><span class="line">  specified, then disabled services are skipped.</span><br><span class="line"></span><br><span class="line">`copy &lt;src&gt; &lt;dst&gt;`</span><br><span class="line">&gt; Copies a file. Similar to write, but useful for binary/large</span><br><span class="line">  amounts of data.</span><br><span class="line">  Regarding to the src file, copying from symbolic link file and world-writable</span><br><span class="line">  or group-writable files are not allowed.</span><br><span class="line">  Regarding to the dst file, the default mode created is 0600 if it does not</span><br><span class="line">  exist. And it will be truncated if dst file is a normal regular file and</span><br><span class="line">  already exists.</span><br><span class="line"></span><br><span class="line">`copy_per_line &lt;src&gt; &lt;dst&gt;`</span><br><span class="line">&gt; Copies a file line by line. Similar to copy, but useful for dst is a sysfs node</span><br><span class="line">  that doesn&#x27;t handle multiple lines of data.</span><br><span class="line"></span><br><span class="line">`domainname &lt;name&gt;`</span><br><span class="line">&gt; Set the domain name.</span><br><span class="line"></span><br><span class="line">`enable &lt;servicename&gt;`</span><br><span class="line">&gt; Turns a disabled service into an enabled one as if the service did not</span><br><span class="line">  specify disabled.</span><br><span class="line">  If the service is supposed to be running, it will be started now.</span><br><span class="line">  Typically used when the bootloader sets a variable that indicates a specific</span><br><span class="line">  service should be started when needed. E.g.</span><br><span class="line"></span><br><span class="line">    on property:ro.boot.myfancyhardware=1</span><br><span class="line">        enable my_fancy_service_for_my_fancy_hardware</span><br><span class="line"></span><br><span class="line">`exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\* ]`</span><br><span class="line">&gt; Fork and execute command with the given arguments. The command starts</span><br><span class="line">  after &quot;--&quot; so that an optional security context, user, and supplementary</span><br><span class="line">  groups can be provided. No other commands will be run until this one</span><br><span class="line">  finishes. _seclabel_ can be a - to denote default. Properties are expanded</span><br><span class="line">  within _argument_.</span><br><span class="line">  Init halts executing commands until the forked process exits.</span><br><span class="line"></span><br><span class="line">`exec_background [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\* ]`</span><br><span class="line">&gt; Fork and execute command with the given arguments. This is handled similarly</span><br><span class="line">  to the `exec` command. The difference is that init does not halt executing</span><br><span class="line">  commands until the process exits for `exec_background`.</span><br><span class="line"></span><br><span class="line">`exec_start &lt;service&gt;`</span><br><span class="line">&gt; Start a given service and halt the processing of additional init commands</span><br><span class="line">  until it returns.  The command functions similarly to the `exec` command,</span><br><span class="line">  but uses an existing service definition in place of the exec argument vector.</span><br><span class="line"></span><br><span class="line">`export &lt;name&gt; &lt;value&gt;`</span><br><span class="line">&gt; Set the environment variable _name_ equal to _value_ in the</span><br><span class="line">  global environment (which will be inherited by all processes</span><br><span class="line">  started after this command is executed)</span><br><span class="line"></span><br><span class="line">`hostname &lt;name&gt;`</span><br><span class="line">&gt; Set the host name.</span><br><span class="line"></span><br><span class="line">`ifup &lt;interface&gt;`</span><br><span class="line">&gt; Bring the network interface _interface_ online.</span><br><span class="line"></span><br><span class="line">`insmod [-f] &lt;path&gt; [&lt;options&gt;]`</span><br><span class="line">&gt; Install the module at _path_ with the specified options.</span><br><span class="line">  -f: force installation of the module even if the version of the running kernel</span><br><span class="line">  and the version of the kernel for which the module was compiled do not match.</span><br><span class="line"></span><br><span class="line">`interface_start &lt;name&gt;` \</span><br><span class="line">`interface_restart &lt;name&gt;` \</span><br><span class="line">`interface_stop &lt;name&gt;`</span><br><span class="line">&gt; Find the service that provides the interface _name_ if it exists and run the `start`, `restart`,</span><br><span class="line">or `stop` commands on it respectively.  _name_ may be either a fully qualified HIDL name, in which</span><br><span class="line">case it is specified as `&lt;interface&gt;/&lt;instance&gt;`, or an AIDL name, in which case it is specified as</span><br><span class="line">`aidl/&lt;interface&gt;` for example `android.hardware.secure_element@1.1::ISecureElement/eSE1` or</span><br><span class="line">`aidl/aidl_lazy_test_1`.</span><br><span class="line"></span><br><span class="line">&gt; Note that these commands only act on interfaces specified by the `interface` service option, not</span><br><span class="line">on interfaces registered at runtime.</span><br><span class="line"></span><br><span class="line">&gt; Example usage of these commands: \</span><br><span class="line">`interface_start android.hardware.secure_element@1.1::ISecureElement/eSE1`</span><br><span class="line">will start the HIDL Service that provides the `android.hardware.secure_element@1.1` and `eSI1`</span><br><span class="line">instance. \</span><br><span class="line">`interface_start aidl/aidl_lazy_test_1` will start the AIDL service that</span><br><span class="line">provides the `aidl_lazy_test_1` interface.</span><br><span class="line"></span><br><span class="line">`load_exports &lt;path&gt;`</span><br><span class="line">&gt; Open the file at _path_ and export global environment variables declared</span><br><span class="line">  there. Each line must be in the format `export &lt;name&gt; &lt;value&gt;`, as described</span><br><span class="line">  above.</span><br><span class="line"></span><br><span class="line">`load_system_props`</span><br><span class="line">&gt; (This action is deprecated and no-op.)</span><br><span class="line"></span><br><span class="line">`load_persist_props`</span><br><span class="line">&gt; Loads persistent properties when /data has been decrypted.</span><br><span class="line">  This is included in the default init.rc.</span><br><span class="line"></span><br><span class="line">`loglevel &lt;level&gt;`</span><br><span class="line">&gt; Sets init&#x27;s log level to the integer level, from 7 (all logging) to 0</span><br><span class="line">  (fatal logging only). The numeric values correspond to the kernel log</span><br><span class="line">  levels, but this command does not affect the kernel log level. Use the</span><br><span class="line">  `write` command to write to `/proc/sys/kernel/printk` to change that.</span><br><span class="line">  Properties are expanded within _level_.</span><br><span class="line"></span><br><span class="line">`mark_post_data`</span><br><span class="line">&gt; Used to mark the point right after /data is mounted.</span><br><span class="line"></span><br><span class="line">`mkdir &lt;path&gt; [&lt;mode&gt;] [&lt;owner&gt;] [&lt;group&gt;] [encryption=&lt;action&gt;] [key=&lt;key&gt;]`</span><br><span class="line">&gt; Create a directory at _path_, optionally with the given mode, owner, and</span><br><span class="line">  group. If not provided, the directory is created with permissions 755 and</span><br><span class="line">  owned by the root user and root group. If provided, the mode, owner and group</span><br><span class="line">  will be updated if the directory exists already.</span><br><span class="line"></span><br><span class="line"> &gt; _action_ can be one of:</span><br><span class="line">  * `None`: take no encryption action; directory will be encrypted if parent is.</span><br><span class="line">  * `Require`: encrypt directory, abort boot process if encryption fails</span><br><span class="line">  * `Attempt`: try to set an encryption policy, but continue if it fails</span><br><span class="line">  * `DeleteIfNecessary`: recursively delete directory if necessary to set</span><br><span class="line">  encryption policy.</span><br><span class="line"></span><br><span class="line">  &gt; _key_ can be one of:</span><br><span class="line">  * `ref`: use the systemwide DE key</span><br><span class="line">  * `per_boot_ref`: use the key freshly generated on each boot.</span><br><span class="line"></span><br><span class="line">`mount_all [ &lt;fstab&gt; ] [--&lt;option&gt;]`</span><br><span class="line">&gt; Calls fs\_mgr\_mount\_all on the given fs\_mgr-format fstab with optional</span><br><span class="line">  options &quot;early&quot; and &quot;late&quot;.</span><br><span class="line">  With &quot;--early&quot; set, the init executable will skip mounting entries with</span><br><span class="line">  &quot;latemount&quot; flag and triggering fs encryption state event. With &quot;--late&quot; set,</span><br><span class="line">  init executable will only mount entries with &quot;latemount&quot; flag. By default,</span><br><span class="line">  no option is set, and mount\_all will process all entries in the given fstab.</span><br><span class="line">  If the fstab parameter is not specified, fstab.$&#123;ro.boot.fstab_suffix&#125;,</span><br><span class="line">  fstab.$&#123;ro.hardware&#125; or fstab.$&#123;ro.hardware.platform&#125; will be scanned for</span><br><span class="line">  under /odm/etc, /vendor/etc, or / at runtime, in that order.</span><br><span class="line"></span><br><span class="line">`mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt;\* ] [&lt;options&gt;]`</span><br><span class="line">&gt; Attempt to mount the named device at the directory _dir_</span><br><span class="line">  _flag_s include &quot;ro&quot;, &quot;rw&quot;, &quot;remount&quot;, &quot;noatime&quot;, ...</span><br><span class="line">  _options_ include &quot;barrier=1&quot;, &quot;noauto\_da\_alloc&quot;, &quot;discard&quot;, ... as</span><br><span class="line">  a comma separated string, e.g. barrier=1,noauto\_da\_alloc</span><br><span class="line"></span><br><span class="line">`perform_apex_config`</span><br><span class="line">&gt; Performs tasks after APEXes are mounted. For example, creates data directories</span><br><span class="line">  for the mounted APEXes, parses config file(s) from them, and updates linker</span><br><span class="line">  configurations. Intended to be used only once when apexd notifies the mount</span><br><span class="line">  event by setting `apexd.status` to ready.</span><br><span class="line"></span><br><span class="line">`restart [--only-if-running] &lt;service&gt;`</span><br><span class="line">&gt; Stops and restarts a running service, does nothing if the service is currently</span><br><span class="line">  restarting, otherwise, it just starts the service. If &quot;--only-if-running&quot; is</span><br><span class="line">  specified, the service is only restarted if it is already running.</span><br><span class="line"></span><br><span class="line">`restorecon &lt;path&gt; [ &lt;path&gt;\* ]`</span><br><span class="line">&gt; Restore the file named by _path_ to the security context specified</span><br><span class="line">  in the file\_contexts configuration.</span><br><span class="line">  Not required for directories created by the init.rc as these are</span><br><span class="line">  automatically labeled correctly by init.</span><br><span class="line"></span><br><span class="line">`restorecon_recursive &lt;path&gt; [ &lt;path&gt;\* ]`</span><br><span class="line">&gt; Recursively restore the directory tree named by _path_ to the</span><br><span class="line">  security contexts specified in the file\_contexts configuration.</span><br><span class="line"></span><br><span class="line">`rm &lt;path&gt;`</span><br><span class="line">&gt; Calls unlink(2) on the given path. You might want to</span><br><span class="line">  use &quot;exec -- rm ...&quot; instead (provided the system partition is</span><br><span class="line">  already mounted).</span><br><span class="line"></span><br><span class="line">`rmdir &lt;path&gt;`</span><br><span class="line">&gt; Calls rmdir(2) on the given path.</span><br><span class="line"></span><br><span class="line">`readahead &lt;file|dir&gt; [--fully]`</span><br><span class="line">&gt; Calls readahead(2) on the file or files within given directory.</span><br><span class="line">  Use option --fully to read the full file content.</span><br><span class="line"></span><br><span class="line">`setprop &lt;name&gt; &lt;value&gt;`</span><br><span class="line">&gt; Set system property _name_ to _value_. Properties are expanded</span><br><span class="line">  within _value_.</span><br><span class="line"></span><br><span class="line">`setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;`</span><br><span class="line">&gt; Set the rlimit for a resource. This applies to all processes launched after</span><br><span class="line">  the limit is set. It is intended to be set early in init and applied globally.</span><br><span class="line">  _resource_ is best specified using its text representation (&#x27;cpu&#x27;, &#x27;rtio&#x27;, etc</span><br><span class="line">  or &#x27;RLIM_CPU&#x27;, &#x27;RLIM_RTIO&#x27;, etc). It also may be specified as the int value</span><br><span class="line">  that the resource enum corresponds to.</span><br><span class="line">  _cur_ and _max_ can be &#x27;unlimited&#x27; or &#x27;-1&#x27; to indicate an infinite rlimit.</span><br><span class="line"></span><br><span class="line">`start &lt;service&gt;`</span><br><span class="line">&gt; Start a service running if it is not already running.</span><br><span class="line">  Note that this is _not_ synchronous, and even if it were, there is</span><br><span class="line">  no guarantee that the operating system&#x27;s scheduler will execute the</span><br><span class="line">  service sufficiently to guarantee anything about the service&#x27;s status.</span><br><span class="line">  See the `exec_start` command for a synchronous version of `start`.</span><br><span class="line"></span><br><span class="line">&gt; This creates an important consequence that if the service offers</span><br><span class="line">  functionality to other services, such as providing a</span><br><span class="line">  communication channel, simply starting this service before those</span><br><span class="line">  services is _not_ sufficient to guarantee that the channel has</span><br><span class="line">  been set up before those services ask for it.  There must be a</span><br><span class="line">  separate mechanism to make any such guarantees.</span><br><span class="line"></span><br><span class="line">`stop &lt;service&gt;`</span><br><span class="line">&gt; Stop a service from running if it is currently running.</span><br><span class="line"></span><br><span class="line">`swapon_all [ &lt;fstab&gt; ]`</span><br><span class="line">&gt; Calls fs\_mgr\_swapon\_all on the given fstab file.</span><br><span class="line">  If the fstab parameter is not specified, fstab.$&#123;ro.boot.fstab_suffix&#125;,</span><br><span class="line">  fstab.$&#123;ro.hardware&#125; or fstab.$&#123;ro.hardware.platform&#125; will be scanned for</span><br><span class="line">  under /odm/etc, /vendor/etc, or / at runtime, in that order.</span><br><span class="line"></span><br><span class="line">`symlink &lt;target&gt; &lt;path&gt;`</span><br><span class="line">&gt; Create a symbolic link at _path_ with the value _target_</span><br><span class="line"></span><br><span class="line">`sysclktz &lt;minutes_west_of_gmt&gt;`</span><br><span class="line">&gt; Set the system clock base (0 if system clock ticks in GMT)</span><br><span class="line"></span><br><span class="line">`trigger &lt;event&gt;`</span><br><span class="line">&gt; Trigger an event.  Used to queue an action from another</span><br><span class="line">  action.</span><br><span class="line"></span><br><span class="line">`umount &lt;path&gt;`</span><br><span class="line">&gt; Unmount the filesystem mounted at that path.</span><br><span class="line"></span><br><span class="line">`umount_all [ &lt;fstab&gt; ]`</span><br><span class="line">&gt; Calls fs\_mgr\_umount\_all on the given fstab file.</span><br><span class="line">  If the fstab parameter is not specified, fstab.$&#123;ro.boot.fstab_suffix&#125;,</span><br><span class="line">  fstab.$&#123;ro.hardware&#125; or fstab.$&#123;ro.hardware.platform&#125; will be scanned for</span><br><span class="line">  under /odm/etc, /vendor/etc, or / at runtime, in that order.</span><br><span class="line"></span><br><span class="line">`verity_update_state`</span><br><span class="line">&gt; Internal implementation detail used to update dm-verity state and</span><br><span class="line">  set the partition._mount-point_.verified properties used by adb remount</span><br><span class="line">  because fs\_mgr can&#x27;t set them directly itself. This is required since</span><br><span class="line">  Android 12, because CtsNativeVerifiedBootTestCases will read property</span><br><span class="line">  &quot;partition.$&#123;partition&#125;.verified.hash_alg&quot; to check that sha1 is not used.</span><br><span class="line">  See https://r.android.com/1546980 for more details.</span><br><span class="line"></span><br><span class="line">`wait &lt;path&gt; [ &lt;timeout&gt; ]`</span><br><span class="line">&gt; Poll for the existence of the given file and return when found,</span><br><span class="line">  or the timeout has been reached. If timeout is not specified it</span><br><span class="line">  currently defaults to five seconds. The timeout value can be</span><br><span class="line">  fractional seconds, specified in floating point notation.</span><br><span class="line"></span><br><span class="line">`wait_for_prop &lt;name&gt; &lt;value&gt;`</span><br><span class="line">&gt; Wait for system property _name_ to be _value_. Properties are expanded</span><br><span class="line">  within _value_. If property _name_ is already set to _value_, continue</span><br><span class="line">  immediately.</span><br><span class="line"></span><br><span class="line">`write &lt;path&gt; &lt;content&gt;`</span><br><span class="line">&gt; Open the file at _path_ and write a string to it with write(2).</span><br><span class="line">  If the file does not exist, it will be created. If it does exist,</span><br><span class="line">  it will be truncated. Properties are expanded within _content_.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Imports</span><br><span class="line">-------</span><br><span class="line">`import &lt;path&gt;`</span><br><span class="line">&gt; Parse an init config file, extending the current configuration.</span><br><span class="line">  If _path_ is a directory, each file in the directory is parsed as</span><br><span class="line">  a config file. It is not recursive, nested directories will</span><br><span class="line">  not be parsed.</span><br><span class="line"></span><br><span class="line">The import keyword is not a command, but rather its own section,</span><br><span class="line">meaning that it does not happen as part of an Action, but rather,</span><br><span class="line">imports are handled as a file is being parsed and follow the below logic.</span><br><span class="line"></span><br><span class="line">There are only three times where the init executable imports .rc files:</span><br><span class="line"></span><br><span class="line">   1. When it imports `/system/etc/init/hw/init.rc` or the script indicated by the property</span><br><span class="line">      `ro.boot.init_rc` during initial boot.</span><br><span class="line">   2. When it imports `/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/` immediately after</span><br><span class="line">      importing `/system/etc/init/hw/init.rc`.</span><br><span class="line">   3. (Deprecated) When it imports /&#123;system,vendor,odm&#125;/etc/init/ or .rc files</span><br><span class="line">      at specified paths during mount_all, not allowed for devices launching</span><br><span class="line">      after Q.</span><br><span class="line"></span><br><span class="line">The order that files are imported is a bit complex for legacy reasons.  The below is guaranteed:</span><br><span class="line"></span><br><span class="line">1. `/system/etc/init/hw/init.rc` is parsed then recursively each of its imports are</span><br><span class="line">   parsed.</span><br><span class="line">2. The contents of `/system/etc/init/` are alphabetized and parsed sequentially, with imports</span><br><span class="line">   happening recursively after each file is parsed.</span><br><span class="line">3. Step 2 is repeated for `/system_ext/etc/init`, `/vendor/etc/init`, `/odm/etc/init`,</span><br><span class="line">   `/product/etc/init`</span><br><span class="line"></span><br><span class="line">The below pseudocode may explain this more clearly:</span><br><span class="line"></span><br><span class="line">    fn Import(file)</span><br><span class="line">      Parse(file)</span><br><span class="line">      for (import : file.imports)</span><br><span class="line">        Import(import)</span><br><span class="line"></span><br><span class="line">    Import(/system/etc/init/hw/init.rc)</span><br><span class="line">    Directories = [/system/etc/init, /system_ext/etc/init, /vendor/etc/init, /odm/etc/init, /product/etc/init]</span><br><span class="line">    for (directory : Directories)</span><br><span class="line">      files = &lt;Alphabetical order of directory&#x27;s contents&gt;</span><br><span class="line">      for (file : files)</span><br><span class="line">        Import(file)</span><br><span class="line"></span><br><span class="line">Actions are executed in the order that they are parsed.  For example the `post-fs-data` action(s)</span><br><span class="line">in `/system/etc/init/hw/init.rc` are always the first `post-fs-data` action(s) to be executed in</span><br><span class="line">order of how they appear in that file.  Then the `post-fs-data` actions of the imports of</span><br><span class="line">`/system/etc/init/hw/init.rc` in the order that they&#x27;re imported, etc.</span><br><span class="line"></span><br><span class="line">Properties</span><br><span class="line">----------</span><br><span class="line">Init provides state information with the following properties.</span><br><span class="line"></span><br><span class="line">`init.svc.&lt;name&gt;`</span><br><span class="line">&gt; State of a named service (&quot;stopped&quot;, &quot;stopping&quot;, &quot;running&quot;, &quot;restarting&quot;)</span><br><span class="line"></span><br><span class="line">`dev.mnt.dev.&lt;mount_point&gt;`, `dev.mnt.blk.&lt;mount_point&gt;`, `dev.mnt.rootdisk.&lt;mount_point&gt;`</span><br><span class="line">&gt; Block device base name associated with a *mount_point*.</span><br><span class="line">  The *mount_point* has / replaced by . and if referencing the root mount point</span><br><span class="line">  &quot;/&quot;, it will use &quot;/root&quot;.</span><br><span class="line">  `dev.mnt.dev.&lt;mount_point&gt;` indicates a block device attached to filesystems.</span><br><span class="line">    (e.g., dm-N or sdaN/mmcblk0pN to access `/sys/fs/ext4/$&#123;dev.mnt.dev.&lt;mount_point&gt;&#125;/`)</span><br><span class="line"></span><br><span class="line">  `dev.mnt.blk.&lt;mount_point&gt;` indicates the disk partition to the above block device.</span><br><span class="line">    (e.g., sdaN / mmcblk0pN to access `/sys/class/block/$&#123;dev.mnt.blk.&lt;mount_point&gt;&#125;/`)</span><br><span class="line"></span><br><span class="line">  `dev.mnt.rootdisk.&lt;mount_point&gt;` indicates the root disk to contain the above disk partition.</span><br><span class="line">    (e.g., sda / mmcblk0 to access `/sys/class/block/$&#123;dev.mnt.rootdisk.&lt;mount_point&gt;&#125;/queue`)</span><br><span class="line"></span><br><span class="line">Init responds to properties that begin with `ctl.`.  These properties take the format of</span><br><span class="line">`ctl.[&lt;target&gt;_]&lt;command&gt;` and the _value_ of the system property is used as a parameter.  The</span><br><span class="line">_target_ is optional and specifies the service option that _value_ is meant to match with.  There is</span><br><span class="line">only one option for _target_, `interface` which indicates that _value_ will refer to an interface</span><br><span class="line">that a service provides and not the service name itself.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line"></span><br><span class="line">`SetProperty(&quot;ctl.start&quot;, &quot;logd&quot;)` will run the `start` command on `logd`.</span><br><span class="line"></span><br><span class="line">`SetProperty(&quot;ctl.interface_start&quot;, &quot;aidl/aidl_lazy_test_1&quot;)` will run the `start` command on the</span><br><span class="line">service that exposes the `aidl aidl_lazy_test_1` interface.</span><br><span class="line"></span><br><span class="line">Note that these</span><br><span class="line">properties are only settable; they will have no value when read.</span><br><span class="line"></span><br><span class="line">The _commands_ are listed below.</span><br><span class="line"></span><br><span class="line">`start` \</span><br><span class="line">`restart` \</span><br><span class="line">`stop` \</span><br><span class="line">These are equivalent to using the `start`, `restart`, and `stop` commands on the service specified</span><br><span class="line">by the _value_ of the property.</span><br><span class="line"></span><br><span class="line">`oneshot_on` and `oneshot_off` will turn on or off the _oneshot_</span><br><span class="line">flag for the service specified by the _value_ of the property.  This is</span><br><span class="line">particularly intended for services that are conditionally lazy HALs.  When</span><br><span class="line">they are lazy HALs, oneshot must be on, otherwise oneshot should be off.</span><br><span class="line"></span><br><span class="line">`sigstop_on` and `sigstop_off` will turn on or off the _sigstop_ feature for the service</span><br><span class="line">specified by the _value_ of the property.  See the _Debugging init_ section below for more details</span><br><span class="line">about this feature.</span><br><span class="line"></span><br><span class="line">Boot timing</span><br><span class="line">-----------</span><br><span class="line">Init records some boot timing information in system properties.</span><br><span class="line"></span><br><span class="line">`ro.boottime.init`</span><br><span class="line">&gt; Time after boot in ns (via the CLOCK\_BOOTTIME clock) at which the first</span><br><span class="line">  stage of init started.</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.first_stage`</span><br><span class="line">&gt; How long in ns it took to run first stage.</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.selinux`</span><br><span class="line">&gt; How long in ns it took to run SELinux stage.</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.modules`</span><br><span class="line">&gt; How long in ms it took to load kernel modules.</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.cold_boot_wait`</span><br><span class="line">&gt; How long init waited for ueventd&#x27;s coldboot phase to end.</span><br><span class="line"></span><br><span class="line">`ro.boottime.&lt;service-name&gt;`</span><br><span class="line">&gt; Time after boot in ns (via the CLOCK\_BOOTTIME clock) that the service was</span><br><span class="line">  first started.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bootcharting</span><br><span class="line">------------</span><br><span class="line">This version of init contains code to perform &quot;bootcharting&quot;: generating log</span><br><span class="line">files that can be later processed by the tools provided by &lt;http://www.bootchart.org/&gt;.</span><br><span class="line"></span><br><span class="line">On the emulator, use the -bootchart _timeout_ option to boot with bootcharting</span><br><span class="line">activated for _timeout_ seconds.</span><br><span class="line"></span><br><span class="line">On a device:</span><br><span class="line"></span><br><span class="line">    adb shell &#x27;touch /data/bootchart/enabled&#x27;</span><br><span class="line"></span><br><span class="line">Don&#x27;t forget to delete this file when you&#x27;re done collecting data!</span><br><span class="line"></span><br><span class="line">The log files are written to /data/bootchart/. A script is provided to</span><br><span class="line">retrieve them and create a bootchart.tgz file that can be used with the</span><br><span class="line">bootchart command-line utility:</span><br><span class="line"></span><br><span class="line">    sudo apt-get install pybootchartgui</span><br><span class="line">    # grab-bootchart.sh uses $ANDROID_SERIAL.</span><br><span class="line">    $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh</span><br><span class="line"></span><br><span class="line">One thing to watch for is that the bootchart will show init as if it started</span><br><span class="line">running at 0s. You&#x27;ll have to look at dmesg to work out when the kernel</span><br><span class="line">actually started init.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Comparing two bootcharts</span><br><span class="line">------------------------</span><br><span class="line">A handy script named compare-bootcharts.py can be used to compare the</span><br><span class="line">start/end time of selected processes. The aforementioned grab-bootchart.sh</span><br><span class="line">will leave a bootchart tarball named bootchart.tgz at /tmp/android-bootchart.</span><br><span class="line">If two such tarballs are preserved on the host machine under different</span><br><span class="line">directories, the script can list the timestamps differences. For example:</span><br><span class="line"></span><br><span class="line">Usage: system/core/init/compare-bootcharts.py _base-bootchart-dir_ _exp-bootchart-dir_</span><br><span class="line"></span><br><span class="line">    process: baseline experiment (delta) - Unit is ms (a jiffy is 10 ms on the system)</span><br><span class="line">    ------------------------------------</span><br><span class="line">    /init: 50 40 (-10)</span><br><span class="line">    /system/bin/surfaceflinger: 4320 4470 (+150)</span><br><span class="line">    /system/bin/bootanimation: 6980 6990 (+10)</span><br><span class="line">    zygote64: 10410 10640 (+230)</span><br><span class="line">    zygote: 10410 10640 (+230)</span><br><span class="line">    system_server: 15350 15150 (-200)</span><br><span class="line">    bootanimation ends at: 33790 31230 (-2560)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Systrace</span><br><span class="line">--------</span><br><span class="line">Systrace (&lt;http://developer.android.com/tools/help/systrace.html&gt;) can be</span><br><span class="line">used for obtaining performance analysis reports during boot</span><br><span class="line">time on userdebug or eng builds.</span><br><span class="line"></span><br><span class="line">Here is an example of trace events of &quot;wm&quot; and &quot;am&quot; categories:</span><br><span class="line"></span><br><span class="line">    $ANDROID_BUILD_TOP/external/chromium-trace/systrace.py \</span><br><span class="line">          wm am --boot</span><br><span class="line"></span><br><span class="line">This command will cause the device to reboot. After the device is rebooted and</span><br><span class="line">the boot sequence has finished, the trace report is obtained from the device</span><br><span class="line">and written as trace.html on the host by hitting Ctrl+C.</span><br><span class="line"></span><br><span class="line">Limitation: recording trace events is started after persistent properties are loaded, so</span><br><span class="line">the trace events that are emitted before that are not recorded. Several</span><br><span class="line">services such as vold, surfaceflinger, and servicemanager are affected by this</span><br><span class="line">limitation since they are started before persistent properties are loaded.</span><br><span class="line">Zygote initialization and the processes that are forked from the zygote are not</span><br><span class="line">affected.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Debugging init</span><br><span class="line">--------------</span><br><span class="line">When a service starts from init, it may fail to `execv()` the service. This is not typical, and may</span><br><span class="line">point to an error happening in the linker as the new service is started. The linker in Android</span><br><span class="line">prints its logs to `logd` and `stderr`, so they are visible in `logcat`. If the error is encountered</span><br><span class="line">before it is possible to access `logcat`, the `stdio_to_kmsg` service option may be used to direct</span><br><span class="line">the logs that the linker prints to `stderr` to `kmsg`, where they can be read via a serial port.</span><br><span class="line"></span><br><span class="line">Launching init services without init is not recommended as init sets up a significant amount of</span><br><span class="line">environment (user, groups, security label, capabilities, etc) that is hard to replicate manually.</span><br><span class="line"></span><br><span class="line">If it is required to debug a service from its very start, the `sigstop` service option is added.</span><br><span class="line">This option will send SIGSTOP to a service immediately before calling exec. This gives a window</span><br><span class="line">where developers can attach a debugger, strace, etc before continuing the service with SIGCONT.</span><br><span class="line"></span><br><span class="line">This flag can also be dynamically controlled via the ctl.sigstop_on and ctl.sigstop_off properties.</span><br><span class="line"></span><br><span class="line">Below is an example of dynamically debugging logd via the above:</span><br><span class="line"></span><br><span class="line">    stop logd</span><br><span class="line">    setprop ctl.sigstop_on logd</span><br><span class="line">    start logd</span><br><span class="line">    ps -e | grep logd</span><br><span class="line">    &gt; logd          4343     1   18156   1684 do_signal_stop 538280 T init</span><br><span class="line">    gdbclient.py -p 4343</span><br><span class="line">    b main</span><br><span class="line">    c</span><br><span class="line">    c</span><br><span class="line">    c</span><br><span class="line">    &gt; Breakpoint 1, main (argc=1, argv=0x7ff8c9a488) at system/core/logd/main.cpp:427</span><br><span class="line"></span><br><span class="line">Below is an example of doing the same but with strace</span><br><span class="line"></span><br><span class="line">    stop logd</span><br><span class="line">    setprop ctl.sigstop_on logd</span><br><span class="line">    start logd</span><br><span class="line">    ps -e | grep logd</span><br><span class="line">    &gt; logd          4343     1   18156   1684 do_signal_stop 538280 T init</span><br><span class="line">    strace -p 4343</span><br><span class="line"></span><br><span class="line">    (From a different shell)</span><br><span class="line">    kill -SIGCONT 4343</span><br><span class="line"></span><br><span class="line">    &gt; strace runs</span><br><span class="line"></span><br><span class="line">Host Init Script Verification</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">Init scripts are checked for correctness during build time. Specifically the below is checked.</span><br><span class="line"></span><br><span class="line">1) Well formatted action, service and import sections, e.g. no actions without a preceding &#x27;on&#x27;</span><br><span class="line">line, and no extraneous lines after an &#x27;import&#x27; statement.</span><br><span class="line">2) All commands map to a valid keyword and the argument count is within the correct range.</span><br><span class="line">3) All service options are valid. This is stricter than how commands are checked as the service</span><br><span class="line">options&#x27; arguments are fully parsed, e.g. UIDs and GIDs must resolve.</span><br><span class="line"></span><br><span class="line">There are other parts of init scripts that are only parsed at runtime and therefore not checked</span><br><span class="line">during build time, among them are the below.</span><br><span class="line"></span><br><span class="line">1) The validity of the arguments of commands, e.g. no checking if file paths actually exist, if</span><br><span class="line">SELinux would permit the operation, or if the UIDs and GIDs resolve.</span><br><span class="line">2) No checking if a service exists or has a valid SELinux domain defined</span><br><span class="line">3) No checking if a service has not been previously defined in a different init script.</span><br><span class="line"></span><br><span class="line">Early Init Boot Sequence</span><br><span class="line">------------------------</span><br><span class="line">The early init boot sequence is broken up into three stages: first stage init, SELinux setup, and</span><br><span class="line">second stage init.</span><br><span class="line"></span><br><span class="line">First stage init is responsible for setting up the bare minimum requirements to load the rest of the</span><br><span class="line">system. Specifically this includes mounting /dev, /proc, mounting &#x27;early mount&#x27; partitions (which</span><br><span class="line">needs to include all partitions that contain system code, for example system and vendor), and moving</span><br><span class="line">the system.img mount to / for devices with a ramdisk.</span><br><span class="line"></span><br><span class="line">Note that in Android Q, system.img always contains TARGET_ROOT_OUT and always is mounted at / by the</span><br><span class="line">time first stage init finishes. Android Q will also require dynamic partitions and therefore will</span><br><span class="line">require using a ramdisk to boot Android. The recovery ramdisk can be used to boot to Android instead</span><br><span class="line">of a dedicated ramdisk as well.</span><br><span class="line"></span><br><span class="line">First stage init has three variations depending on the device configuration:</span><br><span class="line">1) For system-as-root devices, first stage init is part of /system/bin/init and a symlink at /init</span><br><span class="line">points to /system/bin/init for backwards compatibility. These devices do not need to do anything to</span><br><span class="line">mount system.img, since it is by definition already mounted as the rootfs by the kernel.</span><br><span class="line"></span><br><span class="line">2) For devices with a ramdisk, first stage init is a static executable located at /init. These</span><br><span class="line">devices mount system.img as /system then perform a switch root operation to move the mount at</span><br><span class="line">/system to /. The contents of the ramdisk are freed after mounting has completed.</span><br><span class="line"></span><br><span class="line">3) For devices that use recovery as a ramdisk, first stage init it contained within the shared init</span><br><span class="line">located at /init within the recovery ramdisk. These devices first switch root to</span><br><span class="line">/first_stage_ramdisk to remove the recovery components from the environment, then proceed the same</span><br><span class="line">as 2). Note that the decision to boot normally into Android instead of booting</span><br><span class="line">into recovery mode is made if androidboot.force_normal_boot=1 is present in the</span><br><span class="line">kernel commandline, or in bootconfig with Android S and later.</span><br><span class="line"></span><br><span class="line">Once first stage init finishes it execs /system/bin/init with the &quot;selinux_setup&quot; argument. This</span><br><span class="line">phase is where SELinux is optionally compiled and loaded onto the system. selinux.cpp contains more</span><br><span class="line">information on the specifics of this process.</span><br><span class="line"></span><br><span class="line">Lastly once that phase finishes, it execs /system/bin/init again with the &quot;second_stage&quot;</span><br><span class="line">argument. At this point the main phase of init runs and continues the boot process via the init.rc</span><br><span class="line">scripts.</span><br></pre></td></tr></table></figure>

<p>chatgpt译文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br></pre></td><td class="code"><pre><span class="line">Android Init Language</span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line">Android Init语言由五个宽泛的语句类别组成：Actions（动作）、Commands（命令）、Services（服务）、Options（选项）和</span><br><span class="line">Imports（导入）。</span><br><span class="line"></span><br><span class="line">所有这些语句以行为单位，由空格分隔的标记组成。可以使用C风格的反斜杠转义将空格插入标记中。双引号也可以用于防止空格破坏文本形成</span><br><span class="line">多个标记。当反斜杠是行末字符时，可以用于行折叠。</span><br><span class="line"></span><br><span class="line">以`#`开头的行（允许前置空格）是注释。</span><br><span class="line"></span><br><span class="line">可以使用`$&#123;property.name&#125;`的语法扩展系统属性。这在需要连接的上下文中也适用，例如`import /init.recovery.$&#123;ro.hardware&#125;.rc`。</span><br><span class="line"></span><br><span class="line">Actions和Services隐式声明了一个新的区块。所有的命令或选项都属于最近声明的区块。在第一个区块之前的命令或选项将被忽略。</span><br><span class="line"></span><br><span class="line">Services具有唯一的名称。如果定义了第二个名称与现有Service相同的Service，则会被忽略并记录错误消息。</span><br><span class="line"></span><br><span class="line">Init .rc文件</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">Init语言用于采用.rc文件扩展的纯文本文件中。通常在系统中有多个这样的文件，如下所述。</span><br><span class="line"></span><br><span class="line">`/system/etc/init/hw/init.rc`是主要的.rc文件，由init可执行文件在其启动时加载。它负责系统的初始设置。</span><br><span class="line"></span><br><span class="line">在加载主要的`/system/etc/init/hw/init.rc`之后，Init会立即加载`/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/`目录</span><br><span class="line">中包含的所有文件。这在本文件的[Imports](#imports)部分中有更详细的解释。</span><br><span class="line"></span><br><span class="line">在Q之后启动的设备不再支持在mount_all期间导入init脚本。</span><br><span class="line"></span><br><span class="line">这些目录的目的是：</span><br><span class="line"></span><br><span class="line">   1. /system/etc/init/ 用于核心系统项，如SurfaceFlinger、MediaService和logd。</span><br><span class="line">   2. /vendor/etc/init/ 用于SoC供应商项，如用于核心SoC功能的动作或守护进程。</span><br><span class="line">   3. /odm/etc/init/ 用于设备制造商项，如用于运动传感器或其他外围设备功能的动作或守护进程。</span><br><span class="line"></span><br><span class="line">所有二进制文件位于系统、供应商或odm分区的服务应将其服务条目放置在相应的init .rc文件中，位于它们所在分区的/etc/init/目录中。</span><br><span class="line">开发人员可以使用构建系统宏LOCAL_INIT_RC来处理此问题。每个init .rc文件还应包含与其服务关联的任何操作。</span><br><span class="line"></span><br><span class="line">一个例子是位于system/core/logcat目录中的userdebug logcatd.rc和Android.mk文件。Android.mk文件中的LOCAL_INIT_RC宏在构建</span><br><span class="line">过程中将logcatd.rc放置在/system/etc/init/中。Init在执行mount_all命令时加载logcatd.rc，并在适当时运行服务和排队操作。</span><br><span class="line"></span><br><span class="line">将init .rc文件按照它们的守护进程进行拆分比以前使用的大型init .rc文件更可取。这种方法确保init读取的只有存在于文件系统上的二</span><br><span class="line">进制文件对应的服务条目，而在大型init .rc文件中并非如此。此外，当向系统添加多个服务时，这样分拆将有助于解决合并冲突，因为每个</span><br><span class="line">服务都将进入单独的文件。</span><br><span class="line"></span><br><span class="line">APEXs中的带版本的RC文件</span><br><span class="line">---------------------------</span><br><span class="line">随着在Android Q上的主线开始，各个主线模块在其范围内携带自己的init.rc文件。Init根据命名模式`/apex/*/etc/*rc`来处理这些文件。</span><br><span class="line"></span><br><span class="line">由于APEX模块必须在多个Android版本上运行，它们可能需要不同的参数作为其定义的服务的一部分。从Android T开始，通过在init文件名</span><br><span class="line">中加入SDK版本信息来实现。后缀从`.rc`变为`.#rc`，其中#是该RC文件被接受的第一个SDK版本。一个特定于SDK=31的init文件可以被命名</span><br><span class="line">为`init.31rc`。使用这种方案，一个APEX可以包含多个init文件。下面是一个示例。</span><br><span class="line"></span><br><span class="line">对于/apex/sample-module/apex/etc/目录下拥有以下文件的APEX模块：</span><br><span class="line"></span><br><span class="line">   1. init.rc</span><br><span class="line">   2. init.32rc</span><br><span class="line">   4. init.35rc</span><br><span class="line"></span><br><span class="line">选择规则选择不超过当前运行系统的SDK的最高`.#rc`值。不带后缀的`.rc`表示sdk=0。</span><br><span class="line"></span><br><span class="line">当此APEX安装在SDK &lt;=31的设备上时，系统会处理init.rc。当安装在运行SDK 32、33或34的设备上时，它将使用init.32rc。当安装在运</span><br><span class="line">行SDK &gt;= 35的设备上时，它将选择init.35rc。</span><br><span class="line"></span><br><span class="line">此版本方案仅适用于APEX模块中的init文件，不适用于存储在/system/etc/init、/vendor/etc/init或其他目录中的init文件。</span><br><span class="line"></span><br><span class="line">此命名方案在Android S之后提供。</span><br><span class="line"></span><br><span class="line">动作</span><br><span class="line">-------</span><br><span class="line">动作是命令的命名序列。动作有一个触发器，用于确定何时执行该动作。当发生与动作的触发器匹配的事件时，该动作将被添加到待执行队列</span><br><span class="line">的末尾（除非它已经在队列中）。</span><br><span class="line"></span><br><span class="line">队列中的每个动作都按顺序出队，并执行该动作中的每个命令。在执行活动命令期间，Init处理其他活动（设备创建/销毁、属性设置、进程</span><br><span class="line">重启）。</span><br><span class="line"></span><br><span class="line">动作的形式如下：</span><br><span class="line"></span><br><span class="line">    on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*</span><br><span class="line">       &lt;command&gt;</span><br><span class="line">       &lt;command&gt;</span><br><span class="line">       &lt;command&gt;</span><br><span class="line"></span><br><span class="line">根据包含它们的文件的解析顺序（请参阅导入部分），动作按顺序添加到队列并执行，然后在单个文件内顺序执行。</span><br><span class="line"></span><br><span class="line">例如，如果一个文件包含：</span><br><span class="line"></span><br><span class="line">    on boot</span><br><span class="line">       setprop a 1</span><br><span class="line">       setprop b 2</span><br><span class="line"></span><br><span class="line">    on boot &amp;&amp; property:true=true</span><br><span class="line">       setprop c 1</span><br><span class="line">       setprop d 2</span><br><span class="line"></span><br><span class="line">    on boot</span><br><span class="line">       setprop e 1</span><br><span class="line">       setprop f 2</span><br><span class="line"></span><br><span class="line">那么当`boot`触发器发生并且假设属性`true`等于`true`时，执行命令的顺序将是：</span><br><span class="line"></span><br><span class="line">    setprop a 1</span><br><span class="line">    setprop b 2</span><br><span class="line">    setprop c 1</span><br><span class="line">    setprop d 2</span><br><span class="line">    setprop e 1</span><br><span class="line">    setprop f 2</span><br><span class="line">    </span><br><span class="line">    服务</span><br><span class="line">--------</span><br><span class="line">服务是在init启动和（可选地）重新启动时运行的程序。服务的形式如下：</span><br><span class="line"></span><br><span class="line">    service &lt;名称&gt; &lt;路径&gt; [ &lt;参数&gt; ]*</span><br><span class="line">       &lt;选项&gt;</span><br><span class="line">       &lt;选项&gt;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line"> 选项</span><br><span class="line">--------</span><br><span class="line">选项是对服务的修改器。它们会影响到init运行服务的方式和时间。</span><br><span class="line"></span><br><span class="line">`capabilities [ &lt;capability&gt;\* ]`</span><br><span class="line">&gt; 在执行该服务时设置能力（capabilities）。&#x27;capability&#x27;应为一个Linux能力（capability），没有&quot;CAP_&quot;前缀，比如&quot;NET_ADMIN&quot;</span><br><span class="line">或&quot;SETPCAP&quot;。请参考http://man7.org/linux/man-pages/man7/capabilities.7.html 获取Linux能力的列表。</span><br><span class="line">  如果未提供任何能力，则该服务将被移除所有能力，即使它以root用户运行。</span><br><span class="line"></span><br><span class="line">`class &lt;name&gt; [ &lt;name&gt;\* ]`</span><br><span class="line">&gt; 为该服务指定类名（class names）。一个指定类的所有服务可以一起启动或停止。如果没有通过class选项指定类名，则该服务默认为</span><br><span class="line">&quot;default&quot;类。除了（必需的）第一个类名外，额外的类名用于分组服务。</span><br><span class="line">  &quot;animation&quot;类应包括所有启动动画和关机动画所需的服务。由于这些服务可以在启动过程的非常早期被启动，并且可能一直运行到关机</span><br><span class="line">  的最后阶段，因此不能保证可以访问/data分区。这些服务可以检查/data下的文件，但不能保持文件处于打开状态，且在/data不可用时应该正常工作。</span><br><span class="line"></span><br><span class="line">`console [&lt;console&gt;]`</span><br><span class="line">&gt; 该服务需要一个控制台。可选的第二个参数选择一个特定的控制台，而不使用默认规定的控制台。默认的&quot;/dev/console&quot;可以通过设置</span><br><span class="line">&quot;androidboot.console&quot;内核参数来更改。在所有情况下，应省略&quot;/dev/&quot;前缀，所以&quot;/dev/tty0&quot;可以指定为&quot;console tty0&quot;。</span><br><span class="line">  此选项将标准输入、标准输出和标准错误连接到控制台。它与stdio_to_kmsg选项互斥，后者只将标准输出和标准错误连接到kmsg。</span><br><span class="line"></span><br><span class="line">`critical [window=&lt;fatal crash window分钟&gt;] [target=&lt;fatal reboot目标&gt;]`</span><br><span class="line">&gt; 这是一个设备关键的服务。如果在_fatal crash window分钟_内它退出了超过四次，或者在启动完成之前退出，设备将重新启动到</span><br><span class="line">_fatal reboot目标_。</span><br><span class="line">  _fatal crash window分钟_的默认值为4，_fatal reboot目标_的默认值为&#x27;bootloader&#x27;。</span><br><span class="line">  可以通过将属性`init.svc_debug.no_fatal.&lt;service-name&gt;`设置为`true`来跳过对指定关键服务的致命重启，以进行测试。</span><br><span class="line">  </span><br><span class="line">  `disabled`</span><br><span class="line">&gt; 这个服务不会随其类一起自动启动。</span><br><span class="line">  必须通过名称或接口名称显式启动。</span><br><span class="line"></span><br><span class="line">`enter_namespace &lt;type&gt; &lt;path&gt;`</span><br><span class="line">&gt; 进入位于 _path_ 的 _type_ 类型的命名空间。仅支持网络命名空间，_type_ 设置为 &quot;net&quot;。请注意，每种 _type_ 类型只能进入一</span><br><span class="line">个命名空间。</span><br><span class="line"></span><br><span class="line">`file &lt;path&gt; &lt;type&gt;`</span><br><span class="line">&gt; 打开文件路径并将其文件描述符传递给启动的进程。_type_ 必须为</span><br><span class="line">  &quot;r&quot;、&quot;w&quot; 或 &quot;rw&quot;。对于原生可执行文件，请参阅 libcutils</span><br><span class="line">  android\_get\_control\_file()。</span><br><span class="line"></span><br><span class="line">`group &lt;groupname&gt; [ &lt;groupname&gt;\* ]`</span><br><span class="line">&gt; 在执行此服务之前切换到“groupname”。除了（必需的）第一个 groupname 之外的其他 groupname 用于设置进程的附加组（通过 </span><br><span class="line">	setgroups()）。</span><br><span class="line">  当前默认为 root。 （？？？应该默认为 nobody）</span><br><span class="line"></span><br><span class="line">`interface &lt;interface name&gt; &lt;instance name&gt;`</span><br><span class="line">&gt; 将此服务与其提供的一组 AIDL 或 HIDL 服务关联起来。接口名称必须是完全限定的名称而不是值名称。例如，这用于允许 servicemanager</span><br><span class="line">	或 hwservicemanager 惰性启动服务。</span><br><span class="line">  当提供多个接口时，此标记应多次使用。HIDL 接口的示例条目是 `interface vendor.foo.bar@1.0::IBaz default`。对于 AIDL 接口，</span><br><span class="line">  请使用`interface aidl &lt;instance name&gt;`。AIDL 接口的实例名称是</span><br><span class="line">  与 servicemanager 注册的实例名称一致，可以使用 `adb</span><br><span class="line">  shell dumpsys -l` 列出它们。</span><br><span class="line"></span><br><span class="line">`ioprio &lt;class&gt; &lt;priority&gt;`</span><br><span class="line">&gt; 通过 SYS_ioprio_set 系统调用设置此服务的 IO 优先级和 IO 优先级类。</span><br><span class="line">  _class_ 必须是 &quot;rt&quot;、&quot;be&quot; 或 &quot;idle&quot; 中的一个。_priority_ 必须是 0 - 7 范围内的整数。</span><br><span class="line"></span><br><span class="line">`keycodes &lt;keycode&gt; [ &lt;keycode&gt;\* ]`</span><br><span class="line">&gt; 设置触发该服务的按键代码。如果同时按下与传递的按键代码对应的所有按键，则服务将启动。这通常用于启动 bugreport 服务。</span><br><span class="line"></span><br><span class="line">&gt; 此选项可以接受属性而不是按键代码列表。在这种情况下，提供一个选项：按典型属性扩展格式的属性名。属性必须包含逗号分隔的按键代</span><br><span class="line">码值列表或文本 &#x27;none&#x27;，表示该服务不响应按键代码。</span><br><span class="line"></span><br><span class="line">&gt; 例如，`keycodes $&#123;some.property.name:-none&#125;`，其中 some.property.name 扩展</span><br><span class="line">  为 &quot;123,124,125&quot;。由于按键代码在 init 非常早期处理，</span><br><span class="line">  只能使用 PRODUCT_DEFAULT_PROPERTY_OVERRIDES 属性。</span><br><span class="line"></span><br><span class="line">`memcg.limit_in_bytes &lt;value&gt;` 和 `memcg.limit_percent &lt;value&gt;`</span><br><span class="line">&gt; 将子进程的 memory.limit_in_bytes 设置为 `limit_in_bytes`</span><br><span class="line">  字节和 `limit_percent` 中较小的一个，`limit_percent` 表示设备物理内存大小的百分比（仅在 memcg 挂载时）。</span><br><span class="line">  值必须大于等于 0。</span><br><span class="line"></span><br><span class="line">`memcg.limit_property &lt;value&gt;`</span><br><span class="line">&gt; 将子进程的 memory.limit_in_bytes 设置为指定属性的值（仅在 memcg 挂载时）。此属性将覆盖通过 `memcg.limit_in_bytes` </span><br><span class="line">和 `memcg.limit_percent` 指定的值。</span><br><span class="line"></span><br><span class="line">`memcg.soft_limit_in_bytes &lt;value&gt;`</span><br><span class="line">&gt; 将子进程的 memory.soft_limit_in_bytes 设置为指定值（仅在 memcg 挂载时），该值必须大于等于 0。</span><br><span class="line"></span><br><span class="line">`memcg.swappiness &lt;value&gt;`</span><br><span class="line">&gt; 将子进程的 memory.swappiness 设置为指定值（仅在 memcg 挂载时），该值必须大于等于 0。</span><br><span class="line"></span><br><span class="line">`namespace &lt;pid|mnt&gt;`</span><br><span class="line">&gt; 在 fork 服务时进入新的 PID 或挂载命名空间。</span><br><span class="line"></span><br><span class="line">`oneshot`</span><br><span class="line">&gt; 当服务退出时不重新启动。</span><br><span class="line"></span><br><span class="line">`onrestart`</span><br><span class="line">&gt; 在服务重新启动时执行命令（参见下文）。</span><br><span class="line"></span><br><span class="line">`oom_score_adjust &lt;value&gt;`</span><br><span class="line">&gt; 将子进程的 /proc/self/oom\_score\_adj 设置为指定值，</span><br><span class="line">  该值必须在 -1000 到 1000 范围内。</span><br><span class="line"></span><br><span class="line">`override`</span><br><span class="line">&gt; 表示此服务定义旨在覆盖先前定义的具有相同名称的服务。这通常用于在 /odm 上覆盖在 /vendor 上定义的服务。init 解析的具有此关</span><br><span class="line">	键字的最后一个服务定义将用于此服务。</span><br><span class="line">  请注意 init.rc 文件解析的顺序，因为出于向后兼容性原因，它具有一些特殊性。此文件的 &#x27;imports&#x27; 部分详细介绍了顺序。</span><br><span class="line"></span><br><span class="line">`priority &lt;priority&gt;`</span><br><span class="line">&gt; 服务进程的调度优先级。该值必须在</span><br><span class="line">  -20 到 19 的范围内。默认优先级为 0。优先级通过 setpriority() 设置。</span><br><span class="line">  </span><br><span class="line">  `reboot_on_failure &lt;目标&gt;`</span><br><span class="line">&gt; 如果该进程无法启动，或者进程以CLD_EXITED以外的退出代码或非0的状态码终止，则重新启动带有指定目标的系统。_target_ 的格式与</span><br><span class="line">sys.powerctl的参数相同。这主要用于在启动期间进行一些必要的检查。</span><br><span class="line"></span><br><span class="line">`restart_period &lt;秒数&gt;`</span><br><span class="line">&gt; 如果非一次性服务退出，则在其启动时间加上此持续时间后重新启动。默认为5秒，用于限制崩溃服务的速率。可以增加此值以适应定期运行</span><br><span class="line">的服务。例如，可以将其设置为3600表示服务应每小时运行一次，或者设置为86400表示服务应每天运行一次。</span><br><span class="line"></span><br><span class="line">`rlimit &lt;资源&gt; &lt;当前值&gt; &lt;最大值&gt;`</span><br><span class="line">&gt; 将给定的rlimit应用于服务。rlimit会被子进程继承，因此这实际上将给定的rlimit应用于由此服务启动的进程树。解析方式与下面的</span><br><span class="line">setrlimit命令类似。</span><br><span class="line"></span><br><span class="line">`seclabel &lt;安全标签&gt;`</span><br><span class="line">&gt; 在执行此服务之前切换到“seclabel”。主要用于从根文件系统运行的服务，例如ueventd、adbd。位于系统分区上的服务可以根据其文件</span><br><span class="line">安全上下文使用策略定义的转换代替。如果未指定，并且策略中未定义转换，则默认为init上下文。</span><br><span class="line"></span><br><span class="line">`setenv &lt;变量名&gt; &lt;值&gt;`</span><br><span class="line">&gt; 在启动的进程中将环境变量_name_设置为_value_。</span><br><span class="line"></span><br><span class="line">`shutdown &lt;关机行为&gt;`</span><br><span class="line">&gt; 设置服务进程的关机行为。如果未指定，则在关机过程中使用SIGTERM和SIGKILL终止服务。使用&quot;critical&quot;关机行为的服务在关机期间不</span><br><span class="line">会被终止，直到关机超时。当关机超时时，即使标记为&quot;shutdown critical&quot;的服务也会被终止。如果在关机开始时标记为</span><br><span class="line">&quot;shutdown critical&quot;的服务未运行，则会启动该服务。</span><br><span class="line"></span><br><span class="line">`sigstop`</span><br><span class="line">&gt; 在调用exec之前立即向服务发送SIGSTOP信号。这用于调试。关于如何使用该选项的更多信息，请参见下面有关调试的部分。</span><br><span class="line"></span><br><span class="line">`socket &lt;名称&gt; &lt;类型&gt; &lt;权限&gt; [ &lt;用户&gt; [ &lt;组&gt; [ &lt;安全标签&gt; ] ] ]`</span><br><span class="line">&gt; 创建名为/dev/socket/_name_的UNIX域套接字，并将其文件描述符传递给启动的进程。_type_必须是&quot;dgram&quot;、&quot;stream&quot;或&quot;seqpacket&quot;。</span><br><span class="line">_type_可以以&quot;+passcred&quot;结尾，以启用套接字上的SO_PASSCRED选项。用户和组默认为0。&#x27;seclabel&#x27;是套接字的SELinux安全上下文。它默</span><br><span class="line">认为服务的安全上下文，如seclabel中指定的，或根据服务可执行文件的安全上下文计算得出。对于原生可执行文件，请参见</span><br><span class="line">libcutils android\_get\_control\_socket()。</span><br><span class="line"></span><br><span class="line">`stdio_to_kmsg`</span><br><span class="line">&gt; 将stdout和stderr重定向到/dev/kmsg_debug。这对于在早期启动期间不使用本机Android日志记录且我们希望捕获其日志消息的服务非常</span><br><span class="line">有用。仅当启用/dev/kmsg_debug时，即仅在userdebug和eng构建上启用时，才会启用此功能。这与console选项互斥，console选项还会将</span><br><span class="line">stdin连接到给定的控制台。</span><br><span class="line"></span><br><span class="line">`task_profiles &lt;配置文件&gt; [ &lt;配置文件&gt;* ]`</span><br><span class="line">&gt; 在进程分叉时为进程设置任务配置文件。这旨在取代使用writepid选项将进程移动到cgroup的方法。</span><br><span class="line"></span><br><span class="line">`timeout_period &lt;秒数&gt;`</span><br><span class="line">&gt; 提供超时时间，在该时间之后，服务将被终止。在这里，将尊重oneshot关键字，因此一次性服务不会自动重新启动，但其他所有服务都会</span><br><span class="line">重新启动。这对于创建与上面描述的restart_period选项结合使用的周期性服务特别有用。</span><br><span class="line"></span><br><span class="line">`updatable`</span><br><span class="line">&gt; 标记服务可以后续被APEX覆盖（通过&#x27;override&#x27;选项）。具有可更新选项的服务在APEX全部激活之前启动时，执行将会延迟，直到激活完</span><br><span class="line">成。不标记为可更新的服务无法被APEX覆盖。</span><br><span class="line"></span><br><span class="line">`user &lt;用户名&gt;`</span><br><span class="line">&gt; 在执行此服务之前切换到&#x27;username&#x27;。当前默认为root。（？？？可能应默认为nobody）从Android M版本开始，即使进程需要Linux特</span><br><span class="line">权，也应使用此选项。以前，为了获取Linux特权，进程需要以root身份运行，请求特权，然后切换到所需的uid。这里有一种新的机制，通</span><br><span class="line">过fs\_config允许设备厂商向特定文件系统上的特定二进制文件添加Linux特权。该机制在</span><br><span class="line">&lt;http://source.android.com/devices/tech/config/filesystem.html&gt;上进行了描述。使用此新机制时，进程可以使用user选项选择其</span><br><span class="line">所需的uid，而无需以root身份运行。从Android O开始，进程还可以在其.rc文件中直接请求特权。参见下面的&quot;capabilities&quot;选项。</span><br><span class="line"></span><br><span class="line">`writepid &lt;文件&gt; [ &lt;文件&gt;* ]`</span><br><span class="line">&gt; 当进程分叉时，将子进程的pid写入给定的文件。用于cgroup/cpuset。如果未指定/dev/cpuset/下的文件，但系统属性</span><br><span class="line">&#x27;ro.cpuset.default&#x27;设置为非空的cpuset名称（例如&#x27;/foreground&#x27;），则pid将写入文件/dev/cpuset/_cpuset\_name_/tasks。</span><br><span class="line">对于将进程移动到cgroup，此选项的使用已过时。请改用task_profiles选项。</span><br><span class="line"></span><br><span class="line">触发器</span><br><span class="line">--------</span><br><span class="line">触发器是用来匹配特定类型事件并引发某个动作的字符串。</span><br><span class="line"></span><br><span class="line">触发器被分为事件触发器和属性触发器。</span><br><span class="line"></span><br><span class="line">事件触发器是由&#x27;trigger&#x27;命令或在init可执行文件中使用QueueEventTrigger()函数引发的字符串。它们采用简单的字符串形式，比</span><br><span class="line">如&#x27;boot&#x27;或&#x27;late-init&#x27;。</span><br><span class="line"></span><br><span class="line">属性触发器是在命名属性的值变为给定新值或命名属性的值变为任意新值时引发的字符串。它们采用&#x27;property:&lt;name&gt;=&lt;value&gt;&#x27;</span><br><span class="line">和&#x27;property:&lt;name&gt;=\*&#x27;的形式。在init的初始引导阶段，属性触发器还会进行评估并相应地引发。</span><br><span class="line"></span><br><span class="line">一个动作可以有多个属性触发器，但只能有一个事件触发器。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">`on boot &amp;&amp; property:a=b`定义了一个只有在&#x27;boot&#x27;事件触发发生且属性a等于b时才执行的动作。</span><br><span class="line"></span><br><span class="line">`on property:a=b &amp;&amp; property:c=d`定义了一个在以下三种情况下执行的动作：</span><br><span class="line"></span><br><span class="line">   1. 在初始引导期间，如果属性a=b且属性c=d。</span><br><span class="line">   2. 每当属性a从其他值过渡到值b时，而属性c已经等于d。</span><br><span class="line">   3. 每当属性c从其他值过渡到值d时，而属性a已经等于b。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">触发器顺序</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">在早期引导过程中，init使用以下一系列触发器。这些是在init.cpp中定义的内置触发器。</span><br><span class="line"></span><br><span class="line">   1. `early-init` - 首个触发器，在cgroups被配置之后、ueventd的冷启动完成之前触发。</span><br><span class="line">   2. `init` - 冷启动完成后触发。</span><br><span class="line">   3. `charger` - 如果`ro.bootmode == &quot;charger&quot;`，则触发。</span><br><span class="line">   4. `late-init` - 如果`ro.bootmode != &quot;charger&quot;`，或者通过healthd从充电模式启动，则触发。</span><br><span class="line"></span><br><span class="line">剩余的触发器由`init.rc`中配置，并非内置的。这些触发器的默认顺序在`init.rc`的&quot;on late-init&quot;事件下指定。在`init.rc`内部的</span><br><span class="line">动作被省略。</span><br><span class="line"></span><br><span class="line">   1. `early-fs` - 启动vold。</span><br><span class="line">   2. `fs` - Vold已启动。将未标记为first-stage或latemounted的分区挂载。</span><br><span class="line">   3. `post-fs` - 配置任何依赖早期挂载的内容。</span><br><span class="line">   4. `late-fs` - 挂载被标记为latemounted的分区。</span><br><span class="line">   5. `post-fs-data` - 挂载和配置`/data`；设置加密。如果在第一阶段init中无法挂载`/metadata`，则在这里重新格式化。</span><br><span class="line">   6. `zygote-start` - 启动Zygote。</span><br><span class="line">   7. `early-boot` - 在Zygote启动后。</span><br><span class="line">   8. `boot` - 在`early-boot`动作完成后。</span><br><span class="line">   </span><br><span class="line">   命令</span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`bootchart [start|stop]`</span><br><span class="line">&gt; 启动/停止启动图表记录。这些命令在默认的init.rc文件中存在，但仅当文件/data/bootchart/enabled存在时，启动图表记录才会生</span><br><span class="line">效；否则，启动图表记录的start/stop命令不起作用。</span><br><span class="line"></span><br><span class="line">`chmod &lt;octal-mode&gt; &lt;path&gt;`</span><br><span class="line">&gt; 更改文件访问权限。</span><br><span class="line"></span><br><span class="line">`chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;`</span><br><span class="line">&gt; 更改文件所有者和组。</span><br><span class="line"></span><br><span class="line">`class_start &lt;serviceclass&gt;`</span><br><span class="line">&gt; 如果指定类别的所有服务尚未运行，则启动它们。有关启动服务的更多信息，请参阅启动条目。</span><br><span class="line"></span><br><span class="line">`class_stop &lt;serviceclass&gt;`</span><br><span class="line">&gt; 如果指定类别的所有服务当前正在运行，则停止并禁用它们。</span><br><span class="line"></span><br><span class="line">`class_reset &lt;serviceclass&gt;`</span><br><span class="line">&gt; 如果指定类别的所有服务当前正在运行，则停止它们，但不禁用。稍后可以使用`class_start`命令重新启动它们。</span><br><span class="line"></span><br><span class="line">`class_restart [--only-enabled] &lt;serviceclass&gt;`</span><br><span class="line">&gt; 重新启动指定类别的所有服务。如果指定了`--only-enabled`选项，则跳过已禁用的服务。</span><br><span class="line"></span><br><span class="line">`copy &lt;src&gt; &lt;dst&gt;`</span><br><span class="line">&gt; 复制文件。与write类似，但适用于二进制/大量数据。关于src文件，不允许从符号链接文件和world-writable或group-writable文件</span><br><span class="line">复制。关于dst文件，如果文件不存在，则创建的默认模式是0600。如果dst文件是一个普通常规文件并且已经存在，则会被截断。</span><br><span class="line"></span><br><span class="line">`copy_per_line &lt;src&gt; &lt;dst&gt;`</span><br><span class="line">&gt; 逐行复制文件。与copy类似，但适用于dst是不能处理多行数据的sysfs节点。</span><br><span class="line"></span><br><span class="line">`domainname &lt;name&gt;`</span><br><span class="line">&gt; 设置域名。</span><br><span class="line"></span><br><span class="line">`enable &lt;servicename&gt;`</span><br><span class="line">&gt; 将禁用的服务变为启用状态，就好像该服务未指定禁用一样。</span><br><span class="line">  如果该服务应该在运行，则现在它将被启动。</span><br><span class="line">  通常在引导加载程序设置指定特定服务在需要时启动的变量时使用。例如：</span><br><span class="line"></span><br><span class="line">    on property:ro.boot.myfancyhardware=1</span><br><span class="line">        enable my_fancy_service_for_my_fancy_hardware</span><br><span class="line"></span><br><span class="line">`exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\* ]`</span><br><span class="line">&gt; 分支并以给定的参数执行命令。命令在“--”之后开始，以便可以提供可选的安全上下文、用户和辅助组。在此命令完成之前，不会执行其他</span><br><span class="line">命令。_seclabel_可以是“-”表示默认值。属性会在_argument_中展开。</span><br><span class="line">  Init会等待分支的进程退出后再继续执行命令。</span><br><span class="line"></span><br><span class="line">`exec_background [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\* ]`</span><br><span class="line">&gt; 分支并以给定的参数执行命令。这与“exec”命令类似处理。</span><br><span class="line">  不同之处在于，对于`exec_background`，init不会在该进程退出之前停止执行命令。</span><br><span class="line"></span><br><span class="line">`exec_start &lt;service&gt;`</span><br><span class="line">&gt; 启动给定的服务，并暂停处理其他init命令，直到该服务返回。该命令的功能类似于“exec”命令，但使用现有的服务定义替代exec参数向量。</span><br><span class="line"></span><br><span class="line">`export &lt;name&gt; &lt;value&gt;`</span><br><span class="line">&gt; 在全局环境中将环境变量_name_设置为_value_（该变量将被所有在执行此命令后启动的进程继承）</span><br><span class="line"></span><br><span class="line">`hostname &lt;name&gt;`</span><br><span class="line">&gt; 设置主机名。</span><br><span class="line"></span><br><span class="line">`ifup &lt;interface&gt;`</span><br><span class="line">&gt; 将网络接口_interface_上线。</span><br><span class="line"></span><br><span class="line">`insmod [-f] &lt;path&gt; [&lt;options&gt;]`</span><br><span class="line">&gt; 使用指定选项安装_path_处的模块。</span><br><span class="line">  -f: 强制安装模块，即使运行的内核版本和编译该模块的内核版本不匹配。</span><br><span class="line"></span><br><span class="line">`interface_start &lt;name&gt;`</span><br><span class="line">`interface_restart &lt;name&gt;`</span><br><span class="line">`interface_stop &lt;name&gt;`</span><br><span class="line">&gt; 查找提供接口_name_的服务（如果存在），并在其上分别运行`start`、`restart`或`stop`命令。_name_可以是完全限定的HIDL名称，</span><br><span class="line">格式为`&lt;interface&gt;/&lt;instance&gt;`，也可以是AIDL名称，格式为`aidl/&lt;interface&gt;`，例</span><br><span class="line">如`android.hardware.secure_element@1.1::ISecureElement/eSE1`或`aidl/aidl_lazy_test_1`。</span><br><span class="line"></span><br><span class="line">&gt; 注意，这些命令只作用于由`interface`服务选项指定的接口，而不作用于动态注册的接口。</span><br><span class="line"></span><br><span class="line">&gt; 这些命令的示例用法：\</span><br><span class="line">`interface_start android.hardware.secure_element@1.1::ISecureElement/eSE1`将启动</span><br><span class="line">提供`android.hardware.secure_element@1.1`和`eSI1`实例的HIDL服务。\</span><br><span class="line">`interface_start aidl/aidl_lazy_test_1`将启动提供`aidl_lazy_test_1`接口的AIDL服务。</span><br><span class="line"></span><br><span class="line">`load_exports &lt;path&gt;`</span><br><span class="line">&gt; 打开_path_处的文件，并导出其中声明的全局环境变量。每一行必须按照上述格式`export &lt;name&gt; &lt;value&gt;`。</span><br><span class="line"></span><br><span class="line">`load_system_props`</span><br><span class="line">&gt; （此操作已弃用，并且不会执行任何操作。）</span><br><span class="line"></span><br><span class="line">`load_persist_props`</span><br><span class="line">&gt; 在/data被解密后加载持久属性。</span><br><span class="line">  这在默认的init.rc中包含。</span><br><span class="line"></span><br><span class="line">`loglevel &lt;level&gt;`</span><br><span class="line">&gt; 将init的日志级别设置为整数级别，从7（所有日志）到0（仅致命日志）。数字值对应于内核日志级别，但此命令不会影响内核日志级别。</span><br><span class="line">使用`write`命令写入`/proc/sys/kernel/printk`以更改内核日志级别。属性在_level_中展开。</span><br><span class="line"></span><br><span class="line">`mark_post_data`</span><br><span class="line">&gt; 用于标记/data挂载后的点。</span><br><span class="line"></span><br><span class="line">`mkdir &lt;path&gt; [&lt;mode&gt;] [&lt;owner&gt;] [&lt;group&gt;] [encryption=&lt;action&gt;] [key=&lt;key&gt;]`</span><br><span class="line">&gt; 在_path_处创建目录，可选择使用给定的模式、所有者和组。如果未提供，目录将以权限755创建，并由root用户和root组拥有。如果提供</span><br><span class="line">了该参数，将在目录已存在时更新模式、所有者和组。</span><br><span class="line"></span><br><span class="line">&gt; _action_可以是以下之一：</span><br><span class="line">  * `None`：不采取加密操作；如果父目录已加密，则目录将被加密。</span><br><span class="line">  * `Require`：加密目录，如果加密失败，则中止引导过程。</span><br><span class="line">  * `Attempt`：尝试设置加密策略，如果失败继续执行。</span><br><span class="line">  * `DeleteIfNecessary`：递归删除必要的目录以设置加密策略。</span><br><span class="line"></span><br><span class="line">&gt; _key_可以是以下之一：</span><br><span class="line">  * `ref`：使用系统范围的DE密钥</span><br><span class="line">  * `per_boot_ref`：使用每次启动时新生成的密钥。</span><br><span class="line"></span><br><span class="line">`mount_all [ &lt;fstab&gt; ] [--&lt;option&gt;]`</span><br><span class="line">&gt; 在给定的fs\_mgr格式fstab上调用fs\_mgr\_mount\_all，可选使用选项&quot;early&quot;和&quot;late&quot;。</span><br><span class="line">  如果设置了“--early”，init可执行文件将跳过具有“latemount”标志的挂载条目，并触发fs加密状态事件。如果设置了“--late”，init</span><br><span class="line">  可执行文件将仅挂载具有“latemount”标志的条目。默认情况下，未设置选项，并且mount\_all将处理给定fstab中的所有条目。</span><br><span class="line">  如果未指定fstab参数，则在运行时将扫描fstab.$&#123;ro.boot.fstab_suffix&#125;、fstab.$&#123;ro.hardware&#125;</span><br><span class="line">  或fstab.$&#123;ro.hardware.platform&#125;，按照/odm/etc、/vendor/etc或/的顺序。</span><br><span class="line">  </span><br><span class="line">  `mount &lt;类型&gt; &lt;设备&gt; &lt;目录&gt; [ &lt;标志&gt;\*] [&lt;选项&gt;]`</span><br><span class="line">&gt; 尝试将指定的设备挂载到目录_dir_上。</span><br><span class="line">  _标志_包括&quot;ro&quot;、&quot;rw&quot;、&quot;remount&quot;、&quot;noatime&quot;，...</span><br><span class="line">  _选项_是一个逗号分隔的字符串，例如，barrier=1,noauto\_da\_alloc</span><br><span class="line"></span><br><span class="line">`perform_apex_config`</span><br><span class="line">&gt; 在APEX挂载后执行任务。例如，为已挂载的APEX创建数据目录、解析其配置文件，并更新链接器配置。仅在apexd将`apexd.status`设</span><br><span class="line">置为ready时通知挂载事件时使用。</span><br><span class="line"></span><br><span class="line">`restart [--only-if-running] &lt;服务&gt;`</span><br><span class="line">&gt; 停止并重启正在运行的服务，如果服务当前正在重新启动，则不执行任何操作，否则，仅启动服务。如果指定了&quot;--only-if-running&quot;，</span><br><span class="line">则只有在服务已经运行时才会重启服务。</span><br><span class="line"></span><br><span class="line">`restorecon &lt;路径&gt; [ &lt;路径&gt;\* ]`</span><br><span class="line">&gt; 将名为_path_的文件恢复为文件上指定的安全上下文中的状态。</span><br><span class="line">  对于由init.rc创建的目录不需要此操作，因为它们会自动进行正确的标记。</span><br><span class="line"></span><br><span class="line">`restorecon_recursive &lt;路径&gt; [ &lt;路径&gt;\* ]`</span><br><span class="line">&gt; 递归地将名为_path_的目录树恢复为文件上指定的安全上下文中的状态。</span><br><span class="line"></span><br><span class="line">`rm &lt;路径&gt;`</span><br><span class="line">&gt; 对给定路径调用unlink(2)。如果系统分区已经挂载，可能应该使用</span><br><span class="line">&quot;exec -- rm ...&quot; (provided the system partition is already mounted)。</span><br><span class="line"></span><br><span class="line">`rmdir &lt;路径&gt;`</span><br><span class="line">&gt; 对给定路径调用rmdir(2)。</span><br><span class="line"></span><br><span class="line">`readahead &lt;文件|目录&gt; [--fully]`</span><br><span class="line">&gt; 对给定的文件或指定目录中的文件调用readahead(2)。使用选项--fully以读取完整的文件内容。</span><br><span class="line"></span><br><span class="line">`setprop &lt;名称&gt; &lt;值&gt;`</span><br><span class="line">&gt; 将系统属性_name_的值设置为_value_。属性将在_value_中进行扩展。</span><br><span class="line"></span><br><span class="line">`setrlimit &lt;资源&gt; &lt;当前值&gt; &lt;最大值&gt;`</span><br><span class="line">&gt; 设置资源的rlimit。此设置将应用于在限制设置后启动的所有进程。它旨在在init早期进行设置，并应用于全局。</span><br><span class="line">  _资源_最好使用其文本表示（&#x27;cpu&#x27;、&#x27;rtio&#x27;等）或&#x27;RLIM_CPU&#x27;、&#x27;RLIM_RTIO&#x27;等表示。也可以将其指定为资源枚举对应的整数值。</span><br><span class="line">  _当前值_和_最大值_可以设置为&#x27;unlimited&#x27;或&#x27;-1&#x27;，表示无限制的rlimit。</span><br><span class="line">  </span><br><span class="line">  开始&lt;service&gt;</span><br><span class="line">通过启动服务来运行，如果服务尚未运行。</span><br><span class="line">请注意，这不是同步的，即使是同步的，也不能保证操作系统的调度程序会执行足够的次数来保证服务的状态。</span><br><span class="line">有关同步版本的&quot;start&quot;命令，请参阅&quot;exec_start&quot;命令。</span><br><span class="line"></span><br><span class="line">这带来了一个重要的结果，如果服务向其他服务提供功能，例如提供通信通道，那么仅仅在那些服务之前启动此服务是不足以保证在那些服务</span><br><span class="line">请求它之前已经建立了通道的。必须有一种单独的机制来做出任何这样的保证。</span><br><span class="line"></span><br><span class="line">停止&lt;service&gt;</span><br><span class="line">如果服务当前正在运行，则停止运行。</span><br><span class="line"></span><br><span class="line">swapon_all [&lt;fstab&gt;]</span><br><span class="line">在给定的fstab文件上调用fs_mgr_swapon_all命令。</span><br><span class="line">如果没有指定fstab参数，则会在/odm/etc、/vendor/etc或/根目录下以fstab.$&#123;ro.boot.fstab_suffix&#125;、fstab.$&#123;ro.hardware&#125;</span><br><span class="line">或fstab.$&#123;ro.hardware.platform&#125;的顺序进行扫描。</span><br><span class="line"></span><br><span class="line">symlink &lt;target&gt; &lt;path&gt;</span><br><span class="line">在路径_path_上创建一个带有值_target_的符号链接。</span><br><span class="line"></span><br><span class="line">sysclktz &lt;minutes_west_of_gmt&gt;</span><br><span class="line">设置系统时钟基准（如果系统时钟在GMT中嘀嗒，则为0）</span><br><span class="line"></span><br><span class="line">trigger &lt;event&gt;</span><br><span class="line">触发一个事件。用于将一个动作排队从另一个动作中执行。</span><br><span class="line"></span><br><span class="line">umount &lt;path&gt;</span><br><span class="line">卸载位于该路径的文件系统。</span><br><span class="line"></span><br><span class="line">umount_all [&lt;fstab&gt;]</span><br><span class="line">在给定的fstab文件上调用fs_mgr_umount_all命令。</span><br><span class="line">如果没有指定fstab参数，则会在/odm/etc、/vendor/etc或/根目录下以fstab.$&#123;ro.boot.fstab_suffix&#125;、fstab.$&#123;ro.hardware&#125;</span><br><span class="line">或fstab.$&#123;ro.hardware.platform&#125;的顺序进行扫描。</span><br><span class="line"></span><br><span class="line">verity_update_state</span><br><span class="line">用于更新dm-verity状态并设置由adb remount使用的partition._mount-point_.verified属性的内部实现细节，因为fs_mgr不能直接设</span><br><span class="line">置这些属性。这是自Android 12以来所需的，因为CtsNativeVerifiedBootTestCases将读取属性</span><br><span class="line">&quot;partition.$&#123;partition&#125;.verified.hash_alg&quot;以检查是否使用了sha1。有关更多详情，请参见https://r.android.com/1546980。</span><br><span class="line"></span><br><span class="line">wait &lt;path&gt; [&lt;timeout&gt;]</span><br><span class="line">轮询给定文件的存在，直到找到为止，或者超时已达到。如果未指定超时时间，默认为五秒。超时值可以是小数秒，以浮点数表示法指定。</span><br><span class="line"></span><br><span class="line">wait_for_prop &lt;name&gt; &lt;value&gt;</span><br><span class="line">等待系统属性_name_的值为_value_。_value_中的属性将被展开。如果属性_name_已经设置为_value_，则立即继续。</span><br><span class="line"></span><br><span class="line">write &lt;path&gt; &lt;content&gt;</span><br><span class="line">打开位于路径_path_的文件，并使用write(2)将字符串写入其中。</span><br><span class="line">如果文件不存在，则会创建文件。如果文件已存在，则会将其截断。_content_中的属性将被展开。</span><br><span class="line"></span><br><span class="line">导入</span><br><span class="line">-------</span><br><span class="line">`import &lt;路径&gt;`</span><br><span class="line">&gt; 解析一个init配置文件，扩展当前的配置。</span><br><span class="line">  如果`路径`是一个目录，则会解析目录中的每个文件作为配置文件。这是非递归的，嵌套目录不会被解析。</span><br><span class="line"></span><br><span class="line">import关键字不是一个命令，而是它自己的部分，即它不会作为一个动作的一部分发生，而是在解析文件时处理导入，并遵循以下逻辑。</span><br><span class="line"></span><br><span class="line">只有三种情况下，init可执行程序会导入.rc文件：</span><br><span class="line"></span><br><span class="line">   1. 当它在初始启动时导入`/system/etc/init/hw/init.rc`或由属性`ro.boot.init_rc`指示的脚本时。</span><br><span class="line">   2. 当它在导入`/system/etc/init/hw/init.rc`之后立即导入`/&#123;system,system_ext,vendor,odm,product&#125;/etc/init/`。</span><br><span class="line">   3. （不推荐使用）当它在mount_all期间导入/&#123;system,vendor,odm&#125;/etc/init/或.rc文件时，</span><br><span class="line">      不允许在Q之后启动的设备使用。</span><br><span class="line"></span><br><span class="line">文件的导入顺序因遗留原因而稍微复杂。以下是保证的：</span><br><span class="line"></span><br><span class="line">1. 首先，解析`/system/etc/init/hw/init.rc`，然后递归解析它的每个导入文件。</span><br><span class="line">2. `/system/etc/init/`的内容按字母顺序排序并顺序解析，每个文件解析后递归进行导入。</span><br><span class="line">3. 对`/system_ext/etc/init`，`/vendor/etc/init`，`/odm/etc/init`，`/product/etc/init`执行步骤2。</span><br><span class="line"></span><br><span class="line">下面的伪代码可以更清楚地解释这个问题：</span><br><span class="line"></span><br><span class="line">    fn Import(文件)</span><br><span class="line">      解析(文件)</span><br><span class="line">      for (导入 : 文件.导入)</span><br><span class="line">        导入(导入)</span><br><span class="line"></span><br><span class="line">    导入(/system/etc/init/hw/init.rc)</span><br><span class="line">    目录 = [/system/etc/init, /system_ext/etc/init, /vendor/etc/init, /odm/etc/init, /product/etc/init]</span><br><span class="line">    for (目录 : 目录)</span><br><span class="line">      文件 = &lt;按目录内容的字母顺序排序&gt;</span><br><span class="line">      for (文件 : 文件)</span><br><span class="line">        导入(文件)</span><br><span class="line"></span><br><span class="line">动作按照解析顺序执行。例如，在`/system/etc/init/hw/init.rc`中的`post-fs-data`动作总是按照它们在文件中出现的顺序执行。</span><br><span class="line">然后，按导入的顺序执行`/system/etc/init/hw/init.rc`的导入中的`post-fs-data`动作，依此类推。</span><br><span class="line"></span><br><span class="line">属性</span><br><span class="line">------</span><br><span class="line">Init提供以下属性的状态信息。</span><br><span class="line"></span><br><span class="line">`init.svc.&lt;名称&gt;`</span><br><span class="line">&gt; 一个命名服务的状态（&quot;stopped&quot;，&quot;stopping&quot;，&quot;running&quot;，&quot;restarting&quot;）</span><br><span class="line"></span><br><span class="line">`dev.mnt.dev.&lt;挂载点&gt;`，`dev.mnt.blk.&lt;挂载点&gt;`，`dev.mnt.rootdisk.&lt;挂载点&gt;`</span><br><span class="line">&gt; 与*挂载点*关联的块设备基本名称。</span><br><span class="line">  *挂载点*将/替换为.，如果引用根挂载点&quot;/&quot;，则使用&quot;/root&quot;。</span><br><span class="line">  `dev.mnt.dev.&lt;挂载点&gt;`表示附加到文件系统的块设备。</span><br><span class="line">    （例如，使用`$&#123;dev.mnt.dev.&lt;挂载点&gt;&#125;`/sys/fs/ext4/来访问）</span><br><span class="line"></span><br><span class="line">  `dev.mnt.blk.&lt;挂载点&gt;`表示上述块设备的磁盘分区。</span><br><span class="line">    （例如，使用`/sys/class/block/$&#123;dev.mnt.blk.&lt;挂载点&gt;&#125;`来访问）</span><br><span class="line"></span><br><span class="line">  `dev.mnt.rootdisk.&lt;挂载点&gt;`表示包含上述磁盘分区的根磁盘。</span><br><span class="line">    （例如，使用`/sys/class/block/$&#123;dev.mnt.rootdisk.&lt;挂载点&gt;&#125;/queue`来访问）</span><br><span class="line"></span><br><span class="line">Init会响应以`ctl.`开头的属性。这些属性的格式为`ctl.[&lt;target&gt;_]&lt;command&gt;`，系统属性的_value_将用作参数。</span><br><span class="line">_target_是可选的，指定_value_应与哪个服务选项匹配。_target_只有一个选项，即`interface`，表示_value_将引用服务提供的接口，</span><br><span class="line">而不是服务名称本身。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">`SetProperty(&quot;ctl.start&quot;, &quot;logd&quot;)` 将在 `logd` 上运行 `start` 命令。</span><br><span class="line"></span><br><span class="line">`SetProperty(&quot;ctl.interface_start&quot;, &quot;aidl/aidl_lazy_test_1&quot;)` 将在公开 `aidl aidl_lazy_test_1` 接口的服务上运行</span><br><span class="line">`start` 命令。</span><br><span class="line"></span><br><span class="line">请注意，这些属性只是可设置的，当读取时它们没有值。</span><br><span class="line"></span><br><span class="line">以下是 _commands_。</span><br><span class="line"></span><br><span class="line">`start` \</span><br><span class="line">`restart` \</span><br><span class="line">`stop` \</span><br><span class="line">这等效于在由属性的 _value_ 指定的服务上使用 `start`、`restart` 和 `stop` 命令。</span><br><span class="line"></span><br><span class="line">`oneshot_on` 和 `oneshot_off` 将打开或关闭由属性的 _value_ 指定的服务的 _oneshot_ 标志。这特别适用于条件上懒加载硬件抽</span><br><span class="line">象层 (HAL) 的服务。当它们是懒加载 HAL 时，oneshot 必须开启，否则 oneshot 应该关闭。</span><br><span class="line"></span><br><span class="line">`sigstop_on` 和 `sigstop_off` 将打开或关闭由属性的 _value_ 指定的服务的 _sigstop_ 功能。有关此功能的更多详细信息，请参阅</span><br><span class="line">下面的 _Debugging init_ 部分。</span><br><span class="line"></span><br><span class="line">引导时间</span><br><span class="line">-----------</span><br><span class="line">Init 在系统属性中记录了一些引导时间信息。</span><br><span class="line"></span><br><span class="line">`ro.boottime.init`</span><br><span class="line">&gt; 使用 CLOCK_BOOTTIME 时钟以纳秒为单位记录的启动后阶段 init 开始的时间。</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.first_stage`</span><br><span class="line">&gt; 运行第一阶段所需的时间，以纳秒为单位。</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.selinux`</span><br><span class="line">&gt; 运行 SELinux 阶段所需的时间，以纳秒为单位。</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.modules`</span><br><span class="line">&gt; 加载内核模块所需的时间，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">`ro.boottime.init.cold_boot_wait`</span><br><span class="line">&gt; init 等待 ueventd 的冷启动阶段结束的时间，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">`ro.boottime.&lt;service-name&gt;`</span><br><span class="line">&gt; 服务首次启动后的时间，以 CLOCK_BOOTTIME 时钟为单位，以纳秒表示。</span><br><span class="line"></span><br><span class="line">Bootcharting</span><br><span class="line">------------</span><br><span class="line">这个版本的init包含有执行“bootcharting”的代码：生成日志文件，可以在之后使用&lt;http://www.bootchart.org/&gt;提供的工具进行处理。</span><br><span class="line"></span><br><span class="line">在模拟器上，使用-bootchart _timeout_选项激活bootcharting功能，持续_timeout_秒。</span><br><span class="line"></span><br><span class="line">在设备上：</span><br><span class="line"></span><br><span class="line">    adb shell &#x27;touch /data/bootchart/enabled&#x27;</span><br><span class="line"></span><br><span class="line">完成数据收集后，请不要忘记删除此文件！</span><br><span class="line"></span><br><span class="line">日志文件将被写入到/data/bootchart/。提供了一个脚本来检索这些文件并创建一个可以与bootchart命令行工具一起使用的bootchart.tgz</span><br><span class="line">文件：</span><br><span class="line"></span><br><span class="line">    sudo apt-get install pybootchartgui</span><br><span class="line">    # grab-bootchart.sh使用$ANDROID_SERIAL。</span><br><span class="line">    $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh</span><br><span class="line"></span><br><span class="line">需要注意的一点是，bootchart将显示init从0秒开始运行。您需要查看dmesg来确定内核实际上何时启动init。</span><br><span class="line"></span><br><span class="line">比较两个bootchart</span><br><span class="line">------------------------</span><br><span class="line">一个方便的脚本名为compare-bootcharts.py用于比较所选进程的开始/结束时间。上述的grab-bootchart.sh将</span><br><span class="line">在/tmp/android-bootchart下留下一个名为bootchart.tgz的bootchart tarball。如果在主机上的不同目录下保存了两个这</span><br><span class="line">样的tarballs，脚本可以列出时间戳的差异。例如：</span><br><span class="line"></span><br><span class="line">用法：system/core/init/compare-bootcharts.py _base-bootchart-dir_ _exp-bootchart-dir_</span><br><span class="line"></span><br><span class="line">    进程：基准 实验 (增量) - 单位为ms（系统上的jiffy是10ms）</span><br><span class="line">    ------------------------------------</span><br><span class="line">    /init: 50 40 (-10)</span><br><span class="line">    /system/bin/surfaceflinger: 4320 4470 (+150)</span><br><span class="line">    /system/bin/bootanimation: 6980 6990 (+10)</span><br><span class="line">    zygote64: 10410 10640 (+230)</span><br><span class="line">    zygote: 10410 10640 (+230)</span><br><span class="line">    system_server: 15350 15150 (-200)</span><br><span class="line">    bootanimation ends at: 33790 31230 (-2560)</span><br><span class="line"></span><br><span class="line">Systrace</span><br><span class="line">--------</span><br><span class="line">在userdebug或eng构建上，可以使用Systrace (&lt;http://developer.android.com/tools/help/systrace.html&gt;) 获取在启动过程中</span><br><span class="line">的性能分析报告。</span><br><span class="line"></span><br><span class="line">以下是“wm”和“am”类别的示例跟踪事件：</span><br><span class="line"></span><br><span class="line">    $ANDROID_BUILD_TOP/external/chromium-trace/systrace.py \</span><br><span class="line">          wm am --boot</span><br><span class="line"></span><br><span class="line">该命令将导致设备重新启动。设备重新启动并完成启动顺序后，通过按Ctrl+C从设备获取跟踪报告，并将其作为trace.html写入主机。</span><br><span class="line"></span><br><span class="line">限制：记录跟踪事件是在加载持久属性之后开始的，因此不记录在那之前发出的跟踪事件。一些服务，如vold、surfaceflinger和</span><br><span class="line">servicemanager受到此限制的影响，因为它们在加载持久属性之前启动。Zygote初始化和从Zygote派生的进程不受影响。</span><br><span class="line"></span><br><span class="line">调试初始化</span><br><span class="line">--------------</span><br><span class="line">当一个服务从init启动时，可能会无法`execv()`该服务。这种情况并不常见，可能是由于新服务启动时链接器发生错误引起的。Android中的</span><br><span class="line">链接器将其日志打印到`logd`和`stderr`中，因此它们可以在`logcat`中看到。如果在访问`logcat`之前遇到错误，可以使</span><br><span class="line">用`stdio_to_kmsg`服务选项将链接器打印到`stderr`中的日志导向到`kmsg`，然后可以通过串口读取这些日志。</span><br><span class="line"></span><br><span class="line">不建议在没有init的情况下启动init服务，因为init设置了大量环境（用户、组、安全标签、能力等），很难手动复制。</span><br><span class="line"></span><br><span class="line">如果需要从服务的起始位置开始调试，可以添加`sigstop`服务选项。该选项将在调用exec之前立即发送SIGSTOP给服务。在继续使用SIGCONT</span><br><span class="line">继续服务之前，开发者可以通过附加调试器、strace等进行调试。</span><br><span class="line"></span><br><span class="line">该标志也可以通过ctl.sigstop_on和ctl.sigstop_off属性动态控制。</span><br><span class="line"></span><br><span class="line">以下是通过上述方法动态调试logd的示例：</span><br><span class="line"></span><br><span class="line">    stop logd</span><br><span class="line">    setprop ctl.sigstop_on logd</span><br><span class="line">    start logd</span><br><span class="line">    ps -e | grep logd</span><br><span class="line">    &gt; logd          4343     1   18156   1684 do_signal_stop 538280 T init</span><br><span class="line">    gdbclient.py -p 4343</span><br><span class="line">    b main</span><br><span class="line">    c</span><br><span class="line">    c</span><br><span class="line">    c</span><br><span class="line">    &gt; Breakpoint 1, main (argc=1, argv=0x7ff8c9a488) at system/core/logd/main.cpp:427</span><br><span class="line"></span><br><span class="line">以下是使用strace进行相同操作的示例：</span><br><span class="line"></span><br><span class="line">    stop logd</span><br><span class="line">    setprop ctl.sigstop_on logd</span><br><span class="line">    start logd</span><br><span class="line">    ps -e | grep logd</span><br><span class="line">    &gt; logd          4343     1   18156   1684 do_signal_stop 538280 T init</span><br><span class="line">    strace -p 4343</span><br><span class="line"></span><br><span class="line">    （从另一个Shell执行）</span><br><span class="line">    kill -SIGCONT 4343</span><br><span class="line"></span><br><span class="line">    &gt; strace运行</span><br><span class="line"></span><br><span class="line">主机Init脚本验证</span><br><span class="line">-----------------------------</span><br><span class="line">在构建时会检查Init脚本的正确性。具体检查如下所示。</span><br><span class="line"></span><br><span class="line">1) 格式良好的action、service和import部分，例如没有在&#x27;import&#x27;语句之后多余的行，没有在&#x27;on&#x27;行之前的动作。</span><br><span class="line">2) 所有命令都映射到有效的关键词，并且参数计数在正确范围内。</span><br><span class="line">3) 所有服务选项都是有效的。这比命令检查更严格，因为服务选项的参数会完全解析，例如需要解析UID和GID。</span><br><span class="line"></span><br><span class="line">还有一些Init脚本的其他部分是仅在运行时解析的，因此在构建时不会进行检查，其中包括以下内容。</span><br><span class="line"></span><br><span class="line">1) 命令的参数的有效性，例如不会检查文件路径是否存在，SELinux是否允许操作，以及UID和GID是否可解析。</span><br><span class="line">2) 不会检查服务是否存在或是否定义了有效的SELinux域。</span><br><span class="line">3) 不会检查服务是否在其他Init脚本中已经定义。</span><br><span class="line"></span><br><span class="line">早期Init引导顺序</span><br><span class="line">------------------------</span><br><span class="line">早期Init引导顺序分为三个阶段：第一阶段init、SELinux设置、第二阶段init。</span><br><span class="line"></span><br><span class="line">第一阶段init负责设置加载系统的最低要求。具体包括挂载/dev、/proc，挂载&#x27;early mount&#x27;分区（需要包括包含系统代码的所有分区，</span><br><span class="line">例如system和vendor），并将system.img挂载到/（对于使用ramdisk的设备）。</span><br><span class="line"></span><br><span class="line">需要注意的是，在Android Q中，system.img始终包含TARGET_ROOT_OUT，并且总是在第一阶段init完成时挂载到/。Android Q还需要动态</span><br><span class="line">分区，因此需要使用ramdisk引导Android。还可以使用恢复ramdisk来引导到Android，而不是使用专用的ramdisk。</span><br><span class="line"></span><br><span class="line">根据设备配置的不同，第一阶段init有三个变种：</span><br><span class="line">1) 对于system-as-root设备，第一阶段init是/system/bin/init的一部分，而/init是一个指向/system/bin/init的符号链接，以向后兼</span><br><span class="line">容。这些设备不需要执行任何操作来挂载system.img，因为根据定义，它已经被内核作为根文件系统挂载。</span><br><span class="line"></span><br><span class="line">2) 对于具有ramdisk的设备，第一阶段init是位于/init的静态可执行文件。这些设备将system.img挂载为/system，然后通过切换根操作将</span><br><span class="line">挂载点从/system移动到/。挂载完成后，ramdisk的内容被释放。</span><br><span class="line"></span><br><span class="line">3) 对于使用恢复模式作为ramdisk的设备，在恢复ramdisk中的/shared init中包含了第一阶段init。这些设备首先切换根目录到</span><br><span class="line">/first_stage_ramdisk，以从环境中删除恢复组件，然后像第二种情况一样继续处理。注意，决定正常启动到Android而不是启动到恢复模</span><br><span class="line">式时，是通过内核命令行中是否存在androidboot.force_normal_boot=1或在Android S及更高版本中的bootconfig中指定。</span><br><span class="line"></span><br><span class="line">第一阶段init完成后，它会使用&quot;selinux_setup&quot;参数执行/system/bin/init。此阶段是可选地编译和加载SELinux到系统上。有关此过程</span><br><span class="line">的详细信息，请参阅selinux.cpp。</span><br><span class="line"></span><br><span class="line">最后，一旦该阶段完成，它会再次使用&quot;second_stage&quot;参数执行/system/bin/init。此时，主要的init阶段运行，并通过init.rc脚本继续</span><br><span class="line">引导过程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/NDK/蒋超大佬扫盲/10.线程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/NDK/">NDK</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/">蒋超大佬扫盲</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p><strong>一. 什么是线程？</strong></p>
<p>这个基本不用多说了吧，学过编程的都知道，但还是简单介绍以下。线程是CPU调度的最小单位，被包含在进程之中，拥有自己的栈空间，和进程共享堆等其他资源，所以在多线程环境中存在线程同步，互斥等问题。</p>
<p><strong>小知识点</strong></p>
<p>其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone( )。该系统调用copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。 copy后的进程和原先的进程共享了所有的变量，运行环境。这样，原先进程中的变量变动在copy后的进程中便能体现出来。</p>
<p> <strong>提示</strong></p>
<p>本次课程使用ubuntu 环境 、vim编辑器</p>
<p>编译命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">man xx linux方法使用说明</span></span><br><span class="line">man pthread_create</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译c文件  编译线程加-lpthread</span></span><br><span class="line">gcc xxx.c -lpthread</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">strerror(xx)将错误码翻译成字符串</span></span><br><span class="line">strerror(ret)or(xx)</span><br></pre></td></tr></table></figure>

<p> <strong>二. 线程的创建函数pthread_create</strong></p>
<p>用于创建一个线程，对应进程中就是fork函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#man xx linux查询xx方法使用说明</span></span><br><span class="line">man pthread_create</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tidp,<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_rtn)(<span class="type">void</span>*),<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</span></span><br><span class="line"><span class="comment">// 返回成功时，由tidp指向的内存单元被设置为新创建线程的线程ID.attr参数用于指定各种不同的线程属性。新创建的线程从start_rtn函</span></span><br><span class="line"><span class="comment">//数的地址开始运行，该函数只有一个万能指针参数arg，如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构</span></span><br><span class="line"><span class="comment">//中，然后把这个结构的地址作为arg的参数传入。</span></span><br><span class="line"><span class="comment">// 失败返回errno</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// 第一个参数为指向线程标识符的指针。</span></span><br><span class="line"><span class="comment">// 第二个参数用来设置线程属性。</span></span><br><span class="line"><span class="comment">// 第三个参数是线程运行函数的起始地址。</span></span><br><span class="line"><span class="comment">// 最后一个参数是运行函数的参数。</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//fprintf打印</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//不加休眠就直接运行结束了，不会显示打印的日志                                                                                    </span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>三. 线程ID获取函数pthread_self</strong></p>
<p>进程有进程ID，用getpid()。线程同样也有线程ID，对应的函数就是pthread_self函数,用来获取当前线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值：成功线程ID；失败:其他</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child pthread: pid = %d tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread: pid = %d   tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                             </span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>四. 线程退出函数pthread_exit函数</strong></p>
<p>线程通过调用pthread_exit函数终止执行，就如同进程在结束时调用exit函数一样。这个函数的作用是，终止调用它的线程并返回一个指向某个对象的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span>;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testxxx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;need exit.............  [%s][%d] \n&quot;</span>, __func__, __LINE__);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_return</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;need exit ...........................[%s][%d]\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child pthread: pid = %d tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func------------------\n&quot;</span>);</span><br><span class="line">    test_return();</span><br><span class="line">    testxxx();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread: pid = %d   tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);                                                                    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                                                                 </span><br></pre></td></tr></table></figure>

<p><strong>五. pthread_join函数</strong></p>
<p>等待线程的结束，线程间同步的操作。以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 ：thread: 线程标识符，即线程ID，标识唯一线程。</span></span><br><span class="line"><span class="comment">// retval: 用户定义的指针，用来存储被等待线程的返回值。</span></span><br><span class="line"><span class="comment">// 返回值 ： 0代表成功。 失败，返回的则是errno。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testxxx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;need exit.............  [%s][%d] \n&quot;</span>, __func__, __LINE__);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_return</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;need exit ...........................[%s][%d]\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child pthread: pid = %d tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func------------------\n&quot;</span>);</span><br><span class="line">    test_return();</span><br><span class="line">    testxxx();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread: pid = %d   tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    ret = pthread_join(tid, &amp;r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r = %d\n&quot;</span>, (<span class="type">int</span>)r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main end\n&quot;</span>);                                                                          </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>六. pthread_cancel函数</strong></p>
<p>终止一个线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">// 参数：线程标识符，即线程ID，标识唯一线程。</span></span><br><span class="line"><span class="comment">// 返回值：0代表成功。 失败，返回的则是errno。</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child pthread: pid = %d tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun_1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span>                                                            </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="comment">// int ret = pthread_create(&amp;tid, NULL, func, NULL);</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun_1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread: pid = %d   tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    ret = pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    ret = pthread_join(tid, &amp;r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r = %d\n&quot;</span>, r);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main end\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>小提示</strong></p>
<p>必须要有系统调用，线程必须到达一个取消点才可以杀死线程。可以主动添加一个取消点：pthread_testcancel();</p>
<p><strong>七. pthread_detach函数</strong></p>
<p>线程分离函数，线程结束后，直接自动释放，不用主动回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">// 参数：线程标识符，即线程ID，标识唯一线程。</span></span><br><span class="line"><span class="comment">// 返回值：0代表成功。 失败，返回的则是errno。</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child pthread: pid = %d tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_detach error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread: pid = %d   tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                                                                                                     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>八. 线程属性pthread_attr_t</strong></p>
<p>做简单了解：通过线程属性设置线程分离</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span>                        etachstate;            <span class="comment">// 线程的分离状态</span></span><br><span class="line">	<span class="type">int</span>                        schedpolicy;           <span class="comment">// 线程的调度策略</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>         <span class="title">schedparam</span>;</span>            <span class="comment">// 线程的调度参数</span></span><br><span class="line">	<span class="type">int</span>                        inheritsched;          <span class="comment">// 线程的继承性</span></span><br><span class="line">	<span class="type">int</span>                        scope;                 <span class="comment">// 线程的作用域</span></span><br><span class="line">	<span class="type">size_t</span>                     guardsize;             <span class="comment">// 线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">	<span class="type">int</span>                        stackaddr_set;         <span class="comment">// 线程的栈设置</span></span><br><span class="line">	<span class="type">void</span> *                     stackaddr;             <span class="comment">// 线程栈的位置</span></span><br><span class="line">	<span class="type">size_t</span>                     stacksize;             <span class="comment">// 线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程属性初始化: 成功：0  失败：errno</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">// 销毁线程属性所占用的资源: 成功0  失败：errno</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程属性：是否分离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="comment">// 获取线程属性：是否分离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// detachstate:</span></span><br><span class="line"><span class="comment">// PTHREAD_CREATE_DETACHED: 分离线程</span></span><br><span class="line"><span class="comment">// PTHREAD_CREATE_JOINABLE： 非分离线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child pthread: pid = %d tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    ret = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_attr_init error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_attr_setdetachstate error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tid, &amp;attr, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_detach(tid);                                                                 </span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_detach error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread: pid = %d   tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                               </span><br></pre></td></tr></table></figure>




            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/NDK/Android进阶之旅/20.jni方法大全及使用示例" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/NDK/">NDK</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/">Android进阶之旅</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p><strong>一、说明</strong><br>这里介绍的函数大多是 NDK 开发中常用的函数，但并不是全部，内容稍多，基本可以满足我们的开发需求了，建议通过目录索引来找需要了解的。<br>这里的函数都是 JNIEnv 操作的相关函数，JNI_OnLoad 等 JavaVM 的方法不在这里介绍。<br>JNI 有 C、C++ 两种代码风格，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C风格：(*env)-&gt;NewStringUTF(env, &quot;Hellow World!&quot;);</span><br><span class="line">C++风格：env-&gt;NewStringUTF(&quot;Hellow World!&quot;);</span><br></pre></td></tr></table></figure>

<p>这里我们使用 C++ 风格作为示例。</p>
<p><strong>二、获取版本</strong></p>
<ol>
<li>jint GetVersion()<br>说明：获取当前 JNI 的版本号<br>返回值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define JNI_VERSION_1_1 0x00010001</span><br><span class="line">#define JNI_VERSION_1_2 0x00010002</span><br><span class="line">#define JNI_VERSION_1_4 0x00010004</span><br><span class="line">#define JNI_VERSION_1_6 0x00010006</span><br></pre></td></tr></table></figure>

<p><strong>三、类操作</strong></p>
<ol>
<li><code>jclass FindClass(const char* name)</code><br>说明：根据类的全路径找到相应的 jclass 对象<br>参数：</li>
</ol>
<ul>
<li>name：类的全路径，例如 “Ljava&#x2F;lang&#x2F;String;”<br>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass mStringClass = env-&gt;FindClass(&quot;Ljava/lang/String;&quot;);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><code>jclass GetSuperclass(jclass clazz)</code><br>说明：返回一个类的父类，如果 clazz 是 Object 类，没有父类，那么将返回 NULL<br>参数：</li>
</ol>
<ul>
<li>jclazz：当前类对象<br>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz = env-&gt;GetSuperclass(mStringClass); // clazz is Ljava/lang/Object;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><code>jboolean IsAssignableFrom(jclass clazz1, jclass clazz2)</code><br>说明：判断类1是否可以安全的强制转换类2<br>参数：</li>
</ol>
<ul>
<li>clazz1：类1</li>
<li>clazz2：类2</li>
</ul>
<p><strong>四、对象操作</strong></p>
<ol>
<li><code>jobject AllocObject(jclass clazz)</code><br>说明：不调用构造方法创建实例<br>参数：</li>
</ol>
<ul>
<li>clazz：指定对象的类</li>
</ul>
<ol start="2">
<li><code>jobject NewObject(jclass clazz, jmethodID methodID, …)</code></li>
<li><code>jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args)</code></li>
<li><code>jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)</code><br>说明：使用指定的构造方法创建类的实例，唯一不同的是输入参数的传入形式不同<br>参数：</li>
</ol>
<ul>
<li><p>clazz：指定对象的类</p>
</li>
<li><p>methodID：指定的构造方法</p>
</li>
<li><p>args：输入参数列表</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jclass rect_clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);</span><br><span class="line">jmethodID rect_constructor = env-&gt;GetMethodID(rect_clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">jobject rect = env-&gt;NewObject(rect_clazz, rect_constructor);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li><code>jclass GetObjectClass(jobject obj)</code><br>说明：根据对象获取所属类<br>参数：</li>
</ol>
<ul>
<li>obj：某个 Java 对象实例，不能为 NULL</li>
</ul>
<ol start="6">
<li><code>jobjectRefType GetObjectRefType(jobject obj)</code><br>说明：获取到对象的引用类型，JNI 1.6 新增的方法</li>
</ol>
<p>参数：</p>
<ul>
<li><p>obj：某个 Java 对象实例<br>返回：</p>
<p>  JNIInvalidRefType &#x3D; 0 &#x2F;&#x2F; 该 obj 是个无效的引用<br>  JNILocalRefType &#x3D; 1 &#x2F;&#x2F; 该 obj 是个局部引用<br>  JNIGlobalRefType &#x3D; 2 &#x2F;&#x2F; 该 obj 是个全局引用<br>  JNIWeakGlobalRefType &#x3D; 3 &#x2F;&#x2F; 该 obj 是个全局的弱引用</p>
</li>
</ul>
<ol start="7">
<li><code>jboolean IsInstanceOf(jobject obj, jclass clazz)</code><br>说明：判断某个对象是否是指定类的实例<br>参数：</li>
</ol>
<ul>
<li>obj：某个 Java 对象实例</li>
<li>clazz：指定的类对象</li>
</ul>
<ol start="8">
<li><code>jboolean IsSameObject(jobject ref1, jobject ref2)</code><br>说明：判断两个对象的引用是否指向的是相同的 Java 对象<br>参数：</li>
</ol>
<ul>
<li>ref1：某个 Java 对象的引用1</li>
<li>ref2：某个 Java 对象的引用2</li>
</ul>
<p><strong>五、域操作</strong></p>
<ol>
<li><code>jfieldID GetFieldID(jclass clazz, const char name, const char sig)</code><br>说明：获取类中某个非静态成员变量的ID（域ID）<br>参数：</li>
</ol>
<ul>
<li><p>clazz：指定对象的类</p>
</li>
<li><p>name：这个域（Field）在 Java 类中定义的名字</p>
</li>
<li><p>sig：这个域（Field）的类型描述符<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);</span><br><span class="line">jfieldID left_field = env-&gt;GetFieldID(clazz, &quot;left&quot;, &quot;I&quot;);</span><br><span class="line">jfieldID top_field = env-&gt;GetFieldID(clazz, &quot;top&quot;, &quot;I&quot;);</span><br><span class="line">jfieldID right_field = env-&gt;GetFieldID(clazz, &quot;right&quot;, &quot;I&quot;);</span><br><span class="line">jfieldID bottom_field = env-&gt;GetFieldID(clazz, &quot;bottom&quot;, &quot;I&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><code>NativeType Get&lt;type&gt;Field(jobject obj, jfieldID fieldID)</code><br>  说明：获取实例域的变量值，这里 type 表示的是一系列方法，如下：</li>
</ol>
<table>
<thead>
<tr>
<th>Get<type>Field Routine Name</th>
<th>Native Type</th>
</tr>
</thead>
<tbody><tr>
<td>GetObjectField()</td>
<td>jobject</td>
</tr>
<tr>
<td>GetBooleanField()</td>
<td>jboolean</td>
</tr>
<tr>
<td>GetByteField()</td>
<td>jbyte</td>
</tr>
<tr>
<td>GetCharField()</td>
<td>jchar</td>
</tr>
<tr>
<td>GetShortField()</td>
<td>jshort</td>
</tr>
<tr>
<td>GetIntField()</td>
<td>jint</td>
</tr>
<tr>
<td>GetLongField()</td>
<td>jlong</td>
</tr>
<tr>
<td>GetFloatField()</td>
<td>jfloat</td>
</tr>
<tr>
<td>GetDoubleField()</td>
<td>jdouble</td>
</tr>
</tbody></table>
<p>参数：</p>
<ul>
<li><p>obj：某个 Java 对象实例</p>
</li>
<li><p>fieldID：这个变量的域ID<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobject rect; // 初始化过程省略</span><br><span class="line">jclass clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);</span><br><span class="line">jfieldID left_field = env-&gt;GetFieldID(clazz, &quot;left&quot;, &quot;I&quot;);</span><br><span class="line">jint left = env-&gt;GetIntField(rect, left_field);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><code>void Set&lt;type&gt;Field(jobject obj, jfieldID fieldID, NativeType value)</code><br>说明：修改实例域的变量值，这里 type 对应上面的 Get 方法，不再累述<br>参数：</li>
</ol>
<ul>
<li><p>obj：需要修改的 Java 对象实例</p>
</li>
<li><p>fieldID：这个变量的域ID</p>
</li>
<li><p>value：需要设置的值<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobject rect; // 初始化过程省略</span><br><span class="line">jclass clazz = env-&gt;FindClass(&quot;android/graphics/Rect&quot;);</span><br><span class="line">jfieldID left_field = env-&gt;GetFieldID(clazz, &quot;left&quot;, &quot;I&quot;);</span><br><span class="line">env-&gt;SetIntField(rect, left_field, 1);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p><code>jfieldID GetStaticFieldID(jclass clazz, const char name, const char sig)</code><br>说明：同 GetFieldID，只不过这里操作的是静态的域（Filed）</p>
</li>
<li><p><code>NativeType GetStaticField(jobject obj, jfieldID fieldID)</code><br>说明：同 GetField，只不过这里操作的是静态的域（Filed）</p>
</li>
<li><p><code>void SetStaticField(jobject obj, jfieldID fieldID, NativeType value)</code><br>说明：同 SetField，只不过这里操作的是静态的域（Filed）</p>
</li>
</ol>
<p><strong>六、方法操作</strong></p>
<ol>
<li><code>jmethodID GetMethodID(jclass clazz, const char name, const char sig)</code><br>说明：获取类中某个非静态方法的ID</li>
</ol>
<p>参数：</p>
<ul>
<li>clazz：指定对象的类</li>
<li>name：这个方法在 Java 类中定义的名称，构造方法为 ““</li>
<li>sig：这个方法的类型描述符，例如 “()V”，其中括号内是方法的参数，括号后是返回值类型<br>示例：</li>
</ul>
<p>Java 的类定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.afei.jnidemo;</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">    public Test()&#123;&#125;</span><br><span class="line">    public int show(String msg, int number) &#123;</span><br><span class="line">        System.out.println(&quot;msg: &quot; + msg);</span><br><span class="line">        System.out.println(&quot;number: &quot; + number);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>JNI 调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz = env-&gt;FindClass(&quot;com/afei/jnidemo/Test&quot;);</span><br><span class="line">jmethodID constructor_method = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">jmethodID show_method = env-&gt;GetMethodID(clazz, &quot;show&quot;, &quot;(Ljava/lang/String;I)I&quot;);</span><br></pre></td></tr></table></figure>

<p>​    签名时其中括号内是方法的参数，括号后是返回值类型。例如 show 方法，第一个参数是 String 类，对应 Ljava&#x2F;lang&#x2F;String;（注意后面有一个分号），第二个参数是 int 基本类型，对应的类型描述符是 I，返回值也是 int，同样是 I，所以最终该方法的签名为 “(Ljava&#x2F;lang&#x2F;String;I)I”。</p>
<ol start="2">
<li><code>NativeType CallMethod(jobject obj, jmethodID methodID, …)</code></li>
<li><code>NativeType CallMethodA(jobject obj, jmethodID methodID, jvalue* args)</code></li>
<li><code>NativeType CallMethodV(jobject obj, jmethodID methodID, va_list args)</code><br>说明：调用对象的某个方法，唯一不同的是输入参数的传入形式不同，这里 type 表示的是一系列方法，如下：</li>
</ol>
<p><img src="/../../../../images/image-20231123153835482.png" alt="image-20231123153835482"></p>
<p>参数：</p>
<ul>
<li><p>obj：某个 Java 对象实例</p>
</li>
<li><p>methodID：指定方法的ID</p>
</li>
<li><p>args：输入参数列表<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz = env-&gt;FindClass(&quot;com/afei/jnidemo/Test&quot;);</span><br><span class="line">jmethodID show_method = env-&gt;GetMethodID(clazz, &quot;show&quot;, &quot;(Ljava/lang/String;I)I&quot;);</span><br><span class="line">jint result = env-&gt;CallIntMethod(clazz, show_method, &quot;Hello JNI!&quot;, 0);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li><p><code>jmethodID GetStaticMethodID(jclass clazz, const char name, const char sig)</code><br>说明：同 GetMethodID，只不过操作的是静态方法</p>
</li>
<li><p><code>NativeType CallStaticMethod(jclass clazz, jmethodID methodID, …)</code></p>
</li>
<li><p><code>NativeType CallStaticMethodA(jclass clazz, jmethodID methodID, jvalue* args)</code></p>
</li>
<li><p><code>NativeType CallStaticMethodV(jclass clazz, jmethodID methodID, va_list args)</code><br>说明：同 NativeType CallMethod，只不过操作的是静态方法，参数也由 jobject 变成了 jclass。</p>
</li>
</ol>
<p><strong>七、全局引用和局部引用</strong></p>
<ol>
<li><code>jobject NewGlobalRef(jobject obj)</code><br>说明：创建一个全局引用，不用时必须调用 DeleteGlobalRef() 方法释放。<br>参数：</li>
</ol>
<ul>
<li><p>obj：某个 Java 对象实例，可以是局部引用或全局引用<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jclass mPointFClass;  // global reference to PointF class</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">jclass clazz = env-&gt;FindClass(&quot;android/graphics/PointF&quot;);</span><br><span class="line">mPointFClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><code>void DeleteGlobalRef(jobject globalRef)</code><br>说明：释放某个全局引用<br>参数：</li>
</ol>
<ul>
<li>globalRef：某全局引用</li>
</ul>
<ol start="3">
<li><code>jobject NewLocalRef(jobject ref)</code><br>说明：创建一个局部引用。这个方法一般很少用。<br>参数：</li>
</ol>
<ul>
<li>ref：某个引用，可以是全局引用或者局部引用</li>
</ul>
<ol start="4">
<li><code>void DeleteLocalRef(jobject localRef)</code><br>说明：释放某个局部引用<br>参数：</li>
</ol>
<ul>
<li><p>localRef：某局部引用</p>
<p>注意：<br>局部引用在方法执行完后也会自动释放，不过当你在执行一个很大的循环时，里面会产生大量临时的局部引用，那么建议的做法是手动的调用该方法去释放这个局部引用。</p>
</li>
</ul>
<ol start="5">
<li><code>jweak NewWeakGlobalRef(jobject obj)</code><br>说明：创建一个全局的弱引用<br>参数：</li>
</ol>
<ul>
<li><p>obj：某个 Java 对象实例</p>
<p>注意：<br>弱引用不会阻止 GC 回收它引用的对象，在内存不足时，弱引用的对象往往会被回收掉，使用时一定要多加小心。</p>
</li>
</ul>
<ol start="6">
<li><code>void DeleteWeakGlobalRef(jweak obj)</code><br>说明：释放某个全局的弱引用<br>参数：</li>
</ol>
<ul>
<li>obj：某个全局弱引用</li>
</ul>
<p><strong>八、字符串操作</strong></p>
<ol>
<li><code>jstring NewString(const jchar* unicodeChars, jsize len)</code><br>说明：以 UTF-16 的编码方式创建一个 Java 的字符串（jchar 的定义为 uint16_t）<br>参数：</li>
</ol>
<ul>
<li>unicodeChars：指向字符数组的指针</li>
<li>len：字符数组的长度</li>
</ul>
<ol start="2">
<li><code>jstring NewStringUTF(const char* bytes)</code><br>说明：以 UTF-8 的编码方式创建一个 Java 的字符串<br>参数：</li>
</ol>
<ul>
<li>bytes：指向字符数组的指针</li>
</ul>
<ol start="3">
<li><code>jsize GetStringLength(jstring string)</code></li>
<li><code>jsize GetStringUTFLength(jstring string)</code><br>说明：获取字符串的长度，GetStringLength 是 UTF-16 编码，GetStringUTFLength 是 UTF-8 编码<br>参数：</li>
</ol>
<ul>
<li>string：字符串</li>
</ul>
<ol start="5">
<li><code>const jchar GetStringChars(jstring string, jboolean isCopy)</code></li>
<li><code>const char GetStringUTFChars(jstring string, jboolean isCopy)</code><br>说明：将 Java 风格的 jstring 对象转换成 C 风格的字符串，同上一个是 UTF-16 编码，一个是 UTF-8 编码<br>参数：</li>
</ol>
<ul>
<li>string：Java 风格的字符串</li>
<li>isCopy：是否进行拷贝操作，0 为不拷贝</li>
</ul>
<ol start="7">
<li><code>void ReleaseStringChars(jstring string, const jchar* chars)</code></li>
<li><code>void ReleaseStringUTFChars(jstring string, const char* utf)</code><br>说明：释放指定的字符串指针，通常来说，Get 和 Release 是成对出现的<br>参数：</li>
</ol>
<ul>
<li><p>string：Java 风格的字符串</p>
</li>
<li><p>chars&#x2F;utf：对应的 C 风格的字符串<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_com_afei_jnidemo_MainActivity_test(JNIEnv *env, jobject instance, jstring msg_) &#123;</span><br><span class="line">    const char *msg = env-&gt;GetStringUTFChars(msg_, 0);</span><br><span class="line">    // Do Something</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(msg_, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>九、数组操作</strong></p>
<ol>
<li><code>jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement)</code><br>说明：创建引用数据类型的数组<br>参数：</li>
</ol>
<ul>
<li><p>length：数组的长度</p>
</li>
<li><p>elementClass：数组的元素所属的类</p>
</li>
<li><p>initialElement：使用什么样的对象来初始化，可以选择 NULL<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int points_count = 21;</span><br><span class="line">jclass pointFClass = env-&gt;FindClass(&quot;android/graphics/PointF&quot;);</span><br><span class="line">jobjectArray point_array = env-&gt;NewObjectArray(points_count, pointFClass, NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.<code>ArrayType NewArray(jsize length)</code><br>说明：创建基本数据类型的数组。这里的基本数据类型有：</p>
<p><img src="/../../../../images/image-20231123154203044.png" alt="image-20231123154203044"></p>
<p>参数：</p>
<ul>
<li>length：数组的长度</li>
</ul>
<ol start="3">
<li><code>jsize GetArrayLength(jarray array)</code><br>说明：获取数组的长度<br>参数：</li>
</ol>
<ul>
<li>array：指定的数组对象。jarray 是 jbooleanArray、jbyteArray、jcharArray 等的父类。</li>
</ul>
<ol start="4">
<li><code>jobject GetObjectArrayElement(jobjectArray array, jsize index)</code><br>说明：获取引用数据类型数组指定索引位置处的对象<br>参数：</li>
</ol>
<ul>
<li>array：引用数据类型数组</li>
<li>index：目标索引值</li>
</ul>
<ol start="5">
<li><code>void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)</code><br>说明：设置引用数据类型数组指定索引位置处的值<br>参数：</li>
</ol>
<ul>
<li>array：需要设置的引用数据类型数组</li>
<li>index：目标索引值</li>
<li>value：需要设置的值</li>
</ul>
<ol start="6">
<li><code>NativeType GetArrayElements(ArrayType array, jboolean isCopy)</code><br>说明：获取基本数据类型数组的头指针<br>参数：</li>
</ol>
<ul>
<li>array：基本数据类型数组</li>
<li>isCopy：是否进行拷贝操作，0 为不拷贝</li>
</ul>
<ol start="7">
<li><code>void ReleaseArrayElements(ArrayType array, NativeType* elems, jint mode)</code><br>说明：释放基本数据类型数组指针。通常来说，Get 和 Release 是成对出现的<br>参数：</li>
</ol>
<ul>
<li>array：基本数据类型数组</li>
<li>elems：对应的 C 风格的基本数据类型指针</li>
<li>mode：释放模式，通常我们都是使用 0，有三种，如下<br><img src="/../../../../images/image-20231123154251199.png" alt="image-20231123154251199"></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java_com_afei_jnidemo_MainActivity_test(JNIEnv *env, jobject instance, jintArray array_) &#123;</span><br><span class="line">    jint *array = env-&gt;GetIntArrayElements(array_, 0);</span><br><span class="line">    // Do Something</span><br><span class="line">    env-&gt;ReleaseIntArrayElements(array_, array, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="8">
<li><code>void GetArrayRegion(ArrayType array, jsize start, jsize len, NativeType* buf)</code><br>说明：返回基本数据类型数组的部分副本。这里的基本数据类型有：</li>
</ol>
<p><img src="/../../../../images/image-20231123154324154.png" alt="image-20231123154324154"></p>
<p>参数：</p>
<ul>
<li>array：基本数据类型数组</li>
<li>start：起始的索引值</li>
<li>len：拷贝的长度</li>
<li>buf：拷贝到的目标数组</li>
</ul>
<ol start="9">
<li><code>void SetArrayRegion(ArrayType array, jsize start, jsize len, const NativeType* buf)</code><br>说明：设置基本数据类型数组元素。类型和上面的表类似。<br>参数：</li>
</ol>
<ul>
<li>array：需要设置的基本数据类型数组</li>
<li>start：起始的索引值</li>
<li>len：需要设置的 buf 的长度</li>
<li>buf：需要设置的值数组</li>
</ul>
<p><strong>十、异常操作</strong></p>
<ol>
<li><code>jint Throw(jthrowable obj)</code><br>说明：抛出一个异常，需要手动创建异常的实例，调用较复杂，一般不使用这个方法<br>参数：</li>
</ol>
<ul>
<li><p>obj：异常对象<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jclass ioExceptionClazz = env-&gt;FindClass(&quot;java/io/IOException&quot;);</span><br><span class="line">jmethodID ioExceptionConstructor = env-&gt;GetMethodID(ioExceptionClazz, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">jthrowable exceptionObj = static_cast&lt;jthrowable&gt;(env-&gt;NewObject(ioExceptionClazz, </span><br><span class="line">                                                      ioExceptionConstructor, &quot;IO异常&quot;));</span><br><span class="line">if (env-&gt;Throw(exceptionObj) == JNI_OK) &#123;</span><br><span class="line">    // 创建成功</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 创建失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><code>jint ThrowNew(jclass clazz, const char* message)</code><br>说明：抛出一个异常。使用起来比三个方法方便<br>参数：</li>
</ol>
<ul>
<li><p>clazz：指定的异常类</p>
</li>
<li><p>message：异常信息<br>示例：</p>
<p>  if (env-&gt;ThrowNew(env-&gt;FindClass(“java&#x2F;io&#x2F;IOException”), “IO异常”) &#x3D;&#x3D; JNI_OK) {<br>  &#x2F;&#x2F; 创建成功<br>  } else {<br>  &#x2F;&#x2F; 创建失败<br>  }</p>
</li>
</ul>
<ol start="3">
<li><p><code>jthrowable ExceptionOccurred()</code></p>
</li>
<li><p><code>jboolean ExceptionCheck()</code><br>说明：检查是否有异常，如果本地函数有异常抛出，ExceptionOccurred 会返回这个异常的示例，ExceptionCheck 只返回是否有异常</p>
</li>
<li><p>void ExceptionDescribe()<br>说明：将异常和堆栈信息推送到错误流</p>
</li>
<li><p>void ExceptionClear()<br>说明：清除掉发生的异常</p>
</li>
</ol>
<p>以上几个方法的示例：</p>
<p>Java 部分代码为：</p>
<pre><code>public class MainActivity extends AppCompatActivity &#123;
 
    static &#123;
        System.loadLibrary(&quot;native-lib&quot;);
    &#125;
 
    @Override
    protected void
    onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        try &#123;
            test();
        &#125; catch (Exception e) &#123;
            Log.e(&quot;MainActivity&quot;, &quot;onCreate: &quot; + e);
        &#125;
    &#125;
 
    private native void test() throws IllegalArgumentException;
 
    private void callNullPointerException() throws NullPointerException &#123;
        throw new NullPointerException(&quot;MainActivity NullPointerException&quot;);
    &#125;
 
&#125;
</code></pre>
<p>JNI 部分代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_com_afei_jnidemo_MainActivity_test(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(instance);</span><br><span class="line">    jmethodID mid =env-&gt;GetMethodID(clazz, &quot;callNullPointerException&quot;, &quot;()V&quot;);</span><br><span class="line">    env-&gt;CallVoidMethod(instance, mid); // will throw a NullPointerException</span><br><span class="line">    jthrowable exc = env-&gt;ExceptionOccurred(); // 检测是否发生异常</span><br><span class="line">    if (exc) &#123;</span><br><span class="line">        LOGD(&quot;============&quot;);</span><br><span class="line">        env-&gt;ExceptionDescribe(); // 打印异常信息</span><br><span class="line">        LOGD(&quot;============&quot;);</span><br><span class="line">        env-&gt;ExceptionClear(); // 清除掉发生的异常</span><br><span class="line">        jclass newExcCls = env-&gt;FindClass(&quot;java/lang/IllegalArgumentException&quot;);</span><br><span class="line">        env-&gt;ThrowNew(newExcCls, &quot;throw from JNI&quot;); // 返回一个新的异常到 Java</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">07-12 14:57:07.443 26623-26623/com.afei.jnidemo D/FaceAPI: ============</span><br><span class="line">07-12 14:57:07.443 26623-26623/com.afei.jnidemo W/System.err: java.lang.NullPointerException: MainActivity NullPointerException</span><br><span class="line">        at com.afei.jnidemo.MainActivity.callNullPointerException(MainActivity.java:34)</span><br><span class="line">        at com.afei.jnidemo.MainActivity.test(Native Method)</span><br><span class="line">        at com.afei.jnidemo.MainActivity.onCreate(MainActivity.java:25)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:6857)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1125)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2702)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2810)</span><br><span class="line">        at android.app.ActivityThread.-wrap12(ActivityThread.java)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1532)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:181)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6288)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">07-12 14:57:07.443 26623-26623/com.afei.jnidemo W/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:900)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:790)</span><br><span class="line">07-12 14:57:07.443 26623-26623/com.afei.jnidemo D/FaceAPI: ============</span><br><span class="line">07-12 14:57:07.444 26623-26623/com.afei.jnidemo E/MainActivity: onCreate: java.lang.IllegalArgumentException: throw from JNI</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>void FatalError(const char* msg)</code><br>说明：抛出一个致命异常，并且不希望JVM处理<br>参数：</li>
</ol>
<ul>
<li>msg：致命异常的信息</li>
</ul>
<p>十一、其它<br>    其他还有有关 Monitor Operations、NIO Support、Reflection Support 等一些方法，由于我也没使用过，就不再这里解释了。<br>    可以参考 JNI 的官网的介绍：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502">https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/81016413">JNI 方法大全及使用示例-CSDN博客</a></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android进阶/NDK/蒋超大佬扫盲/9.函数签名及ndk调用java方法" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/NDK/">NDK</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/">蒋超大佬扫盲</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> <strong>基础知识</strong></p>
<p> <strong>1.1 访问域</strong></p>
<p>Java有两类域：实例域和静态域。类的每个实例都有自己的实例域副本，而每个类的所有实例共享同一个静态域。</p>
<p>了解Java的都知道，在一个类加载器中，类的class只有一个，但可以有很多类的实例对象。所以在我们使用JNI访问Java的方法时，会有两种不同的方法。</p>
<p><strong>1.2 域ID</strong></p>
<p>在前面章节中我们讲解了Java调用jni的方法，Java调用jni方法只需要注意函数的命名规则即可，但在jni访问Java的方法时需要获得访问域的ID，访问域有两种，同样，域ID也有两种。一种是静态域ID，一种是实例域ID,如下所示：</p>
<p><strong>1.2.1 获取类</strong></p>
<p>1.2.1.1 用对象引用获得jclass</p>
<p>通过传入Java对象（jobject类型变量），获取Java类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz;</span><br><span class="line">clazz = env-&gt;<span class="built_in">GetObjectClass</span>(env, instance);</span><br></pre></td></tr></table></figure>

<p>1.2.1.2 通过包名类名获取jclass</p>
<p>通过传入完整的包名&#x2F;类名获取java类对应的C&#x2F;C++环境下的jclass类型的变量，返回值：Java字节码class对象，对应C++中的jclass对象。注意：包名中的   .   使用   &#x2F;   来替代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass clazz;</span><br><span class="line">clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/jiangc/jni/TestJni&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>1.3 签名规则</strong></p>
<p>以下是签名规则，在jni的环境中调用Java的方法或者获取Field时，需要用到签名，签名规则如下：</p>
<table>
<thead>
<tr>
<th>java 类型</th>
<th>签名</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>Z</td>
</tr>
<tr>
<td>Byte</td>
<td>B</td>
</tr>
<tr>
<td>Char</td>
<td>C</td>
</tr>
<tr>
<td>Short</td>
<td>S</td>
</tr>
<tr>
<td>Int</td>
<td>I</td>
</tr>
<tr>
<td>Long</td>
<td>J</td>
</tr>
<tr>
<td>Float</td>
<td>F</td>
</tr>
<tr>
<td>Double</td>
<td>D</td>
</tr>
<tr>
<td>fully-qualified-class</td>
<td>Lfully-qualified-class</td>
</tr>
<tr>
<td>type[]</td>
<td>[type</td>
</tr>
<tr>
<td>method type</td>
<td>(arg-type)ret-type</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.javap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJni</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;javap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ()Ljava/lang/String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">HelloWorld</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (II)I</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ()Z</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.3.1 使用javap生成函数签名</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.javac TestJni.java</span><br><span class="line">2.javap -s -p -classpatch . TestJni</span><br><span class="line"></span><br><span class="line">javap -s -p -classpath . TestJni</span><br><span class="line">警告: 文件 .\TestJni.class 不包含类 TestJni</span><br><span class="line">Compiled from &quot;TestJni.java&quot;</span><br><span class="line">public class com.example.javap.TestJni &#123;</span><br><span class="line">  public com.example.javap.TestJni();</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  public native java.lang.String HelloWorld();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  public int add(int, int);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line"></span><br><span class="line">  public boolean isTrue();</span><br><span class="line">    descriptor: ()Z</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>1.4 设置Android Studio javap</strong></p>
<p>打开Android  Studio ，File-&gt;Settings-&gt;Tools-&gt;External Tools扩展工具栏，如下图：<br><img src="/../../../../images/image-20231119174245513.png"></p>
<p>点击+号按钮<br><img src="/../../../../images/image-20231119174704232.png"></p>
<p>填写信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program:  javap的绝对路径</span><br><span class="line">Arguments：-s -p $FileClass$</span><br><span class="line">Working directory: $OutputPath$</span><br></pre></td></tr></table></figure>

<p>首先编译一下项目，然后通过右键javap获取函数签名</p>
<p><img src="/../../../../images/image-20231119174910736.png"></p>
<p>获取到的签名如下：<br><img src="/../../../../images/image-20231119175155744.png"></p>
<p>这样我们就可以相对比较快捷的得到函数签名了。</p>
<p><strong>二. 通过jni访问java方法</strong></p>
<p><strong>2.1 调用实例对象的方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_javap_TestJni_HelloWorld</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jmethodID jmethodId;</span><br><span class="line">    jclass clazz = env-&gt;<span class="built_in">GetObjectClass</span>(thiz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == clazz) &#123;</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;jclass is null\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//GetMethodID()获取java方法，GetMethodID(类,方法名,方法签名)</span></span><br><span class="line">    jmethodId = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;(II)I&quot;</span>);</span><br><span class="line">    jint result;</span><br><span class="line">    result = env-&gt;<span class="built_in">CallIntMethod</span>(thiz, jmethodId, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;result = %d\n&quot;</span>, result);</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_javap_TestJni_callStaticFunc</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jclass clazz;</span><br><span class="line">    <span class="comment">// com.example.javap</span></span><br><span class="line">    clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/javap/TestJni&quot;</span>);</span><br><span class="line">    jmethodID jmethodId = env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz, <span class="string">&quot;sAdd&quot;</span>, <span class="string">&quot;(II)I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jint result = env-&gt;<span class="built_in">CallStaticIntMethod</span>(clazz, jmethodId, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;call static result : %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
        </nav>
    
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>