<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
 <meta name="referrer" content="no-referrer"/>
    
    <title>TYL</title>
    
    
        <meta name="keywords" content="TYL" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="cq_tyl的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="TYL">
<meta property="og:url" content="https://cq_tyl.gitee.io/page/2/index.html">
<meta property="og:site_name" content="TYL">
<meta property="og:description" content="cq_tyl的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cq_tyl">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/atom.xml" title="TYL" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 6.3.0"></head>

<head></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TYL</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/about">我的简历</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/about">我的简历</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://cq_tyl.gitee.io"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android Application
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AndroidStudio插件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Alibaba-Java-Coding-Guidelines%EF%BC%88%E9%98%BF%E9%87%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%EF%BC%89/">Alibaba-Java-Coding-Guidelines（阿里代码规范检测）</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/Studio%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6/">Studio汉化插件</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/database-navigator%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">Database-Navigator查看数据库</a></li>  <li class="file"><a href="/wiki/Android%20Application/AndroidStudio%E6%8F%92%E4%BB%B6/%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6Translation/">翻译插件Translation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android兼容适配
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E5%A4%9A%E4%B8%AAfragment%E9%87%8D%E5%8F%A0%E6%97%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88viewpager+fragment%EF%BC%89/">多个Fragment重叠时，点击事件穿透解决方法（viewpager+fragment）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%81%AE%E6%8C%A1%E5%B8%83%E5%B1%80-%E9%9A%90%E8%97%8F%E5%BA%95%E9%83%A8%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AENavigation%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F/">虚拟按键遮挡布局-隐藏底部虚拟按键Navigation实现全屏</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E8%AE%BE%E7%BD%AEImageView%E5%9B%BE%E7%89%87%E6%97%B6,%E5%AE%BD%E5%BA%A6%E4%B8%BAmatch%E6%97%B6%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AEscaleType%E4%B8%BAfitXY/">设置ImageView图片时,宽度为match时需要设置scaleType为fitXY</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/%E9%80%82%E9%85%8D%E5%8D%8E%E4%B8%BA%E7%AD%89%E6%9C%89%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">适配华为等有虚拟按键的屏幕的解决方案</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android动画
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/LayoutTransition%EF%BC%88%E9%80%9A%E7%94%A8%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%EF%BC%89/">LayoutTransition（通用隐藏显示动画）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%EF%BC%88Shared-Element%EF%BC%89/">共享元素（Shared-Element）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%90%AF%E5%8A%A8%E9%A1%B5%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB/">启动页缩放动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E5%B8%A7%E5%8A%A8%E7%94%BB/">帧动画</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E6%8F%AD%E9%9C%B2%E6%95%88%E6%9E%9C/">揭露效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%8A%A8%E7%94%BB/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/">补间动画</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAV%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAV线程池</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/TCP%E5%8D%8F%E8%AE%AE%EF%BC%88Socket%EF%BC%89/">TCP协议（Socket）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Notifaction/">Notifaction</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/">JAVA集合</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%88Handle+Runable-%E5%8F%AF%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%8F%AF%E6%9A%82%E5%81%9C%EF%BC%89/">Android-计时器（Handle+Runable-可重置时间可暂停）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">JAVA多线程之间的通信</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">JSON数据解析</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Sevice%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89/">Sevice（服务）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">类加载器（基础）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/new-Random()--%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">New-Random()--生成随机数</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/SharedPreferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">SharedPreferences数据存储</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-popwind/">Android-Popwind</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E5%92%8CLock/">同步锁Synchronized和Lock</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-ConstraintLayout-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Android-ConstraintLayout-使用详解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/EditText%E7%84%A6%E7%82%B9%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/">EditText焦点动态控制</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/StringBuffer%E5%92%8CStringBuilder/">StringBuffer和StringBuilder</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/ANR/">ANR</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-ImageView-scaleType%E7%9A%84%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3/">Android-ImageView-scaleType的属性理解</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">Android事件分发</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/">逻辑运算符</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-%E5%80%92%E8%AE%A1%E6%97%B6/">Android-倒计时</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83-%E6%96%B9%E6%B3%95%E5%9B%9E%E8%B0%83/">Android中接口回调-方法回调</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/">Android-6-0动态权限</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Android-M-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/">Android-M-最简单的权限请求</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Toast%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89Toast%EF%BC%89/">Toast（自定义Toast）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android-6-0%E6%96%B0%E7%89%B9%E6%80%A7/">Android-6-0新特性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask/">异步任务-AsyncTask</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/AndroidManifest-xml/">AndroidManifest-Xml</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Java-Character-%E7%B1%BB%EF%BC%88%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-%E5%AD%97%E6%AF%8D-%E6%95%B0%E5%AD%97-%E5%A4%A7%E5%B0%8F%E5%86%99%E5%88%A4%E6%96%AD%EF%BC%89/">Java-Character-类（单个字符串类型-字母-数字-大小写判断）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/BroadCastReceiver(%E5%B9%BF%E6%92%AD)/">BroadCastReceiver(广播)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/">Iterator迭代器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/Activity%E5%90%91Fragment%E4%BC%A0%E5%80%BC/">Activity向Fragment传值</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%9F%BA%E7%A1%80/android%E5%AD%97%E9%97%B4%E8%B7%9D%E5%92%8C%E8%A1%8C%E9%97%B4%E8%B7%9D/">Android字间距和行间距</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android工具类
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0/">Android动态修改桌面图标及应用桌面应用名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%8F%91%E5%B8%83%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93%E5%88%B0JitPack%E4%B8%8A/">Android发布自定义库到JitPack上</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/">JAVA内存划分</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-studio-mac-%E8%8E%B7%E5%8F%96MD5-SHA1-SHA256%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9/">Android-Studio-Mac-获取MD5-SHA1-SHA256证书指纹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-textview%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%B1%87%E6%80%BB/">Android-Textview空格占位符以及一些其他占位符汇总</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/github%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/">Github图片加载失败</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAactivity%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%A0%88%E5%A0%86%E4%B8%AD/">判断某个Activity是否存在栈堆中</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Androd-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/">Androd-开机自启动</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E5%9C%A8%E6%B2%A1%E6%9C%89usb%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E8%AE%BE%E5%A4%87/">Android-在没有Usb连接线的情况下如何连接手机设备</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E4%BF%9D%E6%B4%BB/">Android保活</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%B0%86String%E5%88%86%E5%89%B2%E8%BD%AC%E5%8C%96%E4%B8%BAArrayList/">Android将String分割转化为ArrayList</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">Android第三方常用安全漏洞检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AFMarqueeViewLibrary/">Android自定义四个方向滚动的跑马灯MarqueeViewLibrary</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EventBus/">EventBus</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Glide%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%88%E6%97%A0%E9%9C%80%E5%86%8D%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BA%86%EF%BC%89/">Glide设置圆角、圆形图片（无需再创建工具类了）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/GreenDao/">GreenDao</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/RxJava-RxAndroid/">RxJava-RxAndroid</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Sentry-Android%E9%9B%86%E6%88%90-%E4%BD%BF%E7%94%A8-%E6%B7%B7%E6%B7%86/">Sentry-Android集成-使用-混淆</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Svn%E5%BF%BD%E7%95%A5Android%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/">Svn忽略Android项目上传文件-文件夹</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-RadioButton-drawableTop%E5%9B%BE%E7%89%87%E5%8F%98%E5%9E%8B/">Android-RadioButton-drawableTop图片变型</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%8E%86%E6%8F%92%E5%85%A5%E4%BA%8B%E4%BB%B6/">Android-本地日历插入事件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%8E%B7%E5%8F%96assets%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E8%BD%ACFile/">Android-获取assets内的文件转File</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E8%BD%AF%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7%E7%B1%BB/">Android-软键盘工具类</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%95%B0%E5%80%BC%E8%AE%B0%E5%BD%95%E8%A1%A8/">Android-透明度数值记录表</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E6%98%8E%E8%BF%9B%E5%BA%B75-1%E7%9B%92%E5%AD%90%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/">Android明进康5-1盒子定时开关机</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BAlog%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">Android调试输出log打印信息到本地文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/app%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/">App是否正在运行-运行状态</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%BB%E5%BA%95%E5%B7%A5%E5%85%B7---%E5%B0%86%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E7%9A%84%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%9B%BE%E7%89%87/">在线图片去底工具---将纯色背景的图片转换为背景透明的图片</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8FCircleImageView%E7%9A%84%E4%BD%BF%E7%94%A8/">自定义圆形头像CircleImageView的使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Gps-%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B/">Android-Gps-位置信息开关检测</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-eclpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">Android-Eclpse快捷键大全</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/java-android-%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8F%B7%E6%9F%A5%E8%AF%A2%E9%93%B6%E8%A1%8C%E5%8D%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%8D%E7%A7%B0/">Java-Android-银行卡号查询银行卡类型及名称</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E7%BF%BB%E9%A1%B5/">Android-RecyclerView实现横向滑动翻页</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/VAPTCHA-ANDROID-SDK%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/">VAPTCHA-ANDROID-SDK部署文档</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/">Android-Jenkins自动打包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%88%A4%E6%96%ADUrl%E6%A0%BC%E5%BC%8F%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE/">Android判断Url格式是否正确</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/marktext/">Marktext</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E8%87%AA%E5%88%B6-9%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9B%BE%E4%B8%80%E8%87%B4%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/">自制-9图实现和设计图一致的阴影效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-pcm%E8%BD%AC%E7%A0%81wav/">Android-Pcm转码wav</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95%E7%9A%84%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6/">Android-获取当前屏幕的旋转角度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%86%8C%E5%B9%B6%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA/">Android-保存图片到本地相册并及时更新显示</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/android-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/">Android-多语言切换</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/adb%E9%85%8D%E7%BD%AE/">Adb配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%20SildingMenu%EF%BC%88%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%EF%BC%89%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/">Android SildingMenu（侧滑菜单）常用属性</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/Android%E5%9B%BE%E7%89%87%E6%89%8B%E5%8A%BF%E6%8E%A7%E4%BB%B6/">Android图片手势控件</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/DeBug%E8%B0%83%E8%AF%95/">DeBug调试</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/EditText%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E6%97%B6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%95%8C%E9%9D%A2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/">EditText弹出键盘时滚动到界面指定位置</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8D%87%E7%BA%A7/">无障碍升级</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/">判断当前应用是否退到后台</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常记录
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">Activity的四种启动模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-Elevation/">Android-Elevation</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android-%E6%A0%B9%E6%8D%AE%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94String/">Android-根据逗号分隔String</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Android内存管理</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android常用设计模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/">Android自定义View</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Anroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/">Anroid-自定义字体样式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/EditText%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9/">EditText不自动获取焦点</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/GlidePalette%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E8%89%B2/">GlidePalette获取图片背景色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Handler/">Handler</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/">Java多线程编程安全退出线程方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-MultiDex%E5%88%86%E5%8C%85/">Android-MultiDex分包</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-textview%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/">Android-Textview动态修改指定文字颜色</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E6%A0%B9%E6%8D%AE%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/">Android-根据三点坐标求三角形面积</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%88Collections-sort()%EF%BC%89/">Android-英文单词升序排序（Collections-Sort()）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/android%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">android中更新UI的几种方式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/viewpager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E9%80%9F%E5%BA%A6/">Viewpager自定义滑动速度</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">数据序列化方案</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%846%E7%82%B9%E7%BC%96%E7%A8%8B%E7%A7%98%E8%AF%80/">程序员必知的6点编程秘诀</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%8E%86-%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E4%BA%8B%E4%BB%B6%E8%A7%84%E5%88%99-(android-java)/">系统日历-插入重复事件规则-(Android-Java)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android日常问题
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-9-0-P-http-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/">Android-9-0-P-Http-网络请求的问题</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-FaceBook%E7%99%BB%E5%BD%95-%E5%88%86%E4%BA%AB%E8%8E%B7%E5%8F%96HashKey%EF%BC%88%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">Android-FaceBook登录-分享获取HashKey（密钥散列）的简单方法</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android-studio-%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8C%E6%80%BB%E6%98%AF%E8%BF%9B%E5%85%A5Debug%E6%A8%A1%E5%BC%8F/">Android-Studio-点击运行总是进入Debug模式</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB-%E6%81%AF%E5%B1%8F%E5%90%8E%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%8C%81%E5%AE%9A%E4%BD%8D%E3%80%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C/">Android进程保活-息屏后后台保持定位、网络运行</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/DatePickerDialog--setMinDate-setMaxDate%E5%90%8E%E6%A0%87%E9%A2%98%E9%9A%8F%E7%9D%80%E5%8F%98%E5%8C%96-%EF%BC%88%E5%8E%BB%E6%8E%89%E6%A0%87%E9%A2%98%EF%BC%89/">DatePickerDialog--setMinDate-setMaxDate后标题随着变化-（去掉标题）</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/recyclerview-smoothScrollToPosition()%E5%B9%B3%E6%BB%91%E5%A4%B1%E6%95%88-%E6%9C%AA%E8%B5%B7%E6%95%88%E6%9E%9C/">Recyclerview-smoothScrollToPosition()平滑失效-未起效果</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%90%8E%E5%B8%83%E5%B1%80%E4%B8%8A%E7%A7%BB/">软键盘弹出后布局上移</a></li>  <li class="file"><a href="/wiki/Android%20Application/Android%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/studio%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Studio插件下载慢解决方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Material-Design新控件
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/AppbarLayout/">AppbarLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Chronometer%E8%AE%A1%E6%97%B6%E5%99%A8/">Chronometer计时器</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/FloatingActionButton(%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE)/">FloatingActionButton(悬浮按钮)</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/Snackbar/">Snackbar</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/SwitchCompat/">SwitchCompat</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TabLayout/">TabLayout</a></li>  <li class="file"><a href="/wiki/Android%20Application/Material-Design%E6%96%B0%E6%8E%A7%E4%BB%B6/TextInputLayout/">TextInputLayout</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-https双向验证
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/Glide-okhttps%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/">Glide-Okhttps证书验证全局配置</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/P12%E8%AF%81%E4%B9%A6%E8%BD%ACBKS%E8%AF%81%E4%B9%A6/">P12证书转BKS证书</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81-%E6%80%BB%E7%BB%93/">Android-Https双向验证-总结</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-okhttps%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-Okhttps双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-webView%E7%9A%84%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/">Android-webView的双向验证</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android-%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Android-单双向验证知识点</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/android%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6/">Android获取证书文件</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/">Https双向认证证书生成</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/phpstudy%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">Phpstudy搭建本地服务器</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-https%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81/%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95/">配置完成后的测试</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            android-加密-解密-数据压缩
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/android-%E5%8E%9F%E7%94%9Fbase64/">Android-原生Base64</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/10%E8%BF%9B%E5%88%B6%E8%BD%AC20%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%89/">10进制转20进制（任意进制-自定义字符）</a></li>  <li class="file"><a href="/wiki/Android%20Application/android-%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">压缩算法进行字符串压缩</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            rxjava2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20Application/rxjava2/Rxjava2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">Rxjava2的基本使用</a></li>  <li class="file"><a href="/wiki/Android%20Application/rxjava2/rxjava2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">Rxjava2基本概念</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android FrameWork
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework源码分析
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android 13
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            InPutManagerService
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">3.InputReader事件处理</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/">1.InputFlinger的启动</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/">2.EventHub获取事件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">4.InputDispatcher事件分发</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/">5.触摸事件在应用进程的分发和处理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WMSAMS
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/">1.窗口层级 _容器类</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/">2.窗口层级 _层级结构树的构建</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/">3.窗口层级_层级结构树添加窗口</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"></a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/1.android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSeLinux%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">1.Android13启动流程之SeLinux权限介绍.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/2.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BFirstStageMain%E9%98%B6%E6%AE%B5/">2.Android13启动流程之FirstStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/3.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSecondStageMain%E9%98%B6%E6%AE%B5/">3.Android13启动流程之SecondStageMain阶段</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/4.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E5%92%8CSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">4.Android13启动流程之Zygote和SystemServer启动流程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">5.android13启动流程之SystemServer内部逻辑分析.md</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">6.PowerManagerService启动流程和核心方法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/">7.点击桌面APP图标，到APP界面显示流程分析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/">8.点击桌面APP图标，到APP界面显示流程分析(二)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Framework相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/1.Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Handler消息机制原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/2.Binder%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Binder原理解析</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/ANR%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6/">ANR的产生机制</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E7%9B%B8%E5%85%B3/SystemUI/">SystemUI</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%20FrameWork/LINUX%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">LINUX基础命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/VIM%E4%BD%BF%E7%94%A8/">VIM使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Adb常用命令</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/">自定义服务</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E4%BD%BF%E7%94%A8%20git%20add%20-p%20%E6%95%B4%E7%90%86%20patch/">使用Git Add -P 整理 Patch</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/dumpsys%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">Dumpsys命令用法</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%20Repo%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">AOSP Repo 命令参考资料</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ADB%E5%92%8CMonkey%E6%B5%8B%E8%AF%95/">ADB和Monkey测试</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/AOSP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">AOSP常用编译和查找命令文件</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Eclipse安装教程</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">Windows和Ubuntu双系统安装</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Android%20%E6%BA%90%E7%A0%81%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/">Android源码根目录介绍</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Framework%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Framework遇到的问题</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%B0Studio/">导入系统源码到Studio</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Linux%20%E8%AE%BE%E7%BD%AEswap/">Linux设置swap</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/wine%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">Wine安装及使用</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/Selinux&SeAndroid/">Selinux&SeAndroid</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/rc%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/">Rc文件语法规则</a></li>  <li class="file"><a href="/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/">ASFP (Android Studio for Platform)使用</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Jetpack
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Jetpack架构组件从入门到精通</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/1.LifeCycle/">1.LifeCycle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/2.LiveData/">2.LiveData</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/3.DataBinding/">3.DataBinding</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/4.Dagger2/">4.Dagger2</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/5.ViewModle/">5.ViewModle</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/6.Room/">6.Room</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/7.Hilt/">7.Hilt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/8.Paging/">8.Paging</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/9.WorkManager/">9.WorkManager</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/10.Navigation/">10.Navigation</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            NDK
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Android进阶之旅
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/12_makefile/">12_makefile</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_1_Cmake%E8%AF%AD%E6%B3%95/">16_1_Cmake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/16_2_Cmake%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8/">16_2_Cmake项目常用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/19_NDK%E9%9D%A2%E8%AF%95%E9%A2%98/">19_NDK面试题</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/11_%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E5%8E%9F%E7%90%86/">11_编译流程详解/静态库与动态库原理.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/13_android.mk/">13_android.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/14_Application.mk/">14_Application.mk</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/15_Android.mk%E5%92%8CAndroid.bp%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">15_Android.mk和Android.bp对应关系.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/17_Shell%E8%84%9A%E6%9C%AC/">17_Shell脚本</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/18_NDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">18_NDK环境配置</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/1_c%E5%9F%BA%E7%A1%80/">1_c基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/2_jni%E5%9F%BA%E7%A1%80/"></a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/3_jni_native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/">3_jni_native层构建java对象</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/4_jni_%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86/">4_jni_数组的细节处理</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/6_c++%E5%9F%BA%E7%A1%80/">6_c++基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/5_c%E8%BF%9B%E9%98%B6_%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/">5_c进阶_内存四驱模型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/8_%E7%AE%97%E6%B3%95/">8_算法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/7_%E9%93%B6%E8%A1%8C%E5%8D%A1%E8%AF%86%E5%88%AB/">7_银行卡识别.md</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/9_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/">9_音视频基础</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%97%85/20.jni%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">20.jni方法大全及使用示例</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            蒋超大佬扫盲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">1.基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/CMake%E8%AF%AD%E6%B3%95/">CMake语法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/2.Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">2.Cmake基础知识</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/3.JNI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">3.JNI数据类型</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/4.JavaVM/">JavaVM</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/5.OPUS%E7%BC%96%E8%AF%91/">5.opus编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/6.libusb/">6.libusb</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/7.mmkv%E7%BC%96%E8%AF%91/">7.mmkv编译</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/8.mqtt/">8.mqtt</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/9.%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%8F%8Andk%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/">9.函数签名及ndk调用java方法</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/NDK/%E8%92%8B%E8%B6%85%E5%A4%A7%E4%BD%AC%E6%89%AB%E7%9B%B2/10.%E7%BA%BF%E7%A8%8B/">10.线程</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            性能优化
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/leakcanary%E7%9A%84%E4%BD%BF%E7%94%A8/">Leakcanary的使用</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.App%E6%80%A7%E8%83%BD%E6%A6%82%E8%A7%88%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/">1.App性能概览与平台化实践</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">2.App启动优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">3.内存优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">4.布局优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/">5.卡顿优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/">6.线程优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/">7.网络优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/">8.电量优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/">9.瘦身优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">10.稳定性优化</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.%E4%B8%93%E9%A1%B9%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96/">11.专项技术优化</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/java%20%E5%8F%8D%E5%B0%84%E5%8F%8A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Java 反射及代理模式初步学习</a></li>  <li class="file"><a href="/wiki/Android%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93Retrofit/">网络请求库Retrofit</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++教程从0到1入门编程
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/1.C++%E5%9F%BA%E7%A1%80/">C++基础</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/2.C++%E6%8F%90%E9%AB%98/">C++提高</a></li>  <li class="file"><a href="/wiki/C++/C++%E6%95%99%E7%A8%8B%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/3.C++%E6%A0%B8%E5%BF%83/">C++核心</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++/window%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Vscode中配置 C++环境</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC++%E8%AF%AD%E8%A8%80/">轻松搞定C++语言</a></li>  <li class="file"><a href="/wiki/C++/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AC%E8%AF%AD%E8%A8%80(%E6%8F%90%E9%AB%98%E7%AF%87)/">轻松搞定C语言(提高篇)</a></li>  <li class="file"><a href="/wiki/C++/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9AC%E6%8C%87%E9%92%88/">彻底搞定C指针</a></li>  <li class="file"><a href="/wiki/C++/Linux%E7%B3%BB%E7%BB%9F_vscode%E4%B8%AD%E9%85%8D%E7%BD%AE%20c++%E7%8E%AF%E5%A2%83/">Linux系统_vscode中配置 c++环境.md</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            其他笔记
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Flutter
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Android-Studio%E9%85%8D%E7%BD%AEFlutter/">Android-Studio配置Flutter</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter(Android-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91)/">Flutter(Android-混合开发)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-Decoration%E8%83%8C%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%88%E8%BE%B9%E6%A1%86%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1%E3%80%81%E5%BD%A2%E7%8A%B6%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E7%AD%89%EF%BC%89/">Flutter-Decoration背景设定（边框、圆角、阴影、形状、渐变、背景图像等）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E6%8E%A7%E4%BB%B6%E4%B9%8B-MaterialApp/">Flutter-控件之-MaterialApp</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/">Flutter-目录结构和项目资源</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/">Flutter中的手势处理</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%B9%8BScaffold/">Flutter之Scaffold</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/Flutter%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">Flutter代码开发规范</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/StatelessWidget%E5%92%8CStatefulWidget%E7%9A%84%E5%8C%BA%E5%88%AB/">StatelessWidget和StatefulWidget的区别</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomAppBar-%EF%BC%88%E4%B8%8D%E8%A7%84%E5%88%99%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%EF%BC%89/">Flutter-BottomAppBar-（不规则底部工具栏）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-BottomNavigationBar%E7%B1%BB/">Flutter-BottomNavigationBar类</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Chip/">Flutter-Chip</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ExpansionTile(%E9%97%AD%E5%90%88%E5%88%97%E8%A1%A8)/">Flutter-ExpansionTile(闭合列表)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Flexible%E5%92%8C-Expanded/">Flutter-Flexible和-Expanded</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-ListTile(06)/">Flutter-ListTile(06)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Padding/">Flutter-Padding</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Stack(%E5%B1%82%E5%8F%A0%E6%8E%A7%E4%BB%B6)/">Flutter-Stack(层叠控件)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-Text(02)/">Flutter-Text(02)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-card%EF%BC%88%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%EF%BC%89/">Flutter-Card（卡片布局）</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-gridView/">Flutter-gridView</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-listview(07)/">Flutter-Listview(07)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-mainAxisAlignment%E5%92%8CcrossAxisAlignment/">Flutter-mainAxisAlignment和crossAxisAlignment</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%8D%95%E9%80%89%E6%A1%86%E5%92%8C%E5%A4%8D%E9%80%89%E6%A1%86(05)/">Flutter-单选框和复选框(05)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%9B%BE%E7%89%87(04)/">Flutter-图片(04)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%AF%BC%E8%88%AA%E8%BF%94%E5%9B%9E%E6%8B%A6%E6%88%AAWillPopScope(%E9%98%B2%E8%AF%AF%E8%A7%A6)/">Flutter-导航返回拦截WillPopScope(防误触)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%B1%82%E5%8F%A0%E5%B8%83%E5%B1%80Stack%E3%80%81Positioned/">Flutter-层叠布局Stack、Positioned</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/">Flutter-弹性布局Flex</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%8C%89%E9%92%AE(03)/">Flutter-按钮(03)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80Wrap%E3%80%81Flow/">Flutter-流式布局Wrap、Flow</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn-1/">Flutter-线性布局Row和Column-1</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80Row%E5%92%8CColumn/">Flutter-线性布局Row和Column</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%A0%87%E7%82%B9/">Flutter-输入框和标点</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98/">Flutter-颜色渐变</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8(01)/">Flutter基础使用(01)</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Flutter/flutter%E7%AE%80%E4%BB%8B/">Flutter简介</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            QT
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/QT/QT-Creator%E5%AE%89%E8%A3%85/">QT-Creator安装</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            svn配置及使用
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">Svn下载远程仓库</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn客户端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Svn服务端安装和配置</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/svn%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/svn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Svn的基本操作</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/win11%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA/">Win11自动关机</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/">我的简历</a></li>  <li class="file"><a href="/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/csdn%E6%96%87%E7%AB%A0%E5%AF%BC%E5%87%BAmarkdown/">Csdn文章导出到本地markdown</a></li>  </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main">
        <article id="post-Android FrameWork/Framework源码分析/Android 13/InPutManagerService/2.EventHub获取事件" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/">InPutManagerService</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> 从前面inputflinger的启动分析中，我们知道事件来源是在<code>EventHub::getEvents</code>, 所以我们重点看下这个方法的流程来了解事件是如何从驱动上报中获取的。</p>
<h4 id="EventHub-getEvents"><a href="#EventHub-getEvents" class="headerlink" title="EventHub::getEvents"></a>EventHub::getEvents</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;EventHub.cpp</p>
<pre><code>size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123;
    ALOG_ASSERT(bufferSize &gt;= 1);
        
    std::scoped_lock _l(mLock);
    //创建一个input_event数组，用于存放从epoll中读取到的input_events
    struct input_event readBuffer[bufferSize];
    //buffer是inputReader传入的RawEvent数组首地址，数组大小为256，将事件构造成RawEvent并装入后返回给inputReader
    //用这里把数组地址赋给event指针，后续使用这个指针操作这个数组
    RawEvent* event = buffer; //传入的RawEvent数组首地址
    //一次处理事件的最大容量为256个
    size_t capacity = bufferSize;
    bool awoken = false;
    for (;;) &#123;
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);  //获取当前时间戳

        //处理有关设备状态变化的逻辑
        // Reopen input devices if needed.
        if (mNeedToReopenDevices) &#123;
            mNeedToReopenDevices = false;

            ALOGI(&quot;Reopening all input devices due to a configuration change.&quot;);

            closeAllDevicesLocked();
            mNeedToScanDevices = true;
            break; // return to the caller before we actually rescan
        &#125;

        // Report any devices that had last been added/removed.
        //当调用closeDeviceLocked时，就会把需要关闭的设备加入mClosingDevices，下一次循环到这里时就遍历这个列表处理
        for (auto it = mClosingDevices.begin(); it != mClosingDevices.end();) &#123;
            //移除一个设备就构建一个DEVICE_REMOVED类型的event并加入RawEvent数组中
            std::unique_ptr&lt;Device&gt; device = std::move(*it);
            ALOGV(&quot;Reporting device closed: id=%d, name=%s\n&quot;, device-&gt;id, device-&gt;path.c_str());
            event-&gt;when = now;
            event-&gt;deviceId = (device-&gt;id == mBuiltInKeyboardId)
                    ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID
                    : device-&gt;id;
            event-&gt;type = DEVICE_REMOVED;
            event += 1;
            it = mClosingDevices.erase(it);  //从mClosingDevices中移除device
            mNeedToSendFinishedDeviceScan = true;
            if (--capacity == 0) &#123;
                break;
            &#125;
        &#125;

        //当EventHub初始化时，mNeedToScanDevices = true， 所以首次进入需要scan输入设备
        if (mNeedToScanDevices) &#123;
            mNeedToScanDevices = false;
            scanDevicesLocked();  //扫描设备&quot;/dev/input&quot;下的设备，例如event1、event2，这个方法很复杂，
            mNeedToSendFinishedDeviceScan = true;
        &#125;
        //上一步进行了scan device的操作，现在mOpeningDevices是记录着获取到的Device
        while (!mOpeningDevices.empty()) &#123;
            //遍历取出mOpeningDevices中Device，构建RawEvent-&gt;DEVICE_ADDED事件，写入event缓冲区中
            std::unique_ptr&lt;Device&gt; device = std::move(*mOpeningDevices.rbegin());
            mOpeningDevices.pop_back();//把这个device对象从移除mOpeningDevices中
            ALOGV(&quot;Reporting device opened: id=%d, name=%s\n&quot;, device-&gt;id, device-&gt;path.c_str());
            //构建一个RawEvent时间，type = DEVICE_ADDED
            event-&gt;when = now;
            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id;
            event-&gt;type = DEVICE_ADDED;
            event += 1; //RawEvent对象偏移 + 1（RawEvent数组中RawEvent数量）
        
            ...
            //从已经处理的设备中mOpeningDevices中的device加入mDevices Map中，以device-&gt;id标记
            auto [dev_it, inserted] = mDevices.insert_or_assign(device-&gt;id, std::move(device));

            mNeedToSendFinishedDeviceScan = true;  //标记扫描完成，可以退出扫描状态（退出也要发退出事件）
            //如果RawEvent数组装满了，就跳出循环往下执行（需要等数组中数据分发释放后进入这里再处理）
            if (--capacity == 0) &#123;  
                break;
            &#125;
        &#125;
        //如果扫描结束需要发一个mNeedToSendFinishedDeviceScan事件，将这个事件构造并写入event（RawEvent）数组中
        if (mNeedToSendFinishedDeviceScan) &#123;
            mNeedToSendFinishedDeviceScan = false;
            event-&gt;when = now;
            event-&gt;type = FINISHED_DEVICE_SCAN;
            event += 1;  //RawEvent对象偏移 + 1（RawEvent数组中RawEvent数量）
            if (--capacity == 0) &#123;
                break;
            &#125;
        &#125;

        // Grab the next input event.
        //从epoll中下一个输入事件
        bool deviceChanged = false;  //这个变量标记当前设备是否有变化（拔插、配置改变等）
        //mPendingEventCount指epoll中返回的事件（在epoll event数组中）的数量
        //mPendingEventIndex指要处理的epoll事件在epoll返回列表中的下标
        //循环处理epoll返回列表中的epoll事件
        while (mPendingEventIndex &lt; mPendingEventCount) &#123;
            const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++];
            if (eventItem.data.fd == mINotifyFd) &#123;
                if (eventItem.events &amp; EPOLLIN) &#123;
                    mPendingINotify = true;
                &#125; else &#123;
                    ALOGW(&quot;Received unexpected epoll event 0x%08x for INotify.&quot;, eventItem.events);
                &#125;
                continue;
            &#125;

            if (eventItem.data.fd == mWakeReadPipeFd) &#123;
                if (eventItem.events &amp; EPOLLIN) &#123;
                    ALOGV(&quot;awoken after wake()&quot;);
                    awoken = true;
                    char wakeReadBuffer[16];
                    ssize_t nRead;
                    do &#123;
                        nRead = read(mWakeReadPipeFd, wakeReadBuffer, sizeof(wakeReadBuffer));
                    &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(wakeReadBuffer));
                &#125; else &#123;
                    ALOGW(&quot;Received unexpected epoll event 0x%08x for wake read pipe.&quot;,
                          eventItem.events);
                &#125;
                continue;
            &#125;

            //如果非mINotifyFd和非mWakeReadPipeFd，则是底层输入驱动上报的输入事件，那么通过fd获取这个事件对应的Device
            Device* device = getDeviceByFdLocked(eventItem.data.fd);
            
             ...
            // This must be an input event
            //如果是个epoll读事件
            if (eventItem.events &amp; EPOLLIN) &#123;
                //通过read方法获取读缓冲区大小和数据。写入readBuffer，读取size为256个input_event
                int32_t readSize =
                        read(device-&gt;fd, readBuffer, sizeof(struct input_event) * capacity);
                        
                if (readSize == 0 || (readSize &lt; 0 &amp;&amp; errno == ENODEV)) &#123;
                    // Device was removed before INotify noticed.
                    //如果读取的size &lt;= 0 且返回异常可能是设备已经被移除了，只是INotify还没通知，
                    //那么就标记这个设备状态改变，并移除这个设备
                    deviceChanged = true;  //标记这个设备状态改变
                    closeDeviceLocked(*device);  //移除这个设备
                &#125; else if (readSize &lt; 0) &#123;
                    ...
                &#125; else if ((readSize % sizeof(struct input_event)) != 0) &#123;
                    ...
                &#125; else &#123; //正常读到数据了
                    //(特殊)如果读到的device是内置键盘，name就设置它的device-&gt;id = 0
                    int32_t deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id;
                    //计算这次读到的epoll读事件中的readBuffer中包含的input_event数量
                    size_t count = size_t(readSize) / sizeof(struct input_event);
                    //从readBuffer循环取出读到的的input_event对象
                    //构造RawEvent对象写入RawEvent数组中，指针依次往后偏移
                    for (size_t i = 0; i &lt; count; i++) &#123;
                        struct input_event&amp; iev = readBuffer[i];
                        event-&gt;when = processEventTimestamp(iev);
                        event-&gt;readTime = systemTime(SYSTEM_TIME_MONOTONIC);
                        event-&gt;deviceId = deviceId;
                        event-&gt;type = iev.type;
                        event-&gt;code = iev.code;
                        event-&gt;value = iev.value;
                        event += 1;
                        capacity -= 1;
                    &#125;
                    //如果写满了RawEvent数组
                    if (capacity == 0) &#123;
                        // The result buffer is full.  Reset the pending event index
                        // so we will try to read the device again on the next iteration.
                        // 如果RawEvent数组写满了，就把mPendingEventIndex - 1，(因为下次循环开始会加一，提前减一这样处理的就还是当前这个epoll事件)
                        // 说明我们本次epoll读事件我们没有处理完，下一个循环还要继续处理这个epoll事件
                        mPendingEventIndex -= 1;
                        break;
                    &#125;
                &#125;
            &#125; else if (eventItem.events &amp; EPOLLHUP) &#123;  //如果是hang-up事件说明设备拔出，就移除这个设备，通知设备状态变化
                ALOGI(&quot;Removing device %s due to epoll hang-up event.&quot;,
                      device-&gt;identifier.name.c_str());
                deviceChanged = true;
                closeDeviceLocked(*device);
            &#125; else &#123;  //收到异常的epoll事件，不处理
                ALOGW(&quot;Received unexpected epoll event 0x%08x for device %s.&quot;, eventItem.events,
                      device-&gt;identifier.name.c_str());
            &#125;
        &#125;

        // readNotify() will modify the list of devices so this must be done after
        // processing all other events to ensure that we read all remaining events
        // before closing the devices.
        //当处理完一次一次epoll_wait返回列表中所有epoll事件后，检测下是否有底层设备变化（mPendingINotify = true）
        //如果有就通知设备状态改变
        if (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;
            mPendingINotify = false;
            readNotifyLocked();  //通过read去读取INotify fd返回的事件，判断设备状态，是需要重新获取设备还是移除设备
            deviceChanged = true;  //标记设备状态改变，
        &#125;

        // Report added or removed devices immediately.
        // 如果有设备状态改变（新增或者移除）需要马上到下一个循环处理
        if (deviceChanged) &#123;
            continue;
        &#125;

        // Return now if we have collected any events or if we were explicitly awoken.
        //1.如果其他地方调用了`mEventHub-&gt;wake()`则会唤醒阻塞在epoll_wait()中的inputReader线程，下一次循环时然后从这里跳出getEvents方法，往下执行loopOnce，处理输入事件
        //2. 或者RawEvent数组中有数据则跳出getEvents方法，往下执行loopOnce，处理输入事件
        if (event != buffer || awoken) &#123;
            break;
        &#125;

        //如果RawEvent数组为空且没有inputReader线程没有被外部唤醒，则下面就准备开始获取下一次epoll事件(进入阻塞等待)
        mPendingEventIndex = 0; //准备进入下一次事件接收前，重置mPendingEventIndex下标

        mLock.unlock(); // release lock before poll
        //进入epoll_wait阻塞等待驱动上报事件
        int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);
        //从epoll_wait中唤醒
        //也许是外部调用mEventHub-&gt;wake()唤醒
        //或者内核通知事件上报唤醒
        //或者是超时退出休眠
        
        mLock.lock(); // reacquire lock after poll

        if (pollResult == 0) &#123;
            // Timed out.
            // 超时退出的情况
            mPendingEventCount = 0;
            break;
        &#125;

        if (pollResult &lt; 0) &#123;
            // An error occurred.
            mPendingEventCount = 0;

            // Sleep after errors to avoid locking up the system.
            // Hopefully the error is transient.
            if (errno != EINTR) &#123;
                ALOGW(&quot;poll failed (errno=%d)\n&quot;, errno);
                usleep(100000);
            &#125;
        &#125; else &#123;
            // Some events occurred.
            // 获取到epoll事件，将事件数量赋给mPendingEventCount
            mPendingEventCount = size_t(pollResult);
        &#125;
    &#125;

    // All done, return the number of events we read.
    // 处理结束，退出循环将事件返回到inputReader的loopOnce中处理
    return event - buffer;
&#125;
</code></pre>
<h4 id="EventHub-scanDevicesLocked"><a href="#EventHub-scanDevicesLocked" class="headerlink" title="EventHub::scanDevicesLocked()"></a>EventHub::scanDevicesLocked()</h4><pre><code>void EventHub::scanDevicesLocked() &#123;
    status_t result;
    std::error_code errorCode;
            
    if (std::filesystem::exists(DEVICE_INPUT_PATH, errorCode)) &#123;
        result = scanDirLocked(DEVICE_INPUT_PATH);
        
    &#125; else &#123;
        ...
    &#125;
    ...
&#125;

status_t EventHub::scanDirLocked(const std::string&amp; dirname) &#123;
    //遍历 /dev/input/event* 路径，打开这些设备并获取相关设备信息
    for (const auto&amp; entry : std::filesystem::directory_iterator(dirname)) &#123;
        openDeviceLocked(entry.path());
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="EventHub-openDeviceLocked"><a href="#EventHub-openDeviceLocked" class="headerlink" title="EventHub::openDeviceLocked"></a>EventHub::openDeviceLocked</h4><p>这个方法很长，主要作用就是打开<code>/dev/input/eventX</code>设备节点，用返回的fd通过<code>ioctl</code>向驱动获取输入设备<code>device</code>相关信息。</p>
<pre><code>void EventHub::openDeviceLocked(const std::string&amp; devicePath) &#123;
    //如果目标路径是当前已存在的设备（之前扫描过的设备）的，就不再扫描这个路径了，避免出现重复设备
    for (const auto&amp; [deviceId, device] : mDevices) &#123;
        if (device-&gt;path == devicePath) &#123;
            return; // device was already registered
        &#125;
    &#125;

    char buffer[80];

    ALOGV(&quot;Opening device: %s&quot;, devicePath.c_str());
    //通过open打开设备节点，返回该设备节点的fd
    int fd = open(devicePath.c_str(), O_RDWR | O_CLOEXEC | O_NONBLOCK);
            
    InputDeviceIdentifier identifier;  //一个硬件设备的结构体在用户空间中描述, 包括name、vendor、product、descriptor等

    // Get device name.
    //获取设备 device name
    if (ioctl(fd, EVIOCGNAME(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;
        ALOGE(&quot;Could not get device name for %s: %s&quot;, devicePath.c_str(), strerror(errno));
    &#125; else &#123;
        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
        identifier.name = buffer;
    &#125;

    // Check to see if the device is on our excluded list
    //通过device name检测下这个设备是不是在排除名单，如果是就忽略这个设备
    for (size_t i = 0; i &lt; mExcludedDevices.size(); i++) &#123;
        const std::string&amp; item = mExcludedDevices[i];
        if (identifier.name == item) &#123;
            ALOGI(&quot;ignoring event id %s driver %s\n&quot;, devicePath.c_str(), item.c_str());
            close(fd);
            return;
        &#125;
    &#125;

    // Get device driver version.
    //获取设备驱动版本
    int driverVersion;
    if (ioctl(fd, EVIOCGVERSION, &amp;driverVersion)) &#123;
    &#125;

    // Get device identifier.
    //获取设备的identifier，是设备在内核空间的描述
    //内核描述为input_id结构体，内容为：bustype、product、product、version
    struct input_id inputId;
    if (ioctl(fd, EVIOCGID, &amp;inputId)) &#123;
    &#125;
    identifier.bus = inputId.bustype;
    identifier.product = inputId.product;
    identifier.vendor = inputId.product;
    identifier.version = inputId.version;

    // Get device physical location.
    //获取设备的物理位置（物理拓扑中的位置）
    if (ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;
        // fprintf(stderr, &quot;could not get location for %s, %s\n&quot;, devicePath, strerror(errno));
    &#125; else &#123;
        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
        identifier.location = buffer;
    &#125;

    // Get device unique id.
    //获取设备的unique id（一般的设备这个字段都是没有的，为空）
    if (ioctl(fd, EVIOCGUNIQ(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;
        // fprintf(stderr, &quot;could not get idstring for %s, %s\n&quot;, devicePath, strerror(errno));
    &#125; else &#123;
        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
        identifier.uniqueId = buffer;
    &#125;

    // Fill in the descriptor.
    // 获取设备的descriptor，这个字段很重要，它是用于标识这个设备的标识符，无论重启、拔插、升级都不会变
    //根据unique_id、vendor_id、product_id、随机数组合后sha1转化生成，赋值给identifier.descriptor
    assignDescriptorLocked(identifier);

    // Allocate device.  (The device object takes ownership of the fd at this point.)
    //创建Device结构体，用于描述当前从驱动获取到的这个输入设备，将前面获取的设备fd、设备节点路径devicePath、设备硬件描述identifier赋给这个Device,
    //同时还有deviceId，这个id并不是驱动传上来的，而是我们每次通过ioctl获取到新设备时计数 + 1
    int32_t deviceId = mNextDeviceId++;
    std::unique_ptr&lt;Device&gt; device = std::make_unique&lt;Device&gt;(fd, deviceId, devicePath, identifier);

    //我们可以通过这个打印或者dumpsys input获取设备的信息
    ALOGV(&quot;add device %d: %s\n&quot;, deviceId, devicePath.c_str());
    ALOGV(&quot;  bus:        %04x\n&quot;
          &quot;  vendor      %04x\n&quot;
          &quot;  product     %04x\n&quot;
          &quot;  version     %04x\n&quot;,
          identifier.bus, identifier.vendor, identifier.product, identifier.version);
    ALOGV(&quot;  name:       \&quot;%s\&quot;\n&quot;, identifier.name.c_str());
    ALOGV(&quot;  location:   \&quot;%s\&quot;\n&quot;, identifier.location.c_str());
    ALOGV(&quot;  unique id:  \&quot;%s\&quot;\n&quot;, identifier.uniqueId.c_str());
    ALOGV(&quot;  descriptor: \&quot;%s\&quot;\n&quot;, identifier.descriptor.c_str());
    ALOGV(&quot;  driver:     v%d.%d.%d\n&quot;, driverVersion &gt;&gt; 16, (driverVersion &gt;&gt; 8) &amp; 0xff,
          driverVersion &amp; 0xff);

    // Load the configuration file for the device.
    //为当前获取到的设备加载`.idc`配置文件，格式一般是：/vendor/usr/idc/Vendor_XXXX_Product_XXXX_Version_XXXX.idc
    //通过product/vendor/version来检索主要路径下符合条件的`idc`文件
    //解析该文件后保存在device对象的configuration变量中
    device-&gt;loadConfigurationLocked();

    // 针对带电池，有LED灯的输入设备，需要设备associatedDevice来关联它的额外能力
    bool hasBattery = false;
    bool hasLights = false;
    // Check the sysfs root path
    std::optional&lt;std::filesystem::path&gt; sysfsRootPath = getSysfsRootPath(devicePath.c_str());
    if (sysfsRootPath.has_value()) &#123;
        std::shared_ptr&lt;AssociatedDevice&gt; associatedDevice;
        for (const auto&amp; [id, dev] : mDevices) &#123;
            if (device-&gt;identifier.descriptor == dev-&gt;identifier.descriptor &amp;&amp;
                !dev-&gt;associatedDevice) &#123;
                associatedDevice = dev-&gt;associatedDevice;
            &#125;
        &#125;
        if (!associatedDevice) &#123;
            associatedDevice = std::make_shared&lt;AssociatedDevice&gt;(sysfsRootPath.value());
        &#125;
        hasBattery = associatedDevice-&gt;configureBatteryLocked();
        hasLights = associatedDevice-&gt;configureLightsLocked();

        device-&gt;associatedDevice = associatedDevice;
    &#125;

    //向ioctl驱动查询这个设备会上报那种类型的事件，每个类型都问一下支不支持，有点...
    //设备会上报哪一种事件，对应的XXBitmask就会有对应的值，用于判断它是什么类型的设备
    // Figure out the kinds of events the device reports.
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_KEY, 0), device-&gt;keyBitmask);
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_ABS, 0), device-&gt;absBitmask);
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_REL, 0), device-&gt;relBitmask);
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_SW, 0), device-&gt;swBitmask);
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_LED, 0), device-&gt;ledBitmask);
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_FF, 0), device-&gt;ffBitmask);
    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_MSC, 0), device-&gt;mscBitmask);
    device-&gt;readDeviceBitMask(EVIOCGPROP(0), device-&gt;propBitmask);

    // See if this is a keyboard.  Ignore everything in the button range except for
    // joystick and gamepad buttons which are handled like keyboards for the most part.
    // 判断是否是键盘、游戏手柄等
    bool haveKeyboardKeys =
            device-&gt;keyBitmask.any(0, BTN_MISC) || device-&gt;keyBitmask.any(BTN_WHEEL, KEY_MAX + 1);
    bool haveGamepadButtons = device-&gt;keyBitmask.any(BTN_MISC, BTN_MOUSE) ||
            device-&gt;keyBitmask.any(BTN_JOYSTICK, BTN_DIGI);
    if (haveKeyboardKeys || haveGamepadButtons) &#123;
        device-&gt;classes |= InputDeviceClass::KEYBOARD;
    &#125;

    // See if this is a cursor device such as a trackball or mouse.
    //判断设备是不是鼠标或者轨迹球类型
    if (device-&gt;keyBitmask.test(BTN_MOUSE) &amp;&amp; device-&gt;relBitmask.test(REL_X) &amp;&amp;
        device-&gt;relBitmask.test(REL_Y)) &#123;
        device-&gt;classes |= InputDeviceClass::CURSOR;
    &#125;

    // See if this is a rotary encoder type device.
    //判断设备是不是旋转编码器类型（旋钮）
    String8 deviceType = String8();
    if (device-&gt;configuration &amp;&amp;
        device-&gt;configuration-&gt;tryGetProperty(String8(&quot;device.type&quot;), deviceType)) &#123;
        if (!deviceType.compare(String8(&quot;rotaryEncoder&quot;))) &#123;
            device-&gt;classes |= InputDeviceClass::ROTARY_ENCODER;
        &#125;
    &#125;

    // See if this is a touch pad.
    // Is this a new modern multi-touch driver?
    //是不是触摸板，支不支持多点触摸
    if (device-&gt;absBitmask.test(ABS_MT_POSITION_X) &amp;&amp; device-&gt;absBitmask.test(ABS_MT_POSITION_Y)) &#123;
        // Some joysticks such as the PS3 controller report axes that conflict
        // with the ABS_MT range.  Try to confirm that the device really is
        // a touch screen.
        if (device-&gt;keyBitmask.test(BTN_TOUCH) || !haveGamepadButtons) &#123;
            device-&gt;classes |= (InputDeviceClass::TOUCH | InputDeviceClass::TOUCH_MT);
        &#125;
        // Is this an old style single-touch driver?
        //是不是老版的单点触摸驱动
    &#125; else if (device-&gt;keyBitmask.test(BTN_TOUCH) &amp;&amp; device-&gt;absBitmask.test(ABS_X) &amp;&amp;
               device-&gt;absBitmask.test(ABS_Y)) &#123;
        device-&gt;classes |= InputDeviceClass::TOUCH;
        // Is this a BT stylus?
        //是不是蓝牙手写笔
    &#125; else if ((device-&gt;absBitmask.test(ABS_PRESSURE) || device-&gt;keyBitmask.test(BTN_TOUCH)) &amp;&amp;
               !device-&gt;absBitmask.test(ABS_X) &amp;&amp; !device-&gt;absBitmask.test(ABS_Y)) &#123;
        device-&gt;classes |= InputDeviceClass::EXTERNAL_STYLUS;
        // Keyboard will try to claim some of the buttons but we really want to reserve those so we
        // can fuse it with the touch screen data, so just take them back. Note this means an
        // external stylus cannot also be a keyboard device.
        //外部手写笔不能同时是键盘设备
        device-&gt;classes &amp;= ~InputDeviceClass::KEYBOARD;
    &#125;

    // See if this device is a joystick.
    // Assumes that joysticks always have gamepad buttons in order to distinguish them
    // from other devices such as accelerometers that also have absolute axes.
    //是不是操作杆
    if (haveGamepadButtons) &#123;
        auto assumedClasses = device-&gt;classes | InputDeviceClass::JOYSTICK;
        for (int i = 0; i &lt;= ABS_MAX; i++) &#123;
            if (device-&gt;absBitmask.test(i) &amp;&amp;
                (getAbsAxisUsage(i, assumedClasses).test(InputDeviceClass::JOYSTICK))) &#123;
                device-&gt;classes = assumedClasses;
                break;
            &#125;
        &#125;
    &#125;

    // Check whether this device is an accelerometer.
    //是不是加速计
    if (device-&gt;propBitmask.test(INPUT_PROP_ACCELEROMETER)) &#123;
        device-&gt;classes |= InputDeviceClass::SENSOR;
    &#125;

    // Check whether this device has switches.
    //是不是有开关
    for (int i = 0; i &lt;= SW_MAX; i++) &#123;
        if (device-&gt;swBitmask.test(i)) &#123;
            device-&gt;classes |= InputDeviceClass::SWITCH;
            break;
        &#125;
    &#125;

    // Check whether this device supports the vibrator.
    //支不支持震动
    if (device-&gt;ffBitmask.test(FF_RUMBLE)) &#123;
        device-&gt;classes |= InputDeviceClass::VIBRATOR;
    &#125;

    // Configure virtual keys.
    //虚拟按键（类似于老手机上面三个虚拟按键back、home、recent）
    if ((device-&gt;classes.test(InputDeviceClass::TOUCH))) &#123;
        // Load the virtual keys for the touch screen, if any.
        // We do this now so that we can make sure to load the keymap if necessary.
        bool success = device-&gt;loadVirtualKeyMapLocked();
        if (success) &#123;
            device-&gt;classes |= InputDeviceClass::KEYBOARD;
        &#125;
    &#125;

    // Load the key map.
    // We need to do this for joysticks too because the key layout may specify axes, and for
    // sensor as well because the key layout may specify the axes to sensor data mapping.
    //如果设备是键盘等设备就加载按键映射配置文件，
    //包括kl(keyLayout)文件、kcm(KeyCharacterMap)文件
    status_t keyMapStatus = NAME_NOT_FOUND;
    if (device-&gt;classes.any(InputDeviceClass::KEYBOARD | InputDeviceClass::JOYSTICK |
                            InputDeviceClass::SENSOR)) &#123;
        // Load the keymap for the device.
        keyMapStatus = device-&gt;loadKeyMapLocked();  //加载过程和idc文件类似
    &#125;

    // Configure the keyboard, gamepad or virtual keyboard.
    //配置键盘、手柄、虚拟键盘相关
    if (device-&gt;classes.test(InputDeviceClass::KEYBOARD)) &#123;
        // Register the keyboard as a built-in keyboard if it is eligible.
        //如果符合内置键盘的条件就把这个device指定为内置键盘
        if (!keyMapStatus &amp;&amp; mBuiltInKeyboardId == NO_BUILT_IN_KEYBOARD &amp;&amp;
            isEligibleBuiltInKeyboard(device-&gt;identifier, device-&gt;configuration.get(),
                                      &amp;device-&gt;keyMap)) &#123;
            mBuiltInKeyboardId = device-&gt;id;
        &#125;

        // &#39;Q&#39; key support = cheap test of whether this is an alpha-capable kbd
        //如果有Q键就说明是一个标准全功能键盘，设置为ALPHAKEY类型
        if (device-&gt;hasKeycodeLocked(AKEYCODE_Q)) &#123;
            device-&gt;classes |= InputDeviceClass::ALPHAKEY;
        &#125;

        // See if this device has a DPAD.
        //如果有方向键
        if (device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_UP) &amp;&amp;
            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_DOWN) &amp;&amp;
            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_LEFT) &amp;&amp;
            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_RIGHT) &amp;&amp;
            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_CENTER)) &#123;
            device-&gt;classes |= InputDeviceClass::DPAD;
        &#125;

        // See if this device has a gamepad.
        //如果是游戏手柄
        for (size_t i = 0; i &lt; sizeof(GAMEPAD_KEYCODES) / sizeof(GAMEPAD_KEYCODES[0]); i++) &#123;
            if (device-&gt;hasKeycodeLocked(GAMEPAD_KEYCODES[i])) &#123;
                device-&gt;classes |= InputDeviceClass::GAMEPAD;
                break;
            &#125;
        &#125;
    &#125;

    // If the device isn&#39;t recognized as something we handle, don&#39;t monitor it.
    //如果这个设备上面的类型都不符合，那么这个设备就是个屑，不用往下处理了，忽略，直接返回
    if (device-&gt;classes == ftl::Flags&lt;InputDeviceClass&gt;(0)) &#123;
        ALOGV(&quot;Dropping device: id=%d, path=&#39;%s&#39;, name=&#39;%s&#39;&quot;, deviceId, devicePath.c_str(),
              device-&gt;identifier.name.c_str());
        return;
    &#125;

    // Classify InputDeviceClass::BATTERY.
    //如果这个设备还有关联的电池
    if (hasBattery) &#123;
        device-&gt;classes |= InputDeviceClass::BATTERY;
    &#125;

    // Classify InputDeviceClass::LIGHT.
    //如果这个设备还有先进的LED灯
    if (hasLights) &#123;
        device-&gt;classes |= InputDeviceClass::LIGHT;
    &#125;

    // Determine whether the device has a mic.
    //如果这个设备还有麦克风
    if (device-&gt;deviceHasMicLocked()) &#123;
        device-&gt;classes |= InputDeviceClass::MIC;
    &#125;

    // Determine whether the device is external or internal.
    //从设备的idc文件中获取这个设备是内部设备还是外接设备，这个会影响一些优先级等，比如多屏
    if (device-&gt;isExternalDeviceLocked()) &#123;
        device-&gt;classes |= InputDeviceClass::EXTERNAL;
    &#125;

    //游戏手柄和操作杆有时会有多个controller
    if (device-&gt;classes.any(InputDeviceClass::JOYSTICK | InputDeviceClass::DPAD) &amp;&amp;
        device-&gt;classes.test(InputDeviceClass::GAMEPAD)) &#123;
        device-&gt;controllerNumber = getNextControllerNumberLocked(device-&gt;identifier.name);
        device-&gt;setLedForControllerLocked();
    &#125;

    //将这个设备的fd加入epoll的监听
    if (registerDeviceForEpollLocked(*device) != OK) &#123;
        return;
    &#125;
    //使用ioctl设置fd参数，例如按键重复、挂起块和时钟类型
    device-&gt;configureFd();

    ALOGI(&quot;New device: id=%d, fd=%d, path=&#39;%s&#39;, name=&#39;%s&#39;, classes=%s, &quot;
          &quot;configuration=&#39;%s&#39;, keyLayout=&#39;%s&#39;, keyCharacterMap=&#39;%s&#39;, builtinKeyboard=%s, &quot;,
          deviceId, fd, devicePath.c_str(), device-&gt;identifier.name.c_str(),
          device-&gt;classes.string().c_str(), device-&gt;configurationFile.c_str(),
          device-&gt;keyMap.keyLayoutFile.c_str(), device-&gt;keyMap.keyCharacterMapFile.c_str(),
          toString(mBuiltInKeyboardId == deviceId));

    //到这里从驱动获取到的这个设备已经完成各种初始化和配置，是时候加到mOpeningDevices中了，继续下一个循环，最后读取所有的设备
    addDeviceLocked(std::move(device));
&#125;
</code></pre>
<p>这个方法很长，总的概括来看就做了几件事情：</p>
<ol>
<li>打开设备节点，从设备驱动中获取设备的各种描述信息并构造出Device对象</li>
<li>根据设备的信息加载这个设备的<code>idc</code>文件</li>
<li>向驱动查询这个设备支持的事件类型</li>
<li>判断设备的类型，设置相关的属性到<code>device-&gt;classes</code>中</li>
<li>如果是键盘灯设备还需要加载设备对应的<code>kl</code>文件和<code>kcm</code>文件，</li>
<li>将这个<code>设备的fd</code>加入<code>epoll</code>的监听中</li>
<li>通过<code>ioctl</code>设置<code>fd参数</code>，例如<code>按键重复、挂起块和时钟类型</code></li>
<li>最后再把这个设备加到<code>mOpeningDevices</code>中管理</li>
</ol>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/InPutManagerService/1.InputFlinger的启动" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/">InPutManagerService</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h3 id="服务的启动"><a href="#服务的启动" class="headerlink" title="服务的启动"></a>服务的启动</h3><p>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</p>
<pre><code>    private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123;
        t.traceBegin(&quot;startOtherServices&quot;);
        ...
        WindowManagerService wm = null;
        InputManagerService inputManager = null;

        try &#123;
            //1. 获取InputManagerService，并走初始化inputManager流程
            ...
            t.traceBegin(&quot;StartInputManagerService&quot;);
            inputManager = new InputManagerService(context);
            t.traceEnd();
            ...
            //2. WindowManagerService服务持有inputManager对象
            t.traceBegin(&quot;StartWindowManagerService&quot;);
            wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,
                    new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);
               ...
               //3. 向ServiceManager注册java层ims服务，name = &quot;input&quot;，(native层的服务name = &quot;inputflinger&quot;)
            ServiceManager.addService(Context.INPUT_SERVICE, inputManager,
                    /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);
            t.traceEnd();

            ...
            //4. 启动inputflinger，处理输入事件
            t.traceBegin(&quot;StartInputManager&quot;);
            inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());
            inputManager.start();
            t.traceEnd();
            ...
        &#125; catch (Throwable e) &#123;
            ...
        &#125;
</code></pre>
<ol>
<li>获取InputManagerService，并走初始化inputManager（java层和native层）流程</li>
<li>WindowManagerService服务构造时传入inputManager对象，用户wms和ims交互</li>
<li>向ServiceManager注册java层ims服务</li>
<li>启动inputflinger，处理输入事件</li>
</ol>
<p>我们重点看下1和4</p>
<h3 id="1-初始化InputFlinger"><a href="#1-初始化InputFlinger" class="headerlink" title="1. 初始化InputFlinger"></a>1. 初始化InputFlinger</h3><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java</p>
<pre><code>    public InputManagerService(Context context) &#123;
        this(new Injector(context, DisplayThread.get().getLooper()));
    &#125;

    @VisibleForTesting
    InputManagerService(Injector injector) &#123;
        ...
        mContext = injector.getContext();
        mHandler = new InputManagerHandler(injector.getLooper());  //创建一个handle（使用DisplayThread，这个线程用户
       //wms，display，input三个服务使用，对延迟敏感）
        mNative = injector.getNativeService(this);  //创建native input服务（NativeInputManagerService）
        ...
        injector.registerLocalService(new LocalService());  //将InputManagerService中的InputManagerInternal实现类加入LocalServices，供同进程其他服务调用相关功能
    &#125;

    @VisibleForTesting
    static class Injector &#123;
        private final Context mContext;
        private final Looper mLooper;

        Injector(Context context, Looper looper) &#123;
            mContext = context;
            mLooper = looper;
        &#125;

        Context getContext() &#123;
            return mContext;
        &#125;

        Looper getLooper() &#123;
            return mLooper;
        &#125;
        //创建native层对应的service
        NativeInputManagerService getNativeService(InputManagerService service) &#123;
            return new NativeInputManagerService.NativeImpl(service, mContext, mLooper.getQueue());
        &#125;
        //将InputManagerService中的InputManagerInternal实现类加入LocalServices，供同进程其他服务调用相关功能
        void registerLocalService(InputManagerInternal localService) &#123;
            LocalServices.addService(InputManagerInternal.class, localService);
        &#125;
    &#125;
</code></pre>
<h4 id="NativeInputManagerService-NativeImpl"><a href="#NativeInputManagerService-NativeImpl" class="headerlink" title="NativeInputManagerService.NativeImpl"></a>NativeInputManagerService.NativeImpl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface NativeInputManagerService &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NativeImpl</span> implements NativeInputManagerService &#123;</span><br><span class="line">        <span class="comment">/** Pointer to native input manager service object, used by native code. */</span></span><br><span class="line">        @<span class="built_in">SuppressWarnings</span>(&#123;<span class="string">&quot;unused&quot;</span>, <span class="string">&quot;FieldCanBeLocal&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> mPtr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NativeImpl</span>(InputManagerService service, Context context, MessageQueue messageQueue) &#123;</span><br><span class="line">            mPtr = <span class="built_in">init</span>(service, context, messageQueue);  <span class="comment">//初始化native层服务并返回该服务的对象指针到java层</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> native <span class="type">long</span> <span class="title">init</span><span class="params">(InputManagerService service, Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                MessageQueue messageQueue)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="nativeInit"><a href="#nativeInit" class="headerlink" title="nativeInit"></a>nativeInit</h4><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=jni&spm=1001.2101.3001.7020">jni</a>&#x2F;com_android_server_input_InputManagerService.cpp</p>
<pre><code>static const JNINativeMethod gInputManagerMethods[] = &#123;
        &#123;&quot;init&quot;,
         &quot;(Lcom/android/server/input/InputManagerService;Landroid/content/Context;Landroid/os/&quot;
         &quot;MessageQueue;)J&quot;,
         (void*)nativeInit&#125;,  //init(java)-&gt;nativeInit(native)
        ...
&#125;;
    
static jlong nativeInit(JNIEnv* env, jclass /* clazz */,
        jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;
    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    ...
    // 创建native层NativeInputManager，保存java层的context对象、ims对象、msgqueue
    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,
            messageQueue-&gt;getLooper());
    im-&gt;incStrong(0);  //NativeInputManager对象强引用 + 1
    return reinterpret_cast&lt;jlong&gt;(im);  //将native层NativeInputManager对象地址返回给java层，这个地址可以在native层获取出同一个对象
&#125;

//NativeInputManager类声明，实现了三个重要接口抽象类
/*class NativeInputManager : public virtual RefBase,
    public virtual InputReaderPolicyInterface,
    public virtual InputDispatcherPolicyInterface,
    public virtual PointerControllerPolicyInterface &#123;
    */
    
NativeInputManager::NativeInputManager(jobject contextObj,
        jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) :
        mLooper(looper), mInteractive(true) &#123;
    JNIEnv* env = jniEnv();  //获取虚拟机环境指针
        
    mServiceObj = env-&gt;NewGlobalRef(serviceObj);  //将java层的ims对象保存为全局引用

    &#123;
        AutoMutex _l(mLock);
        mLocked.systemUiLightsOut = false;
        mLocked.pointerSpeed = 0;
        mLocked.pointerAcceleration = android::os::IInputConstants::DEFAULT_POINTER_ACCELERATION;
        mLocked.pointerGesturesEnabled = true;
        mLocked.showTouches = false;
        mLocked.pointerDisplayId = ADISPLAY_ID_DEFAULT;
    &#125;
    mInteractive = true;

    InputManager* im = new InputManager(this, this);  //创建native层InputManager
    mInputManager = im;
    defaultServiceManager()-&gt;addService(String16(&quot;inputflinger&quot;), im);  //向ServiceManager注册native层inputflinger服务
&#125;
</code></pre>
<h4 id="new-InputManager"><a href="#new-InputManager" class="headerlink" title="new InputManager"></a>new InputManager</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputManager.cpp</p>
<pre><code>/**
 * The event flow is via the &quot;InputListener&quot; interface, as follows:
 * InputReader -&gt; UnwantedInteractionBlocker -&gt; InputClassifier -&gt; InputDispatcher
 */
InputManager::InputManager(
        const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,
        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;
    mDispatcher = createInputDispatcher(dispatcherPolicy);
    mClassifier = std::make_unique&lt;InputClassifier&gt;(*mDispatcher);
    mBlocker = std::make_unique&lt;UnwantedInteractionBlocker&gt;(*mClassifier);
    mReader = createInputReader(readerPolicy, *mBlocker);
&#125;
</code></pre>
<p>创建并初始化四个event flow中的重要对象, 事件从前到后传递，前面的对象依次持有下一个阶段的对象引用<br><code>event flow: InputReader -&gt; UnwantedInteractionBlocker -&gt; InputClassifier -&gt; InputDispatcher</code></p>
<h4 id="createInputDispatcher"><a href="#createInputDispatcher" class="headerlink" title="createInputDispatcher"></a>createInputDispatcher</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;dispatcher&#x2F;InputDispatcher.cpp</p>
<pre><code>//InputDispatcherFactory.cpp
std::unique_ptr&lt;InputDispatcherInterface&gt; createInputDispatcher(
        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) &#123;
    return std::make_unique&lt;android::inputdispatcher::InputDispatcher&gt;(policy);
&#125;
//  InputDispatcher.cpp
InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy)
      : InputDispatcher(policy, STALE_EVENT_TIMEOUT) &#123;&#125;

InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy,
                                 std::chrono::nanoseconds staleEventTimeout)
      : mPolicy(policy),  //将接口实现对象传进来，用户和wms服务交互
     ...//一些成员变量初始化，太多了不列出
     &#123;
     
    mLooper = new Looper(false);  //用于InputDispatcher线程
    mReporter = createInputReporter();
    //注册SurfaceComposer监听，当window状态改变时回调此接口onWindowInfosChanged通知inputflinger
    mWindowInfoListener = new DispatcherWindowListener(*this);
    SurfaceComposerClient::getDefault()-&gt;addWindowInfosListener(mWindowInfoListener);

    mKeyRepeatState.lastKeyEntry = nullptr;

    policy-&gt;getDispatcherConfiguration(&amp;mConfig);
&#125;
</code></pre>
<h4 id="InputClassifier"><a href="#InputClassifier" class="headerlink" title="InputClassifier"></a>InputClassifier</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputClassifier.cpp</p>
<pre><code>//构建InputClassifier，传入mQueuedListener = listener 这个就是mDispatcher对象，这样就可以回调mDispatcher的方法
InputClassifier::InputClassifier(InputListenerInterface&amp; listener) : mQueuedListener(listener) &#123;&#125;
</code></pre>
<h4 id="UnwantedInteractionBlocker"><a href="#UnwantedInteractionBlocker" class="headerlink" title="UnwantedInteractionBlocker"></a>UnwantedInteractionBlocker</h4><pre><code>//UnwantedInteractionBlocker是所有输入事件都会经历的一个阶段
//inputReader通过它notifyXXX方法向InputDispatcher传递对应事件
//其中对于触摸事件，如果支持手掌误触等功能，则会在这里有特殊处理
UnwantedInteractionBlocker::UnwantedInteractionBlocker(InputListenerInterface&amp; listener)
      : UnwantedInteractionBlocker(listener, isPalmRejectionEnabled())&#123;&#125;;
//isPalmRejectionEnabled 检测是否开始手掌误触功能
UnwantedInteractionBlocker::UnwantedInteractionBlocker(InputListenerInterface&amp; listener,
                                                       bool enablePalmRejection)
      : mQueuedListener(listener), mEnablePalmRejection(enablePalmRejection) &#123;&#125;
</code></pre>
<h4 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputReader.cpp</p>
<pre><code>std::unique_ptr&lt;InputReaderInterface&gt; createInputReader(
        const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, InputListenerInterface&amp; listener) &#123;
    return std::make_unique&lt;InputReader&gt;(std::make_unique&lt;EventHub&gt;(), policy, listener);
&#125;

InputReader::InputReader(std::shared_ptr&lt;EventHubInterface&gt; eventHub,
                         const sp&lt;InputReaderPolicyInterface&gt;&amp; policy,
                         InputListenerInterface&amp; listener)
      : mContext(this),
        mEventHub(eventHub), //1.初始化EventHub
        mPolicy(policy),
        mQueuedListener(listener),  //2. 传入UnwantedInteractionBlocker对象
        mGlobalMetaState(AMETA_NONE),
        mLedMetaState(AMETA_NONE),
        mGeneration(1),
        mNextInputDeviceId(END_RESERVED_ID),
        mDisableVirtualKeysTimeout(LLONG_MIN),
        mNextTimeout(LLONG_MAX),
        mConfigurationChangesToRefresh(0) &#123;
    refreshConfigurationLocked(0);
    updateGlobalMetaStateLocked();
&#125;
</code></pre>
<p><code>InputReader</code>最重要就是：</p>
<ol>
<li>创建并初始化<code>EventHub</code>, 通过它向驱动获取上报的事件</li>
<li>注册<code>UnwantedInteractionBlocker</code> listener, 通过它向<code>inputDispater</code>传递事件</li>
</ol>
<h4 id="EventHub"><a href="#EventHub" class="headerlink" title="EventHub"></a>EventHub</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;EventHub.cpp</p>
<pre><code>EventHub::EventHub(void)
      : mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD),
        mNextDeviceId(1),
        mControllerNumbers(),
        mNeedToSendFinishedDeviceScan(false),
        mNeedToReopenDevices(false),
        mNeedToScanDevices(true),
        mPendingEventCount(0),
        mPendingEventIndex(0),
        mPendingINotify(false) &#123;
    ensureProcessCanBlockSuspend();
    //初始化epoll (用于监听文件描述符上的事件，用于监听具体/dev/input/eventX的fd的事件)
    mEpollFd = epoll_create1(EPOLL_CLOEXEC);
    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno));
    //初始化inotify (用于监听文件和目录的变化，这里主要时用于监听/dev/input/下面的目录变化)
    mINotifyFd = inotify_init1(IN_CLOEXEC);

    std::error_code errorCode;
    bool isDeviceInotifyAdded = false;
    //检测 &quot;/dev/input&quot; 文件节点是否存在
    if (std::filesystem::exists(DEVICE_INPUT_PATH, errorCode)) &#123;
        //如果当前&quot;/dev/input&quot; 文件节点存在则将这个路径加入Inotify监听
        addDeviceInputInotify();
    &#125; else &#123;
        //如果当前&quot;/dev/input&quot; 文件节点不存在，则先将这个路径&quot;/dev&quot;加入Inotify监听(监听dev所有节点)
        //因为有些嵌入式设备不一定一直存在输入设备，那么仅当/dev/input出现时（插入输入设备）才添加对/dev/input内容的监听, 
        addDeviceInotify();
        isDeviceInotifyAdded = true;
    &#125;
    
    //V4L视频设备相关
    if (isV4lScanningEnabled() &amp;&amp; !isDeviceInotifyAdded) &#123;
        addDeviceInotify();
    &#125; else &#123;
        ALOGI(&quot;Video device scanning disabled&quot;);
    &#125;

    struct epoll_event eventItem = &#123;&#125;;
    eventItem.events = EPOLLIN | EPOLLWAKEUP; //设置监听epoll事件类型
    eventItem.data.fd = mINotifyFd;//要处理的事件相关的文件描述符
    
    //将mINotifyFd加入epoll监听的fd池子
    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);

    //创建一个管道
    int wakeFds[2];
    result = pipe2(wakeFds, O_CLOEXEC);

    mWakeReadPipeFd = wakeFds[0];  //0为读端
    mWakeWritePipeFd = wakeFds[1];  //1为写端

    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);

    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);

    eventItem.data.fd = mWakeReadPipeFd;  //将mWakeReadPipeFd设置到eventItem.data.fd，当epoll有event到来会
    //将管道读端fd加入epoll监听的fd池子，当管道写端写入数据时，读端就换监听到epoll事件
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);
&#125;
</code></pre>
<p>到这里初始化InputFlinger就完成了</p>
<h3 id="2-启动inputflinger，处理输入事件"><a href="#2-启动inputflinger，处理输入事件" class="headerlink" title="2. 启动inputflinger，处理输入事件"></a>2. 启动inputflinger，处理输入事件</h3><p>前面<code>SystemServer</code>的1、2、3步都完成后，会往下执行</p>
<pre><code>    //4. 启动inputflinger，处理输入事件
          t.traceBegin(&quot;StartInputManager&quot;);
          //ims也注册wms的回调，用于通知wms一些事件发生
          inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());
          inputManager.start();  //启动ims，开始处理输入事件
          t.traceEnd();
</code></pre>
<h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java</p>
<pre><code>    public void start() &#123;
        Slog.i(TAG, &quot;Starting input manager&quot;);
        mNative.start();  //到native中的方法

        // Add ourselves to the Watchdog monitors.
        Watchdog.getInstance().addMonitor(this); //加入Watchdog的检测列表中

        //一系列对settings中开关的状态值监听
        ...
    &#125;
</code></pre>
<h4 id="nativeStart"><a href="#nativeStart" class="headerlink" title="nativeStart"></a>nativeStart</h4><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;com_android_server_input_InputManagerService.cpp</p>
<pre><code>static void nativeStart(JNIEnv* env, jobject nativeImplObj) &#123;
    NativeInputManager* im = getNativeInputManager(env, nativeImplObj);
    
    status_t result = im-&gt;getInputManager()-&gt;start();
&#125;
</code></pre>
<h4 id="InputManager-start"><a href="#InputManager-start" class="headerlink" title="InputManager::start()"></a>InputManager::start()</h4><pre><code>status_t InputManager::start() &#123;
    status_t result = mDispatcher-&gt;start();
    result = mReader-&gt;start();

    return OK;
&#125;
</code></pre>
<p>分别调用<code>inputDispatcher</code>和<code>inputReader</code>的<code>start</code>方法</p>
<h4 id="InputDispatcher-start"><a href="#InputDispatcher-start" class="headerlink" title="InputDispatcher::start()"></a>InputDispatcher::start()</h4><pre><code>//InputManager.cpp
status_t InputDispatcher::start() &#123;

    //创建线程InputDispatcher，线程体函数dispatchOnce(), 线程唤醒函数mLooper-&gt;wake()
    mThread = std::make_unique&lt;InputThread&gt;(
            &quot;InputDispatcher&quot;, [this]() &#123; dispatchOnce(); &#125;, [this]() &#123; mLooper-&gt;wake(); &#125;);
    return OK;
&#125;
</code></pre>
<p><code>InputThread</code>继承与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Thead&spm=1001.2101.3001.7020">Thead</a>类<br>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputThread.cpp</p>
<pre><code>InputThread::InputThread(std::string name, std::function&lt;void()&gt; loop, std::function&lt;void()&gt; wake)
      : mName(name), mThreadWake(wake) &#123;
    mThread = new InputThreadImpl(loop);
    mThread-&gt;run(mName.c_str(), ANDROID_PRIORITY_URGENT_DISPLAY);  //启动线程，线程优先级很高
&#125;
        
class InputThreadImpl : public Thread &#123;
public:
    explicit InputThreadImpl(std::function&lt;void()&gt; loop)
          : Thread(/* canCallJava */ true), mThreadLoop(loop) &#123;&#125;

    ~InputThreadImpl() &#123;&#125;

private:
    std::function&lt;void()&gt; mThreadLoop;

    bool threadLoop() override &#123;
        mThreadLoop();
        return true;
    &#125;
&#125;;
</code></pre>
<p>创建一个线程，用于分发事件，线程执行体<code>dispatchOnce()</code></p>
<pre><code>void InputDispatcher::dispatchOnce() &#123;
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    &#123; // acquire lock
        std::scoped_lock _l(mLock);
        mDispatcherIsAlive.notify_all();

        // Run a dispatch loop if there are no pending commands.
        // The dispatch loop might enqueue commands to run afterwards.
        if (!haveCommandsLocked()) &#123;
            dispatchOnceInnerLocked(&amp;nextWakeupTime);  //处理事件的分发
        &#125;

        // Run all pending commands if there are any.
        // If any commands were run then force the next poll to wake up immediately.
        if (runCommandsLockedInterruptable()) &#123;  //处理命令队列中的命令
            nextWakeupTime = LONG_LONG_MIN;
        &#125;

        // If we are still waiting for ack on some events,
        // we might have to wake up earlier to check if an app is anr&#39;ing.
        const nsecs_t nextAnrCheck = processAnrsLocked();  //处理input ANR相关
        nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck);

        // We are about to enter an infinitely long sleep, because we have no commands or
        // pending or queued events
        if (nextWakeupTime == LONG_LONG_MAX) &#123;
            mDispatcherEnteredIdle.notify_all();  //线程进入idle状态
        &#125;
    &#125; // release lock

    // Wait for callback or timeout or wake.  (make sure we round up, not down)
    nsecs_t currentTime = now();
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&gt;pollOnce(timeoutMillis);  //再次进入阻塞等待中
&#125;
</code></pre>
<h4 id="InputReader-start"><a href="#InputReader-start" class="headerlink" title="InputReader::start()"></a>InputReader::start()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputReader::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程InputReader，线程体函数loopOnce(), 线程唤醒函数mEventHub-&gt;wake()（调用EventHub的wake方法来唤醒）</span></span><br><span class="line">    mThread = std::<span class="built_in">make_unique</span>&lt;InputThread&gt;(</span><br><span class="line">            <span class="string">&quot;InputReader&quot;</span>, [<span class="keyword">this</span>]() &#123; <span class="built_in">loopOnce</span>(); &#125;, [<span class="keyword">this</span>]() &#123; mEventHub-&gt;<span class="built_in">wake</span>(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="type">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="type">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    std::vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//调用EventHub的getEvents获取输入事件</span></span><br><span class="line">    <span class="type">size_t</span> count = mEventHub-&gt;<span class="built_in">getEvents</span>(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        mReaderIsAliveCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            <span class="built_in">processEventsLocked</span>(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= mNextTimeout) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_RAW_EVENTS) &#123;</span><br><span class="line">                    <span class="built_in">ALOGD</span>(<span class="string">&quot;Timeout expired, latency=%0.3fms&quot;</span>, (now - mNextTimeout) * <span class="number">0.000001f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mNextTimeout = LLONG_MAX;</span><br><span class="line">                <span class="built_in">timeoutExpiredLocked</span>(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldGeneration != mGeneration) &#123;</span><br><span class="line">            inputDevicesChanged = <span class="literal">true</span>;</span><br><span class="line">            inputDevices = <span class="built_in">getInputDevicesLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send out a message that the describes the changed input devices.</span></span><br><span class="line">    <span class="comment">//如果输入设备有变化，通知其他服务</span></span><br><span class="line">    <span class="keyword">if</span> (inputDevicesChanged) &#123;</span><br><span class="line">        mPolicy-&gt;<span class="built_in">notifyInputDevicesChanged</span>(inputDevices);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueuedListener.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程在循环从<code>mEventHub-&gt;getEvents</code>获取输入事件（这个方法会引起阻塞），如果获取到事件，EventHub会唤醒此线程，返回后会刷新<code>mQueuedListener</code>的事件队列, 唤醒<code>InputDispatcher</code>线程来消费。<br>到这里inputflinger的启动就完成，开始正常等待输入事件的上报并处理。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/InPutManagerService/3.InputReader事件处理" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/">InPutManagerService</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>####回顾</p>
<p>从前面的InputFlinger的启动可知，InputReader线程启动后会循环执行loopOnce()方法，然后阻塞在<code>getEvents</code>等待事件的上报，这里就从loopOnce获取到事件被唤醒后来分析InputReader对事件的处理。</p>
<h4 id="InputReader-loopOnce"><a href="#InputReader-loopOnce" class="headerlink" title="InputReader::loopOnce()"></a>InputReader::loopOnce()</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputReader.cpp</p>
<pre><code>void InputReader::loopOnce() &#123;
    int32_t oldGeneration;
    int32_t timeoutMillis;
    bool inputDevicesChanged = false;
    std::vector&lt;InputDeviceInfo&gt; inputDevices;
    
    ...
    //从EventHub中读取事件
    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);
        
    &#123; // acquire lock
        ...
        if (count) &#123;
            //处理事件
            processEventsLocked(mEventBuffer, count);
        &#125;
        ...
        
    &#125; // release lock

    // Send out a message that the describes the changed input devices.
    //如果输入设备状态改变则通过回调通知java层
    if (inputDevicesChanged) &#123;
        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);
    &#125;

    // Flush queued events out to the listener.
    mQueuedListener.flush();
&#125;
</code></pre>
<h3 id="一、处理事件"><a href="#一、处理事件" class="headerlink" title="一、处理事件"></a>一、处理事件</h3><h4 id="InputReader-processEventsLocked"><a href="#InputReader-processEventsLocked" class="headerlink" title="InputReader::processEventsLocked"></a>InputReader::processEventsLocked</h4><pre><code>void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123;
    for (const RawEvent* rawEvent = rawEvents; count;) &#123;
        int32_t type = rawEvent-&gt;type;
        size_t batchSize = 1;
        //除了设备添加、移除、结束扫描事件之外的普通事件采用批处理方式方式处理
        if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;
            int32_t deviceId = rawEvent-&gt;deviceId;
            while (batchSize &lt; count) &#123;
                //如果出现不符合批处理的事件（一般上面的判断已经足够）则退出本次事件流程
                if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT ||
                    rawEvent[batchSize].deviceId != deviceId) &#123;
                    break;
                &#125;
                batchSize += 1;
            &#125;
            //处理普通事件（批量处理）
            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);
        &#125; else &#123;
            switch (rawEvent-&gt;type) &#123;
                //如果是设备添加事件
                case EventHubInterface::DEVICE_ADDED:
                    //添加设备主要就是创建设备对应的inputDevice
                    //通过设备的class类型创建对应的mapper
                    //将对应的mapper和EventHub、inputReader关联（InputDeviceContext）
                    //然后将对应的deviceId、mapper、InputDeviceContext加入inputDevice容器中
                    addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);
                    break;
                //如果是设备移除事件
                case EventHubInterface::DEVICE_REMOVED:
                    removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);
                    break;
                //如果是设备结束扫描事件
                case EventHubInterface::FINISHED_DEVICE_SCAN:
                    handleConfigurationChangedLocked(rawEvent-&gt;when);
                    break;
                default:
                    ALOG_ASSERT(false); // can&#39;t happen
                    break;
            &#125;
        &#125;
        count -= batchSize;
        rawEvent += batchSize;
    &#125;
&#125;
</code></pre>
<h4 id="InputReader-processEventsForDeviceLocked"><a href="#InputReader-processEventsForDeviceLocked" class="headerlink" title="InputReader::processEventsForDeviceLocked"></a>InputReader::processEventsForDeviceLocked</h4><pre><code>void InputReader::processEventsForDeviceLocked(int32_t eventHubId, const RawEvent* rawEvents,
                                               size_t count) &#123;
    auto deviceIt = mDevices.find(eventHubId);  //通过device id找到事件对应的inputDevice对象
    ...
    device-&gt;process(rawEvents, count);  //调用事件对应的inputDevice对象process处理当前事件
&#125;
</code></pre>
<h4 id="InputDevice-process"><a href="#InputDevice-process" class="headerlink" title="InputDevice::process"></a>InputDevice::process</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputDevice.cpp</p>
<pre><code>void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123;
    //按顺序分发给对应的mapper处理，要求事件按照时间顺序处理
    for (const RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) &#123;

        if (mDropUntilNextSync) &#123;  //抛弃下一个SYN事件前的所有事件
            ...
        &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;
            ...
        &#125; else &#123;  //正常走这里
            //通过deviceId查询mDevices中对应的mapper（这个是在设备add事件时添加的）
            for_each_mapper_in_subdevice(rawEvent-&gt;deviceId, [rawEvent](InputMapper&amp; mapper) &#123;
                mapper.process(rawEvent);
            &#125;);
        &#125;
        --count;
    &#125;
&#125;
</code></pre>
<h4 id="for-each-mapper-in-subdevice"><a href="#for-each-mapper-in-subdevice" class="headerlink" title="for_each_mapper_in_subdevice"></a>for_each_mapper_in_subdevice</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;include&#x2F;InputDevice.h</p>
<pre><code>    // run a function against every mapper on a specific subdevice
    inline void for_each_mapper_in_subdevice(int32_t eventHubDevice,
                                             std::function&lt;void(InputMapper&amp;)&gt; f) &#123;
        auto deviceIt = mDevices.find(eventHubDevice);
        if (deviceIt != mDevices.end()) &#123;
            auto&amp; devicePair = deviceIt-&gt;second;
            auto&amp; mappers = devicePair.second;
            for (auto&amp; mapperPtr : mappers) &#123;
                f(*mapperPtr);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>通过<code>rawEvent-&gt;deviceId</code>来查询这个事件对应的设备在<code>设备add事件</code>时添加的<code>mapper</code>，这个<code>mapper</code>是根据<code>device</code>的<code>class类型</code>来决定的</p>
<h4 id="MultiTouchInputMapper-process"><a href="#MultiTouchInputMapper-process" class="headerlink" title="MultiTouchInputMapper::process"></a>MultiTouchInputMapper::process</h4><p>在<code>InputReader::addDeviceLocked</code>中可以知道触摸现在走的是<code>MultiTouchInputMapper</code><br>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;mapper&#x2F;MultiTouchInputMapper.cpp</p>
<pre><code>void MultiTouchInputMapper::process(const RawEvent* rawEvent) &#123;
    TouchInputMapper::process(rawEvent);
    //处理常规触摸EV_ABS事件，包括多指情况（多个slot）
    mMultiTouchMotionAccumulator.process(rawEvent);
&#125;

void TouchInputMapper::process(const RawEvent* rawEvent) &#123;
    mCursorButtonAccumulator.process(rawEvent);  //如果是光标按键事件，一般不是
    mCursorScrollAccumulator.process(rawEvent);  //如果是光标滚动事件，一般不是
    mTouchButtonAccumulator.process(rawEvent);   //如果是触摸按键事件，（手写笔有时有）

    //只有当收到一次EV_SYN事件上上报本次触摸的事件集
    if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;
        sync(rawEvent-&gt;when, rawEvent-&gt;readTime);
    &#125;
&#125;
    
void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) &#123;
    if (rawEvent-&gt;type == EV_ABS) &#123;
        bool newSlot = false;
        if (mUsingSlotsProtocol) &#123;  //如果支持多指触摸协议
            if (rawEvent-&gt;code == ABS_MT_SLOT) &#123;
                mCurrentSlot = rawEvent-&gt;value;
                newSlot = true;
            &#125;
        &#125; else if (mCurrentSlot &lt; 0) &#123;
            mCurrentSlot = 0;
        &#125;

        if (mCurrentSlot &lt; 0 || size_t(mCurrentSlot) &gt;= mSlotCount) &#123;
            ...
        &#125; else &#123;
            Slot* slot = &amp;mSlots[mCurrentSlot];
            // If mUsingSlotsProtocol is true, it means the raw pointer has axis info of
            // ABS_MT_TRACKING_ID and ABS_MT_SLOT, so driver should send a valid trackingId while
            // updating the slot.
            //如果支持多指触摸协议，那么驱动就需要上报有效的trackingId来给上层区分
            if (!mUsingSlotsProtocol) &#123;
                slot-&gt;mInUse = true;
            &#125;
            //根据事件的code来更新slot的信息
            switch (rawEvent-&gt;code) &#123;
                case ABS_MT_POSITION_X:
                    slot-&gt;mAbsMTPositionX = rawEvent-&gt;value;
                    warnIfNotInUse(*rawEvent, *slot);
                    break;
                case ABS_MT_POSITION_Y:
                    slot-&gt;mAbsMTPositionY = rawEvent-&gt;value;
                    warnIfNotInUse(*rawEvent, *slot);
                    break;
                case ABS_MT_TOUCH_MAJOR:
                    slot-&gt;mAbsMTTouchMajor = rawEvent-&gt;value;
                    break;
                case ABS_MT_TOUCH_MINOR:
                    slot-&gt;mAbsMTTouchMinor = rawEvent-&gt;value;
                    slot-&gt;mHaveAbsMTTouchMinor = true;
                    break;
                case ABS_MT_WIDTH_MAJOR:
                    slot-&gt;mAbsMTWidthMajor = rawEvent-&gt;value;
                    break;
                case ABS_MT_WIDTH_MINOR:
                    slot-&gt;mAbsMTWidthMinor = rawEvent-&gt;value;
                    slot-&gt;mHaveAbsMTWidthMinor = true;
                    break;
                case ABS_MT_ORIENTATION:
                    slot-&gt;mAbsMTOrientation = rawEvent-&gt;value;
                    break;
                case ABS_MT_TRACKING_ID:
                    if (mUsingSlotsProtocol &amp;&amp; rawEvent-&gt;value &lt; 0) &#123;
                        // The slot is no longer in use but it retains its previous contents,
                        // which may be reused for subsequent touches.
                        slot-&gt;mInUse = false;
                    &#125; else &#123;
                        slot-&gt;mInUse = true;
                        slot-&gt;mAbsMTTrackingId = rawEvent-&gt;value;
                    &#125;
                    break;
                case ABS_MT_PRESSURE:
                    slot-&gt;mAbsMTPressure = rawEvent-&gt;value;
                    break;
                case ABS_MT_DISTANCE:
                    slot-&gt;mAbsMTDistance = rawEvent-&gt;value;
                    break;
                case ABS_MT_TOOL_TYPE:
                    slot-&gt;mAbsMTToolType = rawEvent-&gt;value;
                    slot-&gt;mHaveAbsMTToolType = true;
                    break;
            &#125;
        &#125;
    &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_MT_REPORT) &#123;
        // MultiTouch Sync: The driver has returned all data for *one* of the pointers.
        mCurrentSlot += 1;
    &#125;
&#125;
</code></pre>
<h4 id="TouchInputMapper-sync"><a href="#TouchInputMapper-sync" class="headerlink" title="TouchInputMapper::sync"></a>TouchInputMapper::sync</h4><pre><code>void TouchInputMapper::sync(nsecs_t when, nsecs_t readTime) &#123;
    //创建一个RawState并加入mRawStatesPending列表
    // Push a new state.
    mRawStatesPending.emplace_back();
    //初始化上面的RawState, 将相关的各个mapper.process()中记录的事件的属性写入（sync）
    RawState&amp; next = mRawStatesPending.back();
    next.clear();
    next.when = when;
    next.readTime = readTime;
    ...
    // Sync touch
    //同步触摸的状态，这里是调用子类MultiTouchInputMapper的实现，将子类的process中赋值的多指触摸相关属性赋值给next
    syncTouch(when, &amp;next);

    // The last RawState is the actually second to last, since we just added a new state
    const RawState&amp; last =
            mRawStatesPending.size() == 1 ? mCurrentRawState : mRawStatesPending.rbegin()[1];

    ...

    processRawTouches(false /*timeout*/);
&#125;
</code></pre>
<h4 id="TouchInputMapper-processRawTouches"><a href="#TouchInputMapper-processRawTouches" class="headerlink" title="TouchInputMapper::processRawTouches"></a>TouchInputMapper::processRawTouches</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;mapper&#x2F;TouchInputMapper.cpp</p>
<pre><code>void TouchInputMapper::processRawTouches(bool timeout) &#123;
    //如果当前事件的设备被禁用，则中断这个触摸事件集的传递
    if (mDeviceMode == DeviceMode::DISABLED) &#123;
        // Drop all input if the device is disabled.
        cancelTouch(mCurrentRawState.when, mCurrentRawState.readTime);
        mCurrentCookedState.clear();
        updateTouchSpots();
        return;
    &#125;

    // Drain any pending touch states. The invariant here is that the mCurrentRawState is always
    // valid and must go through the full cook and dispatch cycle. This ensures that anything
    // touching the current state will only observe the events that have been dispatched to the
    // rest of the pipeline.
    const size_t N = mRawStatesPending.size();
    size_t count;
    for (count = 0; count &lt; N; count++) &#123;
        const RawState&amp; next = mRawStatesPending[count];

        // A failure to assign the stylus id means that we&#39;re waiting on stylus data
        // and so should defer the rest of the pipeline.
        //检测手写笔id是否可以获取到，如果无法获取就中断本次触摸批事件处理
        if (assignExternalStylusId(next, timeout)) &#123;
            break;
        &#125;

        // All ready to go.
        clearStylusDataPendingFlags();  //移除手写笔状态相关变量
        mCurrentRawState.copyFrom(next);  //将next赋给mCurrentRawState
        ...
        cookAndDispatch(mCurrentRawState.when, mCurrentRawState.readTime);
    &#125;
    if (count != 0) &#123;
        //从mRawStatesPending移除本次已处理的RawState，一个RawState对应一次SYNC包含的触摸事件集
        mRawStatesPending.erase(mRawStatesPending.begin(), mRawStatesPending.begin() + count);
    &#125;
    ...
&#125;
</code></pre>
<h4 id="TouchInputMapper-cookAndDispatch"><a href="#TouchInputMapper-cookAndDispatch" class="headerlink" title="TouchInputMapper::cookAndDispatch"></a>TouchInputMapper::cookAndDispatch</h4><pre><code>void TouchInputMapper::cookAndDispatch(nsecs_t when, nsecs_t readTime) &#123;
    // Always start with a clean state.
    mCurrentCookedState.clear();

    // Apply stylus buttons to current raw state.
    applyExternalStylusButtonState(when);  //处理手写笔按键状态

    // Handle policy on initial down or hover events.
    bool initialDown = mLastRawState.rawPointerData.pointerCount == 0 &amp;&amp;
            mCurrentRawState.rawPointerData.pointerCount != 0;

    uint32_t policyFlags = 0;
    bool buttonsPressed = mCurrentRawState.buttonState &amp; ~mLastRawState.buttonState;
    if (initialDown || buttonsPressed) &#123;
        // If this is a touch screen, hide the pointer on an initial down.
        if (mDeviceMode == DeviceMode::DIRECT) &#123;
            getContext()-&gt;fadePointer();
        &#125;

        if (mParameters.wake) &#123;
            policyFlags |= POLICY_FLAG_WAKE;
        &#125;
    &#125;

    // Consume raw off-screen touches before cooking pointer data.
    // If touches are consumed, subsequent code will not receive any pointer data.
    //处理一些非屏幕区域的触摸行为，比如屏幕外的虚拟按键等，
    //如果本次触摸是虚拟按键，那么本次触摸事件将会被虚拟按键逻辑消费，不在往下处理
    if (consumeRawTouches(when, readTime, policyFlags)) &#123;
        mCurrentRawState.rawPointerData.clear();
    &#125;

    // Cook pointer data.  This call populates the mCurrentCookedState.cookedPointerData structure
    // with cooked pointer data that has the same ids and indices as the raw data.
    // The following code can use either the raw or cooked data, as needed.
    //这里就是将触摸设备(TP)的坐标范围映射到实际屏幕的坐标范围等（常识：TP的坐标不一定和屏幕的坐标对应，所以需要转化）
    cookPointerData();
    
    // Apply stylus pressure to current cooked state.
    applyExternalStylusTouchState(when);  处理手写笔触摸状态

    // Synthesize key down from raw buttons if needed.
    // 如果上面有处理触摸按键相关的事件，在这里会进行按键事件的分发，走按键分发逻辑（notifyKey）
    synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_DOWN, when, readTime, getDeviceId(),
                         mSource, mViewport.displayId, policyFlags, mLastCookedState.buttonState,
                         mCurrentCookedState.buttonState);

    // Dispatch the touches either directly or by translation through a pointer on screen.
    if (mDeviceMode == DeviceMode::POINTER) &#123;  //pointer光标
        ...
    &#125; else &#123;  //触摸 DeviceMode::DIRECT touchscreen
        if (!mCurrentMotionAborted) &#123;
            updateTouchSpots();  //更新触摸点相关
            dispatchButtonRelease(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理
            dispatchHoverExit(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理
            dispatchTouches(when, readTime, policyFlags);  // 分发触摸事件，主要是这里
            dispatchHoverEnterAndMove(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理
            dispatchButtonPress(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理
        &#125;

        if (mCurrentCookedState.cookedPointerData.pointerCount == 0) &#123;
            mCurrentMotionAborted = false;
        &#125;
    &#125;

    // Synthesize key up from raw buttons if needed.
    synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_UP, when, readTime, getDeviceId(), mSource,
                         mViewport.displayId, policyFlags, mLastCookedState.buttonState,
                         mCurrentCookedState.buttonState);
        
    // Clear some transient state.
    mCurrentRawState.rawVScroll = 0;
    mCurrentRawState.rawHScroll = 0;

    // Copy current touch to last touch in preparation for the next cycle.
    mLastRawState.copyFrom(mCurrentRawState);
    mLastCookedState.copyFrom(mCurrentCookedState);
&#125;
</code></pre>
<h4 id="TouchInputMapper-cookPointerData"><a href="#TouchInputMapper-cookPointerData" class="headerlink" title="TouchInputMapper::cookPointerData"></a>TouchInputMapper::cookPointerData</h4><pre><code>void TouchInputMapper::cookPointerData() &#123;
    uint32_t currentPointerCount = mCurrentRawState.rawPointerData.pointerCount;
    
    mCurrentCookedState.cookedPointerData.clear();
    mCurrentCookedState.cookedPointerData.pointerCount = currentPointerCount;
    mCurrentCookedState.cookedPointerData.hoveringIdBits =
            mCurrentRawState.rawPointerData.hoveringIdBits;
    mCurrentCookedState.cookedPointerData.touchingIdBits =
            mCurrentRawState.rawPointerData.touchingIdBits;
    mCurrentCookedState.cookedPointerData.canceledIdBits =
            mCurrentRawState.rawPointerData.canceledIdBits;

    if (mCurrentCookedState.cookedPointerData.pointerCount == 0) &#123;
        mCurrentCookedState.buttonState = 0;
    &#125; else &#123;
        mCurrentCookedState.buttonState = mCurrentRawState.buttonState;
    &#125;


    // Walk through the the active pointers and map device coordinates onto
    // display coordinates and adjust for display orientation.
    // 遍历活动指针并将设备坐标映射到显示坐标并调整显示方向。
    // 并将相关的转化值写入mCurrentCookedState.cookedPointerData
    for (uint32_t i = 0; i &lt; currentPointerCount; i++) &#123;
        const RawPointerData::Pointer&amp; in = mCurrentRawState.rawPointerData.pointers[i];

        // Size
        // 长短轴大小校准
        float touchMajor, touchMinor, toolMajor, toolMinor, size;
        switch (mCalibration.sizeCalibration) &#123;
            case Calibration::SizeCalibration::GEOMETRIC:  //几何类型
            case Calibration::SizeCalibration::DIAMETER:  //直径类型
            case Calibration::SizeCalibration::BOX:  // 方型？
            case Calibration::SizeCalibration::AREA:  //面积类型？
                if (mRawPointerAxes.touchMajor.valid &amp;&amp; mRawPointerAxes.toolMajor.valid) &#123;
                    touchMajor = in.touchMajor;
                    touchMinor = mRawPointerAxes.touchMinor.valid ? in.touchMinor : in.touchMajor;
                    toolMajor = in.toolMajor;
                    toolMinor = mRawPointerAxes.toolMinor.valid ? in.toolMinor : in.toolMajor;
                    size = mRawPointerAxes.touchMinor.valid ? avg(in.touchMajor, in.touchMinor)
                                                            : in.touchMajor;
                &#125; else if (mRawPointerAxes.touchMajor.valid) &#123;
                    toolMajor = touchMajor = in.touchMajor;
                    toolMinor = touchMinor =
                            mRawPointerAxes.touchMinor.valid ? in.touchMinor : in.touchMajor;
                    size = mRawPointerAxes.touchMinor.valid ? avg(in.touchMajor, in.touchMinor)
                                                            : in.touchMajor;
                &#125; else if (mRawPointerAxes.toolMajor.valid) &#123;
                    touchMajor = toolMajor = in.toolMajor;
                    touchMinor = toolMinor =
                            mRawPointerAxes.toolMinor.valid ? in.toolMinor : in.toolMajor;
                    size = mRawPointerAxes.toolMinor.valid ? avg(in.toolMajor, in.toolMinor)
                                                           : in.toolMajor;
                &#125; else &#123;
                    ...
                &#125;

                if (mCalibration.haveSizeIsSummed &amp;&amp; mCalibration.sizeIsSummed) &#123;
                    uint32_t touchingCount = mCurrentRawState.rawPointerData.touchingIdBits.count();
                    if (touchingCount &gt; 1) &#123;
                        touchMajor /= touchingCount;
                        touchMinor /= touchingCount;
                        toolMajor /= touchingCount;
                        toolMinor /= touchingCount;
                        size /= touchingCount;
                    &#125;
                &#125;

                if (mCalibration.sizeCalibration == Calibration::SizeCalibration::GEOMETRIC) &#123;
                    touchMajor *= mGeometricScale;
                    touchMinor *= mGeometricScale;
                    toolMajor *= mGeometricScale;
                    toolMinor *= mGeometricScale;
                &#125; else if (mCalibration.sizeCalibration == Calibration::SizeCalibration::AREA) &#123;
                    touchMajor = touchMajor &gt; 0 ? sqrtf(touchMajor) : 0;
                    touchMinor = touchMajor;
                    toolMajor = toolMajor &gt; 0 ? sqrtf(toolMajor) : 0;
                    toolMinor = toolMajor;
                &#125; else if (mCalibration.sizeCalibration == Calibration::SizeCalibration::DIAMETER) &#123;
                    touchMinor = touchMajor;
                    toolMinor = toolMajor;
                &#125;

                mCalibration.applySizeScaleAndBias(&amp;touchMajor);
                mCalibration.applySizeScaleAndBias(&amp;touchMinor);
                mCalibration.applySizeScaleAndBias(&amp;toolMajor);
                mCalibration.applySizeScaleAndBias(&amp;toolMinor);
                size *= mSizeScale;
                break;
            default:
                touchMajor = 0;
                touchMinor = 0;
                toolMajor = 0;
                toolMinor = 0;
                size = 0;
                break;
        &#125;

        // Pressure
        //压感校准
        float pressure;
        switch (mCalibration.pressureCalibration) &#123;
            case Calibration::PressureCalibration::PHYSICAL:
            case Calibration::PressureCalibration::AMPLITUDE:
                pressure = in.pressure * mPressureScale;
                break;
            default:
                pressure = in.isHovering ? 0 : 1;
                break;
        &#125;

        // Tilt and Orientation
        //倾斜角度和方向
        float tilt;
        float orientation;
        if (mHaveTilt) &#123;
            float tiltXAngle = (in.tiltX - mTiltXCenter) * mTiltXScale;
            float tiltYAngle = (in.tiltY - mTiltYCenter) * mTiltYScale;
            orientation = atan2f(-sinf(tiltXAngle), sinf(tiltYAngle));
            tilt = acosf(cosf(tiltXAngle) * cosf(tiltYAngle));
        &#125; else &#123;
            tilt = 0;

            switch (mCalibration.orientationCalibration) &#123;
                case Calibration::OrientationCalibration::INTERPOLATED:
                    orientation = in.orientation * mOrientationScale;
                    break;
                case Calibration::OrientationCalibration::VECTOR: &#123;
                    int32_t c1 = signExtendNybble((in.orientation &amp; 0xf0) &gt;&gt; 4);
                    int32_t c2 = signExtendNybble(in.orientation &amp; 0x0f);
                    if (c1 != 0 || c2 != 0) &#123;
                        orientation = atan2f(c1, c2) * 0.5f;
                        float confidence = hypotf(c1, c2);
                        float scale = 1.0f + confidence / 16.0f;
                        touchMajor *= scale;
                        touchMinor /= scale;
                        toolMajor *= scale;
                        toolMinor /= scale;
                    &#125; else &#123;
                        orientation = 0;
                    &#125;
                    break;
                &#125;
                default:
                    orientation = 0;
            &#125;
        &#125;

        // Distance
        //距离校准
        float distance;
        switch (mCalibration.distanceCalibration) &#123;
            case Calibration::DistanceCalibration::SCALED:
                distance = in.distance * mDistanceScale;
                break;
            default:
                distance = 0;
        &#125;

        // Coverage
        // 覆盖校准？
        int32_t rawLeft, rawTop, rawRight, rawBottom;
        switch (mCalibration.coverageCalibration) &#123;
            case Calibration::CoverageCalibration::BOX:
                rawLeft = (in.toolMinor &amp; 0xffff0000) &gt;&gt; 16;
                rawRight = in.toolMinor &amp; 0x0000ffff;
                rawBottom = in.toolMajor &amp; 0x0000ffff;
                rawTop = (in.toolMajor &amp; 0xffff0000) &gt;&gt; 16;
                break;
            default:
                rawLeft = rawTop = rawRight = rawBottom = 0;
                break;
        &#125;

        // Adjust X,Y coords for device calibration
        // TODO: Adjust coverage coords?
        float xTransformed = in.x, yTransformed = in.y;
        mAffineTransform.applyTo(xTransformed, yTransformed);
        rotateAndScale(xTransformed, yTransformed);

        // Adjust X, Y, and coverage coords for input device orientation.
        float left, top, right, bottom;
        // 转换触摸设备坐标到实际的屏幕方向上的坐标
        switch (mInputDeviceOrientation) &#123;
            case DISPLAY_ORIENTATION_90:
                left = float(rawTop - mRawPointerAxes.y.minValue) * mYScale;
                right = float(rawBottom - mRawPointerAxes.y.minValue) * mYScale;
                bottom = float(mRawPointerAxes.x.maxValue - rawLeft) * mXScale;
                top = float(mRawPointerAxes.x.maxValue - rawRight) * mXScale;
                orientation -= M_PI_2;
                if (mOrientedRanges.haveOrientation &amp;&amp;
                    orientation &lt; mOrientedRanges.orientation.min) &#123;
                    orientation +=
                            (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min);
                &#125;
                break;
            case DISPLAY_ORIENTATION_180:
                left = float(mRawPointerAxes.x.maxValue - rawRight) * mXScale;
                right = float(mRawPointerAxes.x.maxValue - rawLeft) * mXScale;
                bottom = float(mRawPointerAxes.y.maxValue - rawTop) * mYScale;
                top = float(mRawPointerAxes.y.maxValue - rawBottom) * mYScale;
                orientation -= M_PI;
                if (mOrientedRanges.haveOrientation &amp;&amp;
                    orientation &lt; mOrientedRanges.orientation.min) &#123;
                    orientation +=
                            (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min);
                &#125;
                break;
            case DISPLAY_ORIENTATION_270:
                left = float(mRawPointerAxes.y.maxValue - rawBottom) * mYScale;
                right = float(mRawPointerAxes.y.maxValue - rawTop) * mYScale;
                bottom = float(rawRight - mRawPointerAxes.x.minValue) * mXScale;
                top = float(rawLeft - mRawPointerAxes.x.minValue) * mXScale;
                orientation += M_PI_2;
                if (mOrientedRanges.haveOrientation &amp;&amp;
                    orientation &gt; mOrientedRanges.orientation.max) &#123;
                    orientation -=
                            (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min);
                &#125;
                break;
            default:
                left = float(rawLeft - mRawPointerAxes.x.minValue) * mXScale;
                right = float(rawRight - mRawPointerAxes.x.minValue) * mXScale;
                bottom = float(rawBottom - mRawPointerAxes.y.minValue) * mYScale;
                top = float(rawTop - mRawPointerAxes.y.minValue) * mYScale;
                break;
        &#125;

        // Write output coords.
        PointerCoords&amp; out = mCurrentCookedState.cookedPointerData.pointerCoords[i];
        out.clear();
        out.setAxisValue(AMOTION_EVENT_AXIS_X, xTransformed);
        out.setAxisValue(AMOTION_EVENT_AXIS_Y, yTransformed);
        out.setAxisValue(AMOTION_EVENT_AXIS_PRESSURE, pressure);
        out.setAxisValue(AMOTION_EVENT_AXIS_SIZE, size);
        out.setAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR, touchMajor);
        out.setAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR, touchMinor);
        out.setAxisValue(AMOTION_EVENT_AXIS_ORIENTATION, orientation);
        out.setAxisValue(AMOTION_EVENT_AXIS_TILT, tilt);
        out.setAxisValue(AMOTION_EVENT_AXIS_DISTANCE, distance);
        if (mCalibration.coverageCalibration == Calibration::CoverageCalibration::BOX) &#123;
            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_1, left);
            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_2, top);
            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_3, right);
            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_4, bottom);
        &#125; else &#123;
            out.setAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR, toolMajor);
            out.setAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR, toolMinor);
        &#125;

        // Write output relative fields if applicable.
        uint32_t id = in.id;
        if (mSource == AINPUT_SOURCE_TOUCHPAD &amp;&amp;
            mLastCookedState.cookedPointerData.hasPointerCoordsForId(id)) &#123;
            const PointerCoords&amp; p = mLastCookedState.cookedPointerData.pointerCoordsForId(id);
            float dx = xTransformed - p.getAxisValue(AMOTION_EVENT_AXIS_X);
            float dy = yTransformed - p.getAxisValue(AMOTION_EVENT_AXIS_Y);
            out.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, dx);
            out.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, dy);
        &#125;

        // Write output properties.
        PointerProperties&amp; properties = mCurrentCookedState.cookedPointerData.pointerProperties[i];
        properties.clear();
        properties.id = id;
        properties.toolType = in.toolType;

        // Write id index and mark id as valid.
        mCurrentCookedState.cookedPointerData.idToIndex[id] = i;
        mCurrentCookedState.cookedPointerData.validIdBits.markBit(id);
    &#125;
&#125;
</code></pre>
<h4 id="TouchInputMapper-dispatchTouches"><a href="#TouchInputMapper-dispatchTouches" class="headerlink" title="TouchInputMapper::dispatchTouches"></a>TouchInputMapper::dispatchTouches</h4><pre><code>void TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t readTime, uint32_t policyFlags) &#123;
    BitSet32 currentIdBits = mCurrentCookedState.cookedPointerData.touchingIdBits;
    BitSet32 lastIdBits = mLastCookedState.cookedPointerData.touchingIdBits;
    int32_t metaState = getContext()-&gt;getGlobalMetaState();
    int32_t buttonState = mCurrentCookedState.buttonState;
        
    if (currentIdBits == lastIdBits) &#123;  //pointer id 没有改变
        if (!currentIdBits.isEmpty()) &#123;
            // No pointer id changes so this is a move event.
            // The listener takes care of batching moves so we don&#39;t have to deal with that here.
            // 如果pointer id 没有改变，说明是个move事件，这里不进行处理，直接分发到listener
            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_MOVE, 0, 0,
                           metaState, buttonState, AMOTION_EVENT_EDGE_FLAG_NONE,
                           mCurrentCookedState.cookedPointerData.pointerProperties,
                           mCurrentCookedState.cookedPointerData.pointerCoords,
                           mCurrentCookedState.cookedPointerData.idToIndex, currentIdBits, -1,
                           mOrientedXPrecision, mOrientedYPrecision, mDownTime);
        &#125;
    &#125; else &#123;
        // There may be pointers going up and pointers going down and pointers moving
        // all at the same time.
        // 获取并更新四个方向pointers的值，判断本次是down、up、move的哪一种
        BitSet32 upIdBits(lastIdBits.value &amp; ~currentIdBits.value);
        BitSet32 downIdBits(currentIdBits.value &amp; ~lastIdBits.value);
        BitSet32 moveIdBits(lastIdBits.value &amp; currentIdBits.value);
        BitSet32 dispatchedIdBits(lastIdBits.value);  //用于记录上一次分发的事件

        // Update last coordinates of pointers that have moved so that we observe the new
        // pointer positions at the same time as other pointers that have just gone up.
        //更新最后一个pointers的坐标
        bool moveNeeded =
                updateMovedPointers(mCurrentCookedState.cookedPointerData.pointerProperties,
                                    mCurrentCookedState.cookedPointerData.pointerCoords,
                                    mCurrentCookedState.cookedPointerData.idToIndex,
                                    mLastCookedState.cookedPointerData.pointerProperties,
                                    mLastCookedState.cookedPointerData.pointerCoords,
                                    mLastCookedState.cookedPointerData.idToIndex, moveIdBits);
        if (buttonState != mLastCookedState.buttonState) &#123;
            moveNeeded = true;
        &#125;

        // Dispatch pointer up events.
        //分发up事件
        while (!upIdBits.isEmpty()) &#123;
            uint32_t upId = upIdBits.clearFirstMarkedBit();  //这个id应该和downId相同（看上面的更新四个方向BitSet32可知）
            bool isCanceled = mCurrentCookedState.cookedPointerData.canceledIdBits.hasBit(uplastIdBitsId);
            if (isCanceled) &#123;
                ALOGI(&quot;Canceling pointer %d for the palm event was detected.&quot;, upId);
            &#125;
            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_POINTER_UP, 0,
                           isCanceled ? AMOTION_EVENT_FLAG_CANCELED : 0, metaState, buttonState, 0,
                           mLastCookedState.cookedPointerData.pointerProperties,
                           mLastCookedState.cookedPointerData.pointerCoords,
                           mLastCookedState.cookedPointerData.idToIndex, dispatchedIdBits, upId,
                           mOrientedXPrecision, mOrientedYPrecision, mDownTime);
            dispatchedIdBits.clearBit(upId);  //up事件分发后，重置dispatchedIdBits
            mCurrentCookedState.cookedPointerData.canceledIdBits.clearBit(upId);
        &#125;

        // Dispatch move events if any of the remaining pointers moved from their old locations.
        // Although applications receive new locations as part of individual pointer up
        // events, they do not generally handle them except when presented in a move event.
        //分发move事件
        if (moveNeeded &amp;&amp; !moveIdBits.isEmpty()) &#123;
            ALOG_ASSERT(moveIdBits.value == dispatchedIdBits.value);
            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_MOVE, 0, 0,
                           metaState, buttonState, 0,
                           mCurrentCookedState.cookedPointerData.pointerProperties,
                           mCurrentCookedState.cookedPointerData.pointerCoords,
                           mCurrentCookedState.cookedPointerData.idToIndex, dispatchedIdBits, -1,
                           mOrientedXPrecision, mOrientedYPrecision, mDownTime);
        &#125;

        // Dispatch pointer down events using the new pointer locations.
        //分发down事件
        while (!downIdBits.isEmpty()) &#123;
            uint32_t downId = downIdBits.clearFirstMarkedBit();
            dispatchedIdBits.markBit(downId); //记录分发的down事件

            if (dispatchedIdBits.count() == 1) &#123;
                // First pointer is going down.  Set down time.
                mDownTime = when;
            &#125;

            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_POINTER_DOWN,
                           0, 0, metaState, buttonState, 0,
                           mCurrentCookedState.cookedPointerData.pointerProperties,
                           mCurrentCookedState.cookedPointerData.pointerCoords,
                           mCurrentCookedState.cookedPointerData.idToIndex, dispatchedIdBits,
                           downId, mOrientedXPrecision, mOrientedYPrecision, mDownTime);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="TouchInputMapper-dispatchMotion"><a href="#TouchInputMapper-dispatchMotion" class="headerlink" title="TouchInputMapper::dispatchMotion"></a>TouchInputMapper::dispatchMotion</h4><pre><code>void TouchInputMapper::dispatchMotion(nsecs_t when, nsecs_t readTime, uint32_t policyFlags,
                                      uint32_t source, int32_t action, int32_t actionButton,
                                      int32_t flags, int32_t metaState, int32_t buttonState,
                                      int32_t edgeFlags, const PointerProperties* properties,
                                      const PointerCoords* coords, const uint32_t* idToIndex,
                                      BitSet32 idBits, int32_t changedId, float xPrecision,
                                      float yPrecision, nsecs_t downTime) &#123;
    PointerCoords pointerCoords[MAX_POINTERS];
    PointerProperties pointerProperties[MAX_POINTERS];
    uint32_t pointerCount = 0;
    while (!idBits.isEmpty()) &#123;
        uint32_t id = idBits.clearFirstMarkedBit();
        uint32_t index = idToIndex[id];
        pointerProperties[pointerCount].copyFrom(properties[index]);
        pointerCoords[pointerCount].copyFrom(coords[index]);

        if (changedId &gt;= 0 &amp;&amp; id == uint32_t(changedId)) &#123;
            action |= pointerCount &lt;&lt; AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;
        &#125;

        pointerCount += 1;
    &#125;

    ALOG_ASSERT(pointerCount != 0);

    if (changedId &gt;= 0 &amp;&amp; pointerCount == 1) &#123;
        // Replace initial down and final up action.
        // We can compare the action without masking off the changed pointer index
        // because we know the index is 0.
        if (action == AMOTION_EVENT_ACTION_POINTER_DOWN) &#123;
            action = AMOTION_EVENT_ACTION_DOWN;
        &#125; else if (action == AMOTION_EVENT_ACTION_POINTER_UP) &#123;
            if ((flags &amp; AMOTION_EVENT_FLAG_CANCELED) != 0) &#123;
                action = AMOTION_EVENT_ACTION_CANCEL;
            &#125; else &#123;
                action = AMOTION_EVENT_ACTION_UP;
            &#125;
        &#125; else &#123;
            // Can&#39;t happen.
            ALOG_ASSERT(false);
        &#125;
    &#125;
    float xCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION;
    float yCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION;
    if (mDeviceMode == DeviceMode::POINTER) &#123;  //是否是pointer模式，触摸是DIRECT模式，所以一般不设置这个
        mPointerController-&gt;getPosition(&amp;xCursorPosition, &amp;yCursorPosition);
    &#125;
    //获取当前物理屏幕的id（有些设备有多个屏幕）
    //获取displayId主要从DisplayViewport中，而DisplayViewport主要来自：
    // 1. inputDevice中通过configure中指定。
      // 2. WindowManagerService指定。
      // 3.通过idc文件中的唯一id或显示类型获取匹配的Viewport
    const int32_t displayId = getAssociatedDisplayId().value_or(ADISPLAY_ID_NONE);
    const int32_t deviceId = getDeviceId();
    std::vector&lt;TouchVideoFrame&gt; frames = getDeviceContext().getVideoFrames();  //有关视频触摸事件的，一般不是
    std::for_each(frames.begin(), frames.end(),
                  [this](TouchVideoFrame&amp; frame) &#123; frame.rotate(this-&gt;mInputDeviceOrientation); &#125;);
    //创建NotifyMotionArgs对象
    NotifyMotionArgs args(getContext()-&gt;getNextId(), when, readTime, deviceId, source, displayId,
                          policyFlags, action, actionButton, flags, metaState, buttonState,
                          MotionClassification::NONE, edgeFlags, pointerCount, pointerProperties,
                          pointerCoords, xPrecision, yPrecision, xCursorPosition, yCursorPosition,
                          downTime, std::move(frames));
     // 调用mapper创建时关联的context持有的QueuedInputListener对象的notifyMotion
     // 这里是getListener是UnwantedInteractionBlocker
    getListener().notifyMotion(&amp;args);
&#125;
</code></pre>
<h4 id="QueuedInputListener-notifyMotion"><a href="#QueuedInputListener-notifyMotion" class="headerlink" title="QueuedInputListener::notifyMotion"></a>QueuedInputListener::notifyMotion</h4><pre><code>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;
    ALOGD(&quot;hongxi.zhu: QueuedInputListener::notifyMotion() -&gt; mArgsQueue.emplace_back(NotifyMotionArgs)&quot;);
    traceEvent(__func__, args-&gt;id);
    mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args));
&#125;
</code></pre>
<p><code>QueuedInputListener::notifyMotion</code>只是将<code>NotifyMotionArgs</code>加入当前<code>listener</code>对象的<code>mArgsQueue</code>列表, 到这里我们<code>InputReader::processEventsLocked</code>方法就执行结束，回到<code>loopOnce()</code>中继续往下执行到<code>mQueuedListener.flush()</code>，开始事件的传递。</p>
<h3 id="二、mQueuedListener-flush-事件传递"><a href="#二、mQueuedListener-flush-事件传递" class="headerlink" title="二、mQueuedListener.flush()事件传递"></a>二、mQueuedListener.flush()事件传递</h3><p>接着上面，在<code>InputReader::loopOnce()</code>中往下执行到<code>mQueuedListener.flush()</code></p>
<h4 id="QueuedInputListener-flush"><a href="#QueuedInputListener-flush" class="headerlink" title="QueuedInputListener::flush()"></a>QueuedInputListener::flush()</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputListener.cpp</p>
<pre><code>void QueuedInputListener::flush() &#123;
    for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123;
        args-&gt;notify(mInnerListener);  //args这里是前面传进来的NotifyMotionArgs
    &#125;
    mArgsQueue.clear();
&#125;
</code></pre>
<h4 id="NotifyMotionArgs-notify"><a href="#NotifyMotionArgs-notify" class="headerlink" title="NotifyMotionArgs::notify"></a>NotifyMotionArgs::notify</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputListener.cpp</p>
<pre><code>void NotifyMotionArgs::notify(InputListenerInterface&amp; listener) const &#123;
    listener.notifyMotion(this);
&#125;
</code></pre>
<p>这个<code>listener</code>是一个<code>InputListenerInterface</code>子类对象，到底是哪个呢？回顾下<code>InputManager</code>的构造方法，<br>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputManager.cpp</p>
<pre><code>InputManager::InputManager(
        const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,
        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;
    mDispatcher = createInputDispatcher(dispatcherPolicy);
    mClassifier = std::make_unique&lt;InputClassifier&gt;(*mDispatcher);
    mBlocker = std::make_unique&lt;UnwantedInteractionBlocker&gt;(*mClassifier);
    mReader = createInputReader(readerPolicy, *mBlocker);
&#125;
</code></pre>
<p><code>mDispatcher</code>、<code>mClassifier</code>、<code>mBlocker</code>都是<code>InputListenerInterface</code>的子类，从构造方法的传参得出事件传递的过程：<br><code>InputReader-&gt;UnwantedInteractionBlocker-&gt;InputClassifier-&gt;InputDispatcher</code><br>结合类继承关系，可知上面<code>InputReader::loopOnce()</code>中的<code>mQueuedListener</code>是<code>UnwantedInteractionBlocker</code>，调用它的<code>flush</code>方法(这几个子类都没有实现<code>flush</code>方法，所以执行的是<code>QueuedInputListener</code>的<code>flush</code>方法)，<code>QueuedInputListener</code>中的<code>mInnerListener</code>是<code>UnwantedInteractionBlocker</code>，那么<code>listener.notifyMotion(this)</code>实际就是：<code>UnwantedInteractionBlocker::notifyMotion(NotifyMotionArgs)</code></p>
<h4 id="UnwantedInteractionBlocker-notifyMotion"><a href="#UnwantedInteractionBlocker-notifyMotion" class="headerlink" title="UnwantedInteractionBlocker::notifyMotion"></a>UnwantedInteractionBlocker::notifyMotion</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;UnwantedInteractionBlocker.cpp</p>
<pre><code>void UnwantedInteractionBlocker::notifyMotion(const NotifyMotionArgs* args) &#123;
    &#123; // acquire lock
        std::scoped_lock lock(mLock);
        const std::vector&lt;NotifyMotionArgs&gt; processedArgs =
                mPreferStylusOverTouchBlocker.processMotion(*args);
        for (const NotifyMotionArgs&amp; loopArgs : processedArgs) &#123;
            notifyMotionLocked(&amp;loopArgs);
        &#125;
    &#125; // release lock

    // Call out to the next stage without holding the lock
    mQueuedListener.flush();
&#125;
</code></pre>
<h4 id="UnwantedInteractionBlocker-notifyMotionLocked"><a href="#UnwantedInteractionBlocker-notifyMotionLocked" class="headerlink" title="UnwantedInteractionBlocker::notifyMotionLocked"></a>UnwantedInteractionBlocker::notifyMotionLocked</h4><pre><code>void UnwantedInteractionBlocker::notifyMotionLocked(const NotifyMotionArgs* args) &#123;
    auto it = mPalmRejectors.find(args-&gt;deviceId);
    const bool sendToPalmRejector = it != mPalmRejectors.end() &amp;&amp; isFromTouchscreen(args-&gt;source);
    if (!sendToPalmRejector) &#123;  //如果不支持手掌误触处理，走这里，一般走这里
        //调用UnwantedInteractionBlocker中持有的QueuedListener对象的notifyMotion
        //mQueuedListener这里是
        mQueuedListener.notifyMotion(args);  //一般走这里, 按照前面
        return;
    &#125;
    //如果支持手掌误触
    std::vector&lt;NotifyMotionArgs&gt; processedArgs = it-&gt;second.processMotion(*args);
processedArgs.size());
    for (const NotifyMotionArgs&amp; loopArgs : processedArgs) &#123;
        mQueuedListener.notifyMotion(&amp;loopArgs);  //同理这里的mQueuedListener是InputClassifier
    &#125;
&#125;
</code></pre>
<p>然后又是同样的走法<code>notifyMotion</code>-&gt;<code>flush</code>-&gt;<code>notifyMotion</code>, <code>mInnerListener</code>是<code>InputClassifier</code></p>
<h4 id="QueuedInputListener-notifyMotion-1"><a href="#QueuedInputListener-notifyMotion-1" class="headerlink" title="QueuedInputListener::notifyMotion"></a>QueuedInputListener::notifyMotion</h4><pre><code>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;
    traceEvent(__func__, args-&gt;id);
    mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args));
&#125;

void QueuedInputListener::flush() &#123;
    for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123;
           //args这里是前面传进来的NotifyMotionArgs，mInnerListener是InputClassifier
        args-&gt;notify(mInnerListener);
    &#125;
    mArgsQueue.clear();
&#125;

void NotifyMotionArgs::notify(InputListenerInterface&amp; listener) const &#123;
    listener.notifyMotion(this);
&#125;
</code></pre>
<h4 id="InputClassifier-notifyMotion"><a href="#InputClassifier-notifyMotion" class="headerlink" title="InputClassifier::notifyMotion"></a>InputClassifier::notifyMotion</h4><pre><code>void InputClassifier::notifyMotion(const NotifyMotionArgs* args) &#123;
    &#123; // acquire lock
        std::scoped_lock lock(mLock);
        // MotionClassifier is only used for touch events, for now
        const bool sendToMotionClassifier = mMotionClassifier &amp;&amp; isTouchEvent(*args);
        if (!sendToMotionClassifier) &#123;  //目前模拟器走这里，真机不清楚
            mQueuedListener.notifyMotion(args);
        &#125; else &#123;
            NotifyMotionArgs newArgs(*args);
            newArgs.classification = mMotionClassifier-&gt;classify(newArgs);
            mQueuedListener.notifyMotion(&amp;newArgs);
        &#125;
    &#125; // release lock
    mQueuedListener.flush();
&#125;
</code></pre>
<p>然后又是同样的走法<code>notifyMotion</code>-&gt;<code>flush</code>-&gt;<code>notifyMotion</code>, <code>mInnerListener</code>是<code>InputDispatcher</code></p>
<h4 id="QueuedInputListener-notifyMotion-2"><a href="#QueuedInputListener-notifyMotion-2" class="headerlink" title="QueuedInputListener::notifyMotion"></a>QueuedInputListener::notifyMotion</h4><pre><code>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;
    traceEvent(__func__, args-&gt;id);
    mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args));
&#125;

void QueuedInputListener::flush() &#123;
    for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123;
           //args这里是前面传进来的NotifyMotionArgs，mInnerListener是InputClassifier
        args-&gt;notify(mInnerListener);
    &#125;
    mArgsQueue.clear();
&#125;
</code></pre>
<h4 id="InputDispatcher-notifyMotion"><a href="#InputDispatcher-notifyMotion" class="headerlink" title="InputDispatcher::notifyMotion"></a>InputDispatcher::notifyMotion</h4><pre><code>void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) &#123;
    ...
    uint32_t policyFlags = args-&gt;policyFlags;
    policyFlags |= POLICY_FLAG_TRUSTED;

    android::base::Timer t;
    //回调wms中的interceptMotionBeforeQueueingNonInteractive方法
    mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;displayId, args-&gt;eventTime, /*byref*/ policyFlags);
        
    bool needWake = false;
    &#123; // acquire lock
        mLock.lock();
        ...

        // Just enqueue a new motion event.
        //创建一个MotionEntry对象，将NotifyMotionArgs转化为MotionEntry
        std::unique_ptr&lt;MotionEntry&gt; newEntry =
                std::make_unique&lt;MotionEntry&gt;(args-&gt;id, args-&gt;eventTime, args-&gt;deviceId,
                                              args-&gt;source, args-&gt;displayId, policyFlags,
                                              args-&gt;action, args-&gt;actionButton, args-&gt;flags,
                                              args-&gt;metaState, args-&gt;buttonState,
                                              args-&gt;classification, args-&gt;edgeFlags,
                                              args-&gt;xPrecision, args-&gt;yPrecision,
                                              args-&gt;xCursorPosition, args-&gt;yCursorPosition,
                                              args-&gt;downTime, args-&gt;pointerCount,
                                              args-&gt;pointerProperties, args-&gt;pointerCoords);
        ...
        //将MotionEntry加入InboundQueue
        needWake = enqueueInboundEventLocked(std::move(newEntry)); 
        mLock.unlock();
    &#125; // release lock

    if (needWake) &#123;
        mLooper-&gt;wake();  //唤醒InputDispatcher线程，处理InboundQueue中的MotionEntry
    &#125;
&#125;
</code></pre>
<h4 id="InputDispatcher-enqueueInboundEventLocked"><a href="#InputDispatcher-enqueueInboundEventLocked" class="headerlink" title="InputDispatcher::enqueueInboundEventLocked"></a>InputDispatcher::enqueueInboundEventLocked</h4><pre><code>bool InputDispatcher::enqueueInboundEventLocked(std::unique_ptr&lt;EventEntry&gt; newEntry) &#123;
    bool needWake = mInboundQueue.empty();
    mInboundQueue.push_back(std::move(newEntry));
    EventEntry&amp; entry = *(mInboundQueue.back());
    traceInboundQueueLengthLocked();

    switch (entry.type) &#123;
        case EventEntry::Type::KEY: &#123;
              ...
            break;
        &#125;

        case EventEntry::Type::MOTION: &#123;
            LOG_ALWAYS_FATAL_IF((entry.policyFlags &amp; POLICY_FLAG_TRUSTED) == 0,
                                &quot;Unexpected untrusted event.&quot;);
            if (shouldPruneInboundQueueLocked(static_cast&lt;MotionEntry&amp;&gt;(entry))) &#123;
                mNextUnblockedEvent = mInboundQueue.back();
                needWake = true;
            &#125;
            break;
            ...
    &#125;

    return needWake;
&#125;
</code></pre>
<p>   到此，InputReader线程就将事件传递到InputDispatcher线程，InputDispatcher线程被唤醒开始处理触摸事件，而InputReader线程继续循环执行loopOnce()方法，再次阻塞在getEvents方法中等待事件的上报。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/ASFP (android studio for platform)使用" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> Android Studio for Platform 这个是最新的google开发的阅读aosp源码的工具，特别适合做原生系统开发。具体官方介绍如下地址：<br>参考链接：<a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/platform">https://developer.android.google.cn/studio/platform</a></p>
<h3 id="1、android-studio-for-platform工具介绍"><a href="#1、android-studio-for-platform工具介绍" class="headerlink" title="1、android studio for platform工具介绍"></a>1、android studio for platform工具介绍</h3><p><img src="/../../images/6661ce941ec8464c8f324f785d8b16c3.png" alt="在这里插入图片描述"><br>可以直接点击下载（提示目前只有ubuntu可以哈，语言切换到英文，中文发现无法下载)</p>
<p>看看相关的官方介绍：</p>
<p>Android Studio for Platform (ASfP) is the version of the Android Studio IDE for Android Open Source Project (AOSP) platform developers who build with the Soong build system. ASfP includes the following features:</p>
<pre><code>language
Multi-language Support
Edit C++, Kotlin, and Java programming languages in the same IDE.
settings
Project Setup Wizard
Configure your lunch target and platform modules.
</code></pre>
<p>官方的介绍就以上一小段文字，总结如下：<br>ASfP是专门用于开发aosp的ide工具，有着 Soong build system.，主要有以下几个特点<br>语言支持部分：<br>同时支持：C++, Kotlin, and Java 同时使用在ide中编程<br>设置部分：<br>可以配置你的编译target和具体的模块</p>
<h3 id="2、android-studio-for-platform痛点解决"><a href="#2、android-studio-for-platform痛点解决" class="headerlink" title="2、android studio for platform痛点解决"></a>2、android studio for platform痛点解决</h3><p>这里最吸引我们的还是他居然支持多语言，c++，java，kotlin同时都支持。<br>以前我们开发aosp时候，其实java部分使用android studio的体验还是相当好，但是android studio没办法支持c++等native代码的跳转和代码提示，所以不得不使用vscode工具，这个vscode工具相关看c++等代码也是比较方便，基本上的代码也是可以跳转的，但是毕竟有时候需要两个工具相互切快捷键等还是有一点点不方便，虽然不太影响。</p>
<p>所以开发aosp之前的选择就是：<br>java相关代码使用android studio<br>c++相关代码使用vscode</p>
<p>目前ASfP工具出现真的是我们framework开发者的一个巨大福音，解决了android studio无法跳转c++代码的这个巨大痛点。</p>
<h3 id="3、android-studio-for-platform使用体验"><a href="#3、android-studio-for-platform使用体验" class="headerlink" title="3、android studio for platform使用体验"></a>3、android studio for platform使用体验</h3><p>官方使用介绍：</p>
<p>​    </p>
<pre><code>Get started with ASfP

    If you haven&#39;t already installed repo, follow the instructions at Installing Repo.
    If you haven&#39;t already initialized and synced your Repo checkout, follow the instructions at Initializing a Repo client.
    Download ASfP.
    Install ASfP: sudo dpkg -i /path/to/asfp-2023.1.1.19-linux.deb.
    Open ASfP from the command line: /opt/android-studio-for-platform/bin/studio.sh.
    Import your project by pointing to your repo checkout directory, specifying a lunch target, and selecting which modules you want to build.
    Click Finish and your project will begin syncing.
    Request to join our external group for user support.
</code></pre>
<p>​<br>​    </p>
<p>这里我们就直接自己转化把<br>1、下载好工具，安装好即可以（限制在ubuntu）<br><img src="/../../images/b20e0607028843e986a19dcae913e668.png" alt="在这里插入图片描述"><br><img src="/../../images/7fa95deacf934894baf36342705913fd.png" alt="在这里插入图片描述"><br>可以直接点击安装的</p>
<p>2、启动工具<br>在terminator下面输入如下命令：<br>&#x2F;opt&#x2F;android-studio-for-platform&#x2F;bin&#x2F;studio.sh<br>就会启动工具</p>
<p>3、导入需要模块<br><img src="/../../images/8539626963a04c35bea4bcb88c11561b.png" alt="导入AOSP选项"><br>这里导入了Launcher和framework<br><img src="/../../images/5cf8b014d4a04e3fa98f5a8605a97db3.png" alt="在这里插入图片描述"><br><img src="/../../images/6eae4bc3e37a4d40a56e2b68fe5d7d5b.png" alt="在这里插入图片描述"></p>
<p>同步完成就一切都好了即可以查看相关代码和跳转。</p>
<h3 id="ps使用的注意点："><a href="#ps使用的注意点：" class="headerlink" title="ps使用的注意点："></a>ps使用的注意点：</h3><p>1、跳转framework的类时候会跳到对应jar包的class文件，不是java文件，解决如下<br><img src="/../../images/cf63f456bca348f291be71bfa3c7466b.png" alt="在这里插入图片描述"></p>
<p>2、KeyMap如果习惯eclipse的可以切换</p>
<p>3、如果导入c++相关开发建议以下3个文件夹：<br>frameworks<br>system<br>packages</p>
<p>导入越多整体就慢</p>
<h3 id="总结体验："><a href="#总结体验：" class="headerlink" title="总结体验："></a>总结体验：</h3><p>整体体验和以前android studio没有大的差别<br>1、不过说实话单独java部分的代码开发的话，体验还不如以前的android studio轻量，反而依赖的东西太多，对于跳转等，查找代码还没有以前方便，针对java部分的话，这个建议可以先观望等更多版本更新稳定</p>
<p>2、c++部分的native代码，来说简直就利器，非常好用，跳转准确，非常值的推荐</p>
<p>google官方教学视频教程地址：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UV411P7nf/?vd_source=a8c604ee3ce4999324264828f8fd99d8">https://www.bilibili.com/video/BV1UV411P7nf/?vd_source&#x3D;a8c604ee3ce4999324264828f8fd99d8</a></p>
<p><strong>生成桌面图标</strong></p>
<img src="../../images/e5702cee47164cd5818f3f5e164c5005.png" alt="生成桌面图标" style="zoom:67%;" />

<p><strong>修改配置文件</strong></p>
<img src="../../images/8daa5801b6d8469b9281a30b655801ff.png" alt="修改配置文件后进行sync" style="zoom:67%;" />
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/5.Android13启动流程之SystemServer内部逻辑分析" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <blockquote>
<p>主要分析一下SystemServer启动过后的内部逻辑，特别说明一下<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AMS&spm=1001.2101.3001.7020">AMS</a>,WMS都属于SystemServer进程，属于同一个进程</p>
</blockquote>
<h2 id="一-SystemServer进程启动流程"><a href="#一-SystemServer进程启动流程" class="headerlink" title="一. SystemServer进程启动流程"></a>一. SystemServer进程启动流程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128782204">基于Android13的系统启动流程分析（五）之Zygote和SystemServer启动流程</a>这篇文章有详细讲解，这里再简单的过一下如何启动的SystemServer</p>
<p>在zygote进程创建过后，会调用<code>forkSystemServer()</code>来孵化出SystemServer进程，当前该进程创建成功后会反射调用到SystemServer.java的main函数，从而启动完成SystemServer</p>
<h2 id="二-SystemServer主函数分析"><a href="#二-SystemServer主函数分析" class="headerlink" title="二. SystemServer主函数分析"></a>二. SystemServer主函数分析</h2><p>main函数会被ZygoteInit的子方法<code>handleSystemServerProcess</code>反射调用到<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</p>
<pre><code>public static void main(String[] args) &#123;
        new SystemServer().run();
&#125;
</code></pre>
<p>继续看看run方法</p>
<pre><code> private void run() &#123;
       ...
        try &#123;
               ...
            // 设置系统语言，国家，时区相关
            if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;
                final String languageTag = Locale.getDefault().toLanguageTag();
                SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);
                SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);
                SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);
                SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);
            &#125;
            ...
            // Prepare the main looper thread (this thread).
            // 设置main线程的优先级，有此可得主线程就是：SystemServer进程下的其中线程
            android.os.Process.setThreadPriority(
                    android.os.Process.THREAD_PRIORITY_FOREGROUND);
            android.os.Process.setCanSelfBackground(false);
            // 开始主线程的运行，和Looper.loop配对使用
            // 运行在 Looper.prepareMainLooper()～Looper.loop()
            // 之间的就是运行在主线程中
            Looper.prepareMainLooper();
            Looper.getMainLooper().setSlowLogThresholdMs(
                    SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);
            ...
            // 初始化native services,加载android_servers库（libandroid_servers.so）
            System.loadLibrary(&quot;android_servers&quot;);
            ...
            // 通过ActivityThread来创建system上下文
            createSystemContext();

            // Call per-process mainline module initialization.
            // 初始化ActivityThread
            // 创建TelephonyServiceManager，StatsServiceManager，MediaServiceManager
            ActivityThread.initializeMainlineModules();

            // 将SystemServer加入ServiceManager（binder线程池）
            // 每个继承自SystemServer 或属于SystemServer进程的服务都将加入到
            // ServiceManager中的线程池中
            ServiceManager.addService(&quot;system_server_dumper&quot;, mDumper);
            mDumper.addDumpable(this);

            // 每个server基本上对应了一个manager,对外提供的API也是只能获取到manager
            // 创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理，启动系统的各种服务
            mSystemServiceManager = new SystemServiceManager(mSystemContext);
            mSystemServiceManager.setStartInfo(mRuntimeRestart,
                    mRuntimeStartElapsedTime, mRuntimeStartUptime);
            mDumper.addDumpable(mSystemServiceManager);
            // LocalServices是system_server进程中各个服务提供的本地服务
            // system_server进程中每个服务都可以往LocalServices放对象
            // 有些核心服务是继承自SystemServer,LocalServices是公开缓存池目的是：解耦
            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
            ...
        // Start services.
        try &#123;
            t.traceBegin(&quot;StartServices&quot;);
            // 启动系统启动所需的一系列关键服务：AMS,P(power/package)MS,SensorService,DisplayManagerService,LightService等
            startBootstrapServices(t);
            // 启动核心服务：BatteryService，GpuService等
            startCoreServices(t);
            // 启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等
            startOtherServices(t);
            // 以上的所有服务都由mSystemServiceManager来启动，所以都是继承自SystemServer
            // 分别是引导服务、核心服务和其他服务
            // [引导服务]
            // Installer 	系统安装apk时的一个服务类，启动完成Installer服务之后才能启动其他的系统服务
            //ActivityManagerService 	负责四大组件的启动、切换、调度。
            //PowerManagerService 	计算系统中和Power相关的计算，然后决策系统应该如何反应
            //LightsService 	管理和显示背光LED
            //DisplayManagerService 	用来管理所有显示设备
            //UserManagerService 	多用户模式管理
            //SensorService 	为系统提供各种感应器服务
            //PackageManagerService 	用来对apk进行安装、解析、删除、卸载等等操作
            // [核心服务]
            //BatteryService 	管理电池相关的服务
            //UsageStatsService 	收集用户使用每一个APP的频率、使用时常
            //WebViewUpdateService 	WebView更新服务
            // [其他服务]
            //CameraService 	摄像头相关服务
            //AlarmManagerService 	全局定时器管理服务
            //InputManagerService 	管理输入事件
            //WindowManagerService 	窗口管理服务
            //VrManagerService 	VR模式管理服务
            //BluetoothService 	蓝牙管理服务
            //NotificationManagerService 	通知管理服务
            //DeviceStorageMonitorService 	存储相关管理服务
            //LocationManagerService 	定位管理服务
            //AudioService 	音频相关管理服务
        &#125; catch (Throwable ex) &#123;
           ...
        &#125; finally &#123;
            ...
        &#125;
        
       ...
        Looper.loop();// 主线程
        // 若执行到这里说明主线程意外退出了
        // 主线程：Looper.prepareMainlooper~ Looper.loop之间
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    &#125;
</code></pre>
<p>以上方法可以看出来关于其他服务的启动都是运行在主线程中的Looper.prepareMainlooper~ Looper.loop之间，每个SystemServer中的服务都有一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=binder&spm=1001.2101.3001.7020">binder</a>,会加入到ServiceManager的binder线程池中统一管理，这样拿到全局的ServiceManager,根据AIDL 获取到每Service了</p>
<ul>
<li>startBootstrapServices(t)<br>启动系统启动所需的一系列关键服务：<br>AMS,P(power&#x2F;package)MS,SensorService,DisplayManagerService,LightService等</li>
<li>startCoreServices(t)<br>启动核心服务：BatteryService，GpuService等</li>
<li>startOtherServices(t)<br>启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等</li>
</ul>
<blockquote>
<p>在这些启动的服务里（调用了onStart启动服务），都会将服务存入ServiceManager 用来管理系统中的各种Service，用于系统C&#x2F;S架构中的Binder机制通信：Client端要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通讯通路，这样Client端就可以使用Service了</p>
</blockquote>
<p><img src="/../../../images/image-20231129172417054.png" alt="image-20231129172417054"></p>
<p><img src="/../../../images/image-20231129172431908.png" alt="image-20231129172431908"></p>
<h4 id="1-startBootstrapServices"><a href="#1-startBootstrapServices" class="headerlink" title="1. startBootstrapServices"></a>1. startBootstrapServices</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">startBootstrapServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 尽早启动看门狗，以便在早期启动过程中出现死锁时使系统服务器崩溃</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartWatchdog&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动看门狗，看门狗需要定时喂狗，若喂狗超时则会触发重启，以便知道进程和服务是否正常运行</span></span><br><span class="line">      <span class="keyword">final</span> Watchdog watchdog = Watchdog.<span class="built_in">getInstance</span>();</span><br><span class="line">      watchdog.<span class="built_in">start</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartInstaller&quot;</span>);</span><br><span class="line">      <span class="comment">// 通过mSystemServiceManager来启动Installer服务,管理应用的安装与卸载</span></span><br><span class="line">      Installer installer = mSystemServiceManager.<span class="built_in">startService</span>(Installer.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 通过mSystemServiceManager来启动UriGrantsManagerService，管理Uri</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;UriGrantsManagerService&quot;</span>);</span><br><span class="line">mSystemServiceManager.<span class="built_in">startService</span>(UriGrantsManagerService.Lifecycle.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过mSystemServiceManager来启动PowerStatsService，管理电源状态</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartPowerStatsService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(PowerStatsService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">      <span class="comment">// 通过mSystemServiceManager来启动ActivityTaskManagerService，管理Activity任务栈</span></span><br><span class="line">      ActivityTaskManagerService atm = mSystemServiceManager.<span class="built_in">startService</span>(</span><br><span class="line">              ActivityTaskManagerService.Lifecycle.<span class="keyword">class</span>).<span class="built_in">getService</span>();</span><br><span class="line">      <span class="comment">// 启动ActivityManagerService,管理Activity等</span></span><br><span class="line">      mActivityManagerService = ActivityManagerService.Lifecycle.<span class="built_in">startService</span>(</span><br><span class="line">              mSystemServiceManager, atm);</span><br><span class="line">      <span class="comment">// 让ActivityManagerService拿到systemServer,例如可以通过mSystemServiceManager来判断系统是否启动完成</span></span><br><span class="line">      mActivityManagerService.<span class="built_in">setSystemServiceManager</span>(mSystemServiceManager);</span><br><span class="line">      mActivityManagerService.<span class="built_in">setInstaller</span>(installer);</span><br><span class="line">      mWindowManagerGlobalLock = atm.<span class="built_in">getGlobalLock</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// 启用PowerManagerService服务，电源管理服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartPowerManager&quot;</span>);</span><br><span class="line">      mPowerManagerService = mSystemServiceManager.<span class="built_in">startService</span>(PowerManagerService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 启动屏幕亮度服务，比如亮度调整</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartLightsService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(LightsService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动屏幕显示服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartDisplayManager&quot;</span>);</span><br><span class="line">      mDisplayManagerService = mSystemServiceManager.<span class="built_in">startService</span>(DisplayManagerService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">          <span class="comment">// 启动PMS,包管理服务</span></span><br><span class="line">          mPackageManagerService = PackageManagerService.<span class="built_in">main</span>(mSystemContext, installer,</span><br><span class="line">                  domainVerificationService, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF,</span><br><span class="line">                  mOnlyCore);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          Watchdog.<span class="built_in">getInstance</span>().<span class="built_in">resumeWatchingCurrentThread</span>(<span class="string">&quot;packagemanagermain&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">       <span class="comment">// 启动传感器服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartSensorService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(SensorService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>(); <span class="comment">// startBootstrapServices</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到大多数服务都是通过<code>mSystemServiceManager.startService</code>来启动，核心服务和其他服务都是一样的，就不过多分析了<br>可以先看看startService方法内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> String name = serviceClass.<span class="built_in">getName</span>();</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">final</span> T service;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 反射拿到该java类</span></span><br><span class="line">               Constructor&lt;T&gt; constructor = serviceClass.<span class="built_in">getConstructor</span>(Context.<span class="keyword">class</span>);</span><br><span class="line">               service = constructor.<span class="built_in">newInstance</span>(mContext);</span><br><span class="line">           &#125; ...</span><br><span class="line">           <span class="comment">// 将当前服务（java类）加入SystemService服务队列中，统一管理</span></span><br><span class="line">           <span class="built_in">startService</span>(service);</span><br><span class="line">           <span class="keyword">return</span> service;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Trace.<span class="built_in">traceEnd</span>(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将当前服务加入mServices队列中</span></span><br><span class="line">       mServices.<span class="built_in">add</span>(service);</span><br><span class="line">       <span class="comment">// Start it.</span></span><br><span class="line">       <span class="type">long</span> time = SystemClock.<span class="built_in">elapsedRealtime</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 调用当前服务的onStart来启动服务</span></span><br><span class="line">           service.<span class="built_in">onStart</span>();</span><br><span class="line">       &#125; <span class="built_in">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">warnIfTooLong</span>(SystemClock.<span class="built_in">elapsedRealtime</span>() - time, service, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>可以看到startService方法就是反射拿到服务类，然后加入队列中，调用其onStart方法进行启动</p>
<h4 id="2-ServiceManager服务管理"><a href="#2-ServiceManager服务管理" class="headerlink" title="2. ServiceManager服务管理"></a>2. ServiceManager服务管理</h4><p>每个属于SystemServer的服务都将加入到ServiceManager的binder线程池中，以供后续直接获取和管理<br>就拿BatteryService服务来讲解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.<span class="built_in">startService</span>(BatteryService.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>


<p>已知startService后会调用BatteryService服务的onStart方法，继续看看onStart内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">Override</span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="type">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">       mBinderService = <span class="keyword">new</span> <span class="built_in">BinderService</span>();</span><br><span class="line">       <span class="comment">// 将BinderService服务加入ServiceManager中</span></span><br><span class="line">       <span class="built_in">publishBinderService</span>(<span class="string">&quot;battery&quot;</span>, mBinderService);</span><br><span class="line">       mBatteryPropertiesRegistrar = <span class="keyword">new</span> <span class="built_in">BatteryPropertiesRegistrar</span>();</span><br><span class="line">       <span class="comment">// 将batteryproperties服务加入ServiceManager中</span></span><br><span class="line">       <span class="built_in">publishBinderService</span>(<span class="string">&quot;batteryproperties&quot;</span>, mBatteryPropertiesRegistrar);</span><br><span class="line">       <span class="comment">// 将BinderService服务加入到LocalServices中</span></span><br><span class="line">       <span class="built_in">publishLocalService</span>(BatteryManagerInternal.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="built_in">LocalService</span>());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>继续看看<code>mBinderService</code>具体是什么，又是如何加入到ServiceManager中的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BinderService</span> extends Binder &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>可以看到<code>mBinderService</code>就是一个Binder,然后调用<code>publishBinderService</code>加入到ServiceManager中的binder线程池中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">void</span> <span class="title">publishBinderService</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ServiceManager.<span class="built_in">addService</span>(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>调用<code>ServiceManager.addService</code>加入到binder线程池中（ServiceManager暂不深究，只知其内部维护了binder线程池），而ServiceManager服务早就在rc文件中作为核心服务启动了，所以具体实现都是c++代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">core</span> animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart apexd</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart class_restart main</span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>


<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>其实SystemServer是通过init fork出来的，父进程就是zygote,而zygote父进程就是init进程。<br>SystemServer内部逻辑主要就是创建了核心服务，引导服务，其他服务，例如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=WMS&spm=1001.2101.3001.7020">WMS</a>,PMS,电池服务，蓝牙服务等。这些服务都不是单独的进程，而是都属于SystemServer进程，启动这些服务过后会将这些服务加入ServiceManager的binder线程池中，因为这些服务内部都创建了Binder实例，再加入到了ServiceManager的binder线程池中，以便与随时获取服务与只通信</p>
<p>参考文章：<a target="_blank" rel="noopener" href="http://liuwangshu.cn/framework/booting/3-syetemserver.html">Android系统启动流程（三）解析SyetemServer进程启动过程</a></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/4.Android13启动流程之Zygote和SystemServer启动流程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>##一. Android系统启动流程</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128637218">基于Android13的系统启动流程分析（一）之SeLinux权限介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128652348">基于Android13的系统启动流程分析（三）之FirstStageMain阶段</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128759108">基于Android13的系统启动流程分析（四）之SecondStageMain阶段</a></li>
<li>基于SecondStageMain阶段解析rc文件后会启动zygote进程</li>
<li>zygote进程启动过后会通过JNI方式回调到上层再调回到底层的fork函数创建出SystemServer</li>
</ol>
<h2 id="二-Zygote服务创建源码分析"><a href="#二-Zygote服务创建源码分析" class="headerlink" title="二. Zygote服务创建源码分析"></a>二. Zygote服务创建源码分析</h2><p>在init.rc文件中会执行<code>class_start main</code>来启动zygote,代码如下</p>
<pre><code># 启动zygote
on nonencrypted
    class_start main
    class_start late_start
</code></pre>
<p>这个main就是zygote,可以通过init.{zygote64}.rc来查看，代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="meta"># class : 给服务指定一个类属</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">    priority <span class="number">-20</span></span><br><span class="line">    <span class="meta"># user 在执行此服务之前先切换用户名。当前默认为root.</span></span><br><span class="line">    user root</span><br><span class="line">    # 切换组名</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程</span><br><span class="line">    # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为<span class="number">0</span></span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    socket usap_pool_primary stream <span class="number">660</span> root system</span><br><span class="line">    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line">    <span class="meta"># oneshot : 当此服务退出时不会自动重启.</span></span><br><span class="line">    <span class="meta"># disabled:服务不会自动运行，必须显式地通过服务器来启动</span></span><br><span class="line">    # 据设备相关的关键服务，如果在<span class="number">4</span>分钟内，此服务重复启动了<span class="number">4</span>次，那么设备将会重启进入还原模式。</span><br><span class="line">    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal</span><br></pre></td></tr></table></figure>

<p>第二个参数就是服务进程的名称，通过class指定函数入口，并且位于：<code>/system/bin/app_process64</code>,可以看到<code>audioserver</code>，<code>cameraserver</code>，<code>media</code>，<code>netd</code>，<code>wificond</code>这些进程都隶属于zygote进程中，那就代表着</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果zygote挂了，这些进程将一起died</span><br><span class="line">2.如果这些进程挂了，并不会影响zygote died</span><br></pre></td></tr></table></figure>

<p>如果zygote挂了将会捕获到进程异常信号，将zygote进程进行重启，zygote main入口位置：  <code>frameworks/base/cmds/app_process/app_main.cpp</code></p>
<h4 id="1-app-main-cpp源码分析"><a href="#1-app-main-cpp源码分析" class="headerlink" title="1. app_main.cpp源码分析"></a>1. app_main.cpp源码分析</h4><pre><code>int main(int argc, char* const argv[])
&#123;
    ...
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    ...

    // 如果zygote为true则代表即将创建该进程
    // 如果startSystemServer为true则代表创建zygote时也会创建SystemServer
    // 系统正常启动都会将这两个bool默认给到true
    // 因为rc启动main后携带了--zygote和--start-system-server两个参数
    bool zygote = false;
    bool startSystemServer = false;
    bool application = false;
    String8 niceName;
    String8 className;
            
    ++i;  // Skip unused &quot;parent dir&quot; argument.
    while (i &lt; argc) &#123;
        const char* arg = argv[i++];
        if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;// zygote将为true,名称就叫：zygote
            zygote = true;
            niceName = ZYGOTE_NICE_NAME;
        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;// startSystemServer将为true
            startSystemServer = true;
        &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;
            application = true;
        &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;
            niceName.setTo(arg + 12);
        &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;
            className.setTo(arg);
            break;
        &#125; else &#123;
            --i;
            break;
        &#125;
    &#125;

    Vector&lt;String8&gt; args;
    if (!className.isEmpty()) &#123;
       ...
    &#125; else &#123;
        // 进入创建zygote模式
        // 创建/data/dalvik-cache，为后续会创建Dalvik虚拟机做准备
        maybeCreateDalvikCache();

        // 如果startSystemServer为true的话(默认为true)
        // 将”start-system-server”放入启动的参数args
        if (startSystemServer) &#123;
            args.add(String8(&quot;start-system-server&quot;));
        &#125;

        char prop[PROP_VALUE_MAX];
        ...
        // 将所有剩余参数传递给args，例如application或tool或start-system-server或abi
        // 这些启动参数将会传递到其他进程中，后续取出参数决定是否启动systemServer等操作
        for (; i &lt; argc; ++i) &#123;
            args.add(String8(argv[i]));
        &#125;
    &#125;
    ...

    // zygote为真，将创建zygote，该args启动参数会包含start-system-server
    // 调用runtime(AppRuntime)的start来启动zygote，将args传入，因为args包含了启动SystemServer的标志
    if (zygote) &#123;
        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);
    &#125; else if (className) &#123;
        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);
    &#125; else &#123;
        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);
        app_usage();
        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);
    &#125;
&#125;
</code></pre>
<p>以上代码就是启动zygote和将start-system-server放入启动参数，后续会读取参数启动SystemServer,继续分析一下runtime.start的<code>com.android.internal.os.ZygoteInit&quot;</code>进程，位于：<code>frameworks/base/core/jni/AndroidRuntime.cpp</code></p>
<h4 id="2-AndroidRuntime-cpp源码分析"><a href="#2-AndroidRuntime-cpp源码分析" class="headerlink" title="2. AndroidRuntime.cpp源码分析"></a>2. AndroidRuntime.cpp源码分析</h4><p>Vector&lt;**String8**&gt;&amp; options就是包含了start-system-server的启动参数，通过app_main传递过来的</p>
<pre><code>//frameworks/base/core/jni/AndroidRuntime.cpp
void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)
&#123;
    ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;,
            className != NULL ? className : &quot;(unknown)&quot;, getuid());
    // 默认会启动SystemServer
    static const String8 startSystemServer(&quot;start-system-server&quot;);
    // 是否私有，如果SystemServer会被创建时，将会设置为私有
    bool primary_zygote = false;
            
    for (size_t i = 0; i &lt; options.size(); ++i) &#123;
        // options就是传递过来的args,默认是包含了start-system-server
        if (options[i] == startSystemServer) &#123;
            primary_zygote = true;
           ...
        &#125;
    &#125;

    // 获取环境变量，这里第一次执行时默认为空，所以rootDir不存在
    // = 将直接拿到/system作为rootDir并设置环境变量
    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);
    if (rootDir == NULL) &#123;
        rootDir = &quot;/system&quot;;
        if (!hasDir(&quot;/system&quot;)) &#123;
            LOG_FATAL(&quot;No root directory specified, and /system does not exist.&quot;);
            return;
        &#125;
        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);
    &#125;
    ...

    /* start the virtual machine */
    // 这里就开始启动虚拟机了
    // JNI功能初始化
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    // 创建Dalvik虚拟机(这里--&gt;DVM==JavaVM)
    if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123;
        return;
    &#125;
    onVmCreated(env);

    // 调用startReg函数用来为DVM注册JNI
    if (startReg(env) &lt; 0) &#123;
        ALOGE(&quot;Unable to register all android natives\n&quot;);
        return;
    &#125;

    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;
    // 通过反射拿到String类型
    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);
    assert(stringClass != NULL);
    //options就是app_main.cpp传递过来的args,包含了start-system-server
    // 将options转换为array list对象
    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    //从app_main的main函数得知className为com.android.internal.os.ZygoteInit
    classNameStr = env-&gt;NewStringUTF(className);
    assert(classNameStr != NULL);
    // 将数据转换给java类型的array 数组
    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i &lt; options.size(); ++i) &#123;
        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);
    &#125;

    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.
     */
     // 启动com.android.internal.os.ZygoteInit，该线程成为JVM的主进程，在VM退出之前不会返回
    char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;);
    jclass startClass = env-&gt;FindClass(slashClassName);
    if (startClass == NULL) &#123;
       ...
    &#125; else &#123;
        // 通过反射的方式，找到ZygoteInit的main函数
        // 若获取到内容则执行else
        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,
            &quot;([Ljava/lang/String;)V&quot;);
        if (startMeth == NULL) &#123;
            ALOGE(&quot;JavaVM unable to find main() in &#39;%s&#39;\n&quot;, className);
            /* keep going */
        &#125; else &#123;
            // 通过JNI调用ZygoteInit的main函数,将args(strArray)传递到java层
            // 因为ZygoteInit的main函数是Java编写的，因此需要通过JNI调用
            // 所以这里继续跟到java层面:ZygoteInit.java
            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);
            ...
        &#125;
    &#125;
    // 若执行到这里，则会结束zygote创建，关闭jvm
    free(slashClassName);
    ALOGD(&quot;Shutting down VM\n&quot;);
    if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)
        ALOGW(&quot;Warning: unable to detach main thread\n&quot;);
    if (mJavaVM-&gt;DestroyJavaVM() != 0)
        ALOGW(&quot;Warning: VM did not shut down cleanly\n&quot;);
&#125;
</code></pre>
<p>可以看到以上的代码主要就是初始化了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JNI&spm=1001.2101.3001.7020">JNI</a>（c++与Java交互）功能并创建并启动了JVM虚拟机，通过反射的方式去启动ZygoteInit.java的main方法，并将args参数（包含了是否启动SystemServer的参数）传递过去。<br>而<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JVM%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">JVM虚拟机</a>进程就是：com.android.internal.os.ZygoteInit,而ZygoteInit进程位于：<br><em><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit.java</strong></em></p>
<h4 id="3-ZygoteInit-java源码分析"><a href="#3-ZygoteInit-java源码分析" class="headerlink" title="3. ZygoteInit.java源码分析"></a>3. ZygoteInit.java源码分析</h4><pre><code> public static void main(String[] argv) &#123;
        ZygoteServer zygoteServer = null;
        // 标记zygote开始了
        ZygoteHooks.startZygoteNoThreadCreation();
        // 设置zygote自己的用户组pid
        try &#123;
            Os.setpgid(0, 0);
        &#125; catch (ErrnoException ex) &#123;
            throw new RuntimeException(&quot;Failed to setpgid(0,0)&quot;, ex);
        &#125;

        Runnable caller;
        try &#123;
           // 读取系统是否已经启动完成
            final long startTime = SystemClock.elapsedRealtime();
            final boolean isRuntimeRestarted = &quot;1&quot;.equals(
                    SystemProperties.get(&quot;sys.boot_completed&quot;));

            // 将行为写入trace log 标记目前正处于ZygoteInit阶段
            String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;;
            TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag,
                    Trace.TRACE_TAG_DALVIK);
            bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;);
            RuntimeInit.preForkInit();

            boolean startSystemServer = false;
            // zygote进程就是一个socket,名称就叫zygote
            String zygoteSocketName = &quot;zygote&quot;;
            String abiList = null;
            boolean enableLazyPreload = false;
            for (int i = 1; i &lt; argv.length; i++) &#123;
                // 从AndroidRuntime.cpp中传递上来，已经包含了start-system-server
                // 所以startSystemServer = true
                if (&quot;start-system-server&quot;.equals(argv[i])) &#123;
                    startSystemServer = true;
                &#125; ...
            &#125;
            // 为true，是私有zygote
            final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);
            ...
            // 记录的trace log，只记录到这个地方
            bootTimingsTraceLog.traceEnd(); // ZygoteInit
            // 初始化socket,从环境中获取套接字FD(ANDROID_SOCKET_zygote)
            // 若获取不到则创建一个用于和systemServer通信的socket，当systemServer fork出来后socket进程将关闭
            Zygote.initNativeState(isPrimaryZygote);
              ...

            // 根据环境变量（LocalServerSocket）获取zygote文件描述符并重新创建一个socket,可以从这里看到zygote其实就是一个socket
            // 这个name为”zygote”的Socket用来等待ActivityManagerService来请求Zygote来fork出新的应用程序进程
            // 所以ActivityManagerService里启动应用程序（APP），都是由该zygote socket进行处理并fork出的子进程
            zygoteServer = new ZygoteServer(isPrimaryZygote);
            // 默认为true,将启动systemServer
            if (startSystemServer) &#123;
                // zygote就是一个孵化器，所以这里直接fork（分叉，派生）出来SystemServer
                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);
                ...
                // 让SystemServer子进程运行起来
                if (r != null) &#123;
                    r.run();
                    return;
                &#125;
            &#125;

            Log.i(TAG, &quot;Accepting command socket connections&quot;);

            // 让zygote socket（注意不是systemServer zygote）循环运行
            // 等待client进程来请求调用，请求创建子进程（fork出子进程（例如等待AMS的请求））
            caller = zygoteServer.runSelectLoop(abiList);
        &#125; catch (Throwable ex) &#123;
           ...
        &#125; finally &#123;
            if (zygoteServer != null) &#123;
                // 停止关于systemServer的socket,保留和AMS通信的socket
                // 在initNativeState阶段创建了一个和systemServer通信的socket
                // 接着拿到systemServer socket文件描述符重新创建了一个可以和AMS通信的socket（/dev/socket/zygote）
                zygoteServer.closeServerSocket();
            &#125;
        &#125;
        ...
    &#125;
</code></pre>
<ul>
<li>以上代码讲述了SystemServer socket的创建，将行为写入到trace log日志系统中，并通过JNI调用到底层的fork函数，孵化出SystemServer进程，如果SystemServer创建成功并已经运行了就会将当前socket进行close</li>
<li>期间会创建一个zygote socket,用于等待其他子进程来连接，例如等待AMS(activity manager service)来连接该socket,然后继续fork出子进程（也就是应用程序，所以应用程序就是通过zygote来fork出来的）</li>
<li>创建了2个socket,一个是systemServer socket（Zygote.initNativeState(isPrimaryZygote)来创建）,一个是zygote socket（new ZygoteServer来创建），注意区分</li>
</ul>
<p>继续来看一下<code>zygoteServer = new ZygoteServer(isPrimaryZygote);</code></p>
<h6 id="3-1-ZygoteInit-java-ZygoteServer（zygote-socket）分析"><a href="#3-1-ZygoteInit-java-ZygoteServer（zygote-socket）分析" class="headerlink" title="3.1 ZygoteInit.java#ZygoteServer（zygote socket）分析"></a>3.1 ZygoteInit.java#ZygoteServer（zygote socket）分析</h6><pre><code> //frameworks/base/core/java/com/android/internal/os/ZygoteServer.java
 ZygoteServer(boolean isPrimaryZygote) &#123;
        mUsapPoolEventFD = Zygote.getUsapPoolEventFD();

        // 创建socket，名称为zygote,路径：/dev/sockets/zygote
        if (isPrimaryZygote) &#123;
            mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);
           ...
        &#125;
        ...
    &#125;
    
static LocalServerSocket createManagedSocketFromInitSocket(String socketName) &#123;
        //文件描述符通过ANDROID_socket_&lt;socketName&gt;环境变量共享
        int fileDesc;
        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;

        try &#123;
            String env = System.getenv(fullSocketName);
            // 拿到文件描述符内容
            fileDesc = Integer.parseInt(env);
        &#125; catch (RuntimeException ex) &#123;
            throw new RuntimeException(&quot;Socket unset or invalid: &quot; + fullSocketName, ex);
        &#125;

 try &#123;
            // 生成文件描述符
            FileDescriptor fd = new FileDescriptor();
            fd.setInt$(fileDesc);
            return new LocalServerSocket(fd);  //frameworks/base/core/java/android/net/LocalServerSocket.java
        &#125; catch (IOException ex) &#123;
            throw new RuntimeException(
                &quot;Error building socket from file descriptor: &quot; + fileDesc, ex);
        &#125;
    &#125;
    
public LocalServerSocket(FileDescriptor fd) throws IOException
    &#123;
        // 创建socket并持续监听（等待client来调用）
        impl = new LocalSocketImpl(fd);
        impl.listen(LISTEN_BACKLOG);
        localAddress = impl.getSockAddress();
    &#125;
</code></pre>
<p>简单点来说就是创建了一个zygoye socket ，位于&#x2F;dev&#x2F;sockets&#x2F;zygote,并调用了runSelectLoop让其循环运行，等待新进程发来的请求并进行连接<code>zygoteServer.runSelectLoop(abiList)</code>然后fork出子应用程序进程</p>
<pre><code> Runnable runSelectLoop(String abiList) &#123;
        ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;&gt;();
        ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;&gt;();

        // 拿到socket的文件描述符
        socketFDs.add(mZygoteSocket.getFileDescriptor());
        ...
        while (true) &#123;
            ...
            if (pollReturnValue == 0) &#123;
            ...
            &#125; else &#123;
                boolean usapPoolFDRead = false;

                while (--pollIndex &gt;= 0) &#123;
                    if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123;
                        continue;
                    &#125;

                    if (pollIndex == 0) &#123;
                        // Zygote server socket
                        // acceptCommandPeer函数得到ZygoteConnection类并添加到Socket连接列表peers中，
                        // 接着将该ZygoteConnection的文件描述符添加到fd列表fds中，以便可以接收到ActivityManagerService发送过来的请求
                        ZygoteConnection newPeer = acceptCommandPeer(abiList);
                        peers.add(newPeer);
                        socketFDs.add(newPeer.getFileDescriptor());
                    &#125; 
               ...
            &#125;
        &#125;
    &#125;
</code></pre>
<p>zygoteServer.runSelectLoop(abiList)持续等待进程来请求连接并fork出应用。</p>
<blockquote>
<p>至此zygote socket已经启动完毕了，该socket会等待AMS进程发来的应用程序进程fork</p>
</blockquote>
<p>继续看看systemServer是怎么被fork出来的<br><code>forkSystemServer(abiList, zygoteSocketName, zygoteServer);</code></p>
<h6 id="3-2-ZygoteInit-java-forkSystemServer分析"><a href="#3-2-ZygoteInit-java-forkSystemServer分析" class="headerlink" title="3.2 ZygoteInit.java#forkSystemServer分析"></a>3.2 ZygoteInit.java#forkSystemServer分析</h6><pre><code> private static Runnable forkSystemServer(String abiList, String socketName,
            ZygoteServer zygoteServer) &#123;
        ...
        // 创建args数组，这个数组用来保存启动SystemServer的启动参数，其中可以看出SystemServer进程的用户id和用户组id被设
        //置为1000；
        // 并且拥有用户组10011010，1018、1021、1032、30013010的权限；进程名为system_server；
        // 启动的类名为com.android.server.SystemServer
        String[] args = &#123;
                &quot;--setuid=1000&quot;,
                &quot;--setgid=1000&quot;,
                &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot;
                        + &quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011,3012&quot;,
                &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
                &quot;--nice-name=system_server&quot;,
                &quot;--runtime-args&quot;,
                &quot;--target-sdk-version=&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,
                &quot;com.android.server.SystemServer&quot;,
        &#125;;
        ZygoteArguments parsedArgs;

        int pid;
        try &#123;
            ...
            // 通过JNI形式去调用init进程下的fork函数，派生出systemServer进程
            pid = Zygote.forkSystemServer(
                    parsedArgs.mUid, parsedArgs.mGid,
                    parsedArgs.mGids,
                    parsedArgs.mRuntimeFlags,
                    null,
                    parsedArgs.mPermittedCapabilities,
                    parsedArgs.mEffectiveCapabilities);
        &#125; catch (IllegalArgumentException ex) &#123;
            throw new RuntimeException(ex);
        &#125;

        // pid == 0代表已经运行在子进程(SystemServer)上了
        // 代表SystemServer创建成功，创建成功后会关闭该socket
        if (pid == 0) &#123;
            ...
            // 销毁zygoteServer,保留和AMS通信的socket（runSelectLoop）
            // 当SystemServer创建过后，zygoteServerSocket就没有用处了，进行关闭
            zygoteServer.closeServerSocket();
            // 处理 system server 进程初始化工作并启动SystemServer进程
            // 并启动了一个 binder 线程池供system server 进程和其他进程通信使用
            // 最后调用 RuntimeInit.applicationInit() 执行进程启动自身初始化工作
            // applicationInit()最后是通过反射调用了 SystemServer.java 中的 main() 方法
            return handleSystemServerProcess(parsedArgs);
        &#125;
        return null;
    &#125;
</code></pre>
<p><code>Zygote.forkSystemServer</code>就是调用了底层的fork函数，不再进一步分析了。以上代码已知SystemServer子进程已经创建成功，将调用<code>handleSystemServerProcess</code>来启动SystemServer.java的入口<br>handleSystemServerProcess会一直调用到RuntimeInit.java#findStaticMain方法中</p>
<pre><code>    protected static Runnable findStaticMain(String className, String[] argv,
            ClassLoader classLoader) &#123;
        Class&lt;?&gt; cl;

        try &#123;
            // className:com.android.server.SystemServer
            // 反射拿到SystemServer类
            cl = Class.forName(className, true, classLoader);
        &#125; catch (ClassNotFoundException ex) &#123;
           ...
        &#125;

        Method m;
        try &#123;
            // 反射拿到SystemServer.java的main函数，并启动
            m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);
        &#125; catch (NoSuchMethodException ex) &#123;
           ...
        &#125; catch (SecurityException ex) &#123;
           ...
        &#125;
        ...
        return new MethodAndArgsCaller(m, argv);
    &#125;
</code></pre>
<p>可以看到handleSystemServerProcess下面的子方法去调用了com.android.server.SystemServer的main方法，至此SystemServer就创建和启动完毕了</p>
<blockquote>
<p>至此SystemServer 已经创建并启动完毕了，那么SystemServer socket就会销毁并关闭</p>
</blockquote>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>可以知道zygote是从rc中启动的，zygote本质上就是一个socket,不会关闭和销毁，而创建zygote时携带的StartSystemServer参数（必须携带此参数），会启动SystemServer子进程，SystemServer也是通过fork出来的，而底层和上层的交互是通过JNI实现的，SystemServer的启动是由zygoteInit通过反射的方式启动SystemServer的main方法</p>
<blockquote>
<p>zygote启动时创建了服务端socket,用于SystemServer的创建，当SystemServer创建完成后则会关闭连接，期间已经调用了runSelectLoop来循环等待AMS及其他进程来请求连接，从而fork出应用程序的socket<br>服务端 socket会在SystemServer进程创建完毕后就会关闭，已经没有用处了，等待AMS发来连接将采用runSelectLoop方法进行循环等待</p>
</blockquote>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/3.Android13启动流程之SecondStageMain阶段" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="一-Android系统启动基本介绍"><a href="#一-Android系统启动基本介绍" class="headerlink" title="一. Android系统启动基本介绍"></a>一. Android系统启动基本介绍</h2><p>在<a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128652348">基于Android13的系统启动流程分析（三）之FirstStageMain阶段</a>已经讲解过android系统启动的基本介绍了，这里不再单独介绍了</p>
<h2 id="二-SecondStageMain源码分析"><a href="#二-SecondStageMain源码分析" class="headerlink" title="二. SecondStageMain源码分析"></a>二. SecondStageMain源码分析</h2><p>我们先看是怎么进入该阶段的，仍然是由用户空间层main.cpp调用，先简单的说一下第二阶段主要是干什么的：</p>
<ol>
<li><p>设置init进程优先级并创建<code>/dev/.booting</code>设备块代表init正在初始化执行中</p>
</li>
<li><p>初始化属性服务，也就是会读取property_contexts文件内容以及读取build.prop内容通过MMAP映射到全局内存中，也就是对所有进程共享该资源</p>
</li>
<li><p>启动属性服务并创建socket_service,等待新链接去更新或新增属性值</p>
</li>
<li><p>挂载&#x2F;apex,vendor_overlay等其他分区</p>
</li>
<li><p>检查设备是否被unlock解锁</p>
</li>
<li><p>持续监控&#x2F;proc&#x2F;mounts设备文件，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等。将解析内容生成实体类追加到要挂载的mounts_中并进行挂载</p>
</li>
<li><p>将根目录下所有的目录设置为全局共享，例如对&#x2F;data设置为根目录下的全局共享</p>
</li>
<li><p>解析init.rc以及其他import了的rc文件，主要解析rc中的：service，on（action）,Import,而zygote进程正是从解析rc文件中创建的，然后根据zygote（本质上就是一个socket），通过JNI调用到上层代码，再fork出systemServer.java</p>
</li>
<li><p>让init进程无限循环，因为主进程不能退出，退出即代表发生异常</p>
</li>
<li><p>处理sm（ServiceList）中服务超时重启相关（init.rc中的service），若rc中启动的服务启动超时则会让其服务重新启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">       ...</span><br><span class="line">        if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123;</span><br><span class="line">            return SecondStageMain(argc, argv);//第二阶段执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return FirstStageMain(argc, argv); //第一阶段执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-int-SecondStageMain-int-argc-char-argv-分析"><a href="#1-int-SecondStageMain-int-argc-char-argv-分析" class="headerlink" title="1. int SecondStageMain(int argc, char** argv)分析"></a>1. int SecondStageMain(int argc, char** argv)分析</h4><p>位于<code>/system/core/init/init.cpp</code>，直接上代码，代码注释中分步骤来分析</p>
<pre><code>int SecondStageMain(int argc, char** argv) &#123;
    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;
        // 针对产生异常的进程进行信号处理,确保子进程能重启，如果主进程pid=1发生异常则触发crash
        // 已经在上个文章分析过该函数
        InstallRebootSignalHandlers();
    &#125;
     ...
    // 初始化kernel log,所有的kernel log均输出在/dev/kmsg设备节点上
    SetStdioToDevNull(argv);
    InitKernelLogging(argv);
    LOG(INFO) &lt;&lt; &quot;init second stage started!&quot;;
    ...
    // Init不应该因为依赖于任何其他进程而崩溃，因此我们忽略主进程的信号管道信息
    // 但我们不想忽略子进程的SIGPIPE（信号管道），因此我们为信号处理程序设置了一个no op函数
    // SIGPIPE信号产生的场景举例
    // ① 初始时，C、S连接建立，若某一时刻，C端进程宕机或者被KILL而终止（终止的C端进程将会关闭打开的文件描述符，即向S端发送FIN段），S端收到FIN后，响应ACK
    // ② 假设此时，S端仍然向C端发送数据：当第一次写数据后，S端将会收到RST分节； 当收到RST分节后，第二次写数据后，S端将收到SIGPIPE信号（S端进程被终止）
    &#123;
        struct sigaction action = &#123;.sa_flags = SA_RESTART&#125;;
        action.sa_handler = [](int) &#123;&#125;;
        // sigaction是一个函数，可以用来查询或设置信号处理方式
        sigaction(SIGPIPE, &amp;action, nullptr);
    &#125;

    //  MIN_OOM_SCORE_ADJUST = -1000;
    //  MAX_OOM_SCORE_ADJUST = 1000;
    //  设置进程的优先级，例如APK优先级是AMS计算出来并下发到/proc/1/oom_score_adj
    //  统一由init进程设置/proc/**/oom_score_adj为-1000优先级
    if (auto result =
                WriteFile(&quot;/proc/1/oom_score_adj&quot;, StringPrintf(&quot;%d&quot;, DEFAULT_OOM_SCORE_ADJUST));
        !result.ok()) &#123;
        LOG(ERROR) &lt;&lt; &quot;Unable to write &quot; &lt;&lt; DEFAULT_OOM_SCORE_ADJUST
                   &lt;&lt; &quot; to /proc/1/oom_score_adj: &quot; &lt;&lt; result.error();
    &#125;

      ...
    // 创建 /dev/.booting 文件，就是个标记，表示booting进行中
    // is_booting()函数会依靠空文件&quot;.booting&quot;来判断是否进程处于初始化中，初始化结束后，这个文件会被删除
    close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));
    
    // 当设备解锁时，允许adb root
    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限,这一点在第一阶段已经完成了
    // 并设置了INIT_FORCE_DEBUGGABLE环境变量，这里只是根据环境变量获取第一阶段的内容
    const char* force_debuggable_env = getenv(&quot;INIT_FORCE_DEBUGGABLE&quot;);
    bool load_debug_prop = false;
    if (force_debuggable_env &amp;&amp; AvbHandle::IsDeviceUnlocked()) &#123;
        load_debug_prop = &quot;true&quot;s == force_debuggable_env;
    &#125;
    unsetenv(&quot;INIT_FORCE_DEBUGGABLE&quot;);
    
    // 如果设备未unlock，则卸载关于debug版本的/debug_ramdisk
    // 让属性值读取/ramdisk而不是/debug_ramdisk，因为非unlock,不需要debug ramdisk
    if (!load_debug_prop) &#123;
        // setup 1
        UmountDebugRamdisk();
    &#125;

    // 初始化属性服务
    // 获取system/build.prop,vendor/build.prop,/odm/build.prop,/product/build.prop,等其他build.prop并加载到properties map结构中
    // 然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值
    // 注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖
    // setup 2
    PropertyInit();

    // Umount second stage resources after property service has read the .prop files.
    // 在属性服务读取.prop文件后，将卸载/second_stage_resources，因为已经用不到了，已经将属性值加载到内存当中了
    UmountSecondStageRes();

    // Umount the debug ramdisk after property service has read the .prop files when it means to.
    // 若是debug版本，已经获取了属性值过后，也将卸载/debug_ramdisk
    if (load_debug_prop) &#123;
        UmountDebugRamdisk();
    &#125;

    // 挂载第二阶段（该阶段）的文件系统,第一阶段已经挂载了很多基本的文件系统了以及重要的分区
    // 挂载/apex：简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题
    // setup 3
    MountExtraFilesystems();
    ...
    // 之前初始化了属性服务，这里将开始属性服务，其实它就是一个socket
    // 创建socket,处理客户端发来的请求，决定是更新属性值还是新增属性值
    // setup 4
    StartPropertyService(&amp;property_fd);
    ...
    // 根据ro.vndk.version 版本号，将/system/vendor_overlay和/product/vendor_overlay挂载在vendor上
    // 也就是会覆盖vendor分区内容
    // setup 5
    fs_mgr_vendor_overlay_mount_all();
    // 根据ro.oem_unlock_supported属性值来决定是否可以对设备进行unlock（解锁）
    // 若ro.oem_unlock_supported：「1」则代表 设备支持刷写unlock,若不支持该值为0
    // 如果设备支持刷写解锁，ro.boot.verifiedbootstate则会为orange，根据orange状态，把androidboot.flash.locked设置为1
    // 如果设备不支持刷新解锁，ro.boot.verifiedbootstate则会为green，根据orange状态，把androidboot.flash.locked设置为0
    // androidboot.flash.locked在系统启动完成后会形成属性值
    // （或 /firmware/android/flash.locked DT 属性）设置为“1”（如果已锁定）或“0”（如果已解锁）来指示锁定状态。
    export_oem_lock_status();
    // 持续监控/proc/mounts 节点(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;)),主要是解析该文件
    // 解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等(空格分割/dev/block/dm-33 /mnt/pass_through/0/emulated ext4 rw)
    // 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息
    // setup 6
    MountHandler mount_handler(&amp;epoll);
    ...
    // 将根目录下所有的目录设置为全局共享
    // 将根目录/&#123;分区&#125;类型设置为共享，以便默认情况下所有进程都可以看到任何装载事件（例如/data）
    if (!SetupMountNamespaces()) &#123;
        PLOG(FATAL) &lt;&lt; &quot;SetupMountNamespaces failed&quot;;
    &#125;

    ...
    // setup 7
    // 创建ActionManager对象和ServiceList对象
    ActionManager&amp; am = ActionManager::GetInstance();
    ServiceList&amp; sm = ServiceList::GetInstance();
    // 加载rc文件，保存到action manager和service list中
    // rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析
    // 主要解析rc中的：service，on,Import,包含了zygote.rc,路径：/system/bin/app_process64
    // 在文件系统挂载的第一阶段，system/vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载
    // 后面主要分析一下on early-init和on init和zygote
    LoadBootScripts(am, sm);
    ...
    // setup 8
    // 构建action和触发器(on early-init)，放到event_queue，等待执行函数
    am.QueueBuiltinAction(SetupCgroupsAction, &quot;SetupCgroups&quot;);
    am.QueueBuiltinAction(SetKptrRestrictAction, &quot;SetKptrRestrict&quot;);
    am.QueueBuiltinAction(TestPerfEventSelinuxAction, &quot;TestPerfEventSelinux&quot;);
    am.QueueEventTrigger(&quot;early-init&quot;);

    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...
    am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);
    // ... so that we can start queuing up actions that require stuff from /dev.
    am.QueueBuiltinAction(SetMmapRndBitsAction, &quot;SetMmapRndBits&quot;);
    Keychords keychords;
    am.QueueBuiltinAction(
            [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123;
                for (const auto&amp; svc : ServiceList::GetInstance()) &#123;
                    keychords.Register(svc-&gt;keycodes());
                &#125;
                keychords.Start(&amp;epoll, HandleKeychord);
                return &#123;&#125;;
            &#125;,
            &quot;KeychordInit&quot;);

    // Trigger all the boot actions to get us started.
    // 构建action和触发器(on init)，放到event_queue，等待执行函数
    am.QueueEventTrigger(&quot;init&quot;);

    // Don&#39;t mount filesystems or start core system services in charger mode.
    // 如果是充电模式则不需要挂载文件系统和不要启动核心服务
    std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;);
    if (bootmode == &quot;charger&quot;) &#123;
        am.QueueEventTrigger(&quot;charger&quot;);
    &#125; else &#123;
        am.QueueEventTrigger(&quot;late-init&quot;);
    &#125;

    // Run all property triggers based on current state of the properties.
    // 运行所有属性触发器(action)，例如 on property
    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);

    // Restore prio before main loop
    // 设置进程优先级，主进程不能被销毁和退出，循环处理rc中的服务相关
    setpriority(PRIO_PROCESS, 0, 0);
    while (true) &#123;
        // By default, sleep until something happens.
        auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;;

        auto shutdown_command = shutdown_state.CheckShutdown();
        if (shutdown_command) &#123;
            LOG(INFO) &lt;&lt; &quot;Got shutdown_command &#39;&quot; &lt;&lt; *shutdown_command
                      &lt;&lt; &quot;&#39; Calling HandlePowerctlMessage()&quot;;
            HandlePowerctlMessage(*shutdown_command);
            shutdown_state.set_do_shutdown(false);
        &#125;

        if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;
            // 执行队列中的action
            // 队列中依次执行每个action中携带command对应的执行函数
            am.ExecuteOneCommand();
        &#125;
        if (!IsShuttingDown()) &#123;
            // 处理sm（ServiceList）中服务超时重启相关（init.rc中的service）
            auto next_process_action_time = HandleProcessActions();
            if (next_process_action_time) &#123;
                epoll_timeout = std::chrono::ceil&lt;std::chrono::milliseconds&gt;(
                        *next_process_action_time - boot_clock::now());
                if (*epoll_timeout &lt; 0ms) epoll_timeout = 0ms;
            &#125;
        &#125;
...

    return 0;
&#125;
</code></pre>
<h4 id="2-SecondStageMain-int-argc-char-argv-—–-gt-setup-1步骤"><a href="#2-SecondStageMain-int-argc-char-argv-—–-gt-setup-1步骤" class="headerlink" title="2. SecondStageMain(int argc, char** argv)—–&gt;setup 1步骤"></a>2. SecondStageMain(int argc, char** argv)—–&gt;setup 1步骤</h4><p>先贴一下setup 1的代码块，主要分析<code>UmountDebugRamdisk</code>函数</p>
<pre><code>    if (!load_debug_prop) &#123;
        // setup 1
        UmountDebugRamdisk();
    &#125;
    
static void UmountDebugRamdisk() &#123;
    if (umount(&quot;/debug_ramdisk&quot;) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Failed to umount /debug_ramdisk&quot;;
    &#125;
&#125;    
</code></pre>
<p>如果设备未unlock，则卸载关于debug版本的&#x2F;debug_ramdisk,让属性值读取&#x2F;ramdisk而不是&#x2F;debug_ramdisk</p>
<h4 id="3-SecondStageMain-int-argc-char-argv-—–-gt-setup-2步骤"><a href="#3-SecondStageMain-int-argc-char-argv-—–-gt-setup-2步骤" class="headerlink" title="3. SecondStageMain(int argc, char** argv)—–&gt;setup 2步骤"></a>3. SecondStageMain(int argc, char** argv)—–&gt;setup 2步骤</h4><p>该步骤主要作用是初始化属性值服务，这里只是一个初始化的动作</p>
<pre><code>    // setup 2
    PropertyInit();
</code></pre>
<ul>
<li><p>初始化属性服务，获取<code>system/build.prop</code>,<code>vendor/build.prop</code>,<code>/odm/build.prop</code>,<code>/product/build.prop</code>,等其他build.prop并加载到properties map结构中，然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值，注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖</p>
</li>
<li><p><code>PropertyInit</code>位于<code>/system/core/init/property_service.cpp</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void PropertyInit() &#123;</span><br><span class="line">   ...</span><br><span class="line">    // 建立属性服务设备文件（linux思想，万物皆文件系统）</span><br><span class="line">    mkdir(&quot;/dev/__properties__&quot;, S_IRWXU | S_IXGRP | S_IXOTH);</span><br><span class="line">    // 创建序列化过后的propertyInfo实体，主要就是读取property_contexts文件</span><br><span class="line">    CreateSerializedPropertyInfo();</span><br><span class="line">    // 这里主要步骤是：通过mmap映射，将文件（/dev/__properties__/&#123;..&#125;）映射进内存（初始化属性内存映射文件）</span><br><span class="line">    // 这里将文件映射进内存，用于后续对__prooerties__目录（也可以说是文件，将代码块映射为file类型）进行内存共享</span><br><span class="line">    if (__system_property_area_init()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Failed to initialize property area&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 加载/dev/__properties__/property_info，此文件是序列化过的，无法直接查看内容</span><br><span class="line">    if (!property_info_area.LoadDefaultPath()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Failed to load serialized property info file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取/proc/device-tree/firmware/android/目录下的文件，生成ro.boot.xxx属性值</span><br><span class="line">    // 这三个函数主要就是生成ro.boot.xx属性值，这里不详细研究</span><br><span class="line">    ProcessKernelDt();</span><br><span class="line">    ProcessKernelCmdline();</span><br><span class="line">    ProcessBootconfig();</span><br><span class="line"></span><br><span class="line">    // 初始化ro.xx,将ro.boot.xx的属性值复制给ro.xxx</span><br><span class="line">    // &#123; &quot;ro.boot.serialno&quot;,   &quot;ro.serialno&quot;,   UNSET, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.mode&quot;,       &quot;ro.bootmode&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.baseband&quot;,   &quot;ro.baseband&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.bootloader&quot;, &quot;ro.bootloader&quot;, &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.hardware&quot;,   &quot;ro.hardware&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">    // &#123; &quot;ro.boot.revision&quot;,   &quot;ro.revision&quot;,   &quot;0&quot;, &#125;,</span><br><span class="line">    ExportKernelBootProps();</span><br><span class="line"></span><br><span class="line">    // 读取&#123;system/vendor/odm/product&#125;/build.prop等...</span><br><span class="line">    // 将build.prop通过MMAP映射到全局内存中，供所有进程访问 </span><br><span class="line">    PropertyLoadBootDefaults();</span><br></pre></td></tr></table></figure>

<p>调用<code>__system_property_area_init</code>通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=mmap&spm=1001.2101.3001.7020">mmap</a>映射，将文件（&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;{包含了上下文和propertys_info实体：保存了property_contexts文件内容}）映射进内存（初始化属性内存映射文件）， 这里将文件映射进内存，用于后续对__prooerties__目录（也可以说是文件，将代码块映射为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=file%E7%B1%BB&spm=1001.2101.3001.7020">file类</a>型）进行内存共享</p>
</li>
<li><p>CreateSerializedPropertyInfo：</p>
<p>创建序列化过后的属性值信息（既然序列化了，那肯定是要跨进程通信）<br>(1).读取{system_ext，vendor,product,odm,system}_property_contexts属性值安全上下文并赋值给：property_infos<br>(2).property_infos属于容器类型，读取不同的property_contexts将会追加到末尾，而不是覆盖原本内容<br>(3).将property_infos实体序列化，使其可以跨进程传递消息<br>(4).将property_infos实体写入&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;property_info驱动节点中</p>
</li>
<li><p>PropertyLoadBootDefaults<br>这里会将属性值全部写入build.prop里，分为：system&#x2F;build.prop,vendor&#x2F;build.prop,&#x2F;odm&#x2F;build.prop,&#x2F;product&#x2F;build.prop，注意是有优先级顺序的，按先后顺序覆盖,获取build.prop分别是直接从指定文件里获取和从指定分区中获取，这两个方式作用都一样，只不过第二种需要区分出分区里是否存在<code>&#123;partition&#125;/&#123;etc&#125;/build.prop</code>,有的分区是不存在<code>&#123;partition&#125;/etc/build.prop</code>这个文件，而是直接存在于<code>&#123;partition&#125;/build.prop</code></p>
</li>
</ul>
<p>一切都写到了注释里，继续分析比较重要的2个函数<code>CreateSerializedPropertyInfo</code>和<code>PropertyLoadBootDefaults</code></p>
<h6 id="3-1-CreateSerializedPropertyInfo"><a href="#3-1-CreateSerializedPropertyInfo" class="headerlink" title="3.1 CreateSerializedPropertyInfo"></a>3.1 CreateSerializedPropertyInfo</h6><pre><code>void CreateSerializedPropertyInfo() &#123;
    auto property_infos = std::vector&lt;PropertyInfoEntry&gt;();
    //判断文件是否存在，并判断文件是否可写(属性服务的安全上下文，之前有提过设备节点，服务，属性值都要遵守selinux规则)
    if (access(&quot;/system/etc/selinux/plat_property_contexts&quot;, R_OK) != -1) &#123;
        // 加载property_contexts文件，该文件内容都是配置的属性值上下文，属于selinux相关知识
        // 通过ParsePropertyInfoFile解析该文件，得到property_infos
        if (!LoadPropertyInfoFromFile(&quot;/system/etc/selinux/plat_property_contexts&quot;,
                                      &amp;property_infos)) &#123;
            return;
        &#125;
        // 如果这里system_ext/vendor/product没有挂载上（例如在恢复的情况下，vendor分区将不会安装），则无法继续加载该上下文，该分区会在第一阶段挂载
        // 从下面的代码可以看出来，property_infos的是容器类型vector&lt;PropertyInfoEntry&gt;()
        // 所以这里并没有优先级也没有以哪个property_contexts为准，而是根据是否存在对应的分区而append加载
        // 也就是在对应后面追加内容，而不是覆盖：property_infos-&gt;emplace_back(property_info_entry);
        if (access(&quot;/system_ext/etc/selinux/system_ext_property_contexts&quot;, R_OK) != -1) &#123;
            LoadPropertyInfoFromFile(&quot;/system_ext/etc/selinux/system_ext_property_contexts&quot;,
                                     &amp;property_infos);
        &#125;
        if (!LoadPropertyInfoFromFile(&quot;/vendor/etc/selinux/vendor_property_contexts&quot;,
                                      &amp;property_infos)) &#123;
            // Fallback to nonplat_* if vendor_* doesn&#39;t exist.
            LoadPropertyInfoFromFile(&quot;/vendor/etc/selinux/nonplat_property_contexts&quot;,
                                     &amp;property_infos);
        &#125;
        if (access(&quot;/product/etc/selinux/product_property_contexts&quot;, R_OK) != -1) &#123;
            LoadPropertyInfoFromFile(&quot;/product/etc/selinux/product_property_contexts&quot;,
                                     &amp;property_infos);
        &#125;
        if (access(&quot;/odm/etc/selinux/odm_property_contexts&quot;, R_OK) != -1) &#123;
            LoadPropertyInfoFromFile(&quot;/odm/etc/selinux/odm_property_contexts&quot;, &amp;property_infos);
        &#125;
     // 若/system/etc/selinux/plat_property_contexts无法读取，则else
    &#125; else &#123;
        // 由于system下的安全上下文未创建，则可能是system出现异常未挂载上，或者供应商修改过plat_property_contexts
        // 一般供应商都是复写，而不会直接更改文件名称
        // 若找不到该文件，则加载根目录下的这些属性值安全上下文
        if (!LoadPropertyInfoFromFile(&quot;/plat_property_contexts&quot;, &amp;property_infos)) &#123;
            return;
        &#125;
        LoadPropertyInfoFromFile(&quot;/system_ext_property_contexts&quot;, &amp;property_infos);
        if (!LoadPropertyInfoFromFile(&quot;/vendor_property_contexts&quot;, &amp;property_infos)) &#123;
            // Fallback to nonplat_* if vendor_* doesn&#39;t exist.
            LoadPropertyInfoFromFile(&quot;/nonplat_property_contexts&quot;, &amp;property_infos);
        &#125;
        LoadPropertyInfoFromFile(&quot;/product_property_contexts&quot;, &amp;property_infos);
        LoadPropertyInfoFromFile(&quot;/odm_property_contexts&quot;, &amp;property_infos);
    &#125;

    // 序列化property_infos实体，使其可以跨进程传递
    auto serialized_contexts = std::string();
    auto error = std::string();
    if (!BuildTrie(property_infos, &quot;u:object_r:default_prop:s0&quot;, &quot;string&quot;, &amp;serialized_contexts,
                   &amp;error)) &#123;
        LOG(ERROR) &lt;&lt; &quot;Unable to serialize property contexts: &quot; &lt;&lt; error;
        return;
    &#125;
</code></pre>
<p>​<br>​        &#x2F;&#x2F; 将property_infos写入&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;property_info设备文件中<br>​        constexpr static const char kPropertyInfosPath[] &#x3D; “&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;property_info”;<br>​        if (!WriteStringToFile(serialized_contexts, kPropertyInfosPath, 0444, 0, 0, false)) {<br>​            PLOG(ERROR) &lt;&lt; “Unable to write serialized property infos to file”;<br>​        }<br>​        selinux_android_restorecon(kPropertyInfosPath, 0);<br>​    }</p>
<p>  以上的步骤都是对property_infos变量进行赋值，数据就是property_contexts文件内容，而property_infos是属于vector&lt;**PropertyInfoEntry**&gt;()容器类型,而每次加载property_infos时都是调用的<code>property_infos-&gt;emplace_back(property_info_entry);</code>在容器后面追加数据，不会覆盖原有的数据</p>
<blockquote>
<p>读取property_contexts文件内容，将内容传递给property_infos实体</p>
</blockquote>
<h6 id="3-2-PropertyLoadBootDefaults"><a href="#3-2-PropertyLoadBootDefaults" class="headerlink" title="3.2 PropertyLoadBootDefaults"></a>3.2 PropertyLoadBootDefaults</h6><pre><code>void PropertyLoadBootDefaults() &#123;
    std::map&lt;std::string, std::string&gt; properties;
    // 如果是恢复模式则加载/prop.default
    if (IsRecoveryMode()) &#123;
        load_properties_from_file(&quot;/prop.default&quot;, nullptr, &amp;properties);
    &#125;

    // 这里还没执行，只是一个未执行的代码块，从分区里读取build.prop文件
    const auto load_properties_from_partition = [&amp;properties](const std::string&amp; partition,
                                                              int support_legacy_path_until) &#123;
        // 加载&#123;system_ext,product等分区&#125;/etc/build.prop文件
        // 以后代码上获取的属性值就是从该文件中获取的
        auto path = &quot;/&quot; + partition + &quot;/etc/build.prop&quot;;
        if (load_properties_from_file(path.c_str(), nullptr, &amp;properties)) &#123;
            return;
        &#125;
        ...
    &#125;
    // 获取第一阶段生成的second_stage_resources/system/etc/ramdisk/build.prop
    // 并追加到properties中（这里是map结构，注意会覆盖内容）
    LoadPropertiesFromSecondStageRes(&amp;properties);
    // 先读取的/system/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/system/build.prop&quot;, nullptr, &amp;properties);
    // 获取/system_ext分区下的build.prop/default.prop，赋值给然后赋值给propertiess（这里是map结构，注意会覆盖内容）
    load_properties_from_partition(&quot;system_ext&quot;, /* support_legacy_path_until */ 30);
     // 继续读取的/vendor/default.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/vendor/default.prop&quot;, nullptr, &amp;properties);
    // &#125;
    // 继续读取的/vendor/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/vendor/build.prop&quot;, nullptr, &amp;properties);
    // 继续读取的/vendor_dlkm/etc/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/vendor_dlkm/etc/build.prop&quot;, nullptr, &amp;properties);
    // 继续读取的/odm_dlkm/etc/build.prop，然后赋值给properties（这里是map结构，注意会覆盖内容）
    load_properties_from_file(&quot;/odm_dlkm/etc/build.prop&quot;, nullptr, &amp;properties);
    // 获取/&#123;odm,product&#125;.prop/default.prop，赋值给然后赋值给propertiess（这里是map结构，注意会覆盖内容）
    load_properties_from_partition(&quot;odm&quot;, /* support_legacy_path_until */ 28);
    load_properties_from_partition(&quot;product&quot;, /* support_legacy_path_until */ 30);
    // 因为propertiess是map结构，如果key一样则会覆盖内容,所以以上代码的顺序不能调换，优先级最高的是/product下的build.prop
    // /system-&gt;/system_ext-&gt;/vendor-&gt;/omd-&gt;/product

    // 如果&quot;/debug_ramdisk/adb_debug.prop&quot;存在，说明设备已经unlock过了，则加载unlock过后的属性值，例如ro.debugger=1,则是开启了调试模式
    if (access(kDebugRamdiskProp, R_OK) == 0) &#123;
        LOG(INFO) &lt;&lt; &quot;Loading &quot; &lt;&lt; kDebugRamdiskProp;
        load_properties_from_file(kDebugRamdiskProp, nullptr, &amp;properties);
    &#125;

    // 将从build.prop,default.prop获取的properties，循环设置属性值
    // 这里是把.prop文件里的属性值通过mmap映射到内存中，使得所有进程可以访问（全局）
    for (const auto&amp; [name, value] : properties) &#123;
        std::string error;
        // 如果是ro则是只读，只能设置一次，再次设置会无效，如果存在相同的key,则会调用update更新
        if (PropertySet(name, value, &amp;error) != PROP_SUCCESS) &#123;
            LOG(ERROR) &lt;&lt; &quot;Could not set &#39;&quot; &lt;&lt; name &lt;&lt; &quot;&#39; to &#39;&quot; &lt;&lt; value
                       &lt;&lt; &quot;&#39; while loading .prop files&quot; &lt;&lt; error;
        &#125;
    &#125;
    ...
    // 设置persist.sys.usb.config属性值来决定是否开启调试模式（adb或none）
    update_sys_usb_config();
&#125;
</code></pre>
<p>以上代码主要做的一个动作：读取各个分区里的build.prop或直接从指定目录下读取build.prop并调用<code>PropertySet</code>设置到全局内存中，让所有进程访问</p>
<p>主要的两个函数：<code>load_properties_from_partition</code>和<code>load_properties_from_file</code>，分别从分区里读取和从指定文件读取，为什么这么做呢？因为有的分区下是没有&#x2F;etc目录的，无法直接指定文件位置，所以通过调用 <code>&quot;/&quot; + partition + &quot;/etc/build.prop&quot;</code>来读取，若不存在该文件则直接return。<br>注意这里读取了{system,system_ext,vendor,vendor_dlkm,odm_dlkm,odm,product}&#x2F;build.prop,由于properties属于map结构，如果key相同是会覆盖原有的值，所以这里是有优先级排序的：</p>
<ol>
<li>&#x2F;system&#x2F;build.prop</li>
<li>&#x2F;system_ext&#x2F;{etc}&#x2F;build.prop</li>
<li>&#x2F;vendor&#x2F;default.prop</li>
<li>&#x2F;vendor&#x2F;build.prop</li>
<li>&#x2F;vendor_dlkm&#x2F;etc&#x2F;build.prop</li>
<li>&#x2F;odm_dlkm&#x2F;etc&#x2F;build.prop</li>
<li>&#x2F;odm&#x2F;{etc}&#x2F;build.prop</li>
<li>&#x2F;product&#x2F;{etc}&#x2F;build.prop</li>
</ol>
<blockquote>
<p>如果在system中自定义了属性值，又在product自定义了一样的属性值，那么是以product为准</p>
</blockquote>
<p>这里只是init初始化过程，读取build.prop并解析出来每一行属性值并调用<code>PropertySet</code>设置到全局内存中</p>
<p>继续分析一下<code>PropertySet</code>函数，该函数比较简单</p>
<pre><code>static uint32_t PropertySet(const std::string&amp; name, const std::string&amp; value, std::string* error) &#123;
    ...
    // 找到该属性值
    prop_info* pi = (prop_info*) __system_property_find(name.c_str());
    if (pi != nullptr) &#123;
        // 如果是以ro开头则代表只读，禁止写入，返回error
        if (StartsWith(name, &quot;ro.&quot;)) &#123;
            *error = &quot;Read-only property was already set&quot;;
            return PROP_ERROR_READ_ONLY_PROPERTY;
        &#125;
        // 若存在该属性值且非ro 则更新属性值
        __system_property_update(pi, value.c_str(), valuelen);
    &#125; else &#123;
        // 若找不到该属性值则新增
        int rc = __system_property_add(name.c_str(), name.size(), value.c_str(), valuelen);
        if (rc &lt; 0) &#123;
            *error = &quot;__system_property_add failed&quot;;
            return PROP_ERROR_SET_FAILED;
        &#125;
    &#125;

    // 如果是以persist.开头，则会全部写进/data/property/persistent_properties
    // 属于一个缓存机制
    // std::string persistent_property_filename = &quot;/data/property/persistent_properties&quot;;
    if (persistent_properties_loaded &amp;&amp; StartsWith(name, &quot;persist.&quot;)) &#123;
        WritePersistentProperty(name, value);
    &#125;
    ...
    return PROP_SUCCESS;
&#125;
</code></pre>
<p>以上代码就是若存在属性值则更新，若不存在则新增。如果是ro开头的属性值则代表只读，只能初始化的时候给默认值，后续不允许修改值，如果是persist开头的则会全部缓存进<code>/data/property/persistent_properties</code>，persist开头的属性值是可改的，如果用户修改过了persist开头的属性值相当于修改了<code>/data/property/persistent_properties</code>里的属性值，那么重启后仍然生效，并不会还原默认值。这样即不影响属性值的原子性（原有的属性值），又给了开发者&#x2F;用户操作的空间，如果是刷机或恢复出厂则会还原</p>
<p>如果是系统开发者自定义了属性值，但是发现默认定义的时候属性值无法写入，则可能是property_contexts安全上下文影响，可以直接修改这里的代码，<code>__system_property_add</code>强行调用该方法即可</p>
<h4 id="4-SecondStageMain-int-argc-char-argv-—–-gt-setup-3步骤"><a href="#4-SecondStageMain-int-argc-char-argv-—–-gt-setup-3步骤" class="headerlink" title="4. SecondStageMain(int argc, char** argv)—–&gt;setup 3步骤"></a>4. SecondStageMain(int argc, char** argv)—–&gt;setup 3步骤</h4><pre><code>setup 4
MountExtraFilesystems();

static void MountExtraFilesystems() &#123;
#define CHECKCALL(x) \
    if ((x) != 0) PLOG(FATAL) &lt;&lt; #x &quot; failed.&quot;;

    // /apex is used to mount APEXes
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/apex&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));

    // /linkerconfig is used to keep generated linker configuration
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/linkerconfig&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));
#undef CHECKCALL
&#125;
</code></pre>
<p>可以看到<code>MountExtraFilesystems</code>主要就挂载了&#x2F;apex和&#x2F;linkerconfig并归属于tmpfs文件系统（运行在内存的文件系统，运行速度较快）,这里主要探讨一下APEX.<br>应用程序可以通过更新APK来升级，供应商客制化系统后可以通过OTA进行系统升级，而针对google 开发者来修复原生的系统bug该如何更新呢？那就是通过google发布的安全patch和更新manline以及apex来解决</p>
<ul>
<li>简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题</li>
<li>apex可以将系统内部的各个功能打包成模块，然后针对这些模块单独升级</li>
<li>apk是应用程序的载体，对应用开发者而言，可以apk方式对应用功能进行升级</li>
<li>apex是系统功能的载体，对系统开发者（目前看主要是谷歌）而言，可以apex方式对系统功能进行升级</li>
<li>一般是google开发者通过playstore发布，然后供我们下载更新，而对应ODM第三方供应商，则需要通过OTA升级</li>
<li>apex相当于对系统功能进行了更细粒度的划分，可以独立升级这些功能，可以把apex看成是一个一个的系统升级包</li>
</ul>
<h4 id="5-SecondStageMain-int-argc-char-argv-—–-gt-setup-4步骤"><a href="#5-SecondStageMain-int-argc-char-argv-—–-gt-setup-4步骤" class="headerlink" title="5. SecondStageMain(int argc, char** argv)—–&gt;setup 4步骤"></a>5. SecondStageMain(int argc, char** argv)—–&gt;setup 4步骤</h4><pre><code>    // setup 4
    StartPropertyService(&amp;property_fd);
</code></pre>
<p>在setup2中初始化了property,获取了build.prop和property_contexts并设置为内存中全局共享</p>
<pre><code>void StartPropertyService(int* epoll_socket) &#123;
    // 在init阶段version=1,这里已经升级到2了
    InitPropertySet(&quot;ro.property_service.version&quot;, &quot;2&quot;);

    // 创建sockets,套接字,可以用于网络通信，也可以用于本机内的进程通信
    // socketpair()函数用于创建一对无名的,相互连接的套接字
    // 如果函数创建成功,则返回0,创建好的套接字分别是sv[0]和sv[1];否则返回-1
    int sockets[2];
    // 参数1：表示协议族AF_UNIX
    // 参数2：表示协议，SOCK_SEQPACKET提供连续可靠的数据包连接
    // SOCK_CLOEXEC：当文件描述符设置了O_CLOEXEC属性后，在调用exec函数族时，文件描述符就会自动关闭，无需手动关闭
    // 而SOCK_DGRAM是基于UDP的
    // 参数3：表示类型，只能为0
    // 参数4：套节字柄，该两个句柄作用相同，均能进行读写双向操作
    if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sockets) != 0) &#123;
        PLOG(FATAL) &lt;&lt; &quot;Failed to socketpair() between property_service and init&quot;;
    &#125;
    ...
    // PROP_SERVICE_NAME：/dev/socket/property_service，创建socket
    if (auto result = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
                                   false, 0666, 0, 0, &#123;&#125;);
        result.ok()) &#123;
        property_set_fd = *result;
    &#125; else &#123;
        LOG(FATAL) &lt;&lt; &quot;start_property_service socket creation failed: &quot; &lt;&lt; result.error();
    &#125;

    // 监听socket:/dev/socket/property_service,最大连接：8
    listen(property_set_fd, 8);

    // 开启线程处理socket
    auto new_thread = std::thread&#123;PropertyServiceThread&#125;;
    property_service_thread.swap(new_thread);
&#125;
</code></pre>
<p>这里就是创建了socket,而属性值服务的本质就是一个socket（&#x2F;dev&#x2F;socket&#x2F;property_service）,最大连接为：8，持续等待连接,连接成功后决定是更新还是新增属性值，仍然是调用的<code>PropertySet</code>，继续分析一下<code>PropertyServiceThread</code>，该函数里调用了<code>handle_property_set_fd</code>函数，来看看具体实现</p>
<pre><code>static void handle_property_set_fd() &#123;
    // 设置超时:2s
    static constexpr uint32_t kDefaultSocketTimeout = 2000; /* ms */

    // 可以设置四个参数，所以用的是accept4,而当启用了SOCK_CLOEXEC参数后，进程在调用exec函数族时，文件描述符就会自动关闭，无需手动关闭
    int s = accept4(property_set_fd, nullptr, nullptr, SOCK_CLOEXEC);
    if (s == -1) &#123;
        return;
    &#125;
    ...
    
    switch (cmd) &#123;
    case PROP_MSG_SETPROP: &#123;
        char prop_name[PROP_NAME_MAX];
        char prop_value[PROP_VALUE_MAX];
        ...
        prop_name[PROP_NAME_MAX-1] = 0;
        prop_value[PROP_VALUE_MAX-1] = 0;
        ...
        // 当收到客户端发来的请求，去更新或新增属性值时会调用HandlePropertySet去处理
        const auto&amp; cr = socket.cred();
        std::string error;
        uint32_t result =
                HandlePropertySet(prop_name, prop_value, source_context, cr, nullptr, &amp;error);
        if (result != PROP_SUCCESS) &#123;
            LOG(ERROR) &lt;&lt; &quot;Unable to set property &#39;&quot; &lt;&lt; prop_name &lt;&lt; &quot;&#39; from uid:&quot; &lt;&lt; cr.uid
                       &lt;&lt; &quot; gid:&quot; &lt;&lt; cr.gid &lt;&lt; &quot; pid:&quot; &lt;&lt; cr.pid &lt;&lt; &quot;: &quot; &lt;&lt; error;
        &#125;

        break;
      &#125;
     ...
    &#125;
&#125;
</code></pre>
<p>可以看到设置了连接超时时间为2000ms,执行 <code>case PROP_MSG_SETPROP</code>，获取属性值的名称和值，调用<code>HandlePropertySet</code>里的<code>PropertySet</code>进行更新属性值或新增。<code>PropertySet</code>已经分析过了</p>
<blockquote>
<p>至此属性值相关就分析完毕了，简单的来说就是读取build.prop属性值共享到全局内存中让所有进程获取，然后创建属性值服务（socket），持续监听客户端（哪个进程去调用更新属性值就是当前客户端）发来的请求，最大只能同时受理8个来自客户端的请求，若有客户端请求则去更新属性值或新增属性值</p>
</blockquote>
<h4 id="6-SecondStageMain-int-argc-char-argv-—–-gt-setup-5步骤"><a href="#6-SecondStageMain-int-argc-char-argv-—–-gt-setup-5步骤" class="headerlink" title="6. SecondStageMain(int argc, char** argv)—–&gt;setup 5步骤"></a>6. SecondStageMain(int argc, char** argv)—–&gt;setup 5步骤</h4><pre><code>    // setup 5
    fs_mgr_vendor_overlay_mount_all();
</code></pre>
<p>这里的代码只要是针对如果有vendor_overlay分区，则覆盖&#x2F;vendor分区，主要看供应商的客制化</p>
<pre><code>const std::vector&lt;const std::string&gt; kVendorOverlaySourceDirs = &#123;
        &quot;/system/vendor_overlay/&quot;,
        &quot;/product/vendor_overlay/&quot;,
&#125;;

bool fs_mgr_vendor_overlay_mount_all() &#123;
    ...
    // 获取 &quot;/system/vendor_overlay/&quot;,&quot;/product/vendor_overlay/&quot;下的所有子目录
    // 将vendor_overlay挂载到vendor上，若存在该覆盖分区则会覆盖之前的vendor分区
    const auto vendor_overlay_dirs = fs_mgr_get_vendor_overlay_dirs(vndk_version);
    if (vendor_overlay_dirs.empty()) return true;
    if (fs_mgr_overlayfs_valid() == OverlayfsValidResult::kNotSupported) &#123;
        LINFO &lt;&lt; &quot;vendor overlay: kernel does not support overlayfs&quot;;
        return false;
    &#125;

    // Mount each directory in /(system|product)/vendor_overlay/&lt;ver&gt; on /vendor
    // 挂载vendor_overlay到/vendor分区上
    auto ret = true;
    for (const auto&amp; vendor_overlay_dir : vendor_overlay_dirs) &#123;
        if (!fs_mgr_vendor_overlay_mount(vendor_overlay_dir)) &#123;
            ret = false;
        &#125;
    &#125;
    return ret;
&#125;
</code></pre>
<h4 id="7-SecondStageMain-int-argc-char-argv-—–-gt-setup-6步骤"><a href="#7-SecondStageMain-int-argc-char-argv-—–-gt-setup-6步骤" class="headerlink" title="7. SecondStageMain(int argc, char** argv)—–&gt;setup 6步骤"></a>7. SecondStageMain(int argc, char** argv)—–&gt;setup 6步骤</h4><pre><code>    // setup 6
    MountHandler mount_handler(&amp;epoll);
</code></pre>
<p>该函数主要功能：持续监控<code>/proc/mounts</code> 节点<code>(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;))</code>,主要是解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等， 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息，挂载mounts信息里的分区<br>位置：&#x2F;system&#x2F;core&#x2F;init&#x2F;mount_handler.cpp</p>
<pre><code>MountHandler::MountHandler(Epoll* epoll) : epoll_(epoll), fp_(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;), fclose) &#123;
    if (!fp_) PLOG(FATAL) &lt;&lt; &quot;Could not open /proc/mounts&quot;;
    auto result = epoll-&gt;RegisterHandler(
            fileno(fp_.get()), [this]() &#123; this-&gt;MountHandlerFunction(); &#125;, EPOLLERR | EPOLLPRI);
    if (!result.ok()) LOG(FATAL) &lt;&lt; result.error();
&#125;
</code></pre>
<p>继续看一下<code>MountHandlerFunction</code>函数</p>
<pre><code>void MountHandler::MountHandlerFunction() &#123;
    rewind(fp_.get());
    std::vector&lt;MountHandlerEntry&gt; touched;
    auto untouched = mounts_; //容器类型
    char* buf = nullptr;
    size_t len = 0;
    // 循环读取文件内容中的每一行
    while (getline(&amp;buf, &amp;len, fp_.get()) != -1) &#123;
        auto buf_string = std::string(buf);
        // /proc/mounts文件下存在一系列代码
        // 若读取到/0/emulated则跳过
        if (buf_string.find(&quot;/emulated&quot;) != std::string::npos) &#123;
            continue;
        &#125;
        // 根据读取的文件内容，来解析分区以及device path,type等
        auto entry = ParseMount(buf_string);
        auto match = untouched.find(entry);
        // 若这一行解析到底了仍然没有匹配的信息，则这一条记录追加到touched中
        // entry：举例---&gt;对文件内容/dev/block/dm-33 /data_mirror/data_ce/null ext4 解析过后的实体
        if (match == untouched.end()) &#123;
            touched.emplace_back(std::move(entry));
        &#125; else &#123;
            // 若找到了匹配的信息则移除
            untouched.erase(match);
        &#125;
    &#125;
    free(buf);
    // 将匹配到的entry进行移除，并记录Mount属性值
    for (auto&amp; entry : untouched) &#123;
        SetMountProperty(entry, false);
        mounts_.erase(entry);
    &#125;
    // 将未匹配到的entry追加到mounts_，并记录Mount属性值
    for (auto&amp; entry : touched) &#123;
        SetMountProperty(entry, true);
        // emplace是更具有性能的 更新或追加
        mounts_.emplace(std::move(entry));
    &#125;
&#125;
</code></pre>
<ol>
<li>读取&#x2F;proc&#x2F;mounts，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等</li>
<li>若解析到&#x2F;0&#x2F;emulated则跳过,不处理</li>
<li>根据mounts_，当entry（解析后的内容）可以在其中找到则移除</li>
<li>若entry未在mounts_找到，则追加到mounts_中</li>
<li>相当于移除旧的entry，将新的entry追加到mounts_</li>
</ol>
<p>再看看是如何解析文件内容的<code>auto entry = ParseMount(buf_string)</code>，解析文件内容</p>
<pre><code>MountHandlerEntry ParseMount(const std::string&amp; line) &#123;
    auto fields = android::base::Split(line, &quot; &quot;);
    while (fields.size() &lt; 3) fields.emplace_back(&quot;&quot;);
    if (fields[0] == &quot;/dev/root&quot;) &#123;
        auto&amp; dm = dm::DeviceMapper::Instance();
        std::string path;
        // 根据名称获取system分区目录路径，若根据名称找不到则直接获取根目录/
        // 若找到根目录则继续找/system,若找到则拿到device path
        // 例如/system就是挂载在/dev/block/dm-1上，那么获取的就是这个玩意
        // /dev/block/dm-3 /vendor ext4 ro,seclabel,relatime 0 0
        if (dm.GetDmDevicePathByName(&quot;system&quot;, &amp;path) || dm.GetDmDevicePathByName(&quot;vroot&quot;, &amp;path)) &#123;
            fields[0] = path;
        &#125; else if (android::fs_mgr::Fstab fstab; android::fs_mgr::ReadDefaultFstab(&amp;fstab)) &#123;
            auto entry = GetEntryForMountPoint(&amp;fstab, &quot;/&quot;);
            if (entry || (entry = GetEntryForMountPoint(&amp;fstab, &quot;/system&quot;))) &#123;
                fields[0] = entry-&gt;blk_device;
            &#125;
        &#125;
    &#125;
    // 获取所有/dev目录下的device
    // readlink 是Linux系统中的一个常用命令，主要用来找出符号链接所指向的位置
    // 也就是找到devcie path：/dev/block/dm-33
    if (android::base::StartsWith(fields[0], &quot;/dev/&quot;)) &#123;
        if (std::string link; android::base::Readlink(fields[0], &amp;link)) &#123;
            fields[0] = link;
        &#125;
    &#125;
    // fields0：/dev/block/dm-33（blk_device）
    // fields1:挂载在device上的分区/文件路径：/data_mirror/cur_profiles（mount_point）
    // fields2:该分区的type类型，例如可能是ext4（fs_type）
    return MountHandlerEntry(fields[0], fields[1], fields[2]);
&#125;
</code></pre>
<p>让我们再来看看这个文件内容<br><img src="/../../../images/3bc2180a2fae46178ec412f8b01cfdce.png" alt="在这里插入图片描述">可以看出来第一列是分区挂载的位置，第二列是哪个分区，第三列属于分区格式</p>
<h4 id="8-SecondStageMain-int-argc-char-argv-—–-gt-setup-7步骤"><a href="#8-SecondStageMain-int-argc-char-argv-—–-gt-setup-7步骤" class="headerlink" title="8. SecondStageMain(int argc, char** argv)—–&gt;setup 7步骤"></a>8. SecondStageMain(int argc, char** argv)—–&gt;setup 7步骤</h4><pre><code>    // setup 7
    // 创建ActionManager对象和ServiceList对象
    ActionManager&amp; am = ActionManager::GetInstance();
    ServiceList&amp; sm = ServiceList::GetInstance();
    // 解析rc文件
    LoadBootScripts(am, sm);
</code></pre>
<ul>
<li><p>加载rc文件，保存到action manager和service list中</p>
</li>
<li><p>rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析</p>
</li>
<li><p>主要解析rc中的：service，on,Import,包含了zygote.rc,路径：&#x2F;system&#x2F;bin&#x2F;app_process64</p>
</li>
<li><p>在文件系统挂载的第一阶段，system&#x2F;vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载</p>
</li>
<li><p>rc中action的执行顺序：<code>on early-init</code>，<code>on init</code>，<code>on late-init</code>，<code>on property</code></p>
<p>static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) {<br>&#x2F;&#x2F; 创建解析器,只解析init.rc文件中的service，on,Import类型<br>&#x2F;&#x2F; action 使用 ActionParser，而 service 使用 ServiceParser 解析<br>Parser parser &#x3D; CreateParser(action_manager, service_list);<br>&#x2F;&#x2F; 获取ro.boot.init_rc属性值,此时该属性值应该是空的<br>std::string bootscript &#x3D; GetProperty(“ro.boot.init_rc”, “”);<br>if (bootscript.empty()) {<br>    &#x2F;&#x2F; 解析&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc<br>    &#x2F;&#x2F; 这里的路径就是将&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc 拷贝到out目录下<br>    parser.ParseConfig(“&#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.rc”);<br>    …<br>} else {<br>    parser.ParseConfig(bootscript);<br>}<br>}</p>
<p>Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) {<br>Parser parser;<br><br>parser.AddSectionParser(“service”, std::make_unique<ServiceParser>(<br>                                           &amp;service_list, GetSubcontext(), std::nullopt));<br>parser.AddSectionParser(“on”, std::make_unique<ActionParser>(&amp;action_manager, GetSubcontext()));<br>parser.AddSectionParser(“import”, std::make_unique<ImportParser>(&amp;parser));<br><br>return parser;<br>}</p>
</li>
</ul>
<p>可以看到只需要解析init.rc文件中的service,on,import类型</p>
<h4 id="9-SecondStageMain-int-argc-char-argv-—–-gt-setup-8步骤"><a href="#9-SecondStageMain-int-argc-char-argv-—–-gt-setup-8步骤" class="headerlink" title="9. SecondStageMain(int argc, char** argv)—–&gt;setup 8步骤"></a>9. SecondStageMain(int argc, char** argv)—–&gt;setup 8步骤</h4><pre><code>    // setup 8
    // 构建action和触发器(on early-init)，放到event_queue，等待执行函数
   ...
    am.QueueEventTrigger(&quot;early-init&quot;);
    // 构建action和触发器(on init)，放到event_queue，等待执行函数
    am.QueueEventTrigger(&quot;init&quot;);
    // 如果是充电模式则不需要挂载文件系统和不要启动核心服务
    std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;);
    if (bootmode == &quot;charger&quot;) &#123;
        am.QueueEventTrigger(&quot;charger&quot;);
    &#125; else &#123;
        am.QueueEventTrigger(&quot;late-init&quot;);
    &#125;
    // 运行所有属性触发器(action)，例如 on property
    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);
</code></pre>
<p>把action加入队列中按顺序依次执行，继续一下rc文件中做了什么动作， rc中action的执行顺序：<code>on early-init</code>，<code>on init</code>，<code>on late-init</code>，<code>on nonencrypted（启动zygote）</code>，<code>on property</code></p>
<h6 id="9-1-on-early-init"><a href="#9-1-on-early-init" class="headerlink" title="9.1. on early-init"></a>9.1. on early-init</h6><pre><code>on early-init
   ...
    mkdir /acct/uid
    # 挂载linkerconfig（动态链接器）
    mount none /linkerconfig/bootstrap /linkerconfig bind rec
    # 启动ueventd(位于/system/bin/ueventd),ueventd是init启动的第一个进程
    start ueventd
    # memory.pressure_level used by lmkd
    chown root system /dev/memcg/memory.pressure_level
    chmod 0040 /dev/memcg/memory.pressure_level
    # app mem cgroups, used by activity manager, lmkd and zygote
    mkdir /dev/memcg/apps/ 0755 system system
    mkdir /dev/memcg/system 0550 system system
    mkdir /dev/net 0755 root root
    symlink ../tun /dev/net/tun
    ...
    # 挂载tracefs，可以通过指定方式到处trace日志，分析CPU和内存相关等问题
    mount tracefs tracefs /sys/kernel/tracing gid=3012

    # create sys dirctory
    # 创建/sys目录并指定权限
    mkdir /dev/sys 0755 system system
    mkdir /dev/sys/fs 0755 system system
    mkdir /dev/sys/block 0755 system system
</code></pre>
<p>可以看到针对<code>lmkd（Low Memory Killer Daemon）</code>以及app 创建用户组，创建目录，挂载tracefs：可以通过指定方式到处trace日志，分析CPU和内存相关等问题。<br>第一个启动的核心服务是：<code>start ueventd</code>，位于&#x2F;system&#x2F;bin&#x2F;ueventd,ueventd是init启动的第一个服务进程</p>
<h6 id="9-2-on-init"><a href="#9-2-on-init" class="headerlink" title="9.2. on init"></a>9.2. on init</h6><pre><code>on init
    ...
    chmod 0775 /dev/cpuset/system-background
    chmod 0664 /dev/cpuset/foreground/tasks
    chmod 0664 /dev/cpuset/background/tasks
    chmod 0664 /dev/cpuset/system-background/tasks
    chmod 0664 /dev/cpuset/top-app/tasks
    chmod 0664 /dev/cpuset/restricted/tasks
    chmod 0664 /dev/cpuset/tasks
    chmod 0664 /dev/cpuset/camera-daemon/tasks
    # 挂载bpf
    mount bpf bpf /sys/fs/bpf nodev noexec nosuid
    mkdir /dev/fscklogs 0770 root system    
    ...
    # 允许system组读写电源状态
    chown system system /sys/power/state
    chown system system /sys/power/wakeup_count
    chmod 0660 /sys/power/state
    ...
    # 在运行其他进程之前需要先启动log服务，说明init中启动的服务，第一个启动的进程是ueventd
    start logd
    # 启用 Low Memory Killer Daemon（lmkd）
    # 1.基于Memory的CGroup进行进程的回收；2.作为frameworks与kernel的沟通桥梁传递参数与信息
    # Start lmkd before any other services run so that it can register them
    chown root system /sys/module/lowmemorykiller/parameters/adj
    chmod 0664 /sys/module/lowmemorykiller/parameters/adj
    chown root system /sys/module/lowmemorykiller/parameters/minfree
    chmod 0664 /sys/module/lowmemorykiller/parameters/minfree
    start lmkd

    # Start essential services.
    # 启用ServiceManager,管理各个服务，非常重要
    start servicemanager
    start hwservicemanager
    start vndservicemanager
</code></pre>
<p>可以看到第二个启动的核心服务是：<code>start logd</code>，日志系统。<br>第三个核心服务是：<code>start lmkd</code>，Low Memory Killer Daemon<br><strong>作用</strong>：基于Memory的CGroup进行进程的回收，作为frameworks与kernel的沟通桥梁传递参数与信息。<br>接着启动了：<code>servicemanager</code>，<code>hwservicemanager</code>，<code>vndservicemanager</code>，这些都属于核心服务<br>若核心服务未启动成功，那么其他服务将无法启动，系统将无法启动，其他服务必须依赖核心服务</p>
<h6 id="9-3-on-late-init"><a href="#9-3-on-late-init" class="headerlink" title="9.3. on late-init"></a>9.3. on late-init</h6><pre><code># 装载文件系统并启动核心系统服务
on late-init
    trigger early-fs
    # 触发on fs和on post-fs
    trigger fs
    trigger post-fs
    trigger late-fs
    trigger post-fs-data
    trigger load_persist_props_action
    trigger load_bpf_programs
    trigger zygote-start
    trigger firmware_mounts_complete
    trigger early-boot
    trigger boot
</code></pre>
<p>可以看到调用顺序为：启动系统on late-init会先执行，然后继续触发on fs，on post-fs ，on late-fs，on zygote-start ，on boot等，在调用<code>on zygote-start</code>后会解析zygote服务并指定class 名称，然后加入服务管理队列，后续等待调用<code>on nonencrypted</code>来启动zygote服务</p>
<h6 id="9-4-on-nonencrypted"><a href="#9-4-on-nonencrypted" class="headerlink" title="9.4. on nonencrypted"></a>9.4. on nonencrypted</h6><pre><code>on nonencrypted
    class_start main
    class_start late_start

目录：/system/core/rootdir/init.zygote64.rc
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    # class : 给服务指定一个类属
    class main
    priority -20
    # user 在执行此服务之前先切换用户名。当前默认为root.
    user root
    # 切换组名
    group root readproc reserved_disk
    # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程
    # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为0
    socket zygote stream 660 root system
    socket usap_pool_primary stream 660 root system
    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
    # oneshot : 当此服务退出时不会自动重启.
    # disabled:服务不会自动运行，必须显式地通过服务器来启动
    # 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。
    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal
</code></pre>
<p>可以看到通过class_start main来启动主函数main,位于：frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</p>
<pre><code>int main(int argc, char* const argv[])
&#123;
    ...
    if (zygote) &#123;
        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);
    &#125; else if (className) &#123;
        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);
    &#125; else &#123;
        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);
        app_usage();
        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);
    &#125;
&#125;
</code></pre>
<p>这里启动了zygote,并且携带参数启动了systemServer，关于zygote这里就不再详细分析了</p>
<h2 id="二-附录"><a href="#二-附录" class="headerlink" title="二. 附录"></a>二. 附录</h2><p>rc文件中的command以及触发器，action等，对应的关系如下：</p>
<pre><code>static const BuiltinFunctionMap builtin_functions = &#123;
        &#123;&quot;bootchart&quot;,               &#123;1,     1,    &#123;false,  do_bootchart&#125;&#125;&#125;,
        &#123;&quot;chmod&quot;,                   &#123;2,     2,    &#123;true,   do_chmod&#125;&#125;&#125;,
        &#123;&quot;chown&quot;,                   &#123;2,     3,    &#123;true,   do_chown&#125;&#125;&#125;,
        &#123;&quot;class_reset&quot;,             &#123;1,     1,    &#123;false,  do_class_reset&#125;&#125;&#125;,
        &#123;&quot;class_reset_post_data&quot;,   &#123;1,     1,    &#123;false,  do_class_reset_post_data&#125;&#125;&#125;,
        &#123;&quot;class_restart&quot;,           &#123;1,     1,    &#123;false,  do_class_restart&#125;&#125;&#125;,
        &#123;&quot;class_start&quot;,             &#123;1,     1,    &#123;false,  do_class_start&#125;&#125;&#125;,
        &#123;&quot;class_start_post_data&quot;,   &#123;1,     1,    &#123;false,  do_class_start_post_data&#125;&#125;&#125;,
        &#123;&quot;class_stop&quot;,              &#123;1,     1,    &#123;false,  do_class_stop&#125;&#125;&#125;,
        &#123;&quot;copy&quot;,                    &#123;2,     2,    &#123;true,   do_copy&#125;&#125;&#125;,
        &#123;&quot;copy_per_line&quot;,           &#123;2,     2,    &#123;true,   do_copy_per_line&#125;&#125;&#125;,
        &#123;&quot;domainname&quot;,              &#123;1,     1,    &#123;true,   do_domainname&#125;&#125;&#125;,
        &#123;&quot;enable&quot;,                  &#123;1,     1,    &#123;false,  do_enable&#125;&#125;&#125;,
        &#123;&quot;exec&quot;,                    &#123;1,     kMax, &#123;false,  do_exec&#125;&#125;&#125;,
        &#123;&quot;exec_background&quot;,         &#123;1,     kMax, &#123;false,  do_exec_background&#125;&#125;&#125;,
        &#123;&quot;exec_start&quot;,              &#123;1,     1,    &#123;false,  do_exec_start&#125;&#125;&#125;,
        &#123;&quot;export&quot;,                  &#123;2,     2,    &#123;false,  do_export&#125;&#125;&#125;,
        &#123;&quot;hostname&quot;,                &#123;1,     1,    &#123;true,   do_hostname&#125;&#125;&#125;,
        &#123;&quot;ifup&quot;,                    &#123;1,     1,    &#123;true,   do_ifup&#125;&#125;&#125;,
        &#123;&quot;init_user0&quot;,              &#123;0,     0,    &#123;false,  do_init_user0&#125;&#125;&#125;,
        &#123;&quot;insmod&quot;,                  &#123;1,     kMax, &#123;true,   do_insmod&#125;&#125;&#125;,
        &#123;&quot;installkey&quot;,              &#123;1,     1,    &#123;false,  do_installkey&#125;&#125;&#125;,
        &#123;&quot;interface_restart&quot;,       &#123;1,     1,    &#123;false,  do_interface_restart&#125;&#125;&#125;,
        &#123;&quot;interface_start&quot;,         &#123;1,     1,    &#123;false,  do_interface_start&#125;&#125;&#125;,
        &#123;&quot;interface_stop&quot;,          &#123;1,     1,    &#123;false,  do_interface_stop&#125;&#125;&#125;,
        &#123;&quot;load_exports&quot;,            &#123;1,     1,    &#123;false,  do_load_exports&#125;&#125;&#125;,
        &#123;&quot;load_persist_props&quot;,      &#123;0,     0,    &#123;false,  do_load_persist_props&#125;&#125;&#125;,
        &#123;&quot;load_system_props&quot;,       &#123;0,     0,    &#123;false,  do_load_system_props&#125;&#125;&#125;,
        &#123;&quot;loglevel&quot;,                &#123;1,     1,    &#123;false,  do_loglevel&#125;&#125;&#125;,
        &#123;&quot;mark_post_data&quot;,          &#123;0,     0,    &#123;false,  do_mark_post_data&#125;&#125;&#125;,
        &#123;&quot;mkdir&quot;,                   &#123;1,     6,    &#123;true,   do_mkdir&#125;&#125;&#125;,
        // TODO: Do mount operations in vendor_init.
        // mount_all is currently too complex to run in vendor_init as it queues action triggers,
        // imports rc scripts, etc.  It should be simplified and run in vendor_init context.
        // mount and umount are run in the same context as mount_all for symmetry.
        &#123;&quot;mount_all&quot;,               &#123;0,     kMax, &#123;false,  do_mount_all&#125;&#125;&#125;,
        &#123;&quot;mount&quot;,                   &#123;3,     kMax, &#123;false,  do_mount&#125;&#125;&#125;,
        &#123;&quot;perform_apex_config&quot;,     &#123;0,     0,    &#123;false,  do_perform_apex_config&#125;&#125;&#125;,
        &#123;&quot;umount&quot;,                  &#123;1,     1,    &#123;false,  do_umount&#125;&#125;&#125;,
        &#123;&quot;umount_all&quot;,              &#123;0,     1,    &#123;false,  do_umount_all&#125;&#125;&#125;,
        &#123;&quot;update_linker_config&quot;,    &#123;0,     0,    &#123;false,  do_update_linker_config&#125;&#125;&#125;,
        &#123;&quot;readahead&quot;,               &#123;1,     2,    &#123;true,   do_readahead&#125;&#125;&#125;,
        &#123;&quot;remount_userdata&quot;,        &#123;0,     0,    &#123;false,  do_remount_userdata&#125;&#125;&#125;,
        &#123;&quot;restart&quot;,                 &#123;1,     1,    &#123;false,  do_restart&#125;&#125;&#125;,
        &#123;&quot;restorecon&quot;,              &#123;1,     kMax, &#123;true,   do_restorecon&#125;&#125;&#125;,
        &#123;&quot;restorecon_recursive&quot;,    &#123;1,     kMax, &#123;true,   do_restorecon_recursive&#125;&#125;&#125;,
        &#123;&quot;rm&quot;,                      &#123;1,     1,    &#123;true,   do_rm&#125;&#125;&#125;,
        &#123;&quot;rmdir&quot;,                   &#123;1,     1,    &#123;true,   do_rmdir&#125;&#125;&#125;,
        &#123;&quot;setprop&quot;,                 &#123;2,     2,    &#123;true,   do_setprop&#125;&#125;&#125;,
        &#123;&quot;setrlimit&quot;,               &#123;3,     3,    &#123;false,  do_setrlimit&#125;&#125;&#125;,
        &#123;&quot;start&quot;,                   &#123;1,     1,    &#123;false,  do_start&#125;&#125;&#125;,
        &#123;&quot;stop&quot;,                    &#123;1,     1,    &#123;false,  do_stop&#125;&#125;&#125;,
        &#123;&quot;swapon_all&quot;,              &#123;0,     1,    &#123;false,  do_swapon_all&#125;&#125;&#125;,
        &#123;&quot;enter_default_mount_ns&quot;,  &#123;0,     0,    &#123;false,  do_enter_default_mount_ns&#125;&#125;&#125;,
        &#123;&quot;symlink&quot;,                 &#123;2,     2,    &#123;true,   do_symlink&#125;&#125;&#125;,
        &#123;&quot;sysclktz&quot;,                &#123;1,     1,    &#123;false,  do_sysclktz&#125;&#125;&#125;,
        &#123;&quot;trigger&quot;,                 &#123;1,     1,    &#123;false,  do_trigger&#125;&#125;&#125;,
        &#123;&quot;verity_update_state&quot;,     &#123;0,     0,    &#123;false,  do_verity_update_state&#125;&#125;&#125;,
        &#123;&quot;wait&quot;,                    &#123;1,     2,    &#123;true,   do_wait&#125;&#125;&#125;,
        &#123;&quot;wait_for_prop&quot;,           &#123;2,     2,    &#123;false,  do_wait_for_prop&#125;&#125;&#125;,
        &#123;&quot;write&quot;,                   &#123;2,     2,    &#123;true,   do_write&#125;&#125;&#125;,
    &#125;;
</code></pre>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>至此第二阶段就分析完毕了，一句话来总结：<code>优先保证init进程的存活率（拉高优先级），处理设备是否unlock,决定是否卸载一些分区以及调整selinux规则和权限，创建并启动属性服务（实质上就是把属性值映射到全局内存中供所有进程访问，然后在创建socket等待进程来连接 实现更新和新增属性值），继续决定是否把vendor_overlay覆盖到/vendor分区中，然后持续监控/proc/mounts,如果有分区信息加入到该文件中则挂载此分区，接着解析rc文件（创建目录，修改权限，挂载分区，启动服务进程等），根据调用顺序启动核心服务（adbd,ueventd等）以及主服务(zygote)和其他服务</code></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-其他笔记/csdn文章导出markdown" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/">其他笔记</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> ###1、使用浏览器的开发者工具 浏览器按F12</p>
<p>找到“<strong>元素</strong>”标签，按Ctrl+F 查找 “<strong>article_content</strong>” 关键词：如图</p>
<p><img src="/../../images/7867188fb7714351a318e937861fc672.png"></p>
<h2 id="2、右击这个div-选择-复制-找到-复制outerHTML"><a href="#2、右击这个div-选择-复制-找到-复制outerHTML" class="headerlink" title="2、右击这个div 选择 复制 找到 复制outerHTML"></a>2、右击这个div 选择 <strong>复制</strong> 找到 <strong>复制outerHTML</strong><img src="/../../images/597970e0ae194f0b8c68759d6c28985d.png"></h2><h2 id="3、将复制出的HTML代码扔到编辑器中删除部分"><a href="#3、将复制出的HTML代码扔到编辑器中删除部分" class="headerlink" title="3、将复制出的HTML代码扔到编辑器中删除部分"></a>3、将复制出的HTML代码扔到编辑器中删除部分</h2><p>将一下部分替换为空（使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D&spm=1001.2101.3001.7020">正则匹配</a>）</p>
<ul class="pre-numbering.*</ul>

<p>（因为这部分是代码部分的前面的数字，直接复制就会附带所以去掉！）</p>
<p><img src="/../../images/339eda7e252f4e7984ee784757cf2e2a.png"></p>
<h2 id="4、放到markdown编辑器-在线工具-tool-lu"><a href="#4、放到markdown编辑器-在线工具-tool-lu" class="headerlink" title="4、放到markdown编辑器 - 在线工具 (tool.lu)"></a>4、放到<a target="_blank" rel="noopener" href="https://tool.lu/markdown/" title="markdown编辑器 - 在线工具 (tool.lu)">markdown编辑器 - 在线工具 (tool.lu)</a></h2><p>这个网址的左边HTML2MD部分 然后右边部分生成的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Markdown&spm=1001.2101.3001.7020">Markdown</a>笔记就可以直接复制了<img src="/../../images/6267713d93324839b3c3c6261cb0a1f4.png"></p>
<h2 id="5、结果展示"><a href="#5、结果展示" class="headerlink" title="5、结果展示"></a>5、结果展示</h2><p><img src="/../../images/36e58021f028414fbb55bdf25c8da14f.png"></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/2.Android13启动流程之FirstStageMain阶段" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="一-Android系统启动基本介绍"><a href="#一-Android系统启动基本介绍" class="headerlink" title="一. Android系统启动基本介绍"></a>一. Android系统启动基本介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服</span><br><span class="line">务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init</span><br></pre></td></tr></table></figure>

<p><strong>1. Bootloader 引导</strong></p>
<p>当按下设备电源键时，最先运行的就是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=bootloader&spm=1001.2101.3001.7020">bootloader</a>（固化在ROM的程序），bootloader 的主要作用就是硬件设备（如 CPU、flash、内存）的初始化并加载到RAM，通过建立内存空间映射，为装载 Linux 内核做好准备,。如果 bootloader 在运行期间，按下预定义的组合按键，可以进入系统fastboot模式 或者 Receiver 模式。</p>
<p><strong>2. 装载和启动 Linux 内核</strong></p>
<p>在编译完<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AOSP&spm=1001.2101.3001.7020">AOSP</a>时会生成boot.img或者boot_debug.img，该镜像就是 Linux 内核和根文件系统，bootloader 会把该镜像装载到内存中，然后 linux 内核会执行整个系统的初始化，完成后装载根文件系统，最后启动 init 进程。</p>
<p><strong>3. 启动 Init 进程</strong></p>
<p>Linux 内核加载完毕后，会从kernel内核层调用到用户空间层，则会首先启动 init 进程，init 进程是系统的第一个进程，在 init 进程的启动过程中会解析最主要的 init.rc 脚本，根据 init.rc 文件的描述，系统会创建文件及目录以及权限的赋予，初始化属性和启动 Android 系统重要的守护进程。</p>
<p><strong>4. 启动 ServiceManager</strong></p>
<p>ServiceManager 由 init 进程启动。它的主要作用是管理 Binder 服务，service 服务的注册和查找，如 AMS、PMS， 都是通过 ServiceManger 来管理。</p>
<p><strong>5. 启动 MediaServer</strong></p>
<p>MediaServer 是由 init 进程启动，它包含了一些多媒体 binder 服务，包括 CameraService、MediaPlayerService、AudioPolicyService 等等</p>
<blockquote>
<p>onrestart restart audioserver<br>onrestart restart cameraserver<br>onrestart restart media<br>onrestart restart media.tuner<br>onrestart restart netd<br>onrestart restart wificond</p>
</blockquote>
<p><strong>6. 启动 Zygote 进程</strong></p>
<p>init 进程初始化结束后，会启动 Zygote 进程。在 Android 系统中所有的应用程序进程和系统服务进程都是通过Zygote 进程 fork 出来的。预装载系统的资源文件，所有从 Zygote 进程 fork 出的子进程都会共享这些资源，节省了资源加载的时间，提高的应用的启动速度。Zygote 启动结束后也会变为守护进程，负责响应启动 APK 的请求。</p>
<p><strong>7. 启动 SystemServer</strong></p>
<p>SystemServer 是跟随Zygote创建出来的第一个子进程，同时也是整个 Android 系统的核心。在系统中运行的大部分系统服务都是有 SystemServer 创建，接着会启动 AMS、WMS、PMS 等。阅读过源码可以发现大部分服务会继承自systemServer</p>
<pre><code>PD2183:/ $ ps --pid 1                                  
USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME  
root             1     0 13133644  8264 0                   0 S init
</code></pre>
<p>init进程由init_task进程fork而来，在kernel初始化完成后init_task便化身为idle进程，可以看到init的进程pid为：1<br>而init_task进程是Linux中第一个进程，也即0号进程(PID为0)，这里不进一步分析linux内核层。</p>
<h2 id="二-FirstStageMain阶段分析"><a href="#二-FirstStageMain阶段分析" class="headerlink" title="二. FirstStageMain阶段分析"></a>二. FirstStageMain阶段分析</h2><p><img src="/../../../images/image-20231129165729682.png" alt="image-20231129165729682"></p>
<p>针对super分区，在开机init的first stage第一阶段运行期间，会解析并验证metadata元数据并创建虚拟block设备来表示每个子分区，super分区头部信息就是metadata元数据，用于映射（mapping）出虚拟block设备，这里盗用一张大佬的图来看一下super结构</p>
<p><img src="/../../../images/8acb8a5c6d73423ea8c487a5f1dfffda-17012480993077.png" alt="super镜像">super分区除了包含<code>system\product\vendor</code>，在头部信息包含了描述分区布局的<code>metadata</code>，系统加载动态分区时读取metadata，对其进行解析。</p>
<p>Metadata中的信息会被转换成device mapper中的映射表Mapping Table，基于这个映射表，super分区对应设备<code>/dev/block/by-name/super</code>的不同部分被映射成多个虚拟设备，如<code>/dev/block/mapper/system_a</code> ，<code>/dev/block/mapper/vendor_a</code>等</p>
<h4 id="1-用户空间层main-cpp"><a href="#1-用户空间层main-cpp" class="headerlink" title="1. 用户空间层main.cpp"></a>1. 用户空间层main.cpp</h4><pre><code>using namespace android::init;

int main(int argc/*1*/, char** argv/*init*/) &#123; // 内核层传过来的，argc：1,argv：init
#if __has_feature(address_sanitizer)
    __asan_set_error_report_callback(AsanReportCallback);
#elif __has_feature(hwaddress_sanitizer)
    __hwasan_set_error_report_callback(AsanReportCallback);
#endif
    // Boost prio which will be restored later
    setpriority(PRIO_PROCESS, 0, -20); // 设置进程最高优先级 -20最高，20最低
    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;
        return ueventd_main(argc, argv);
    &#125;

    if (argc &gt; 1) &#123;
        if (!strcmp(argv[1], &quot;subcontext&quot;)) &#123;
            android::base::InitLogging(argv, &amp;android::base::KernelLogger);
            const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();

            return SubcontextMain(argc, argv, &amp;function_map);
        &#125;

        if (!strcmp(argv[1], &quot;selinux_setup&quot;)) &#123;
            return SetupSelinux(argv);
        &#125;

        if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123;
            return SecondStageMain(argc, argv);
        &#125;
    &#125;

    return FirstStageMain(argc, argv); //第一阶段执行
&#125;
</code></pre>
<p>内核层传过来的参数：argc：1,argv：init，所以第一阶段仍然是调用<code>return FirstStageMain(argc, argv);</code> 这里不详细介绍subcontext,ueventd，只关注FirstStageMain阶段即可，调用顺序如下</p>
<ul>
<li>FirstStageMain：主要创建和挂载基本的文件系统，挂载特定分区，启用log等</li>
<li>SetupSelinux：挂载并启用selinux权限系统，之前文章有讲过关于权限问题;</li>
<li>SecondStageMain：主要解析ini.rc文件，创建zygote孵化器，fork 进程等</li>
</ul>
<h4 id="2-FirstStageMain-int-argc-char-argv-解析"><a href="#2-FirstStageMain-int-argc-char-argv-解析" class="headerlink" title="2. FirstStageMain(int argc, char** argv)解析"></a>2. FirstStageMain(int argc, char** argv)解析</h4><p>该阶段所挂载的文件系统都属于ramdisk，运行在虚拟内存上</p>
<pre><code>//system/core/init/first_stage_init.cpp
int FirstStageMain(int argc, char** argv) &#123;
    // init阶段的启动引导加载程序（bootLoader），若发生异常重启也会再次执行，主要处理init || fork的子进程进程异常行为
    // init信号处理器，调试版本当init crash，默认重启到 bootLoader
    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;
        InstallRebootSignalHandlers();// setup1
    &#125;
    // 用来设置创建目录或文件时所应该赋予权限的掩码
    // Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755
    // 在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高
    umask(0);

    // 第一次执行时清除环境变量，reset path
    CHECKCALL(clearenv());
    CHECKCALL(setenv(&quot;PATH&quot;, _PATH_DEFPATH, 1));
    // setup 2
    // 设置linux最基本的文件系统并且挂载到 / 目录(init ram disk)上,
    // 并给0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限），后续会通过rc文件处理一些分区权限和进程
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); //将/dev设置为tmpfs并挂载，设置0755权限，tmpfs是在内存上建立的文件系统（Filesystem）
    CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//tmpfs文件系统类型
    CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));
    CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//tmpfs文件系统类型
    CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));
    // setup 3
     CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));
#undef MAKE_STR
    // 修改 「保存操作系统的启动参数」 的权限：0440，
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数
    CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));
    std::string cmdline;
    // 读取操作系统的启动参数
    android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程
    // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    chmod(&quot;/proc/bootconfig&quot;, 0440);
    std::string bootconfig;
    // 读取系统启动参数配置
    android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig);
    gid_t groups[] = &#123;AID_READPROC&#125;;
    CHECKCALL(setgroups(arraysize(groups), groups));
    // setup 4
    // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。
    // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中
    // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息
    CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL));
    CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL));
    CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11)));
    if constexpr (WORLD_WRITABLE_KMSG) &#123;
        CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11)));
    &#125;
    // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数
    CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8)));
    CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9)));
    
    // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。
    CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2)));
    CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3)));
    
    // setup 5
    // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载
    // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理
    // tmpfs之前说过了，是运作在RAM的文件系统
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=1000&quot;));
    CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755));
    CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755));
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));
    // 创建selinux驱动节点，类型属于：tmpfs
    CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744));
    // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的
    SetStdioToDevNull(argv);
    InitKernelLogging(argv);
    // log可以使用了，第一阶段正式开始 创建设备
    LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;;
    // setup 6
    // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统
    auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;;
    // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量
    // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成
    if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    // 加载kernel模块且是非正常的启动模式
    // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)，并加载kernel模块且处于非正常的启动模式
    // 再根据want_console来决定是否打开串口日志
    if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console,
                           want_parallel, module_count)) &#123;
        if (want_console != FirstStageConsoleParam::DISABLED) &#123;
            LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;;
        &#125; else &#123;
            LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;;
        &#125;
    &#125;
    // 继续根据是否打开串口日志来创建devices
    // want_console == 1
    if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;
         // 非恢复模式下进行，在 recovery 模式下不允许创建设备
        if (!IsRecoveryMode()) &#123;
            // 在创建逻辑分区之前挂载 /metadata
            // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问
            // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区
            created_devices = DoCreateDevices();
            if (!created_devices) &#123;
                LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;;
            &#125;
        &#125;
        StartConsole(cmdline);
    &#125;
    // setup 7
    // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop
    // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下
    if (access(kBootImageRamdiskProp, F_OK) == 0) &#123;
        // 获取/second_stage_resources/system/etc/ramdisk/build.prop
        // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建
        std::string dest = GetRamdiskPropForSecondStage();
         // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk
        std::string dir = android::base::Dirname(dest);
        std::error_code ec;
        if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message();
        &#125;
        // 生成 /second_stage_resources/system/etc/ramdisk/build.prop
        if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot;
                       &lt;&lt; ec.message();
        &#125;
        LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest;
    &#125;
    // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root
    // /userdebug_plat_sepolicy.cil属于selinux策略里的规则
    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限
    if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123;
        constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;;
        constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;;
        ...
        setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1);
    &#125;
    // setup 8
    // 如果内核命令行中存在 androidboot.force_normal_boot=1，则设备会正常启动，即正常启动时
    if (ForceNormalBoot(cmdline, bootconfig)) &#123;
        // 创建第一阶段ramdisk目录 /first_stage_ramdisk
        mkdir(&quot;/first_stage_ramdisk&quot;, 0755);
        // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;;
        PrepareSwitchRoot();
        if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123;
            PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;;
        &#125;
        // 将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk
        SwitchRoot(&quot;/first_stage_ramdisk&quot;);
    &#125;
    
    // 挂载 system、vendor 、product等系统分区
    if (!DoFirstStageMount(!created_devices)) &#123;
        LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;;
    &#125;
    // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root
    // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等
    struct stat new_root_info;
    if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    // 根目录发生变化，则释放old ramdisk，用new ramdisk
    if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123;
        FreeRamdisk(old_root_dir.get(), old_root_info.st_dev);
    &#125;
    // setup 8 主要内容:将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk
    // setup 9
    //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。
    // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root）,
    // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：bootloader，boot.img，system.img。
    // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过
    SetInitAvbVersionInRecovery();
    // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了
    // init程序的二进制文件目录
    const char* path = &quot;/system/bin/init&quot;;
    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux
    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区
    // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp
    execv(path, const_cast&lt;char**&gt;(args));
&#125;
</code></pre>
<p>​    具体信息可以看注释，这里我分为了11个步骤来分析，也就是对应的setup 1~10</p>
<h4 id="2-FirstStageMain-int-argc-char-argv-—–-gt-setup-1步骤"><a href="#2-FirstStageMain-int-argc-char-argv-—–-gt-setup-1步骤" class="headerlink" title="2. FirstStageMain(int argc, char** argv)—–&gt;setup 1步骤"></a>2. FirstStageMain(int argc, char** argv)—–&gt;setup 1步骤</h4><p>主要分析<code>InstallRebootSignalHandlers();// setup1</code>其关键作用：主要加载引导程序以及init阶段crash的进程处理，也就是异常处理</p>
<pre><code>// 主要加载引导程序以及init阶段crash的进程处理
//system/core/init/reboot_utils.cpp
void InstallRebootSignalHandlers() &#123;
    struct sigaction action;
    // memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作
    memset(&amp;action, 0, sizeof(action));
    // sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里即将所有的信号标志位置为1。
    // 成功返回0,反之返回1
    sigfillset(&amp;action.sa_mask);
    // 对于从init派生的进程（init进程对操作系统的意义在于，其他所有的用户进程都直接或者间接派生自init进程,例如解析init.rc出来的进程zygote）
    // 这些信号处理程序也会被捕获，但是我们不希望它们触发重新启动，所以我们在这里直接为子进程调用_exit（）
    // 针对加载引导程序或init crash后加载引导程序，不应该restart,而是直接退出 再次启动系统时重新start
    action.sa_handler = [](int signal) &#123;
        if (getpid() != 1) &#123;
            _exit(signal);
        &#125;
        // 由于init fatal || crash执行重启（所以有些机器故障会无限卡logo重启），这里执行了重启或是强制关机
        InitFatalReboot(signal); //1
    &#125;;
    action.sa_flags = SA_RESTART;
    // 设置信号处理器
    sigaction(SIGABRT, &amp;action, nullptr);
    sigaction(SIGBUS, &amp;action, nullptr);
    sigaction(SIGFPE, &amp;action, nullptr);
    sigaction(SIGILL, &amp;action, nullptr);
    sigaction(SIGSEGV, &amp;action, nullptr);
#if defined(SIGSTKFLT)
    sigaction(SIGSTKFLT, &amp;action, nullptr);
#endif
    sigaction(SIGSYS, &amp;action, nullptr);
    sigaction(SIGTRAP, &amp;action, nullptr);
&#125;
</code></pre>
<p>以上代码块的逻辑大概就是收集进程信号集，将这些异常的信号集进行特殊处理（关机或重启 触发循环卡logo等），并把这些信号标志为1，针对init进程（Pid&#x3D;1）派生出来的子进程（例如zygote）而是选择直接退出 不进一步处理，因为如果init进程重新启动后将会重新派生出原来的子进程。这里继续分析一下<code>InitFatalReboot(signal); //1</code></p>
<h5 id="2-1-InitFatalReboot-signal"><a href="#2-1-InitFatalReboot-signal" class="headerlink" title="2.1 InitFatalReboot(signal)"></a>2.1 InitFatalReboot(signal)</h5><pre><code>void __attribute__((noreturn)) InitFatalReboot(int signal_number) &#123;
    // 派生出子进程，pid == -1则代表fork进程失败
    auto pid = fork();

    // Init 是Android OS中第一个user space process（用户态或用户空间pid = 1），守护进程（在后台运行的守护进程，其一作用于执行启动的系统任务）
    // Init 进程是所有用户进程的鼻祖，Init 进程会孵化（fork，派生）出 ueventd、logd、healthd、installd、adbd、lmkd 等用户守护进程
    if (pid == -1) &#123; // 当pid==1时说明fork失败，立即执行bootloader重启，可能会重新执行到pid == 0
        // Couldn&#39;t fork, don&#39;t even try to backtrace, just reboot.
        RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target);
    &#125; else if (pid == 0) &#123; //fork成功，说明现在运行在子进程上，并且子进程需确保能重启
        sleep(5);
        RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target);
    &#125;

    // 当关机时，尝试在父进程（pid = 1，即init）中获取back trace日志
    LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: signal &quot; &lt;&lt; signal_number;
    std::unique_ptr&lt;Backtrace&gt; backtrace(
            Backtrace::Create(BACKTRACE_CURRENT_PROCESS, BACKTRACE_CURRENT_THREAD));
    if (!backtrace-&gt;Unwind(0)) &#123;
        LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Failed to unwind callstack.&quot;;
    &#125;
    for (size_t i = 0; i &lt; backtrace-&gt;NumFrames(); i++) &#123;
        LOG(ERROR) &lt;&lt; backtrace-&gt;FormatFrameData(i);
    &#125;
    // 判断init（主）进程是否被标记为异常（例如init主进程都退出了），决定是否需要重启bootLoader（正常步骤会执行到重启，异常则直接sysdump）
    // 启动内核时出现panic的几种情况：出现init进程被异常杀死，则直接触发崩溃，即进入sysdump
    if (init_fatal_panic) &#123;
        LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Trigger crash&quot;;
        // 通过#define PROC_SYSRQ &quot;/proc/sysrq-trigger&quot; 写值触发系统崩溃
        // echo b &gt; /proc/sysrq-trigger --&gt;立即重启
        // echo o &gt; /proc/sysrq-trigger --&gt;立即关机
        // echo c &gt; /proc/sysrq-trigger --&gt;立即让系统崩溃
        // echo t &gt; /proc/sysrq-trigger --&gt;导出线程状态信息
        // echo u &gt; /proc/sysrq-trigger --&gt;立即重新挂载所有的文件系统为只读
        android::base::WriteStringToFile(&quot;c&quot;, PROC_SYSRQ);
        LOG(ERROR) &lt;&lt; __FUNCTION__ &lt;&lt; &quot;: Sys-Rq failed to crash the system; fallback to exit().&quot;;
        _exit(signal_number);
    &#125;
    // 在init进程上重启
    RebootSystem(ANDROID_RB_RESTART2, init_fatal_reboot_target);
&#125;
</code></pre>
<p>以上代码块主要作用于确保子进程，如果fork成功则代表目前运行在子进程上，目的就是一个：确保子进程能重启，如果init进程（主进程）被标记为致命异常，则会立即执行<code>android::base::WriteStringToFile(&quot;c&quot;, PROC_SYSRQ);</code>，触发死机</p>
<p><img src="/../../../images/image-20231129165843941.png" alt="image-20231129165843941"></p>
<p>至此setup 1就分析完了，总结一句话：针对异常的进程进行特殊的处理，例如让子进程确保能重启，检查init进程是否退出或产生异常，若主进程异常则直接对设备进行强制死机，进入sysdump</p>
<h4 id="3-FirstStageMain-int-argc-char-argv-—–-gt-setup-2步骤"><a href="#3-FirstStageMain-int-argc-char-argv-—–-gt-setup-2步骤" class="headerlink" title="3. FirstStageMain(int argc, char** argv)—–&gt;setup 2步骤"></a>3. FirstStageMain(int argc, char** argv)—–&gt;setup 2步骤</h4><p>setup 2主要就是初始化文件系统，我这里单独在贴一下代码：</p>
<pre><code>    // setup 2
    //将/dev设置为tmpfs文件系统并挂载，设置0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限）
    // 后续会通过rc文件处理一些分区权限和进程，tmpfs是在内存上建立的文件系统（Filesystem）
    // tmpfs文件系统是一种基于内存的文件系统，可以运行在RAM上，所以/dev都属于tmpfs文件系统
     CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); 
    CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//1
    // 关于/dev/socket目录
    // 0. tmpfs文件系统类型，例如zygote就保存到该位置（/dev/socket）
    // 1. zygote 开始循环监听 /dev/socket/zygote，system_server 与zygote 达成首次通信
    // 2. 之后AMS会且连接 /dev/socket/zygote 的socket，进行通信
    CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));//2
    CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//3
    CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));
</code></pre>
<p>这里主要初始化了基本的文件系统tmpfs，既然基于RAM，那肯定有易失性，特点如下：</p>
<ul>
<li>基于内存的文件系统</li>
<li>能够动态地使用虚拟内存</li>
<li>不需要格式化文件系统</li>
<li>tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的,其优点是读写速度很快，但存在掉电丢失的风险(ramfs与tmpfs有着对比性)，这也许就是它叫tmpfs的原故</li>
<li>由于tmpfs基于RAM，运行在内存上，因此它比硬盘的速度肯定要快，因此我们可以利用这个优点使用它来提升机器的性能（小伙伴们可以试着把tmpfs改为基于disk的文件系统试试），tmpfs 的另一个主要的好处是它闪电般的速度，因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的</li>
<li>tmpfs使用了虚拟内存的机制，它会进行swap，用例：达到空间上限时继续写入 结果：提示错误信息并终止，且tmpfs是有上限的，超过时会提示错误信息并终止 所以相比ramfs是比较安全的</li>
</ul>
<p>tmpfs和ramfs有着对比性，tmpfs是相对安全的，因为 达到空间上限时仍继续写入数据，那么提示错误信息并终止<br>而ramfs没有空间上限，会持续写入尚未分配的空间（占用其他未分配的内存）。因此tmpfs是固定大小，ramfs不固定其大小。<br>可以通过命令来查看手机系统使用的是tmpfs还是ramfs，以及他们的信息<br><code>adb shell mount | grep -E &quot;(tmpfs|ramfs)&quot;</code><br><img src="/../../../images/d30141674ffd4f67872de7ebb20587ce-17012480993079.png" alt="info">可以看到该设备使用的是tmpfs文件系统，以及可以看到属于tmpfs文件系统的分区，大小信息等,还有一个命令也可以查看，比较简约<br><code>adb shell df -h | grep -E &quot;(tmpfs|ramfs)&quot;</code><br><img src="/../../../images/cf2077e430a1481aa6d427caa4ecda63-170124809930711.png" alt="info"><br>可以看到使用的大小，&#x2F;dev &#x2F;mnt &#x2F;apex都属于tmpfs文件系统，代码里提到过关于&#x2F;dev&#x2F;socket目录，是一个比较重要的知识点，具体看注释即可</p>
<h4 id="4-FirstStageMain-int-argc-char-argv-—–-gt-setup-3步骤"><a href="#4-FirstStageMain-int-argc-char-argv-—–-gt-setup-3步骤" class="headerlink" title="4. FirstStageMain(int argc, char** argv)—–&gt;setup 3步骤"></a>4. FirstStageMain(int argc, char** argv)—–&gt;setup 3步骤</h4><p>继续贴上FirstStageMain函数里面的setup 3的代码，</p>
<pre><code>// 挂载proc文件系统（驻留在RAM中），Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种虚拟文件系统
CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));// 1
#undef MAKE_STR
    // 修改 「保存操作系统的启动参数」 的权限：0440，
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数
    CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));
    std::string cmdline;
    // 读取操作系统的启动参数
    android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);
    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程
    // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作
    chmod(&quot;/proc/bootconfig&quot;, 0440);
    std::string bootconfig;
    // 读取系统启动参数配置
    android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig);
    gid_t groups[] = &#123;AID_READPROC&#125;;
    CHECKCALL(setgroups(arraysize(groups), groups));
</code></pre>
<p>这里主要解释一下注释的第一点</p>
<blockquote>
<p>该目录下保存的并不是真正的文件和目录（虚拟文件系统），而是一些【运行时】的信息，如 CPU 信息、负载信息、系统内存信息、磁盘 IO 信息等。<br>存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系的硬件及当前【正在运行进程的信息】，甚至可以通过更改其中某些文件来改变内核的运行状态</p>
</blockquote>
<pre><code>/proc/cmdline         # 保存操作系统的启动参数,/proc/cmdline中保存bootloader 启动linux kernel 时 的参数
/proc/cpuinfo         # 保存CPU的相关信息。对应lscpu命令。
/proc/devices         # 系统已经加载的所有块设备和字符设备的信息。
/proc/diskstats       # 统计磁盘设备的I/O信息。
/proc/filesystems     # 保存当前系统支持的文件系统。
/proc/kcore	          # 物理内存的镜像。该文件大小是已使用的物理内存加上4K。
/proc/loadavg	      # 保存最近1分钟、5分钟、15分钟的系统平均负载。
/proc/meminfo	      # 保存当前内存使用情况。对应free命令
/proc/mounts -&gt; self/mounts	# 系统中当前挂载的所有文件系统。mount命令。
                            # mounts文件是链接到self/mounts。
/proc/partitions      # 每个分区的主设备号（major）、次设备号（minor）、包含的块（block）数目。
/proc/uptime          # 系统自上次启动后的运行时间。
/proc/version         # 当前系统的内核版本号
/proc/vmstat          # 当前系统虚拟内存的统计数据
</code></pre>
<p>所以该步骤的代码块主要代码：<code>CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));</code>和<code>android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);</code>，指定权限，若权限改变则无法正常读取，可以防止强行改变权限为a+x或777而带来的非法操作，然后读取cmdline，读取操作系统的启动参数</p>
<h4 id="4-FirstStageMain-int-argc-char-argv-—–-gt-setup-4步骤"><a href="#4-FirstStageMain-int-argc-char-argv-—–-gt-setup-4步骤" class="headerlink" title="4. FirstStageMain(int argc, char** argv)—–&gt;setup 4步骤"></a>4. FirstStageMain(int argc, char** argv)—–&gt;setup 4步骤</h4><pre><code>    // setup 4
    // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。
    // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中
    // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息
    CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL));
    // 挂载/sys/fs/selinux文件系统，也属于/sys
    // /sys/fs/selinux ： selinux机制，也就是处理selinux权限机制文件存放的位置，判断是否开启严格模式等
    CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL));
     // 创建处理日志的设备文件
    // Linux内核通过printk打印的log信息,这些log写入到了/dev/kmsg文件中,
    // 也就是kernel log,在展锐平台上可以通过python解析ylog来看到kernel log
    // 也可以在 Shell终端可以通过dmesg /dev/kmsg 命令查看这些log信息
    CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11)));
    // 如果是ud版本则继续创建kmsg_debug设备文件
    // WORLD_WRITABLE_KMSG = 1 则是ud,为0即user
    if constexpr (WORLD_WRITABLE_KMSG) &#123;
        CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11)));
    &#125;
    // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数
    // 随机数在计算中很重要。 TCP/IP 序列号、密码盐和 DNS 源端口号都依赖于随机数。
    // 在密码学中，随机性无处不在，从密钥的生成到加密系统，甚至密码系统受到攻击的方式。没有随机性，所有加密操作都是可预测的，因此不安全
    CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8)));
    CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9)));

    // This is needed for log wrapper, which gets called before ueventd runs.
    // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。
    CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2)));
    CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3)));
</code></pre>
<ol>
<li><p>上面的代码比较简单，主要就是创建随机数设备文件，所以上层可以调用random获取随机数，随机数在计算中很重要，TCP&#x2F;IP 序列号、密码盐和 DNS 源端口号都依赖于随机数，也例如加密机制，都需要用到随机数。</p>
</li>
<li><p>同时也创建了&#x2F;dev&#x2F;null设备文件，dev&#x2F;null 在Linux中是一个空设备文件，它于其他普通的设备文件不同，当往null写入数据时会被丢弃掉，它不能够被执行，所以不能使用管道符去操作它，只能通过文件重定向（&gt;,&gt;&gt;），我们可以通过把命令的输出重定向到 &#x2F;dev&#x2F;null 来丢弃脚本的全部输出</p>
</li>
<li><p>也创建了&#x2F;dev&#x2F;kmsg设备文件，主要存储日志，Shell终端可以通过dmesg &#x2F;dev&#x2F;kmsg 命令查看这些log信息<br><img src="/../../../images/74ae09adda2541acad5d9318c1de064d.png" alt="log"></p>
</li>
<li><p>在介绍一下&#x2F;sys文件系统，sysfs（常驻于RAM中）是一个伪文件系统，不占有任何磁盘空间的虚拟文件系统</p>
</li>
</ol>
<blockquote>
<p>&#x2F;sys下存放的都是设备驱动，网络环境，偏硬件的文件<br>1.&#x2F;sys&#x2F;firmware ： 固件 文件目录<br>2.&#x2F;sys&#x2F;kernel : 内核文件目录<br>3.&#x2F;sys&#x2F;module ： 内核驱动模块<br>4.&#x2F;sys&#x2F;power ： 电源相关模块<br>5.&#x2F;sys&#x2F;bus ： 驱动总线文件目录<br>6.&#x2F;sys&#x2F;block ： 块设备目录（映射的&#x2F;sys&#x2F;devices目录）<br>7.&#x2F;sys&#x2F;devices ： 设备目录（也有虚拟设备目录），例如：sys&#x2F;devices&#x2F;virtual&#x2F;block&#x2F;dm-28<br>8.&#x2F;sys&#x2F;fs&#x2F;selinux ： selinux机制，也就是处理selinux权限机制文件存放的位置，判断是否开启严格模式等</p>
</blockquote>
<h4 id="5-FirstStageMain-int-argc-char-argv-—–-gt-setup-5步骤"><a href="#5-FirstStageMain-int-argc-char-argv-—–-gt-setup-5步骤" class="headerlink" title="5. FirstStageMain(int argc, char** argv)—–&gt;setup 5步骤"></a>5. FirstStageMain(int argc, char** argv)—–&gt;setup 5步骤</h4><pre><code>    // setup 5
    // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载
    // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理
    // tmpfs之前说过了，是运作在RAM的文件系统
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=1000&quot;));
    CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755));
    CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755));
    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,
                    &quot;mode=0755,uid=0,gid=0&quot;));
    // 创建selinux驱动节点，类型属于：tmpfs
    CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744));
    // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的
    SetStdioToDevNull(argv);
    InitKernelLogging(argv);
    // log可以使用了，第一阶段正式开始 创建设备
    LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;;
</code></pre>
<p>这里的代码也比较简单，主要创建比较重要的分区，注意这里只是创建并没有挂载，&#x2F;mnt&#x2F;{vendor,product}，然后初始化kernel log,LOG日志可以正常使用和输出。</p>
<ul>
<li>vendor： 用于存放odm供应商开发的文件，例如MTK自带节点 &#x2F;mnt&#x2F;vendor&#x2F;protect_f&#x2F; 可存储恢复出厂+刷机不丢失数据</li>
<li>product：根据不同的项目，存放项目中不同的内容，例如APK位置等</li>
<li>mnt ： 此目录主要是作为挂载点使用，例如挂载&#x2F;mnt&#x2F;sdcard</li>
</ul>
<h4 id="6-FirstStageMain-int-argc-char-argv-—–-gt-setup-6步骤"><a href="#6-FirstStageMain-int-argc-char-argv-—–-gt-setup-6步骤" class="headerlink" title="6. FirstStageMain(int argc, char** argv)—–&gt;setup 6步骤"></a>6. FirstStageMain(int argc, char** argv)—–&gt;setup 6步骤</h4><pre><code>   // setup 6
    // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统
    auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;;
    // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量
    // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成
    if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)，
    // 并加载kernel模块且处于非正常的启动模式，根据want_console来决定是否打开串口日志
    if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console,
                           want_parallel, module_count)) &#123;
        if (want_console != FirstStageConsoleParam::DISABLED) &#123;
            LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;;
        &#125; else &#123;
            LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;;
        &#125;
    &#125;
    // 继续根据是否打开串口日志来创建devices
    // want_console == 1
    if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;
         // 非恢复模式下进行，在 recovery 模式下不允许创建设备
        if (!IsRecoveryMode()) &#123;
            // 在创建逻辑分区之前挂载 /metadata
            // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问
            // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区
            created_devices = DoCreateDevices();// 1
            if (!created_devices) &#123;
                LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;;
            &#125;
        &#125;
        StartConsole(cmdline);
    &#125;
</code></pre>
<p>这里的代码主要是打开串口log（可选），在手机无法开机的情况下会抓串口log来分析问题。这里挂载了&#x2F;metadata,metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问，在文章开头也提到过metadata分区，这里会挂载和创建metadata里的设备文件，感兴趣的可以进一步去了解，挂载&#x2F;metadata的前提条件是必须有根目录“&#x2F;” 或 &#x2F;system，否则，切换根目录后无法访问ramdisk（后续会把old ramdisk切换到new ramdisk,切换后的新根目录会还原默认权限）</p>
<h4 id="7-FirstStageMain-int-argc-char-argv-—–-gt-setup-7步骤"><a href="#7-FirstStageMain-int-argc-char-argv-—–-gt-setup-7步骤" class="headerlink" title="7. FirstStageMain(int argc, char** argv)—–&gt;setup 7步骤"></a>7. FirstStageMain(int argc, char** argv)—–&gt;setup 7步骤</h4><pre><code>    // setup 7
    // 判断文件是否存在，并判断文件是否可写:/system/etc/ramdisk/build.prop
    // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop
    // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下
    if (access(kBootImageRamdiskProp, F_OK) == 0) &#123;
        // 获取/second_stage_resources/system/etc/ramdisk/build.prop
        // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建
        std::string dest = GetRamdiskPropForSecondStage();
        // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk
        std::string dir = android::base::Dirname(dest);
        std::error_code ec;
         // 创建/second_stage_resources/system/etc/ramdisk目录
        if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message();
        &#125;
         // 拷贝 /system/etc/ramdisk/build.prop文件到 /second_stage_resources/system/etc/ramdisk
        // 生成 /second_stage_resources/system/etc/ramdisk/build.prop
        if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123;
            LOG(FATAL) &lt;&lt; &quot;Can&#39;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot;
                       &lt;&lt; ec.message();
        &#125;
        LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest;
    &#125;
    // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root
    // /userdebug_plat_sepolicy.cil属于selinux策略里的规则
    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限
    if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123;
        constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;;
        constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;;
        ...
        setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1);
    &#125;
</code></pre>
<p><img src="/../../../images/1bd0359ac89b4091a7c8ba09d1377dc8.png" alt="img"><br>setup7的代码片段主要讲解了获取ramdis下的prop属性值，为了第二阶段做准备，一句话来说就是创建了second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk目录文件，然后把&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop复制到上面的目录下，得到：&#x2F;second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop。<br>针对已经unlock了的设备加载特定的selinux规则，以放大权限，使得只读分区可以写入数据</p>
<h4 id="8-FirstStageMain-int-argc-char-argv-—–-gt-setup-8步骤"><a href="#8-FirstStageMain-int-argc-char-argv-—–-gt-setup-8步骤" class="headerlink" title="8. FirstStageMain(int argc, char** argv)—–&gt;setup 8步骤"></a>8. FirstStageMain(int argc, char** argv)—–&gt;setup 8步骤</h4><pre><code>    // setup 8
    // 如果是正常启动模式则创建 /first_stage_ramdisk目录作为根目录，把之前的根目录切换掉
    // 因为之前都是基于根目录创建文件系统，放大了权限，将old根目录切换到first_stage_ramdisk后
    // 将会在first_stage_ramdisk根目录把权限恢复到默认，例如old根目录部分文件系统是777权限，切换到first_stage_ramdisk根目录后
    // 权限会放低，会给一个安全的权限，判断是否是正常启动可以通过该属性值判断：androidboot.force_normal_boot
    if (ForceNormalBoot(cmdline, bootconfig)) &#123;
        // 创建第一阶段ramdisk目录 /first_stage_ramdisk
        mkdir(&quot;/first_stage_ramdisk&quot;, 0755);
        // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;;
        PrepareSwitchRoot();
        // 挂载/first_stage_ramdisk目录
        if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123;
            PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;;
        &#125;
        // 将根目录（/）切换为 (/first_stage_ramdisk) 
        // 将根切换到 first_stage_ramdisk
        SwitchRoot(&quot;/first_stage_ramdisk&quot;);
    &#125;
    
    // 挂载 system、vendor 、product等系统分区，1
    if (!DoFirstStageMount(!created_devices)) &#123;
        LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;;
    &#125;
    
    // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root
    // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等
    struct stat new_root_info;
    if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123;
        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;
        old_root_dir.reset();
    &#125;
    
    // 如果新的根目录已经创建，则释放old ramdisk，用new ramdisk
    if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123;
        FreeRamdisk(old_root_dir.get(), old_root_info.st_dev);
    &#125;
</code></pre>
<p>如果是正常启动模式则创建 &#x2F;first_stage_ramdisk目录作为根目录，把之前的根目录切换掉，因为之前都是基于根目录创建文件系统，放大了权限，将old根目录切换到first_stage_ramdisk后，将会把first_stage_ramdisk根目录把权限恢复到默认（相对较低的权限），假设old根目录部分文件系统是777权限，切换到<code>/first_stage_ramdisk</code>根目录后，权限会放低（0755），会给一个安全的权限，如果文件权限给太高，是非常危险的，此后会将system、vendor 、product等系统分区挂载到新根目录上。</p>
<blockquote>
<p>必须执行的一步：如果新的根目录已经创建，则释放old ramdisk，用new ramdisk，再将system、vendor 、product等系统分区挂载到&#x2F;first_stage_ramdisk上</p>
</blockquote>
<p>这里再跟一下DoFirstStageMount函数</p>
<h5 id="8-1-DoFirstStageMount"><a href="#8-1-DoFirstStageMount" class="headerlink" title="8.1 DoFirstStageMount"></a>8.1 DoFirstStageMount</h5><p>该方法位于&#x2F;system&#x2F;core&#x2F;init&#x2F;first_stage_mount.cpp#DoFirstStageMount</p>
<pre><code>// 装载设备树中fstab指定的分区
bool DoFirstStageMount(bool create_devices) &#123;
    // 如果处于恢复模式，则跳过第一阶段装载
    if (IsRecoveryMode()) &#123;
        LOG(INFO) &lt;&lt; &quot;First stage mount skipped (recovery mode)&quot;;
        return true;
    &#125;

    auto fsm = FirstStageMount::Create();// 1
    if (!fsm.ok()) &#123;
        LOG(ERROR) &lt;&lt; &quot;Failed to create FirstStageMount &quot; &lt;&lt; fsm.error();
        return false;
    &#125;

    if (create_devices) &#123;
        if (!(*fsm)-&gt;DoCreateDevices()) return false;// 2
    &#125;

    return (*fsm)-&gt;DoFirstStageMount();
&#125;
</code></pre>
<p>先看第一点 <code>auto fsm = FirstStageMount::Create();</code>，该方法主要用于AVB校验，AVB校验可以去看看google文档</p>
<pre><code>Result&lt;std::unique_ptr&lt;FirstStageMount&gt;&gt; FirstStageMount::Create() &#123;
        // 读取fstab,file system table,里面包含了要挂载的逻辑分区
    auto fstab = ReadFirstStageFstab();
    if (!fstab.ok()) &#123;
        return fstab.error();
    &#125;
    // 判断device tree（fstabl）中是否有vbmeta/compatible结构，值是android,vbmeta
    // 创建FirstStageMountVBootV1或者FirstStageMountVBootV2实例，取决于	
    // IsDtVbmetaCompatible(fstab)的返回值，如果支持vbmeta，则使用FirstStageMountVBootV2,反之FirstStageMountVBootV1
    if (IsDtVbmetaCompatible(*fstab)) &#123;
        return std::make_unique&lt;FirstStageMountVBootV2&gt;(std::move(*fstab));
    &#125; else &#123;
        return std::make_unique&lt;FirstStageMountVBootV1&gt;(std::move(*fstab));
    &#125;
&#125;
</code></pre>
<p>以上主要是创建V1或者V2版本的AVB校验，AVB校验主要是针对分区进行校验，对于要启动的 Android 版本中包含的所有可执行代码和数据，启动时验证均要求在使用前以加密形式对其进行验证。包括内核（从 boot 分区加载）、设备树（从 dtbo 分区加载）、system 分区和 vendor 分区等</p>
<ul>
<li>对于 boot 和 dtbo 这类仅读取一次的小分区，通常是通过将整个内容加载到内存中，然后计算其哈希值来进行验证</li>
<li>内存装不下的较大分区（如文件系统）可能会使用哈希树；</li>
<li>如果在某个时刻计算出的根哈希值与预期根哈希值不一致，系统便不会使用相应数据，无法启动Android</li>
<li>在工作上遇到过开发者模式下OEM无法打开的情况，跟代码才发现开启OEM时会把persist分区文件里的指定位置上写入值（忘记值是多少了），通过解析该分区文件，写入的数据会以十六进制保持到指定位置上。但是瞬间就会把OEM的开关站位信息给擦除了，通过log看该分区文件是启用了RPMB分区安全保护机制</li>
</ul>
<p>我们继续看第二点<code>if (!(*fsm)-&gt;DoCreateDevices()) return false;</code></p>
<pre><code>bool FirstStageMount::DoFirstStageMount() &#123;
    // 如果fstab(设备树)为空则不执行挂载动作
    // Fstab是内核在启动时用来挂载文件系统的文件系统表
    if (!IsDmLinearEnabled() &amp;&amp; fstab_.empty()) &#123;
        // Nothing to mount.
        LOG(INFO) &lt;&lt; &quot;First stage mount skipped (missing/incompatible/empty fstab in device tree)&quot;;
        return true;
    &#125;

    // 挂载分区详细步骤
    if (!MountPartitions()) return false;

    return true;
&#125;
</code></pre>
<p>详细逻辑都在<code>MountPartitions</code>里面，继续跟着看看，该内容比较长</p>
<pre><code>bool FirstStageMount::MountPartitions() &#123;
    // 将system分区挂载到设备的“/”根目录
    if (!TrySwitchSystemAsRoot()) return false;
    
    if (!SkipMountingPartitions(&amp;fstab_, true /* verbose */)) return false;
    
    // 读取fstab（设备树，product,vendor等逻辑分区），并把其中的逻辑分区进行挂载
    for (auto current = fstab_.begin(); current != fstab_.end();) &#123;
        // 跳过/system,因为已经挂载上了
        if (current-&gt;mount_point == &quot;/system&quot;) &#123;
            ++current;
            continue;
        &#125;
        // 跳过overlay，稍后后挂载它，OverlayFS是新引入的机制，感兴趣的自行了解
        // 当我们adb remount分区时，本来是可以直接把vendor改rw权限，但是引入overlayfs后仍然时只读权限
        // 因为分为了2层，能读写的始终在第一层，第二层仍然保留了原始的权限，保留其原子性
        if (current-&gt;fs_type == &quot;overlay&quot;) &#123;
            ++current;
            continue;
        &#125;
        
        // flash相关，不太清楚
        if (current-&gt;fs_type == &quot;emmc&quot;) &#123;
            ++current;
            continue;
        &#125;

        // 挂载fstab里的所有逻辑分区（例如：system，system_ext,vendor,product）
        Fstab::iterator end;
        if (!MountPartition(current, false /* erase_same_mounts */, &amp;end)) &#123;
            if (current-&gt;fs_mgr_flags.no_fail) &#123;
                LOG(INFO) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point
                          &lt;&lt; &quot;, ignoring mount for no_fail partition&quot;;
            &#125; else if (current-&gt;fs_mgr_flags.formattable) &#123;
                LOG(INFO) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point
                          &lt;&lt; &quot;, ignoring mount for formattable partition&quot;;
            &#125; else &#123;
                PLOG(ERROR) &lt;&lt; &quot;Failed to mount &quot; &lt;&lt; current-&gt;mount_point;
                return false;
            &#125;
        &#125;
        current = end;
    &#125;
    ...
    // 如果在fstab中没有看到/system或/，那么我们需要为overlayfs创建一个根目录/system或“/”
    if (!GetEntryForMountPoint(&amp;fstab_, &quot;/system&quot;) &amp;&amp; !GetEntryForMountPoint(&amp;fstab_, &quot;/&quot;)) &#123;
        FstabEntry root_entry;
        if (GetRootEntry(&amp;root_entry)) &#123;
            fstab_.emplace_back(std::move(root_entry));
        &#125;
    &#125;

    // 为overlayfs实例化设备文件,将vendor,product,data分区等实例化到该设备文件中
    // 例如/dev/block/dm-33设备文件上挂载的是/data，此时会有dm-verity来验证数据，比如root后更改了设备文件，那校验则会不通过，造成无法开机
    // dm-verity 是一个虚拟块设备，专门用于文件系统的校验，fs直接交互的设备是dm-verity，dm-verity调用真正的块驱动去读取对应的块（dm-verity读取dm-xxx）
    //   /dev/block/dm-3                94M  94M  300K 100% /vendor
    //   /dev/block/dm-2               1.5G 1.5G  4.8M 100% /product
    //   /dev/block/dm-1               166M 165M  508K 100% /system_ext
    //   /dev/block/dm-33              5.8G 609M  5.2G  11% /data
    auto init_devices = [this](std::set&lt;std::string&gt; devices) -&gt; bool &#123;
        for (auto iter = devices.begin(); iter != devices.end();) &#123;
            if (android::base::StartsWith(*iter, &quot;/dev/block/dm-&quot;)) &#123;
                if (!block_dev_init_.InitDmDevice(*iter)) &#123;
                    return false;
                &#125;
                iter = devices.erase(iter);
            &#125; else &#123;
                iter++;
            &#125;
        &#125;
        return InitRequiredDevices(std::move(devices));
    &#125;;
    MapScratchPartitionIfNeeded(&amp;fstab_, init_devices);

    // 再次挂载fstab_里面的全部逻辑分区，也就是overlayfs机制（adb remount也是靠这个机制实现的）
    // 再次声明将只读分区修改为可读写后，写入修改后的分区内容会保存到upperdir上，而不是直接修改其底层分区数据
    // 以保证overlayfs文件操作原子性，这里再次挂载了fstab里的所有逻辑分区，那岂不是重复了？其实这里再次挂载只是一个merged（合并）操作
    fs_mgr_overlayfs_mount_all(&amp;fstab_);

    return true;
&#125;
</code></pre>
<p>以上主要挂载了fstab(设备树)下的所有逻辑分区并实例化到对应的&#x2F;dev&#x2F;block&#x2F;dm-xx设备文件上，例如挂载了：system,system_ext,vendor,product，还有挂载了overlay，overlay机制是用于保护分区原子性和分区安全而存在，具体可以自行了解一下，注释里也解释了一些，代码里两次挂载了fstab下的逻辑分区，第二次挂载是因为overlay机制的影响，是为了合并两个名称相同的分区，这里上一张图片来观察分区挂载的设备文件和位置<br><img src="/../../../images/9fe6c0c9d9d140f68110e5043127eedf.png" alt="img">可以观察到vendor.img镜像被挂载到了&#x2F;vendor分区上，使用的设备文件是<code>/dev/block/dm-3</code></p>
<h4 id="9-FirstStageMain-int-argc-char-argv-—–-gt-setup-9-x2F-10步骤"><a href="#9-FirstStageMain-int-argc-char-argv-—–-gt-setup-9-x2F-10步骤" class="headerlink" title="9. FirstStageMain(int argc, char** argv)—–&gt;setup 9&#x2F;10步骤"></a>9. FirstStageMain(int argc, char** argv)—–&gt;setup 9&#x2F;10步骤</h4><pre><code>        // setup 9
    //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。
    // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root，则会被dm-verity检测到）,
    // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：boot![]()loader，boot.img，system.img。
    // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过
    SetInitAvbVersionInRecovery();
    // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了
    // init程序的二进制文件目录
    const char* path = &quot;/system/bin/init&quot;;
    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux
    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区
    // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp
    execv(path, const_cast&lt;char**&gt;(args));
</code></pre>
<p><code>SetInitAvbVersionInRecovery</code>里的步骤也是读取fstab，然后根据<code>IsDtVbmetaCompatible</code>是否支持AVB2.0,来进行处理，setup 10就是进入下一个阶段了（SetupSelinux）</p>
<h2 id="三-FirstStageMain阶段总结"><a href="#三-FirstStageMain阶段总结" class="headerlink" title="三. FirstStageMain阶段总结"></a>三. FirstStageMain阶段总结</h2><p>以上所有的代码和步骤：根据main.cpp来启用第一阶段<code>FirstStageMain</code>，挂载最基本的文件系统，该文件系统是运行于RAM上的，优点是相比disk磁盘来说运行速度快，不占存储空间，特点是易失性，断电即丢失，挂载上最基本的文件系统后会根据根目录”&#x2F;“来挂载&#x2F;mnt&#x2F;{vendor,product}等重要的分区，其他不重要的文件挂载在第二阶段rc中处理，生成 &#x2F;second_stage_resources&#x2F;system&#x2F;etc&#x2F;ramdisk&#x2F;build.prop,该文件会在第二阶段使用，在第一阶段并开启kernel log，挂载&#x2F;first_stage_ramdisk新的根目录，根据设备树（fstab）来创建逻辑分区system，system_ext,vendor,product并挂载到&#x2F;first_stage_ramdisk根目录上，然后将old 根目录切换到&#x2F;first_stage_ramdisk 根目录，释放old根目录，&#x2F;first_stage_ramdisk根目录将赋予较为安全的权限，创建AVB数据校验，启用overlayfs机制来保护分区原子性，初始化恢复模式下的AVB校验方案，然后调用<code>&quot;/system/bin/init&quot;</code>进入下一个阶段：selinux_setup </p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Android FrameWork/Framework源码分析/Android 13/1.android13启动流程之SeLinux权限介绍" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android-FrameWork/">Android FrameWork</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Framework源码分析</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/">Android 13</a>
    </div>

                        
                        
  



                        
                        
                    </div>
                
                
   

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p> 本章讲解的方向和你将收获的知识：</p>
<ul>
<li>什么是SeLinux系统，SeLinux的简介和介绍</li>
<li>SeLinux系统的主要作用和存在的意义，是基于哪个版本开始推行该方案的</li>
<li>如果遇到了SeLinux权限问题该如何解决，有几种解决方案</li>
<li>SeLinux详细内容知识分解，你将了解宽松模式和严格模式</li>
</ul>
<h3 id="一-SeLinux介绍"><a href="#一-SeLinux介绍" class="headerlink" title="一. SeLinux介绍"></a>一. SeLinux介绍</h3><ol>
<li><p>SeLinux 全称 Security-Enhanced Linux 即安全增强型 Linux，基于MAC机制的一种实现，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统，这不是android特有的特性，而是由Linux衍生过来的SEAndroid。</p>
</li>
<li><p>在Android Q版本上就开始推行SeLinux机制且强行执行此机制（沙盒机制，只能获取到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AOSP&spm=1001.2101.3001.7020">AOSP</a>指定的对外的接口去获取），所以在之前很多应用在Android Q上会产生很多权限相关的问题。</p>
</li>
<li><p>如果在<strong>Android Q或以上的版本遇到权限问题</strong>，尝试命令：<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020">adb</a> shell logcat | grep avc，如果有对应的avc log输出则大概率是受SeLinux权限影响</p>
<blockquote>
<p>avc: denied { <strong>read</strong> } for pid&#x3D;1834 comm&#x3D;“gps_location” name&#x3D;“mmcblk0p17” dev&#x3D;“tmpfs”<br>scontext&#x3D;u:r:gps_location:s0 tcontext&#x3D;u:object_r:block_device:s0 tclass&#x3D;blk_file permissive&#x3D;0</p>
</blockquote>
</li>
<li><p><strong>SeLinux关键字介绍</strong><br>MAC和DAC都隶属于访问控制类，分为自主和强制两种方式<br><img src="/../../../images/3fed48b1140643d890050f861dfd5c8d.png" alt="pic">4.1 <strong>访问控制</strong><br>Linux 内核资源访问控制分为 DAC（Discretionary Access Control，自主访问控制）和 MAC（Mandatory<br>Access Control，强制访问控制）两类<br>4.2 <strong>DAC</strong><br>这是基于用户-用户组的读、写、执行的权限检查，该管理过于宽松，如果获得 root 权限，可以在 Linux 系统内做任何事情<br>4.3 <strong>MAC</strong><br>SELinux是 MAC 机制的一种实现，基于安全上下文和安全策略的安全机制，用于补充 DAC 检查。访问系统资源时，会先进行 DAC 检查，DAC 检查通过，才能进行 MAC 检查，如果 MAC 检查通过，才能获得访问权限</p>
</li>
</ol>
<h3 id="二-SeLinux基础知识"><a href="#二-SeLinux基础知识" class="headerlink" title="二. SeLinux基础知识"></a>二. SeLinux基础知识</h3><blockquote>
<p><strong>SELinux 分为 Permissive 和 Enforcing 两种模式</strong></p>
</blockquote>
<ol>
<li><p>Permissive 宽容模式<br>宽容模式，代表 SELinux 运作中，违反 SELinux 规则时只会有警告讯息（avc denied），而不会实际限制的访问.<br>在 Permissive 模式中，SELinux 被启用，但安全策略规则并没有被强制执行。当安全策略规则应该拒绝访问时，访问仍然被允许。然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝（avc）.</p>
</li>
<li><p>Enforcing 严格模式<br>在 Enforcing 模式中， SELinux 被启动，并强制执行所有的安全策略规则，代表 SELinux 运作中，违反 SELinux 规则的行为将被阻止并记录到日志中(avc)</p>
</li>
<li><p>查看当前SELinux模式<br>（1）通过adb命令行来查看：adb shell getenforce，输出结果—&gt;Enforcing 或者 Permissive<br>（2）通过adb logcat命令行来观察：adb logcat | grep avc</p>
<blockquote>
<p>avc:denied {write setter} for path&#x3D;”&#x2F;dev&#x2F;…” dev&#x3D;”tmpfs”<br>scontext&#x3D;u:r:system_server:s0 tcontext&#x3D;u:object_r:file:s0 <em><strong>permissive&#x3D;1</strong></em><br>(permissive&#x3D;1，说明是 Permissive 模式。permissive&#x3D;0，说明是 Enforcing 模式)</p>
</blockquote>
</li>
<li><p>avc权限语法介绍</p>
<blockquote>
<p>avc: denied { read } for pid&#x3D;1834 comm&#x3D;“system_server” name&#x3D;“mmcblk0p17” dev&#x3D;“tmpfs” ino&#x3D;10268 <strong>[scontext&#x3D;u:r:system_server:s0]</strong> <strong>[tcontext&#x3D;u:object_r:block_device:s0]</strong> tclass&#x3D;blk_file permissive&#x3D;0</p>
</blockquote>
<p>（此 AVC log 说明 system_server（进程）缺少对标签为 block_device、类型为 blk_file 和名称为 mmcblk0p17 文件的 read 权限）<br>(1). avc: denied：表示当前操作被拒绝。<br>(2). { read }：表示被拒绝的操作，{ }中含有实际尝试的操作。<br>(3). for pid&#x3D;1834：当前发生 avc: denied 进程的 ID。<br>(4). comm&#x3D;“system_server”：当前发生 avc: denied 进程的名称，即主体进程名称。<br>(5). name&#x3D;“mmcblk0p17”：操作尝试的目标文件或目录的路径，即客体资源名称。<br>(6). dev&#x3D;“tmpfs”：含有这个文件系统的设备节点，客体资源在该文件系统中。<br>(7). ino&#x3D;10268：目标文件或目录的节点号。<br>(8). scontext&#x3D;u:r:system_server:s0：主体进程的安全上下文。<br>(9). tcontext&#x3D;u:object_r:block_device:s0：客体资源的安全上下文。<br>(10). tclass&#x3D;blk_file：访问资源所属类别。<br>(11). permissive&#x3D;0：当前是 Enforcing 模式，permissive&#x3D;1 时为 Permissive 模式</p>
</li>
</ol>
<h3 id="三-解决SeLinux权限问题"><a href="#三-解决SeLinux权限问题" class="headerlink" title="三. 解决SeLinux权限问题"></a>三. 解决SeLinux权限问题</h3><p>1.命令行修改权限模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root;   </span><br><span class="line">adb shell setenforce <span class="number">0</span> ---&gt;设置为Permissive宽松模式，临时关闭SELinux，机器重启以后还是会恢复的</span><br></pre></td></tr></table></figure>

<p>2.AndroidManifest.xml配置开关<br>需要注意targetSdkVersion 需要小于 30</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于控制应用在Android 10及更高版本上的外部存储行为</span></span><br><span class="line">android:requestLegacyExternalStorage=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>3.修改init启动过程中的代码<br>这种方式比较简单—&gt;修改 system&#x2F;core&#x2F;init&#x2F;selinux.cpp 文件里的 IsEnforcing()函数,直接让它返回false即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEnforcing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ALLOW_PERMISSIVE_SELINUX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">StatusFromProperty</span>() == SELINUX_ENFORCING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelinuxSetEnforcement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getenforce获取Enforcing模式</span></span><br><span class="line">    <span class="type">bool</span> kernel_enforcing = (<span class="built_in">security_getenforce</span>() == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 直接让is_enforcing返回false即关闭严格模式</span></span><br><span class="line">    <span class="type">bool</span> is_enforcing = <span class="built_in">IsEnforcing</span>();</span><br><span class="line">    <span class="keyword">if</span> (kernel_enforcing != is_enforcing) &#123;</span><br><span class="line">        <span class="comment">// 调用security_setenforce(false)设置为Permissive宽容模式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">security_setenforce</span>(is_enforcing)) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;security_setenforce(&quot;</span> &lt;&lt; (is_enforcing ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>)</span><br><span class="line">                        &lt;&lt; <span class="string">&quot;) failed&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">WriteFile</span>(<span class="string">&quot;/sys/fs/selinux/checkreqprot&quot;</span>, <span class="string">&quot;0&quot;</span>); !result.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Unable to write to /sys/fs/selinux/checkreqprot: &quot;</span> &lt;&lt; result.<span class="built_in">error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.根据报错的权限添加SELinux权限<br>由于缺少 SELinux 权限导致如下“avc: denied”，需要根据 AVC log 信息添加相应权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avc: denied &#123; read write &#125; <span class="keyword">for</span> pid=<span class="number">3483</span> comm=“batteryTest” name=“rtc0” </span><br><span class="line">dev=“tmpfs” scontext=u:r:system_server:s0 tcontext=u:object_r:custom_battery_device:s0 </span><br><span class="line">tclass=chr_file permissive=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>system_server（进程）缺少对标签为 custom_battery_device、类型为 chr_file 和名称为 rtc0 文件节点的读写权限。<br>根据上面缺少的avc添加所需的读写权限：<br>(1). 打开&#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;{scontext.te}(system_server.te)文件<br>(2). 添加如下代码：<code>和上面的标签对应上：&#123;allow scontext tcontext:tclass permission &#125;</code><br>(3). 例如<code>allow system_server custom_battery_device:chr_file &#123;read write&#125;</code> ,编译源码并进行烧录即可</p>
<h3 id="四-Neverallow问题"><a href="#四-Neverallow问题" class="headerlink" title="四. Neverallow问题"></a>四. Neverallow问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">添加了selinux权限后，代码进行编译时，编译失败并报 neverallow 错误，例如添加`allow system_app sysfs:file &#123;write&#125;;`权限后</span><br><span class="line">  编译报错</span><br><span class="line"></span><br><span class="line">原因是 Google 不允许应用进程写 sysfs 类型的文件，这是Google规范，安全考虑，部分权限不允许给，</span><br><span class="line">当然也可以修改domain.te来修改Google的规范，虽然可以解决问题，但是这是不被允许的，在送测的时候会导致GMS测试失败。</span><br><span class="line"></span><br><span class="line">例如domain.te拥有以下代码：</span><br><span class="line">neverallow &#123; appdomain -bluetooth -nfc &#125;sysfs:dir_file_class_set write</span><br><span class="line">那么则不允许给dir_file_class_set标签赋予write权限。</span><br><span class="line"></span><br><span class="line">那又必须要这个权限怎么办？那就可以客制化SELiunx权限。</span><br></pre></td></tr></table></figure>

<h3 id="五-SELinux权限客制化（自定义权限）"><a href="#五-SELinux权限客制化（自定义权限）" class="headerlink" title="五. SELinux权限客制化（自定义权限）"></a>五. SELinux权限客制化（自定义权限）</h3><p>根据上面所说，Google规则需遵守，部分权限不允许通过，所以需要自定义权限规则.</p>
<ul>
<li><p>type定义<br>type分为了<code>property.te</code>、<code>file.te</code>、<code>system.te</code>，有很多类型，不止这三种，使用哪个文件取决于avc权限中的tclass属性，目前只用file.te举例，打开file.te添加如下type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/system/sepolicy/<span class="keyword">private</span>/file.te</span><br><span class="line"># &#123;parameter1，parameter2，parameter3&#125;</span><br><span class="line"><span class="meta"># type固定格式，custom_battery_file自定义的名称，file_type定义为文件类型</span></span><br><span class="line"># 逗号分割，后面可以继续跟类型 例如：data_file_type</span><br><span class="line">type custom_battery_file, file_type;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置安全上下文<br>安全上下文分为了 <code>genfs_contexts</code>、<code>file_contexts</code>、<code>property_contexts</code> ，当然不止这几种，例举了一些常用的<br>打开 &#x2F;system&#x2F;sepolicy&#x2F;private&#x2F;file_contexts 文件，打开哪个文件取决于avc权限中的tclass属性<br>（三个xxx_contexts，需要自行判断缺少的权限的客体资源是目录还是文件 或是 属性值）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/system/sepolicy/<span class="keyword">private</span>/file_contexts</span><br><span class="line"># 添加如下代码</span><br><span class="line"># 第一个参数写文件节点（读取这个文件节点没权限，就添加这个节点）</span><br><span class="line"># 第二个参数固定写法u:object_r:custom_battery_file（这里写file.te里定义的类型）:s0（这些参数不做详细解释）</span><br><span class="line">/vendor/custom/product/battery	u:object_r:custom_battery_file:s0</span><br></pre></td></tr></table></figure>


<p>&#x2F;xxx&#x2F;xxx (目标文件路径或文件) u:object_r:file.te里面自定义的名称:s0</p>
</li>
<li><p>配置原进程访问权限<br>根据avc log中的scontext（主体进程）的值来决定在哪个文件下添加访问权限<br>例如 <code>scontext=u:r:system_server:s0</code>，那则打开system_server.te即可</p>
<pre><code>/system/sepolicy/private/system_server.te
# 1.allow固定格式 
# 2.system_server固定格式取决于scontext的值  
# 3.custom_battery_file（file.te里自定义的类型）
# 4.冒号后面的file，取决于avc log中的tclass类型是什么（例如tclass=file）
# 5.&#123;要给的权限类型&#125;
allow system_server custom_battery_file:file &#123;read open&#125;;
</code></pre>
<p>这样就客制化好了一个节点的写权限</p>
</li>
</ul>
<h3 id="六-补充知识（mls规则）"><a href="#六-补充知识（mls规则）" class="headerlink" title="六. 补充知识（mls规则）"></a>六. 补充知识（mls规则）</h3><p>终端中查看安全上下文的方法<br>在终端中，可通过如下指令查看文件安全上下文：ls -lZ<br>在终端中，可通过如下指令查看属性安全上下文：getprop -Z<br>在终端中，可通过如下指令查看进程安全上下文：ps -Z</p>
<blockquote>
<p>如果 te 文件已经添加 SELinux 权限，但没有生效，查看 AVC log 信息出现“s0:c512,c768”字眼，则可判<br>断是由于 mls 规则导致。说明主体和客体安全级别不同，<br>举例：已经在 platform_app.te 中添加了 SELinux 权限，但 log 中依然有如下报错：<br>avc: denied { write } for pid&#x3D;2002 comm&#x3D;“lightness”<br><strong>scontext&#x3D;u:r:platform_app:s0(主体):c512,c768</strong> <strong>tcontext&#x3D;u:r:custom_device_lightness:s0(客体资源)</strong> <strong>tclass&#x3D;char_file(file类型，读取的文件节点属于file类型)</strong> permissive&#x3D;0</p>
</blockquote>
<p><strong>主体：</strong> scontext&#x3D;u:r:【platform_app】<br><strong>客体：</strong> tcontext&#x3D;u:r:【custom_device_lightness】<br>这是因为 Google 在文件 system&#x2F;sepolicy&#x2F;private&#x2F;mls 中进行了安全级的限制，代码如下：<br><code>【mlsconstrain cahr_file &#123; write &#125; (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);】</code><br>l1需要l2相等，或者l1等于mlstrustedsubject l2等于mlstrustedsubject ，才能允许SELiunx权限。</p>
<p>这种情况需要主体进程或者客体进程中的一个是 mlstrustedsubject，这里 platform_app（主体） 最好不要修改，所以要修改客体 slogmodem（客体）。</p>
<p>具体修改方法如下：</p>
<pre><code>/system/sepolicy/private/platform_app.te(取决于主体进程)文件
添加如下代码：
type custom_device_lightness, domain, mlstrustedsubject;
</code></pre>
<h3 id="七-代码修改后烧录"><a href="#七-代码修改后烧录" class="headerlink" title="七. 代码修改后烧录"></a>七. 代码修改后烧录</h3><p>1.如果只是修改 selinux 相关文件–通过编译命令：<br>（1）lunch 项目<br>（2）cd system&#x2F;sepolicy<br>（3）mma<br>将编译产物 out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;system&#x2F;etc&#x2F;selinux 和 out&#x2F;target&#x2F;product&#x2F;xxx&#x2F;vendor&#x2F;etc&#x2F;selinux 拷贝出来，推入手机查看是否生效，执行指令如下：<br>（1）cd out&#x2F;target&#x2F;product&#x2F;xxx<br>（2）adb root<br>（3）adb remount<br>（4）adb push system&#x2F;etc&#x2F;selinux &#x2F;system&#x2F;etc&#x2F;<br>（5）adb push vendor&#x2F;etc&#x2F;selinux &#x2F;vendor&#x2F;etc&#x2F;<br>如果手机不能root &amp;&amp; remount，可以考虑通过编译烧录的方式去验证</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>至此SELinux权限系统基本上介绍完毕，如何解决权限问题，如何关闭权限和切换权限，自定义权限，配置权限，皆已教学完毕。不为别的，为了留下工作上的脚印</p>
</blockquote>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
        </nav>
    
</section>
        </div>
        <footer id="footer">
    <div class="outer">
       
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>