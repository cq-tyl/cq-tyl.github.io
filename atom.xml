<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TYL</title>
  
  <subtitle>myBlog</subtitle>
  <link href="https://cq_tyl.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cq_tyl.gitee.io/"/>
  <updated>2024-03-02T03:53:26.746Z</updated>
  <id>https://cq_tyl.gitee.io/</id>
  
  <author>
    <name>cq_tyl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>完整项目经历</title>
    <link href="https://cq_tyl.gitee.io/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    <id>https://cq_tyl.gitee.io/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/</id>
    <published>2024-03-02T03:03:59.633Z</published>
    <updated>2024-03-02T03:53:26.746Z</updated>
    
    <content type="html"><![CDATA[<p>##项目经历</p><ul><li><p>重庆捷旭科技有限公司                                      2021.02-至今                                         Android工程师 </p><ul><li><p>捷宇rk3566-android13_r6 framework定制开发</p><p>产品简介：<a href="http://www.fjjieyu.com/product/index/133">http://www.fjjieyu.com/product/index/133</a></p><p>1.将云法庭apk内置成系统应用并实现不可退出不可卸载的需求；<br>2.修改开关机动画为云上共享法庭的启动动画；<br>3.app执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;<br>4.实现带鱼屏宽屏的分屏场景-双屏动画切换移动功能；<br>5.冻屏bug处理<br>6.壁纸切换闪黑bug解决</p></li><li><p>云上共享法庭 android开发<br>重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，独立负责里面的内网法官&#x2F;当事人&#x2F;签字<br>端&#x2F;手机端&#x2F;电视端的开发及适配处理；</p></li><li><p>信息发布 android开发<br>类似与广告机的应用，动态实现图片&#x2F;音视频&#x2F;文字&#x2F;定制布局等不同场景的展示及开机自启和自动升级等功能；</p></li><li><p>案件排期 android开发<br>一款基层法院窗口信息显示应用，通过与条屏厂家对接实现条屏的适配显示窗口信息等；</p></li><li><p>傲视取号机 android开发<br>一款基层法院取号应用，通过与硬件厂家对接实现刷身份证，取号，叫号，切纸等操作；</p></li></ul></li><li><p>重庆国狮科技有限公司                                         2018.02-2019.03                                   Android组负责人</p><ul><li>出行加司机 android开发<br>一款专用于出行加网约车平台司机接单应用,根据司机注册公司及车辆信息，可动态接<br>取不同类型的网约车订单，该应用已繁衍出小巷约车应用。</li><li>出行加乘客 android开发<br>一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不<br>同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以<br>激励用户的使用</li><li>项目名称： 商务司机<br>一款用于网约车乘客派单的应用，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不<br>同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以<br>激励用户的使用</li><li>文具购（二次开发 Android<br>是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类<br>查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能</li><li>vaptcha手势验证 android开发<br>公司接的一个外包项目，android应用的第三方库开发，识别并计算出用户的手势滑动<br>坐标并上传至后台返回完成手势验证。<br>Vaptcha Sdk文档 https &#x2F;&#x2F;<a href="http://www.jianshu.com/p/1b72ea2142c2">www.jianshu.com/p/1b72ea2142c2</a></li><li>富山 android开发<br>类似于梦想打卡的投资类项目，主体由android原生结合webView完成，该项目完成<br>周期仅用了3个星期的时间并通过招商等形式繁衍出了富海应用。</li><li>完美日程 android开发<br>一款仿谷歌日历的本地日历应用，已完成大部分业务逻辑，包含了自定义日历视图，<br>本地日历活动同步，节假日的动态显示以及用户自定义个人目标等功能。</li><li>梦想打卡 android开发<br>一款提供给用户在固定时间进行签到的应用，用户可选择参与不同的打卡签到活动，<br>在指定时间完成签到则获得现金奖励，该项目通过招商等形式已繁衍出喔喔打卡&#x2F;星星<br>打卡等应用。</li></ul></li><li><p>重庆全心协力科技有限公司                             2016.04-2018.02                             Android工程师 </p><ul><li>现场云 android开发<br>是公司自己的项目（已维护更新5个版本），打造的一款提升工厂生产效率，旨 在避免<br>问题产生到问题解决无人监管无人记录导致同一问题反复出现或无人处 理的情况，兼<br>具点检和报表统计，即时聊天等功能。</li><li>文具购（二次开发） android开发<br>是公司接的外包项目，阿里巴巴旗下的文具经销商制定的文具贩卖app，集成 了分类<br>查询，限时促销，物流配送及查询，支付宝及微信付款，评价等功能</li><li>健康西南 android开发<br>是在医事通平台下，西南医院的一款App，也集合了预约挂号、导医、查询等 功能。</li><li>小马医疗 android开发<br>一款为以医疗、推广为主的App。主要功能有预约挂号、健康咨询、健康商城 等。分<br>四个主界面全部用原生的页面撰写，其余二级页面加载网页</li><li>医事通 android开发<br>广州市卫生信息服务平台的手机版，为用户更方便快捷的提供预约挂号服务</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##项目经历&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重庆捷旭科技有限公司   	                                   2021.02-至今                                         Android工程师 &lt;/p</summary>
      
    
    
    
    <category term="其他笔记" scheme="https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"/>
    
    <category term="我的简历" scheme="https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>我的简历</title>
    <link href="https://cq_tyl.gitee.io/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E6%AD%A3%E5%BC%8F%E7%AE%80%E5%8E%86/"/>
    <id>https://cq_tyl.gitee.io/wiki/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/%E6%AD%A3%E5%BC%8F%E7%AE%80%E5%8E%86/</id>
    <published>2024-03-02T02:00:11.905Z</published>
    <updated>2024-03-02T04:55:45.413Z</updated>
    
    <content type="html"><![CDATA[ <center>     <h1>唐玉龙</h1> </center><p>##个人信息</p><ul><li><p>性 别：男                                                                     年 龄：34 </p></li><li><p>手 机：18996195388                                                             邮 箱：<a href="mailto:&#x31;&#x31;&#x30;&#x34;&#x36;&#53;&#51;&#x32;&#54;&#50;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;">&#x31;&#x31;&#x30;&#x34;&#x36;&#53;&#51;&#x32;&#54;&#50;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;</a></p></li><li><p>学校：重庆交通大学(非全) 本科                                                 专 业：计算机科学与技术</p></li><li><p>工作年限：7年app&amp;1年framework                                                  岗 位：Android研发工程师</p></li><li><p>博客：<a href="https://cq-tyl.github.io/">https://cq-tyl.github.io</a>                                                            简书：<a href="https://www.jianshu.com/u/517b3c07af90">https://www.jianshu.com/u/517b3c07af90</a></p></li></ul><p>##专业技能</p><ul><li>8年互联网开发经验(7年app&amp;1年framework)，精通Java语言，了解C语言，并熟悉SDK及NDK、JNI开发；</li><li>熟悉安卓系统架构，熟悉Android系统启动流程，熟悉IMS,了解WMS，AMS模块；</li><li>熟悉画中画、分屏、自由窗口,了解SystemUl,Launcher3等系统应用的定制开发；</li><li>熟悉winscop,perfetto,systrace,Profile,adb,logcat,dumpsys等常用调试工具；</li><li>熟悉Binder,Aidl,socket等跨进程通信;</li><li>熟练处理冻屏、闪黑、不开机、重启、死机、黑屏、定屏、ANR、Crash等问题;</li><li>熟悉app组件化开发、jetpack及各种安卓开发组件；</li><li>熟悉app性能优化、屏幕适配、进程保活、软件稳定性处理；</li><li>熟悉git,svn,as,asfp,vscode,vim等常用开发工具；</li><li>能够解决Framework层的定制问题并熟悉Android APK及Android系统应用的开发流程，拥有良好的表达能力与沟通能力,工作积极主动,<br>能尽心尽责地完成本职工作. 热衷于移动互联的垂直领域,对Hal及bsp方向有着浓厚的兴趣；</li></ul><p>##工作经历</p><ul><li><p>重庆捷旭科技有限公司                                      2021.02-至今                                         Android工程师 </p></li><li><p>重庆国狮科技有限公司                                          2018.02-2019.03                                  Android组负责人</p></li><li><p>重庆全心协力科技有限公司                                  2016.04-2018.02                                  Android工程师</p></li></ul><p>##重点项目经历</p><ul><li><p>捷宇M32-rk3566-android13_r6 framework定制开发</p><ul><li>项目简介：定制M32信息交互终端设备，集成身份核验、电子签名、指纹采集、社保卡读写、二维码扫描、高拍仪、服务评价、数据加密等功能，能有效实现业务无纸化办理，应用于电子政务、医保社保、卫生健康、公共服务等智慧办公、身份核验及签批审核无纸化等领域。</li><li>项目地址：<a href="http://www.fjjieyu.com/product/index/133">http://www.fjjieyu.com/product/index/133</a></li><li>项目职责：</li><li>使用技术：<ul><li><p>将apk内置成系统应用实现不可退出不可卸载的需求；</p></li><li><p>修改开关机动画为云上共享法庭的启动动画；</p></li><li><p>app执行shell命令（自定义服务实现app通过自定义服务与adbd通信来实现shell命令）;</p></li><li><p>实现带鱼屏宽屏的分屏场景-双屏动画切换移动功能；</p></li><li><p>冻屏bug处理</p></li><li><p>壁纸切换闪黑bug解决</p></li></ul></li></ul></li><li><p>云上共享法庭APP开发</p><ul><li><p>项目简介：重庆全市法院数智法庭建设的重点项目，实现法院庭审从排期到闭庭签字的全流程办案，独立负责里面的内网法官&#x2F;当事人&#x2F;签字端&#x2F;手机端&#x2F;电视端的Android开发及适配处理任务；</p></li><li><p>项目地址：<a href="https://www.jetshine.com.cn/product.html?id=1520657316474638337">https://www.jetshine.com.cn/product.html?id=1520657316474638337</a></p></li><li><p>项目职责：</p></li><li><p>使用技术：</p></li></ul></li><li><p>出行加司机&amp;乘客 android开发 </p><ul><li><p>项目简介：一款专用于出行加网约车平台司机接单,网约车乘客派单的应用，根据司机注册公司及车辆信息，可动态接取不同类型的网约车订单，乘客可选择出租车&#x2F;专车&#x2F;顺风车&#x2F;闪电送&#x2F;代驾等不同类型的车辆并派单，应用也提供了店铺优惠信息的发布以及领取等各种优惠活动以激励用户的使用，该应用已繁衍出小巷约车应用；</p></li><li><p>项目地址：<a href="https://www.dacheruanjian.cn/index.html">https://www.dacheruanjian.cn/index.html</a></p></li><li><p>项目职责：</p></li><li><p>使用技术：</p></li></ul></li></ul><p>##完整项目经历</p>]]></content>
    
    
      
      
    <summary type="html"> &lt;center&gt;
     &lt;h1&gt;唐玉龙&lt;/h1&gt;
 &lt;/center&gt;

&lt;p&gt;##个人信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;性 别：男						                                                               </summary>
      
    
    
    
    <category term="其他笔记" scheme="https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/"/>
    
    <category term="我的简历" scheme="https://cq_tyl.gitee.io/categories/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>MVC、MVP、MVVM架构</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%E8%BF%9B%E9%98%B6/MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/</id>
    <published>2024-02-18T08:25:45.849Z</published>
    <updated>2024-02-27T06:36:10.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-架构介绍"><a href="#01-架构介绍" class="headerlink" title="01 架构介绍"></a>01 架构介绍</h2><p>先来看一下MVC、MVP、<a href="https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020">MVVM</a>的架构图。</p><p><img src="/../../images/be7811835b0814ddeebca2ffa18b4b7b.png"></p><p>从这些架构图中，可以看到每种架构都有3个模块以及数据流动方向箭头。</p><p><strong>模块</strong></p><p>在系统架构中，首先要做的就是把系统整体按照一定的原则划分成模块。</p><p><strong>数据流动</strong></p><p>模块划分之后，模块之间的通信，就是数据的流动。在Android中，流动数据包括两部分，事件和数据。</p><p><strong>架构</strong></p><p>模块和模块之间的数据通信方式构成不同的架构。在这3种架构中，都是把系统整体划分成了3个模块：<strong>视图层，数据层，业务层。</strong> 他们之间的区别在于，模块之间的通信方式（数据流动方向）不一致。</p><ul><li>MVC是视图层接收到事件后调用到业务层处理业务逻辑，业务层调用数据层处理数据，数据层再调用视图层更新页面。</li><li>MVP是视图层接收到事件后调用到业务层处理，业务层调用数据层处理数据，数据层处理数据后回调给业务层，业务层再回调给视图层更新页面。（数据层已不再持有视图层，他们之间通过业务层（Presenter）交互，具体使用接口实现，使数据层和视图层解耦。</li><li>MVVM在MVP的基础上实现了视图层和业务层的双向数据绑定（data binding），不再通过接口的方式交互，ViewModel不在和Presenter一样持有视图层，使视图层和业务层解耦。</li></ul><h2 id="02-具体实现"><a href="#02-具体实现" class="headerlink" title="02 具体实现"></a>02 具体实现</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="/../../images/c37db6c4812686b6d6ed0a1396bfd213.png"></p><p>视图层：在<a href="https://so.csdn.net/so/search?q=MVC%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">MVC架构</a>中， Android的xml布局文件和Activity&#x2F;Fragment文件被划分为View视图层。 因为xml作为视图层功能太弱，只能够实现页面的布局，不能够实现页面数据和事件的处理。需要和Activity一起才能够构成一个完整的视图层。</p><p>业务层：大多数的MVC架构开发的安卓项目， 并没有把Controller业务层独立出来，而是将业务层也在Activity&#x2F;Fragment中实现。这导致了Activity&#x2F;Fragment的代码非常臃肿，这就是MVC的缺点之一。 在本例中，我们会将业务层独立出来，实现一个标准的MVC架构。</p><p>数据层：数据层Model指的是，数据管理模块，这包括了数据的获取，处理。存储等。 MVP、MVVM的架构中的Model也是一样。后面不再赘述。</p><p><strong>代码结构</strong></p><img src="../../images/e27724fe4c2920ff7b1623bf12b8f015.png" style="zoom:67%;" /><p><strong>xml代码</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/ll_gallery_outer&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_result&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center&quot; /&gt;    &lt;EditText        android:id=&quot;@+id/tv_account&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;40dp&quot;        android:layout_gravity=&quot;center&quot;        android:layout_marginLeft=&quot;16dp&quot;        android:layout_marginTop=&quot;20dp&quot;        android:layout_marginRight=&quot;16dp&quot;        android:gravity=&quot;center&quot;        android:hint=&quot;输入用户名&quot; /&gt;    &lt;EditText        android:id=&quot;@+id/tv_pwd&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;40dp&quot;        android:layout_gravity=&quot;center&quot;        android:layout_marginLeft=&quot;16dp&quot;        android:layout_marginRight=&quot;16dp&quot;        android:gravity=&quot;center&quot;        android:hint=&quot;输入密码&quot; /&gt;    &lt;Button        android:id=&quot;@+id/btn_login&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;40dp&quot;        android:layout_gravity=&quot;center&quot;        android:layout_marginLeft=&quot;16dp&quot;        android:layout_marginRight=&quot;16dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;登录&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p><strong>Activity代码</strong></p><pre><code>public class MVCActivity extends AppCompatActivity &#123;    TextView tvResult;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_login);         tvResult = findViewById(R.id.tv_result);        TextView tvAccount = findViewById(R.id.tv_account);        TextView tvPwd = findViewById(R.id.tv_pwd);        Button btnLogin = findViewById(R.id.btn_login);        MVCController mvcController = new MVCController();        btnLogin.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                mvcController.login(tvAccount.getText().toString(),tvPwd.getText().toString(), MVCActivity.this);            &#125;        &#125;);    &#125;    public void loginSuccess()&#123;        tvResult.setText(&quot;登录结果：登录成功&quot;);    &#125;    public void loginFail()&#123;        tvResult.setText(&quot;登录结果：登录失败&quot;);    &#125;&#125;</code></pre><p>​    </p><p><strong>Controller代码</strong></p><pre><code>public class MVCController &#123;    MVCModel mvcModel;    public MVCController() &#123;        mvcModel = new MVCModel();    &#125;    public void login(String account, String pwd, MVCActivity loginActivity) &#123;        mvcModel.login(account, pwd, loginActivity);    &#125;&#125;</code></pre><p>​    </p><p><strong>Model代码</strong></p><pre><code>public class MVCModel &#123;    public void login(String account, String pwd, MVCActivity loginActivity)&#123;        if (account == null || account.length()==0) &#123;            loginActivity.loginFail();        &#125;        if (pwd == null || pwd.length()==0) &#123;            loginActivity.loginFail();        &#125;        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd))&#123;            loginActivity.loginSuccess();        &#125;    &#125;&#125;</code></pre><h4 id="实现代码说明"><a href="#实现代码说明" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>在Activity中监听登录按钮的事件，接收到事件之后，调用Controller的登录方法处理登录逻辑，在Controller的登录方法中调用Model请求网络数据（这里是模拟）判断是否登录成功，Model拿到登录结果后，调用Activity的方法刷新页面数据，展示登录结果。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：通过划分模块的方式，将系统分成了3个模块，视图层，业务层和数据层。 代码开发实现不再是只在一个代码文件中，一定程度便于程序开发。</p><p>缺点：但是三个模块之间还存在很强的耦合关系。 不利于业务需求的更变和代码维护工作。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><img src="/../../images/aa8a22ae779896db83a16b173c9782a4.png"></p><p><a href="https://so.csdn.net/so/search?q=MVP%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">MVP架构</a>是基于MVC的改进，将MVC的中Controller独立出来作为Presenter。 xml和Activity还是作为视图层， 视图层接收到页面数据，调用Presenter进行业务逻辑处理，Presenter调用Model进行数据处理，Model回传数据给Presenter，Presenter回传数据给View。数据的回传通过接口回调的方式来实现。</p><p><strong>代码结构</strong></p><p><img src="/../../images/ceb4b647e87386e3bbdaa4a844249588.png"></p><p><strong>IModel接口代码</strong></p><pre><code>public interface IModel &#123;    public boolean login(String account, String pwd);&#125;</code></pre><p>​    </p><p><strong>IView接口代码</strong></p><pre><code>public interface IView &#123;    public void loginSuccess();    public void loginFail();&#125;</code></pre><p>​    </p><p><strong>Activity代码</strong></p><pre><code>public class MVPActivity extends AppCompatActivity implements IView &#123;    TextView tvResult;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_login);        tvResult = findViewById(R.id.tv_result);        TextView tvAccount = findViewById(R.id.tv_account);        TextView tvPwd = findViewById(R.id.tv_pwd);        Button btnLogin = findViewById(R.id.btn_login);        MVPPresenter presenter = new MVPPresenter();        presenter.setiView(this);        btnLogin.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                presenter.login(tvAccount.getText().toString(), tvPwd.getText().toString());            &#125;        &#125;);    &#125;    public void loginSuccess() &#123;        tvResult.setText(&quot;登录结果：登录成功&quot;);    &#125;    public void loginFail() &#123;        tvResult.setText(&quot;登录结果：登录失败&quot;);    &#125;&#125;</code></pre><p><strong>Model代码</strong></p><pre><code>public class MVPModel implements IModel &#123;    public boolean login(String account, String pwd) &#123;        if (account == null || account.length() == 0) &#123;            return false;        &#125;        if (pwd == null || pwd.length() == 0) &#123;            return false;        &#125;        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p><strong>Presenter代码</strong></p><pre><code>public class MVPPresenter &#123;    MVPModel model;    public MVPPresenter() &#123;        model = new MVPModel();    &#125;    IView iView;    public void setiView(IView iView) &#123;        this.iView = iView;    &#125;    public void login(String account, String pwd) &#123;        boolean loginResult = model.login(account, pwd);        if (loginResult)&#123;            iView.loginSuccess();        &#125;else &#123;            iView.loginFail();        &#125;    &#125;&#125;</code></pre><h4 id="实现代码说明-1"><a href="#实现代码说明-1" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>定义了两个接口，IView和IModel, Activity和Model分别实现了这两个接口。 在Presenter中持有这两个实例。Presenter调用Model处理数据后，通过Iview的接口方法回调给Activity刷新页面。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>从上面的代码可以看到，三个模块之间的通信是通过接口实现的，在实际开发，定义的接口和方法会非常多。 导致很简单的一个页面功能也需要实现多个接口和方法。</p><p>优点就是通过Presenter，把MVC中的Controller代码抽出来了，并且Presenter作为View和Model通信的桥梁，完成了Model和View的解耦。</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><img src="/../../images/721acde222529fd6f3964f1fa7755c63.png"></p><p>MVVM在MVP的基础上加入了双向绑定，使View能够感知ViewModel中的数据变化，ViewModel能够感知View数据的变化。</p><p><strong>代码结构</strong></p><p><img src="/../../images/945eade69fd1693f76c583b4251da203.png"></p><p><strong>xml代码</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable            name=&quot;viewModel&quot;            type=&quot;com.domain.android.study.notes.architecture.mvvm.MVVMViewModel&quot; /&gt;    &lt;/data&gt;    &lt;LinearLayout        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        android:id=&quot;@+id/ll_gallery_outer&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;TextView            android:id=&quot;@+id/tv_result&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@&#123;viewModel.result&#125;&quot;            android:layout_gravity=&quot;center&quot; /&gt;        &lt;EditText            android:id=&quot;@+id/tv_account&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_marginLeft=&quot;16dp&quot;            android:layout_marginRight=&quot;16dp&quot;            android:layout_height=&quot;40dp&quot;            android:hint=&quot;输入用户名&quot;            android:gravity=&quot;center&quot;            android:text=&quot;@=&#123;viewModel.account&#125;&quot;            android:layout_gravity=&quot;center&quot;            android:layout_marginTop=&quot;20dp&quot; /&gt;        &lt;EditText            android:id=&quot;@+id/tv_pwd&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_marginLeft=&quot;16dp&quot;            android:layout_marginRight=&quot;16dp&quot;            android:layout_height=&quot;40dp&quot;            android:hint=&quot;输入密码&quot;            android:text=&quot;@=&#123;viewModel.pwd&#125;&quot;            android:gravity=&quot;center&quot;            android:layout_gravity=&quot;center&quot; /&gt;        &lt;Button            android:id=&quot;@+id/btn_login&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_marginLeft=&quot;16dp&quot;            android:layout_marginRight=&quot;16dp&quot;            android:layout_height=&quot;40dp&quot;            android:text=&quot;登录&quot;            android:gravity=&quot;center&quot;            android:layout_gravity=&quot;center&quot; /&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p><strong>Activity代码</strong></p><pre><code>public class MVVMActivity extends AppCompatActivity &#123;    MVVMViewModel viewModel;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        ActivityLoginBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_login);        viewModel = ViewModelProviders.of(this).get(MVVMViewModel.class);        binding.setVariable(BR.viewModel, viewModel);        binding.setLifecycleOwner(this);        binding.btnLogin.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                viewModel.login();            &#125;        &#125;);    &#125;&#125;</code></pre><p><strong>ViewModel代码</strong></p><pre><code>public class MVVMViewModel  extends ViewModel &#123;    public ObservableField&lt;String&gt; account = new ObservableField&lt;&gt;(&quot;&quot;);    public ObservableField&lt;String&gt; pwd = new ObservableField&lt;&gt;(&quot;&quot;);    public ObservableField&lt;String&gt; result = new ObservableField&lt;&gt;(&quot;&quot;);    MVVMModel mvvmModel;    public MVVMViewModel() &#123;         mvvmModel = new MVVMModel();    &#125;    public void login()&#123;        boolean loginResult = mvvmModel.login(account.get(), pwd.get());        result.set(loginResult ? &quot;登录结果：成功&quot; :&quot;登录结果：失败&quot;);    &#125;&#125;</code></pre><p><strong>Model代码</strong></p><pre><code>public class MVVMModel &#123;    public boolean login(String account, String pwd) &#123;        if (account == null || account.length() == 0) &#123;            return false;        &#125;        if (pwd == null || pwd.length() == 0) &#123;            return false;        &#125;        if (&quot;user123&quot;.equals(account) &amp;&amp; &quot;pwd123&quot;.equals(pwd)) &#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p><strong>注意</strong></p><p>在本例MVVM架构实现中，用到了Android提供的data binding这个数据双向绑定框架。需要在APP模块的gralde文件中添加以下配置开启：</p><pre><code> android &#123; ... dataBinding &#123;        enabled true    &#125;  ...    &#125;</code></pre><h4 id="实现代码说明-2"><a href="#实现代码说明-2" class="headerlink" title="实现代码说明"></a>实现代码说明</h4><p>通过Android提供的数据双向绑定库data binding 将Acitvity&#x2F;xml视图层与ViewModel绑定。在xml布局文件中，通过<code>@&#123;&#125;</code>来表示单向绑定或者<code>@=&#123;&#125;</code>来表示双向绑定。Activity接受到视图层的登录点击事件后，调用ViewModel处理登录业务逻辑，ViewModel通过双向数据绑定拿到到视图层输入的账号密码数据，调用Model处理数据，Model处理数据后，回传给ViewModel, ViewModel的数据改变，View感知后刷新页面。</p><p><strong>注意</strong></p><p>data binding通过观察者模式实现。 内部具体实现也是通过调用notify通知数据变化给观察者，notify调用了观察者实现的接口方法。</p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：经过数据双向绑定之后，我们不在需要想MVP中写那么多接口回调方法区实现视图层和业务层的交互。业务层也不再持有视图层的引用。</p><p>缺点：通过这种方式进行数据双向绑定后，xml中会多出一些标签、表达式、甚至和业务有点的简单计算代码。这不利于业务的逻辑的查看。并且由于双向绑定是data binding实现的。在这个过程中， 如果出现bug导致数据没有被感知改变，不方便排错，因为xml不能debug调试。</p><h2 id="03-总结"><a href="#03-总结" class="headerlink" title="03 总结"></a>03 总结</h2><p>MVC、MVP、MVVM大体上都是把系统划分成3个模块：视图层、业务层、数据层。 但是他们的通信方式、数据流动方向不一致，形成了不同的架构。 其后面产生的架构都是为了更好的解耦，解决已有架构的不足。每个架构都有自己的优缺点，<strong>没有最好的架构，只有最合适的架构。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-架构介绍&quot;&gt;&lt;a href=&quot;#01-架构介绍&quot; class=&quot;headerlink&quot; title=&quot;01 架构介绍&quot;&gt;&lt;/a&gt;01 架构介绍&lt;/h2&gt;&lt;p&gt;先来看一下MVC、MVP、&lt;a href=&quot;https://so.csdn.net/so/searc</summary>
      
    
    
    
    <category term="Android进阶" scheme="https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>0.jetpack合集</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%E8%BF%9B%E9%98%B6/Jetpack/0.jetpack%E5%90%88%E9%9B%86/</id>
    <published>2024-02-18T07:45:36.748Z</published>
    <updated>2024-02-18T07:47:00.989Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/jetpack合集.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;/pdf/jetpack合集.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;


</summary>
      
    
    
    
    <category term="Android进阶" scheme="https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    <category term="Jetpack" scheme="https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/Jetpack/"/>
    
    
  </entry>
  
  <entry>
    <title>0.app性能优化集合</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/0.app%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9B%86%E5%90%88/</id>
    <published>2024-02-18T07:26:02.418Z</published>
    <updated>2024-02-18T07:32:51.951Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/app性能优化.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;/pdf/app性能优化.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;




</summary>
      
    
    
    
    <category term="Android进阶" scheme="https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    <category term="性能优化" scheme="https://cq_tyl.gitee.io/categories/Android%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/4.WMS%E7%AA%97%E5%8F%A3%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/</id>
    <published>2024-01-15T01:54:22.172Z</published>
    <updated>2024-01-15T01:55:45.566Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="4-WMS窗口相关流程"><a href="#4-WMS窗口相关流程" class="headerlink" title="4.WMS窗口相关流程"></a>4.WMS窗口相关流程</h2><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>什么是窗口<br>窗口即是屏幕上的一块用于绘制各种UI元素并可以响应<a href="https://so.csdn.net/so/search?q=%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5&spm=1001.2101.3001.7020">用户输入</a>的一个矩形区域。从原理上讲，窗口的概念是独自占有一个Surface实例的显示区域（我们在屏幕上看到的图形都需要绘制在Surface上）。<br>Window是个<a href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&spm=1001.2101.3001.7020">抽象类</a>其实现类为PhoneWindow。<br>本文以窗口添加的流程为例，讲解窗口添加相关的流程及其涉及的方法。<br>其他建议：可以先学习<a href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树相关内容，有助于对窗口模块的理解<br><a href="https://blog.csdn.net/yimelancholy/article/details/132174913">Android T 窗口层级其一 —— 容器类</a><br><a href="https://blog.csdn.net/yimelancholy/article/details/132213111">Android T 窗口层级其二 —— 层级结构树的构建</a><br><a href="https://blog.csdn.net/yimelancholy/article/details/132722735">Android T 窗口层级其三 —— 层级结构树添加窗口</a></p><h2 id="二、流程简述"><a href="#二、流程简述" class="headerlink" title="二、流程简述"></a>二、流程简述</h2><p>当Activity.onResume()被调用之后，客户端会与WMS进行通信将我们的布局显示在屏幕上。其中主要涉及以下几个过程：<br>客户端通知WMS创建一个窗口，并添加到WindowToken。即addToDisplayAsUser阶段。<br>客户端通知WMS创建Surface，并计算窗口尺寸大小。即relayoutWindow阶段。<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度。即performMeasure阶段。<br>客户端确定该窗口下View的尺寸和位置。即performLayout阶段。<br>确定好View的尺寸大小位置之后，便对View进行绘制。即performDraw阶段。<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来。即reportDrawFinished阶段。<br><img src="/../../../../../images/9bac0587c3614e088e376a948ffb45cb.png" alt="在这里插入图片描述"><br>这里以Activity.onResume()被调用之后为起点</p><h3 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h3><p>WindowManager：是一个接口类，负责窗口的管理（增、删、改）。</p><p>WindowManagerImpl：WindowManager的实现类，但是他把对于窗口的具体管理操作交给WindowManagerGlobal来处理。</p><p>WindowManagerGlobal：是一个单例类，实现了窗口的添加、删除、更新的逻辑，但是</p><p>ViewRootImpl：通过IWindowSession与WMS进行通信。其内部类W实现了WMS与ViewRootImpl的通信。<br><img src="/../../../../../images/7817e0249e55462596f58e9a66e68ac9.png" alt="在这里插入图片描述"></p><p>ActivityThread.java</p><ul><li>handleResumeActivity<br>通过WindowManager接口添加view，即<code>wm.addView(decor, l);</code>，wm为ViewManager对象，即<code>ViewManager wm = a.getWindowManager();</code></li></ul><p>WindowManagerImpl.java</p><ul><li>addView<br><code>mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,mContext.getUserId());</code>mGlobal为WindowManagerGlobal对象。</li></ul><p>WindowManagerGlobal.java</p><ul><li>addView<br><code>root.setView(view, wparams, panelParentView, userId);</code>root为ViewRootImpl对象。<br><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>parentWindow为Window（Window为抽象类，PhoneWindow继承于Window），即在Window中调用adjustLayoutParamsForSubWindow，用于赋值参数布局的token以及title</li></ul><p>ViewRootImpl.java</p><ul><li>setView<br>1.addToDisplayAsUser<br>客户端通知WMS创建一个窗口，并添加到WindowToken<br><code>res = mWindowSession.addToDisplayAsUser(mWindow,mWindowAttributes,getHostVisibility(), mDisplay.getDisplayId(), userId,mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,mTempControls);</code><br>2.requestLayout<br>在添加到窗口管理器之前安排第一个布局，以确保我们在从系统接收任何其他事件之前进行重新布局<br>scheduleTraversals-&gt;doTraversal-&gt;performTraversals<br>performTraversals中调用了五个关键方法：<br>relayoutWindow<br>客户端通知WMS创建Surface，并计算窗口尺寸大小<br>performMeasure<br>客户端获取到WMS计算的窗口大小后，进一步测量该窗口下View的宽度和高度<br>performLayout<br>客户端确定该窗口下View的尺寸和位置<br>performDraw<br>确定好View的尺寸大小位置之后，便对View进行绘制<br>createSyncIfNeeded-&gt;reportDrawFinished<br>通知WMS，客户端已经完成绘制。WMS进行系统窗口的状态刷新以及动画处理，并最终将Surface显示出来</li></ul><h3 id="2-通信方式"><a href="#2-通信方式" class="headerlink" title="2. 通信方式"></a>2. 通信方式</h3><p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p><ul><li><p>IWindowSession.aidl<br>ViewRootImpl中通过此接口调用服务端<br>1.addToDisplayAsUser<br>2.relayout<br>3.finishDrawing</p></li><li><p>Session.java<br>IWindowSession的实现在这里，最终调用到WMS中<br>1.addToDisplayAsUser-&gt;addWindow<br>2.relayout-&gt;relayoutWindow<br>3.finishDrawing-&gt;finishDrawingWindow</p></li></ul><h3 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3. 服务端"></a>3. 服务端</h3><p>WindowManagerService：负责为Activity对应的窗口分配Surface，管理Surface的显示顺序以及位置尺寸，控制窗口动画，并且还是输入系统的一个重要中转站。</p><p>WindowState：和客户端窗口一一对应，在向WMS添加一个窗口时，WMS会为其创建一个WindowState，来表示窗口的所有属性，WindowState相当于属性窗口管理（比如对外提供操作接口，属于层级结构中最底部的容器），窗口画面相关都剥离给了WindowStateAnimator，WindowState也是WMS中事实上的窗口。</p><p>WindowStateAnimator：主要用于管理WindowState相关画面surface，通过mDrawState参数来描述Surface所处的状态。</p><p>WindowToken：保存了所有具有同一个token的WindowState，将属于同一个activity的窗口组织在一起，activity在需要更新窗口时，必须向WMS提供WindowToken以表名自己的身份，并且窗口的类型必须与所持有的的WindowToken类型一致。<br>补充：一个WindowToken可以对应多个WindowState。 WindowToken是一个用于表示窗口层次结构中的窗口的标识符。每个Window具有一个与之关联的WindowToken，它用于帮助系统管理窗口的显示和交互。<br>一个WindowToken可以有多个WindowState表示与之相关的窗口。这是因为在Android系统中，可能会存在一些特殊情况，例如PopupWindow、Dialog等，它们属于同一个WindowToken，但是显示在不同的窗口上。<br>因此，一个WindowToken可以与多个WindowState关联，这样可以实现多个窗口的操作和管理。</p><p>WindowSurfaceController：用来创建SurfaceControl。</p><p>DisplayContent：即代表的是单个屏幕。隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每个DisplayContent都对应着一个唯一的id，在添加窗口时可以通过指定这个ID决定将其显示在哪个屏幕中。</p><p>WindowSurfacePlacer：整个窗口层次结构刷新的入口。</p><p>RootWindowContainer：是窗口容器的顶层容器，其直接管理DisplayContent。</p><p><strong>WindowManagerService.java</strong></p><h4 id="3-1-addWindow"><a href="#3-1-addWindow" class="headerlink" title="3.1.addWindow"></a>3.1.addWindow</h4><p><img src="/../../../../../images/f032b7cd5a8c470baec7a233a96571a1.png" alt="在这里插入图片描述"><br>1.根据客户端传来的token获取WindowToken或创建WindowToken，并将其挂载到对应的层级节点上<br><code>WindowToken token = displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);</code><br>判断WindowToken是否有父亲,即parentWindow 是否不为空<br><code>final boolean hasParent = parentWindow != null;</code><br>注：前面代码有判断是否是子窗口，是则会给parentWindow 赋值；否则parentWindow仍为初始值，即为空<br><img src="/../../../../../images/5b2dfebaa2fa466bbc667e9140ea7150.png" alt="在这里插入图片描述"><br>关于窗口类型，见 <a href="https://blog.csdn.net/yimelancholy/article/details/130442487">窗口常见参数汇总</a><br>Activity启动时会在ActivityRecord的构造方法中new Token()。<br><strong>应用侧直接通过addView的方式添加窗口不会有ActivityRecord,因此不会在ActivityRecord的构造方法中new Token()。</strong><br><strong>系统侧直接添加的窗口（状态栏、导航栏等），是通过new WindowToken.Builder的方式添加</strong><br><strong>即主动使用ViewManager.addView来添加一个窗口则不会在ActivityRecord的构造方法中new Token()，否则通过new WindowToken.Builder的方式添加。</strong><br>attrs.token这个参数一可以在应用端设置，应用没有设置token那么就为空，token为IBinder类型对象，默认值为空<code>public IBinder token = null;</code><br>例如：<br>在应用侧可通过mLayoutParams.token的方式设置值<br><code>private WindowManager.LayoutParams mLayoutParams;</code><br><code>mLayoutParams.token = null;</code></p><p>后面会继续判断token是否为空,最终会到最后的else中创建token<br><img src="/../../../../../images/72554e9137594c86972bb0cda59bae86.png" alt="在这里插入图片描述"><br>2.创建WindowState<br><code>final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId,session.mCanAddInternalSystemWindow);</code><br>3.验证当前窗口是否可以添加到WMS<br><code>res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</code><br>该方法会对窗口TYPE,FLAG等多方面判断。只有返回ADD_OKAY时表示允许当前窗口的添加，反之则不允许添加该窗口。假如想禁止某些应用做添加窗口操作时，可以在里面通过应用的包名过滤该应用，也可以直接在WindowManagerGlobal.java的addView()方法中直接对应用想要添加的窗口进行过滤。<br>注：<code>ADD_OKAY</code>在WindowManagerGlobal中定义，这个类里面还有一些其他的返回值，所有返回给<code>res</code>的常量最终会在ViewRootImpl的setView方法中判断<br>4.调用openInputChannel，初始化input相关通路（本文不做讨论）<br><code>final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);</code><br><code>if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125;</code><br>5.将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WMS窗口添加之后，还没有创建Surface，此时mDrawState状态为NO_SURFACE</p><h4 id="3-2-relayoutWindow"><a href="#3-2-relayoutWindow" class="headerlink" title="3.2 relayoutWindow"></a>3.2 relayoutWindow</h4><p><img src="/../../../../../images/0251fd28a86a46fea1e29a81b2f55897.png" alt="在这里插入图片描述"><br>1.根据客户端传递过来的IWindow的mWindowMap获取窗口添加阶段创建的WindowState<br><code>final WindowState win = windowForClientLocked(session, client, false);</code><br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br><code>win.setDisplayLayoutNeeded();</code>win为WindowState对象，该方法实际操作在DisplayContent中<br><code>final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;(win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING || win.mActivityRecord.isClientVisible());</code><br>3.创建SurfaceControl<br>在layoutWindow()调用了createSurfaceControl方法创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code>该方法的实现仍然在WMS中<br>这里以createSurfaceControl方法为起点<br><img src="/../../../../../images/c9cf74cf9cbd45bfb3476c07e3f990b3.png" alt="在这里插入图片描述"><br>在createSurfaceControl()中调用WindowStateAnimator执行具体的SurfaceControl的创建 <code>surfaceController = winAnimator.createSurfaceLocked();</code><br>创建Surface后，Surface还未进行绘制，此时mDrawState状态为DRAW_PENDING<br>将创建的SurfaceControl赋值给客户端的outSurfaceControl<br><code>surfaceController.getSurfaceControl(outSurfaceControl);</code><br>4.窗口尺寸的计算以及Surface状态更新<br>在layoutWindow()调用了performSurfacePlacement<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code>mWindowPlacerLocked为WindowSurfacePlacer对象，因此这里以WindowSurfacePlacer的performSurfacePlacement()为起点<br><img src="/../../../../../images/45182f6e931246bda89e986fff0005f6.png" alt="在这里插入图片描述"><br>处理窗口布局循环<br>WindowSurfacePlacer.performSurfacePlacementLoop()<br>处理Surface的状态更变，以及调用LayoutWindowLw的流程<br>RootWindowContainer.performSurfacePlacementNoTrace()<br>计算窗口位置大小<br>DisplayPolicy.layoutWindowLw()</p><h4 id="3-3-finishDrawingWindow"><a href="#3-3-finishDrawingWindow" class="headerlink" title="3.3 finishDrawingWindow"></a>3.3 finishDrawingWindow</h4><p><img src="/../../../../../images/aa5261464c984b56830d1931ec67e207.png" alt="在这里插入图片描述"><br><img src="/../../../../../images/8d84cc58579d4e5cb0c2e924ce3f8afc.png" alt="在这里插入图片描述"></p><p>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PEDING<code>win.finishDrawing(postDrawTransaction, seqId)</code>,并请求窗口布局<code>mWindowPlacerLocked.requestTraversal();</code><br>2.通过mApplySurfaceChangesTransaction的callback，</p><p><img src="/../../../../../images/9e5c8036f3504e6f84c1a9f80070bdfa.png" alt="在这里插入图片描述"><br>调用commitFinishDrawingLocked()<img src="/../../../../../images/a2c46436037a4a3da9af6fa7c12d1b47.png" alt="在这里插入图片描述"><br>改变mDrawState状态将mDrawState更新为READY_TO_SHOW,<br>最终mDrawState更新为HAS_DRAW后，再次请求窗口布局<br><img src="/../../../../../images/cae5471da1f24847b7e954bd0827ad11.png" alt="在这里插入图片描述"><br>3.执行show Surface<br><code>showSurfaceRobustlyLocked(t)</code><br>注：WindowStateAnimator的commitFinishDrawingLocked()方法中，如果是<strong>应用通过WindowManager中的addView的方式创建窗口，则不会有ActivityRecord</strong>，或者该窗口类型为启动窗口，则直接调用<code>result = mWin.performShowLocked();</code>，即WindowState的performShowLocked()方法改变窗口状态为HAS_DRAW，否则会从RootWindowContainer的checkAppTransitionReady方法逐步调用到performShowLocked()<br><img src="/../../../../../images/97725b2413d74debb25621deab0c5c62.png" alt="在这里插入图片描述"></p><h3 id="4-窗口状态变化总结"><a href="#4-窗口状态变化总结" class="headerlink" title="4.窗口状态变化总结"></a>4.窗口状态变化总结</h3><p>WMS为了管理窗口的显示进度，在WindowStateAnimator中定义了mDrawState来描述Surface所处的状态。主要有如下五种状态：<br>NO_SURFACE:WMS添加窗口,即调用addWindow之后，还没有创建Surface，mDrawState处于该状态。<br>DRAW_PENDING:app调用relayoutWindow创建Surface后，但是Surface还没有进行绘制，mDrawState处于该状态。<br>COMMIT_DRAW_PENDING:app完成Surface的绘制，调用finishDrawing，将mDrawState设置为该状态。<br>READY_TO_SHOW:在performSurfacePlacement过程中会将所有处于COMMIT_DRAW_PENDING状态的mDrawState变更为READY_TO_SHOW。<br>HAS_DRAW:若准备显示窗口，WMS执行performShowLocked，将mDrawState设置为该状态<br><img src="/../../../../../images/ad8fdb698a23430a942bcfd773fcba80.png" alt="在这里插入图片描述"></p><p>窗口显示相关方法</p><p>工作内容解释</p><p>addWindow</p><p>App向WMS请求添加窗口记录，会在WMS里新建WindowState(NO_SURFACE)</p><p>relayoutWindow</p><p>App向WMS申请surface用于绘制，执行后window拥有了surface(NO_SURFACE-&gt;DRAW_PENDING)</p><p>finishDrawingWindow</p><p>App在surface上完成绘制后，通知WMS(DRAW_PENDING-&gt;COMMIT_DRAW_PENDING)</p><p>commitFinishDrawingLocked</p><p>WMS遍历window，对于完成绘制的window(COMMIT_DRAW_PENDING-&gt;READY_TO_SHOW)</p><p>performShowLocked</p><p>判断系统是否允许窗口显示isReadyForDisplay(READY_TO_SHOW-&gt;HAS_DRAWN)</p><p>showSurfaceRobustlyLocked</p><p>对HAS_DRAWN状态的窗口，用SurfaceControl通知SurfaceFlinger显示出来</p><h3 id="5-移除流程简述"><a href="#5-移除流程简述" class="headerlink" title="5.移除流程简述"></a>5.移除流程简述</h3><p>窗口移除从App端发起，当Activity执行destroy(),即以handleDestroyActivity()为起点，执行wm.removeViewImmediate()开启；<br><strong>通过WindowManagerGlobal–&gt;ViewRootImpl–&gt;Session–&gt;WindowManagerService的removeWindow()，调用到WindowState的removeIfPossible()–&gt;removeImmediately()，接着调用到WindowStateAnimator的destroySurfaceLocked()–&gt;destroySurface(),逐步调用改变绘制状态为NO_SURFACE–&gt;WindowSurfaceController的destroy()最终调用到SurfaceControl的remove()来通知SurfaceFlinger来移除layer</strong>；</p><h2 id="三、代码流程详解"><a href="#三、代码流程详解" class="headerlink" title="三、代码流程详解"></a>三、代码流程详解</h2><h3 id="1-客户端-1"><a href="#1-客户端-1" class="headerlink" title="1.客户端"></a>1.客户端</h3><h4 id="1-1-Activity走到onresume后"><a href="#1-1-Activity走到onresume后" class="headerlink" title="1.1 Activity走到onresume后"></a>1.1 Activity走到onresume后</h4><p>从ActivityThread.handleResumeActivity方法看起<br>1.调用performResumeActivity，执行onResume。<br>2.获取WindowManager的实现类WindowManagerImpl的实例。<br>3.调用WindowManagerImpl.addView传入DecorView和当前布局参数WindowManager.LayoutParams。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p><pre><code>@Override    public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest,            boolean isForward, String reason) &#123;            ......        // TODO Push resumeArgs into the activity for consideration        // skip below steps for double-resume and r.mFinish = true case.        /*1.执行onResume*/        if (!performResumeActivity(r, finalStateRequest, reason)) &#123;            return;        &#125;        ......        //获取Activity实例        final Activity a = r.activity;        ......        // If the window hasn&#39;t yet been added to the window manager,        // and this guy didn&#39;t finish itself or start another activity,        // then go ahead and add the window.        //mStartedActivity在performLaunchActivity和performResumeActivity方法中被置为false        boolean willBeVisible = !a.mStartedActivity;        ......        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;            //获取当前Activity的PhoneWindow            r.window = r.activity.getWindow();            //从PhoneWindow中获取DecorView            View decor = r.window.getDecorView();            //将view的可见性状态设置为INVISIBLE,view不可见但是仍然占用布局空间            decor.setVisibility(View.INVISIBLE);            /*2.获取WindowManager的实现类WindowManagerImpl的实例*/            ViewManager wm = a.getWindowManager();            //获取布局参数            WindowManager.LayoutParams l = r.window.getAttributes();            //将phoneWindow的DecorView赋值给mDecor            a.mDecor = decor;            //设置窗口类型为TYPE_BASE_APPLICATION            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;            l.softInputMode |= forwardBit;            if (r.mPreserveWindow) &#123;                a.mWindowAdded = true;                r.mPreserveWindow = false;                // Normally the ViewRoot sets up callbacks with the Activity                // in addView-&gt;ViewRootImpl#setView. If we are instead reusing                // the decor view we have to notify the view root that the                // callbacks may have changed.                ViewRootImpl impl = decor.getViewRootImpl();                if (impl != null) &#123;                    impl.notifyChildRebuilt();                &#125;            &#125;            if (a.mVisibleFromClient) &#123;                if (!a.mWindowAdded) &#123;                    a.mWindowAdded = true;                    /*3.传入DecorView和当前布局参数WindowManager.LayoutParams*/                    wm.addView(decor, l);                &#125; else &#123;                    // The activity will get a callback for this &#123;@link LayoutParams&#125; change                    // earlier. However, at that time the decor will not be set (this is set                    // in this method), so no action will be taken. This call ensures the                    // callback occurs with the decor set.                    a.onWindowAttributesChanged(l);                &#125;            &#125;        &#125;        ......    &#125;</code></pre><p><code>wm.addView(decor, l);</code>WindowManager接口的实现是WindowManagerImpl，即实际调用的是WindowManagerImpl中的addView方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerImpl.java</p><pre><code>    @Override    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;        applyTokens(params);        //转交给windowManagerGlobal，添加view        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,                mContext.getUserId());    &#125;</code></pre><p>WindowManagerImpl对窗口的管理交给WindowManagerGlobal，调用WindowManagerGlobal的addView方法<br>WindowManagerGlobal中对窗口的处理主要如下几个步骤：<br>1.对WindowManagerImpl传进来的参数进行检查。<br>2.设置WindowManager.LayoutParams中的token、title等相关属性。查看“【<strong>1.2 Token的创建与传递</strong>】”。<br>3.创建ViewRootImpl对象，并获取客户端与WMS通信的Session。查看“【<strong>1.3 ViewRootImpl的创建</strong>】”。<br>4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。<br>5.调用ViewRootImpl，与WMS通信添加窗口。查看“【<strong>1.4 ViewRootImpl与WMS的通信</strong>】”。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p><pre><code>    public void addView(View view, ViewGroup.LayoutParams params,            Display display, Window parentWindow, int userId) &#123;        /*1.对WindowManagerImpl传进来的参数进行检查*/        if (view == null) &#123;            throw new IllegalArgumentException(&quot;view must not be null&quot;);        &#125;        if (display == null) &#123;            throw new IllegalArgumentException(&quot;display must not be null&quot;);        &#125;        if (!(params instanceof WindowManager.LayoutParams)) &#123;            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);        &#125;        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;        //此处的ParentWindow即当Activity的PhoneWindow        if (parentWindow != null) &#123;            /*2.为wparams的token进行赋值*/            parentWindow.adjustLayoutParamsForSubWindow(wparams);        &#125; else &#123;            ......        &#125;        ViewRootImpl root;        View panelParentView = null;        synchronized (mLock) &#123;            ......            IWindowSession windowlessSession = null;            ......            if (windowlessSession == null) &#123;                   /*3.新建ViewRootImpl，在新建时会通过WindowManagerGlobal获取session*/                root = new ViewRootImpl(view.getContext(), display);            &#125; else &#123;                root = new ViewRootImpl(view.getContext(), display,                        windowlessSession);            &#125;            view.setLayoutParams(wparams);            /*4.在WindowManagerGlobal中备份DecorView，WindowManager.LayoutParams以及ViewRootImpl。*/            //当前view加入到view列表中            mViews.add(view);            //将新建的viewRootImpl加入到root列表中            mRoots.add(root);            //将当前布局参数加入到布局参数列表中            mParams.add(wparams);            // do this last because it fires off messages to start doing things            try &#123;                /*5.调用ViewRootImpl，设置view，panelParentView为null，与WMS通信添加窗口*/                root.setView(view, wparams, panelParentView, userId);            &#125; catch (RuntimeException e) &#123;                // BadTokenException or InvalidDisplayException, clean up.                if (index &gt;= 0) &#123;                    removeViewLocked(index, true);                &#125;                throw e;            &#125;        &#125;    &#125;</code></pre><h4 id="1-2-Token的创建与传递"><a href="#1-2-Token的创建与传递" class="headerlink" title="1.2 Token的创建与传递"></a>1.2 Token的创建与传递</h4><p><code>parentWindow.adjustLayoutParamsForSubWindow(wparams);</code>调用Window的adjustLayoutParamsForSubWindow()方法<br>在adjustLayoutParamsForSubWindow中会分别对WindowManager.LayoutParams中的token以及title进行赋值。<br>1.首先针对子窗口、系统窗口以及应用窗口做了不同的处理，此处我们只关注应用窗口的处理。<br>2.其次将当前PhoneWindow.mAppToken赋值给WindowManager.LayoutParams.token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p><pre><code>    void adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123;        CharSequence curTitle = wp.getTitle();        if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;                wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;                //对子窗口的Token以及Title赋值                ......        &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp;                wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;                //对子窗口的Token以及Title赋值                ......        &#125; else &#123;            //对应用窗口的Token以及Title赋值            if (wp.token == null) &#123;                //将当前PhoneWindow的mAppToken赋值给wp.Token                wp.token = mContainer == null ? mAppToken : mContainer.mAppToken;            &#125;            //将Title设置为mAppName            if ((curTitle == null || curTitle.length() == 0)                    &amp;&amp; mAppName != null) &#123;                wp.setTitle(mAppName);            &#125;        &#125;        //设置为packageName         if (wp.packageName == null) &#123;            wp.packageName = mContext.getPackageName();        &#125;        ......    &#125;</code></pre><p>此处的mAppToken便是在Activity启动时，在ATMS端创建的Token。<br>接下来我们看看Token是如何从ATMS端传递过来，并赋值给PhoneWindow.mAppToken的<br><img src="/../../../../../images/e778248cfd7e4dd5a3fa856039013d62.png" alt="在这里插入图片描述"></p><p>1.在ATMS端新建ActivityRecord时，便新建了Token。并赋值给ActivityRecord.token<br>ActivityRecord继承WindowToken<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p><pre><code> private ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,            int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage,            @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType,            ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,            String _resultWho, int _reqCode, boolean _componentSpecified,            boolean _rootVoiceInteraction, ActivityTaskSupervisor supervisor,            ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState,            TaskDescription _taskDescription, long _createTime) &#123;        //新建Token        super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,                null /* displayContent */, false /* ownerCanManageAppTokens */);        ......&#125;</code></pre><p>2.将ActivityRecord.token封装在clientTransaction中，并将这个传递到客户端<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskSupervisor.java</p><pre><code>    boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,            boolean andResume, boolean checkConfig) throws RemoteException &#123;        ......        final Task task = r.getTask();        final Task rootTask = task.getRootTask();        ......        try &#123;            ......            try &#123;                ......                // Create activity launch transaction.                /*将ActivityRecord.token封装在clientTransaction中*/                final ClientTransaction clientTransaction = ClientTransaction.obtain(                        proc.getThread(), r.token);                final boolean isTransitionForward = r.isTransitionForward();                final IBinder fragmentToken = r.getTaskFragment().getFragmentToken();                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),                        System.identityHashCode(r), r.info,                        // TODO: Have this take the merged configuration instead of separate global                        // and override configs.                        mergedConfiguration.getGlobalConfiguration(),                        mergedConfiguration.getOverrideConfiguration(), r.compat,                        r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor,                        proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(),                        results, newIntents, r.takeOptions(), isTransitionForward,                        proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController,                        r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken));                ......                // Schedule transaction.                /*将clientTransaction传递给客户端*/                mService.getLifecycleManager().scheduleTransaction(clientTransaction);                ......            &#125; catch (RemoteException e) &#123;                ......            &#125;        &#125; finally &#123;            ......        &#125;        ......        return true;    &#125;</code></pre><p><code>final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.token);</code><br>在ClientTransaction中调用obtain方法，把ActivityRecord.token存到mActivityToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;ClientTransaction.java</p><pre><code>    /** Obtain an instance initialized with provided params. */    public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123;        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);        if (instance == null) &#123;        //创建ClientTransaction            instance = new ClientTransaction();        &#125;        instance.mClient = client;        /*把ActivityRecord.token存到mActivityToken*/        //private IBinder mActivityToken;        instance.mActivityToken = activityToken;        return instance;    &#125;</code></pre><p>3.客户端从ClientTransaction中获取ATMS端传来的Token，并传递到LaunchActivityItem中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;TransactionExecutor.java</p><pre><code>   /** Cycle through all states requested by callbacks and execute them at proper times. */    @VisibleForTesting    public void executeCallbacks(ClientTransaction transaction) &#123;        final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();        ......        /*从ClientTransaction中获取ATMS端传来的Token*/        final IBinder token = transaction.getActivityToken();        ActivityClientRecord r = mTransactionHandler.getActivityClient(token);        ......        final int size = callbacks.size();        for (int i = 0; i &lt; size; ++i) &#123;            final ClientTransactionItem item = callbacks.get(i);            ......            /*将Token传递到LaunchActivityItem中*/            item.execute(mTransactionHandler, token, mPendingActions);            item.postExecute(mTransactionHandler, token, mPendingActions);            ......        &#125;    &#125;</code></pre><p>4.在LaunchActivityItem中将客户端传过来的Token保存在ActivityClientRecord.token中<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;LaunchActivityItem.java</p><pre><code>    @Override    public void execute(ClientTransactionHandler client, IBinder token,            PendingTransactionActions pendingActions) &#123;        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);        //将客户端传过来的Token保存在ActivityClientRecord的token中        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,                mPendingResults, mPendingNewIntents, mActivityOptions, mIsForward, mProfilerInfo,                client, mAssistToken, mShareableActivityToken, mLaunchedFromBubble,                mTaskFragmentToken);        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);    &#125;</code></pre><p><code>client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</code>ClientTransactionHandler调用handleLaunchActivity方法，ClientTransactionHandler为抽象类，其子类为ActivityThread，即实际调用的是该类中的handleLaunchActivity()，有从该方法中调用到了performLaunchActivity()<br>5.客户端ActivityThread将ActivityClientRecord以及其对应的token保存在ActivityThread.mActivities数组中，并调用Activity.attach将Token传给Activity。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</p><pre><code>    /**  Core implementation of activity launch. */    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;        ......        try &#123;            Application app = r.packageInfo.makeApplicationInner(false, mInstrumentation);            ......            synchronized (mResourcesManager) &#123;                /*将ActivityClientRecord以及其对应的Token保存在mActivities中*/                //mActivities的类型为ArrayMap&lt;IBinder, ActivityClientRecord&gt;                mActivities.put(r.token, r);            &#125;            if (activity != null) &#123;                ......                /*将Token赋值给Activity.mToken*/                activity.attach(appContext, this, getInstrumentation(), r.token,                        r.ident, app, r.intent, r.activityInfo, title, r.parent,                        r.embeddedID, r.lastNonConfigurationInstances, config,                        r.referrer, r.voiceInteractor, window, r.activityConfigCallback,                        r.assistToken, r.shareableActivityToken);                ......        &#125; catch (SuperNotCalledException e) &#123;            throw e;        &#125; catch (Exception e) &#123;            ......        &#125;        return activity;    &#125;</code></pre><p>6.在Activity中将客户端传来的Token赋值给Activity.mToken。此外在该方法中还新建了PhoneWindow,并将PhoneWindow.mAppToken也设置为客户端传过来的Token。<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Activity.java</p><pre><code>    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)    final void attach(Context context, ActivityThread aThread,            Instrumentation instr, IBinder token, int ident,            Application application, Intent intent, ActivityInfo info,            CharSequence title, Activity parent, String id,            NonConfigurationInstances lastNonConfigurationInstances,            Configuration config, String referrer, IVoiceInteractor voiceInteractor,            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,            IBinder shareableActivityToken) &#123;        attachBaseContext(context);        mFragments.attachHost(null /*parent*/);        /*新建PhoneWindow*/        mWindow = new PhoneWindow(this, window, activityConfigCallback);        ......        /*将客户端传过来的Token赋值给mToken*/        mToken = token;        ......        /*PhoneWindow.mAppToken设置为当前客户端传递过来的Token*/        mWindow.setWindowManager(                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),                mToken, mComponent.flattenToString(),                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);        ......    &#125;</code></pre><p>PhoneWindow继承Window，setWindowManager实际调用的是其父类方法，把mAppToken设置为当前客户端传递过来的mToken<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;Window.java</p><pre><code>    /**     * Set the window manager for use by this Window to, for example,     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the     * Window itself -- that must be done by the client.     *     * @param wm The window manager for adding new windows.     */    public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123;        //传递客户端的mToken给appToken        setWindowManager(wm, appToken, appName, false);    &#125;    /**     * Set the window manager for use by this Window to, for example,     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the     * Window itself -- that must be done by the client.     *     * @param wm The window manager for adding new windows.     */    public void setWindowManager(WindowManager wm, IBinder appToken, String appName,            boolean hardwareAccelerated) &#123;        /*把appToken赋值给mAppToken*/        mAppToken = appToken;        mAppName = appName;        mHardwareAccelerated = hardwareAccelerated;        if (wm == null) &#123;            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);        &#125;        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);    &#125;</code></pre><h4 id="1-3-ViewRootImpl的创建"><a href="#1-3-ViewRootImpl的创建" class="headerlink" title="1.3 ViewRootImpl的创建"></a>1.3 ViewRootImpl的创建</h4><p><code>root = new ViewRootImpl(view.getContext(), display);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用创建ViewRootImpl，这里我们看下ViewRootImpl的构造方法<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</p><pre><code>    public ViewRootImpl(Context context, Display display) &#123;        this(context, display, WindowManagerGlobal.getWindowSession(),                false /* useSfChoreographer */);    &#125;    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) &#123;        this(context, display, session, false /* useSfChoreographer */);    &#125;    public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,            boolean useSfChoreographer) &#123;        mContext = context;        mWindowSession = session;        ......    &#125;</code></pre><p>从这个构造方法中我们可以看出，通过WindowManagerGlobal.getWindowSession获取到客户端与WMS沟通的桥梁IWindowSession，并将其赋值给ViewRootImpl.mWindowSession。</p><p>下面我们查看WindowManagerGlobal中是如何获取Session的。<br>1.通过getWindowManagerService获取IWindowManager，而WindowManagerService则实现了这个Binder接口。<br>2.调用IWindowManager.openSession方法即WMS.openSession，在WMS端便会新建Session。至此客户端与WMS通信的桥梁便已经搭建好了<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</p><pre><code>    @UnsupportedAppUsage    public static IWindowSession getWindowSession() &#123;        synchronized (WindowManagerGlobal.class) &#123;            if (sWindowSession == null) &#123;                try &#123;                    // Emulate the legacy behavior.  The global instance of InputMethodManager                    // was instantiated here.                    // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage                    InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();                    /*1.获取Binder*/                    IWindowManager windowManager = getWindowManagerService();                    /*2.调用WMS的openSession*/                    sWindowSession = windowManager.openSession(                            new IWindowSessionCallback.Stub() &#123;                                @Override                                public void onAnimatorScaleChanged(float scale) &#123;                                    ValueAnimator.setDurationScale(scale);                                &#125;                            &#125;);                &#125; catch (RemoteException e) &#123;                    throw e.rethrowFromSystemServer();                &#125;            &#125;            return sWindowSession;        &#125;    &#125;</code></pre><p>从代码中可以看出如果sWindowSession不为空则直接返回，sWindowSession为当前WindowManagerGlobal属性，且WindowManagerGloba又是单例的，所以客户端一个进程中只有一个IWindowSession与WMS通信。如果sWindowSession为空，则会创建IWindowSession。</p><p>调用WindowManagerService中的openSession，新建Session<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p><pre><code>    @Override    public IWindowSession openSession(IWindowSessionCallback callback) &#123;        /*新建Session*/        return new Session(this, callback);    &#125;</code></pre><h4 id="1-4-ViewRootImpl与WMS的通信"><a href="#1-4-ViewRootImpl与WMS的通信" class="headerlink" title="1.4 ViewRootImpl与WMS的通信"></a>1.4 ViewRootImpl与WMS的通信</h4><p><code>root.setView(view, wparams, panelParentView, userId);</code>之前在【<strong>1.1 Activity走到onresume后</strong>】的流程中有调用ViewRootImpl与WMS的通信，继续看看<br>当前方法是与WMS进行通信添加窗口的入口，在此处我们只关注两点:<br>1.requestLayout()该方法会调用到doTraversal()，之后调用performTraversals()，最终调用到relayoutWindow()和reportDrawFinished()流程，在通过Session与服务端通信<br>2.mWindowSession.addToDisplayAsUser，与服务端进行Binder通信，调用Session的addToDisplayAsUser方法。</p><pre><code>   /**     * We have one child     */    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;        setView(view, attrs, panelParentView, UserHandle.myUserId());    &#125;    /**     * We have one child     */    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,            int userId) &#123;        synchronized (this) &#123;            if (mView == null) &#123;                mView = view;                ......                //将布局参数拷贝纸mWindowAttributes                mWindowAttributes.copyFrom(attrs);                //设置包名                if (mWindowAttributes.packageName == null) &#123;                    mWindowAttributes.packageName = mBasePackageName;                &#125;                mWindowAttributes.privateFlags |=                        WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;                attrs = mWindowAttributes;                ......                // Keep track of the actual window flags supplied by the client.                //获取当前布局的flags                mClientWindowLayoutFlags = attrs.flags;                ......                int res; /* = WindowManagerImpl.ADD_OKAY; */                // Schedule the first layout -before- adding to the window                // manager, to make sure we do the relayout before receiving                // any other events from the system.                /*请求布局，对应服务端layoutWindow流程*/                requestLayout();                InputChannel inputChannel = null;                if ((mWindowAttributes.inputFeatures                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;                    inputChannel = new InputChannel();                &#125;                ......                try &#123;                    ......                    /*与服务端进行Binder通信，调用Session的addToDisplayAsUser方法*/                    //执行addWindow的相关流程                    res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,                            getHostVisibility(), mDisplay.getDisplayId(), userId,                            mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,                            mTempControls);                    ......                &#125; catch (RemoteException e) &#123;                    ......                &#125; finally &#123;                    if (restore) &#123;                        attrs.restore();                    &#125;                &#125;                ......                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow);                if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;                    mAttachInfo.mRootView = null;                    mAdded = false;                    mFallbackEventHandler.setView(null);                    unscheduleTraversals();                    setAccessibilityFocus(null, null);                    switch (res) &#123;                        case WindowManagerGlobal.ADD_BAD_APP_TOKEN:                        case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:                            throw new WindowManager.BadTokenException(                                    &quot;Unable to add window -- token &quot; + attrs.token                                    + &quot; is not valid; is your activity running?&quot;);                        case WindowManagerGlobal.ADD_NOT_APP_TOKEN:                            throw new WindowManager.BadTokenException(                                    &quot;Unable to add window -- token &quot; + attrs.token                                    + &quot; is not for an application&quot;);                        case WindowManagerGlobal.ADD_APP_EXITING:                            throw new WindowManager.BadTokenException(                                    &quot;Unable to add window -- app for token &quot; + attrs.token                                    + &quot; is exiting&quot;);                        case WindowManagerGlobal.ADD_DUPLICATE_ADD:                            throw new WindowManager.BadTokenException(                                    &quot;Unable to add window -- window &quot; + mWindow                                    + &quot; has already been added&quot;);                        case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:                            // Silently ignore -- we would have just removed it                            // right away, anyway.                            return;                        case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;                                    + mWindow + &quot; -- another window of type &quot;                                    + mWindowAttributes.type + &quot; already exists&quot;);                        case WindowManagerGlobal.ADD_PERMISSION_DENIED:                            throw new WindowManager.BadTokenException(&quot;Unable to add window &quot;                                    + mWindow + &quot; -- permission denied for window type &quot;                                    + mWindowAttributes.type);                        case WindowManagerGlobal.ADD_INVALID_DISPLAY:                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;                                    + mWindow + &quot; -- the specified display can not be found&quot;);                        case WindowManagerGlobal.ADD_INVALID_TYPE:                            throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot;                                    + mWindow + &quot; -- the specified window type &quot;                                    + mWindowAttributes.type + &quot; is not valid&quot;);                        case WindowManagerGlobal.ADD_INVALID_USER:                            throw new WindowManager.BadTokenException(&quot;Unable to add Window &quot;                                    + mWindow + &quot; -- requested userId is not valid&quot;);                    &#125;                    throw new RuntimeException(                            &quot;Unable to add window -- unknown error code &quot; + res);                &#125;                ......            &#125;        &#125;    &#125;</code></pre><p>其中关键的添加代码为</p><pre><code>res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,        getHostVisibility(), mDisplay.getDisplayId(), userId,        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,        mTempControls);</code></pre><p><code>addToDisplayAsUser()</code>方法最终会走到WindowManagerService.java的addWindow方法，addWindow方法的返回值最后会返回给<code>res</code>，之后回看ViewRootImpl的setView方法，返回值如果满足<code>if (res &lt; WindowManagerGlobal.ADD_OKAY)</code>条件，那么会根据<code>switch (res)</code>中对应的case抛出异常。<br>至此，客户端流程结束，后面进入服务端流程。</p><h3 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h3><h4 id="2-1-窗口添加"><a href="#2-1-窗口添加" class="headerlink" title="2.1 窗口添加"></a>2.1 窗口添加</h4><p>WMS通过Session接受客户端添加窗口的请求，因此WMS会新建WindowState、将WindowState加入到WindowToken，并更新WindowToken下所有WindowState的z-order。<br>客户端通过Binder通信调用WMS端的Session.addToDisplayAsUser进入addWindow的流程。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.WindowState初始化<br>3.WindowState加入到WIndowToken</p><h5 id="2-1-1-接收客户端请求"><a href="#2-1-1-接收客户端请求" class="headerlink" title="2.1.1 接收客户端请求"></a>2.1.1 接收客户端请求</h5><p>客户端传递给Session的参数<br>IWindow window:是WMS与客户端通信的句柄。<br>WindowManager.LayoutParams arrts：窗口布局参数。<br>viewVisibility：附着在窗口的rootView的可见性。<br>displayId：顾名思义，display id表示的是DisplayContent即屏幕的id。<br>InsetsVisibilities requestedVisibilities:当前对象的mVisibilities记录了insets的可见性。<br>InputChannel outInputChannel：InputDispatcher接收InputReader读取到的事件，分发给对应窗口，InputDispatcher属于system_server进程和各个应用不在同一进程，它们之间的联系靠的就是InputChannel。<br>InsetsState outInsetsState：用来保存系统中所有Insets的状态，该对象只是在客户端创建，内部属性需要在WMS端赋值。<br>InsetsSourceControl[] outActiveControls：InSetsSourceControl数组。该对象也是只在客户端创建，内部属性需要在WMS端赋值。<br>Session调用<strong>WindowManagerService.addWindow</strong> 将客户端传入的参数传递给WindowManagerService。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p><pre><code>    @Override    public int addToDisplayAsUser(IWindow window, WindowManager.LayoutParams attrs,            int viewVisibility, int displayId, int userId, InsetsVisibilities requestedVisibilities,            InputChannel outInputChannel, InsetsState outInsetsState,            InsetsSourceControl[] outActiveControls) &#123;        return mService.addWindow(this, window, attrs, viewVisibility, displayId, userId,                requestedVisibilities, outInputChannel, outInsetsState, outActiveControls);    &#125;</code></pre><h5 id="2-1-2-addWindow"><a href="#2-1-2-addWindow" class="headerlink" title="2.1.2 addWindow"></a>2.1.2 addWindow</h5><p>添加窗口的主要逻辑均在WMS.addWindow执行，该方法主要实现以下功能：<br>1.首先进行权限验证以及各种条件判断。<br>2.根据客户端传来的token获取windowToken。<br>3.借助客户端传来的参数，创建WindowState实例，并将其加入到WMS. mWindowMap中。<br>4.将新建的WindowState加入到相应的WindowToken，并为每个窗口赋值一个z-order。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p><pre><code>    public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility,            int displayId, int requestUserId, InsetsVisibilities requestedVisibilities,            InputChannel outInputChannel, InsetsState outInsetsState,            InsetsSourceControl[] outActiveControls) &#123;        ......                /*1.进行权限验证以及各种条件判断*/        //判断调用者是否有权限add window        int res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,                appOp);        if (res != ADD_OKAY) &#123;            return res;        &#125;        WindowState parentWindow = null;        final int callingUid = Binder.getCallingUid();        final int callingPid = Binder.getCallingPid();        final long origId = Binder.clearCallingIdentity();        //获取将要添加的窗口类型        final int type = attrs.type;        synchronized (mGlobalLock) &#123;            ......            //根据displayId以及客户端传过来的token获取相应的displayContent            final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);            ......            //判断mWindowMap中是否已经存在当前客户端的key,如果有则已经将当前客户端的window添加了，无需重复添加            if (mWindowMap.containsKey(client.asBinder())) &#123;                ProtoLog.w(WM_ERROR, &quot;Window %s is already added&quot;, client);                return WindowManagerGlobal.ADD_DUPLICATE_ADD;            &#125;            //判断是否是子窗口            if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;                parentWindow = windowForClientLocked(null, attrs.token, false);                if (parentWindow == null) &#123;                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is not a window: &quot;                            + &quot;%s.  Aborting.&quot;, attrs.token);                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;                &#125;                if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;                    ProtoLog.w(WM_ERROR, &quot;Attempted to add window with token that is a sub-window: &quot;                            + &quot;%s.  Aborting.&quot;, attrs.token);                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;                &#125;            &#125;            //判断当前DisplayContent是否是私有的，只拥有该display或者display已经的应用才可以在其上创建            if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) &#123;                ProtoLog.w(WM_ERROR,                        &quot;Attempted to add private presentation window to a non-private display.  &quot;                                + &quot;Aborting.&quot;);                return WindowManagerGlobal.ADD_PERMISSION_DENIED;            &#125;            ......            ActivityRecord activity = null;            //设置是否有父窗口的标志位            final boolean hasParent = parentWindow != null;            // Use existing parent window token for child windows since they go in the same token            // as there parent window so we can apply the same policy on them.                        /*2.根据客户端传来的token获取windowToken*/            //attrs.token去DisplayContent.mTokenMap中去取WindowToken            //那么WindowToken是什么时候加入到mTokenMap中的呢            //这就要追溯到Activity的启动时，加入到DisplayContent中            //在ActivityStarter.startActivityInner中调用addOrReparentStartingActivity通过addChild一步步调用到WindowContainert中。            //在调用setParent,最终通过onDisplayChanged将ActivityRecord加入到DisplayContent.mTokenMap中            WindowToken token = displayContent.getWindowToken(                    hasParent ? parentWindow.mAttrs.token : attrs.token);            // If this is a child window, we want to apply the same type checking rules as the            // parent window type.            final int rootType = hasParent ? parentWindow.mAttrs.type : type;            boolean addToastWindowRequiresToken = false;            final IBinder windowContextToken = attrs.mWindowContextToken;            if (token == null) &#123;            ......             &#125;else if (rootType &gt;= FIRST_APPLICATION_WINDOW                    &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;                //当前窗口为应用窗口，通过token，获取ActivityRecord                activity = token.asActivityRecord();            ......            &#125; else if (token.asActivityRecord() != null) &#123;                ProtoLog.w(WM_ERROR, &quot;Non-null activity for system window of rootType=%d&quot;,                        rootType);                // It is not valid to use an app token with other system types; we will                // instead make a new token for it (as if null had been passed in for the token).                attrs.token = null;                token = new WindowToken.Builder(this, client.asBinder(), type)                        .setDisplayContent(displayContent)                        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)                        .build();            &#125;            /*3.创建WindowState*/            final WindowState win = new WindowState(this, session, client, token, parentWindow,                    appOp[0], attrs, viewVisibility, session.mUid, userId,                    session.mCanAddInternalSystemWindow);            //将客户端传过来的Insets可见性赋值给WindowState的requestedVisibilities            win.setRequestedVisibilities(requestedVisibilities);            //验证当前窗口是否可以添加到WMS            res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);            if (res != ADD_OKAY) &#123;                return res;            &#125;            //调用openInputChannel，初始化input相关通路            final boolean openInputChannels = (outInputChannel != null                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);            if  (openInputChannels) &#123;                win.openInputChannel(outInputChannel);            &#125;            //创建SufaceSession用于SurfaceFlinger通信            win.attach();            //将客户端与WindowState加入到mWindowMap中            mWindowMap.put(client.asBinder(), win);            win.initAppOpsState();            ......            /*4.将WindowState加入到WindowToken*/            win.mToken.addWindow(win);            ......        return res;    &#125;</code></pre><p><strong>mWindowMap保存了每个WindowState和客户端窗口的映射关系，客户端应用请求窗口操作时，通过mWindowMap查询到对应的WindowState</strong></p><h5 id="2-1-3-WindowToken的创建"><a href="#2-1-3-WindowToken的创建" class="headerlink" title="2.1.3 WindowToken的创建"></a>2.1.3 WindowToken的创建</h5><pre><code>token = new WindowToken.Builder(this, client.asBinder(), type)        .setDisplayContent(displayContent)        .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)        .build();</code></pre><p>这里调用的是其WindowToken自身的build方法创建<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p><pre><code>WindowToken build() &#123;    return new WindowToken(mService, mToken, mType, mPersistOnEmpty, mDisplayContent,            mOwnerCanManageAppTokens, mRoundedCornerOverlay, mFromClientToken, mOptions);&#125;protected WindowToken(WindowManagerService service, IBinder _token, int type,        boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens,        boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123;    super(service);    token = _token;    windowType = type;    mOptions = options;    mPersistOnEmpty = persistOnEmpty;    mOwnerCanManageAppTokens = ownerCanManageAppTokens;    mRoundedCornerOverlay = roundedCornerOverlay;    mFromClientToken = fromClientToken;    if (dc != null) &#123;        dc.addWindowToken(token, this);    &#125;&#125;</code></pre><p><code>dc.addWindowToken(token, this);</code>在WindowToken构造方法中，调用DisplayContent.addWindowToken将WindowToken添加到以DisplayContent为根节点的WindowContainer层级结构中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>    void addWindowToken(IBinder binder, WindowToken token) &#123;        final DisplayContent dc = mWmService.mRoot.getWindowTokenDisplay(token);        if (dc != null) &#123;            // We currently don&#39;t support adding a window token to the display if the display            // already has the binder mapped to another token. If there is a use case for supporting            // this moving forward we will either need to merge the WindowTokens some how or have            // the binder map to a list of window tokens.            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;                    + getName() + &quot; already mapped to display=&quot; + dc + &quot; tokens=&quot; + dc.mTokenMap);        &#125;        if (binder == null) &#123;            throw new IllegalArgumentException(&quot;Can&#39;t map token=&quot; + token + &quot; to display=&quot;                    + getName() + &quot; binder is null&quot;);        &#125;        if (token == null) &#123;            throw new IllegalArgumentException(&quot;Can&#39;t map null token to display=&quot;                    + getName() + &quot; binder=&quot; + binder);        &#125;        mTokenMap.put(binder, token);        if (token.asActivityRecord() == null) &#123;            // Set displayContent for non-app token to prevent same token will add twice after            // onDisplayChanged.            // TODO: Check if it&#39;s fine that super.onDisplayChanged of WindowToken            //  (WindowsContainer#onDisplayChanged) may skipped when token.mDisplayContent assigned.            token.mDisplayContent = this;            // Add non-app token to container hierarchy on the display. App tokens are added through            // the parent container managing them (e.g. Tasks).            //1.调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。            final DisplayArea.Tokens da = findAreaForToken(token).asTokens();            //2.将WindowToken添加到父容器中。            da.addChild(token);        &#125;    &#125;</code></pre><p>这里我们分两步看<br>1.<code>final DisplayArea.Tokens da = findAreaForToken(token).asTokens();</code>调用DisplayContent.findAreaForToken为当前WindowToken寻找一个合适的父容器，DisplayArea.Tokens对象。</p><pre><code>    /**     * Finds the &#123;@link DisplayArea&#125; for the &#123;@link WindowToken&#125; to attach to.     * &lt;p&gt;     * Note that the differences between this API and     * &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; is that this API finds a     * &#123;@link DisplayArea&#125; in &#123;@link DisplayContent&#125; level, which may find a &#123;@link DisplayArea&#125;     * from multiple &#123;@link RootDisplayArea RootDisplayAreas&#125; under this &#123;@link DisplayContent&#125;&#39;s     * hierarchy, while &#123;@link RootDisplayArea#findAreaForTokenInLayer(WindowToken)&#125; finds a     * &#123;@link DisplayArea.Tokens&#125; from a &#123;@link DisplayArea.Tokens&#125; list mapped to window layers.     * &lt;/p&gt;     *     * @see DisplayContent#findAreaForTokenInLayer(WindowToken)     */    DisplayArea findAreaForToken(WindowToken windowToken) &#123;        return findAreaForWindowType(windowToken.getWindowType(), windowToken.mOptions,                windowToken.mOwnerCanManageAppTokens, windowToken.mRoundedCornerOverlay);    &#125;</code></pre><p>​    </p><p>为传入的WindowToken找到一个DisplayArea对象来添加进去。</p><pre><code>    DisplayArea findAreaForWindowType(int windowType, Bundle options,            boolean ownerCanManageAppToken, boolean roundedCornerOverlay) &#123;        // TODO(b/159767464): figure out how to find an appropriate TDA.        //1.如果是App窗口，那么返回默认的TaskDisplayArea对象。        if (windowType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; windowType &lt;= LAST_APPLICATION_WINDOW) &#123;            return getDefaultTaskDisplayArea();        &#125;        // Return IME container here because it could be in one of sub RootDisplayAreas depending on        // the focused edit text. Also, the RootDisplayArea choosing strategy is implemented by        // the server side, but not mSelectRootForWindowFunc customized by OEM.        //2.如果是输入法窗口，那么返回ImeContainer。        if (windowType == TYPE_INPUT_METHOD || windowType == TYPE_INPUT_METHOD_DIALOG) &#123;            return getImeContainer();        &#125;        //3.如果是其他类型，继续寻找。        return mDisplayAreaPolicy.findAreaForWindowType(windowType, options,                ownerCanManageAppToken, roundedCornerOverlay);    &#125;</code></pre><p>如果是App窗口，那么返回默认的TaskDisplayArea对象。<br>如果是输入法窗口，那么返回ImeContainer。<br>如果是其他类型，继续寻找。<br><code>mDisplayAreaPolicy.findAreaForWindowType(windowType, options, ownerCanManageAppToken, roundedCornerOverlay);</code>调用的是DisplayAreaPolicy中的findAreaForWindowType方法，DisplayAreaPolicy为抽象类,DisplayAreaPolicyBuilder中的Result继承了该类<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p><pre><code>static class Result extends DisplayAreaPolicy &#123;    ......       @Override       public DisplayArea.Tokens findAreaForWindowType(int type, Bundle options,               boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123;           return mSelectRootForWindowFunc.apply(type, options).findAreaForWindowTypeInLayer(type,                   ownerCanManageAppTokens, roundedCornerOverlay);       &#125;       ......</code></pre><p>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootDisplayArea.java</p><pre><code>  DisplayArea.Tokens findAreaForWindowTypeInLayer(int windowType, boolean ownerCanManageAppTokens,           boolean roundedCornerOverlay) &#123;       //通过getWindowLayerFromTypeLw方法获取对应的窗口类型       int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,               ownerCanManageAppTokens, roundedCornerOverlay);       if (windowLayerFromType == APPLICATION_LAYER) &#123;           throw new IllegalArgumentException(                   &quot;There shouldn&#39;t be WindowToken on APPLICATION_LAYER&quot;);       &#125;       return mAreaForLayer[windowLayerFromType];   &#125;</code></pre><p>通过getWindowLayerFromTypeLw方法计算出该窗口的类型对应的层级值windowLayerFromType，然后从mAreaForLayer数组中，找到windowLayerFromType对应的那个DisplayArea.Tokens对象。<br>2. <code>da.addChild(token);</code>将WindowToken添加到父容器（叶子节点）中。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayArea.java</p><pre><code>    /**     * DisplayArea that contains WindowTokens, and orders them according to their type.     */    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;        ......        void addChild(WindowToken token) &#123;            addChild(token, mWindowComparator);        &#125;        ......</code></pre><p><code>addChild(token, mWindowComparator);</code>最终调用到WindowContainer.addChild方法添加WindowToken到叶子节点</p><h5 id="2-1-4-WindowState初始化"><a href="#2-1-4-WindowState初始化" class="headerlink" title="2.1.4 WindowState初始化"></a>2.1.4 WindowState初始化</h5><p>在addWindow中初始化WindowState</p><pre><code>final WindowState win = new WindowState(this, session, client, token, parentWindow,        appOp[0], attrs, viewVisibility, session.mUid, userId,        session.mCanAddInternalSystemWindow);</code></pre><p>下面我们看一下在WindowState的实例化过程中，都做了什么。<br>1.根据客户端传过来的参数，对相关属性进行赋值。<br>2.根据当前窗口的类型获取mBaseLayer,当将WindowState加入到WindowToken时，该值用来确定加入窗口在WindowToken数组中的位置。<br>3.实例化WindowStateAnimator，该类会跟踪当前WIndowState的动画以及surface操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p><pre><code>WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,            WindowState parentWindow, int appOp, WindowManager.LayoutParams a, int viewVisibility,            int ownerId, int showUserId, boolean ownerCanAddInternalSystemWindow,            PowerManagerWrapper powerManagerWrapper) &#123;        /*1.根据客户端传递过来的参数，对相关属性进行赋值*/        //调用WindowState的父类WindowContainer构造方法，将WMS赋值给其父类属性mWmService        super(service);        //获取事务        mTmpTransaction = service.mTransactionFactory.get();        //将Session赋值给mSession        mSession = s;        //将与客户端通信的Binder赋值给mClient        mClient = c;        mAppOp = appOp;        //将当前activity的token赋值给mToken        mToken = token;        //通过token，获取当前窗口对的ActivityRecord        mActivityRecord = mToken.asActivityRecord();        //赋值id        mOwnerUid = ownerId;        mShowUserId = showUserId;        //是否可以添加系统窗口的标志位        mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;        mWindowId = new WindowId(this);        //布局参数赋值给mAttrs        mAttrs.copyFrom(a);        //将surfaceInsets赋值给mLastSurfaceInsets        mLastSurfaceInsets.set(mAttrs.surfaceInsets);        //将窗口可见性赋值给mViewVisibility         mViewVisibility = viewVisibility;        //将窗口WindowManagerPolicy赋值给mPolicy         mPolicy = mWmService.mPolicy;        mContext = mWmService.mContext;        ......        /*2.获取当前窗口的BaseLayer*/        if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;            ......        &#125; else &#123;            // The multiplier here is to reserve space for multiple            // windows in the same type layer.            //当前为应用窗口所以mPolicy.getWindowLayerLw(this)获取值为2，即应用层级            //TYPE_LAYER_MULTIPLIER为同一类型的多窗口保留空间            //TYPE_LAYER_OFFSET将同一组窗口移动到同一层中其他窗口的上方或者下方            mBaseLayer = mPolicy.getWindowLayerLw(this)                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;            mSubLayer = 0;            mIsChildWindow = false;            mLayoutAttached = false;            mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD                    || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;            mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;        &#125;        ......        /*3.新建windowStateAnimator，该类会跟踪当前WindowState的动画以及surface操作*/        mWinAnimator = new WindowStateAnimator(this);        //将透明度alpha赋值给mAlpha         mWinAnimator.mAlpha = a.alpha;        ......    &#125;</code></pre><h5 id="2-1-5-将WindowState加入到WindowToken"><a href="#2-1-5-将WindowState加入到WindowToken" class="headerlink" title="2.1.5 将WindowState加入到WindowToken"></a>2.1.5 将WindowState加入到WindowToken</h5><p>在addWindow中将WindowState加入到WindowToken<br><code>win.mToken.addWindow(win);</code><br>WindowState加入到WindowToken中的具体过程：<br>1.将要加入的WindowState.mBaseLayer与WindowToken中现有的WindowState.mBaseLayer相比，按照mBaseLayer有小到大存放到数组中，若mBaseLayer相等，则后加入的WindowState放在数组后面。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowToken.java</p><pre><code> void addWindow(final WindowState win) &#123;        ProtoLog.d(WM_DEBUG_FOCUS,                &quot;addWindow: win=%s Callers=%s&quot;, win, Debug.getCallers(5));        if (win.isChildWindow()) &#123;            // Child windows are added to their parent windows.            //如果是子窗口直接返回            return;        &#125;        // This token is created from WindowContext and the client requests to addView now, create a        // surface for this token.        if (mSurfaceControl == null) &#123;            createSurfaceControl(true /* force */);            // Layers could have been assigned before the surface was created, update them again            reassignLayer(getSyncTransaction());        &#125;        if (!mChildren.contains(win)) &#123;            ProtoLog.v(WM_DEBUG_ADD_REMOVE, &quot;Adding %s to %s&quot;, win, this);            //调用WindowContainer.addChild方法            addChild(win, mWindowComparator);            mWmService.mWindowsChanged = true;            // TODO: Should we also be setting layout needed here and other places?        &#125;    &#125; /**   * Compares two child window of this token and returns -1 if the first is lesser than the   * second in terms of z-order and 1 otherwise.   */  private final Comparator&lt;WindowState&gt; mWindowComparator =          (WindowState newWindow, WindowState existingWindow) -&gt; &#123;      final WindowToken token = WindowToken.this;      ......      //如果新窗口的mBaseLayer 不小于（大于等于）已经存在的WindowState的BaseLayer，则返回1，否则返回-1      return isFirstChildWindowGreaterThanSecond(newWindow, existingWindow) ? 1 : -1;  &#125;;    /**     * Returns true if the new window is considered greater than the existing window in terms of     * z-order.     */    protected boolean isFirstChildWindowGreaterThanSecond(WindowState newWindow,            WindowState existingWindow) &#123;        // New window is considered greater if it has a higher or equal base layer.        //此处可以发现比较的是两个窗口的mBaseLayer        return newWindow.mBaseLayer &gt;= existingWindow.mBaseLayer;    &#125;</code></pre><p>我们看看WindowContainer.addChild方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p><pre><code>   /**     * Adds the input window container has a child of this container in order based on the input     * comparator.     * @param child The window container to add as a child of this window container.     * @param comparator Comparator to use in determining the position the child should be added to.     *                   If null, the child will be added to the top.     */    @CallSuper    protected void addChild(E child, Comparator&lt;E&gt; comparator) &#123;        ......        //记录插入数组的位置，若为-1则将windowState加入到后面        int positionToAdd = -1;        if (comparator != null) &#123;            //判断当前WindowToken中WindowState的数量            //依次比较将要加入的窗口与已经存在的WindowState的BaseLayer            //mChildren越大放到数组最前面WindowToken            final int count = mChildren.size();            for (int i = 0; i &lt; count; i++) &#123;                //比较baseLayer，如果child大于列表中已经存在的，则需要返回1，否则返回-1                //新加入的的child大于mChildren.get(i)则返回1，小于则返回-1                //注：comparator比较器的逻辑见上面代码的mWindowComparator                 if (comparator.compare(child, mChildren.get(i)) &lt; 0) &#123;                    //记录当前要插入的位置                    positionToAdd = i;                    break;                &#125;            &#125;        &#125;        //如果新加入的窗口大于现在所有窗口        if (positionToAdd == -1) &#123;            //将该窗口加入到列表最后            mChildren.add(child);        &#125; else &#123;            mChildren.add(positionToAdd, child);        &#125;        // Set the parent after we&#39;ve actually added a child in case a subclass depends on this.        //此处将child的mParent设置为this        child.setParent(this);    &#125;</code></pre><p>2.将WindowState的mParent置为刚才的WindowToken，并更新其Parent的mTreeWeight。mTreeWeight记录了其子节点的数量。<br>继续查看WindowState的父类WindowContainer.setParent</p><pre><code>    final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123;        //将当前WindowState的mParent设置为相应的WindowToken        final WindowContainer oldParent = mParent;        mParent = parent;        if (mParent != null) &#123;            //更新parent中的mTreeWeight属性            //mTreeWeight代表以parent的根节点的子树中的元素的数量            mParent.onChildAdded(this);        &#125; else if (mSurfaceAnimator.hasLeash()) &#123;            mSurfaceAnimator.cancelAnimation();        &#125;        if (!mReparenting) &#123;            onSyncReparent(oldParent, mParent);            if (mParent != null &amp;&amp; mParent.mDisplayContent != null                    &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;                onDisplayChanged(mParent.mDisplayContent);            &#125;            //计算显示layer            onParentChanged(mParent, oldParent);        &#125;    &#125;</code></pre><p>3.将WindowState加入到WindowToken之后，调用parent的assignChildLayers方法，调整其所有child的z-order。主要经历以下步骤：<br>初始化layer&#x3D;0，代表着z-order。<br>遍历mChildren数组，判断Children是否需要提高到顶部（判断标志位mNeedsZBoost）。如果不需要则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果需要则执行下一遍循环。<br>再次遍历mChildren数组，判断Children是否需要提高到顶部。如果需要则则调用Children的assignLayer方法调整其z-order为layer，并将layer++。如果不需要则执行下一次循环。<br>注：<strong>Z-order</strong>也被称为深度顺序（depth order）或Z轴顺序，它用于确定图层（Layers）在屏幕上的堆叠顺序。简单来说，<strong>Z-order</strong>就是图层在Z轴上的位置，Z轴位置越低，图层越在底层，Z轴位置越高，图层越在顶层。<br>继续看onParentChanged方法</p><pre><code>/**     * Callback that is triggered when @link WindowContainer#setParent(WindowContainer)&#125; was called.     * Supposed to be overridden and contain actions that should be executed after parent was set.     */    @Override    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123;        onParentChanged(newParent, oldParent, null);    &#125;    void onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent,            PreAssignChildLayersCallback callback) &#123;        ......        if (mSurfaceControl == null) &#123;            // If we don&#39;t yet have a surface, but we now have a parent, we should            // build a surface.            //创建一个SurfaceControl来调整窗口的z-order            createSurfaceControl(false /*force*/);        &#125; else &#123;               ......        &#125;        ......        // Either way we need to ask the parent to assign us a Z-order.        //进入WindowToken的父类WindowContainer中，调整窗口的z-order        mParent.assignChildLayers();        scheduleAnimation();    &#125;        void assignChildLayers() &#123;        assignChildLayers(getSyncTransaction());        scheduleAnimation();    &#125;        void assignChildLayers(Transaction t) &#123;    //分配给当前窗口的z-order，初始化为0        int layer = 0;        // We use two passes as a way to promote children which        // need Z-boosting to the end of the list.        //此处会以parent为根节点向下遍历到子节点，再从下到上依次进行处理        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;            final WindowContainer wc = mChildren.get(j);            wc.assignChildLayers(t);            //needsZBoot是用来判断当前窗口是否应该提升到容器的顶部            //若不需要提升到容器的顶部            if (!wc.needsZBoost()) &#123;                //调用WindowState的父类WindowContainer中的assignLayer                wc.assignLayer(t, layer++);            &#125;        &#125;        //处理需要提升到容器顶部的窗口        for (int j = 0; j &lt; mChildren.size(); ++j) &#123;            final WindowContainer wc = mChildren.get(j);            if (wc.needsZBoost()) &#123;                wc.assignLayer(t, layer++);            &#125;        &#125;        if (mOverlayHost != null) &#123;            mOverlayHost.setLayer(t, layer++);        &#125;    &#125;</code></pre><p>4.在Children的assignLayer中会首先判断此次要调整的layer与自己上次layer是否相等，不相等则最终会调用nativeSetLayer来调整自己的z-order。</p><pre><code>    void assignLayer(Transaction t, int layer) &#123;        // Don&#39;t assign layers while a transition animation is playing        // TODO(b/173528115): establish robust best-practices around z-order fighting.        //如果正在执行Transaction，则不需要进行assignLayer        if (mTransitionController.isPlaying()) return;        //layer为此次要调整的z-order        final boolean changed = layer != mLastLayer || mLastRelativeToLayer != null;        //如果需要调整        if (mSurfaceControl != null &amp;&amp; changed) &#123;            //调用setLayer调整窗口的z-order            setLayer(t, layer);            //将mLastLayer调整为新的z-order            mLastLayer = layer;            mLastRelativeToLayer = null;        &#125;    &#125;        protected void setLayer(Transaction t, int layer) &#123;        if (mSurfaceFreezer.hasLeash()) &#123;               ......        &#125; else &#123;            // Route through surface animator to accommodate that our surface control might be            // attached to the leash, and leash is attached to parent container.            //调用SurfaceAnimator中的setLayer            mSurfaceAnimator.setLayer(t, layer);        &#125;    &#125;</code></pre><p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;SurfaceAnimator.java</p><pre><code>    /**     * Sets the layer of the surface.     * &lt;p&gt;     * When the layer of the surface needs to be adjusted, we need to set it on the leash if the     * surface is reparented to the leash. This method takes care of that.     */    void setLayer(Transaction t, int layer) &#123;          //调用SurfaceControl中的setlayer方法        t.setLayer(mLeash != null ? mLeash : mAnimatable.getSurfaceControl(), layer);    &#125;</code></pre><p>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p><pre><code>        /**         * Set the Z-order for a given SurfaceControl, relative to it&#39;s siblings.         * If two siblings share the same Z order the ordering is undefined. Surfaces         * with a negative Z will be placed below the parent surface.         *         * @param sc The SurfaceControl to set the Z order on         * @param z The Z-order         * @return This Transaction.         */        @NonNull        public Transaction setLayer(@NonNull SurfaceControl sc,                @IntRange(from = Integer.MIN_VALUE, to = Integer.MAX_VALUE) int z) &#123;            //调用调整layer            checkPreconditions(sc);            nativeSetLayer(mNativeObject, sc.mNativeObject, z);            return this;        &#125;</code></pre><h4 id="2-2-窗口位置和大小计算"><a href="#2-2-窗口位置和大小计算" class="headerlink" title="2.2 窗口位置和大小计算"></a>2.2 窗口位置和大小计算</h4><p>当WindowState加入到WindowToken并调整z-order之后，客户端会再次调用<strong>WindowManagerService.relayoutWindow</strong>执行窗口布局。<br>主要做了这三件事：<br>1.接收客户端请求<br>2.创建SurfaceControl<br>3.窗口位置和大小计算</p><h5 id="2-2-1-接收客户端请求"><a href="#2-2-1-接收客户端请求" class="headerlink" title="2.2.1 接收客户端请求"></a>2.2.1 接收客户端请求</h5><p>与addWindow流程的调用过程类似，WindowManagerService.relayoutWindow也是由客户端通过Session来调用的。<br>首先我们来看一下客户端给我们传递了哪些参数吧。<br>window：是WMS与客户端通信的Binder。<br>attrs：窗口的布局属性，根据attrs提供的属性来布局窗口。<br>requestWidth、requestHeight：客户端请求的窗口尺寸。<br>viewFlags：窗口的可见性。包括VISIBLE（0，view可见），INVISIBLE（4，view不可见，但是仍然占用布局空间）GONE（8，view不可见，不占用布局空间）<br>flags：定义一些布局行为。<br>outFrames：返回给客户端的，保存了重新布局之后的位置与大小。<br>mergedConfiguration:相关配置信息。<br>outSurfaceControl:返回给客户端的surfaceControl。<br>outInsetsState：用来保存系统中所有Insets的状态。<br>outActiveControls：InSetsSourceControl数组。<br>outSyncSeqIdBundle：与布局同步有关。<br>Session调用WMS.relayoutWindow将客户端传入的参数传递给WMS。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p><pre><code>    @Override    public int relayout(IWindow window, WindowManager.LayoutParams attrs,            int requestedWidth, int requestedHeight, int viewFlags, int flags,            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,            SurfaceControl outSurfaceControl, InsetsState outInsetsState,            InsetsSourceControl[] outActiveControls, Bundle outSyncSeqIdBundle) &#123;        if (false) Slog.d(TAG_WM, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot;                + Binder.getCallingPid());        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, mRelayoutTag);        int res = mService.relayoutWindow(this, window, attrs,                requestedWidth, requestedHeight, viewFlags, flags,                outFrames, mergedConfiguration, outSurfaceControl, outInsetsState,                outActiveControls, outSyncSeqIdBundle);        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        if (false) Slog.d(TAG_WM, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot;                + Binder.getCallingPid());        return res;    &#125;</code></pre><h5 id="2-2-2-relayoutWindow"><a href="#2-2-2-relayoutWindow" class="headerlink" title="2.2.2 relayoutWindow"></a>2.2.2 relayoutWindow</h5><p>在WMS.relayoutWindow中主要做了以下事情：<br>1.根据客户端传过来的IWindow在mWindowMap获取窗口添加阶段创建的WindowState。<br>2.设置DisplayContent.mLayoutNeeded以及shouldRelayout标志位<br>3.Surface的创建流程。<br>4.窗口尺寸的计算以及Surface的状态变更。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p><pre><code>    public int relayoutWindow(Session session, IWindow client, LayoutParams attrs,            int requestedWidth, int requestedHeight, int viewVisibility, int flags,            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,            SurfaceControl outSurfaceControl, InsetsState outInsetsState,            InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle) &#123;        ......        synchronized (mGlobalLock) &#123;            /*1.根据客户端传过来的Iwindow从mWindowMap中获取对应的WindowState*/            final WindowState win = windowForClientLocked(session, client, false);            if (win == null) &#123;                return 0;            &#125;            //获取DisplayContent、DisplayPolicy以及WindowStateAnimator             final DisplayContent displayContent = win.getDisplayContent();            final DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();            WindowStateAnimator winAnimator = win.mWinAnimator;            if (viewVisibility != View.GONE) &#123;                //根据客户端请求的窗口大小设置WindowState的requestedWidth, requestedHeight                //并设置WindowState.mLayoutNeeded为true                win.setRequestedSize(requestedWidth, requestedHeight);            &#125;            ......            //根据请求的宽带和高度窗口缩放比例            win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);            ......            //获取原来window的可见性，此时为INVISIBLE            final int oldVisibility = win.mViewVisibility;            ......            //代表现在没有surface但应该很快就有标志位            win.mRelayoutCalled = true;            win.mInRelayout = true;            //将当前窗口的可见性有原来的INVISIBLE调整为VISIBLE            win.setViewVisibility(viewVisibility);            ProtoLog.i(WM_DEBUG_SCREEN_ON,                    &quot;Relayout %s: oldVis=%d newVis=%d. %s&quot;, win, oldVisibility,                            viewVisibility, new RuntimeException().fillInStackTrace());            /*2.1.将displayContent中的布局标志为mLayoutNeeded置为true*/            win.setDisplayLayoutNeeded();            win.mGivenInsetsPending = (flags &amp; WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;            // We should only relayout if the view is visible, it is a starting window, or the            // associated appToken is not hidden.            /*2.2.判断是否允许relayout，此时为true*/            //判断条件：view可见且（activityRecord不为空，或者布局类型为TYPE_APPLICATION_STARTING，或者窗口已经告诉客户端可以显示）            final boolean shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;                    (win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING                            || win.mActivityRecord.isClientVisible());            ......            // Create surfaceControl before surface placement otherwise layout will be skipped            // (because WS.isGoneForLayout() is true when there is no surface.            /*3.surface的创建流程*/            if (shouldRelayout) &#123;                try &#123;                    //进入creatSurfaceControl开始创建SurfaceControl                    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);                &#125; catch (Exception e) &#123;                    ......                    return 0;                &#125;            &#125;            // We may be deferring layout passes at the moment, but since the client is interested            // in the new out values right now we need to force a layout.            /*4.窗口尺寸的计算以及Surface的状态变更*/            //WindowSurfacePlacer在WMS初始化的时候创建            mWindowPlacerLocked.performSurfacePlacement(true /* force */);            ......            //填充计算好的frame返回给客户端，更新mergedConfiguration对象            win.fillClientWindowFramesAndConfiguration(outFrames, mergedConfiguration,                    false /* useLatestConfig */, shouldRelayout);            // Set resize-handled here because the values are sent back to the client.            win.onResizeHandled();            ......        &#125;        Binder.restoreCallingIdentity(origId);        //返回result        return result;    &#125;</code></pre><h5 id="2-2-3-创建SurfaceControl"><a href="#2-2-3-创建SurfaceControl" class="headerlink" title="2.2.3 创建SurfaceControl"></a>2.2.3 创建SurfaceControl</h5><p>在relayoutWindow中创建SurfaceControl<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code><br>关于SurfaceControl的创建在WMS中主要做两件事：<br>1.调用WindwoStateAnimator执行具体的SurfaceControl的创建。<br>2.将创建的SurfaceControl赋值给客户端的outSurfaceControl。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p><pre><code>    private int createSurfaceControl(SurfaceControl outSurfaceControl, int result,            WindowState win, WindowStateAnimator winAnimator) &#123;        ......        WindowSurfaceController surfaceController;        try &#123;            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;createSurfaceControl&quot;);            /*             * WindowStateAnimator用来帮助WindowState管理animator和surface基本操作的             * 1.WMS将创建的surfaceContorl的操作交给windowAnimator来处理             */            surfaceController = winAnimator.createSurfaceLocked();        &#125; finally &#123;            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        &#125;        if (surfaceController != null) &#123;            /*2.将WMS的SurfaceControl赋值给客户端的outSurfaceControl*/            surfaceController.getSurfaceControl(outSurfaceControl);            ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot;OUT SURFACE %s: copied&quot;, outSurfaceControl);        &#125; else &#123;            // For some reason there isn&#39;t a surface.  Clear the            // caller&#39;s object so they see the same state.            ProtoLog.w(WM_ERROR, &quot;Failed to create surface control for %s&quot;, win);            outSurfaceControl.release();        &#125;        return result;    &#125;</code></pre><p>在WindowStateAnimator中创建SurfaceControl主要经过以下三个步骤：<br>1.重置Surface标志位，变更mDrawState状态为DRAW_PENDING。<br>2.通过实例化WindowSurfaceController来创建SurfaceControl。<br>3.处理Surface标志位，将其置为true，标志着当前WindowState已经有surface了<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p><pre><code>   WindowSurfaceController createSurfaceLocked() &#123;        final WindowState w = mWin;                //首先判断是否存在mSurfaceController        if (mSurfaceController != null) &#123;            return mSurfaceController;        &#125;        /*1.1.设置WindowState的mHasSurface设置为false*/        w.setHasSurface(false);        ProtoLog.i(WM_DEBUG_ANIM, &quot;createSurface %s: mDrawState=DRAW_PENDING&quot;, this);        /*1.2.将WindowStateAnimator中的DrawState设置为DRAW_PENDING*/        resetDrawState();        mService.makeWindowFreezingScreenIfNeededLocked(w);        /*1.3.将surface创建flag设置为hidden*/        int flags = SurfaceControl.HIDDEN;        //获取windowState的布局参数        final WindowManager.LayoutParams attrs = w.mAttrs;        // Set up surface control with initial size.        try &#123;            ......            /*2.创建WindowSurfaceController*/            //attrs.getTitle().toString()为当前activity的全路径名            //format为位图格式            //flags为surface创建的标志位（如：HIDDED(0x04,surface创建为隐藏)，SKIP_SCREENSHOT(0x040，截屏时跳过此图层将不会包含在非主显示器上),SECURE(0X080,禁止复制表面的内容，屏幕截图和次要的非安全显示将呈现黑色内容而不是surface内容)等）            //attrs.type为窗口类型            mSurfaceController = new WindowSurfaceController(attrs.getTitle().toString(), format,                    flags, this, attrs.type);            mSurfaceController.setColorSpaceAgnostic((attrs.privateFlags                    &amp; WindowManager.LayoutParams.PRIVATE_FLAG_COLOR_SPACE_AGNOSTIC) != 0);            /*3.将WindowState的hasSurface标志设置为true，标志着道歉WindowState已经有surface了*/            w.setHasSurface(true);            ......        &#125; catch (OutOfResourcesException e) &#123;            ......        &#125; catch (Exception e) &#123;            ......        &#125;        ......        return mSurfaceController;    &#125;</code></pre><p>SurfaceControl的创建过程为典型的建造者模式<br>接下来看看WindowSurfaceController的构造方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p><pre><code>WindowSurfaceController(String name, int format, int flags, WindowStateAnimator animator,            int windowType) &#123;        //设置WindowStateAnimator        mAnimator = animator;        //窗口名        title = name;        //WMS对象        mService = animator.mService;        //WindowState对象        final WindowState win = animator.mWin;        //窗口类型        mWindowType = windowType;        //IWindowSession对象        mWindowSession = win.mSession;        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;new SurfaceControl&quot;);        //makeSurface最终会调用到DisplayContent的makeChildSurface方法，返回SurfaceControl.Builder        final SurfaceControl.Builder b = win.makeSurface()                .setParent(win.getSurfaceControl())                .setName(name)                .setFormat(format)                .setFlags(flags)                .setMetadata(METADATA_WINDOW_TYPE, windowType)                .setMetadata(METADATA_OWNER_UID, mWindowSession.mUid)                .setMetadata(METADATA_OWNER_PID, mWindowSession.mPid)                .setCallsite(&quot;WindowSurfaceController&quot;);        ......        //获取SurfaceControl实例对象        mSurfaceControl = b.build();        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);    &#125;</code></pre><p>两个关键方法win.makeSurface()和b.build()<br>1.<code>final SurfaceControl.Builder b = win.makeSurface()</code><br>我们先来看看win.makeSurface()，windowState中没有makeSurface()方法，因此调用其父类WindowContainer的makeSurface()方法<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p><pre><code>    SurfaceControl.Builder makeSurface() &#123;        final WindowContainer p = getParent();        return p.makeChildSurface(this);    &#125;        /**     * @param child The WindowContainer this child surface is for, or null if the Surface     *              is not assosciated with a WindowContainer (e.g. a surface used for Dimming).     */    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;        final WindowContainer p = getParent();        // Give the parent a chance to set properties. In hierarchy v1 we rely        // on this to set full-screen dimensions on all our Surface-less Layers.        return p.makeChildSurface(child)                .setParent(mSurfaceControl);    &#125;</code></pre><p>最终会调用到DisplayContent的makeChildSurface<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>    @Override    SurfaceControl.Builder makeChildSurface(WindowContainer child) &#123;        //此时child为WindowState        //获取SurfaceSession，SurfaceSession的创建在Session.windowAddedLocked中，其最开始调用在WindowManagerService.addWindow中win.attach()中创建        SurfaceSession s = child != null ? child.getSession() : getSession();        //返回SurfaceControl.Builder        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(s).setContainerLayer();        if (child == null) &#123;            return b;        &#125;        //设置SurfaceControl.Builder的name以及parent        return b.setName(child.getName())                .setParent(mSurfaceControl);    &#125;</code></pre><p>2.<code>mSurfaceControl = b.build();</code><br>再来看看b.build()，调用SurfaceControl中的build<br>代码路径：framework&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p><pre><code>    /**      * Construct a new &#123;@link SurfaceControl&#125; with the set parameters. The builder      * remains valid.      */     @NonNull     public SurfaceControl build() &#123;     //检查width以及height，初始都应该为0         if (mWidth &lt; 0 || mHeight &lt; 0) &#123;             throw new IllegalStateException(                     &quot;width and height must be positive or unset&quot;);         &#125;         if ((mWidth &gt; 0 || mHeight &gt; 0) &amp;&amp; (isEffectLayer() || isContainerLayer())) &#123;             throw new IllegalStateException(                     &quot;Only buffer layers can set a valid buffer size.&quot;);         &#125;             if ((mFlags &amp; FX_SURFACE_MASK) == FX_SURFACE_NORMAL) &#123;             setBLASTLayer();         &#125;    //创建SurfaceControl的实例         return new SurfaceControl(                 mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,                 mLocalOwnerView, mCallsite);     &#125;       /**    * @param session  The surface session, must not be null.    * @param name     The surface name, must not be null.    * @param w        The surface initial width.    * @param h        The surface initial height.    * @param flags    The surface creation flags.    * @param metadata Initial metadata.    * @param callsite String uniquely identifying callsite that created this object. Used for    *                 leakage tracking.    * @throws throws OutOfResourcesException If the SurfaceControl cannot be created.    */    private SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags,         SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView,         String callsite)                 throws OutOfResourcesException, IllegalArgumentException &#123;     if (name == null) &#123;         throw new IllegalArgumentException(&quot;name must not be null&quot;);     &#125;         mName = name;     mWidth = w;     mHeight = h;     mLocalOwnerView = localOwnerView;     //创建Parcel用来传递数据     Parcel metaParcel = Parcel.obtain();     try &#123;       ......       //调用native层         mNativeObject = nativeCreate(session, name, w, h, format, flags,                 parent != null ? parent.mNativeObject : 0, metaParcel);     &#125; finally &#123;         metaParcel.recycle();     &#125;     if (mNativeObject == 0) &#123;         throw new OutOfResourcesException(                 &quot;Couldn&#39;t allocate SurfaceControl native object&quot;);     &#125;     mNativeHandle = nativeGetHandle(mNativeObject);     mCloseGuard.openWithCallSite(&quot;release&quot;, callsite);    &#125;</code></pre><p>​    </p><p>SurfaceControl的构造方法调用完成后，返回查看前面<br><code>result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</code></p><h5 id="2-2-4-计算窗口大小位置"><a href="#2-2-4-计算窗口大小位置" class="headerlink" title="2.2.4 计算窗口大小位置"></a>2.2.4 计算窗口大小位置</h5><p>在relayoutWindow中计算窗口大小位置<br><code>mWindowPlacerLocked.performSurfacePlacement(true /* force */);</code><br>该流程我们分为三部分介绍：<br>1.该部分处理有关窗口布局循环的逻辑。<br>2.该部分处理Surface的状态变更，以及调用layoutWindowLw的流程。<br>3.计算窗口位置大小。</p><h6 id="1-处理窗口布局循环"><a href="#1-处理窗口布局循环" class="headerlink" title="1.处理窗口布局循环"></a>1.处理窗口布局循环</h6><p>performSurfacePlacement是一个确定所有窗口的Surface的如何摆放，如何显示、显示在什么位置、显示区域多大的一个入口方法。<br>该方法主要设置了布局的循环条件，当mTraversalScheduled 标志位为true，且loopCount大于0。将会调用performSurfacePlacementLoop执行布局操作。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p><pre><code>    final void performSurfacePlacement(boolean force) &#123;        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;            mDeferredRequests++;            return;        &#125;        //将循环的最大次数设置为6次        int loopCount = 6;        do &#123;            //将该标志为设置为false            mTraversalScheduled = false;            //执行窗口布局操作            performSurfacePlacementLoop();            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);            loopCount--;        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);        mService.mRoot.mWallpaperActionPending = false;    &#125;</code></pre><p>performSurfacePlacementLoop方法主要做两件事：<br>1.调用RootWindowContainer对所有窗口执行布局操作，<br>2.处理是否再次进行布局的逻辑。如果DisplayContent.mLayoutNeeded标志位为true且布局循环次数小于6次，则会将mTraversalScheduled标志位置为true，在performSurfacePlacement中会再次调用performSurfacePlacementLoop。</p><pre><code>    private void performSurfacePlacementLoop() &#123;        //若当前已经进行布局操作，则无需重复调用直接返回        if (mInLayout) &#123;            ......            return;        &#125;        ......        //将该标志位置为true，表示正在处于布局过程中        mInLayout = true;        ......        try &#123;            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/            mService.mRoot.performSurfacePlacement();            mInLayout = false;            if (mService.mRoot.isLayoutNeeded()) &#123;                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/                if (++mLayoutRepeatCount &lt; 6) &#123;                    //该方法中会将mTraversalScheduled标志位设置位true                    requestTraversal();                &#125; else &#123;                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);                    mLayoutRepeatCount = 0;                &#125;            &#125; else &#123;                mLayoutRepeatCount = 0;            &#125;            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);            &#125;        &#125; catch (RuntimeException e) &#123;            mInLayout = false;            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);        &#125;    &#125;</code></pre><h6 id="2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程"><a href="#2-处理所有Surface的状态变更，以及调用layoutWindowLw的流程" class="headerlink" title="2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程"></a>2.处理所有Surface的状态变更，以及调用layoutWindowLw的流程</h6><p><code>mService.mRoot.performSurfacePlacement();</code><br>上面说到在RootWindowContainer.performSurfacePlacement()中调用了performSurfaceNoTrace()方法，该方法为实际的处理布局的方法，主要处理以下流程：<br>1.如果有焦点变化，更新焦点。<br>2.执行窗口尺寸计算，surface状态变更等操作。<br>3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在finishdrawing()中再详细分析。<br>4.如果壁纸有变化，更新壁纸。<br>5.再次处理焦点变化。<br>6.如果过程中由size或者位置变化，则通知客户端重新relayout。<br>7.销毁不可见的窗口<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p><pre><code>    void performSurfacePlacement() &#123;        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);        try &#123;            //调用performSurfacePlacementNoTrace()            performSurfacePlacementNoTrace();        &#125; finally &#123;            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        &#125;    &#125;    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;    // TODO: Super long method that should be broken down...    void performSurfacePlacementNoTrace() &#123;        ......        /*1.如果有焦点变化，更新焦点*/        if (mWmService.mFocusMayChange) &#123;            mWmService.mFocusMayChange = false;            mWmService.updateFocusedWindowLocked(                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);        &#125;        ......                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);        //开启事务，获取GlobalTransactionWrapper对象        mWmService.openSurfaceTransaction();        try &#123;            /*2.执行窗口尺寸计算，surface状态变更等操作*/            applySurfaceChangesTransaction();        &#125; catch (RuntimeException e) &#123;            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);        &#125; finally &#123;            //关闭事务            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);            if (SHOW_LIGHT_TRANSACTIONS) &#123;                Slog.i(TAG,                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);            &#125;        &#125;        ......        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/        checkAppTransitionReady(surfacePlacer);        ......        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;            final DisplayContent displayContent = mChildren.get(displayNdx);            //判断DisplayContent的壁纸是否需要改变            if (displayContent.mWallpaperMayChange) &#123;                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;                if (DEBUG_LAYOUT_REPEATS) &#123;                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,                            displayContent.pendingLayoutChanges);                &#125;            &#125;        &#125;        /*5.在此处理焦点变化*/        if (mWmService.mFocusMayChange) &#123;            mWmService.mFocusMayChange = false;            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,                    false /*updateInputWindows*/);        &#125;        ......        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/        handleResizingWindows();        if (mWmService.mDisplayFrozen) &#123;            ProtoLog.v(WM_DEBUG_ORIENTATION,                    &quot;With display frozen, orientationChangeComplete=%b&quot;,                    mOrientationChangeComplete);        &#125;        if (mOrientationChangeComplete) &#123;            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);            &#125;            mWmService.stopFreezingDisplayLocked();        &#125;        // Destroy the surface of any windows that are no longer visible.        /*7.销毁不可见的窗口*/        i = mWmService.mDestroySurface.size();        if (i &gt; 0) &#123;            do &#123;                i--;                WindowState win = mWmService.mDestroySurface.get(i);                win.mDestroying = false;                final DisplayContent displayContent = win.getDisplayContent();                if (displayContent.mInputMethodWindow == win) &#123;                    displayContent.setInputMethodWindowLocked(null);                &#125;                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;                &#125;                win.destroySurfaceUnchecked();            &#125; while (i &gt; 0);            mWmService.mDestroySurface.clear();        &#125;        ......    &#125;</code></pre><p>​    </p><p>在<code>applySurfaceChangesTransaction();</code>方法中其主要执行：<br>1.水印、StrictMode警告框以及模拟器显示的布局。<br>2.遍历所有DisplayContent执行其applySurfaceChangesTransaction<br>我们一起看看这个方法</p><pre><code>    private void applySurfaceChangesTransaction() &#123;        mHoldScreenWindow = null;        mObscuringWindow = null;        // TODO(multi-display): Support these features on secondary screens.        /*1.水印、StrictMode警告框以及模拟器显示的布局*/        //获取手机默认DisplayContent的信息        final DisplayContent defaultDc = mWmService.getDefaultDisplayContentLocked();        final DisplayInfo defaultInfo = defaultDc.getDisplayInfo();        final int defaultDw = defaultInfo.logicalWidth;        final int defaultDh = defaultInfo.logicalHeight;        //布局水印        if (mWmService.mWatermark != null) &#123;            mWmService.mWatermark.positionSurface(defaultDw, defaultDh, mDisplayTransaction);        &#125;        //布局StrictMode警告框        if (mWmService.mStrictModeFlash != null) &#123;            mWmService.mStrictModeFlash.positionSurface(defaultDw, defaultDh, mDisplayTransaction);        &#125;        //布局模拟器显示覆盖        if (mWmService.mEmulatorDisplayOverlay != null) &#123;            mWmService.mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh,                    mWmService.getDefaultDisplayRotation(), mDisplayTransaction);        &#125;        /*2.遍历RootWindowContainer下所有DisplayContent执行其applySurfaceChangesTransaction()*/        final int count = mChildren.size();        for (int j = 0; j &lt; count; ++j) &#123;            final DisplayContent dc = mChildren.get(j);            dc.applySurfaceChangesTransaction();        &#125;        // Give the display manager a chance to adjust properties like display rotation if it needs        // to.        mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction);        SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);    &#125;</code></pre><p>接下来继续跟踪<code>dc.applySurfaceChangesTransaction();</code><br>该方法主要<br>1.遍历所有窗口，计算窗口的布局大小，具体流程查看performLayoutNoTrace。（主要跟踪点）<br>2.surface的状态更改。（见“<strong>2.3.3mDrawState变更为HAS_DRAW”流程</strong>”）<br>3.处理surface的位置、大小以及显示等。（见“<strong>2.3.4 show Surface”流程</strong>”）<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>    void applySurfaceChangesTransaction() &#123;        //获取WindowSurfacePlacer         final WindowSurfacePlacer surfacePlacer = mWmService.mWindowPlacerLocked;        ......        // Perform a layout, if needed.        /*1.执行布局，该方法最终会调用performLayoutNoTrace，计算窗口的布局参数*/        performLayout(true /* initial */, false /* updateInputWindows */);        ......        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applyWindowSurfaceChanges&quot;);        try &#123;            /*2.遍历所有窗口，主要是改变surface的状态。见“2.3.3mDrawState变更为HAS_DRAW”流程*/            forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);        &#125; finally &#123;            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        &#125;        /*3.处理各个surface的位置、大小以及是否要在屏幕上显示等。后面finishDrawing()流程中再跟踪*/        prepareSurfaces();        ......    &#125;</code></pre><p>继续跟踪<code>performLayout(true /* initial */, false /* updateInputWindows */);</code><br>该方法主要就是调用performLayoutNoTrace()方法，首先判断布局标志位mLayoutNeeded，该标志位在WMS.relayoutWindow中被置为true。<br>false则直接返回不会进行布局操作。<br>true则分别遍历父窗口和子窗口进行布局，我们暂且只分析父窗口的布局操作，查看mPerformLayout。</p><pre><code>    void performLayout(boolean initial, boolean updateInputWindows) &#123;        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performLayout&quot;);        try &#123;            //调用performLayoutNoTrace            performLayoutNoTrace(initial, updateInputWindows);        &#125; finally &#123;            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        &#125;    &#125;    private void performLayoutNoTrace(boolean initial, boolean updateInputWindows) &#123;            /*1.判断是否需要布局，不需要则直接返回，即判断布局标志位mLayoutNeeded是否为true*/        if (!isLayoutNeeded()) &#123;            return;        &#125;        //将DisplayContent.mLayoutNeeded属性置为false        clearLayoutNeeded();        ......        // First perform layout of any root windows (not attached to another window).        /*2.对所有顶级窗口进行布局*/        //最终会回调mPerformLayout        forAllWindows(mPerformLayout, true /* traverseTopToBottom */);        // Now perform layout of attached windows, which usually depend on the position of the        // window they are attached to. XXX does not deal with windows that are attached to windows        // that are themselves attached.        /*3.处理子窗口的布局*/        //最终会回调mPerformLayoutAttached        forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);        ......    &#125;</code></pre><p><code>forAllWindows(mPerformLayoutAttached, true /* traverseTopToBottom */);</code><br>当遍历到DisplayContent下的每个窗口时都会执行mPerformLayout，该方法会将WindowState.mLayoutNeeded标志位置false，并将具体的布局操作交给DisplayPolicy进行处理，见“<strong>3. 计算窗口位置大小</strong>“。</p><pre><code>    private final Consumer&lt;WindowState&gt; mPerformLayout = w -&gt; &#123;        //如果当前窗口为子窗口则直接返回        if (w.mLayoutAttached) &#123;            return;        &#125;        // Don&#39;t do layout of a window if it is not visible, or soon won&#39;t be visible, to avoid        // wasting time and funky changes while a window is animating away.        //先判断当前窗口是否会不可见        final boolean gone = w.isGoneForLayout();        ......        // If this view is GONE, then skip it -- keep the current frame, and let the caller know        // so they can ignore it if they want.  (We do the normal layout for INVISIBLE windows,        // since that means &quot;perform layout as normal, just don&#39;t display&quot;).        if (!gone || !w.mHaveFrame || w.mLayoutNeeded) &#123;            if (mTmpInitial) &#123;                //设置窗口布局WindowFrames.mContentChanged为false                w.resetContentChanged();            &#125;            //将mSurfacePlacementNeeded标志为置为true            w.mSurfacePlacementNeeded = true;            //将WindowState.mLayoutNeeded标志位置为false            w.mLayoutNeeded = false;            //判断当前窗口是否是第一次布局            final boolean firstLayout = !w.isLaidOut();            //调用DisplayPolicy.layoutWindowLw进行布局，根据DisplayFrames对象对WindowState.mWindowFrames中的各个Rect对象属性进行确定            getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);            w.mLayoutSeq = mLayoutSeq;            // If this is the first layout, we need to initialize the last frames and inset values,            // as otherwise we&#39;d immediately cause an unnecessary resize.            if (firstLayout) &#123;                // The client may compute its actual requested size according to the first layout,                // so we still request the window to resize if the current frame is empty.                if (!w.getFrame().isEmpty()) &#123;                    w.updateLastFrames();                &#125;                w.onResizeHandled();            &#125;            if (DEBUG_LAYOUT) Slog.v(TAG, &quot;  LAYOUT: mFrame=&quot; + w.getFrame()                    + &quot; mParentFrame=&quot; + w.getParentFrame()                    + &quot; mDisplayFrame=&quot; + w.getDisplayFrame());        &#125;    &#125;;</code></pre><p>当mLayoutNeeded标志被设置时，表示布局需要更新；mSurfacePlacementNeeded标志被设置时，表示需要更新surface位置的条件之一（WindowState.updateSurfacePosition方法中有判断）。</p><h6 id="3-计算窗口位置大小"><a href="#3-计算窗口位置大小" class="headerlink" title="3.计算窗口位置大小"></a>3.计算窗口位置大小</h6><p><code>getDisplayPolicy().layoutWindowLw(w, null, mDisplayFrames);</code><br>layoutWindowLw主要做了以下三件事<br>1.首先会获DisplayFrames：DisplayContent新建时创建，内部数据由屏幕提供。<br>2.其次调用WindowLayout.computeFrames计算窗口布局大小。<br>3.最后调用WindowState.setFrames将计算的布局参数赋值给当前窗口的windowFrames。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayPolicy.java</p><pre><code>    /**     * Called for each window attached to the window manager as layout is proceeding. The     * implementation of this function must take care of setting the window&#39;s frame, either here or     * in finishLayout().     *     * @param win The window being positioned.     * @param attached For sub-windows, the window it is attached to; this     *                 window will already have had layoutWindow() called on it     *                 so you can use its Rect.  Otherwise null.     * @param displayFrames The display frames.     */    public void layoutWindowLw(WindowState win, WindowState attached, DisplayFrames displayFrames) &#123;        //判断是否需要跳过布局        if (win.skipLayout()) &#123;            return;        &#125;        // This window might be in the simulated environment.        // We invoke this to get the proper DisplayFrames.        /*1.获取DisplayFrames*/        displayFrames = win.getDisplayFrames(displayFrames);        //获取某个方向的窗口布局参数        final WindowManager.LayoutParams attrs = win.getLayoutingAttrs(displayFrames.mRotation);        //null        final Rect attachedWindowFrame = attached != null ? attached.getFrame() : null;        // If this window has different LayoutParams for rotations, we cannot trust its requested        // size. Because it might have not sent its requested size for the new rotation.        final boolean trustedSize = attrs == win.mAttrs;        final int requestedWidth = trustedSize ? win.mRequestedWidth : UNSPECIFIED_LENGTH;        final int requestedHeight = trustedSize ? win.mRequestedHeight : UNSPECIFIED_LENGTH;        /*2.调用WindowLayout.computeFrames计算窗口布局大小*/        mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,                sTmpClientFrames);        /*3.将计算的布局参数赋值给windowFrames*/        win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);    &#125;</code></pre><p>先来看看computeFrames，计算窗口布局大小</p><pre><code>mWindowLayout.computeFrames(attrs, win.getInsetsState(), displayFrames.mDisplayCutoutSafe,                win.getBounds(), win.getWindowingMode(), requestedWidth, requestedHeight,                win.getRequestedVisibilities(), attachedWindowFrame, win.mGlobalScale,                sTmpClientFrames);</code></pre><p>调用的是WindowLayout的computeFrames方法</p><pre><code>public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames)</code></pre><p>入参说明：<br><code>attrs</code>：这些是窗口的布局参数。它们定义了窗口的位置、大小、堆叠顺序等属性。<br><code>state</code>：这个参数代表了窗口的边距状态。边距是窗口与设备边缘之间的空间，可能会被其他元素（如状态栏或导航栏）占据。<br><code>displayCutoutSafe</code>：这是一个矩形，表示在计算窗口大小时可以安全忽略的显示切边区域。这通常是为了防止应用程序内容与设备上的物理切边重叠。<br><code>windowBounds</code>：这是窗口的边界矩形，通常表示窗口在屏幕上的位置和大小。<br><code>windowingMode</code>：这个参数定义了窗口的窗口模式。例如，它可以是全屏、浮动等模式。<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br><code>requestedVisibilities</code>：请求的可见性。这定义了应用程序请求的边距可见性，例如状态栏或导航栏是否可见。<br><code>attachedWindowFrame</code>：附加窗口的边界。如果这个窗口是附加到另一个窗口的，这个参数表示它相对于其父窗口的位置和大小。<br><code>compatScale</code>：兼容性比例，一个缩放因子，用于调整窗口内容的显示大小以适应不同的屏幕尺寸或分辨率。<br><code>outFrames</code>：用于返回计算后的窗口信息。它包含了窗口的实际边界、边距等信息。<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowLayout.java</p><pre><code>    public void computeFrames(WindowManager.LayoutParams attrs, InsetsState state,            Rect displayCutoutSafe, Rect windowBounds, @WindowingMode int windowingMode,            int requestedWidth, int requestedHeight, InsetsVisibilities requestedVisibilities,            Rect attachedWindowFrame, float compatScale, ClientWindowFrames outFrames) &#123;        //传入的参数attrs中提取出窗口的类型（type）、标志（fl）、私有标志（pfl）和布局是否在屏幕内（layoutInScreen）        final int type = attrs.type;        final int fl = attrs.flags;        final int pfl = attrs.privateFlags;        final boolean layoutInScreen = (fl &amp; FLAG_LAYOUT_IN_SCREEN) == FLAG_LAYOUT_IN_SCREEN;        //定义了用于存储结果的矩形变量，包含：显示边界（outDisplayFrame）、父边界（outParentFrame）和实际边界（outFrame）        final Rect outDisplayFrame = outFrames.displayFrame;        final Rect outParentFrame = outFrames.parentFrame;        final Rect outFrame = outFrames.frame;        // Compute bounds restricted by insets        //计算窗口被Insets限制的边界。Insets是屏幕边缘的空间，用于放置状态栏、导航栏等。        //这一步通过调用state.calculateInsets()方法完成，该方法需要窗口边界和窗口布局参数作为输入。        final Insets insets = state.calculateInsets(windowBounds, attrs.getFitInsetsTypes(),                attrs.isFitInsetsIgnoringVisibility());        //代码根据Insets的边类型（LEFT、TOP、RIGHT、BOTTOM），从计算出的Insets中提取出相应的边距，        //并将它们添加到窗口的原始边界上，得到显示边界。        final @WindowInsets.Side.InsetsSide int sides = attrs.getFitInsetsSides();        final int left = (sides &amp; WindowInsets.Side.LEFT) != 0 ? insets.left : 0;        final int top = (sides &amp; WindowInsets.Side.TOP) != 0 ? insets.top : 0;        final int right = (sides &amp; WindowInsets.Side.RIGHT) != 0 ? insets.right : 0;        final int bottom = (sides &amp; WindowInsets.Side.BOTTOM) != 0 ? insets.bottom : 0;        //代码将计算出的显示边界赋值给outDisplayFrame        outDisplayFrame.set(windowBounds.left + left, windowBounds.top + top,                windowBounds.right - right, windowBounds.bottom - bottom);        //根据窗口的附加信息和布局属性来确定父边界的位置和大小。        if (attachedWindowFrame == null) &#123;            //将outParentFrame设置为与outDisplayFrame相同，这意味着父边界与显示边界相同            outParentFrame.set(outDisplayFrame);            //检查私有标志PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME是否被设置。            //这个标志可能表示是否需要根据输入法窗口（IME）的位置来调整父边界。            if ((pfl &amp; PRIVATE_FLAG_INSET_PARENT_FRAME_BY_IME) != 0) &#123;                //从状态中获取输入法窗口的源（source）                final InsetsSource source = state.peekSource(ITYPE_IME);                if (source != null) &#123;                    //如果输入法窗口的source存在，则使用该source来计算父边界的内边距（Insets）。                    outParentFrame.inset(source.calculateInsets(                            outParentFrame, false /* ignoreVisibility */));//这里忽略source的可见性。                &#125;            &#125;        &#125; else &#123;            //如果layoutInScreen为true，则将outParentFrame设置为与attachedWindowFrame相同。            //这表示父边界是由附加窗口的边界决定的。            //如果layoutInScreen为false，则将outParentFrame设置为与outDisplayFrame相同。            //这表示父边界与显示边界相同。            outParentFrame.set(!layoutInScreen ? attachedWindowFrame : outDisplayFrame);        &#125;        // Compute bounds restricted by display cutout        //根据屏幕的显示切边和窗口的布局属性来计算窗口在屏幕上受到限制的位置和大小，确保窗口不会覆盖到显示切边区域        final int cutoutMode = attrs.layoutInDisplayCutoutMode;//切边模式        final DisplayCutout cutout = state.getDisplayCutout();//屏幕上的显示切边区域        //将displayCutoutSafeExceptMaybeBars设置为与displayCutoutSafe相同，        //这是一个临时矩形，用于稍后计算不受某些系统界面元素（如状态栏）影响的显示切边安全区域。        final Rect displayCutoutSafeExceptMaybeBars = mTempDisplayCutoutSafeExceptMaybeBarsRect;        displayCutoutSafeExceptMaybeBars.set(displayCutoutSafe);        //将outFrames.isParentFrameClippedByDisplayCutout设置为false，表示父边界目前没有被显示切边裁剪        outFrames.isParentFrameClippedByDisplayCutout = false;        //如果layoutInDisplayCutoutMode不是ALWAYS并且显示切边不为空        if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS &amp;&amp; !cutout.isEmpty()) &#123;            // Ensure that windows with a non-ALWAYS display cutout mode are laid out in            // the cutout safe zone.            //获取屏幕的显示边界（displayFrame）            final Rect displayFrame = state.getDisplayFrame();            //获取状态的Source            final InsetsSource statusBarSource = state.peekSource(ITYPE_STATUS_BAR);            //检查状态栏源（statusBarSource）是否存在，并且如果displayCutoutSafe.top大于屏幕的顶部            if (statusBarSource != null &amp;&amp; displayCutoutSafe.top &gt; displayFrame.top) &#123;                // Make sure that the zone we&#39;re avoiding for the cutout is at least as tall as the                // status bar; otherwise fullscreen apps will end up cutting halfway into the status                // bar.                //调整displayCutoutSafeExceptMaybeBars.top以确保切边避开的区域至少与状态栏一样高。                displayCutoutSafeExceptMaybeBars.top =                        Math.max(statusBarSource.getFrame().bottom, displayCutoutSafe.top);            &#125;            //如果layoutInDisplayCutoutMode是SHORT_EDGES            if (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES) &#123;                if (displayFrame.width() &lt; displayFrame.height()) &#123;                    //如果屏幕的宽度小于高度，则将displayCutoutSafeExceptMaybeBars的顶部和底部设置为最大和最小整数值，                    //这意味着不考虑这些方向上的显示切边。                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;                &#125; else &#123;                    //否则，将左侧和右侧设置为最大和最小整数值                    //这意味着不考虑这些方向上的显示切边。                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;                &#125;            &#125;            //通过位运算检查attrs.flags中的FLAG_LAYOUT_INSET_DECOR标志是否被设置。如果被设置，则layoutInsetDecor为true            // FLAG_LAYOUT_INSET_DECOR:使窗口的内容布局在DecorView（装饰视图）之内            final boolean layoutInsetDecor = (attrs.flags &amp; FLAG_LAYOUT_INSET_DECOR) != 0;            //检查布局是否应在屏幕上进行且是否需要考虑显示切边            //布局在屏幕上、DecorView之内 且 显示切边模式为默认或短边缘模式            if (layoutInScreen &amp;&amp; layoutInsetDecor                    &amp;&amp; (cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT                    || cutoutMode == LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES)) &#123;                //使用给定的displayFrame、系统栏类型和可见性请求来计算系统栏的插入                //系统栏包含： STATUS_BARS | NAVIGATION_BARS | CAPTION_BAR                final Insets systemBarsInsets = state.calculateInsets(                        displayFrame, WindowInsets.Type.systemBars(), requestedVisibilities);                //如果系统栏在左侧、顶部、右侧或底部的插入大于0，则调整displayCutoutSafeExceptMaybeBars的相应边界，                //使其尽可能地远离屏幕边缘。这是为了确保窗口不会覆盖到这些系统栏。                if (systemBarsInsets.left &gt; 0) &#123;                    displayCutoutSafeExceptMaybeBars.left = Integer.MIN_VALUE;                &#125;                if (systemBarsInsets.top &gt; 0) &#123;                    displayCutoutSafeExceptMaybeBars.top = Integer.MIN_VALUE;                &#125;                if (systemBarsInsets.right &gt; 0) &#123;                    displayCutoutSafeExceptMaybeBars.right = Integer.MAX_VALUE;                &#125;                if (systemBarsInsets.bottom &gt; 0) &#123;                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;                &#125;            &#125;            //如果窗口类型是输入法（IME）            if (type == TYPE_INPUT_METHOD) &#123;                //获取导航栏的Source                final InsetsSource navSource = state.peekSource(ITYPE_NAVIGATION_BAR);                //如果存在导航栏且其底部插入大于0                if (navSource != null &amp;&amp; navSource.calculateInsets(displayFrame, true).bottom &gt; 0) &#123;                    // The IME can always extend under the bottom cutout if the navbar is there.                    //调整displayCutoutSafeExceptMaybeBars.bottom，允许IME窗口扩展到底部显示切边以下。                    //这是为了确保IME可以正常显示在有导航栏的设备上。                    displayCutoutSafeExceptMaybeBars.bottom = Integer.MAX_VALUE;                &#125;            &#125;            //如果窗口已附加到其父窗口并且不是全屏布局，则attachedInParent为true            final boolean attachedInParent = attachedWindowFrame != null &amp;&amp; !layoutInScreen;            // TYPE_BASE_APPLICATION windows are never considered floating here because they don&#39;t            // get cropped / shifted to the displayFrame in WindowState.            //判断窗口是否为浮窗            //如果窗口不是全屏的、全屏布局的并且不是基础应用程序类型，那么它是一个浮动在屏幕上的窗口，简称浮窗。            final boolean floatingInScreenWindow = !attrs.isFullscreen() &amp;&amp; layoutInScreen                    &amp;&amp; type != TYPE_BASE_APPLICATION;            // Windows that are attached to a parent and laid out in said parent already avoid            // the cutout according to that parent and don&#39;t need to be further constrained.            // Floating IN_SCREEN windows get what they ask for and lay out in the full screen.            // They will later be cropped or shifted using the displayFrame in WindowState,            // which prevents overlap with the DisplayCutout.            //对于非附加到父窗口和非浮动在屏幕上的窗口，需要处理其与显示切边的交集。这是因为这些窗口需要避免与显示切边重叠。            if (!attachedInParent &amp;&amp; !floatingInScreenWindow) &#123;                mTempRect.set(outParentFrame); //临时存储父窗口的边界                //将父窗口的边界设置为与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界                outParentFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);                //如果父窗口的边界交集后与原始边界不同，则表示父窗口的边界被切边裁剪了                outFrames.isParentFrameClippedByDisplayCutout = !mTempRect.equals(outParentFrame);            &#125;            //将输出显示边界设置与displayCutoutSafeExceptMaybeBars交集的边界，没有交集则置为空矩阵的边界            outDisplayFrame.intersectUnchecked(displayCutoutSafeExceptMaybeBars);        &#125;        //检查attrs.flags中的FLAG_LAYOUT_NO_LIMITS位是否被设置。        //FLAG_LAYOUT_NO_LIMITS表示允许窗口布局到屏幕外侧。        final boolean noLimits = (attrs.flags &amp; FLAG_LAYOUT_NO_LIMITS) != 0;        //检查当前窗口是否处于多窗口模式        final boolean inMultiWindowMode = WindowConfiguration.inMultiWindowMode(windowingMode);        // TYPE_SYSTEM_ERROR is above the NavigationBar so it can&#39;t be allowed to extend over it.        // Also, we don&#39;t allow windows in multi-window mode to extend out of the screen.        //noLimits是否为true即允许窗口布局到屏幕外）          //type是否不等于TYPE_SYSTEM_ERROR（表示窗口类型不是系统错误）          //inMultiWindowMode是否为false（表示窗口不在多窗口模式下）        if (noLimits &amp;&amp; type != TYPE_SYSTEM_ERROR &amp;&amp; !inMultiWindowMode) &#123;            //设置输出显示的窗口边界            //[left,top]为左上角左边，[right,bottom]为右上角坐标，两个坐标构成一个矩形            //左上角左边设置为屏幕最小点，右下角坐标设置为屏幕最大点，即窗口将占据整个屏幕的边界            outDisplayFrame.left = MIN_X;            outDisplayFrame.top = MIN_Y;            outDisplayFrame.right = MAX_X;            outDisplayFrame.bottom = MAX_Y;        &#125;        //如果compatScale不等于1，则hasCompatScale为true。这意味着存在一个兼容的缩放因子。        final boolean hasCompatScale = compatScale != 1f;        //父窗口的宽度和高度        final int pw = outParentFrame.width();        final int ph = outParentFrame.height();        //判断窗口的布局尺寸是否因为显示切边而扩展        //某些设备可能具有物理上的切边（如刘海屏、水滴屏等），这些切边区域不能用于显示内容。        //PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT作用就是为了确保应用程序的布局在具有切边的设备上仍然正确显示        //设置这个标志时，窗口的实际尺寸将大于其请求的尺寸，以便在切边区域周围填充空间。        final boolean extendedByCutout =                (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != 0;        //请求的窗口宽度和高度        int rw = requestedWidth;        int rh = requestedHeight;        //窗口的位置坐标        float x, y;        //最终确定的窗口宽度和高度        int w, h;        // If the view hierarchy hasn&#39;t been measured, the requested width and height would be        // UNSPECIFIED_LENGTH. This can happen in the first layout of a window or in the simulated        // layout. If extendedByCutout is true, we cannot use the requested lengths. Otherwise,        // the window frame might be extended again because the requested lengths may come from the        // window frame.        //如果请求的窗口宽度或高度，是UNSPECIFIED_LENGTH或者窗口因为显示切边而扩展，        //那么其大于或等于0则使用attrs.width或attrs.height的值，否则使用父窗口的宽度和高度        if (rw == UNSPECIFIED_LENGTH || extendedByCutout) &#123;            rw = attrs.width &gt;= 0 ? attrs.width : pw;        &#125;        if (rh == UNSPECIFIED_LENGTH || extendedByCutout) &#123;            rh = attrs.height &gt;= 0 ? attrs.height : ph;        &#125;        //如果设置了FLAG_SCALED标志，代码会根据是否应用兼容性缩放来调整窗口的宽度和高度。        if ((attrs.flags &amp; FLAG_SCALED) != 0) &#123;            if (attrs.width &lt; 0) &#123;                w = pw;            &#125; else if (hasCompatScale) &#123;                w = (int) (attrs.width * compatScale + .5f);            &#125; else &#123;                w = attrs.width;            &#125;            if (attrs.height &lt; 0) &#123;                h = ph;            &#125; else if (hasCompatScale) &#123;                h = (int) (attrs.height * compatScale + .5f);            &#125; else &#123;                h = attrs.height;            &#125;        &#125; else &#123;            if (attrs.width == MATCH_PARENT) &#123;                w = pw;            &#125; else if (hasCompatScale) &#123;                w = (int) (rw * compatScale + .5f);            &#125; else &#123;                w = rw;            &#125;            if (attrs.height == MATCH_PARENT) &#123;                h = ph;            &#125; else if (hasCompatScale) &#123;                h = (int) (rh * compatScale + .5f);            &#125; else &#123;                h = rh;            &#125;        &#125;        //如果存在兼容缩放因子，则调整窗口的x和y位置以考虑缩放。否则，直接使用原始的x和y位置。        if (hasCompatScale) &#123;            x = attrs.x * compatScale;            y = attrs.y * compatScale;        &#125; else &#123;            x = attrs.x;            y = attrs.y;        &#125;                //当前窗口是多窗口且设置PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME        //PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME的作用是窗口应该根据其父窗口的边界来调整自己的大小和位置。        //即控制子窗口在其父窗口内的布局行为，确保子窗口不会超出父窗口的边界。        if (inMultiWindowMode                &amp;&amp; (attrs.privateFlags &amp; PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME) == 0) &#123;            // Make sure window fits in parent frame since it is in a non-fullscreen task as            // required by &#123;@link Gravity#apply&#125; call.            //将窗口的宽度和高度分别设置为它们与父窗口宽度和高度中的较小值。            //这样做的目的是确保子窗口的大小不会超过其父窗口的大小。            w = Math.min(w, pw);            h = Math.min(h, ph);        &#125;        // We need to fit it to the display if either        // a) The window is in a fullscreen container, or we don&#39;t have a task (we assume fullscreen        // for the taskless windows)        // b) If it&#39;s a secondary app window, we also need to fit it to the display unless        // FLAG_LAYOUT_NO_LIMITS is set. This is so we place Popups, dialogs, and similar windows on        // screen, but SurfaceViews want to be always at a specific location so we don&#39;t fit it to        // the display.            //如果窗口不在多窗口模式下，或者窗口类型不是基础应用程序类型并且noLimits标志未设置，那么窗口需要适应显示。        final boolean fitToDisplay = !inMultiWindowMode                || ((attrs.type != TYPE_BASE_APPLICATION) &amp;&amp; !noLimits);        // Set mFrame        //根据给定的重力属性、宽度、高度、父边界等，计算并设置outFrame。        //这里主要是确定窗口的位置。        Gravity.apply(attrs.gravity, w, h, outParentFrame,                (int) (x + attrs.horizontalMargin * pw),                (int) (y + attrs.verticalMargin * ph), outFrame);        // Now make sure the window fits in the overall display frame.        //如果窗口需要适应显示，那么使用Gravity.applyDisplay方法来调整outFrame(实际边界)的大小和位置在outDisplayFrame(显示边界)之内。        if (fitToDisplay) &#123;            Gravity.applyDisplay(attrs.gravity, outDisplayFrame, outFrame);        &#125;         //确保应用窗口的位置不会与设备的切边冲突。         //如果窗口的布局因为切边的存在而进行了扩展，并且窗口的边界超出了安全区域，那么它会调整窗口的位置，使其位于安全区域内。        if (extendedByCutout &amp;&amp; !displayCutoutSafe.contains(outFrame)) &#123;            mTempRect.set(outFrame);            // Move the frame into displayCutoutSafe.            final int clipFlags = DISPLAY_CLIP_VERTICAL | DISPLAY_CLIP_HORIZONTAL;            Gravity.applyDisplay(attrs.gravity &amp; ~clipFlags, displayCutoutSafe,                    mTempRect);            if (mTempRect.intersect(outDisplayFrame)) &#123;                outFrame.union(mTempRect);            &#125;        &#125;        if (DEBUG) Log.d(TAG, &quot;computeWindowFrames &quot; + attrs.getTitle()                + &quot; outFrames=&quot; + outFrames                + &quot; windowBounds=&quot; + windowBounds.toShortString()                + &quot; attachedWindowFrame=&quot; + (attachedWindowFrame != null                        ? attachedWindowFrame.toShortString()                        : &quot;null&quot;)                + &quot; requestedWidth=&quot; + requestedWidth                + &quot; requestedHeight=&quot; + requestedHeight                + &quot; compatScale=&quot; + compatScale                + &quot; windowingMode=&quot; + WindowConfiguration.windowingModeToString(windowingMode)                + &quot; displayCutoutSafe=&quot; + displayCutoutSafe                + &quot; attrs=&quot; + attrs                + &quot; state=&quot; + state                + &quot; requestedVisibilities=&quot; + requestedVisibilities);  &#125;</code></pre><p>computeFrame方法是WindowState类中的一个重要方法，用于计算窗口的位置和大小。具体来说，它负责计算窗口的绘制区域，即窗口的内容在屏幕上实际显示的位置和大小。这个计算涉及到考虑窗口的位置、大小、布局参数以及可能的边界限制，确保窗口内容不会超出屏幕边界或被其他窗口遮挡。</p><p>在窗口管理器中，computeFrame方法通常会在以下情况被调用：</p><ul><li>当窗口第一次被创建时，需要计算其初始位置和大小。</li><li>当窗口的布局参数或内容发生变化时，需要重新计算窗口的位置和大小。</li><li>当屏幕旋转或大小变化等系统事件发生时，需要调整所有窗口的位置和大小。</li></ul><p>总之，computeFrame方法在Android窗口管理系统中起到了非常重要的作用，确保应用程序窗口能够正确地在屏幕上显示，并且适应不同的设备和系统事件, 为了计算小窗的位置，以及处理小窗内的View 的边界异常情况，</p><p>再来看看setFrames，更新窗口大小位置变化</p><pre><code> win.setFrames(sTmpClientFrames, win.mRequestedWidth, win.mRequestedHeight);</code></pre><p>调用的是WindowState的setFrames方法<br>入参说明：<br><code>sTmpClientFrames</code>：在computeFrames方法计算后的值，用于传递的窗口位置大小相关信息<br><code>requestedWidth</code>、<code>requestedHeight</code>：这是应用程序请求的窗口宽度和高度。<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p><pre><code>    void setFrames(ClientWindowFrames clientWindowFrames, int requestedWidth, int requestedHeight) &#123;        final WindowFrames windowFrames = mWindowFrames;        //用mTmpRect存储windowFrames.mParentFrame        mTmpRect.set(windowFrames.mParentFrame);                //LOCAL_LAYOUTd的值取决于配置项persist.debug.local_layout的值        if (LOCAL_LAYOUT) &#123;            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。            windowFrames.mCompatFrame.set(clientWindowFrames.frame);                        //将clientWindowFrames.frame的值设置为windowFrames.mFrame。            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。            windowFrames.mFrame.set(clientWindowFrames.frame);            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);            if (hasCompatScale()) &#123;                // The frames sent from the client need to be adjusted to the real coordinate space.                //如果存在兼容比例（通过调用hasCompatScale()方法检查），则对windowFrames中的Frame进行缩放，以适应实际的坐标空间。                //这里使用mGlobalScale作为缩放因子。                windowFrames.mFrame.scale(mGlobalScale);                windowFrames.mDisplayFrame.scale(mGlobalScale);                windowFrames.mParentFrame.scale(mGlobalScale);            &#125;        &#125; else &#123;            //将clientWindowFrames.parentFrame的值设置为windowFrames.mParentFrame。            //将clientWindowFrames.displayFrame的值设置为windowFrames.mDisplayFrame。            //将clientWindowFrames.frame的值设置为windowFrames.mFrame。            windowFrames.mDisplayFrame.set(clientWindowFrames.displayFrame);            windowFrames.mParentFrame.set(clientWindowFrames.parentFrame);            windowFrames.mFrame.set(clientWindowFrames.frame);            //将clientWindowFrames.frame的值设置为windowFrames.mCompatFrame。            windowFrames.mCompatFrame.set(windowFrames.mFrame);            if (hasCompatScale()) &#123;                // Also, the scaled frame that we report to the app needs to be adjusted to be in                // its coordinate space.                //仅对windowFrames.mCompatFrame缩放                windowFrames.mCompatFrame.scale(mInvGlobalScale);            &#125;        &#125;        //isParentFrameClippedByDisplayCutout是一个Boolean        //如果为true，表示父窗口的边界被显示切边裁剪了；如果为false，表示父窗口的边界没有被显示切边裁剪。        windowFrames.setParentFrameWasClippedByDisplayCutout(                clientWindowFrames.isParentFrameClippedByDisplayCutout);        // Calculate relative frame        //将mRelFrame设置为与mFrame相同的值。这意味着mRelFrame现在存储了与mFrame相同的位置和尺寸信息。        windowFrames.mRelFrame.set(windowFrames.mFrame);        //获取当前窗口的父容器        WindowContainer&lt;?&gt; parent = getParent();        //初始化parentLeft和parentTop为0，表示父容器的左上角坐标        int parentLeft = 0;        int parentTop = 0;         if (mIsChildWindow) &#123;//如果当前窗口是一个子窗口            //从父窗口的状态中获取其边界的位置信息。            parentLeft = ((WindowState) parent).mWindowFrames.mFrame.left;            parentTop = ((WindowState) parent).mWindowFrames.mFrame.top;        &#125; else if (parent != null) &#123;//如果当前窗口不是子窗口，并且父容器不为空            //获取父容器的边界位置            final Rect parentBounds = parent.getBounds();            parentLeft = parentBounds.left;            parentTop = parentBounds.top;        &#125;        //调整mRelFrame的位置，使其相对于父容器的左上角有一个偏移        windowFrames.mRelFrame.offsetTo(windowFrames.mFrame.left - parentLeft,                windowFrames.mFrame.top - parentTop);        //如果请求的宽度、高度或者父框架与上次不同        if (requestedWidth != mLastRequestedWidth || requestedHeight != mLastRequestedHeight                || !mTmpRect.equals(windowFrames.mParentFrame)) &#123;            //更新最后请求的宽度和高度，并标记内容已更改            mLastRequestedWidth = requestedWidth;            mLastRequestedHeight = requestedHeight;            windowFrames.setContentChanged(true);        &#125;        //如果窗口的类型是TYPE_DOCK_DIVIDER，并且边界的位置发生了变化，mMovedByResize标记为true。        //在分屏的场合，YPE_DOCK_DIVIDER窗口类型用于绘制这个分隔栏，并处理用户的触摸事件以实现大小调整功能。        if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;            if (!windowFrames.mFrame.equals(windowFrames.mLastFrame)) &#123;                mMovedByResize = true;            &#125;        &#125;                //如果当前窗口是壁纸，并且框架的宽度或高度发生了变化，更新壁纸的位置。        if (mIsWallpaper) &#123;            final Rect lastFrame = windowFrames.mLastFrame;            final Rect frame = windowFrames.mFrame;            if (lastFrame.width() != frame.width() || lastFrame.height() != frame.height()) &#123;                mDisplayContent.mWallpaperController.updateWallpaperOffset(this, false /* sync */);            &#125;        &#125;                //更新windowFrames.mFrame        updateSourceFrame(windowFrames.mFrame);        //如果定义了LOCAL_LAYOUT，并且还没有边界，更新最后边界的位置。        if (LOCAL_LAYOUT) &#123;            if (!mHaveFrame) &#123;                // The first frame should not be considered as moved.                updateLastFrames();            &#125;        &#125;                //如果存在活动记录，并且当前窗口不是子窗口        if (mActivityRecord != null &amp;&amp; !mIsChildWindow) &#123;            //调用mActivityRecord.layoutLetterbox(this);来填充空白区域。也就是Letterbox模式            mActivityRecord.layoutLetterbox(this);        &#125;        //设置mSurfacePlacementNeeded为true。        mSurfacePlacementNeeded = true;        //设置mHaveFrame为true，表示已经设置了边界        mHaveFrame = true;    &#125;</code></pre><p>其中WindowFrames 是一个表示窗口边框大小和位置的类。<br>WindowFrames 中有一些重要成员变量，用于描述不同的窗口区域。</p><p><code>mFrame</code>表示窗口在屏幕上的位置和大小，是窗口管理和界面绘制的基础依据。<br><code>mVisibleFrame</code>表示窗口可见区域的位置和大小，即除去状态栏和导航栏等系统 UI 元素后，窗口实际可以显示的区域。<br><code>mDecorFrame</code>表示窗口装饰区域的位置和大小，即窗口除去实际内容区域外，包含的标题栏、边框、按钮等 UI 元素所占用的空间。<br><code>mDisplayFrame</code>表示整个屏幕的可见区域的位置和大小，也就是说它包含了状态栏和导航栏等系统 UI 元素。</p><p>这些成员变量共同描述了窗口在屏幕中的位置和大小，并提供给其他模块使用，比如 WindowManager 和 View 系统。<br>在 Android Framework 中，WindowManagerService 会在每次窗口大小发生变化时，调用 WindowFrames 的 setFrames() 方法，更新这些成员变量的值。</p><h4 id="2-3-窗口状态刷新"><a href="#2-3-窗口状态刷新" class="headerlink" title="2.3 窗口状态刷新"></a>2.3 窗口状态刷新</h4><p>当应用端执行measure-layout-draw之后，便会调用<strong>WindowManagerService.finishDrawingWindow</strong>，处理Surface的状态变更并将Surface show出来。<br>首先还是看一下该阶段的流程图，对整个流程有个初步的了解。<br>将整个流程分为三部分：<br>1.WMS接受客户端请求，将mDrawState更新为COMMIT_DRAW_PENDING，并请求窗口布局。<br>2.mDrawState更新为HAS_DRAW，再次请求窗口布局。<br>3.执行show Surface。</p><h5 id="2-3-1-接受客户端请求"><a href="#2-3-1-接受客户端请求" class="headerlink" title="2.3.1 接受客户端请求"></a>2.3.1 接受客户端请求</h5><p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</p><pre><code>    @Override    public void finishDrawing(IWindow window,            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;        if (DEBUG) Slog.v(TAG_WM, &quot;IWindow finishDrawing called for &quot; + window);        //调用WMS中的finishDrawingWindow处理        mService.finishDrawingWindow(this, window, postDrawTransaction, seqId);    &#125;</code></pre><h5 id="2-3-2-finishDrawingWindow"><a href="#2-3-2-finishDrawingWindow" class="headerlink" title="2.3.2 finishDrawingWindow"></a>2.3.2 finishDrawingWindow</h5><p>1.在WMS中根据客户端的Binder在mWindowMap中获取对应的WindowState。<br>2.调用WindowState.finishDrawing执行mDrawState的状态变更。<br>3.将WindowState.mLayoutNeeded标志位置为true。<br>4.请求进行布局刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p><pre><code>    void finishDrawingWindow(Session session, IWindow client,            @Nullable SurfaceControl.Transaction postDrawTransaction, int seqId) &#123;        if (postDrawTransaction != null) &#123;            postDrawTransaction.sanitize();        &#125;        final long origId = Binder.clearCallingIdentity();        try &#123;            synchronized (mGlobalLock) &#123;                /*1.根据客户端的Binder在mWindowMap中获取对应的WindowState*/                WindowState win = windowForClientLocked(session, client, false);                ProtoLog.d(WM_DEBUG_ADD_REMOVE, &quot;finishDrawingWindow: %s mDrawState=%s&quot;,                        win, (win != null ? win.mWinAnimator.drawStateToString() : &quot;null&quot;));                /*2.finishDrawing执行mDrawState的状态更变*/                if (win != null &amp;&amp; win.finishDrawing(postDrawTransaction, seqId)) &#123;                    if (win.hasWallpaper()) &#123;                        win.getDisplayContent().pendingLayoutChanges |=                                WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;                    &#125;                    /*3.将当前WindowState.mLayoutNeeded置为true*/                    //该标志位是判断是否进行窗口大小尺寸计算的条件之一                    win.setDisplayLayoutNeeded();                    /*4.请求进行布局刷新*/                    mWindowPlacerLocked.requestTraversal();                &#125;            &#125;        &#125; finally &#123;            Binder.restoreCallingIdentity(origId);        &#125;    &#125;</code></pre><h6 id="1-mDrawState的状态更变"><a href="#1-mDrawState的状态更变" class="headerlink" title="1.mDrawState的状态更变"></a>1.mDrawState的状态更变</h6><p>在finishDrawingWindow中调用WindowState的finishDrawing方法<br><code>win.finishDrawing(postDrawTransaction, seqId)</code><br>这个方法主要调用了WindowStateAnimator的finishDrawingLocked进行状态更变<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p><pre><code>   boolean finishDrawing(SurfaceControl.Transaction postDrawTransaction, int syncSeqId) &#123;           ......           //调用WindowStateAnimator.finishDrawingLocked，会将mDrawState的状态更改为COMMIT_DRAW_PENDING        final boolean layoutNeeded =                mWinAnimator.finishDrawingLocked(postDrawTransaction, mClientWasDrawingForSync);        mClientWasDrawingForSync = false;        // We always want to force a traversal after a finish draw for blast sync.        return !skipLayout &amp;&amp; (hasSyncHandlers || layoutNeeded);    &#125;</code></pre><p>我们继续看看WindowStateAnimator中的finishDrawingLocked()方法<br>首先判断mDrawState的状态是否为DRAW_PENDING，在我们创建SurfaceControl时，会将mDrawState状态更新为DRAW_PENDING。因此接下来将状态调整为COMMIT_DRAW_PENDING。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p><pre><code>    boolean finishDrawingLocked(SurfaceControl.Transaction postDrawTransaction,            boolean forceApplyNow) &#123;        ......        boolean layoutNeeded = false;        if (mDrawState == DRAW_PENDING) &#123;            ......            //如果当前状态为DRAW_PENDING，则将mDrawState更变为COMMIT_DRAW_PENDING            mDrawState = COMMIT_DRAW_PENDING;            layoutNeeded = true;        &#125;        ......        return layoutNeeded;    &#125;</code></pre><h6 id="2-请求布局刷新"><a href="#2-请求布局刷新" class="headerlink" title="2.请求布局刷新"></a>2.请求布局刷新</h6><p>在finishDrawingWindow中请求布局刷新<br><code>mWindowPlacerLocked.requestTraversal();</code><br>requestTraversal中主要做了两件事：<br>1.首先将遍历标志为mTraversalSchedule置为true。<br>2.其次发送handle消息mPerformSurfacePlacement</p><pre><code>    void requestTraversal() &#123;        //判断遍历标志mTraversalScheduled是否为true        if (mTraversalScheduled) &#123;            return;        &#125;        // Set as scheduled even the request will be deferred because mDeferredRequests is also        // increased, then the end of deferring will perform the request.        //将遍历标志位置为true        mTraversalScheduled = true;        if (mDeferDepth &gt; 0) &#123;            mDeferredRequests++;            if (DEBUG) Slog.i(TAG, &quot;Defer requestTraversal &quot; + Debug.getCallers(3));            return;        &#125;        //发送handle消息，处理消息会调用mPerformSurfacePlacement        mService.mAnimationHandler.post(mPerformSurfacePlacement);    &#125;</code></pre><p>mPerformSurfacePlacement会新建一个线程调用performSurfacePlacement。<br>performSurfacePlacement方法我们在讲relayoutWindow相关流程的时候讲过，这是执行遍历布局的入口。可以回看下【<strong>2.2.4 计算窗口大小位置中的“1.处理窗口布局循环”</strong>】</p><pre><code>    private class Traverser implements Runnable &#123;        @Override        public void run() &#123;            synchronized (mService.mGlobalLock) &#123;                //调用执行performSurfacePlacement                performSurfacePlacement();            &#125;        &#125;    &#125;    private final Traverser mPerformSurfacePlacement = new Traverser();        final void performSurfacePlacement(boolean force) &#123;        //当mDeferDepth大于0且force为false时，则将延迟布局请求数+1，并直接返回        if (mDeferDepth &gt; 0 &amp;&amp; !force) &#123;            mDeferredRequests++;            return;        &#125;        //将循环的最大次数设置为6次        int loopCount = 6;        do &#123;            //将该标志为设置为false            mTraversalScheduled = false;            //执行窗口布局操作            performSurfacePlacementLoop();            mService.mAnimationHandler.removeCallbacks(mPerformSurfacePlacement);            loopCount--;        //只有当mTraversalScheduled为true且循环次数大于0时，才会再次循环执行布局        &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0);        mService.mRoot.mWallpaperActionPending = false;    &#125;    private void performSurfacePlacementLoop() &#123;        //若当前已经进行布局操作，则无需重复调用直接返回        if (mInLayout) &#123;            ......            return;        &#125;        ......        //将该标志位置为true，表示正在处于布局过程中        mInLayout = true;        ......        try &#123;            /*1.调用RootWindowContainer的performSurfacePlacement()方法对所有窗口执行布局操作*/            mService.mRoot.performSurfacePlacement();            mInLayout = false;            if (mService.mRoot.isLayoutNeeded()) &#123;                /*2.若需要布局，且布局次数小于6次，则需要再次请求布局*/                if (++mLayoutRepeatCount &lt; 6) &#123;                    //该方法中会将mTraversalScheduled标志位设置位true                    requestTraversal();                &#125; else &#123;                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);                    mLayoutRepeatCount = 0;                &#125;            &#125; else &#123;                mLayoutRepeatCount = 0;            &#125;            if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;                mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);                mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);            &#125;        &#125; catch (RuntimeException e) &#123;            mInLayout = false;            Slog.wtf(TAG, &quot;Unhandled exception while laying out windows&quot;, e);        &#125;    &#125;</code></pre><p>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p><pre><code>    void performSurfacePlacement() &#123;        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;performSurfacePlacement&quot;);        try &#123;            //调用performSurfacePlacementNoTrace()            performSurfacePlacementNoTrace();        &#125; finally &#123;            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        &#125;    &#125;    // &quot;Something has changed!  Let&#39;s make it correct now.&quot;    // TODO: Super long method that should be broken down...    void performSurfacePlacementNoTrace() &#123;        ......        /*1.如果有焦点变化，更新焦点*/        if (mWmService.mFocusMayChange) &#123;            mWmService.mFocusMayChange = false;            mWmService.updateFocusedWindowLocked(                    UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/);        &#125;        ......                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applySurfaceChanges&quot;);        //开启事务，获取GlobalTransactionWrapper对象        mWmService.openSurfaceTransaction();        try &#123;            /*2.执行窗口尺寸计算，surface状态变更等操作*/            applySurfaceChangesTransaction();        &#125; catch (RuntimeException e) &#123;            Slog.wtf(TAG, &quot;Unhandled exception in Window Manager&quot;, e);        &#125; finally &#123;            //关闭事务，把事务提交            mWmService.closeSurfaceTransaction(&quot;performLayoutAndPlaceSurfaces&quot;);            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);            if (SHOW_LIGHT_TRANSACTIONS) &#123;                Slog.i(TAG,                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION performLayoutAndPlaceSurfaces&quot;);            &#125;        &#125;        ......        /*3.将Surface状态变更为HAS_DRAWN，触发App触发动画。该过程在“2.3.3mDrawState变更为HAS_DRAW”流程中再详细分析*/        checkAppTransitionReady(surfacePlacer);        ......        /*4.遍历所有DisplayContent，如果壁纸有变化，更新壁纸*/        for (int displayNdx = 0; displayNdx &lt; mChildren.size(); ++displayNdx) &#123;            final DisplayContent displayContent = mChildren.get(displayNdx);            //判断DisplayContent的壁纸是否需要改变            if (displayContent.mWallpaperMayChange) &#123;                ProtoLog.v(WM_DEBUG_WALLPAPER, &quot;Wallpaper may change!  Adjusting&quot;);                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;                if (DEBUG_LAYOUT_REPEATS) &#123;                    surfacePlacer.debugLayoutRepeats(&quot;WallpaperMayChange&quot;,                            displayContent.pendingLayoutChanges);                &#125;            &#125;        &#125;        /*5.在此处理焦点变化*/        if (mWmService.mFocusMayChange) &#123;            mWmService.mFocusMayChange = false;            mWmService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,                    false /*updateInputWindows*/);        &#125;        ......        /*6.如果过程中size或者位置变化，则通知客户端重新relayout*/        handleResizingWindows();        if (mWmService.mDisplayFrozen) &#123;            ProtoLog.v(WM_DEBUG_ORIENTATION,                    &quot;With display frozen, orientationChangeComplete=%b&quot;,                    mOrientationChangeComplete);        &#125;        if (mOrientationChangeComplete) &#123;            if (mWmService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) &#123;                mWmService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;                mWmService.mLastFinishedFreezeSource = mLastWindowFreezeSource;                mWmService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);            &#125;            mWmService.stopFreezingDisplayLocked();        &#125;        // Destroy the surface of any windows that are no longer visible.        /*7.销毁不可见的窗口*/        i = mWmService.mDestroySurface.size();        if (i &gt; 0) &#123;            do &#123;                i--;                WindowState win = mWmService.mDestroySurface.get(i);                win.mDestroying = false;                final DisplayContent displayContent = win.getDisplayContent();                if (displayContent.mInputMethodWindow == win) &#123;                    displayContent.setInputMethodWindowLocked(null);                &#125;                if (displayContent.mWallpaperController.isWallpaperTarget(win)) &#123;                    displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;                &#125;                win.destroySurfaceUnchecked();            &#125; while (i &gt; 0);            mWmService.mDestroySurface.clear();        &#125;        ......    &#125;</code></pre><p>​    </p><p>这里我们主要关注<code>applySurfaceChangesTransaction();</code>和<code>checkAppTransitionReady(surfacePlacer);</code></p><h6 id="窗口位置计算与窗口状态刷新流程不同点"><a href="#窗口位置计算与窗口状态刷新流程不同点" class="headerlink" title="* 窗口位置计算与窗口状态刷新流程不同点"></a>* 窗口位置计算与窗口状态刷新流程不同点</h6><p>可以发现，窗口位置计算流程与窗口状态刷新流程都调用了performSurfacePlacement，两次调用的主要不同点在于：<br>1.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用mApplySurfaceChangesTransaction，处理mDrawState状态。<br>2.窗口状态刷新流程在RootWindowContainer.performSurfacePlacementNoTrace中调用checkAppTransitionReady，处理mDrawState状态变更为HAS_DRAWN，触发Activity过渡动画。<br>3.窗口状态刷新流程在WindowSurfacePlacementLoop.performSurfacePlacementLoop中会调用requestTraversal，请求再次布局。<br>4.窗口状态刷新流程在DisplayContent.applySurfaceChangesTransaction中调用prepareSurfaces()处理处理surface的位置、大小以及显示等。</p><h5 id="2-3-3-mDrawState变更为HAS-DRAW"><a href="#2-3-3-mDrawState变更为HAS-DRAW" class="headerlink" title="2.3.3 mDrawState变更为HAS_DRAW"></a>2.3.3 mDrawState变更为HAS_DRAW</h5><h6 id="1-mApplySurfaceChangesTransaction"><a href="#1-mApplySurfaceChangesTransaction" class="headerlink" title="1.mApplySurfaceChangesTransaction"></a>1.mApplySurfaceChangesTransaction</h6><p>RootWindowContainer的applySurfaceChangesTransaction()方法最终会调用到DisplayContent中调用的applySurfaceChangesTransaction()方法（【2.2.4 计算窗口大小位置】中讲过流程，不再赘述）<br>我们接着该方法中的mApplySurfaceChangesTransaction跟踪。<br><code>forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);</code><br>如果当前WindowState存在surfaceControl，则进入到WindowStateAnimator进行mDrawState的状态更变。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>    private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;        ......        //首先判断当前windowState的是否有surfaceControl        if (w.mHasSurface) &#123;            // Take care of the window being ready to display.            //调用WindowStateAnimator的commitFinishDrawingLocked()方法            final boolean committed = winAnimator.commitFinishDrawingLocked();            ......        &#125;        ......    &#125;;</code></pre><p>继续看看WindowStateAnimator的commitFinishDrawingLocked()方法<br><code>final boolean committed = winAnimator.commitFinishDrawingLocked();</code><br>1.对mDrawState的状态进行过滤，非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回。<br>2.此时我们的mDrawState已经在“<strong>【2.3.2 finishDrawingWindow】</strong>”将状态更新为COMMIT_DRAW_PENDING，因此此处将其变更为READY_TO_SHOW。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p><pre><code>    // This must be called while inside a transaction.    boolean commitFinishDrawingLocked() &#123;        //非COMMIT_DRAW_PENDING和READY_TO_SHOW则直接返回        if (mDrawState != COMMIT_DRAW_PENDING &amp;&amp; mDrawState != READY_TO_SHOW) &#123;            return false;        &#125;        ProtoLog.i(WM_DEBUG_ANIM, &quot;commitFinishDrawingLocked: mDrawState=READY_TO_SHOW %s&quot;,                mSurfaceController);        //将状态更变为READY_TO_SHOW        mDrawState = READY_TO_SHOW;        boolean result = false;        final ActivityRecord activity = mWin.mActivityRecord;        //直接进入到WindowState.performShowLocked()流程的三种情况        //1.如果ActivityRecord为空，这种情况可以理解为不依赖Activity的窗口，比如常见的悬浮窗        //2.或者canShowWindows()为true，这个方法大概是说：只有当所有窗口都已绘制完成，并且没有正在进行父级窗口的应用过渡动画，并且没有非默认颜色的窗口存在时，返回true        //3.或者窗口类型为启动窗口，启动窗口就是StartingWindow，应用启动时出现的窗口，常见的就是Splash screen ，许多应用都会定义自己的SplashActivity        //进入performShowLocked()流程后mDrawState更新HAS_DRAWN        //由于非这三种情况最终也会调用到performShowLocked()，因此下面这种情况我们暂不讨论        if (activity == null || activity.canShowWindows()                || mWin.mAttrs.type == TYPE_APPLICATION_STARTING) &#123;            result = mWin.performShowLocked();        &#125;        return result;    &#125;</code></pre><h6 id="2-checkAppTransitionReady"><a href="#2-checkAppTransitionReady" class="headerlink" title="2.checkAppTransitionReady()"></a>2.checkAppTransitionReady()</h6><p>这里我们继续跟踪RootWindowContainer.performSurfacePlacementNoTrace()方法中的checkAppTransitionReady()方法<br><code>checkAppTransitionReady(surfacePlacer);</code><br>该方法会遍历所有DisplayContent，处理activity的过滤动画，此处我们只有跟踪有关mDrawState状态更变的相关代码<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java</p><pre><code>    private void checkAppTransitionReady(WindowSurfacePlacer surfacePlacer) &#123;        // Trace all displays app transition by Z-order for pending layout change.        for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123;            final DisplayContent curDisplay = mChildren.get(i);            // If we are ready to perform an app transition, check through all of the app tokens            // to be shown and see if they are ready to go.            //检查所有要显示的app token，是否已经准备就绪            if (curDisplay.mAppTransition.isReady()) &#123;                // handleAppTransitionReady may modify curDisplay.pendingLayoutChanges.                curDisplay.mAppTransitionController.handleAppTransitionReady();                if (DEBUG_LAYOUT_REPEATS) &#123;                    surfacePlacer.debugLayoutRepeats(&quot;after handleAppTransitionReady&quot;,                            curDisplay.pendingLayoutChanges);                &#125;            &#125;            ......        &#125;    &#125;</code></pre><p>调用AppTransitionController的handleAppTransitionReady()方法，该方法主要做了以下事情<br>1.处理activity的过渡动画（远程动画）<br>2.分别调用 handleClosingApps以及handleOpeningApps对要关闭的和要打开的Activity进行可见性更新。<br>3.由于activity的可见性变更，将DisplayContent.mLayoutNeeded设置为true，该标志位在DisplayContent.performLayoutNoTrace中用来判断是否对当前DisplayContent下的所有窗口进行刷新。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;AppTransitionController.java</p><pre><code>    /**     * Handle application transition for given display.     */    void handleAppTransitionReady() &#123;        ......        try &#123;            /*1.1应用app transition动画（远程动画）*/            applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,                    voiceInteraction);            /*1.2处理closing activity可见性*/            handleClosingApps();            /*1.3处理opening actvity可见性*/            handleOpeningApps();            ......        &#125; finally &#123;            mService.mSurfaceAnimationRunner.continueStartingAnimations();        &#125;        ......        // This has changed the visibility of windows, so perform        // a new layout to get them all up-to-date.        /*2.由于activity的可见性变更，将DisplayContent.mLayoutNeeded标志位置为true*/        mDisplayContent.setLayoutNeeded();        ......    &#125;</code></pre><p><strong>applyAnimations()</strong><br>基于一组ActivityRecord来应用动画，这些ActivityRecord表示正在进行切换的应用程序。<br><code>applyAnimations(openingAppsForAnimation, closingAppsForAnimation, transit, animLp,voiceInteraction);</code></p><pre><code>    /**     * Apply an app transition animation based on a set of &#123;@link ActivityRecord&#125;     *     * @param openingApps The list of opening apps to which an app transition animation applies.     * @param closingApps The list of closing apps to which an app transition animation applies.     * @param transit The current transition type.     * @param animLp Layout parameters in which an app transition animation runs.     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice     *                         interaction session driving task.     */    private void applyAnimations(ArraySet&lt;ActivityRecord&gt; openingApps,            ArraySet&lt;ActivityRecord&gt; closingApps, @TransitionOldType int transit,            LayoutParams animLp, boolean voiceInteraction) &#123;        //方法检查过渡类型是否未设置，或者打开和关闭的应用程序是否都为空。如果是，则方法直接返回，不执行任何动画。        if (transit == WindowManager.TRANSIT_OLD_UNSET                || (openingApps.isEmpty() &amp;&amp; closingApps.isEmpty())) &#123;            return;        &#125;        //调用getAnimationTargets方法获取打开和关闭的窗口容器（WindowContainer）        final ArraySet&lt;WindowContainer&gt; openingWcs = getAnimationTargets(                openingApps, closingApps, true /* visible */);        final ArraySet&lt;WindowContainer&gt; closingWcs = getAnimationTargets(                openingApps, closingApps, false /* visible */);        //打开和关闭的窗口应用动画。这是通过调重载的applyAnimations方法完成的，传递相应的参数，如动画的目标、过渡类型等。        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,                voiceInteraction);        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,                voiceInteraction);        //如果存在最近任务动画控制器（RecentsAnimationController），则发送任务出现任务        final RecentsAnimationController rac = mService.getRecentsAnimationController();        if (rac != null) &#123;            rac.sendTasksAppeared();        &#125;        //遍历打开和关闭的应用程序，并设置mOverrideTaskTransition为false        for (int i = 0; i &lt; openingApps.size(); ++i) &#123;            openingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;        &#125;        for (int i = 0; i &lt; closingApps.size(); ++i) &#123;            closingApps.valueAtUnchecked(i).mOverrideTaskTransition = false;        &#125;        //如果存在辅助功能控制器（AccessibilityController）且有回调，则调用其onAppWindowTransition方法。        final AccessibilityController accessibilityController =                mDisplayContent.mWmService.mAccessibilityController;        if (accessibilityController.hasCallbacks()) &#123;            accessibilityController.onAppWindowTransition(mDisplayContent.getDisplayId(), transit);        &#125;    &#125;</code></pre><p>入参含义：<br><code>openingApps</code> 和 <code>closingApps</code>: 这两个参数是ActivityRecord类型的数组，分别表示正在打开和关闭的应用程序，即这些ActivityRecord表示正在进行切换的应用程序。<br><code>transit</code>: 这是一个整型参数，表示过渡类型。例如，WindowManager.TRANSIT_OLD_UNSET表示没有特定的过渡类型。<br><code>animLp</code>: 这是一个LayoutParams对象，用于定义窗口的布局参数。<br><code>voiceInteraction</code>: 一个布尔值，表示是否为语音交互。</p><p>总而言之，该方法主要负责处理应用程序窗口的打开和关闭动画。它确保应用程序在切换时有一个平滑的视觉效果，为用户提供更好的体验。最后还与辅助功能服务交互，确保辅助功能用户也能正确地感知应用程序窗口的切换。</p><p>再来说说其中调用的applyAnimations方法部分</p><pre><code>        applyAnimations(openingWcs, openingApps, transit, true /* visible */, animLp,                voiceInteraction);        applyAnimations(closingWcs, closingApps, transit, false /* visible */, animLp,                voiceInteraction);</code></pre><p>调用的是重载的applyAnimations方法</p><pre><code>      /**     * Apply animation to the set of window containers.     *     * @param wcs The list of &#123;@link WindowContainer&#125;s to which an app transition animation applies.     * @param apps The list of &#123;@link ActivityRecord&#125;s being transitioning.     * @param transit The current transition type.     * @param visible &#123;@code true&#125; if the apps becomes visible, &#123;@code false&#125; if the apps becomes     *                invisible.     * @param animLp Layout parameters in which an app transition animation runs.     * @param voiceInteraction &#123;@code true&#125; if one of the apps in this transition belongs to a voice     *                         interaction session driving task.     */    private void applyAnimations(ArraySet&lt;WindowContainer&gt; wcs, ArraySet&lt;ActivityRecord&gt; apps,            @TransitionOldType int transit, boolean visible, LayoutParams animLp,            boolean voiceInteraction) &#123;        //获取窗口容器的数量        final int wcsCount = wcs.size();        //遍历每一个窗口容器        for (int i = 0; i &lt; wcsCount; i++) &#123;            final WindowContainer wc = wcs.valueAt(i);            // If app transition animation target is promoted to higher level, SurfaceAnimator            // triggers WC#onAnimationFinished only on the promoted target. So we need to take care            // of triggering AR#onAnimationFinished on each ActivityRecord which is a part of the            // app transition.            //对于每一个窗口容器，检查正在进行切换的应用程序（apps）中哪些是该窗口容器的后代。            //这些后代应用程序将被添加到一个列表中。            final ArrayList&lt;ActivityRecord&gt; transitioningDescendants = new ArrayList&lt;&gt;();            for (int j = 0; j &lt; apps.size(); ++j) &#123;                final ActivityRecord app = apps.valueAt(j);                if (app.isDescendantOf(wc)) &#123;                    transitioningDescendants.add(app);                &#125;            &#125;            //调用每个窗口容器的applyAnimation方法，传入相应的参数（如动画的布局参数、过渡类型、是否可见等）以及后代应用程序的列表。            wc.applyAnimation(animLp, transit, visible, voiceInteraction, transitioningDescendants);        &#125;    &#125;</code></pre><p>入参含义：<br><code>wcs</code>: 一个WindowContainer对象的集合，这些对象是需要应用动画的窗口容器。<br><code>apps</code>: 一个ActivityRecord对象的集合，这些对象表示正在进行切换的应用程序。<br><code>transit</code>: 当前的过渡类型，例如淡入淡出、滑动等。<br><code>visible</code>: 一个布尔值，表示应用程序是否变为可见。<br><code>animLp</code>: 布局参数，定义了动画运行时的布局。<br><code>voiceInteraction</code>: 一个布尔值，表示是否有语音交互。</p><p>这部分远程动画流程，这里不做重点</p><p><strong>handleClosingApps()</strong><br>该方法中主要的作用就是将所有即将close的activity的mVisible标志设置为false。该标志位在后续prepareSurfaces中是判断是否show surface的条件之一。</p><pre><code>   private void handleClosingApps() &#123;        final ArraySet&lt;ActivityRecord&gt; closingApps = mDisplayContent.mClosingApps;        final int appsCount = closingApps.size();        for (int i = 0; i &lt; appsCount; i++) &#123;            final ActivityRecord app = closingApps.valueAt(i);            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now closing app %s&quot;, app);            //设置activity的可见性，将mVisible设置为false            app.commitVisibility(false /* visible */, false /* performLayout */);            app.updateReportedVisibilityLocked();            // Force the allDrawn flag, because we want to start            // this guy&#39;s animations regardless of whether it&#39;s            // gotten drawn.            //强制将allDrawn设置为true            app.allDrawn = true;            ......        &#125;    &#125;</code></pre><p><strong>handleOpeningApps()</strong><br>该方法与handleClosingApps方法类似,主要处理两件事情：<br>1.将所有即将open的activity的mVisible标志位设置为true.<br>2.调用ActivityRecord.showAllWindowsLocked()，最终会调用到WindowState.performShowLocked() ，处理mDrawState的状态变更</p><pre><code>    private void handleOpeningApps() &#123;        final ArraySet&lt;ActivityRecord&gt; openingApps = mDisplayContent.mOpeningApps;        final int appsCount = openingApps.size();        for (int i = 0; i &lt; appsCount; i++) &#123;            final ActivityRecord app = openingApps.valueAt(i);            ProtoLog.v(WM_DEBUG_APP_TRANSITIONS, &quot;Now opening app %s&quot;, app);            /*1.设置activity的可见性，将mVisible设置为true*/            app.commitVisibility(true /* visible */, false /* performLayout */);            ......            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,                    &quot;&gt;&gt;&gt; OPEN TRANSACTION handleAppTransitionReady()&quot;);            //开启事务            mService.openSurfaceTransaction();            try &#123;                /*2.此方法最终会调用到WindowState.performShowLocked*/                app.showAllWindowsLocked();            &#125; finally &#123;            //关闭事务            mService.closeSurfaceTransaction(&quot;handleAppTransitionReady&quot;);                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,                        &quot;&lt;&lt;&lt; CLOSE TRANSACTION handleAppTransitionReady()&quot;);            &#125;            ......        &#125;    &#125;</code></pre><p><code>app.showAllWindowsLocked();</code>先调用到ActivityRecord的showAllWindowsLocked()<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityRecord.java</p><pre><code>    /**     * This must be called while inside a transaction.     */    void showAllWindowsLocked() &#123;        forAllWindows(windowState -&gt; &#123;            if (DEBUG_VISIBILITY) Slog.v(TAG, &quot;performing show on: &quot; + windowState);            windowState.performShowLocked();        &#125;, false /* traverseTopToBottom */);    &#125;</code></pre><p><code>windowState.performShowLocked();</code>再调用到WindowState的performShowLocked()<br>将mDrawState的状态由READY_TO_SHOW变更为HAS_DRAW<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p><pre><code>    // This must be called while inside a transaction.    boolean performShowLocked() &#123;        ......        //获取WindowStateAnimator.mDrawState        final int drawState = mWinAnimator.mDrawState;        //这里判断（drawState 状态为HAS_DRAWN 或者READY_TO_SHOW）且ActivityRecord不为空        if ((drawState == HAS_DRAWN || drawState == READY_TO_SHOW) &amp;&amp; mActivityRecord != null) &#123;            //窗口类型不为启动窗口            if (mAttrs.type != TYPE_APPLICATION_STARTING) &#123;                mActivityRecord.onFirstWindowDrawn(this);            &#125; else &#123;                mActivityRecord.onStartingWindowDrawn();            &#125;        &#125;        //如果当前mDrawState的状态不为READY_TO_SHOW ，则直接返回        if (mWinAnimator.mDrawState != READY_TO_SHOW || !isReadyForDisplay()) &#123;            return false;        &#125;        ......        //走入窗口动画流程        mWinAnimator.applyEnterAnimationLocked();                // Force the show in the next prepareSurfaceLocked() call.        mWinAnimator.mLastAlpha = -1;        ProtoLog.v(WM_DEBUG_ANIM, &quot;performShowLocked: mDrawState=HAS_DRAWN in %s&quot;, this);        //设置mDrawState的状态为HAS_DRAWN        mWinAnimator.mDrawState = HAS_DRAWN;        mWmService.scheduleAnimationLocked();        ......        return true;    &#125;</code></pre><p>添加窗口时，会调用这个<code>mWinAnimator.applyEnterAnimationLocked();</code>窗口动画的方法，然后调用到<code>applyAnimationLocked()</code>；窗口移除时，会直接调用<code>applyAnimationLocked()</code>显示动画。可参考<a href="https://blog.csdn.net/yimelancholy/article/details/134289284?spm=1001.2014.3001.5502">Android T窗口动画显示和退出流程</a></p><h6 id="3-再次请求布局"><a href="#3-再次请求布局" class="headerlink" title="3.再次请求布局"></a>3.再次请求布局</h6><p>回到WindowSurfacePlacer中通过requestTraversals()，再次请求布局，该方法将mTraversalScheduled标志位设置为true的判断条件有两个：<br>1.遍历所有DisplayContent.mLayoutNeeded标志为是否为true。（由于AppTransitionController.handleAppTransitionReady阶段已经将mLayoutNeeded置为true，因此该条件为真）<br>2.重复布局的次数不能超过6次，该条件也为真。（因为当前还只是第一次布局)<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfacePlacer.java</p><pre><code>    private void performSurfacePlacementLoop() &#123;        ......        try &#123;            ......            /*1.遍历所有DisplayContent.mLayoutNeeded标志位是否为true*/            if (mService.mRoot.isLayoutNeeded()) &#123;                /*2.如果需要布局，且布局次数小于6次，则需要再次请求布局*/                if (++mLayoutRepeatCount &lt; 6) &#123;                    //该方法中会将mTraversalScheduled标志位设置位true                    requestTraversal();                &#125; else &#123;                    Slog.e(TAG, &quot;Performed 6 layouts in a row. Skipping&quot;);                    mLayoutRepeatCount = 0;                &#125;            &#125; else &#123;                mLayoutRepeatCount = 0;            &#125;            ......        &#125; catch (RuntimeException e) &#123;        ......        &#125;    &#125;</code></pre><p>接下来进入<strong>第二次布局循环</strong>，其主要目的是为了show surface</p><h5 id="2-3-4-show-Surface"><a href="#2-3-4-show-Surface" class="headerlink" title="2.3.4 show Surface"></a>2.3.4 show Surface</h5><p>在第二次循环中，我们主要关注DisplayContent中applySurfaceChangesTransaction()方法调用的prepareSurfaces()</p><p>该方法最终会调用到根容器WindowContainer，来遍历所有子容器中的prepareSurfaces。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>    @Override    void prepareSurfaces() &#123;        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;prepareSurfaces&quot;);        try &#123;            //获取事务            final Transaction transaction = getPendingTransaction();            //调用其父类方法            super.prepareSurfaces();            // TODO: Once we totally eliminate global transaction we will pass transaction in here            //       rather than merging to global.            SurfaceControl.mergeToGlobalTransaction(transaction);        &#125; finally &#123;            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);        &#125;    &#125;</code></pre><p>调用其父类方法<code>super.prepareSurfaces();</code><br>DisplayContent的父类为WindowContainer<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowContainer.java</p><pre><code>    void prepareSurfaces() &#123;        // If a leash has been set when the transaction was committed, then the leash reparent has        // been committed.        mCommittedReparentToAnimationLeash = mSurfaceAnimator.hasLeash();        //调用所有子容器中的prepareSurfaces        for (int i = 0; i &lt; mChildren.size(); i++) &#123;            mChildren.get(i).prepareSurfaces();        &#125;    &#125;</code></pre><p><code>mChildren.get(i).prepareSurfaces();</code>在WindowState.prepareSurfaces中，主要做了两方面工作。<br>1.将mWindowFrames中计算出来的left以及top设置surface位置，并调整窗口比例。<br>2.控制surface的可见性，查看WindowStateAnimator.prepareSurfaceLocked<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</p><pre><code>    void prepareSurfaces() &#123;        mIsDimming = false;        applyDims();        //实际调用的是其父类WindowContainer的方法        /*1.最终调用自身的updateSurfacePosition()（自身有重写该方法）计算surface的位置*/        updateSurfacePositionNonOrganized();        // Send information to SurfaceFlinger about the priority of the current window.        updateFrameRateSelectionPriorityIfNeeded();        //更新窗口比例        updateScaleIfNeeded();        /*2.控制surface的可见性，调用WindowStateAnimator的prepareSurfaceLocked()方法*/        mWinAnimator.prepareSurfaceLocked(getSyncTransaction());        super.prepareSurfaces();    &#125;        @Override    @VisibleForTesting    void updateSurfacePosition(Transaction t) &#123;        if (mSurfaceControl == null) &#123;            return;        &#125;        //这段代码首先检查布局是否被延迟（通过 isLayoutDeferred() 方法）        //或者应用是否正在进行布局（通过 isGoneForLayout() 方法）。        //如果满足这些条件并且 mSurfacePlacementNeeded 为 false，则方法返回，不执行后续操作。        //这是因为当布局被延迟或应用正在进行布局时，界面的位置可能不是最新的，因此不执行updateSurfacePosition。        if ((mWmService.mWindowPlacerLocked.isLayoutDeferred() || isGoneForLayout())                &amp;&amp; !mSurfacePlacementNeeded) &#123;            // Since this relies on mWindowFrames, changes made while layout is deferred are            // likely to be invalid. Similarly, if it&#39;s goneForLayout, mWindowFrames may not be            // up-to-date and thus can&#39;t be relied on.            return;        &#125;                //将mSurfacePlacementNeeded设置为false        mSurfacePlacementNeeded = false;        //将mSurfacePosition的left以及top设置mWindowFrames中计算出来的left以及top，并根据parent进行偏移        transformFrameToSurfacePosition(mWindowFrames.mFrame.left, mWindowFrames.mFrame.top,                mSurfacePosition);        //根据壁纸的比例对SurfacePosition进行调整        if (mWallpaperScale != 1f) &#123;            final Rect bounds = getLastReportedBounds();            Matrix matrix = mTmpMatrix;            matrix.setTranslate(mXOffset, mYOffset);            matrix.postScale(mWallpaperScale, mWallpaperScale, bounds.exactCenterX(),                    bounds.exactCenterY());            matrix.getValues(mTmpMatrixArray);            mSurfacePosition.offset(Math.round(mTmpMatrixArray[Matrix.MTRANS_X]),                Math.round(mTmpMatrixArray[Matrix.MTRANS_Y]));        &#125; else &#123;            mSurfacePosition.offset(mXOffset, mYOffset);        &#125;        ......    &#125;</code></pre><p><code>mWinAnimator.prepareSurfaceLocked(getSyncTransaction());</code> 调用WindowStateAnimator的prepareSurfaceLocked()方法，该则真正的处理触发surface show的逻辑。主要分为两部分。<br>1.将计算的alpha应用于当前surface。<br>2.判断是否调用showSurfaceRobustlyLocked将surface show出来。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowStateAnimator.java</p><pre><code>   void prepareSurfaceLocked(SurfaceControl.Transaction t) &#123;        final WindowState w = mWin;        //首先判断是否有SurfaceControl        if (!hasSurface()) &#123;            ......            return;        &#125;        //设置mShowAlpha        computeShownFrameLocked();        //判断parentWindow是否hidden，或者当前窗口是否on-screen        if (w.isParentWindowHidden() || !w.isOnScreen()) &#123;            ......        &#125; else if (mLastAlpha != mShownAlpha                || mLastHidden) &#123;            mLastAlpha = mShownAlpha;            ProtoLog.i(WM_SHOW_TRANSACTIONS,                    &quot;SURFACE controller=%s alpha=%f HScale=%f, VScale=%f: %s&quot;,                    mSurfaceController, mShownAlpha, w.mHScale, w.mVScale, w);            /*1.设置surface的alpha*/            boolean prepared =                mSurfaceController.prepareToShowInTransaction(t, mShownAlpha);            //如果当前状态为HAS_DRAWN            if (prepared &amp;&amp; mDrawState == HAS_DRAWN) &#123;                if (mLastHidden) &#123;                /*2.触发show surface*/                    if (showSurfaceRobustlyLocked(t)) &#123;                        mAnimator.requestRemovalOfReplacedWindows(w);                        //设置mLastHidden为false                        mLastHidden = false;                        .......                    &#125; else &#123;                        w.setOrientationChanging(false);                    &#125;                &#125;            &#125;        &#125; else &#123;            if (mWin.isAnimating(TRANSITION | PARENTS)) &#123;                ProtoLog.v(WM_DEBUG_ANIM, &quot;prepareSurface: No changes in animation for %s&quot;, this);            &#125;        &#125;        ......    &#125;</code></pre><p>从上述代码中可以看出触发showSurfaceRobustlyLocked的判断条件有以下几点：<br>1.w.isParentWindowHidden判断其parent的mHidden是否为true，此时当前窗口没有parent直接返回false<br>2.w.isOnScreen，判断当前窗口是否在屏幕上，如果该窗口mVisible为true或者在不可见之前正在运行动画，判断为在屏幕上。我们在上次布局的AppTransitionController.handleAppTransitionReady阶段将当前窗口的mVisible置为了true，因此w.isOnScreen返回true。<br>3.mLastAlpha !&#x3D; mShownAlpha以及mLastHidden满足其一即可，此处我们分析mLastHidden，该标志位在创建SurfaceControl或者hide surface时会被置为true，因为当前窗口才刚刚被创建，因此mLastHidden为true。<br>经过以上判断可以得出我们顺利触发showSurfaceRobustlyLocked<br>后面通过WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController</p><pre><code>    /**     * Have the surface flinger show a surface, robustly dealing with     * error conditions.  In particular, if there is not enough memory     * to show the surface, then we will try to get rid of other surfaces     * in order to succeed.     *     * @return Returns true if the surface was successfully shown.     */    private boolean showSurfaceRobustlyLocked(SurfaceControl.Transaction t) &#123;        //WindowStateAnimator将show SurfaceControl的请求传递给了WindowSurfaceController        //调用WindowSurfaceController的showRobustly方法        boolean shown = mSurfaceController.showRobustly(t);        //如果没有成功返回false        if (!shown)            return false;        t.merge(mPostDrawTransaction);        return true;    &#125;</code></pre><p>在WindowSurfaceController中，首先判断标志位mSurfaceShown，若为true则直接返回；若为false，则将mSurfaceShown置为true，并调用SurfaceControl.show。至此真正的绘图已经显示出来，但是否真正的被用户看见，还需要看其parent是否被show。<br>代码路径：framework&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowSurfaceController.java</p><pre><code>    boolean showRobustly(SurfaceControl.Transaction t) &#123;        ......        //首先判断surface是否已经shown        if (mSurfaceShown) &#123;            return true;        &#125;        //将mSurfaceShown设置为true        setShown(true);        //调用SurfceControl中的show方法，将surface show出来        t.show(mSurfaceControl);        if (mAnimator.mIsWallpaper) &#123;            EventLog.writeEvent(EventLogTags.WM_WALLPAPER_SURFACE,                    mAnimator.mWin.getDisplayId(), 1 /* request shown */);        &#125;        return true;    &#125;</code></pre><p>从SurfaceControl的创建以及show的流程上看，可以发现WMS是通过WindowSurfaceController对SurfaceControl进行管理的。<br>最后我们看一下SurfaceControl中的show方法<br>代码路径：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;SurfaceControl.java</p><pre><code>        /**         * Request that a given surface and it&#39;s sub-tree be shown.         *         * @param sc The surface to show.         * @return This transaction.         * @hide         */        @UnsupportedAppUsage        public Transaction show(SurfaceControl sc) &#123;            checkPreconditions(sc);            nativeSetFlags(mNativeObject, sc.mNativeObject, 0, SURFACE_HIDDEN);            return this;        &#125;</code></pre><h4 id="2-4-performSurfacePlacement-流程总结"><a href="#2-4-performSurfacePlacement-流程总结" class="headerlink" title="2.4 performSurfacePlacement()流程总结"></a>2.4 performSurfacePlacement()流程总结</h4><p><img src="/../../../../../images/0b16f1c79359438783f3ed8e5f94ce84.png" alt="在这里插入图片描述"><br>在“【<strong>2.2 窗口位置计算</strong>】”以及“【<strong>2.3 窗口状态刷新</strong>】”部分均调用了WindowSurfacePlacer.performSurfacePlacement()，实际上任何窗口属性变化都会触发该方法，但我们在performSurfacePlacement中只关注了窗口位置大小计算以及窗口状态变更的相关流程。此处再对该流程进行简单的梳理。<br>当调用到WindowSurfacePlacer.performSurfacePlacement()时首先会执行“<strong>1</strong>”更新所有窗口的大小以及状态信息，在执行“<strong>2</strong>”处理是否在此调用执行performSurfacePlacement。<br><strong>1.1.1</strong>：主要调用computeFrames，计算窗口的尺寸大小。<br><strong>1.1.2</strong>：主要处理mDrawState的状态变更，在commitFinishDrawingLocked中会将处于DRAW_PENDING状态的mDrawState更新为COMMIT_DRAW_PENDING。<br><strong>1.1.3</strong>：主要根据computerFrames中计算出来的窗口大小来设置Surface的位置，并调用SurfaceControl.show()将窗口show出来。<br><strong>1.2</strong>：将处于COMMIT_DRAW_PENDING状态的mDrawState更新为READY_TO_SHOW，并将DisplayContent.mLayoutNeeded设置为true。在“<strong>2</strong>”中会判断该标志位来处理是否再次调用performSurfacePlacement的操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;4-WMS窗口相关流程&quot;&gt;&lt;a href=&quot;#4-WMS窗口相关流程&quot; class=&quot;headerlink&quot; title=&quot;4.WMS窗口相关流程&quot;&gt;&lt;/a&gt;4.WMS窗口相关流程&lt;/h2&gt;&lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; cl</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="WMSAMS" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"/>
    
    
  </entry>
  
  <entry>
    <title>3.窗口层级_层级结构树添加窗口</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/3.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%AA%97%E5%8F%A3/</id>
    <published>2024-01-15T01:52:21.366Z</published>
    <updated>2024-01-15T01:55:55.747Z</updated>
    
    <content type="html"><![CDATA[<p>尚未添加窗口的<a href="https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">层级结构</a>树，如图<br><img src="/../../../../../images/52bf50fb1c174a14809994182587a19e.png" alt="在这里插入图片描述">DisplayArea层级结构中的每一个DisplayArea，都包含着一个层级值范围，这个层级值范围表明了这个DisplayArea可以容纳哪些类型的窗口。<br>每种窗口类型，都可以通过WindowManagerPolicy.getWindowLayerFromTypeLw方法，返回一个相应的层级值。</p><pre><code>/**     * Returns the layer assignment for the window type. Allows you to control how different     * kinds of windows are ordered on-screen.     *     * @param type The type of window being assigned.     * @param canAddInternalSystemWindow If the owner window associated with the type we are     *        evaluating can add internal system windows. I.e they have     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;     *        can be assigned layers greater than the layer for     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their     *        layers would be lesser.     * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.     */    default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;        return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow,                false /* roundedCornerOverlay */);    &#125;    /**     * Returns the layer assignment for the window type. Allows you to control how different     * kinds of windows are ordered on-screen.     *     * @param type The type of window being assigned.     * @param canAddInternalSystemWindow If the owner window associated with the type we are     *        evaluating can add internal system windows. I.e they have     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;     *        can be assigned layers greater than the layer for     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their     *        layers would be lesser.     * @param roundedCornerOverlay </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;尚未添加窗口的&lt;a href=&quot;https://so.csdn.net/so/search?q=%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020&quot;&gt;层级结构&lt;/a&gt;树，如图&lt;br&gt;&lt;img src=&quot;/</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="WMSAMS" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"/>
    
    
  </entry>
  
  <entry>
    <title>2.窗口层级 _层级结构树的构建</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/2.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/</id>
    <published>2024-01-15T01:50:17.559Z</published>
    <updated>2024-01-15T01:56:03.602Z</updated>
    
    <content type="html"><![CDATA[<p>如何通过dump中的内容找到对应的代码？<br>我们dump窗口层级发现会有很多信息，<code>adb shell dumpsys activity containers</code><br><img src="/../../../../../images/555fb894ede74f2eaa1c225401c5b842.png" alt="在这里插入图片描述">这里我们以其中的DefaultTaskDisplayArea为例</p><p><img src="/../../../../../images/97cd0ef57f694c56ac83261890469dd0.png" alt="在这里插入图片描述">在源码的<a href="https://so.csdn.net/so/search?q=framework&spm=1001.2101.3001.7020">framework</a>目录下查找该字符串，找到对应的代码就可以通过打印堆栈或者搜索代码跟踪的方式找到其调用逻辑</p><pre><code>final TaskDisplayArea defaultTaskDisplayArea =             new TaskDisplayArea(content, wmService,            &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);</code></pre><p>也就是这一句</p><p>当然我们上篇文章也讲到了DisplayContent代表的屏幕的DisplayArea层级结构的根节点，我们可以直接从DisplayContent.java的构造方法出发，追踪其流程</p><h2 id="DisplayContent初始化"><a href="#DisplayContent初始化" class="headerlink" title="DisplayContent初始化"></a>DisplayContent初始化</h2><p>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>/**     * Create new &#123;@link DisplayContent&#125; instance, add itself to the root window container and     * initialize direct children.     * @param display May not be null.     * @param root &#123;@link RootWindowContainer&#125;     */    DisplayContent(Display display, RootWindowContainer root) &#123;        super(root.mWindowManager, &quot;DisplayContent&quot;, FEATURE_ROOT);        ......        final Transaction pendingTransaction = getPendingTransaction();        configureSurfaces(pendingTransaction);        pendingTransaction.apply();        ......    &#125;</code></pre><p>创建新的DisplayContent实例，将其自身添加到根窗口容器并初始化直接子级<br><strong>FEATURE_ROOT，对应DisplayContent，一个屏幕上的根DisplayArea，也就是dump中的Display节点。</strong><br><img src="/../../../../../images/653d5a70093f4f4a8d6938e860f90e5d.png" alt="在这里插入图片描述"></p><p>这里我们主要关注一下<code>configureSurfaces(pendingTransaction);</code></p><pre><code> /**     * Configures the surfaces hierarchy for DisplayContent     * This method always recreates the main surface control but reparents the children     * if they are already created.     * @param transaction as part of which to perform the configuration     */    private void configureSurfaces(Transaction transaction) &#123;        final SurfaceControl.Builder b = mWmService.makeSurfaceBuilder(mSession)                .setOpaque(true)                .setContainerLayer()                .setCallsite(&quot;DisplayContent&quot;);        mSurfaceControl = b.setName(getName()).setContainerLayer().build();        if (mDisplayAreaPolicy == null) &#123;            // Setup the policy and build the display area hierarchy.            // Build the hierarchy only after creating the surface so it is reparented correctly            mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(                    mWmService, this /* content */, this /* root */,                    mImeWindowsContainer);        &#125;        ......           &#125;</code></pre><p>通过DisplayContent来配置图层结构</p><h2 id="DisplayAreaPolicy初始化"><a href="#DisplayAreaPolicy初始化" class="headerlink" title="DisplayAreaPolicy初始化"></a>DisplayAreaPolicy初始化</h2><p>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicy.java</p><pre><code>mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(        mWmService, this /* content */, this /* root */,        mImeWindowsContainer)</code></pre><p>调用DisplayAreaPolicy中的Provider接口instantiate方法，去初始化一个DisplayArea层级结构<br><strong>记住这边传递的参数，后面代码需要结合起来看</strong></p><h3 id="DisplayAreaPolicy-Provider"><a href="#DisplayAreaPolicy-Provider" class="headerlink" title="DisplayAreaPolicy.Provider"></a>DisplayAreaPolicy.Provider</h3><pre><code>    /**     * Provider for &#123;@link DisplayAreaPolicy&#125; instances.     *     * &lt;p&gt;By implementing this interface and overriding the     * &#123;@code config_deviceSpecificDisplayAreaPolicyProvider&#125;, a device-specific implementations     * of &#123;@link DisplayAreaPolicy&#125; can be supplied.     */    public interface Provider &#123;        /**         * Instantiates a new &#123;@link DisplayAreaPolicy&#125;. It should set up the &#123;@link DisplayArea&#125;         * hierarchy.         *         * @see DisplayAreaPolicy#DisplayAreaPolicy         */        DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content,                RootDisplayArea root, DisplayArea.Tokens imeContainer);</code></pre><p>用来实例化一个DisplayAreaPolicy对象，这个对象应该建立起DisplayArea层级结构，实际走到的则是DisplayAreaPolicy.Provider的实现类DisplayAreaPolicy.DefaultProvider.instantiate方法</p><h3 id="DisplayAreaPolicy-DefaultProvider"><a href="#DisplayAreaPolicy-DefaultProvider" class="headerlink" title="DisplayAreaPolicy.DefaultProvider"></a>DisplayAreaPolicy.DefaultProvider</h3><pre><code> /** Provider for platform-default display area policy. */    static final class DefaultProvider implements DisplayAreaPolicy.Provider &#123;        @Override        public DisplayAreaPolicy instantiate(WindowManagerService wmService,                DisplayContent content, RootDisplayArea root,                DisplayArea.Tokens imeContainer) &#123;             //1.创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中            final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,                    &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);            final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();            tdaList.add(defaultTaskDisplayArea);            // Define the features that will be supported under the root of the whole logical            // display. The policy will build the DisplayArea hierarchy based on this.            //2.创建HierarchyBuilder            final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);            // Set the essential containers (even if the display doesn&#39;t support IME).            //3.1添加ImeContainer到HierarchyBuilder            //3.2创建并保存默认TaskDisplayArea到HierarchyBuilder            rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);            if (content.isTrusted()) &#123;                // Only trusted display can have system decorations.                //4.为HierarchyBuilder添加Feature                configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);            &#125;            // Instantiate the policy with the hierarchy defined above. This will create and attach            // all the necessary DisplayAreas to the root.            //5.生成DisplayArea层级结构            return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);        &#125;</code></pre><p>我们先了解下DisplayArea.Tokens的构造方法</p><pre><code>        Tokens(WindowManagerService wms, Type type, String name) &#123;            this(wms, type, name, FEATURE_WINDOW_TOKENS);        &#125;</code></pre><p><strong>FEATURE_WINDOW_TOKENS，容纳非activity窗口的DisplayArea，dump中对应着ImeContainer、WindowToken等</strong><br>这里DefaultProvider实现了这个接口。<br>这个方法主要干了这几件事情：</p><h4 id="1-初始化TaskDisplayArea"><a href="#1-初始化TaskDisplayArea" class="headerlink" title="1.初始化TaskDisplayArea"></a>1.初始化TaskDisplayArea</h4><pre><code>final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,        &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;();tdaList.add(defaultTaskDisplayArea);</code></pre><p><strong>FEATURE_DEFAULT_TASK_CONTAINER，容纳默认Task容器的DisplayArea，dump中正是以“DefaultTaskDisplayArea”命名</strong><br>创建一个名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到List中</p><h4 id="2-创建HierarchyBuilder"><a href="#2-创建HierarchyBuilder" class="headerlink" title="2.创建HierarchyBuilder"></a>2.创建HierarchyBuilder</h4><pre><code>final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);</code></pre><p>HierarchyBuilder是什么？是用来定义在整个逻辑显示的根里面所需的一些Feature<br>HierarchyBuilder是在DisplayAreaPolicyBuilder中定义的<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p><pre><code>    /**     *  Builder to define &#123;@link Feature&#125; and &#123;@link DisplayArea&#125; hierarchy under a     * &#123;@link RootDisplayArea&#125;     */    static class HierarchyBuilder &#123;        private static final int LEAF_TYPE_TASK_CONTAINERS = 1;        private static final int LEAF_TYPE_IME_CONTAINERS = 2;        private static final int LEAF_TYPE_TOKENS = 0;        private final RootDisplayArea mRoot;        private final ArrayList&lt;DisplayAreaPolicyBuilder.Feature&gt; mFeatures = new ArrayList&lt;&gt;();        private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;();        @Nullable        private DisplayArea.Tokens mImeContainer;        HierarchyBuilder(RootDisplayArea root) &#123;            mRoot = root;        &#125;        ......    &#125;</code></pre><p>从代码中我们可以看出，HierarchyBuilder用来构建一个DisplayArea层级结构，该层级结构的根节点<br>其构造方法<code>HierarchyBuilder(RootDisplayArea root)</code>传入的是RootDisplayArea的对象。<br>结合前面的<code>configureSurfaces</code>方法中我们可以发现传入的是DisplayContent，即HierarchyBuilder以DisplayContent对象为根节点，生成一个DisplayArea层级结构。</p><h4 id="3-1添加ImeContainer到HierarchyBuilder"><a href="#3-1添加ImeContainer到HierarchyBuilder" class="headerlink" title="3.1添加ImeContainer到HierarchyBuilder"></a>3.1添加ImeContainer到HierarchyBuilder</h4><pre><code>rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);</code></pre><p>我们先看<code>setImeContainer(imeContainer)</code>部分。其中参数imeContainer是DisplayArea.Tokens的对象。</p><p>在DisplayContent中DisplayAreaPolicy初始化时，传递了一个<strong>mImeWindowsContainer</strong>对应我们这里的<strong>imeContainer</strong>形参，其是在DisplayContent中定义并初始化的<br>代码路径：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java</p><pre><code>    // Contains all IME window containers. Note that the z-ordering of the IME windows will depend    // on the IME target. We mainly have this container grouping so we can keep track of all the IME    // window containers together and move them in-sync if/when needed. We use a subclass of    // WindowContainer which is omitted from screen magnification, as the IME is never magnified.    // TODO(display-area): is &quot;no magnification&quot; in the comment still true?    private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);</code></pre><p>ImeContainer就是输入法的容器，其继承在DisplayContent中DisplayArea.Tokens</p><pre><code>    /**     * Container for IME windows.     *     * This has some special behaviors:     * - layers assignment is ignored except if setNeedsLayer() has been called before (and no     *   layer has been assigned since), to facilitate assigning the layer from the IME target, or     *   fall back if there is no target.     * - the container doesn&#39;t always participate in window traversal, according to     *   &#123;@link #skipImeWindowsDuringTraversal()&#125;     */    private static class ImeContainer extends DisplayArea.Tokens &#123;</code></pre><p>HierarchyBuilder的setImeContainer方法<br>代码路径：frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p><pre><code>        private DisplayArea.Tokens mImeContainer;                /** Sets IME container as a child of this hierarchy root. */        HierarchyBuilder setImeContainer(DisplayArea.Tokens imeContainer) &#123;            mImeContainer = imeContainer;            return this;        &#125;</code></pre><p>从代码中可以看出，就是将<strong>DisplayContent的mImeWindowsContainer</strong>保存到了<strong>HierarchyBuilder的mImeContainer</strong>成员变量中，后续创建DisplayArea层级结构时可以直接拿来使用。</p><h4 id="3-2添加TaskDisplayArea到HierarchyBuilder"><a href="#3-2添加TaskDisplayArea到HierarchyBuilder" class="headerlink" title="3.2添加TaskDisplayArea到HierarchyBuilder"></a>3.2添加TaskDisplayArea到HierarchyBuilder</h4><pre><code>rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);</code></pre><p>这里我们看<code>setTaskDisplayAreas(tdaList)</code>部分，第一步【1.初始化TaskDisplayArea】的时候，就已经把名为“DefaultTaskDisplayArea”的TaskDisplayArea,并将其添加到tdaList中，</p><pre><code>        private final ArrayList&lt;TaskDisplayArea&gt; mTaskDisplayAreas = new ArrayList&lt;&gt;();       /**         * Sets &#123;@link TaskDisplayArea&#125; that are children of this hierarchy root.         * &#123;@link DisplayArea&#125; group must have at least one &#123;@link TaskDisplayArea&#125;.         */        HierarchyBuilder setTaskDisplayAreas(List&lt;TaskDisplayArea&gt; taskDisplayAreas) &#123;            mTaskDisplayAreas.clear();            mTaskDisplayAreas.addAll(taskDisplayAreas);            return this;        &#125;</code></pre><p>虽然TaskDisplayArea是支持嵌套的，并且这里也采用了一个ArrayList来管理TaskDisplayArea，但是目前TaskDisplayArea只在这里被创建，即目前一个DisplayContent只有一个名为“DefaultTaskDisplayArea”的TaskDisplayArea。从dumpsys activity containers 中我们也可以看到,整个文件也只有一个“DefaultTaskDisplayArea”</p><h4 id="4-为HierarchyBuilder添加Feature"><a href="#4-为HierarchyBuilder添加Feature" class="headerlink" title="4.为HierarchyBuilder添加Feature"></a>4.为HierarchyBuilder添加Feature</h4><pre><code>// Only trusted display can have system decorations.configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);</code></pre><p><code>configureTrustedHierarchyBuilder</code>这个方法就在DisplayAreaPolicy.DefaultProvider内部</p><pre><code>private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,                WindowManagerService wmService, DisplayContent content) &#123;            // WindowedMagnification should be on the top so that there is only one surface            // to be magnified.            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,                    FEATURE_WINDOWED_MAGNIFICATION)                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)                    // Make the DA dimmable so that the magnify window also mirrors the dim layer.                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)                    .build());            if (content.isDefaultDisplay) &#123;                // Only default display can have cutout.                // See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked.                rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,                        FEATURE_HIDE_DISPLAY_CUTOUT)                        .all()                        .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,                                TYPE_NOTIFICATION_SHADE)                        .build())                        .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,                                FEATURE_ONE_HANDED)                                .all()                                .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,                                        TYPE_SECURE_SYSTEM_OVERLAY)                                .build());            &#125;            rootHierarchy                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,                            FEATURE_FULLSCREEN_MAGNIFICATION)                            .all()                            .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,                                    TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,                                    TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)                            .build())                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,                            FEATURE_IME_PLACEHOLDER)                            .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)                            .build());        &#125;    &#125;</code></pre><p>从代码中可以看到五大的Feature：WindowedMagnification、HideDisplayCutout、OneHanded、FullscreenMagnification、ImePlaceholder，这些Feature其实也就是我们在dumpsys中看到那些，还有一些关键方法all()、and()、except()、upto()、build()等<br>在我们正式开始聊这个几个Feature添加之前，我们先来看看，Feature是怎么定义的</p><h5 id="4-1-Feature的定义"><a href="#4-1-Feature的定义" class="headerlink" title="4.1 Feature的定义"></a>4.1 Feature的定义</h5><p>从HierarchyBuilder的addFeature方法跟踪发现，Feature是在DisplayAreaPolicyBuilder中定义的</p><pre><code>        HierarchyBuilder addFeature(DisplayAreaPolicyBuilder.Feature feature) &#123;            mFeatures.add(feature);            return this;        &#125;</code></pre><p>Feature的定义<br>代码路径&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayAreaPolicyBuilder.java</p><pre><code>    /**     * A feature that requires &#123;@link DisplayArea DisplayArea(s)&#125;.     */    static class Feature &#123;        private final String mName;        private final int mId;        private final boolean[] mWindowLayers;        private final NewDisplayAreaSupplier mNewDisplayAreaSupplier;        private Feature(String name, int id, boolean[] windowLayers,                NewDisplayAreaSupplier newDisplayAreaSupplier) &#123;            mName = name;            mId = id;            mWindowLayers = windowLayers;            mNewDisplayAreaSupplier = newDisplayAreaSupplier;        &#125;        ......    &#125;</code></pre><p>首先Feature代表的是DisplayArea的一个特征，可以根据Feature来对不同的DisplayArea进行划分。</p><ul><li>mName：这个Feature的名字，如上面的“WindowedMagnification”，“HideDisplayCutout”之类的，后续DisplayArea层级结构建立起来后，每个DisplayArea的名字用的就是当前DisplayArea对应的那个Feature的名字。</li><li>mId：Feature的ID，如上面的FEATURE_WINDOWED_MAGNIFICATION和FEATURE_HIDE_DISPLAY_CUTOUT，虽说是Feature的ID，因为Feature又是DisplayArea的特征</li><li>mWindowLayers：代表了这个DisplayArea可以包含哪些层级对应的窗口</li><li>mNewDisplayAreaSupplier：只是一个接口，内部定义一个create方法。</li></ul><p>关键是其Feature内部定义Builder类以及其build()方法</p><h6 id="Feature-Builder和Feature-Builder-build"><a href="#Feature-Builder和Feature-Builder-build" class="headerlink" title="Feature.Builder和Feature.Builder.build()"></a>Feature.Builder和Feature.Builder.build()</h6><pre><code>static class Builder &#123;            private final WindowManagerPolicy mPolicy;            private final String mName;            private final int mId;            private final boolean[] mLayers;            private NewDisplayAreaSupplier mNewDisplayAreaSupplier = DisplayArea::new;            private boolean mExcludeRoundedCorner = true;            /**             * Builds a new feature that applies to a set of window types as specified by the             * builder methods.             *             * &lt;p&gt;The set of types is updated iteratively in the order of the method invocations.             * For example, &#123;@code all().except(TYPE_STATUS_BAR)&#125; expresses that a feature should             * apply to all types except TYPE_STATUS_BAR.             *             * &lt;p&gt;The builder starts out with the feature not applying to any types.             *             * @param name the name of the feature.             * @param id of the feature. &#123;@see Feature#getId&#125;             */            Builder(WindowManagerPolicy policy, String name, int id) &#123;                mPolicy = policy;                mName = name;                mId = id;                mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1];            &#125;            ......            Feature build() &#123;                if (mExcludeRoundedCorner) &#123;                    // Always put the rounded corner layer to the top most layer.                    mLayers[mPolicy.getMaxWindowLayer()] = false;                &#125;                return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);            &#125;</code></pre><p>通过一套适用于具体的窗口类型构建方法来构建新Feature<br>其中<code>mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1];</code> mPolicy.getMaxWindowLayer()返回的是窗口最大层数。</p><pre><code>    /**     * Returns the max window layer.     * &lt;p&gt;Note that the max window layer should be higher that the maximum value which reported     * by &#123;@link #getWindowLayerFromTypeLw(int, boolean)&#125; to contain rounded corner overlay.&lt;/p&gt;     *     * @see WindowManager.LayoutParams#PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY     */    default int getMaxWindowLayer() &#123;        return 36;    &#125;</code></pre><p>1.代码中最大层数是36，这里+1，则也就是<code>mLayers = new boolean[37]</code>，即窗口层级区间为<code>[0,36]</code><br>2.在看看<code>build()</code>方法中的 <code>mLayers[mPolicy.getMaxWindowLayer()] = false;</code>，则表示<code>mLayers[36]</code> &#x3D; false，即第36层在build时会置为false（注：mExcludeRoundedCorner这个变量的值一直是true，没有改动）<br>3.<code>return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);</code><br>其中<strong>mLayers</strong>对应的就是<strong>Feature中的mWindowLayers</strong>，即<code>mLayers.clone()</code>就是把<strong>Feature.mWindowLayer</strong>的值复制给<strong>Feature.Builder.mLayer</strong>。</p><p>下面我们来说说构建Feature的关键星魂</p><h5 id="4-2-构建Feature的核心方法"><a href="#4-2-构建Feature的核心方法" class="headerlink" title="4.2 构建Feature的核心方法"></a>4.2 构建Feature的核心方法</h5><p>以下代码均在DisplayAreaPolicyBuilder.Feature.Builder中</p><h6 id="Feature-Builder第一星魂：all"><a href="#Feature-Builder第一星魂：all" class="headerlink" title="Feature.Builder第一星魂：all()"></a>Feature.Builder第一星魂：all()</h6><pre><code>        /**         * Set that the feature applies to all window types.         */        Builder all() &#123;            Arrays.fill(mLayers, true);            return this;        &#125;</code></pre><p>将mLayers数组中的所有元素都设置为true，表示当前DisplayArea可以包含所有类型的窗口。<br><strong>简述，all()就是把所有类型窗口置为true（添加）</strong></p><h6 id="Feature-Builder第二星魂：and"><a href="#Feature-Builder第二星魂：and" class="headerlink" title="Feature.Builder第二星魂：and()"></a>Feature.Builder第二星魂：and()</h6><pre><code>        /**         * Set that the feature applies to the given window types.         */        Builder and(int... types) &#123;            for (int i = 0; i &lt; types.length; i++) &#123;                int type = types[i];                set(type, true);            &#125;            return this;        &#125;</code></pre><p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为true，表示该DisplayArea可以包含传入的窗口类型对应的窗口。<br><strong>简述，and就是把你传入的所有参数（窗口类型）置为true（添加）</strong></p><h6 id="Feature-Builder第三星魂：except"><a href="#Feature-Builder第三星魂：except" class="headerlink" title="Feature.Builder第三星魂：except()"></a>Feature.Builder第三星魂：except()</h6><pre><code>        /**         * Set that the feature does not apply to the given window types.         */        Builder except(int... types) &#123;            for (int i = 0; i &lt; types.length; i++) &#123;                int type = types[i];                set(type, false);            &#125;            return this;        &#125;</code></pre><p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的元素设置为false，表示该DisplayArea不再包含传入的窗口类型对应的窗口。<br><strong>简述，except就是你传入的所有参数（窗口类型）置为false（不添加）</strong></p><h6 id="Feature-Builder第四星魂（必点）：upTo"><a href="#Feature-Builder第四星魂（必点）：upTo" class="headerlink" title="Feature.Builder第四星魂（必点）：upTo()"></a>Feature.Builder第四星魂（必点）：upTo()</h6><pre><code>        /**         * Set that the feature applies window types that are layerd at or below the layer of         * the given window type.         */        Builder upTo(int typeInclusive) &#123;            final int max = layerFromType(typeInclusive, false);            for (int i = 0; i &lt; max; i++) &#123;                mLayers[i] = true;            &#125;            set(typeInclusive, true);            return this;        &#125;</code></pre><p>先将传入的窗口类型先转换为对应的层级值，然后将mLayers数组中与该层级值对应的的元素之前的所有元素（包含该元素）设置为true，表示当前DisplayArea可以包含比传入的窗口类型层级值低的所有窗口。<br><strong>简述，upTo把就是[0,typeInclusive]区间内的所有类型窗口置为true（添加）。</strong><br>其中layerFromType方法非常重要，我们一起看看</p><pre><code>            private int layerFromType(int type, boolean internalWindows) &#123;                return mPolicy.getWindowLayerFromTypeLw(type, internalWindows);            &#125;</code></pre><p>调用的了WindowManagerPolicy.getWindowLayerFromTypeLw方法</p><h6 id="WindowManagerPolicy-getWindowLayerFromTypeLw"><a href="#WindowManagerPolicy-getWindowLayerFromTypeLw" class="headerlink" title="WindowManagerPolicy.getWindowLayerFromTypeLw"></a>WindowManagerPolicy.getWindowLayerFromTypeLw</h6><pre><code>  /**     * Returns the layer assignment for the window type. Allows you to control how different     * kinds of windows are ordered on-screen.     *     * @param type The type of window being assigned.     * @param canAddInternalSystemWindow If the owner window associated with the type we are     *        evaluating can add internal system windows. I.e they have     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;     *        can be assigned layers greater than the layer for     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their     *        layers would be lesser.     * @return int An arbitrary integer used to order windows, with lower numbers below higher ones.     */    default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;        return getWindowLayerFromTypeLw(type, canAddInternalSystemWindow,                false /* roundedCornerOverlay */);    &#125;    /**     * Returns the layer assignment for the window type. Allows you to control how different     * kinds of windows are ordered on-screen.     *     * @param type The type of window being assigned.     * @param canAddInternalSystemWindow If the owner window associated with the type we are     *        evaluating can add internal system windows. I.e they have     *        &#123;@link Manifest.permission#INTERNAL_SYSTEM_WINDOW&#125;. If true, alert window     *        types &#123;@link android.view.WindowManager.LayoutParams#isSystemAlertWindowType(int)&#125;     *        can be assigned layers greater than the layer for     *        &#123;@link android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY&#125; Else, their     *        layers would be lesser.     * @param roundedCornerOverlay </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何通过dump中的内容找到对应的代码？&lt;br&gt;我们dump窗口层级发现会有很多信息，&lt;code&gt;adb shell dumpsys activity containers&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/../../../../../images/555fb89</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="WMSAMS" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"/>
    
    
  </entry>
  
  <entry>
    <title>1.窗口层级 _容器类</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/WMSAMS/1.%E7%AA%97%E5%8F%A3%E5%B1%82%E7%BA%A7%20_%E5%AE%B9%E5%99%A8%E7%B1%BB/</id>
    <published>2024-01-15T01:48:10.016Z</published>
    <updated>2024-01-15T01:56:54.248Z</updated>
    
    <content type="html"><![CDATA[<p> 窗口在App端是以PhoneWindow的形式存在，承载了一个Activity的<a href="https://so.csdn.net/so/search?q=View%E5%B1%82&spm=1001.2101.3001.7020">View层</a>级结构。这里我们探讨一下WMS端窗口的形式。<br>可以通过<code>adb shell dumpsys activity containers</code> 来看窗口显示的层级</p><h2 id="窗口容器类-——-WindowContainer类"><a href="#窗口容器类-——-WindowContainer类" class="headerlink" title="窗口容器类 —— WindowContainer类"></a>窗口容器类 —— WindowContainer类</h2><pre><code>/** * Defines common functionality for classes that can hold windows directly or through their * children in a hierarchy form. * The test class is &#123;@link WindowContainerTests&#125; which must be kept up-to-date and ran anytime * changes are made to this class. */class WindowContainer&lt;E extends WindowContainer&gt; extends ConfigurationContainer&lt;E&gt;        implements Comparable&lt;WindowContainer&gt;, Animatable, SurfaceFreezer.Freezable,        InsetsControlTarget &#123;    ......         /**     * The parent of this window container.     * For removing or setting new parent &#123;@link #setParent&#125; should be used, because it also     * performs configuration updates based on new parent&#39;s settings.     */    private WindowContainer&lt;WindowContainer&gt; mParent = null;    ......    // List of children for this window container. List is in z-order as the children appear on    // screen with the top-most window container at the tail of the list.    protected final WindowList&lt;E&gt; mChildren = new WindowList&lt;E&gt;();</code></pre><p>WindowContainer注释中开头就说明了其作用，即给可以直接持有窗口的自己或它的孩子定义了一些公共的方法和属性。<br>WindowContainer定义了能够直接或者间接以层级结构的形式持有窗口的类的通用功能。<br>从类的定义和名称，可以看到WindowContainer是一个容器类，可以容纳WindowContainer及其子类对象。如果另外一个容器类作为WindowState的容器，那么这个容器类需要继承WindowContainer或其子类。</p><p>其中mParent和mChildren，一个代表父节点一个代表子节点，而且子节点的list顺序代表就是z轴的层级显示顺序，list尾巴在比list的头的z轴层级要高。<br>1）mParent是WindowContainer类型成员变量，保存的是当前WindowContainer的父容器的引用。<br>2）mChildren是WindowList类型的成员变量，保存的则是当前WindowContainer持有的所有子容器。并且列表的顺序也就是子容器出现在屏幕上的顺序，最顶层的子容器位于队尾。</p><h2 id="根窗口容器-——-RootWindowContainer"><a href="#根窗口容器-——-RootWindowContainer" class="headerlink" title="根窗口容器 —— RootWindowContainer"></a>根窗口容器 —— RootWindowContainer</h2><pre><code>/** Root &#123;@link WindowContainer&#125; for the device. */public class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt;</code></pre><p>根窗口容器，树的根是它。通过它遍历寻找，可以找到窗口树上的窗口。它的孩子是DisplayContent。</p><h2 id="屏幕-——-DisplayContent"><a href="#屏幕-——-DisplayContent" class="headerlink" title="屏幕 —— DisplayContent"></a>屏幕 —— DisplayContent</h2><pre><code>/** * Utility class for keeping track of the WindowStates and other pertinent contents of a * particular Display. */class DisplayContent extends RootDisplayArea implements WindowManagerPolicy.DisplayContentInfo &#123;</code></pre><p>该类是对应着显示屏幕的，Android是支持多屏幕的，所以可能存在多个DisplayContent对象。上图只画了一个对象的结构，其他对象的结构也是和画的对象的结构是相似的。</p><hr><p>RootWindowContainer代表dumpsys containers中<code>ROOT</code> ，DisplayContentdumpsys containers中<code>Display</code>，0表示当前显示的屏幕<br><img src="/../../../../../images/00ddc5bdfa14495ab9c20a27c55b16d0.png" alt="在这里插入图片描述"></p><hr><h2 id="窗口-——-WindowState类"><a href="#窗口-——-WindowState类" class="headerlink" title="窗口 —— WindowState类"></a>窗口 —— WindowState类</h2><pre><code>/** A window in the window manager. */class WindowState extends WindowContainer&lt;WindowState&gt; implements WindowManagerPolicy.WindowState,        InsetsControlTarget, InputTarget &#123;</code></pre><p>在<a href="https://so.csdn.net/so/search?q=WMS&spm=1001.2101.3001.7020">WMS</a>窗口体系中，<strong>一个WindowState对象就代表了一个窗口</strong>，其继承WindowContainer，这就说明<strong>WindowState同样可以作为其他窗口的父容器</strong>，例如我们常见的PopupWindow<br><img src="/../../../../../images/5c82982f2b99427db095ee1ec5f3ccac.png" alt="在这里插入图片描述"></p><h2 id="WindowState的容器"><a href="#WindowState的容器" class="headerlink" title="WindowState的容器"></a>WindowState的容器</h2><p>可直接持有WindowState的容器即WindowToken和ActivityRecord，WallpaperWindowToken也可以持有WindowState，而其是继承WindowToken的</p><h3 id="WindowToken类"><a href="#WindowToken类" class="headerlink" title="WindowToken类"></a>WindowToken类</h3><pre><code>/** * Container of a set of related windows in the window manager. Often this is an AppWindowToken, * which is the handle for an Activity that it uses to display windows. For nested windows, there is * a WindowToken created for the parent window to manage its children. */class WindowToken extends WindowContainer&lt;WindowState&gt; &#123;</code></pre><p>这个注释的意思大概是说：窗口管理器中一组相关窗口的容器。这通常是一个AppWindowToken，它是用于显示窗口的“活动”的句柄。对于嵌套窗口，会为父窗口创建一个WindowToken来管理其子窗口。<br>总而言之就是用WindowToken来管理WindowState<br><img src="/../../../../../images/6d37fa0437ed4007824c795d34425adf.png" alt="在这里插入图片描述"></p><h3 id="WallpaperWindowToken类"><a href="#WallpaperWindowToken类" class="headerlink" title="WallpaperWindowToken类"></a>WallpaperWindowToken类</h3><pre><code>/** * A token that represents a set of wallpaper windows. */class WallpaperWindowToken extends WindowToken &#123;</code></pre><p>WallpaperWindowToken继承WindowToken，是用来存放和Wallpaper相关的窗口。<br><img src="/../../../../../images/d149ce4f628f4a1daef28b9fa64d2c47.png" alt="在这里插入图片描述"></p><h3 id="ActivityRecord类"><a href="#ActivityRecord类" class="headerlink" title="ActivityRecord类"></a>ActivityRecord类</h3><pre><code>/** * An entry in the history task, representing an activity. */public final class ActivityRecord extends WindowToken implements WindowManagerService.AppFreezeListener &#123;</code></pre><p>ActivityRecord是WindowToken的子类，在WMS中<strong>一个ActivityRecord对象就代表一个Activity对象</strong>。</p><p><img src="/../../../../../images/34b57f50600048a09e562f6a1f6a5c64.png" alt="在这里插入图片描述"></p><hr><p>一般来说，一个窗口的父容器是WindowToken还是ActivityRecord，是否主动使用ViewManager.addView来添加一个窗口<br>父容器为WindowToken的情况：APP（含系统应用）主动调用添加窗口方法来添加窗口，如StatusBar、浮窗等。即非Activity窗口<br>父容器为ActivityRecord的情况：系统侧调用添加窗口方法来添加窗口，如在桌面启动一个应用等。即Activity窗口</p><p>从层级角度将窗口划分为：<br>App之上的窗口，父容器为WindowToken，如StatusBar和NavigationBar。<br>App窗口，父容器为ActivityRecord，如Launcher。<br>App之下的窗口，父容器为WallpaperWindowToken，如ImageWallpaper窗口</p><hr><h2 id="WindowToken的容器-——-DisplayArea-Tokens"><a href="#WindowToken的容器-——-DisplayArea-Tokens" class="headerlink" title="WindowToken的容器 —— DisplayArea.Tokens"></a>WindowToken的容器 —— DisplayArea.Tokens</h2><pre><code>    /**     * DisplayArea that contains WindowTokens, and orders them according to their type.     */    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;</code></pre><p>包含WindowTokens的容器Tokens，并根据其类型对其进行排序。</p><h2 id="ActivityRecord的容器-——-Task"><a href="#ActivityRecord的容器-——-Task" class="headerlink" title="ActivityRecord的容器 —— Task"></a>ActivityRecord的容器 —— Task</h2><pre><code>/** * &#123;@link Task&#125; is a TaskFragment that can contain a group of activities to perform a certain job. * Activities of the same task affinities usually group in the same &#123;@link Task&#125;. A &#123;@link Task&#125; * can also be an entity that showing in the Recents Screen for a job that user interacted with. * A &#123;@link Task&#125; can also contain other &#123;@link Task&#125;s. */class Task extends TaskFragment &#123;</code></pre><p>Task继承TaskFragment，<strong>它的孩子可以是Task，也可以是ActivityRecord类型</strong>。是一个TaskFragment，它可以包含一组执行特定作业的Activity。具有相同任务相似性的Activity通常在同一任务中分组。任务也可以是显示在用户交互的作业的最近屏幕中的实体。任务还可以包含其他任务。</p><pre><code>/** * A basic container that can be used to contain activities or other &#123;@link TaskFragment&#125;, which * also able to manage the activity lifecycle and updates the visibilities of the activities in it. */class TaskFragment extends WindowContainer&lt;WindowContainer&gt; &#123;</code></pre><p>一个基本容器，可用于包含Activity或其他TaskFragment，它还能够管理Activity生命周期并更新其中活动的可见性。</p><h2 id="Task的容器-——-TaskDisplayArea"><a href="#Task的容器-——-TaskDisplayArea" class="headerlink" title="Task的容器 —— TaskDisplayArea"></a>Task的容器 —— TaskDisplayArea</h2><pre><code>/** * &#123;@link DisplayArea&#125; that represents a section of a screen that contains app window containers. * * The children can be either &#123;@link Task&#125; or &#123;@link TaskDisplayArea&#125;. */final class TaskDisplayArea extends DisplayArea&lt;WindowContainer&gt; &#123;</code></pre><p>TaskDisplayArea，代表了屏幕上一块专门用来存放App窗口的区域。<br>它的子容器可能是Task或者是TaskDisplayArea。</p><hr><p><img src="/../../../../../images/0436a0559b31465ab39915cd84880d30.png" alt="在这里插入图片描述">DefaultTaskDisplay是TaskDisplayArea的别名，在代码中有体现，后面说明<br>从这个dump中我们可以看到TaskDisplayArea下面就是Task，Task下面就是ActivityRecord且有多个，而ActivityRecord下面的a9a1d8b和c4b2818是各自的WindowState</p><hr><h2 id="DisplayArea类"><a href="#DisplayArea类" class="headerlink" title="DisplayArea类"></a>DisplayArea类</h2><pre><code>/** * Container for grouping WindowContainer below DisplayContent. * * DisplayAreas are managed by a &#123;@link DisplayAreaPolicy&#125;, and can override configurations and * can be leashed. * * DisplayAreas can contain nested DisplayAreas. * * DisplayAreas come in three flavors, to ensure that windows have the right Z-Order: * - BELOW_TASKS: Can only contain BELOW_TASK DisplayAreas and WindowTokens that go below tasks. * - ABOVE_TASKS: Can only contain ABOVE_TASK DisplayAreas and WindowTokens that go above tasks. * - ANY: Can contain any kind of DisplayArea, and any kind of WindowToken or the Task container. * * @param &lt;T&gt; type of the children of the DisplayArea. */public class DisplayArea&lt;T extends WindowContainer&gt; extends WindowContainer&lt;T&gt; &#123;</code></pre><p>用于将WindowContainer分组到DisplayContent下方的容器。<br>DisplayArea由｛@link DisplayAreaPolicy｝管理，能够复写<strong>Configuration</strong>和被绑定到<strong>leash</strong>上。<br>DisplayArea可以包含嵌套的DisplayArea。<br>DisplayAreas有三种风格，以确保窗口具有正确的Z顺序：</p><ul><li>BELOW_TASKS:只能包含位于任务下方的BELLOW_TASK显示区域和WindowToken。</li><li>ABOVE_TASKS:只能包含位于任务上方的ABOVE_TASK显示区域和WindowToken。</li><li>ANY：可以包含任何类型的DisplayArea，以及任何类型的WindowToken或Task容器。</li></ul><p>@param＜T＞DisplayArea的子项的类型。</p><p>DisplayArea有三个直接子类，TaskDisplayArea，DisplayArea.Tokens和DisplayArea.Tokens</p><h3 id="Task的容器-——-TaskDisplayArea-1"><a href="#Task的容器-——-TaskDisplayArea-1" class="headerlink" title="Task的容器 —— TaskDisplayArea"></a>Task的容器 —— TaskDisplayArea</h3><pre><code>/** * &#123;@link DisplayArea&#125; that represents a section of a screen that contains app window containers. * * The children can be either &#123;@link Task&#125; or &#123;@link TaskDisplayArea&#125;. */final class TaskDisplayArea extends DisplayArea&lt;WindowContainer&gt; &#123;</code></pre><p>TaskDisplayArea为DisplayContent的孩子，对应着窗口层次的第2层。第2层作为应用层，看它的定义：int APPLICATION_LAYER &#x3D; 2，应用层的窗口是处于第2层。<br>TaskDisplayArea代表了屏幕上的一个包含App类型的WindowContainer的区域。它的子节点可以是Task，或者是TaskDisplayArea。</p><pre><code>public DisplayAreaPolicy instantiate(WindowManagerService wmService,                DisplayContent content, RootDisplayArea root,                DisplayArea.Tokens imeContainer) &#123;        Inject.ResultOne&lt;TaskDisplayArea&gt; result = new Inject.ResultOne&lt;&gt;(new TaskDisplayArea(content, wmService,                    &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER));</code></pre><p>在DisplayAreaPolicy.java中有创建，并更名为<strong>DefaultTaskDisplayArea</strong></p><h3 id="WindowTokens的容器-——-DisplayArea-Tokens"><a href="#WindowTokens的容器-——-DisplayArea-Tokens" class="headerlink" title="WindowTokens的容器 —— DisplayArea.Tokens"></a>WindowTokens的容器 —— DisplayArea.Tokens</h3><pre><code>    /**     * DisplayArea that contains WindowTokens, and orders them according to their type.     */    public static class Tokens extends DisplayArea&lt;WindowToken&gt; &#123;</code></pre><p>Tokens为DisplayArea的内部类，且继承DisplayArea。<br>即Tokens代表专门包含WindowTokens的容器，它的孩子是WindowToken，而WindowToken的孩子则为WindowState对象。WindowState是对应着一个窗口的。</p><h4 id="输入法的容器-——-ImeContainer"><a href="#输入法的容器-——-ImeContainer" class="headerlink" title="输入法的容器 —— ImeContainer"></a>输入法的容器 —— ImeContainer</h4><pre><code>    /**     * Container for IME windows.     *     * This has some special behaviors:     * - layers assignment is ignored except if setNeedsLayer() has been called before (and no     *   layer has been assigned since), to facilitate assigning the layer from the IME target, or     *   fall back if there is no target.     * - the container doesn&#39;t always participate in window traversal, according to     *   &#123;@link #skipImeWindowsDuringTraversal()&#125;     */    private static class ImeContainer extends DisplayArea.Tokens &#123;</code></pre><p>ImeContainer为DisplayContent.java的内部类，且继承DisplayArea.Tokens，即同样是一个WindowToken的容器，它的孩子是WindowToken类型。WindowToken的孩子为WindowState类型，而WindowState类型则对应着输入法窗口。<br><img src="/../../../../../images/de8424323b554406b8f257566a8b5f5e.png" alt="在这里插入图片描述"></p><h3 id="模糊效果-——-DisplayArea-Dimmable"><a href="#模糊效果-——-DisplayArea-Dimmable" class="headerlink" title="模糊效果 —— DisplayArea.Dimmable"></a>模糊效果 —— DisplayArea.Dimmable</h3><pre><code>    /**     * DisplayArea that can be dimmed.     */    static class Dimmable extends DisplayArea&lt;DisplayArea&gt; &#123;        private final Dimmer mDimmer = new Dimmer(this);</code></pre><p>Dimmable也是DisplayArea的内部类，从名字可以看出，这类的DisplayArea可以添加模糊效果，并且Dimmable也是一个DisplayArea类型的DisplayArea容器。<br>可以通过Dimmer对象mDimmer施加模糊效果，模糊图层可以插入到以该Dimmable对象为根节点的层级结构之下的任意两个图层之间。<br>且它有一个直接子类，RootDisplayArea。</p><h4 id="DisplayArea层级结构的根节点-——-RootDisplayArea"><a href="#DisplayArea层级结构的根节点-——-RootDisplayArea" class="headerlink" title="DisplayArea层级结构的根节点 —— RootDisplayArea"></a>DisplayArea层级结构的根节点 —— RootDisplayArea</h4><pre><code>/** * Root of a &#123;@link DisplayArea&#125; hierarchy. It can be either the &#123;@link DisplayContent&#125; as the root * of the whole logical display, or a &#123;@link DisplayAreaGroup&#125; as the root of a partition of the * logical display. */class RootDisplayArea extends DisplayArea.Dimmable &#123;</code></pre><p>｛@link DisplayArea｝层次结构的根。它可以是作为整个逻辑显示的根的{@link DisplayContent}，也可以是作为逻辑显示的分区的根的｛@link DisplayAreaGroup}。<br>即：<br>DisplayContent，作为整个屏幕的DisplayArea层级结构根节点。<br>DisplayAreaGroup，作为屏幕上部分区域对应的DisplayArea层级结构的根节点</p><h5 id="屏幕-——-DisplayContent-1"><a href="#屏幕-——-DisplayContent-1" class="headerlink" title="屏幕 —— DisplayContent"></a>屏幕 —— DisplayContent</h5><pre><code>/** * Utility class for keeping track of the WindowStates and other pertinent contents of a * particular Display. */class DisplayContent extends RootDisplayArea implements WindowManagerPolicy.DisplayContentInfo &#123;</code></pre><p>用于跟踪特定显示器的WindowStates和其他相关内容的实用程序类，总而言之就是代表一个屏幕。<br>隶属于同一个DisplayContent的窗口将会被显示在同一个屏幕中。每一个DisplayContent都对应着唯一ID</p><h5 id="DisplayAreaGroup"><a href="#DisplayAreaGroup" class="headerlink" title="DisplayAreaGroup"></a>DisplayAreaGroup</h5><pre><code>/** The root of a partition of the logical display. */class DisplayAreaGroup extends RootDisplayArea &#123;</code></pre><p>逻辑显示分区的根</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 窗口在App端是以PhoneWindow的形式存在，承载了一个Activity的&lt;a href=&quot;https://so.csdn.net/so/search?q=View%E5%B1%82&amp;spm=1001.2101.3001.7020&quot;&gt;View层&lt;/a&gt;级结构。这里我</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="WMSAMS" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/WMSAMS/"/>
    
    
  </entry>
  
  <entry>
    <title>判断当前应用是否退到后台</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E6%98%AF%E5%90%A6%E9%80%80%E5%88%B0%E5%90%8E%E5%8F%B0/</id>
    <published>2024-01-12T02:10:06.662Z</published>
    <updated>2024-01-12T02:12:05.404Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class MyApp extends MultiDexApplication &#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    @Override</span><br><span class="line">     public void onCreate() &#123;</span><br><span class="line">      initActivityLifecycle();</span><br><span class="line">     &#125;</span><br><span class="line">      private void initActivityLifecycle() &#123;</span><br><span class="line">        registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityCreated(Activity activity, Bundle bundle) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStarted(Activity activity) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityResumed(Activity activity) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityPaused(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStopped(Activity activity) &#123;</span><br><span class="line">                if(count &gt; 0) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                boolean isBackground = isBackground();</span><br><span class="line">                Log.e(&quot;tyl&quot;,&quot;isBackground=&quot;+isBackground);</span><br><span class="line">                if(isBackground)&#123;</span><br><span class="line">                 //app已经切入到后台</span><br><span class="line">                    //System.exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivitySaveInstanceState(Activity activity, Bundle bundle) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityDestroyed(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 判断app是否在后台</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isBackground()&#123;</span><br><span class="line">        if(count &lt;= 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="Android Application" scheme="https://cq_tyl.gitee.io/categories/Android-Application/"/>
    
    <category term="Android工具类" scheme="https://cq_tyl.gitee.io/categories/Android-Application/Android%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>8.点击桌面APP图标，到APP界面显示流程分析(二)</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/8.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C)/</id>
    <published>2024-01-12T01:21:10.250Z</published>
    <updated>2024-01-19T02:31:53.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="八、绘制"><a href="#八、绘制" class="headerlink" title="八、绘制"></a>八、绘制</h3><h4 id="ViewRootImpl-performDraw"><a href="#ViewRootImpl-performDraw" class="headerlink" title="ViewRootImpl.performDraw"></a>ViewRootImpl.performDraw</h4><p>先看CPU绘制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ViewRootImpl.mTraversalRunnable.run()</span><br><span class="line">| doTraversal();</span><br><span class="line">  | performTraversals();</span><br><span class="line">    |relayoutWindow   <span class="comment">//创建surface流程 + sf 创建layer流程</span></span><br><span class="line">|hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface);</span><br><span class="line">|mAttachInfo.mThreadedRenderer.allocateBuffers();<span class="comment">//硬件绘制，预分配内存    </span></span><br><span class="line">    |performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      |mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">// measure 流程</span></span><br><span class="line">    |performLayout(lp, mWidth, mHeight);</span><br><span class="line">      |mView.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight()); <span class="comment">// layout 流程</span></span><br><span class="line">    |mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();<span class="comment">//分发OnGlobalLayout事件</span></span><br><span class="line">    | <span class="type">View</span> <span class="variable">focused</span> <span class="operator">=</span> mView.findFocus();  focused.restoreDefaultFocus(); <span class="comment">//插眼WYF，这块逻辑以后再看</span></span><br><span class="line"><span class="comment">//分发OnPreDraw事件</span></span><br><span class="line">    |<span class="type">boolean</span> <span class="variable">cancelDraw</span> <span class="operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible; <span class="comment">//不拦截的话 cancelDraw = FALSE</span></span><br><span class="line">    |performDraw();</span><br><span class="line">      |Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;draw&quot;</span>);</span><br><span class="line">      |<span class="type">boolean</span> <span class="variable">canUseAsync</span> <span class="operator">=</span> draw(fullRedrawNeeded);</span><br><span class="line">        |   mAttachInfo.mTreeObserver.dispatchOnDraw();<span class="comment">// 分发OnDraw，回调OnDrawListener中的onDraw()方法。</span></span><br><span class="line"><span class="comment">//  硬件绘制</span></span><br><span class="line">        |   isHardwareEnabled()  </span><br><span class="line">          | mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//  如果未开启硬件绘制使用软件绘制：</span></span><br><span class="line">        |   drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)</span><br><span class="line">          |   <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> mSurface.lockCanvas(dirty);</span><br><span class="line"><span class="comment">///frameworks/base/core/java/android/view/Surface.java</span></span><br><span class="line">|--&gt;Canvas <span class="title function_">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span><br><span class="line">            ||<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Canvas</span> <span class="variable">mCanvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompatibleCanvas</span>(); <span class="comment">// 初始化 Canvas.mNativeCanvasWrapper</span></span><br><span class="line">|<span class="comment">// 把 native lock 的Surface地址保存到mLockedObject，这个mLockedObject通常情况和mNativeObject是一个地址</span></span><br><span class="line">            ||mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">              ||<span class="comment">// /frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line">                |   |--&gt;nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span><br><span class="line">                |    |<span class="comment">// 把Java层保存的地址转换为 native Surface</span></span><br><span class="line">                |    |sp&lt;Surface&gt; <span class="title function_">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>);</span><br><span class="line">||ANativeWindow_Buffer buffer;</span><br><span class="line">              ||surface-&gt;lock(&amp;buffer, dirtyRectPtr);  </span><br><span class="line">|--&gt;Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">|<span class="comment">// 1、需要先连接到SurfaceFlinger端的BufferQueueProducer，会返回宽高数据，SurfaceFlinger端的BufferQueueCore也会设置一些属性</span></span><br><span class="line">                            |<span class="comment">// 注释说在调用dequeueBuffer前，必须先调用connect，是传入生产者监听，接收 onBufferReleased 回调。</span></span><br><span class="line">                            |<span class="comment">// 但是软绘，传入的监听是StubProducerListener，onBufferReleased是个空函数</span></span><br><span class="line">|<span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> Surface::connect(NATIVE_WINDOW_API_CPU); </span><br><span class="line">                ||ANativeWindowBuffer* out;  </span><br><span class="line">|<span class="type">int</span> <span class="variable">fenceFd</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">                ||<span class="comment">// 2、调用dequeueBuffer获取 ANativeWindowBuffer 对象 和 fenceFd。 </span></span><br><span class="line">                |  |<span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> dequeueBuffer(&amp;out, &amp;fenceFd);    <span class="comment">// 【进入 dequeueBuffer 章节】</span></span><br><span class="line">                ||<span class="comment">// 3、使用ANativeWindowBuffer创建后台 GraphicBuffer 对象 </span></span><br><span class="line">                |  |sp&lt;GraphicBuffer&gt; <span class="title function_">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out)</span>); <span class="comment">// GraphicBuffer 继承 ANativeWindowBuffer</span></span><br><span class="line">|<span class="comment">// 4、获取前台buffer</span></span><br><span class="line">|const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); </span><br><span class="line">|<span class="comment">// 宽高格式都相同时，可以把前台的buffer的 Region 复制给后台buffer</span></span><br><span class="line">                            |const <span class="type">bool</span> <span class="variable">canCopyBack</span> <span class="operator">=</span> (frontBuffer != nullptr &amp;&amp; backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;...);</span><br><span class="line">|<span class="comment">// 干净区域 = 上一次所重绘的区域减去接下来需要重绘的脏区域newDirtyRegion，</span></span><br><span class="line">                            |   <span class="comment">// copyBlt 把干净的区域从frontBuffer拷贝到backBuffer</span></span><br><span class="line">|<span class="keyword">if</span> (canCopyBack)const Region <span class="title function_">copyback</span><span class="params">(mDirtyRegion.subtract(newDirtyRegion)</span>);copyBlt(...);</span><br><span class="line">|<span class="comment">// 5、锁定 GraphicBuffer，获取buffer地址</span></span><br><span class="line">                            |<span class="keyword">void</span>* vaddr;  <span class="comment">// 这变量会携带图形buffer的地址回来，图形库，其实就是在这个地址上做像素操作 </span></span><br><span class="line">|<span class="comment">//调用 GraphicBufferMapper::lockAsync</span></span><br><span class="line">|backBuffer-&gt;lockAsync(...,newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">|mLockedBuffer = backBuffer; <span class="comment">// 后台buffer变为已经lock的buffer，入队后变为 mPostedBuffer</span></span><br><span class="line">|<span class="comment">// 6、把获取到的这些信息，存储到ANativeWindow_Buffer，函数返回后，会把这对象传给图形库</span></span><br><span class="line">|outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">|outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">|outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">|outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">|outBuffer-&gt;bits   = vaddr;  <span class="comment">// 把图形buffer的地址赋值给 ANativeWindow_Buffer.bits </span></span><br><span class="line">|<span class="comment">//graphics::Canvas.mCanvas = native 层的 SkiaCanvas</span></span><br><span class="line">              ||graphics::Canvas <span class="title function_">canvas</span><span class="params">(env, canvasObj)</span>;</span><br><span class="line">|<span class="comment">// 把图形缓存的地址，宽高格式啊这些，设置进图形库的 SkiaCanvas，有了这些，图形库就专注画图就行了</span></span><br><span class="line">|canvas.setBuffer(&amp;buffer, static_cast&lt;int32_t&gt;(surface-&gt;getBuffersDataSpace()));</span><br><span class="line">                    |sp&lt;Surface&gt; <span class="title function_">lockedSurface</span><span class="params">(surface)</span>;<span class="comment">// 创建新的sp引用</span></span><br><span class="line">|lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);<span class="comment">// 引用加一</span></span><br><span class="line">                    |<span class="keyword">return</span> (jlong) lockedSurface.get();  <span class="comment">// 返回地址，传入Java 层的 mLockedObject</span></span><br><span class="line">            ||<span class="keyword">return</span> mCanvas;</span><br><span class="line">          |mView.draw(canvas);  <span class="comment">//[View的绘制流程]</span></span><br><span class="line">          |surface.unlockCanvasAndPost(canvas);  <span class="comment">// queueBuffer流程起始</span></span><br><span class="line">|<span class="keyword">if</span> (mHwuiContext != <span class="literal">null</span>) mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">|<span class="keyword">else</span> unlockSwCanvasAndPost(canvas);</span><br><span class="line">|nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">|--&gt;nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span><br><span class="line">                            |sp&lt;Surface&gt; <span class="title function_">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>);</span><br><span class="line">                            |graphics::Canvas <span class="title function_">canvas</span><span class="params">(env, canvasObj)</span>;</span><br><span class="line">|canvas.setBuffer(nullptr, ADATASPACE_UNKNOWN);<span class="comment">// detach the canvas from the surface</span></span><br><span class="line">|<span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> surface-&gt;unlockAndPost();</span><br><span class="line">|--&gt;Surface::unlockAndPost()</span><br><span class="line">                                |<span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">|<span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line">|err = queueBuffer(mLockedBuffer.get(), fd);  <span class="comment">// 【进入 queueBuffer 章节】</span></span><br><span class="line">|mPostedBuffer = mLockedBuffer;  <span class="comment">// 把锁定状态的buffer转换为 已经入队的 buffer</span></span><br><span class="line">|mLockedBuffer = nullptr;</span><br></pre></td></tr></table></figure><h4 id="Surface-connect–-gt-BBQBufferQueueProducer-connect"><a href="#Surface-connect–-gt-BBQBufferQueueProducer-connect" class="headerlink" title="Surface.connect–&gt;BBQBufferQueueProducer.connect"></a>Surface.connect–&gt;BBQBufferQueueProducer.connect</h4><ul><li>重点是注册生产者回调</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span>;</span><br><span class="line">|<span class="keyword">if</span> (!mConnectedToCpu) <span class="comment">// 没调用过 connect 时，false</span></span><br><span class="line">    |Surface::<span class="built_in">connect</span>(NATIVE_WINDOW_API_CPU);</span><br><span class="line">|--&gt;Surface::<span class="built_in">connect</span>(<span class="type">int</span> api)</span><br><span class="line">        |<span class="comment">// StubProducerListener 就是个虚假的实现,重载函数都为空函数</span></span><br><span class="line">        |<span class="type">static</span> sp&lt;IProducerListener&gt; listener = <span class="keyword">new</span> <span class="built_in">StubProducerListener</span>();</span><br><span class="line">|<span class="keyword">return</span> <span class="built_in">connect</span>(api, listener);</span><br><span class="line">|--&gt;Surface::<span class="built_in">connect</span>(<span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener)</span><br><span class="line">            |<span class="keyword">return</span> <span class="built_in">connect</span>(api, listener, <span class="literal">false</span>);</span><br><span class="line">|<span class="comment">//参数 reportBufferRemoval = false</span></span><br><span class="line">|--&gt;Surface::<span class="built_in">connect</span>( <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener, <span class="type">bool</span> reportBufferRemoval)</span><br><span class="line">                |IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">                |mReportRemovedBuffers = reportBufferRemoval; <span class="comment">// false</span></span><br><span class="line">|<span class="comment">// mProducerControlledByApp = true; BBQSurface 创建时，传入的是 true</span></span><br><span class="line">|<span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">connect</span>(listener, api, mProducerControlledByApp, &amp;output);</span><br><span class="line">|--&gt;BBQBufferQueueProducer.<span class="built_in">connect</span>(IProducerListener&amp; listener,<span class="type">int</span> api,<span class="type">bool</span> producerControlledByApp QueueBufferOutput* output)</span><br><span class="line">                    |<span class="keyword">return</span> BufferQueueProducer::<span class="built_in">connect</span>(listener, api, producerControlledByApp, output);</span><br><span class="line">|--&gt;BufferQueueProducer::<span class="built_in">connect</span>(IProducerListener&amp; listener,<span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput *output)</span><br><span class="line">                        |mConsumerName = mCore-&gt;mConsumerName;<span class="comment">//mConsumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot;</span></span><br><span class="line">|<span class="comment">// 中间有一段代码，会依据擦混入的参数producerControlledByApp再调整一次 BufferQueueCore的 mFreeSlots mUnusedSlots</span></span><br><span class="line">                        |<span class="comment">// 目前的参数为无效代码，不贴代码了</span></span><br><span class="line">                |       |<span class="keyword">switch</span> (api) &#123;</span><br><span class="line">                                <span class="keyword">case</span> NATIVE_WINDOW_API_EGL:</span><br><span class="line">                        |       <span class="keyword">case</span> NATIVE_WINDOW_API_CPU:</span><br><span class="line">                |               <span class="keyword">case</span> NATIVE_WINDOW_API_MEDIA:</span><br><span class="line">                                <span class="keyword">case</span> NATIVE_WINDOW_API_CAMERA:</span><br><span class="line">                        |        mCore-&gt;mConnectedApi = api;</span><br><span class="line">                                <span class="comment">// 返回给 Surface 的属性</span></span><br><span class="line">                                <span class="comment">// 这些值，在 BLASTBufferQueue.update 把SurfaceContrl的值传到BufferQueueCore，现在又从 BufferQueueCore 传回Surface</span></span><br><span class="line">                |                output-&gt;width = mCore-&gt;mDefaultWidth;</span><br><span class="line">                        |        output-&gt;height = mCore-&gt;mDefaultHeight;</span><br><span class="line">                                <span class="comment">// 用于优化旋转。预旋转</span></span><br><span class="line">                |                output-&gt;transformHint = mCore-&gt;mTransformHintInUse = mCore-&gt;mTransformHint;<span class="comment">//初始化时为 0</span></span><br><span class="line">                                <span class="comment">// 返回当前 处于 QUEUEED 状态的 buffer 数量</span></span><br><span class="line">                        |        output-&gt;numPendingBuffers = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>());</span><br><span class="line">                                output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + <span class="number">1</span>;</span><br><span class="line">                |                output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line">                                output-&gt;maxBufferCount = mCore-&gt;mMaxBufferCount;</span><br><span class="line">                        |<span class="comment">// 【注册生产者回调--onBufferReleased】</span></span><br><span class="line">                        |        mCore-&gt;mConnectedProducerListener = listener;<span class="comment">// CPU绘制传入的 StubProducerListener,没啥用</span></span><br><span class="line">                                <span class="comment">// 用于触发 onBufferReleased 回调, mBufferReleasedCbEnabled 为true的时候才能触发</span></span><br><span class="line">                |                mCore-&gt;mBufferReleasedCbEnabled = listener-&gt;<span class="built_in">needsReleaseNotify</span>(); <span class="comment">// CPU 绘制返回false</span></span><br><span class="line">                        |<span class="comment">// 再刷一遍 BufferQueueCore 的属性，其实这些属性 BufferQueueCore 初始化时设置的也是这些值  </span></span><br><span class="line">                        |mCore-&gt;mConnectedPid = BufferQueueThreadState::<span class="built_in">getCallingPid</span>();</span><br><span class="line">                        |mCore-&gt;mBufferHasBeenQueued = <span class="literal">false</span>;mCore-&gt;mDequeueBufferCannotBlock = <span class="literal">false</span>;</span><br><span class="line">                |       |mCore-&gt;mQueueBufferCanDrop = <span class="literal">false</span>;mCore-&gt;mLegacyBufferDrop = <span class="literal">true</span>;</span><br><span class="line">                        |mCore-&gt;mAllowAllocation = <span class="literal">true</span>;  <span class="comment">// 允许分配内存</span></span><br><span class="line">                |<span class="comment">// 使用请求到的数据，设置 Surface 属性</span></span><br><span class="line">|mDefaultWidth = output.width;mDefaultHeight = output.height;</span><br><span class="line">                |mNextFrameNumber = output.nextFrameNumber;mMaxBufferCount = output.maxBufferCount;</span><br><span class="line">               |mTransformHint = output.transformHint;<span class="comment">// 这只是一个提示，实际的转换可能会有所不同。被用来提高layer的系统性能</span></span><br><span class="line">                |mConsumerRunningBehind = (output.numPendingBuffers &gt;= <span class="number">2</span>);</span><br><span class="line">                |<span class="keyword">if</span> (!err &amp;&amp; api == NATIVE_WINDOW_API_CPU)mConnectedToCpu = <span class="literal">true</span>;  <span class="comment">// CPU绘制</span></span><br><span class="line">                    <span class="keyword">else</span>mDirtyRegion = Region::INVALID_REGION;</span><br></pre></td></tr></table></figure><ul><li>Surface继承 ANativeWindow<ul><li>ANativeWindow 图形库的各种函数</li></ul></li><li>ANativeWindow_Buffer     ANativeWindow_Buffer.bits  存储图形buffer的地址<ul><li>用于 Surface::lock 的参数，用于图形库。</li></ul></li><li>GraphicBuffer  继承 ANativeWindowBuffer<ul><li>封装图形内存分配接口 GraphicBufferMapper GraphicBufferAllocator ，以及进程间传递的序列化接口</li><li>ANativeWindowBuffer<ul><li>typedef  ANativeWindowBufferANativeWindowBuffer_t</li><li>typedef  ANativeWindowBuffer_t    android_native_buffer_t;</li><li>内部有个成员 native_handle_t* handle;  <strong>存储buffer的fd</strong></li></ul></li></ul></li></ul><h4 id="Surface-dequeueBuffer–-gt-BufferQueueProducer-dequeueBuffer"><a href="#Surface-dequeueBuffer–-gt-BufferQueueProducer-dequeueBuffer" class="headerlink" title="Surface.dequeueBuffer–&gt;BufferQueueProducer.dequeueBuffer"></a>Surface.dequeueBuffer–&gt;BufferQueueProducer.dequeueBuffer</h4><p>BBQBufferQueueProducer 没有重载 BufferQueueProducer.dequeueBuffer</p><p>直接调用父类 BufferQueueProducer.dequeueBuffer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span>;</span><br><span class="line">|<span class="keyword">if</span> (!mConnectedToCpu) <span class="comment">// 没调用过 connect 时，false</span></span><br><span class="line">    |Surface::<span class="built_in">connect</span>(NATIVE_WINDOW_API_CPU);</span><br><span class="line">|ANativeWindowBuffer* out; </span><br><span class="line">|<span class="type">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">|<span class="type">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);</span><br><span class="line">|--&gt;Surface::<span class="built_in">dequeueBuffer</span>(<span class="type">android_native_buffer_t</span>** buffer, <span class="type">int</span>* fenceFd);</span><br><span class="line">|   |<span class="built_in">getDequeueBufferInputLocked</span>(&amp;dqInput);</span><br><span class="line">|--&gt;Surface::<span class="built_in">getDequeueBufferInputLocked</span>(IGraphicBufferProducer::DequeueBufferInput* dequeueInput)</span><br><span class="line">        |<span class="comment">// Req 前缀表示 request，用于请求使用的参数，软绘应该全使用的默认值</span></span><br><span class="line">        |dequeueInput-&gt;width = mReqWidth ? mReqWidth : mUserWidth;<span class="comment">// 默认 mReqWidth = mUserWidth = 0</span></span><br><span class="line">|dequeueInput-&gt;height = mReqHeight ? mReqHeight : mUserHeight;<span class="comment">// 默认 mReqHeight = mUserHeight = 0</span></span><br><span class="line">|dequeueInput-&gt;format = mReqFormat;<span class="comment">// 默认 0</span></span><br><span class="line">|dequeueInput-&gt;usage = mReqUsage;<span class="comment">// 默认 0</span></span><br><span class="line">|dequeueInput-&gt;usage = mReqUsage;<span class="comment">// mEnableFrameTimestamps 默认false</span></span><br><span class="line">|dequeueInput-&gt;getTimestamps = mEnableFrameTimestamps;<span class="comment">// mEnableFrameTimestamps 默认false</span></span><br><span class="line">|<span class="type">int</span> buf = <span class="number">-1</span>;</span><br><span class="line">|sp&lt;Fence&gt; fence;</span><br><span class="line">|<span class="type">nsecs_t</span> startTime = <span class="built_in">systemTime</span>();<span class="comment">// 当前时间</span></span><br><span class="line">|FrameEventHistoryDelta frameTimestamps;</span><br><span class="line">|<span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, dqInput.width,dqInput.height, dqInput.format,</span><br><span class="line">                                                                dqInput.usage, &amp;mBufferAge,dqInput.getTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">|--&gt;BufferQueueProducer.<span class="built_in">dequeueBuffer</span>(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, </span><br><span class="line">                                          PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge, FrameEventHistoryDelta* outTimestamps)</span><br><span class="line">        |mConsumerName = mCore-&gt;mConsumerName; <span class="comment">// consumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot;</span></span><br><span class="line">|<span class="comment">//width、height 可以都为0，但是不能一个是0，一个非零。</span></span><br><span class="line">|<span class="keyword">if</span> ((width &amp;&amp; !height) || (!width &amp;&amp; height))<span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">|<span class="keyword">if</span> (mCore-&gt;mFreeBuffers.<span class="built_in">empty</span>() &amp;&amp; mCore-&gt;mIsAllocating)mCore-&gt;<span class="built_in">waitWhileAllocatingLocked</span>(lock);<span class="comment">//正在分配buffer，自旋等待</span></span><br><span class="line">|<span class="keyword">if</span> (format == <span class="number">0</span>)format = mCore-&gt;mDefaultBufferFormat; <span class="comment">// mDefaultBufferFormat = PIXEL_FORMAT_RGBA_8888</span></span><br><span class="line">|<span class="comment">// mConsumerUsageBits 在BLASTBufferItemConsumer构造是赋值为 GraphicBuffer::USAGE_HW_COMPOSER |GraphicBuffer::USAGE_HW_TEXTURE</span></span><br><span class="line">|usage |= mCore-&gt;mConsumerUsageBits</span><br><span class="line">        |<span class="type">const</span> <span class="type">bool</span> useDefaultSize = !width &amp;&amp; !height;<span class="comment">// 宽高都为0，使用默认尺寸</span></span><br><span class="line">|<span class="keyword">if</span> (useDefaultSize)</span><br><span class="line">            |<span class="comment">//默认宽高在 BLASTBufferQueue.update 把SurfaceContrl的宽高值传到BufferQueueCore</span></span><br><span class="line">            |width = mCore-&gt;mDefaultWidth; height = mCore-&gt;mDefaultHeight;</span><br><span class="line">|<span class="keyword">if</span> (mCore-&gt;mAutoPrerotation &amp;&amp; (mCore-&gt;mTransformHintInUse &amp; NATIVE_WINDOW_TRANSFORM_ROT_90))</span><br><span class="line">                |std::<span class="built_in">swap</span>(width, height); <span class="comment">// mAutoPrerotation自动预旋转默认false，mTransformHintInUse 90度时宽高互换</span></span><br><span class="line">|<span class="type">int</span> found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">|<span class="comment">//【获取可用的 BufferSlot 索引】</span></span><br><span class="line">        |   <span class="built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller::Dequeue, lock, &amp;found);</span><br><span class="line">|--&gt;BufferQueueProducer::<span class="built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller caller, std::unique_lock&lt;std::mutex&gt;&amp; lock, <span class="type">int</span>* found)</span><br><span class="line">|<span class="type">bool</span> tryAgain = <span class="literal">true</span>;</span><br><span class="line">|<span class="keyword">while</span> (tryAgain)</span><br><span class="line">    |*found = BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">|<span class="comment">// 首先从list链表 BufferQueueCore-&gt;mFreeBuffers 拿 BufferSlot，如果集合是空的，会返回BufferQueueCore::INVALID_BUFFER_SLOT</span></span><br><span class="line">|<span class="type">int</span> slot = <span class="built_in">getFreeBufferLocked</span>();</span><br><span class="line">|<span class="keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT)</span><br><span class="line">        |*found = slot;</span><br><span class="line">|<span class="keyword">else</span> <span class="keyword">if</span> (mCore-&gt;mAllowAllocation)</span><br><span class="line">|<span class="comment">// mFreeBuffers没有，就从set集合 BufferQueueCore-&gt;mFreeSlots 拿 BufferSlot，如果集合是空的，返回BufferQueueCore::INVALID_BUFFER_SLOT</span></span><br><span class="line">        |*found = <span class="built_in">getFreeSlotLocked</span>();</span><br><span class="line">|tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) || tooManyBuffers;</span><br><span class="line">|<span class="comment">// 没有 buffer了，或者 queue 太多了(这个可能性不大，mFreeSlots 这个set就三个数据，dequeue不出来那么多，queue就更不可能)，</span></span><br><span class="line">    |<span class="keyword">if</span> (tryAgain)</span><br><span class="line">        |<span class="keyword">if</span> (mDequeueTimeout &gt;= <span class="number">0</span>)<span class="comment">//  BBQ 设置的mDequeueTimeout=int64.max</span></span><br><span class="line">            |<span class="comment">// 等待buffer(有可能是buffer被释放了，小概率因为mFreeSlots集合增加了)</span></span><br><span class="line">        |mCore-&gt;mDequeueCondition.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">nanoseconds</span>(mDequeueTimeout));</span><br><span class="line">|<span class="comment">//拿到可用的索引found对应的 BufferSlot 的 GraphicBuffer</span></span><br><span class="line">|<span class="function"><span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span></span>;</span><br><span class="line">|<span class="comment">//【把找到的buffer，插入到set集合 mActiveBuffers 中】</span></span><br><span class="line">|mCore-&gt;mActiveBuffers.<span class="built_in">insert</span>(found);</span><br><span class="line">|<span class="comment">//把索引值返回</span></span><br><span class="line">|*outSlot = found;</span><br><span class="line">|<span class="comment">// 【把找到的 BufferSlot buffer状态转为 dequeue】</span></span><br><span class="line">|mSlots[found].mBufferState.<span class="built_in">dequeue</span>();</span><br><span class="line">|<span class="comment">//找到的 BufferSlot 没有关联GraphicBuffer，或者 GraphicBuffer 宽高，格式、usage、layerCount 和需求不相等的话，需要重新分配</span></span><br><span class="line">        |<span class="keyword">if</span> ((buffer == <span class="literal">nullptr</span>) || buffer-&gt;<span class="built_in">needsReallocation</span>(width, height, format, BQ_LAYER_COUNT, usage))</span><br><span class="line">            |mSlots[found].mAcquireCalled = <span class="literal">false</span>;mSlots[found].mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">|mSlots[found].mRequestBufferCalled = <span class="literal">false</span>;mSlots[found].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">|mSlots[found].mEglFence = EGL_NO_SYNC_KHR;mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">|mCore-&gt;mBufferAge = <span class="number">0</span>;   <span class="comment">// 设置 mBufferAge 为0，新鲜的buffer啊，还没有被queue过</span></span><br><span class="line">|mCore-&gt;mIsAllocating = <span class="literal">true</span>; <span class="comment">// 设置为正在分配内存</span></span><br><span class="line">|<span class="comment">//【 添加 “需要重新分配buffer” flag】</span></span><br><span class="line">|returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">|<span class="keyword">else</span> <span class="comment">// 计算buffer年龄</span></span><br><span class="line">            |<span class="comment">// mBufferAge： [(自从当前的 BufferSlot 上次被 queueBuffer 后，又queue了多少个BufferSlot) + 1]    </span></span><br><span class="line">            |mCore-&gt;mBufferAge = mCore-&gt;mFrameCounter + <span class="number">1</span> - mSlots[found].mFrameNumber;</span><br><span class="line">|<span class="comment">// 非共享内存模式下， 把当前的 buffer Fence ，传到外部参数 outFence</span></span><br><span class="line">|*outFence = (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == found) ? Fence::NO_FENCE : mSlots[found].mFence;</span><br><span class="line">|<span class="comment">// BufferSlot的Fence重新赋值为 NO_FENCE</span></span><br><span class="line">|mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">|mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">|<span class="comment">// 【需要重新分配buffer情况，分配新的buffer】</span></span><br><span class="line">|<span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) </span><br><span class="line">            |<span class="comment">//GraphicBuffer构造函数中调用 GraphicBufferAllocator.allocate 分配图形buffer，并映射内存到当前进程</span></span><br><span class="line">            |sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> <span class="built_in">GraphicBuffer</span>(width, height, format, BQ_LAYER_COUNT, usage,mConsumerName);</span><br><span class="line">|mCore-&gt;mIsAllocating = <span class="literal">false</span>;  <span class="comment">// 分配完了，要重新设置回 false 啊</span></span><br><span class="line">|mCore-&gt;mIsAllocatingCondition.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒那些因为 正在分配buffer 而等待的线程</span></span><br><span class="line">|<span class="comment">// 如果需要等待 eglFence 释放 Fence</span></span><br><span class="line">|<span class="keyword">if</span> (eglFence != EGL_NO_SYNC_KHR)</span><br><span class="line">            |EGLint result = <span class="built_in">eglClientWaitSyncKHR</span>(eglDisplay, eglFence, <span class="number">0</span>,<span class="number">1000000000</span>);<span class="comment">// 等待B</span></span><br><span class="line">|<span class="built_in">eglDestroySyncKHR</span>(eglDisplay, eglFence);</span><br><span class="line">|*outBufferAge = mCore-&gt;mBufferAge; <span class="comment">// buffer年龄传到外部</span></span><br><span class="line">|<span class="built_in">addAndGetFrameTimestamps</span>(<span class="literal">nullptr</span>, outTimestamps);<span class="comment">// BBQ 没有实现这方法，是个空实现。只有 BufferQueue 在消费者进程里，才会被调用。</span></span><br><span class="line">|<span class="keyword">return</span> returnFlags;</span><br><span class="line">|<span class="comment">//继续 Surface::dequeueBuffer</span></span><br><span class="line">|mLastDequeueDuration = <span class="built_in">systemTime</span>() - startTime;<span class="comment">// 计算 dequeue 时间</span></span><br><span class="line">|mLastDequeueStartTime = startTime;<span class="comment">// 记录上次 dequeue 开始时间</span></span><br><span class="line">|<span class="comment">// 根据拿到的 slolt 下标,获取本地Surface自己的 GraphicBuffer</span></span><br><span class="line">|<span class="function">sp&lt;GraphicBuffer&gt;&amp; <span class="title">gbuf</span><span class="params">(mSlots[buf].buffer)</span></span>; </span><br><span class="line">|<span class="keyword">if</span> (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) <span class="built_in">freeAllBuffers</span>();</span><br><span class="line">|<span class="keyword">if</span> (dqInput.getTimestamps)mFrameEventHistory-&gt;<span class="built_in">applyDelta</span>(frameTimestamps);</span><br><span class="line">|<span class="comment">// dequeueBuffer返回值 带有 BUFFER_NEEDS_REALLOCATION 标记，并且 gbuf == nullptr 的时候 进入此分支</span></span><br><span class="line">|<span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="literal">nullptr</span>)</span><br><span class="line">        |<span class="comment">//【请求 GraphicBuffer】</span></span><br><span class="line">        |<span class="comment">// requestBuffer接口很简单，直接返回 dequeueBuffer时关联/创建的 GraphicBuffer对象。</span></span><br><span class="line">        |<span class="comment">// S版本以前，需要跨进程传递GraphicBuffer对象，反序列化时，会调用GraphicBufferMapper.importBuffer映射内存</span></span><br><span class="line">        |result = mGraphicBufferProducer-&gt;<span class="built_in">requestBuffer</span>(buf, &amp;gbuf);</span><br><span class="line">|<span class="keyword">if</span> (fence-&gt;<span class="built_in">isValid</span>()) *fenceFd = fence-&gt;<span class="built_in">dup</span>();</span><br><span class="line">|<span class="comment">// 赋值外部的 android_native_buffer_t** buffer</span></span><br><span class="line">|*buffer = gbuf.<span class="built_in">get</span>();</span><br><span class="line">|<span class="comment">//std::unordered_set&lt;int&gt; mDequeuedSlots;</span></span><br><span class="line">|mDequeuedSlots.<span class="built_in">insert</span>(buf); <span class="comment">// Dequeued 的buffer的 下标 存入 mDequeuedSlots</span></span><br></pre></td></tr></table></figure><h4 id="Surface-queueBuffer"><a href="#Surface-queueBuffer" class="headerlink" title="Surface.queueBuffer"></a>Surface.queueBuffer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">// 前置流程：</span></span><br><span class="line">surface.<span class="built_in">unlockCanvasAndPost</span>(canvas);  <span class="comment">// queueBuffer</span></span><br><span class="line">|<span class="keyword">if</span> (mHwuiContext != null) mHwuiContext.<span class="built_in">unlockAndPost</span>(canvas);</span><br><span class="line">|<span class="keyword">else</span> <span class="built_in">unlockSwCanvasAndPost</span>(canvas);</span><br><span class="line">|<span class="built_in">nativeUnlockCanvasAndPost</span>(mLockedObject, canvas);</span><br><span class="line">|--&gt;<span class="built_in">nativeUnlockCanvasAndPost</span>(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span><br><span class="line">        |<span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line">        |<span class="function">graphics::Canvas <span class="title">canvas</span><span class="params">(env, canvasObj)</span></span>;</span><br><span class="line">|canvas.<span class="built_in">setBuffer</span>(<span class="literal">nullptr</span>, ADATASPACE_UNKNOWN);<span class="comment">// detach the canvas from the surface</span></span><br><span class="line">|<span class="type">status_t</span> err = surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line">|--&gt;Surface::<span class="built_in">unlockAndPost</span>()</span><br><span class="line">    |       |<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">||<span class="type">status_t</span> err = mLockedBuffer-&gt;<span class="built_in">unlockAsync</span>(&amp;fd);</span><br><span class="line">|GraphicBuffer::<span class="built_in">getBufferMapper</span>().<span class="built_in">unlockAsync</span>(handle, fenceFd);</span><br><span class="line">||err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);  <span class="comment">// 进入【queueBuffer 章节】</span></span><br><span class="line">||mPostedBuffer = mLockedBuffer;  <span class="comment">// 把锁定的buffer转换为 已经入队的 buffer</span></span><br><span class="line">||mLockedBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">|<span class="built_in">nativeRelease</span>(mLockedObject);</span><br><span class="line">|mLockedObject = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【queueBuffer 章节】</span></span><br><span class="line">Surface::<span class="built_in">queueBuffer</span>(<span class="type">android_native_buffer_t</span>* buffer, <span class="type">int</span> fenceFd) </span><br><span class="line">|<span class="type">int</span> i = <span class="built_in">getSlotFromBufferLocked</span>(buffer);</span><br><span class="line">|<span class="comment">// 遍历 Surface.mSlots 数组，找到 GraphicBuffer.handle 相同的 BufferSlot 索引</span></span><br><span class="line">|--&gt;Surface::<span class="built_in">getSlotFromBufferLocked</span>(<span class="type">android_native_buffer_t</span>* buffer)</span><br><span class="line">    |<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_BUFFER_SLOTS; i++)</span><br><span class="line">        |<span class="keyword">if</span> (mSlots[i].buffer != <span class="literal">nullptr</span> &amp;&amp; mSlots[i].buffer-&gt;handle == buffer-&gt;handle)</span><br><span class="line">            |<span class="keyword">return</span> i;</span><br><span class="line">|IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">|IGraphicBufferProducer::QueueBufferInput input;</span><br><span class="line">|<span class="comment">/*</span></span><br><span class="line"><span class="comment">Surface.mTimestamp 使用默认的 NATIVE_WINDOW_TIMESTAMP_AUTO 时，</span></span><br><span class="line"><span class="comment">QueueBufferInput.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span></span><br><span class="line"><span class="comment">QueueBufferInput.isAutoTimestamp = true; // 这个参数标明是否在入队时，自动生成时间戳</span></span><br><span class="line"><span class="comment">|*/</span> </span><br><span class="line">|<span class="built_in">getQueueBufferInputLocked</span>(buffer, fenceFd, mTimestamp, &amp;input);</span><br><span class="line">|<span class="comment">// 一些 Gralloc 的元数据 mapper.setDataspace，HdrMetadata 设置</span></span><br><span class="line">|<span class="built_in">applyGrallocMetadataLocked</span>(buffer, input);</span><br><span class="line">|sp&lt;Fence&gt; fence = input.fence;</span><br><span class="line">|<span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>();</span><br><span class="line">|<span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line">|--&gt;BufferQueueProducer::<span class="built_in">queueBuffer</span>(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span><br><span class="line">    |<span class="type">int64_t</span> requestedPresentTimestamp;<span class="type">bool</span> isAutoTimestamp;android_dataspace dataSpace;</span><br><span class="line">|<span class="function">Rect <span class="title">crop</span><span class="params">(Rect::EMPTY_RECT)</span></span>;<span class="type">int</span> scalingMode;<span class="type">uint32_t</span> transform;</span><br><span class="line">|<span class="type">uint32_t</span> stickyTransform;sp&lt;Fence&gt; acquireFence;<span class="type">bool</span> getFrameTimestamps = <span class="literal">false</span>;</span><br><span class="line">|<span class="comment">// 读取输入参数的数据</span></span><br><span class="line">|input.<span class="built_in">deflate</span>(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace,</span><br><span class="line">                      &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform, &amp;getFrameTimestamps);</span><br><span class="line">|<span class="type">const</span> Region&amp; surfaceDamage = input.<span class="built_in">getSurfaceDamage</span>();</span><br><span class="line">|<span class="type">const</span> HdrMetadata&amp; hdrMetadata = input.<span class="built_in">getHdrMetadata</span>();</span><br><span class="line">|sp&lt;IConsumerListener&gt; frameAvailableListener;<span class="comment">// buffer 可用通知</span></span><br><span class="line">|sp&lt;IConsumerListener&gt; frameReplacedListener;<span class="comment">//buffer被替换通知</span></span><br><span class="line">|BufferItem item; <span class="comment">// 创建 BufferItem</span></span><br><span class="line">|<span class="comment">// 拿到 slot 对应的 GraphicBuffer </span></span><br><span class="line">|<span class="function"><span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">graphicBuffer</span><span class="params">(mSlots[slot].mGraphicBuffer)</span></span>;</span><br><span class="line">|<span class="comment">// 裁剪区域</span></span><br><span class="line">|<span class="function">Rect <span class="title">bufferRect</span><span class="params">(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight())</span></span>;</span><br><span class="line">|<span class="function">Rect <span class="title">croppedRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">|<span class="comment">// crop 和 bufferRect 的交集，结果存入  croppedRect</span></span><br><span class="line">|crop.<span class="built_in">intersect</span>(bufferRect, &amp;croppedRect);</span><br><span class="line">|mSlots[slot].mFence = acquireFence;</span><br><span class="line">|<span class="comment">//【设置为 QUEUED 状态】</span></span><br><span class="line">|mSlots[slot].mBufferState.<span class="built_in">queue</span>();</span><br><span class="line">|++mCore-&gt;mFrameCounter;<span class="comment">// 每次 queueBuffer 都+1</span></span><br><span class="line">|currentFrameNumber = mCore-&gt;mFrameCounter;</span><br><span class="line">|mSlots[slot].mFrameNumber = currentFrameNumber;<span class="comment">//存储当前BufferSlot的帧号</span></span><br><span class="line">|<span class="comment">// 封装 BufferItem 信息</span></span><br><span class="line">    |item.mAcquireCalled = mSlots[slot].mAcquireCalled;</span><br><span class="line">|item.mGraphicBuffer = mSlots[slot].mGraphicBuffer; <span class="comment">//图形buffer</span></span><br><span class="line">|item.mCrop = crop;<span class="comment">//裁切矩形</span></span><br><span class="line">|item.mTransform = transform &amp; ~<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<span class="comment">// 旋转变换 </span></span><br><span class="line">|item.mTransformToDisplayInverse = (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="number">0</span>;</span><br><span class="line">|item.mScalingMode = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(scalingMode);<span class="comment">//缩放模式</span></span><br><span class="line">|item.mTimestamp = requestedPresentTimestamp;<span class="comment">//时间戳</span></span><br><span class="line">|item.mIsAutoTimestamp = isAutoTimestamp;<span class="comment">// 是否在入队时，自动生成时间戳，默认情况下 true</span></span><br><span class="line">|item.mDataSpace = dataSpace;<span class="comment">// 描述图像内容，依赖于图像格式</span></span><br><span class="line">|item.mHdrMetadata = hdrMetadata;<span class="comment">//  HDR metadata 不懂</span></span><br><span class="line">|item.mFrameNumber = currentFrameNumber;<span class="comment">//帧号</span></span><br><span class="line">|item.mSlot = slot;<span class="comment">/*索引*/</span> item.mFence = acquireFence;<span class="comment">/*fence*/</span> item.mFenceTime = acquireFenceTime;<span class="comment">/*FenceTime*/</span></span><br><span class="line">|<span class="comment">// mIsDroppable 如果为true，则 queuebuffer 时，可以替换旧的buffer。</span></span><br><span class="line">|item.mIsDroppable = mCore-&gt;mAsyncMode || ...;<span class="comment">// 当前 mIsDroppable = false</span></span><br><span class="line">|item.mSurfaceDamage = surfaceDamage;<span class="comment">//已经被修改的区域</span></span><br><span class="line">|item.mQueuedBuffer = <span class="literal">true</span>;<span class="comment">// 标明buffer已经被生产者 queued，acquireBuffer后设置为false</span></span><br><span class="line">|item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<span class="comment">// 仅仅在共享buffer下有用，标明消费者应该尽快 acquire 下一帧</span></span><br><span class="line">|item.mApi = mCore-&gt;mConnectedApi;<span class="comment">//表明是 CPU还是GPU queue的buffer</span></span><br><span class="line">|output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line">|<span class="comment">//【BufferItem入队】</span></span><br><span class="line">|mCore-&gt;mQueue.<span class="built_in">push_back</span>(item);</span><br><span class="line">|<span class="comment">// BufferQueueCore.mConsumerListener = ConsumerBase(BLASTBufferItemConsumer的父类)</span></span><br><span class="line">|frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">|mCore-&gt;mBufferHasBeenQueued = <span class="literal">true</span>;<span class="comment">// 每次queueBuffer后都设置为true</span></span><br><span class="line">|mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒等待的线程</span></span><br><span class="line">|mCore-&gt;mLastQueuedSlot = slot;<span class="comment">//  赋值最新queue的 BufferSlot 索引</span></span><br><span class="line">|<span class="comment">// 返回给Surface的数据</span></span><br><span class="line">    |output-&gt;width = mCore-&gt;mDefaultWidth;output-&gt;height = mCore-&gt;mDefaultHeight;</span><br><span class="line">|output-&gt;transformHint = mCore-&gt;mTransformHintInUse = mCore-&gt;mTransformHint;</span><br><span class="line">|output-&gt;numPendingBuffers = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>());<span class="comment">// 返回当前已经Queue的数量，代表还未被消费的数量</span></span><br><span class="line">|output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + <span class="number">1</span>;<span class="comment">// 返回下一帧的帧号</span></span><br><span class="line">|<span class="comment">// atrace 记录 mQueue 大小</span></span><br><span class="line">    |   <span class="built_in">ATRACE_INT</span>(mCore-&gt;mConsumerName.<span class="built_in">string</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>()));</span><br><span class="line">|<span class="comment">// BBQ生产者构造函数设置 mConsumerIsSurfaceFlinger = false</span></span><br><span class="line">|<span class="keyword">if</span> (!mConsumerIsSurfaceFlinger)</span><br><span class="line">        |<span class="comment">// 清理 GraphicBuffer 指针【TODO：这里的一些比较重要联动细节待研究】</span></span><br><span class="line">        |item.mGraphicBuffer.<span class="built_in">clear</span>();</span><br><span class="line">|<span class="type">int</span> connectedApi = mCore-&gt;mConnectedApi;</span><br><span class="line">|sp&lt;Fence&gt; lastQueuedFence = std::<span class="built_in">move</span>(mLastQueueBufferFence);</span><br><span class="line">|mLastQueueBufferFence = std::<span class="built_in">move</span>(acquireFence);</span><br><span class="line">|<span class="comment">//【消费者回调】</span></span><br><span class="line">    |<span class="comment">// 回调到 ConsumerBase.onFrameAvailable ，再回调到 BLASTBufferQueue.onFrameAvailable</span></span><br><span class="line">|frameAvailableListener-&gt;<span class="built_in">onFrameAvailable</span>(item);<span class="comment">//【转入“BufferQueueConsumer::acquireBuffer”章节】</span></span><br><span class="line">|<span class="comment">// 如果是 GPU 绘制，最多queueBuffer两个buffer，第二个buffer没有绘制完成，就需要等待 fence</span></span><br><span class="line">|<span class="keyword">if</span> (connectedApi == NATIVE_WINDOW_API_EGL)</span><br><span class="line">        |lastQueuedFence-&gt;<span class="built_in">waitForever</span>(<span class="string">&quot;Throttling EGL Production&quot;</span>);</span><br><span class="line">|mLastQueueDuration = <span class="built_in">systemTime</span>() - now; <span class="comment">// 记录 queueBuffer 时间</span></span><br><span class="line">|<span class="comment">// 更新Surface的一些成员属性</span></span><br><span class="line">|<span class="built_in">onBufferQueuedLocked</span>(i, fence, output);</span><br></pre></td></tr></table></figure><h4 id="BufferQueueConsumer-acquireBuffer"><a href="#BufferQueueConsumer-acquireBuffer" class="headerlink" title="BufferQueueConsumer::acquireBuffer"></a>BufferQueueConsumer::acquireBuffer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码BLASTBufferQueue::<span class="built_in">onFrameAvailable</span>(<span class="type">const</span> BufferItem&amp; item)</span><br><span class="line">|<span class="built_in">acquireNextBufferLocked</span>(std::<span class="literal">nullopt</span>);</span><br><span class="line">|--&gt;BLASTBufferQueue::<span class="built_in">acquireNextBufferLocked</span>(<span class="type">const</span> std::optional&lt;SurfaceComposerClient::Transaction*&gt; transaction)</span><br><span class="line">    |<span class="comment">// 参数 transaction = nullopt</span></span><br><span class="line">    |<span class="type">const</span> <span class="type">bool</span> includeExtraAcquire = !transaction;<span class="comment">// includeExtraAcquire = true</span></span><br><span class="line">|<span class="comment">// 判断 mNumAcquired 是否大于等于 mMaxAcquiredBuffers + (includeExtraAcquire ? 2 : 1) </span></span><br><span class="line">|<span class="type">const</span> <span class="type">bool</span> maxAcquired = <span class="built_in">maxBuffersAcquired</span>(includeExtraAcquire);</span><br><span class="line">|<span class="comment">// Transaction 一个事务里边会填充各种需要执行的业务和业务数据，最终传递到 SurfaceFlinger，SF对事务解析的结果通常是设置Layer的各种属性</span></span><br><span class="line">    |<span class="comment">// 每设置一种数据，都会存到ComposerState中，并添加对应的flag，SF端根据flag解析数据</span></span><br><span class="line">|SurfaceComposerClient::Transaction localTransaction;</span><br><span class="line">|<span class="type">bool</span> applyTransaction = <span class="literal">true</span>;</span><br><span class="line">|SurfaceComposerClient::Transaction* t = &amp;localTransaction;</span><br><span class="line">|BufferItem bufferItem; <span class="comment">// 创建一个未填充数据的的栈对象 BufferItem</span></span><br><span class="line">|<span class="comment">//【acquireBuffer流程!!!!!!!!!!!!!!!!】</span></span><br><span class="line">|<span class="type">status_t</span> status = mBufferItemConsumer-&gt;<span class="built_in">acquireBuffer</span>(&amp;bufferItem, <span class="number">0</span> <span class="comment">/* expectedPresent */</span>, <span class="literal">false</span>);</span><br><span class="line">|--&gt;BufferItemConsumer::<span class="built_in">acquireBuffer</span>(BufferItem *item, <span class="type">nsecs_t</span> presentWhen, <span class="type">bool</span> waitForFence)</span><br><span class="line">        |<span class="built_in">acquireBufferLocked</span>(item, presentWhen); <span class="comment">// presentWhen = 0</span></span><br><span class="line">|--&gt;ConsumerBase::<span class="built_in">acquireBufferLocked</span>(BufferItem *item, <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber)</span><br><span class="line">            |<span class="comment">// 调用消费者的 acquireBuffer, mConsumer 为 BufferQueueConsumer</span></span><br><span class="line">            |mConsumer-&gt;<span class="built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);</span><br><span class="line">|--&gt;BufferQueueConsumer::<span class="built_in">acquireBuffer</span>(BufferItem* outBuffer, <span class="type">nsecs_t</span> expectedPresent, <span class="type">uint64_t</span> maxFrameNumber)</span><br><span class="line">            |<span class="comment">// 参数： outBuffer 是个需要带回数据的指针; expectedPresent = 0; maxFrameNumber = 0</span></span><br><span class="line">                |<span class="comment">// 拿到队列的迭代指针</span></span><br><span class="line">                |BufferQueueCore::<span class="function">Fifo::iterator <span class="title">front</span><span class="params">(mCore-&gt;mQueue.begin())</span></span>;</span><br><span class="line">|<span class="comment">// 忽略一大段不执行的分支：作用就是丢弃buffer的操作、共享buffer</span></span><br><span class="line">                |<span class="type">int</span> slot = front-&gt;mSlot; <span class="comment">// 把 mQueue 队列里的第一个 BufferItem 的mSlot，赋值给 slot</span></span><br><span class="line">|<span class="comment">// 【把拿到的 BufferItem 通过指针参数带回】</span></span><br><span class="line">|*outBuffer = *front; </span><br><span class="line">|<span class="built_in">ATRACE_BUFFER_INDEX</span>(slot);<span class="comment">// trace 记录 BufferSlot 的索引值</span></span><br><span class="line">|<span class="keyword">if</span> (!outBuffer-&gt;mIsStale) <span class="comment">// 如果buffer没有过时</span></span><br><span class="line">                    |mSlots[slot].mAcquireCalled = <span class="literal">true</span>;<span class="comment">// 设置状态为已经被acquire过了</span></span><br><span class="line">|<span class="comment">// 【切换状态为 acquired 状态】</span></span><br><span class="line">|mSlots[slot].mBufferState.<span class="built_in">acquire</span>();</span><br><span class="line">|mSlots[slot].mFence = Fence::NO_FENCE;  <span class="comment">// 设置为 NO_FENCE</span></span><br><span class="line">|<span class="keyword">if</span> (outBuffer-&gt;mAcquireCalled) <span class="comment">// 已经被消费过了，需要设置 GraphicBuffer 为 nullptr，避免 remapping</span></span><br><span class="line">                        |outBuffer-&gt;mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">|<span class="comment">//【把 BufferItem 从队queued列中移除】</span></span><br><span class="line">|mCore-&gt;mQueue.<span class="built_in">erase</span>(front);</span><br><span class="line">|mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();<span class="comment">// 唤醒等待的线程</span></span><br><span class="line">|<span class="comment">// atrace 记录此时的队列长度</span></span><br><span class="line">|<span class="built_in">ATRACE_INT</span>(mCore-&gt;mConsumerName.<span class="built_in">string</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(mCore-&gt;mQueue.<span class="built_in">size</span>()));</span><br><span class="line">|<span class="comment">//返回到 ConsumerBase::acquireBufferLocked</span></span><br><span class="line">|<span class="comment">//BBQ生产者 BufferQueueProducer::queueBuffer 时，把 mGraphicBuffer 指针清空了，这个分支不走的</span></span><br><span class="line">|<span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">                |<span class="keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">                    |<span class="built_in">freeBufferLocked</span>(item-&gt;mSlot);</span><br><span class="line">|mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;</span><br><span class="line">|<span class="comment">// 这里的 BufferItemConsumer.mSlots 和 BufferQueueConsumer.mSlots 不是同一个对象</span></span><br><span class="line">|mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;<span class="comment">// 帧号存到 BufferItemConsumer.mSlots 里</span></span><br><span class="line">|mSlots[item-&gt;mSlot].mFence = item-&gt;mFence; <span class="comment">// Fence存到 BufferItemConsumer.mSlots 里</span></span><br><span class="line">|<span class="comment">//返回到 BufferItemConsumer::acquireBuffer</span></span><br><span class="line">|<span class="keyword">if</span> (waitForFence) <span class="comment">// waitForFence = false ,无需等待fence</span></span><br><span class="line">            |item-&gt;mFence-&gt;<span class="built_in">waitForever</span>(<span class="string">&quot;BufferItemConsumer::acquireBuffer&quot;</span>);</span><br><span class="line">|<span class="comment">// 返回的 GraphicBuffer 为 BLASTBufferItemConsumer.mSlots 的 GraphicBuffer</span></span><br><span class="line">|item-&gt;mGraphicBuffer = mSlots[item-&gt;mSlot].mGraphicBuffer;</span><br><span class="line">|<span class="comment">//返回到BLASTBufferQueue::acquireNextBufferLocked</span></span><br><span class="line">    |<span class="keyword">auto</span> buffer = bufferItem.mGraphicBuffer; </span><br><span class="line">|mNumFrameAvailable--;</span><br><span class="line">|<span class="keyword">if</span> (buffer == <span class="literal">nullptr</span>) <span class="comment">//TODO：流程上，应该是进入了此分支，现实是不可能，这里看了好几遍也没找到问题出哪里了，以后再重新分析一下吧</span></span><br><span class="line">        |mBufferItemConsumer-&gt;<span class="built_in">releaseBuffer</span>(bufferItem, Fence::NO_FENCE);</span><br><span class="line">        |<span class="keyword">return</span>;</span><br><span class="line">|<span class="comment">// 如果buffer的尺寸不匹配，直接释放buffer，请求下一个</span></span><br><span class="line">|<span class="keyword">if</span> (<span class="built_in">rejectBuffer</span>(bufferItem))</span><br><span class="line">        |mBufferItemConsumer-&gt;<span class="built_in">releaseBuffer</span>(bufferItem, Fence::NO_FENCE);</span><br><span class="line">|<span class="built_in">acquireNextBufferLocked</span>(transaction);</span><br><span class="line">|<span class="keyword">return</span>;</span><br><span class="line">|mNumAcquired++; <span class="comment">// Acquired数量加一，release 时减一</span></span><br><span class="line">|mLastAcquiredFrameNumber = bufferItem.mFrameNumber;<span class="comment">// 记录当前的帧号</span></span><br><span class="line">|<span class="comment">// 创建 ReleaseCallbackId ，加入到map mSubmitted，SurfaceFlinger 释放buffer，回调回来时会通过ReleaseCallbackId查找BufferItem</span></span><br><span class="line">    |<span class="function">ReleaseCallbackId <span class="title">releaseCallbackId</span><span class="params">(buffer-&gt;getId(), mLastAcquiredFrameNumber)</span></span>;</span><br><span class="line">|mSubmitted[releaseCallbackId] = bufferItem;</span><br><span class="line">|mSize = mRequestedSize;</span><br><span class="line">|Rect crop = <span class="built_in">computeCrop</span>(bufferItem);<span class="comment">// 裁剪矩形</span></span><br><span class="line">|<span class="comment">//【 releaseBuffer 回调函数 !!!!!!!!!!!!!!!!】,SurfaceFlinger合成完后，就是回调的 releaseBufferCallbackThunk函数</span></span><br><span class="line">|<span class="keyword">auto</span> releaseBufferCallback = std::<span class="built_in">bind</span>(releaseBufferCallbackThunk, <span class="built_in">wp</span>&lt;BLASTBufferQueue&gt;(<span class="keyword">this</span>),...);</span><br><span class="line">|sp&lt;Fence&gt; fence = bufferItem.mFence ? <span class="keyword">new</span> <span class="built_in">Fence</span>(bufferItem.mFence-&gt;<span class="built_in">dup</span>()) : Fence::NO_FENCE;<span class="comment">//GPU绘制的fence</span></span><br><span class="line">|<span class="comment">//【把buffer、fence、释放buffer的回调函数 都传入事务，通过事务传递给SurfaceFlinger】</span></span><br><span class="line">|t-&gt;<span class="built_in">setBuffer</span>(mSurfaceControl, buffer, fence, bufferItem.mFrameNumber, releaseBufferCallback);</span><br><span class="line">|<span class="comment">// 使用 bufferItem中的数据，填充事务的其他各种数据...</span></span><br><span class="line">|t-&gt;<span class="built_in">setDataspace</span>(mSurfaceControl, <span class="built_in">static_cast</span>&lt;ui::Dataspace&gt;(bufferItem.mDataSpace));</span><br><span class="line">|t-&gt;<span class="built_in">setHdrMetadata</span>(mSurfaceControl, bufferItem.mHdrMetadata);</span><br><span class="line">|t-&gt;<span class="built_in">setBufferCrop</span>(mSurfaceControl, crop);</span><br><span class="line">|t-&gt;<span class="built_in">setAutoRefresh</span>(mSurfaceControl, bufferItem.mAutoRefresh);</span><br><span class="line">|t-&gt;<span class="built_in">setSurfaceDamageRegion</span>(mSurfaceControl, bufferItem.mSurfaceDamage);</span><br><span class="line">|<span class="comment">//....</span></span><br><span class="line">    |<span class="comment">// 最后调用apply，把事务传递到SurfaceFlinger</span></span><br><span class="line">    |t-&gt;<span class="built_in">setApplyToken</span>(mApplyToken).<span class="built_in">apply</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">|SurfaceComposerClient::Transaction::<span class="built_in">apply</span>(<span class="type">bool</span> synchronous, <span class="type">bool</span> oneWay)</span><br><span class="line">        |<span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">|sf-&gt;<span class="built_in">setTransactionState</span>(mFrameTimelineInfo, composerStates, displayStates, flags, applyToken,...)</span><br></pre></td></tr></table></figure><h3 id="九、SurfaceFlinger-合成—-Android-13-Android-T"><a href="#九、SurfaceFlinger-合成—-Android-13-Android-T" class="headerlink" title="九、SurfaceFlinger 合成— Android 13 (Android T)"></a>九、SurfaceFlinger 合成— Android 13 (Android T)</h3><p><strong>相对于Android 12，Android13在架构上做了微调</strong></p><ul><li><p>SurfaceFlinger::onMessageInvalidate 对应于 SurfaceFlinger::commit，但是结构上做了大量的调整</p><p>一些函数像 handleMessageTransaction、handleTransaction、handleMessageInvalidate、handlePageFlip 这些都不见了</p></li><li><p>SurfaceFlinger::onMessageRefresh 对应于 SurfaceFlinger::composite</p></li></ul><p><strong>然后Android13 还做了GPU合成的优化</strong></p><ul><li>对GPU合成进行预测，如果有GPU合成，那么 chooseCompositionStrategy 和 GPU合成 并行执行。用以节约时间。</li></ul><h4 id="SurfaceComposerClient-Transaction-apply–-gt-SurfaceFlinger-setTransactionState"><a href="#SurfaceComposerClient-Transaction-apply–-gt-SurfaceFlinger-setTransactionState" class="headerlink" title="SurfaceComposerClient::Transaction::apply–&gt;SurfaceFlinger::setTransactionState"></a>SurfaceComposerClient::Transaction::apply–&gt;SurfaceFlinger::setTransactionState</h4><ul><li>事务入队。加入到队列  SurfaceFlinger.mTransactionQueue</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line">SurfaceComposerClient::Transaction::<span class="built_in">apply</span>(<span class="type">bool</span> synchronous, <span class="type">bool</span> oneWay)</span><br><span class="line">|   <span class="comment">// applyToken 来源于 BLASTBufferQueue.h </span></span><br><span class="line">|   <span class="comment">// const sp&lt;IBinder&gt; mApplyToken GUARDED_BY(mMutex) = new BBinder();</span></span><br><span class="line">|sf-&gt;<span class="built_in">setTransactionState</span>(mFrameTimelineInfo, composerStates, displayStates, flags, applyToken,</span><br><span class="line">                            mInputWindowCommands, mDesiredPresentTime, mIsAutoTimestamp,</span><br><span class="line">                            &#123;&#125; <span class="comment">/*uncacheBuffer - only set in doUncacheBufferTransaction*/</span>,</span><br><span class="line">                            hasListenerCallbacks, listenerCallbacks, mId);</span><br><span class="line"><span class="comment">//进入 SurfaceFlinger 进程</span></span><br><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line">SurfaceFlinger::<span class="built_in">setTransactionState</span>(<span class="type">const</span> FrameTimelineInfo&amp; frameTimelineInfo, <span class="type">const</span> Vector&lt;ComposerState&gt;&amp; states,</span><br><span class="line">                                    <span class="type">const</span> Vector&lt;DisplayState&gt;&amp; displays, <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; applyToken,</span><br><span class="line">                                    <span class="type">const</span> InputWindowCommands&amp; inputWindowCommands, <span class="type">int64_t</span> desiredPresentTime,</span><br><span class="line">                                    <span class="type">bool</span> isAutoTimestamp, <span class="type">const</span> <span class="type">client_cache_t</span>&amp; uncacheBuffer, <span class="type">bool</span> hasListenerCallbacks,</span><br><span class="line">                                    <span class="type">const</span> std::vector&lt;ListenerCallbacks&gt;&amp; listenerCallbacks, <span class="type">uint64_t</span> transactionId)</span><br><span class="line">|<span class="comment">//...</span></span><br><span class="line">|<span class="type">const</span> <span class="type">int64_t</span> postTime = <span class="built_in">systemTime</span>();</span><br><span class="line">|IPCThreadState* ipc = IPCThreadState::<span class="built_in">self</span>();</span><br><span class="line">|<span class="type">const</span> <span class="type">int</span> originPid = ipc-&gt;<span class="built_in">getCallingPid</span>();</span><br><span class="line">|<span class="type">const</span> <span class="type">int</span> originUid = ipc-&gt;<span class="built_in">getCallingUid</span>();</span><br><span class="line">|<span class="comment">// 主要逻辑就是把这个 TransactionState 对象入队。然后请求 SF-vsync </span></span><br><span class="line">|TransactionState state&#123;frameTimelineInfo, states, displays, flags, applyToken, inputWindowCommands, </span><br><span class="line">                           desiredPresentTime, isAutoTimestamp, uncacheBuffer, postTime, permissions,</span><br><span class="line">                           hasListenerCallbacks,listenerCallbacks, originPid, originUid, transactionId&#125;;</span><br><span class="line">|<span class="comment">//...</span></span><br><span class="line">|<span class="built_in">queueTransaction</span>(state);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">queueTransaction</span>(TransactionState&amp; state)</span><br><span class="line">    |state.queueTime = <span class="built_in">systemTime</span>();</span><br><span class="line">|<span class="comment">//std::deque&lt;TransactionState&gt; mTransactionQueue;双端队列</span></span><br><span class="line">    |<span class="comment">//【把 TransactionState 入队】</span></span><br><span class="line">    |<span class="comment">// 在 SurfaceFlinger::flushTransactions() 函数中会出队    </span></span><br><span class="line">|mTransactionQueue.<span class="built_in">emplace_back</span>(state);</span><br><span class="line">|<span class="built_in">ATRACE_INT</span>(<span class="string">&quot;TransactionQueue&quot;</span>, mTransactionQueue.<span class="built_in">size</span>());</span><br><span class="line">|<span class="type">const</span> <span class="keyword">auto</span> schedule = ...;</span><br><span class="line">|<span class="type">const</span> <span class="keyword">auto</span> frameHint = state.<span class="built_in">isFrameActive</span>() ? FrameHint::kActive : FrameHint::kNone;</span><br><span class="line">|<span class="comment">// 传入的事务flag是枚举类型 eTransactionFlushNeeded = 0x10;</span></span><br><span class="line">|<span class="built_in">setTransactionFlags</span>(eTransactionFlushNeeded, schedule, state.applyToken, frameHint);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">setTransactionFlags</span>(<span class="type">uint32_t</span> mask, TransactionSchedule schedule, IBinder&amp; applyToken, FrameHint frameHint)</span><br><span class="line">        |<span class="comment">// 调整vsync一些时间配置</span></span><br><span class="line">        |<span class="built_in">modulateVsync</span>(&amp;VsyncModulator::setTransactionSchedule, schedule, applyToken);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、mTransactionFlags 添加 eTransactionFlushNeeded 标记</span></span><br><span class="line"><span class="comment">    2、mTransactionFlags原值 同 mask 相与， 表示原先有没有这个标记。并把结果存储 scheduled</span></span><br><span class="line"><span class="comment">    3、!scheduled 取非，表示如果原先没有这个标记，就进入此分支，执行 scheduleCommit</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">|<span class="keyword">if</span> (<span class="type">const</span> <span class="type">bool</span> scheduled = mTransactionFlags.<span class="built_in">fetch_or</span>(mask) &amp; mask; !scheduled)</span><br><span class="line">            |<span class="built_in">scheduleCommit</span>(frameHint);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">scheduleCommit</span>(FrameHint hint)</span><br><span class="line">                |<span class="keyword">if</span> (hint == FrameHint::kActive)</span><br><span class="line">                    |mScheduler-&gt;<span class="built_in">resetIdleTimer</span>();</span><br><span class="line">|mPowerAdvisor-&gt;<span class="built_in">notifyDisplayUpdateImminent</span>();</span><br><span class="line">|<span class="comment">// 这个函数的调用链很长，知道这个代码是请求 SurfaceFlinger 的 vsync 就行了</span></span><br><span class="line">|mScheduler-&gt;<span class="built_in">scheduleFrame</span>();</span><br></pre></td></tr></table></figure><h4 id="MessageQueue-scheduleFrame-—-请求vsync"><a href="#MessageQueue-scheduleFrame-—-请求vsync" class="headerlink" title="MessageQueue::scheduleFrame() — 请求vsync"></a>MessageQueue::scheduleFrame() — 请求vsync</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码MessageQueue::<span class="built_in">scheduleFrame</span>()</span><br><span class="line">|mVsync.registration-&gt;<span class="built_in">schedule</span>(&#123;.workDuration = mVsync.workDuration.<span class="built_in">get</span>().<span class="built_in">count</span>(),</span><br><span class="line">                                   .readyDuration = <span class="number">0</span>,</span><br><span class="line">                                   .earliestVsync = mVsync.lastCallbackTime.<span class="built_in">count</span>()&#125;);</span><br><span class="line">|--&gt;VSyncCallbackRegistration::<span class="built_in">schedule</span>(VSyncDispatch::ScheduleTiming scheduleTiming)</span><br><span class="line">    |<span class="keyword">if</span> (!mValidToken)<span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">|<span class="comment">// mDispatch 是 VSyncDispatchTimerQueue</span></span><br><span class="line">    |<span class="keyword">return</span> mDispatch.<span class="built_in">get</span>().<span class="built_in">schedule</span>(mToken, scheduleTiming);</span><br><span class="line">|VSyncDispatchTimerQueue::<span class="built_in">schedule</span>(CallbackToken token, ScheduleTiming scheduleTiming)</span><br><span class="line">        |ScheduleResult result;</span><br><span class="line">|<span class="comment">// VSyncCallbackRegistration 构造的时候，调用registerCallback生成了一个 token ，这个token存储到了 map 对象 mCallbacks</span></span><br><span class="line">        |   <span class="comment">// 现在拿出来</span></span><br><span class="line">        |<span class="keyword">auto</span> it = mCallbacks.<span class="built_in">find</span>(token);</span><br><span class="line">|<span class="keyword">auto</span>&amp; callback = it-&gt;second;  <span class="comment">// map 迭代器 second 中存储 VSyncDispatchTimerQueueEntry</span></span><br><span class="line">|<span class="comment">// VSyncDispatchTimerQueueEntry 中存储真正的回调函数 MessageQueue::vsyncCallback</span></span><br><span class="line">|result = callback-&gt;<span class="built_in">schedule</span>(scheduleTiming, mTracker, now);</span><br><span class="line">|<span class="comment">// 这里步骤还很多。大概是更新vsync的时间配置啥的</span></span><br><span class="line">|--&gt;VSyncDispatchTimerQueueEntry::<span class="built_in">schedule</span>(VSyncDispatch::ScheduleTiming timing, VSyncTracker&amp; tracker, <span class="type">nsecs_t</span> now)</span><br><span class="line">            |<span class="comment">//省略VSyncDispatchTimerQueueEntry函数内XXXX，太长了。抽空再研究</span></span><br><span class="line">            |<span class="comment">//.........</span></span><br><span class="line">        |<span class="keyword">if</span> (callback-&gt;<span class="built_in">wakeupTime</span>() &lt; mIntendedWakeupTime - mTimerSlack) </span><br><span class="line">            |<span class="comment">// 启动vsync的定时器</span></span><br><span class="line">            |<span class="built_in">rearmTimerSkippingUpdateFor</span>(now, it);</span><br><span class="line">|<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><h4 id="sf-vsync事件分发流程"><a href="#sf-vsync事件分发流程" class="headerlink" title="sf-vsync事件分发流程"></a>sf-vsync事件分发流程</h4><ul><li>Android 13 把用了好多年的 onMessageInvalidate()、onMessageRefresh 体系给改了</li><li>变成了 SurfaceFlinger::commit 和 SurfaceFlinger::composite ，中间不post消息了，直接无缝切换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></span><br><span class="line">MessageQueue::<span class="built_in">vsyncCallback</span>(<span class="type">nsecs_t</span> vsyncTime, <span class="type">nsecs_t</span> targetWakeupTime, <span class="type">nsecs_t</span> readyTime)</span><br><span class="line">|mHandler-&gt;<span class="built_in">dispatchFrame</span>(vsyncId, vsyncTime);</span><br><span class="line">|--&gt;MessageQueue::Handler::<span class="built_in">dispatchFrame</span>(<span class="type">int64_t</span> vsyncId, <span class="type">nsecs_t</span> expectedVsyncTime)</span><br><span class="line">    |mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>())</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp;) &#123;</span><br><span class="line">    mFramePending.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> frameTime = <span class="built_in">systemTime</span>();</span><br><span class="line">    <span class="comment">// mQueue  类型android::impl::MessageQueue</span></span><br><span class="line">    <span class="comment">// android::impl::MessageQueue.mCompositor 类型 ICompositor</span></span><br><span class="line">    <span class="comment">// SurfaceFlinger 继承 ICompositor</span></span><br><span class="line">    <span class="comment">// mQueue.mCompositor 其实就是 SurfaceFlinger </span></span><br><span class="line">    <span class="keyword">auto</span>&amp; compositor = mQueue.mCompositor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【流程1，返回false的话，直接返回，不会执行后面的合成流程composite】</span></span><br><span class="line">    <span class="keyword">if</span> (!compositor.<span class="built_in">commit</span>(frameTime, mVsyncId, mExpectedVsyncTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//【流程2，合成】</span></span><br><span class="line">    compositor.<span class="built_in">composite</span>(frameTime, mVsyncId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过RegionSamplingThread对合成帧进行采样</span></span><br><span class="line">    compositor.<span class="built_in">sample</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SurfaceFlinger-commit-流程"><a href="#SurfaceFlinger-commit-流程" class="headerlink" title="SurfaceFlinger::commit 流程"></a>SurfaceFlinger::commit 流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line">SurfaceFlinger::<span class="built_in">commit</span>(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId, <span class="type">nsecs_t</span> expectedVsyncTime)</span><br><span class="line">|<span class="comment">// 返回 SurfaceFlinger.mTransactionFlags 是否携带 eTransactionFlushNeeded 标记。同时清除这个标记</span></span><br><span class="line">|<span class="comment">//eTransactionFlushNeeded 是由 queueTransaction 流程中设置的</span></span><br><span class="line">|<span class="keyword">if</span> (<span class="built_in">clearTransactionFlags</span>(eTransactionFlushNeeded))</span><br><span class="line">    |<span class="comment">//【1】、flushTransactions()，核心是获取所有的TransactionState，之后将作为 applyTransactions流程 的参数】</span></span><br><span class="line">    |<span class="comment">// 把 Transaction::apply 流程中，加入 mTransactionQueue 队列的 TransactionState 出队</span></span><br><span class="line">    |std::vector&lt;TransactionState&gt; transactions = <span class="built_in">flushTransactions</span>();</span><br><span class="line">|<span class="comment">// 这个函数核心就是把 mTransactionQueue 队列的数据转移到一个 vector 中返回</span></span><br><span class="line">        <span class="comment">// 中间处理一些还没有处理完的事务。具体代码待研究</span></span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">flushTransactions</span>()</span><br><span class="line">        |std::vector&lt;TransactionState&gt; transactions;</span><br><span class="line">        |<span class="keyword">while</span> (!mTransactionQueue.<span class="built_in">empty</span>())<span class="comment">// 【取出setTransactionState流程中入队的所有事务】</span></span><br><span class="line">            |<span class="keyword">auto</span>&amp; transaction = mTransactionQueue.<span class="built_in">front</span>();</span><br><span class="line">|<span class="comment">// 省略 X 行代码</span></span><br><span class="line">            |transactions.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(transaction));<span class="comment">// 把事务转入向量集合 vector&lt;TransactionState&gt; transactions</span></span><br><span class="line">|mTransactionQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">|<span class="built_in">ATRACE_INT</span>(<span class="string">&quot;TransactionQueue&quot;</span>, mTransactionQueue.<span class="built_in">size</span>());</span><br><span class="line">|<span class="keyword">return</span> transactions;</span><br><span class="line">|<span class="comment">// 【2】、处理以前创建的layer，核心就是把新创建的layer加入到Z轴排序集合体系 mCurrentState.layersSortedByZ 】</span></span><br><span class="line">    |<span class="comment">// Android12以前layersSortedByZ不是在这里添加的。或许谷歌以后想仅仅通过事务的接口创建layer？？</span></span><br><span class="line">    |needsTraversal |= <span class="built_in">commitCreatedLayers</span>();</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">commitCreatedLayers</span>()</span><br><span class="line">        |std::vector&lt;LayerCreatedState&gt; createdLayers;</span><br><span class="line"><span class="comment">/* mCreatedLayers： 创建layer流程中，通过 SurfaceFlinger::addClientLayer 把layer添加到了 mCreatedLayers 这个vector中</span></span><br><span class="line"><span class="comment">   现在开始拿来使用了 */</span></span><br><span class="line">|createdLayers = std::<span class="built_in">move</span>(mCreatedLayers); <span class="comment">//数据转移到新的对象createdLayers中</span></span><br><span class="line">|mCreatedLayers.<span class="built_in">clear</span>();<span class="comment">//清除mCreatedLayers所有的数据</span></span><br><span class="line">|<span class="keyword">if</span> (createdLayers.<span class="built_in">size</span>() == <span class="number">0</span>)  </span><br><span class="line">            |<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有新增的Layer，直接返回，那么 mLayersAdded 就不会被设置为 true</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; createdLayer : createdLayers)</span><br><span class="line">            |<span class="built_in">handleLayerCreatedLocked</span>(createdLayer);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">handleLayerCreatedLocked</span>(<span class="type">const</span> LayerCreatedState&amp; state)</span><br><span class="line">                |sp&lt;Layer&gt; layer = state.layer.<span class="built_in">promote</span>();</span><br><span class="line">|<span class="type">bool</span> addToRoot = state.addToRoot;</span><br><span class="line">|sp&lt;Layer&gt; parent = state.initialParent.<span class="built_in">promote</span>();</span><br><span class="line">|<span class="comment">// 如果没有父layer的话，执行以下代码。</span></span><br><span class="line">                |<span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToRoot)</span><br><span class="line">|layer-&gt;<span class="built_in">setIsAtRoot</span>(<span class="literal">true</span>);</span><br><span class="line">|<span class="comment">//【添加到 mCurrentState.layersSortedByZ 这个以Z轴排序的集合中】</span></span><br><span class="line">|mCurrentState.layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line">|<span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>)</span><br><span class="line">                    |layer-&gt;<span class="built_in">onRemovedFromCurrentState</span>();<span class="comment">// Layer删除处理</span></span><br><span class="line">|<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>())</span><br><span class="line">                    |parent-&gt;<span class="built_in">addChild</span>(layer);</span><br><span class="line">|layer-&gt;<span class="built_in">onRemovedFromCurrentState</span>();<span class="comment">// Layer删除处理</span></span><br><span class="line">|<span class="keyword">else</span><span class="comment">// <span class="doctag">TODO:</span> 待验证 parent 为 ContainerLayer， addToRoot=true</span></span><br><span class="line">                    |parent-&gt;<span class="built_in">addChild</span>(layer);<span class="comment">// BufferStateLayer 应该走这里。添加到 Layer.mCurrentChildren 集合中</span></span><br><span class="line">|layer-&gt;<span class="built_in">updateTransformHint</span>(mActiveDisplayTransformHint);</span><br><span class="line">|mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line">|<span class="comment">// 在之后的流程 commitTransactionsLocked 函数中会设置回 false</span></span><br><span class="line">|mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">|<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果有新创建的layer，需要执行合成步骤 SurfaceFlinger.composite 函数</span></span><br><span class="line">|needsTraversal |= <span class="built_in">applyTransactions</span>(transactions, vsyncId);</span><br><span class="line">|<span class="comment">// 因图形buffer更新放到事务中来了，所以事务这里重点关注 eBufferChanged </span></span><br><span class="line">|<span class="comment">//【3】、applyTransactions流程: 把事务中的对于flag的数据存入Layer.mDrawingState对应的属性</span></span><br><span class="line">    |<span class="comment">// 对于Layer删除、调整Z轴，则是把相关数据存入 SurfaceFlinger.mCurrentState.layersSortedByZ</span></span><br><span class="line">    |<span class="comment">// 对于图形buffer更新而言，核心就是赋值 mDrawingState.buffer</span></span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">applyTransactions</span>(std::vector&lt;TransactionState&gt;&amp; transactions,<span class="type">int64_t</span> vsyncId)</span><br><span class="line">        |<span class="keyword">return</span> <span class="built_in">applyTransactionsLocked</span>(transactions, vsyncId);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">applyTransactionsLocked</span>(std::vector&lt;TransactionState&gt;&amp; transactions, <span class="type">int64_t</span> vsyncId)</span><br><span class="line">            |<span class="type">bool</span> needsTraversal = <span class="literal">false</span>;</span><br><span class="line">|<span class="comment">// 【遍历步骤1中flushTransactions()返回的 transactions】</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; transaction : transactions)</span><br><span class="line">                |needsTraversal |= <span class="built_in">applyTransactionState</span>(...)</span><br><span class="line">                |--&gt;SurfaceFlinger::<span class="built_in">applyTransactionState</span>(..)</span><br><span class="line">                |<span class="type">uint32_t</span> transactionFlags = <span class="number">0</span>;</span><br><span class="line">|<span class="type">uint32_t</span> clientStateFlags = <span class="number">0</span>;</span><br><span class="line">                |<span class="comment">// 省略一大堆内容</span></span><br><span class="line">                |clientStateFlags = <span class="built_in">setClientStateLocked</span>(frameTimelineInfo, state, desiredPresentTime,isAutoTimestamp, postTime, permissions);</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">setClientStateLocked</span>(<span class="type">const</span> FrameTimelineInfo&amp; frameTimelineInfo,ComposerState&amp; composerState,...)</span><br><span class="line">                        |<span class="comment">//省略一大堆内容</span></span><br><span class="line">                        |<span class="type">layer_state_t</span>&amp; s = composerState.state;</span><br><span class="line">                        |<span class="comment">// BLASTBufferQueue 传递buffer到SF的时候，调用Transaction::setBuffer 添加 eBufferChanged 标记</span></span><br><span class="line">|<span class="keyword">if</span> (what &amp; <span class="type">layer_state_t</span>::eBufferChanged)</span><br><span class="line">                            |layer-&gt;<span class="built_in">setBuffer</span>(buffer, *s.bufferData, postTime, desiredPresentTime, </span><br><span class="line">                                                     isAutoTimestamp, dequeueBufferTimestamp, frameTimelineInfo)</span><br><span class="line">                            |<span class="comment">// 只有 BufferStateLayer 覆写了setBuffer，其他layer使用父类Layer.setBuffer,父类的函数直接返回false</span></span><br><span class="line">                            |--&gt;BufferStateLayer::<span class="built_in">setBuffer</span>(std::shared_ptr&lt;renderengine::ExternalTexture&gt;&amp; buffer,<span class="type">const</span> BufferData&amp; bufferData,...)</span><br><span class="line">                            |<span class="comment">// 省略一大堆</span></span><br><span class="line">                            |<span class="comment">// 这里的 mDrawingState 是 Layer 的，和SurfaceFlinger的 mDrawingState 不是一个类</span></span><br><span class="line">                            |<span class="comment">// 以前 Layer也有一个 mCurrentState 对象，现在没有了</span></span><br><span class="line">                            |mDrawingState.frameNumber = frameNumber;</span><br><span class="line">|mDrawingState.releaseBufferListener = bufferData.releaseBufferListener;</span><br><span class="line">|mDrawingState.buffer = std::<span class="built_in">move</span>(buffer);<span class="comment">//【把buffer给到 mDrawingState.buffer】</span></span><br><span class="line">|mDrawingState.acquireFence =  ... bufferData.acquireFence;</span><br><span class="line">                                |mDrawingState.modified = <span class="literal">true</span>; <span class="comment">// 表示是否有状态被修改，几乎所有Layer事务都会设置这个变量为true</span></span><br><span class="line">|mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setPostTime</span>(layerId, mDrawingState.frameNumber, <span class="built_in">getName</span>().<span class="built_in">c_str</span>(),mOwnerUid, postTime,...);</span><br><span class="line">                                |mDrawingState.isAutoTimestamp = isAutoTimestamp;</span><br><span class="line">|mDrawingState.releaseBufferEndpoint = bufferData.releaseBufferEndpoint;</span><br><span class="line">|<span class="comment">// 每次vsync事件都会伴随生成一个 vsyncId。<span class="doctag">TODO:</span>通常情况可能没有 frameTimelineInfo,，没找到赋值过程，待研究 </span></span><br><span class="line">|<span class="keyword">else</span> <span class="keyword">if</span> (frameTimelineInfo.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID)</span><br><span class="line">                            |layer-&gt;<span class="built_in">setFrameTimelineVsyncForBufferlessTransaction</span>(frameTimelineInfo, postTime);</span><br><span class="line">|transactionFlags |= clientStateFlags;<span class="comment">// 添加 setClientStateLocked 返回的flag</span></span><br><span class="line">|<span class="type">bool</span> needsTraversal = <span class="literal">false</span>;</span><br><span class="line">|<span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) </span><br><span class="line">                        |transactionFlags = transactionFlags &amp; (~eTraversalNeeded);</span><br><span class="line">|needsTraversal = <span class="literal">true</span>;</span><br><span class="line">|<span class="keyword">if</span> (transactionFlags)<span class="built_in">setTransactionFlags</span>(transactionFlags); <span class="comment">//如果还有eTraversalNeeded以外的flag，请求vsync</span></span><br><span class="line">|<span class="keyword">return</span> needsTraversal;</span><br><span class="line">            |<span class="keyword">if</span> (mTransactionTracing) </span><br><span class="line">                |mTransactionTracing-&gt;<span class="built_in">addCommittedTransactions</span>(transactions, vsyncId);</span><br><span class="line">|<span class="keyword">return</span> needsTraversal;<span class="comment">//返回最终的 needsTraversal，这个为true的话，会执行 commitTransactions、composite</span></span><br><span class="line">|<span class="comment">// 是否需要执行事务提交。【提交的核心就是把 mCurrentState 赋值给 mDrawingState】</span></span><br><span class="line">|<span class="comment">// mCurrentState 保存APP传来的数据，mDrawingState 用于合成</span></span><br><span class="line">|<span class="type">const</span> <span class="type">bool</span> shouldCommit =  (<span class="built_in">getTransactionFlags</span>() &amp; ~eTransactionFlushNeeded) || needsTraversal;</span><br><span class="line">|<span class="comment">//【4】、commitTransactions()流程：核心是把mCurrentState转移到 mDrawingState</span></span><br><span class="line">|<span class="keyword">if</span>(shouldCommit) </span><br><span class="line">    |<span class="built_in">commitTransactions</span>();</span><br><span class="line">|--&gt;SurfaceFlinger:::<span class="built_in">commitTransactions</span>()</span><br><span class="line">    |<span class="function">State <span class="title">drawingState</span><span class="params">(mDrawingState)</span></span>;</span><br><span class="line">|mDebugInTransaction = <span class="built_in">systemTime</span>();</span><br><span class="line">|<span class="built_in">modulateVsync</span>(&amp;VsyncModulator::onTransactionCommit);</span><br><span class="line">|<span class="built_in">commitTransactionsLocked</span>(<span class="built_in">clearTransactionFlags</span>(eTransactionMask));</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">commitTransactionsLocked</span>(<span class="type">uint32_t</span> transactionFlags);</span><br><span class="line">|<span class="comment">// 屏幕的热插拔SurfaceFlinger::onComposerHalHotplug会调用 setTransactionFlags(eDisplayTransactionNeeded)，然后到这里处理</span></span><br><span class="line">            |<span class="comment">// <span class="doctag">TODO:</span>主线程中接收到的热插拔，不会走到这里。这里处理的可能是非主屏的热插拔，待验证。   </span></span><br><span class="line">|<span class="type">const</span> <span class="type">bool</span> displayTransactionNeeded = transactionFlags &amp; eDisplayTransactionNeeded;</span><br><span class="line">|<span class="comment">// 处理显示器的事务，显示屏幕增删，显示器的尺寸变化</span></span><br><span class="line">|<span class="keyword">if</span> (displayTransactionNeeded)</span><br><span class="line">                |<span class="built_in">processDisplayChangesLocked</span>();</span><br><span class="line">|<span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line">        |mCurrentState.<span class="built_in">traverse</span>(...) </span><br><span class="line">            |layer-&gt;<span class="built_in">updateTransformHint</span>(hintDisplay-&gt;<span class="built_in">getTransformHint</span>());<span class="comment">//更新旋转提示</span></span><br><span class="line">|<span class="keyword">if</span> (mLayersAdded) <span class="comment">// 在此之前的步骤[2] commitCreatedLayers 中设置的 true</span></span><br><span class="line">|mLayersAdded = <span class="literal">false</span>;</span><br><span class="line">|mVisibleRegionsDirty = <span class="literal">true</span>;<span class="comment">//有脏区域，【用于步骤6计算脏区域】</span></span><br><span class="line">|<span class="keyword">if</span> (mLayersRemoved)<span class="comment">// 处理被移除的Layer</span></span><br><span class="line">                |mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">|mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">|mDrawingState.<span class="built_in">traverseInZOrder</span>(...)</span><br><span class="line">                    |Region visibleReg;</span><br><span class="line">|visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">|<span class="built_in">invalidateLayerStack</span>(layer, visibleReg);<span class="comment">//更新DisplayDevice中原有的可视脏区</span></span><br><span class="line">|<span class="comment">//把Layer的添加以及删除从Current状态转为Drawing状态</span></span><br><span class="line">        |<span class="built_in">doCommitTransactions</span>();</span><br><span class="line">        |--&gt;SurfaceFlinger::<span class="built_in">doCommitTransactions</span>()</span><br><span class="line">                |<span class="comment">// 处理以及被移除的layer集合 mLayersPendingRemoval。释放buffer，从layersSortedByZ移除，加入到mOffscreenLayers</span></span><br><span class="line">                |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; l : mLayersPendingRemoval)</span><br><span class="line">                    |l-&gt;<span class="built_in">latchAndReleaseBuffer</span>();</span><br><span class="line">                    |mCurrentState.layersSortedByZ.<span class="built_in">remove</span>(l);</span><br><span class="line">|mOffscreenLayers.<span class="built_in">emplace</span>(l.<span class="built_in">get</span>());</span><br><span class="line">|mLayersPendingRemoval.<span class="built_in">clear</span>();</span><br><span class="line">                |<span class="comment">//【核心步骤】</span></span><br><span class="line">            |mDrawingState = mCurrentState;</span><br><span class="line">|mCurrentState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line">|<span class="keyword">if</span> (mVisibleRegionsDirty)</span><br><span class="line">                    |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; rootLayer : mDrawingState.layersSortedByZ)</span><br><span class="line">                        |<span class="comment">// 遍历所有的根layer，把所有子Layer的mCurrentChildren赋值给mDrawingChildren</span></span><br><span class="line">                        |rootLayer-&gt;<span class="built_in">commitChildList</span>();</span><br><span class="line">|mDrawingChildren = mCurrentChildren;</span><br><span class="line">|mDrawingParent = mCurrentParent;</span><br><span class="line">|mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">|<span class="comment">// 如果还有待处理的事务，请求下一个SF vsync</span></span><br><span class="line">|<span class="keyword">if</span> (<span class="built_in">transactionFlushNeeded</span>())</span><br><span class="line">    |<span class="built_in">setTransactionFlags</span>(eTransactionFlushNeeded);</span><br><span class="line">|mustComposite |= shouldCommit;</span><br><span class="line">|<span class="comment">//【5】、latchBuffers 相当于以前的handlePageFlip 流程</span></span><br><span class="line">|   <span class="comment">//【如果有新的buffer的layer大于0，并且拿到了buffer，SurfaceFlinger::latchBuffers()函数返回true，执行 SurfaceFlinger::composite 】</span></span><br><span class="line">|mustComposite |= <span class="built_in">latchBuffers</span>();</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">latchBuffers</span>() <span class="comment">//【详细内容，见 latchBuffers() 章节】</span></span><br><span class="line">    |layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime, expectedPresentTime)</span><br><span class="line">    |<span class="comment">//父类Layer的 latchBuffer 返回 false, 子类只有 BufferLayer 重载了 latchBuffer </span></span><br><span class="line">    |--&gt;BufferLayer.<span class="built_in">latchBuffer</span>(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> <span class="comment">/*latchTime*/</span>, <span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span><br><span class="line">    |<span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime, expectedPresentTime);</span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">updateTexImage</span>(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> latchTime,<span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span><br><span class="line">|<span class="comment">//【6】、计算边界、脏区域</span></span><br><span class="line">|<span class="built_in">updateLayerGeometry</span>();</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">updateLayerGeometry</span>()</span><br><span class="line">    |<span class="keyword">if</span> (mVisibleRegionsDirty) <span class="comment">//【mVisibleRegionsDirty在有新的Layer增加时设置为 true 】</span></span><br><span class="line">        |<span class="comment">/* 调用每个Layer的 computeBounds 方法</span></span><br><span class="line"><span class="comment">           计算每个Layer的以下边界：</span></span><br><span class="line"><span class="comment">        mSourceBounds  应用任何变换之前以及由其父对象裁剪之前的Layer边界。</span></span><br><span class="line"><span class="comment">        mBounds   Layer空间中的Layer边界。mSourceBounds 和 Layer的裁剪矩形的交集，再和其父空间交集</span></span><br><span class="line"><span class="comment">        mScreenBounds  Layer在屏幕上的空间。由 mBounds transform转换而来 */</span></span><br><span class="line">        |<span class="built_in">computeLayerBounds</span>();</span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">computeLayerBounds</span>()</span><br><span class="line">            |<span class="type">const</span> FloatRect maxBounds = <span class="built_in">getMaxDisplayBounds</span>();</span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : mDrawingState.layersSortedByZ)</span><br><span class="line">                    |layer-&gt;<span class="built_in">computeBounds</span>(maxBounds, ui::<span class="built_in">Transform</span>(), <span class="number">0.f</span> <span class="comment">/* shadowRadius */</span>);</span><br><span class="line">|<span class="comment">// mLayersPendingRefresh 参见步骤[5] latchBuffers()</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh)<span class="comment">// mLayersPendingRefresh 存储中能拿到 buffer的layer</span></span><br><span class="line">        |Region visibleReg;</span><br><span class="line">|visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">|<span class="comment">// 对每个包含当前layer的显示器的脏区域初始化为 Layer.mScreenBounds</span></span><br><span class="line">|<span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">|<span class="comment">// mLayersPendingRefresh这个集合表示有新的buffer更新，并且能拿到buffer的layer。</span></span><br><span class="line">    |<span class="comment">// 在 SurfaceFlinger::latchBuffers()流程中添加，此时清空此集合</span></span><br><span class="line">|mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">|<span class="comment">// 非开机阶段，mustComposite==true情况下将执行合成步骤 SurfaceFlinger::composite</span></span><br><span class="line">|<span class="keyword">return</span> mustComposite &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER);</span><br></pre></td></tr></table></figure><h5 id="latchBuffers"><a href="#latchBuffers" class="headerlink" title="latchBuffers()"></a>latchBuffers()</h5><ul><li>因为使用 BufferStateLayer + BBQ ， latchBuffer 流程相比Android12以前逻辑要少很多</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">// SurfaceFlinger.mLayersWithQueuedFrames 存储有新buffer的layer</span></span><br><span class="line"><span class="comment">// SurfaceFlinger.mLayersPendingRefresh 存储mLayersWithQueuedFrames中能拿到 buffer的layer。用于更新显示设备的脏区域</span></span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">latchBuffers</span>()</span><br><span class="line">    |<span class="type">const</span> <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();<span class="comment">// perfetto 会记录这个时间</span></span><br><span class="line">|<span class="type">bool</span> visibleRegions = <span class="literal">false</span>;<span class="comment">// 用于 latchBuffer 的参数</span></span><br><span class="line">|<span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line">    |<span class="comment">// 【1、核心逻辑是把 有buffer更新的layer存储到set集合 mLayersWithQueuedFrames】</span></span><br><span class="line">    |mDrawingState.<span class="built_in">traverse</span>(...)</span><br><span class="line">    |<span class="comment">// layer 各种属性变化后都会设置 eTransactionNeeded 这个flag，比如尺寸，背景，位置，inputInfo、刷新率等等，几乎所有的变化都会设置eTransactionNeeded。</span></span><br><span class="line">    |<span class="keyword">if</span> (layer-&gt;<span class="built_in">clearTransactionFlags</span>(eTransactionNeeded) || mForceTransactionDisplayChange)</span><br><span class="line">            |<span class="comment">//赋值 mDrawingState.transform</span></span><br><span class="line">            |<span class="comment">//mDrawingStateModified = mDrawingState.modified;mDrawingState.modified = false;</span></span><br><span class="line">            |<span class="type">const</span> <span class="type">uint32_t</span> flags = layer-&gt;<span class="built_in">doTransaction</span>(<span class="number">0</span>);</span><br><span class="line">|<span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">                |mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">|<span class="comment">// layer有新buffer时，hasReadyFrame() 返回true</span></span><br><span class="line">|<span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>())</span><br><span class="line">|<span class="comment">// shouldPresentNow函数，对于 BufferStateLayer 而言，有buffer的来了，就返回true</span></span><br><span class="line">            |<span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime))</span><br><span class="line">                |<span class="comment">//【2、把有新buffer的layer，加入set集合 mLayersWithQueuedFrames】</span></span><br><span class="line">                |mLayersWithQueuedFrames.<span class="built_in">emplace</span>(layer);</span><br><span class="line">|mForceTransactionDisplayChange = <span class="literal">false</span>;</span><br><span class="line">|<span class="comment">// 【3、mLayersWithQueuedFrames不为空，则调用集合中每个layer的 latchBuffer 函数】</span></span><br><span class="line">|<span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>())</span><br><span class="line">        |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames)</span><br><span class="line">            |<span class="comment">// latchBuffer 判断是否需要重新计算显示区域，由参数visibleRegions带回结果</span></span><br><span class="line">            |<span class="comment">//【4、获取buffer，并把 Layer.mDrawingState 中的属性变量转移到 BufferLayer.mBufferInfo 】</span></span><br><span class="line">            |<span class="comment">// mBufferInfo 用于 Layer中获取各种buffer信息相关的get方法</span></span><br><span class="line">            |<span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime, expectedPresentTime))</span><br><span class="line">                |--&gt;BufferLayer::<span class="built_in">latchBuffer</span>(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime, <span class="type">nsecs_t</span> expectedPresentTime)</span><br><span class="line">                |<span class="keyword">if</span> (!<span class="built_in">fenceHasSignaled</span>())</span><br><span class="line">                        |<span class="comment">// 【如果Fence还没有发送信号，请求 SF-vsync，并且函数返回，等一下次的vsync再处理这个buffer】</span></span><br><span class="line">                        |mFlinger-&gt;<span class="built_in">onLayerUpdate</span>();</span><br><span class="line">|<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">|BufferInfo oldBufferInfo = mBufferInfo;</span><br><span class="line">|<span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime, expectedPresentTime);</span><br><span class="line">|<span class="comment">// BufferStateLayer 和 以前使用的 BufferQueueLayer 是完全不同的步骤。大部分内容是debug用的</span></span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">updateTexImage</span>(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> latchTime, <span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span><br><span class="line">                        |<span class="type">const</span> <span class="type">int32_t</span> layerId = <span class="built_in">getSequence</span>();<span class="comment">// sequence，每个layer唯一，是个递增int</span></span><br><span class="line">                        |<span class="comment">//把 acquireFence 存储到 mFlinger-&gt;mTimeStats-&gt;mTimeStatsTracker[layerId].timeRecords[layerRecord.waitData].acquireFence</span></span><br><span class="line">                        |mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setAcquireFence</span>(layerId, frameNumber, acquireFence);</span><br><span class="line">|mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setLatchTime</span>(layerId, frameNumber, latchTime);</span><br><span class="line">|<span class="comment">//  perfetto 相应的数据源配置启用的情况下，记录 Fence 和 latchTime</span></span><br><span class="line">|mFlinger-&gt;mFrameTracer-&gt;<span class="built_in">traceFence</span>(...);</span><br><span class="line">                        |mFlinger-&gt;mFrameTracer-&gt;<span class="built_in">traceTimestamp</span>(...);</span><br><span class="line">                        |mDrawingStateModified = <span class="literal">false</span>;<span class="comment">// 修改为false，对应于步骤1中 Layer.doTransaction</span></span><br><span class="line">|<span class="built_in">updateActiveBuffer</span>();</span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">updateActiveBuffer</span>()</span><br><span class="line">                        |<span class="function"><span class="type">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">                        |<span class="comment">//mPendingBufferTransactions--</span></span><br><span class="line">                        |<span class="comment">// 调用到 latchBuffer 阶段，setBuffer 的事务就算处理完了，待处理的buffer数量计数器 mPendingBufferTransactions要减一</span></span><br><span class="line">                        |<span class="comment">//这里对应于SurfaceFlinger::setTransactionState函数中：mBufferCountTracker.increment(state.surface-&gt;localBinder());</span></span><br><span class="line">                        |<span class="comment">// mBufferCountTracker.increment 函数使 mPendingBufferTransactions 自增1</span></span><br><span class="line">                        |<span class="built_in">decrementPendingBufferCount</span>();</span><br><span class="line">|<span class="comment">// 把 mDrawingState 中的buffer、acquireFence、frameNumber 转移到 mBufferInfo</span></span><br><span class="line">|mBufferInfo.mBuffer = s.buffer;</span><br><span class="line">|mBufferInfo.mFence = s.acquireFence;</span><br><span class="line">|mBufferInfo.mFrameNumber = s.frameNumber;</span><br><span class="line">|<span class="comment">// mCurrentFrameNumber = mDrawingState.frameNumber; mPreviousFrameNumber = mCurrentFrameNumber;</span></span><br><span class="line">|<span class="built_in">updateFrameNumber</span>();</span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">updateFrameNumber</span>()</span><br><span class="line">                        |mPreviousFrameNumber = mCurrentFrameNumber;</span><br><span class="line">                        |mCurrentFrameNumber = mDrawingState.frameNumber;<span class="keyword">return</span> NO_ERROR;</span><br><span class="line">|<span class="comment">// 这个函数就是把 mDrawingState 中buffer相关信息的各种变量转移到 mBufferInfo 中</span></span><br><span class="line">                    |<span class="comment">// mBufferInfo.mDesiredPresentTime、mFenceTime、mFence、mTransform、mDataspace、mCrop、mScaleMode、mSurfaceDamage</span></span><br><span class="line">                    |<span class="comment">// mHdrMetadata、mApi、mTransformToDisplayInverse、mBufferSlot等等赋值    </span></span><br><span class="line">|<span class="built_in">gatherBufferInfo</span>();</span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">gatherBufferInfo</span>()</span><br><span class="line">                        |BufferLayer::<span class="built_in">gatherBufferInfo</span>();</span><br><span class="line">|<span class="function"><span class="type">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">|mBufferInfo.mFence = s.acquireFence;</span><br><span class="line">|mBufferInfo.mCrop = <span class="built_in">computeBufferCrop</span>(s);</span><br><span class="line">|mBufferInfo.mScaleMode = NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW;</span><br><span class="line">|mBufferInfo.mBufferSlot = mHwcSlotGenerator-&gt;<span class="built_in">getHwcCacheSlot</span>(s.clientCacheId);</span><br><span class="line">|<span class="comment">//....</span></span><br><span class="line">|<span class="comment">// 后边的代码是判断 是否需要重新计算显示区域</span></span><br><span class="line">                    |<span class="comment">// 大致情况是：当前是第一个buffer、裁剪区域变化了，旋转变了，缩放变了，宽高变了，透明度变了，mTransformToDisplayInverse变了</span></span><br><span class="line">                    |<span class="comment">// 以上情况都需要重新计算显示区域    </span></span><br><span class="line">                    |<span class="keyword">if</span>(oldBufferInfo.mBuffer == <span class="literal">nullptr</span> || mBufferInfo.mCrop != oldBufferInfo.mCrop ....)</span><br><span class="line">||recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">|<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                |<span class="comment">//【5、如果 latchBuffer 返回true，把layer加入向量集合 mLayersPendingRefresh 】</span></span><br><span class="line">                |<span class="comment">// 依据 latchBuffer 逻辑，latchBuffer 返回false，通常是由于 Fence 还没有发送信号。当然还有其他细节原因，这里未贴出代码。</span></span><br><span class="line">                |<span class="comment">//【可以说，mLayersPendingRefresh 保存了GPU绘制已经完成的layer】    </span></span><br><span class="line">                |mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">|newDataLatched = <span class="literal">true</span>;</span><br><span class="line">|<span class="comment">// Layer.surfaceDamageRegion = mBufferInfo.mSurfaceDamage;</span></span><br><span class="line">|layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">|<span class="comment">//回到 SurfaceFlinger::latchBuffers() 函数</span></span><br><span class="line">    |<span class="comment">// latchBuffer 函数，由参数 visibleRegions 返回 是否需要重新计算显示区域</span></span><br><span class="line">    |<span class="comment">// 这里把结果添加到 mVisibleRegionsDirty 变量中</span></span><br><span class="line">|mVisibleRegionsDirty |= visibleRegions; </span><br><span class="line">|<span class="comment">// 如果有新的buffer的layer大于0，并且 拿到了buffer，</span></span><br><span class="line">    |   <span class="comment">// 那么SurfaceFlinger::latchBuffers()函数返回true，表示需要执行合成步骤 SurfaceFlinger::composite </span></span><br><span class="line">    |<span class="comment">//【6、如果有新的buffer的layer数量大于0，并且 拿到了buffer，SurfaceFlinger::latchBuffers()函数返回true，执行 SurfaceFlinger::composite 】</span></span><br><span class="line">|<span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br></pre></td></tr></table></figure><h4 id="SurfaceFlinger-composite"><a href="#SurfaceFlinger-composite" class="headerlink" title="SurfaceFlinger::composite"></a>SurfaceFlinger::composite</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码SurfaceFlinger::<span class="built_in">composite</span>(<span class="type">nsecs_t</span> frameTime, <span class="type">int64_t</span> vsyncId)</span><br><span class="line">|<span class="comment">// 【1】准备合成的参数    </span></span><br><span class="line">|compositionengine::CompositionRefreshArgs refreshArgs;</span><br><span class="line">|<span class="comment">/*</span></span><br><span class="line"><span class="comment">    SmallMap&lt;IBinder, DisplayDevice&gt; mDisplays;</span></span><br><span class="line"><span class="comment">    合成是以 mDisplays 元素中的顺序去合成的</span></span><br><span class="line"><span class="comment">    内置的显示器，是在开机的时候加入的，因此按照顺序合成的话，内置显示器要优先于 外部显示器 和 虚拟显示器</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">|   <span class="type">const</span> <span class="keyword">auto</span>&amp; displays = <span class="built_in">FTL_FAKE_GUARD</span>(mStateLock, mDisplays);</span><br><span class="line">|<span class="comment">// outputs 为Output的vector</span></span><br><span class="line">|refreshArgs.outputs.<span class="built_in">reserve</span>(displays.<span class="built_in">size</span>());<span class="comment">// 增加容器的大小为显示屏的大小</span></span><br><span class="line">|<span class="comment">// 遍历显示设备</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, display] : displays)</span><br><span class="line">    |<span class="comment">// DisplayDevice.mCompositionDisplay 类型 android::compositionengine::Display，继承 Output</span></span><br><span class="line">    |<span class="comment">// outputs 代表所有需要合成的显示器</span></span><br><span class="line">    |refreshArgs.outputs.<span class="built_in">push_back</span>(display-&gt;<span class="built_in">getCompositionDisplay</span>());<span class="comment">//【所有需要合成工作的显示设备】</span></span><br><span class="line">|<span class="comment">// 遍历 mDrawingState.layersSortedByZ，这个 layersSortedByZ 存储了所有的的layer</span></span><br><span class="line">|<span class="comment">// 以Z轴顺序遍历 mDrawingState.layersSortedByZ ，从底层开始遍历</span></span><br><span class="line">|mDrawingState.<span class="built_in">traverseInZOrder</span>(...)</span><br><span class="line">    |<span class="comment">//并非所有种类的layer都能通过 Layer.getCompositionEngineLayerFE() 拿到LayerFE对象。是有显示界面的才有返回对象</span></span><br><span class="line">    |<span class="comment">//父类 Layer.getCompositionEngineLayerFE() 返回 nullptr</span></span><br><span class="line">    |<span class="comment">//只有 BufferLayer 和 EffectLayer 实现了这个方法</span></span><br><span class="line">    |<span class="comment">// getCompositionEngineLayerFE 这个函数就是返回layer自身，并强转为Layer父类 compositionengine::LayerFE 类型</span></span><br><span class="line">    |<span class="keyword">if</span> (<span class="keyword">auto</span> layerFE = layer-&gt;<span class="built_in">getCompositionEngineLayerFE</span>())</span><br><span class="line">        |<span class="comment">// refreshArgs.layers 是 std::vector&lt;sp&lt;compositionengine::LayerFE&gt;&gt; 类型</span></span><br><span class="line">        |<span class="comment">// 这个是以 Z 轴顺序添加到 layers 中的</span></span><br><span class="line">        |refreshArgs.layers.<span class="built_in">push_back</span>(layerFE);<span class="comment">//【添加所有参与合成的layer】</span></span><br><span class="line">|<span class="comment">//mLayersWithQueuedFrames 是有新的帧数据的Layer</span></span><br><span class="line">|<span class="comment">//  把有帧数据的Layer转移到 refreshArgs.layersWithQueuedFrames</span></span><br><span class="line">|refreshArgs.layersWithQueuedFrames.<span class="built_in">reserve</span>(mLayersWithQueuedFrames.<span class="built_in">size</span>());</span><br><span class="line">|mCompositionEngine-&gt;<span class="built_in">present</span>(refreshArgs);</span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">auto</span> layer : mLayersWithQueuedFrames)</span><br><span class="line">    |<span class="keyword">if</span> (<span class="keyword">auto</span> layerFE = layer-&gt;<span class="built_in">getCompositionEngineLayerFE</span>())</span><br><span class="line">        |refreshArgs.layersWithQueuedFrames.<span class="built_in">push_back</span>(layerFE);</span><br><span class="line">|<span class="comment">// 把准备好的合成的参数，传入 CompositionEngine 开始合成工作</span></span><br><span class="line">|mCompositionEngine-&gt;<span class="built_in">present</span>(refreshArgs);</span><br><span class="line">|--&gt;CompositionEngine::<span class="built_in">present</span>(CompositionRefreshArgs&amp; args)</span><br><span class="line">    |<span class="comment">// 【2】如果存在新的buffer处理，mNeedsAnotherUpdate设置为true，</span></span><br><span class="line">|<span class="built_in">preComposition</span>(args);</span><br><span class="line">|<span class="comment">// LayerFESet 是 unordered_set 类型</span></span><br><span class="line">|LayerFESet latchedLayers; <span class="comment">// using LayerFESet = std::unordered_set&lt;sp&lt;LayerFE&gt;, LayerFESpHash&gt;; </span></span><br><span class="line">|<span class="comment">// 【3】遍历所有需要合成输出的显示设备  【核心是把显示区域相关数据转存到 OutputLayer 的mState对象】</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs)<span class="comment">// 第一层循环，遍历所有的显示设备</span></span><br><span class="line">        |<span class="comment">// 调用每个显示设备的 prepare 方法</span></span><br><span class="line">        |output-&gt;<span class="built_in">prepare</span>(args, latchedLayers);</span><br><span class="line">|--&gt;Output::<span class="built_in">prepare</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs, LayerFESet&amp; geomSnapshots)</span><br><span class="line">            |<span class="built_in">rebuildLayerStacks</span>(refreshArgs, geomSnapshots);</span><br><span class="line">|--&gt;Output::<span class="built_in">rebuildLayerStacks</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs, LayerFESet&amp; layerFESet)</span><br><span class="line">                |<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();<span class="comment">// editState() 返回 OutputCompositionState 类型的  Output.mState;</span></span><br><span class="line">|compositionengine::Output::CoverageState coverage&#123;layerFESet&#125;;</span><br><span class="line">|<span class="comment">// 1、从顶层到底层遍历所有参与合成的Layer，累积计算 覆盖区域、完全不透明区域、脏区域</span></span><br><span class="line">                |<span class="comment">// 2、存储当前层的显示区域、排除透明区域的显示区域、被覆盖区域、显示器空间显示区域、阴影区域等到 当前显示设备上的OutputLayer的mState对象</span></span><br><span class="line">|<span class="built_in">collectVisibleLayers</span>(refreshArgs, coverage);</span><br><span class="line">|--&gt;Output::<span class="built_in">collectVisibleLayers</span>(CompositionRefreshArgs&amp; refreshArgs,Output::CoverageState&amp; coverage)</span><br><span class="line">                    |<span class="comment">// 从顶层到底层开始遍历所有Layer，以便于计算哪些可以显示。 这个过程中，每层的显示区域是不断减少的，相反，覆盖区域是不断增大的</span></span><br><span class="line">                    |<span class="keyword">for</span> (<span class="keyword">auto</span> layer : <span class="built_in">reversed</span>(refreshArgs.layers))</span><br><span class="line">                        |<span class="comment">// 1、从顶层到底层遍历所有参与合成的Layer，累积计算 覆盖区域、完全不透明区域、脏区域</span></span><br><span class="line">                        |<span class="comment">// 2、【如果显示设备没有对应的 OutputLayer，创建 OutputLayer 同时创建 HWCLayer，并作为 OutputLayer.mState 的成员】</span></span><br><span class="line">                        |<span class="comment">// 3、存储当前层的显示区域、排除透明区域的显示区域、被覆盖区域、显示器空间显示区域、阴影区域等到 当前显示设备上的 OutputLayer 的mState对象</span></span><br><span class="line">                        |<span class="comment">//OutputLayer.mState.visibleRegion、visibleNonTransparentRegion、coveredRegion、outputSpaceVisibleRegion、shadowRegion</span></span><br><span class="line">                        |<span class="comment">//outputSpaceBlockingRegionHint</span></span><br><span class="line">                        |<span class="comment">// 4、Output.mPendingOutputLayersOrderedByZ.emplace_back(std::move(outputLayer));</span></span><br><span class="line">                        |<span class="built_in">ensureOutputLayerIfVisible</span>(layer, coverage);</span><br><span class="line">                    |<span class="comment">// setReleasedLayers 函数会遍历 Output.mCurrentOutputLayersOrderedByZ</span></span><br><span class="line">                    |<span class="comment">// 此时 Output.mCurrentOutputLayersOrderedByZ 中会在当前vsync显示的layer都转移到了mPendingOutputLayersOrderedByZ</span></span><br><span class="line">|<span class="comment">// 这里会把mCurrentOutputLayersOrderedByZ余下的Layer中，在当前vsync，入队新的buffer的layer放入到 Output.mReleasedLayers 中</span></span><br><span class="line">                    |<span class="comment">// 就是说，mReleasedLayers是一些即将移除的的layer，但是当前vsync还在生产帧数据的layer</span></span><br><span class="line">|<span class="built_in">setReleasedLayers</span>(refreshArgs);</span><br><span class="line">|<span class="comment">// 把 Output.mPendingOutputLayersOrderedByZ 转到 Output.mCurrentOutputLayersOrderedByZ //使用的move赋值</span></span><br><span class="line">                    |<span class="comment">// 【每个vsync内，Output中存储的OutputLayer，都是最新即将要显示的Layer】</span></span><br><span class="line">|<span class="built_in">finalizePendingOutputLayers</span>();</span><br><span class="line">|<span class="type">const</span> ui::Transform&amp; tr = outputState.transform;</span><br><span class="line">|Region undefinedRegion&#123;outputState.displaySpace.<span class="built_in">getBoundsAsRect</span>()&#125;;</span><br><span class="line">|<span class="comment">// 整个显示空间 减去 所有Layer的不透明覆盖区域 为未定义的区域</span></span><br><span class="line">|undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(coverage.aboveOpaqueLayers));</span><br><span class="line">|outputState.undefinedRegion = undefinedRegion;</span><br><span class="line">|<span class="comment">// 把计算好的脏区域传入 outputState.dirtyRegion // Output::postFramebuffer() 中被清空</span></span><br><span class="line">|outputState.dirtyRegion.<span class="built_in">orSelf</span>(coverage.dirtyRegion);</span><br><span class="line">|<span class="comment">// 【4】把状态属性转移到 BufferLayer.mCompositionState。这个对象是 compositionengine::LayerFECompositionState 类型</span></span><br><span class="line">    |<span class="comment">// 可以通过 LayerFE.getCompositionState() 获取合成状态对象。不算EffectLayer的话，其实就是就是获取 BufferLayer.mCompositionState</span></span><br><span class="line">|<span class="built_in">updateLayerStateFromFE</span>(args);</span><br><span class="line">|--&gt;CompositionEngine::<span class="built_in">updateLayerStateFromFE</span>(CompositionRefreshArgs&amp; args)</span><br><span class="line">        |<span class="comment">// 从前端layer中更新合成状态</span></span><br><span class="line">        |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs)</span><br><span class="line">            |output-&gt;<span class="built_in">updateLayerStateFromFE</span>(args);</span><br><span class="line">|--&gt;Output::<span class="built_in">updateLayerStateFromFE</span>(<span class="type">const</span> CompositionRefreshArgs&amp; args)</span><br><span class="line">                |<span class="comment">// SurfaceFlinger.mVisibleRegionsDirty 为true时， args.updatingGeometryThisFrame=true</span></span><br><span class="line">                |<span class="comment">// 有新的Layer增加时 mVisibleRegionsDirty 为true</span></span><br><span class="line">                |layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">prepareCompositionState</span>(args.updatingGeometryThisFrame ? LayerFE::StateSubset::GeometryAndContent</span><br><span class="line">                                                                : LayerFE::StateSubset::Content);</span><br><span class="line">|--&gt;Layer::<span class="built_in">prepareCompositionState</span>(compositionengine::LayerFE::StateSubset subset)</span><br><span class="line">                    |<span class="comment">// 根据 StateSubset 的类型选择以下函数的几种组合去执行</span></span><br><span class="line">                    |<span class="comment">/* prepareBasicGeometry更新BufferLayer状态对象LayerFECompositionState(mCompositionState)的以下属性:</span></span><br><span class="line"><span class="comment">                     outputFilter、isVisible、isOpaque、shadowRadius、contentDirty、geomLayerBounds、geomLayerTransform、</span></span><br><span class="line"><span class="comment">                     geomInverseLayerTransform、transparentRegionHint、blendMode、alpha、backgroundBlurRadius、blurRegions、stretchEffect </span></span><br><span class="line"><span class="comment">                       同时设置 Layer.contentDirty = false;*/</span></span><br><span class="line">                    |<span class="built_in">prepareBasicGeometryCompositionState</span>();</span><br><span class="line"><span class="comment">/*更新BufferLayer状态对象mCompositionState的以下属性:</span></span><br><span class="line"><span class="comment">geomBufferSize、geomContentCrop、geomCrop、geomBufferTransform、</span></span><br><span class="line"><span class="comment">geomBufferUsesDisplayInverseTransform|geomUsesSourceCrop、isSecure、metadata</span></span><br><span class="line"><span class="comment">  就是集合图形相关的属性*/</span></span><br><span class="line">|<span class="built_in">prepareGeometryCompositionState</span>();</span><br><span class="line"><span class="comment">/* preparePerFrameCompositionState更新BufferLayer状态对象mCompositionState的以下属性:</span></span><br><span class="line"><span class="comment">      compositionType、hdrMetadata、compositionType、buffer、bufferSlot、acquireFence、frameNumber、sidebandStreamHasFrame</span></span><br><span class="line"><span class="comment">      forceClientComposition、isColorspaceAgnostic、dataspace、colorTransform、colorTransformIsIdentity、surfaceDamage</span></span><br><span class="line"><span class="comment">      hasProtectedContent、dimmingEnabled、isOpaque、stretchEffect、blurRegions、backgroundBlurRadius、fps</span></span><br><span class="line"><span class="comment">   就是帧数据相关的属性*/</span></span><br><span class="line">|<span class="built_in">preparePerFrameCompositionState</span>();</span><br><span class="line">|</span><br><span class="line">|<span class="comment">// 调用每个显示设备的 present 方法</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; output : args.outputs)</span><br><span class="line">        |output-&gt;<span class="built_in">present</span>(args);</span><br><span class="line">|--&gt;Output::<span class="built_in">present</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line">            |<span class="comment">// 2.4.1 更新Output合成状态对象OutputCompositionState</span></span><br><span class="line">            |<span class="comment">// Output.mState的 colorMode、dataspace、renderIntent、targetDataspace 属性 </span></span><br><span class="line">            |<span class="built_in">updateColorProfile</span>(refreshArgs);</span><br><span class="line">|<span class="comment">// 2.4.2 更新 OutputLayer.mState.forceClientComposition、displayFrame、sourceCrop、bufferTransform、dataspace</span></span><br><span class="line">            |<span class="comment">// 【显示区域相关属性已经在rebuildLayerStacks阶段更新完成，至此OutputLayer.mState的属性基本全更新完了】   </span></span><br><span class="line">|<span class="built_in">updateCompositionState</span>(refreshArgs);</span><br><span class="line">|--&gt;Output::<span class="built_in">updateCompositionState</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line">                |<span class="comment">// 查找最顶层使用背景模糊的 OutputLayer</span></span><br><span class="line">                |mLayerRequestingBackgroundBlur = <span class="built_in">findLayerRequestingBackgroundComposition</span>();</span><br><span class="line">|<span class="comment">// 如果有 OutputLayer 使用了背景模糊，则必须使用 GPU 合成</span></span><br><span class="line">                |<span class="type">bool</span> forceClientComposition = mLayerRequestingBackgroundBlur != <span class="literal">nullptr</span>;</span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">        |<span class="comment">/* 更新每个OutputLayer OutputLayerState 的以下属性</span></span><br><span class="line"><span class="comment">        |forceClientComposition、displayFrame、sourceCrop、bufferTransform、bufferTransform、dataspace */</span></span><br><span class="line">                    |layer-&gt;<span class="built_in">updateCompositionState</span>(refreshArgs.updatingGeometryThisFrame,refreshArgs.devOptForceClientComposition ||</span><br><span class="line">                    |                                  forceClientComposition, refreshArgs.internalDisplayRotationFlags)</span><br><span class="line">                    |<span class="comment">// 到最顶层使用背景模糊的 OutputLayer 之前都强制使用 GPU 合成</span></span><br><span class="line">                    |<span class="keyword">if</span> (mLayerRequestingBackgroundBlur == layer)</span><br><span class="line">                    |   |forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">|<span class="comment">// 2.4.3</span></span><br><span class="line">|<span class="built_in">planComposition</span>();</span><br><span class="line">|--&gt;Output::<span class="built_in">planComposition</span>()</span><br><span class="line">                |<span class="comment">// 需要 ro.surface_flinger.enable_layer_caching 这个属性为true，mLayerCachingEnabled=true，然后才会启用 Planner</span></span><br><span class="line">                |<span class="comment">// Planner 似乎还未启用，目前查几台机器都未启用</span></span><br><span class="line">                |<span class="keyword">if</span> (!mPlanner || !<span class="built_in">getState</span>().isEnabled)</span><br><span class="line">                    |<span class="keyword">return</span>;</span><br><span class="line">|<span class="comment">// 把Layer扁平化到数据结构  compositionengine::impl::OutputLayerCompositionState.overrideInfo</span></span><br><span class="line">                |<span class="comment">// 缓存layer，扁平化到override中，下次再用其中的数据。TODO：似乎还未启用，暂时忽略    </span></span><br><span class="line">|mPlanner-&gt;<span class="built_in">plan</span>(<span class="built_in">getOutputLayersOrderedByZ</span>());</span><br><span class="line">|<span class="comment">// 2.4.4 把状态属性写入HWC待执行的缓存，等待执行</span></span><br><span class="line">|<span class="built_in">writeCompositionState</span>(refreshArgs);</span><br><span class="line">|--&gt;Output::<span class="built_in">writeCompositionState</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line">                |<span class="comment">// 遍历当前显示器的 OutputLayer</span></span><br><span class="line">                |<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">                    |<span class="comment">// 前边一大段是 透视图层 的处理</span></span><br><span class="line">                    |<span class="comment">// 如果上一个Layer的buffer和当前的Layer的buffer一样，那么忽略当前Layer</span></span><br><span class="line">                    |<span class="comment">// 下面直接看主逻辑</span></span><br><span class="line">                    |layer-&gt;<span class="built_in">writeStateToHWC</span>(includeGeometry, skipLayer, z++, overrideZ, isPeekingThrough);</span><br><span class="line">|--&gt;OutputLayer::<span class="built_in">writeStateToHWC</span>(<span class="type">bool</span> includeGeometry, <span class="type">bool</span> skipLayer, <span class="type">uint32_t</span> z,<span class="type">bool</span> zIsOverridden, <span class="type">bool</span> isPeekingThrough)</span><br><span class="line">                        |<span class="type">const</span> <span class="keyword">auto</span>&amp; state = <span class="built_in">getState</span>();</span><br><span class="line">|<span class="keyword">if</span> (!state.hwc) <span class="keyword">return</span>;<span class="comment">//如果没有HWC接口，直接返回</span></span><br><span class="line">|<span class="keyword">auto</span>&amp; hwcLayer = (*state.hwc).hwcLayer;</span><br><span class="line">|<span class="keyword">if</span> (!hwcLayer)<span class="keyword">return</span>; <span class="comment">// 如果没有 hwcLayer 直接返回</span></span><br><span class="line">|<span class="comment">// 获取 Layer 的 LayerFECompositionState ，只有 BufferLayer和 EffectLayer 有</span></span><br><span class="line">|<span class="type">const</span> <span class="keyword">auto</span>* outputIndependentState = <span class="built_in">getLayerFE</span>().<span class="built_in">getCompositionState</span>();</span><br><span class="line">|<span class="keyword">if</span> (!outputIndependentState)<span class="keyword">return</span>;</span><br><span class="line">|<span class="comment">// 合成类型</span></span><br><span class="line">|<span class="keyword">auto</span> requestedCompositionType = outputIndependentState-&gt;compositionType;</span><br><span class="line">|<span class="comment">// 有忽略的layer，新增的layer</span></span><br><span class="line">|<span class="keyword">if</span> (... skipLayer || includeGeometry)</span><br><span class="line">                            |<span class="comment">// 写入HWC依赖显示设备的几何图形信息</span></span><br><span class="line">                            |<span class="comment">// HWC2::Layer.setDisplayFrame、setSourceCrop、setZOrder、setTransform</span></span><br><span class="line">                            |<span class="built_in">writeOutputDependentGeometryStateToHWC</span>(hwcLayer.<span class="built_in">get</span>(), requestedCompositionType, z);</span><br><span class="line">|<span class="comment">// 写入HWC不依赖显示设备的几何图形信息</span></span><br><span class="line">                            |<span class="comment">// HWC2::Layer.setBlendMode、setPlaneAlpha、setLayerGenericMetadata</span></span><br><span class="line">                            |<span class="comment">//skipLayer 为true的话，alpha=0.0f 颜色设置为完全透明</span></span><br><span class="line">|<span class="built_in">writeOutputIndependentGeometryStateToHWC</span>(hwcLayer.<span class="built_in">get</span>(), *outputIndependentState, skipLayer);</span><br><span class="line">|<span class="comment">// 写入HWC依赖显示设备的每个帧状态 </span></span><br><span class="line">                        |<span class="comment">// HWC2::Layer.etVisibleRegion、setBlockingRegion、setDataspace、setBrightness</span></span><br><span class="line">|<span class="built_in">writeOutputDependentPerFrameStateToHWC</span>(hwcLayer.<span class="built_in">get</span>());</span><br><span class="line">|<span class="comment">// 写入HWC不依赖显示设备的每帧状态</span></span><br><span class="line">                        |<span class="comment">// HWC2::Layer.setColorTransform、setSurfaceDamage、setPerFrameMetadata、setBuffer</span></span><br><span class="line">|<span class="built_in">writeOutputIndependentPerFrameStateToHWC</span>(hwcLayer.<span class="built_in">get</span>(), *outputIndependentState, requestedCompositionType, skipLayer);</span><br><span class="line">|<span class="comment">// 写入合成类型  HWC2::Layer.setCompositionType</span></span><br><span class="line">|<span class="built_in">writeCompositionTypeToHWC</span>(hwcLayer.<span class="built_in">get</span>(), requestedCompositionType, isPeekingThrough, skipLayer);</span><br><span class="line">|<span class="comment">// 2.4.5 设置显示设备的颜色矩阵，做颜色变换，色盲、护眼模式等</span></span><br><span class="line">|<span class="built_in">setColorTransform</span>(refreshArgs);</span><br><span class="line">|<span class="comment">// 2.4.6 给虚拟显示屏用的。正常主屏使用 FramebufferSurface ，啥事也不做</span></span><br><span class="line">|<span class="built_in">beginFrame</span>();</span><br><span class="line">|GpuCompositionResult result;</span><br><span class="line">|<span class="comment">// 是否可以预测合成策略--Android 13 新增</span></span><br><span class="line">            |<span class="comment">// 去掉一些小概率原因，总结：如果上次不全是硬件合成，且存在GPU合成Layer时，返回true    </span></span><br><span class="line">|<span class="type">const</span> <span class="type">bool</span> predictCompositionStrategy = <span class="built_in">canPredictCompositionStrategy</span>(refreshArgs);</span><br><span class="line">|<span class="keyword">if</span> (predictCompositionStrategy)</span><br><span class="line">                |<span class="comment">// 异步执行 chooseCompositionStrategy --Android 13 新增</span></span><br><span class="line">                |<span class="comment">// 就是 chooseCompositionStrategy 和 GPU合成 并行执行。用以节约时间</span></span><br><span class="line">                |result = <span class="built_in">prepareFrameAsync</span>(refreshArgs);</span><br><span class="line">|<span class="keyword">else</span></span><br><span class="line">                |<span class="comment">//核心逻辑还是确认使用 客户端合成 还是 使用硬件合成</span></span><br><span class="line">                |<span class="built_in">prepareFrame</span>();<span class="comment">//【转“Output::prepareFrame()”章节】</span></span><br><span class="line">|--&gt;Output::<span class="built_in">prepareFrame</span>()<span class="comment">// 详情参见：prepareFrame() 章节</span></span><br><span class="line">                    |<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();</span><br><span class="line">                    |std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt; changes;</span><br><span class="line">|<span class="type">bool</span> success = <span class="built_in">chooseCompositionStrategy</span>(&amp;changes);<span class="comment">//选择合成策略</span></span><br><span class="line">|<span class="built_in">resetCompositionStrategy</span>();<span class="comment">// 重置合成策略的变量</span></span><br><span class="line">|outputState.previousDeviceRequestedChanges = changes;</span><br><span class="line">|outputState.previousDeviceRequestedSuccess = success;</span><br><span class="line">|<span class="keyword">if</span> (success)</span><br><span class="line">                        |<span class="built_in">applyCompositionStrategy</span>(changes);<span class="comment">//应用合成策略</span></span><br><span class="line">|<span class="built_in">finishPrepareFrame</span>();<span class="comment">// 用于虚拟屏</span></span><br><span class="line">|<span class="comment">//继续 Output::present(const compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span></span><br><span class="line">|<span class="built_in">devOptRepaintFlash</span>(refreshArgs);<span class="comment">// doDebugFlashRegions当打开开发者选项中的“显示Surface刷新”时，额外为产生变化的图层绘制闪烁动画</span></span><br><span class="line">|<span class="comment">// GPU 合成，新增了一些对 prepareFrameAsync 结果的处理逻辑</span></span><br><span class="line">|<span class="built_in">finishFrame</span>(refreshArgs, std::<span class="built_in">move</span>(result));<span class="comment">//【转“Output::finishFrame”章节】</span></span><br><span class="line">|<span class="comment">//【转“Output::postFramebuffer()”】</span></span><br><span class="line">|<span class="built_in">postFramebuffer</span>();<span class="comment">// postFramebuffer 函数就是告诉HWC开始做最后的合成了,并显示。获取释放fence，</span></span><br><span class="line">|<span class="comment">// 渲染最新的 cached sets，需要开启了Planner。TODO：渲染设置了预期显示时间的buffer？</span></span><br><span class="line">|<span class="built_in">renderCachedSets</span>(refreshArgs);</span><br><span class="line">|<span class="built_in">postFrame</span>();<span class="comment">// 没啥东西输出log</span></span><br><span class="line">|<span class="built_in">postComposition</span>();<span class="comment">// 杂七杂八的合成后处理，对于 BufferStateLayer 最终要的是 releasePendingBuffer</span></span><br><span class="line">|--&gt;SurfaceFlinger::<span class="built_in">postComposition</span>() </span><br><span class="line">    |<span class="comment">// 省略一大段内容</span></span><br><span class="line">    |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer: mLayersWithQueuedFrames)</span><br><span class="line">        |<span class="comment">// 都是更新 FrameTracker、TimeStats 这些</span></span><br><span class="line">        |layer-&gt;<span class="built_in">onPostComposition</span>(display, glCompositionDoneFenceTime,mPreviousPresentFences[<span class="number">0</span>].fenceTime, compositorTiming);</span><br><span class="line">|layer-&gt;<span class="built_in">releasePendingBuffer</span>(<span class="comment">/*dequeueReadyTime*/</span> now);</span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">releasePendingBuffer</span>(<span class="type">nsecs_t</span> dequeueReadyTime)</span><br><span class="line">            |<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; handle : mDrawingState.callbackHandles)</span><br><span class="line">                |<span class="keyword">if</span> (handle-&gt;releasePreviousBuffer &amp;&amp; mDrawingState.releaseBufferEndpoint == handle-&gt;listener)</span><br><span class="line">                    |<span class="comment">// 这个 mPreviousReleaseCallbackId 在 BufferStateLayer::updateActiveBuffer() 赋值</span></span><br><span class="line">                    |<span class="comment">// mPreviousReleaseCallbackId = &#123;getCurrentBufferId(), mBufferInfo.mFrameNumber&#125;;</span></span><br><span class="line">                    |handle-&gt;previousReleaseCallbackId = mPreviousReleaseCallbackId;</span><br><span class="line">|<span class="keyword">break</span>;</span><br><span class="line">|<span class="comment">// 把 callback 加入 TransactionCallbackInvoker::mCompletedTransactions</span></span><br><span class="line">|mFlinger-&gt;<span class="built_in">getTransactionCallbackInvoker</span>().<span class="built_in">addCallbackHandles</span>(mDrawingState.callbackHandles, jankData);</span><br><span class="line">|<span class="comment">//【这里就是通过binder通信，回调到 APP 端BBQ执行 releaseBuffer 了】</span></span><br><span class="line">|mTransactionCallbackInvoker.<span class="built_in">sendCallbacks</span>(<span class="literal">false</span> <span class="comment">/* onCommitOnly */</span>);</span><br><span class="line">|--&gt;BpTransactionCompletedListener::<span class="built_in">onTransactionCompleted</span>(android::ListenerStats)</span><br><span class="line">|<span class="comment">// 如果还有新的buffer，需要请求新的vsync</span></span><br><span class="line">|<span class="keyword">if</span> (mCompositionEngine-&gt;<span class="built_in">needsAnotherUpdate</span>())</span><br><span class="line">    |<span class="built_in">scheduleCommit</span>(FrameHint::kNone)</span><br></pre></td></tr></table></figure><h5 id="Output-prepareFrame"><a href="#Output-prepareFrame" class="headerlink" title="Output::prepareFrame()"></a>Output::prepareFrame()</h5><ul><li>所谓 Client 合成，就是 HWC 的客户端 SurfaceFlinger 去合成，SurfaceFlinger 合成的话使用GPU合成，因此 Client 合成，即GPU合成</li><li>prepareFrame <strong>核心逻辑是确认使用 客户端合成 还是 使用硬件合成</strong></li><li>prepareFrame  函数中同  HWC服务 交互去确认是否有客户端合成，如果没有客户端合成，并可以忽略验证，那么会直接显示。流程到这里基本结束了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码CompositionEngine::<span class="built_in">present</span>(CompositionRefreshArgs&amp; args)</span><br><span class="line">|<span class="comment">//....</span></span><br><span class="line">|--&gt;Output::<span class="built_in">prepareFrame</span>()</span><br><span class="line">|<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();</span><br><span class="line">|std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt; changes;</span><br><span class="line">|<span class="type">bool</span> success = <span class="built_in">chooseCompositionStrategy</span>(&amp;changes);</span><br><span class="line">|--&gt;Display::<span class="built_in">chooseCompositionStrategy</span>(std::optional&lt;android::HWComposer::DeviceRequestedChanges&gt;* outChanges)</span><br><span class="line">    |<span class="comment">// 在最近的一次合成中如果有任意一个layer是 GPU 合成，则返回true</span></span><br><span class="line">    |<span class="type">const</span> <span class="type">bool</span> requiresClientComposition = <span class="built_in">anyLayersRequireClientComposition</span>();</span><br><span class="line">|<span class="type">status_t</span> result = hwc.<span class="built_in">getDeviceCompositionChanges</span>(*halDisplayId, requiresClientComposition,...outChanges);</span><br><span class="line">    |--&gt;HWComposer::<span class="built_in">getDeviceCompositionChanges</span>(HalDisplayId displayId, <span class="type">bool</span> frameUsesClientComposition,...outChanges)</span><br><span class="line">        |<span class="comment">// 如果有需要GPU合成的layer， canSkipValidate=false;</span></span><br><span class="line">        |<span class="comment">// 没有需要GPU合成的layer，如果Composer支持获得预期的展示时间，canSkipValidate=true;</span></span><br><span class="line">        |<span class="comment">// 没有需要GPU合成的layer，Composer 也不支持获得预期的当前时间，只有当我们知道我们不会提前呈现时，我们才能跳过验证。</span></span><br><span class="line">        |<span class="type">const</span> <span class="type">bool</span> canSkipValidate = &#123;...&#125;;</span><br><span class="line">|<span class="keyword">if</span> (canSkipValidate)</span><br><span class="line">            |sp&lt;Fence&gt; outPresentFence;</span><br><span class="line">            |<span class="type">uint32_t</span> state = UINT32_MAX;</span><br><span class="line">|<span class="comment">//如果可以跳过验证，则直接在屏幕上显示内容,否则执行 validate(HWC 检查各个图层的状态，并确定如何进行合成)</span></span><br><span class="line">            |<span class="comment">// numTypes返回合成类型需要变更的layer数量，numRequests 返回需要做getDisplayRequests请求的layer数量    </span></span><br><span class="line">            |hwcDisplay-&gt;<span class="built_in">presentOrValidate</span>(expectedPresentTime, &amp;numTypes, &amp;numRequests, &amp;outPresentFence, &amp;state);</span><br><span class="line">|<span class="keyword">if</span> (state == <span class="number">1</span>)</span><br><span class="line">                |<span class="comment">// 跳过了验证环节，直接显示了。这时直接返回</span></span><br><span class="line">                |std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">|hwcDisplay-&gt;<span class="built_in">getReleaseFences</span>(&amp;releaseFences);<span class="comment">// 显示成功，会返回 Fence fd</span></span><br><span class="line">|displayData.releaseFences = std::<span class="built_in">move</span>(releaseFences);</span><br><span class="line">|displayData.lastPresentFence = outPresentFence;</span><br><span class="line">|displayData.validateWasSkipped = <span class="literal">true</span>;</span><br><span class="line">|displayData.presentError = error;</span><br><span class="line">|<span class="keyword">return</span> NO_ERROR;</span><br><span class="line">|<span class="keyword">else</span></span><br><span class="line">            |<span class="comment">// HWC 检查各个图层的状态，并确定如何进行合成</span></span><br><span class="line">            |<span class="comment">// numTypes返回合成类型需要变更的layer数量，numRequests 返回需要做getDisplayRequests请求的layer数量</span></span><br><span class="line">            |hwcDisplay-&gt;<span class="built_in">validate</span>(expectedPresentTime, &amp;numTypes, &amp;numRequests);</span><br><span class="line">|<span class="comment">// composer3::Composition 为枚举类型：</span></span><br><span class="line">|<span class="comment">//&#123; INVALID = 0, CLIENT = 1,  DEVICE = 2,  SOLID_COLOR = 3,  CURSOR = 4,  SIDEBAND = 5,  DISPLAY_DECORATION = 6,&#125;; </span></span><br><span class="line">|std::unordered_map&lt;HWC2::Layer*, composer3::Composition&gt; changedTypes;</span><br><span class="line">|changedTypes.<span class="built_in">reserve</span>(numTypes);<span class="comment">// map扩容为numTypes</span></span><br><span class="line">|<span class="comment">// changedTypes 返回 map&lt;Layer，Composition&gt;  包含所有 与上次调用validateDisplay之前设置的合成类型不同的合成类型的Layer</span></span><br><span class="line">|hwcDisplay-&gt;<span class="built_in">getChangedCompositionTypes</span>(&amp;changedTypes);</span><br><span class="line">|<span class="comment">// 枚举 hal::DisplayRequest&#123;FLIP_CLIENT_TARGET = 1u , WRITE_CLIENT_TARGET_TO_OUTPUT = 2u ,&#125;</span></span><br><span class="line">        |<span class="comment">// 0 表示：指示客户端提供新的客户端目标缓冲区，即使没有为客户端合成标记任何layers。</span></span><br><span class="line">        |<span class="comment">// 1 表示：指示客户端将客户端合成的结果直接写入虚拟显示输出缓冲区。</span></span><br><span class="line">|<span class="keyword">auto</span> displayRequests = <span class="built_in">static_cast</span>&lt;hal::DisplayRequest&gt;(<span class="number">0</span>);</span><br><span class="line">|<span class="comment">// 枚举 hal::LayerRequest&#123;CLEAR_CLIENT_TARGET = 1 &lt;&lt; 0,  &#125;</span></span><br><span class="line">        |<span class="comment">// 1表示：客户端必须在该layer所在的位置使用透明像素清除其目标。如果必须混合该层，客户端可能会忽略此请求。    </span></span><br><span class="line">|std::unordered_map&lt;HWC2::Layer*, hal::LayerRequest&gt; layerRequests;</span><br><span class="line">|layerRequests.<span class="built_in">reserve</span>(numRequests); <span class="comment">// map扩容为 numRequests</span></span><br><span class="line">|<span class="comment">// 返回 hal::DisplayRequest 和 每个Layer的 hal::LayerRequest 类型，用于指导 SurfaceFlinger 的GPU合成</span></span><br><span class="line">|hwcDisplay-&gt;<span class="built_in">getRequests</span>(&amp;displayRequests, &amp;layerRequests);</span><br><span class="line">|<span class="comment">// 返回client target属性，这个新增的，目前可能仅仅实现了亮度、调光、数据格式、数据空间相关属性</span></span><br><span class="line">|DeviceRequestedChanges::ClientTargetProperty clientTargetProperty;</span><br><span class="line">|hwcDisplay-&gt;<span class="built_in">getClientTargetProperty</span>(&amp;clientTargetProperty);</span><br><span class="line">|<span class="comment">// 组合成 DeviceRequestedChanges 结构体，返回</span></span><br><span class="line">|outChanges-&gt;<span class="built_in">emplace</span>(DeviceRequestedChanges&#123;std::<span class="built_in">move</span>(changedTypes), std::<span class="built_in">move</span>(displayRequests),</span><br><span class="line">                                                       std::<span class="built_in">move</span>(layerRequests), std::<span class="built_in">move</span>(clientTargetProperty)&#125;);</span><br><span class="line">        |<span class="comment">// 注释这么说的：此函数相当于从getChangedCompositionTypes请求更改后的类型，在相应的层上设置这些类型，然后再次调用validateDisplay。</span></span><br><span class="line">        |<span class="comment">// 但是，看源码感觉注释说的不大对，这里仅仅是把这个成员设为true： DisplayCommand::acceptDisplayChanges = true</span></span><br><span class="line">        |<span class="comment">// 注释说的应该是命令缓存发送到HWC后，执行的流程</span></span><br><span class="line">|hwcDisplay-&gt;<span class="built_in">acceptChanges</span>();</span><br><span class="line">    |<span class="comment">//只有正常执行会返回 true，其他，显示设备未连接、没有硬件合成、getDeviceCompositionChanges返回false，那么会 return false; </span></span><br><span class="line">    |<span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">|<span class="built_in">resetCompositionStrategy</span>();</span><br><span class="line">|--&gt;Output::<span class="built_in">resetCompositionStrategy</span>()</span><br><span class="line">    |<span class="keyword">auto</span>&amp; outputState = <span class="built_in">editState</span>();</span><br><span class="line">|<span class="comment">// 先重置这些变量，在后续的流程中会使用。相当于设置默认值，因为对基本的Output实现只能进行客户端合成</span></span><br><span class="line">|outputState.usesClientComposition = <span class="literal">true</span>;</span><br><span class="line">|outputState.usesDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">|outputState.reusedClientComposition = <span class="literal">false</span>;</span><br><span class="line">|<span class="comment">// 这个previousDeviceRequestedChanges变量在 Output::canPredictCompositionStrategy 函数中用来判断是否预测合成策略</span></span><br><span class="line">|outputState.previousDeviceRequestedChanges = changes;</span><br><span class="line">|outputState.previousDeviceRequestedSuccess = success;</span><br><span class="line">|<span class="keyword">if</span> (success)<span class="comment">// HWComposer::getDeviceCompositionChanges 执行错误，不会进入到这里。比如IComposer任意一接口调用失败</span></span><br><span class="line">|<span class="built_in">applyCompositionStrategy</span>(changes);</span><br><span class="line">|--&gt;Display::<span class="built_in">applyCompositionStrategy</span>(<span class="type">const</span> std::optional&lt;DeviceRequestedChanges&gt;&amp; changes)</span><br><span class="line">        |<span class="keyword">if</span> (changes)</span><br><span class="line">            |<span class="comment">// 对每个 OutputLayer 应用HWC设备要求的合成类型更改</span></span><br><span class="line">        |<span class="built_in">applyChangedTypesToLayers</span>(changes-&gt;changedTypes);</span><br><span class="line">|--&gt;Display::<span class="built_in">applyChangedTypesToLayers</span>(<span class="type">const</span> ChangedTypes&amp; changedTypes)</span><br><span class="line">                |<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">                    |<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>();<span class="comment">// 获取 OutputLayer中存储的 HWC::Layer</span></span><br><span class="line">                    |<span class="keyword">auto</span> it = changedTypes.<span class="built_in">find</span>(hwcLayer);</span><br><span class="line">|<span class="keyword">if</span> (it == changedTypes.<span class="built_in">end</span>())<span class="keyword">continue</span>;</span><br><span class="line">                    |layer-&gt;<span class="built_in">applyDeviceCompositionTypeChange</span>(</span><br><span class="line">                    <span class="built_in">static_cast</span>&lt;aidl::android::hardware::graphics::composer3::Composition&gt;(it-&gt;second));</span><br><span class="line">|<span class="comment">// 应用HWC设备要求的合成类型更改</span></span><br><span class="line">|--&gt;OutputLayer::<span class="built_in">applyDeviceCompositionTypeChange</span>(Composition compositionType)</span><br><span class="line">                        |<span class="keyword">auto</span>&amp; state = <span class="built_in">editState</span>();</span><br><span class="line">|<span class="keyword">auto</span>&amp; hwcState = *state.hwc;</span><br><span class="line">|<span class="comment">// 这个 OutputLayerCompositionState::Hwc.hwcCompositionType 用于预测合成策略 Output::canPredictCompositionStrategy</span></span><br><span class="line">                        |hwcState.hwcCompositionType = compositionType;<span class="comment">//这个代表最近使用的合成类型</span></span><br><span class="line">|<span class="built_in">applyDisplayRequests</span>(changes-&gt;displayRequests);</span><br><span class="line">|--&gt;Display::<span class="built_in">applyDisplayRequests</span>(<span class="type">const</span> DisplayRequests&amp; displayRequests)</span><br><span class="line">                |<span class="keyword">auto</span>&amp; state = <span class="built_in">editState</span>();</span><br><span class="line">                |<span class="comment">// 如果 displayRequests 包含flag FLIP_CLIENT_TARGET，则 flipClientTarget=true</span></span><br><span class="line">                |<span class="comment">// 如果为true，则在执行客户端合成时应提供新的客户端目标(client target)缓冲区</span></span><br><span class="line">|state.flipClientTarget = (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(displayRequests) </span><br><span class="line">                                              &amp; <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(hal::DisplayRequest::FLIP_CLIENT_TARGET)) != <span class="number">0</span>;</span><br><span class="line">|<span class="built_in">applyLayerRequestsToLayers</span>(changes-&gt;layerRequests);</span><br><span class="line">|--&gt;Display::<span class="built_in">applyLayerRequestsToLayers</span>(<span class="type">const</span> LayerRequests&amp; layerRequests)</span><br><span class="line">                |<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">                    |<span class="comment">// OutputLayer.editState().clearClientTarget = false;</span></span><br><span class="line">                    |layer-&gt;<span class="built_in">prepareForDeviceLayerRequests</span>();</span><br><span class="line">|<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>();</span><br><span class="line">|<span class="keyword">if</span> (<span class="keyword">auto</span> it = layerRequests.<span class="built_in">find</span>(hwcLayer); it != layerRequests.<span class="built_in">end</span>())</span><br><span class="line">                        |<span class="comment">// 应用HWC的layer请求</span></span><br><span class="line">                        |layer-&gt;<span class="built_in">applyDeviceLayerRequest</span>(<span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::LayerRequest&gt;(it-&gt;second));</span><br><span class="line">|--&gt;OutputLayer::<span class="built_in">applyDeviceLayerRequest</span>(hal::LayerRequest request)</span><br><span class="line">                            |<span class="keyword">if</span>(request== hal::LayerRequest::CLEAR_CLIENT_TARGET:)</span><br><span class="line">                                |<span class="comment">// 客户端合成时，该layer所在的位置使用透明像素清除其目标</span></span><br><span class="line">                                |<span class="built_in">editState</span>().clearClientTarget = <span class="literal">true</span>;</span><br><span class="line">|<span class="built_in">applyClientTargetRequests</span>(changes-&gt;clientTargetProperty);</span><br><span class="line">|--&gt;Display::<span class="built_in">applyClientTargetRequests</span>(<span class="type">const</span> ClientTargetProperty&amp; clientTargetProperty)</span><br><span class="line">                |<span class="built_in">editState</span>().dataspace = <span class="built_in">static_cast</span>&lt;ui::Dataspace&gt;(clientTargetProperty.clientTargetProperty.dataspace);</span><br><span class="line">|<span class="built_in">editState</span>().clientTargetBrightness = clientTargetProperty.brightness;</span><br><span class="line">|<span class="built_in">editState</span>().clientTargetDimmingStage = clientTargetProperty.dimmingStage;</span><br><span class="line">|<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">setBufferDataspace</span>(<span class="built_in">editState</span>().dataspace);</span><br><span class="line">|<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">setBufferPixelFormat</span>(<span class="built_in">static_cast</span>&lt;ui::PixelFormat&gt;(clientTargetProperty.clientTargetProperty.pixelFormat));</span><br><span class="line">|<span class="keyword">auto</span>&amp; state = <span class="built_in">editState</span>();</span><br><span class="line">|<span class="comment">// anyLayersRequireClientComposition:</span></span><br><span class="line">|<span class="comment">// Output 中有任意一个 OutputLayer 状态对象的 hwc-&gt;hwcCompositionType 为 Composition::CLIENT，则返回true</span></span><br><span class="line">|<span class="comment">// 就是 OutputLayer.getState().hwc-&gt;hwcCompositionType == Composition::CLIENT</span></span><br><span class="line">        |<span class="comment">// 即，当前显示设备中有任意一个Layer的合成为 客户端合成，则 Output.getState().usesClientComposition = true; </span></span><br><span class="line">|state.usesClientComposition = <span class="built_in">anyLayersRequireClientComposition</span>();<span class="comment">// true表示有使用客户端合成</span></span><br><span class="line">|<span class="comment">// 当前显示设备的当前帧中，不是全部使用了客户端合成，则 usesDeviceComposition = true;</span></span><br><span class="line">        |<span class="comment">// 表示当前显示设备的当前帧可能完使用硬件合成，也可能是两者都有</span></span><br><span class="line">|state.usesDeviceComposition = !<span class="built_in">allLayersRequireClientComposition</span>();<span class="comment">// true表示有使用硬件合成</span></span><br><span class="line">|<span class="comment">// 以上两个变量将用于接下来的 Output::finishPrepareFrame()流程，虚拟屏的prepareFrame方法 和 finishFrame 流程</span></span><br><span class="line">|<span class="built_in">finishPrepareFrame</span>();</span><br><span class="line">|<span class="comment">// 用于虚拟屏</span></span><br><span class="line">|--&gt;Output::<span class="built_in">finishPrepareFrame</span>()</span><br><span class="line">    |<span class="type">const</span> <span class="keyword">auto</span>&amp; state = <span class="built_in">getState</span>();</span><br><span class="line">|<span class="keyword">if</span> (mPlanner)</span><br><span class="line">        |mPlanner-&gt;<span class="built_in">reportFinalPlan</span>(<span class="built_in">getOutputLayersOrderedByZ</span>());</span><br><span class="line">|<span class="comment">// 准备帧进行渲染----这里只有 虚拟屏幕 实现了prepareFrame，其他什么也不做</span></span><br><span class="line">    |mRenderSurface-&gt;<span class="built_in">prepareFrame</span>(state.usesClientComposition, state.usesDeviceComposition);</span><br></pre></td></tr></table></figure><h5 id="Output-finishFrame"><a href="#Output-finishFrame" class="headerlink" title="Output::finishFrame"></a>Output::finishFrame</h5><ul><li>处理Client合成(GPU合成)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码Output::<span class="built_in">present</span>(<span class="type">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">finishFrame</span>(refreshArgs, std::<span class="built_in">move</span>(result));<span class="comment">// GPU 合成</span></span><br><span class="line"><span class="comment">// result 为 prepareFrameAsync 的执行结果</span></span><br><span class="line">|--&gt;Output::<span class="built_in">finishFrame</span>(<span class="type">const</span> CompositionRefreshArgs&amp; refreshArgs, GpuCompositionResult&amp;&amp; result)</span><br><span class="line">    |<span class="type">const</span> <span class="keyword">auto</span>&amp; outputState = <span class="built_in">getState</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    outputState.strategyPrediction </span></span><br><span class="line"><span class="comment">    走 prepareFrame() 为 DISABLED，表示不使用预测合成策略</span></span><br><span class="line"><span class="comment">    走 prepareFrameAsync() 为 SUCCESS 或者 FAIL  表示合预测成功或者失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">|<span class="keyword">if</span> (outputState.strategyPrediction == CompositionStrategyPredictionState::SUCCESS)</span><br><span class="line">        |<span class="comment">//如果预测成功，则已经执行完 GPU 合成了，不必再dequeueRenderBuffer了</span></span><br><span class="line">        |optReadyFence = std::<span class="built_in">move</span>(result.fence);</span><br><span class="line">|<span class="keyword">else</span> <span class="comment">// prepareFrameAsync 中预测失败了</span></span><br><span class="line">        |<span class="comment">// 虽然预测失败了，但是已经dequeued的buffer，会通过GpuCompositionResult传送过来，拿来复用</span></span><br><span class="line">        |<span class="keyword">if</span> (result.<span class="built_in">bufferAvailable</span>())</span><br><span class="line">            |buffer = std::<span class="built_in">move</span>(result.buffer);</span><br><span class="line">|bufferFence = std::<span class="built_in">move</span>(result.fence);</span><br><span class="line">|<span class="keyword">else</span> <span class="comment">// dequeueRenderBuffer失败，连dequeued的buffer都没有，那就重走一遍 prepareFrameAsync GPU 合成的那块逻辑。当然，也可能就没有执行 prepareFrameAsync</span></span><br><span class="line">            |<span class="comment">// BufferQueue熟悉的配方 dequeueBuffer</span></span><br><span class="line">            |<span class="built_in">dequeueRenderBuffer</span>(&amp;bufferFence, &amp;buffer))</span><br><span class="line">            |--&gt;Output::<span class="built_in">dequeueRenderBuffer</span>(unique_fd* bufferFence, std::shared_ptr&lt;ExternalTexture&gt;* tex)</span><br><span class="line">            |<span class="type">const</span> <span class="keyword">auto</span>&amp; outputState = <span class="built_in">getState</span>();</span><br><span class="line">            |<span class="comment">// 有使用客户端合成 或者 设置了 flipClientTarget 都需要进行 GPU 合成</span></span><br><span class="line">            |<span class="keyword">if</span> (outputState.usesClientComposition || outputState.flipClientTarget)</span><br><span class="line">                    |<span class="comment">//【dequeueBuffer，然后把dequeue的Buffer包装为 ExternalTexture】</span></span><br><span class="line">                    |*tex = mRenderSurface-&gt;<span class="built_in">dequeueBuffer</span>(bufferFence);</span><br><span class="line">|--&gt;RenderSurface::<span class="built_in">dequeueBuffer</span>(base::unique_fd* bufferFence)</span><br><span class="line">                        |<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">|ANativeWindowBuffer* buffer = <span class="literal">nullptr</span>;</span><br><span class="line">                        |<span class="comment">// 调用 Surface.dequeueBuffer</span></span><br><span class="line">                        |mNativeWindow-&gt;<span class="built_in">dequeueBuffer</span>(mNativeWindow.<span class="built_in">get</span>(), &amp;buffer, &amp;fd);</span><br><span class="line">|<span class="comment">// GraphicBuffer 继承 ANativeWindowBuffer</span></span><br><span class="line">|<span class="comment">// GraphicBuffer::from 把父类ANativeWindowBuffer强制转换为子类 GraphicBuffer</span></span><br><span class="line">|sp&lt;GraphicBuffer&gt; newBuffer = GraphicBuffer::<span class="built_in">from</span>(buffer);</span><br><span class="line">|<span class="comment">// ExternalTexture 使用 RenderEngine 代表客户端管理GPU图像资源。</span></span><br><span class="line">                        |<span class="comment">// 渲染引擎不是GLES的话，在 ExternalTexture 构造函数中把GraphicBuffer映射到RenderEngine所需的GPU资源中。</span></span><br><span class="line">|mTexture = <span class="keyword">new</span> <span class="built_in">ExternalTexture</span>(newBuffer,mCompositionEngine.<span class="built_in">getRenderEngine</span>(),WRITEABLE)</span><br><span class="line">                        |*bufferFence = base::<span class="built_in">unique_fd</span>(fd);<span class="comment">//返回fence fd</span></span><br><span class="line">|<span class="keyword">return</span> mTexture;<span class="comment">// 返回纹理类</span></span><br><span class="line">|<span class="comment">// 执行GPU合成</span></span><br><span class="line">|optReadyFence = <span class="built_in">composeSurfaces</span>(Region::INVALID_REGION, refreshArgs, buffer, bufferFence);</span><br><span class="line">|<span class="comment">// BufferQueue熟悉的配方 queueBuffer</span></span><br><span class="line">|mRenderSurface-&gt;<span class="built_in">queueBuffer</span>(std::<span class="built_in">move</span>(*optReadyFence));</span><br><span class="line">|--&gt;RenderSurface::<span class="built_in">queueBuffer</span>(base::unique_fd readyFence)</span><br><span class="line">        |<span class="comment">// 调用 Surface.queueBuffer</span></span><br><span class="line">        |mNativeWindow-&gt;<span class="built_in">queueBuffer</span>(mNativeWindow.<span class="built_in">get</span>(),mTexture-&gt;<span class="built_in">getBuffer</span>()-&gt;<span class="built_in">getNativeBuffer</span>(),<span class="built_in">dup</span>(readyFence));</span><br><span class="line">|<span class="comment">// mDisplaySurface:</span></span><br><span class="line">        |<span class="comment">// 对于非虚拟屏是 FramebufferSurface，其包装消费者、继承 DisplaySurface；对于虚拟屏是 VirtualDisplaySurface</span></span><br><span class="line">|mDisplaySurface-&gt;<span class="built_in">advanceFrame</span>();</span><br><span class="line">|--&gt;FramebufferSurface::<span class="built_in">advanceFrame</span>()<span class="comment">//就是调用 FramebufferSurface::nextBuffer</span></span><br><span class="line">            |<span class="type">uint32_t</span> slot = <span class="number">0</span>;</span><br><span class="line">|sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">|<span class="function">sp&lt;Fence&gt; <span class="title">acquireFence</span><span class="params">(Fence::NO_FENCE)</span></span>;</span><br><span class="line">|Dataspace dataspace = Dataspace::UNKNOWN;</span><br><span class="line">            |<span class="built_in">nextBuffer</span>(slot, buf, acquireFence, dataspace);</span><br><span class="line">|<span class="comment">// 这里核心是调用 setClientTarget ，把 客户端合成输出的缓冲区句柄 传递给 HWC。</span></span><br><span class="line">            |<span class="comment">// 当然，目前还未真正传递到HWC，只是写到命令缓冲区。需要等待执行 present 才执行传递</span></span><br><span class="line">|--&gt;FramebufferSurface::<span class="built_in">nextBuffer</span>(<span class="type">uint32_t</span>&amp; outSlot,sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence,Dataspace&amp; outDataspace)</span><br><span class="line">|mHwc.<span class="built_in">setClientTarget</span>(mDisplayId, outSlot, outFence, outBuffer, outDataspace);</span><br></pre></td></tr></table></figure><h5 id="Output-postFramebuffer"><a href="#Output-postFramebuffer" class="headerlink" title="Output::postFramebuffer()"></a>Output::postFramebuffer()</h5><ul><li><strong>送显 + 获取 Layer releaseFence</strong></li><li>这个 releaseFence 并不是当前送显的fence，是上一帧的</li><li>Layer releaseFence 会合并 GPU合成的fence<ul><li>就是说APP dequeuebuffer拿到新buffer后，需要等待GPU合成完成 + HWC使用当前Layer buffer替换上一个buffer(app dequque的buffer)后，才能在这个新buffer上填充数据</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//先看下结构体 FrameFences</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct FrameFences &#123;</span></span><br><span class="line"><span class="comment">    // 这个fence，在当前帧在屏幕上显现，或者发送到面板内存时，会发送信号</span></span><br><span class="line"><span class="comment">        sp&lt;Fence&gt; presentFence&#123;Fence::NO_FENCE&#125;;</span></span><br><span class="line"><span class="comment">        // GPU 合成的buffer的消费者 acquire fence；代表GPU合成是否完成；(注：GPU绘制的acquire fence，在latchBuffer阶段已经判断了。)</span></span><br><span class="line"><span class="comment">        sp&lt;Fence&gt; clientTargetAcquireFence&#123;Fence::NO_FENCE&#125;;</span></span><br><span class="line"><span class="comment">        // 所有Layer的fence；在先前呈现的buffer被读取完成后发送信息；HWC生成</span></span><br><span class="line"><span class="comment">        std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; layerFences;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Output::<span class="built_in">postFramebuffer</span>()</span><br><span class="line">|<span class="keyword">auto</span> frame = <span class="built_in">presentAndGetFrameFences</span>();</span><br><span class="line">|--&gt;Display::<span class="built_in">presentAndGetFrameFences</span>()</span><br><span class="line">    |<span class="comment">// 【1】这里就是赋值 FrameFences.clientTargetAcquireFence</span></span><br><span class="line">    |<span class="keyword">auto</span> fences = impl::Output::<span class="built_in">presentAndGetFrameFences</span>();</span><br><span class="line">|--&gt;Output::<span class="built_in">presentAndGetFrameFences</span>() </span><br><span class="line">        |<span class="keyword">if</span> (<span class="built_in">getState</span>().usesClientComposition)</span><br><span class="line">            |result.clientTargetAcquireFence = mRenderSurface-&gt;<span class="built_in">getClientTargetAcquireFence</span>();</span><br><span class="line">|<span class="comment">// 1、【在屏幕上呈现当前显示内容（如果是虚拟显示，则显示到输出缓冲区中）】</span></span><br><span class="line">|<span class="comment">// 2、获取device上所有layer的 ReleaseFence</span></span><br><span class="line">|hwc.<span class="built_in">presentAndGetReleaseFences</span>(*halDisplayIdOpt, <span class="built_in">getState</span>().earliestPresentTime, <span class="built_in">getState</span>().previousPresentFence);</span><br><span class="line">|<span class="comment">// getPresentFence返回 HWComposer.mDisplayData.at(displayId).lastPresentFence;</span></span><br><span class="line">    |<span class="comment">// 这个fence，在当前帧在屏幕上显现，或者发送到面板内存时，会发送信号</span></span><br><span class="line">    |<span class="comment">//【2】赋值 FrameFences.presentFence</span></span><br><span class="line">|fences.presentFence = hwc.<span class="built_in">getPresentFence</span>(*halDisplayIdOpt);</span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">        |<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>();</span><br><span class="line">|<span class="comment">// 从HWC显示设备上所有Layer的fence</span></span><br><span class="line">|<span class="comment">//【3】赋值 FrameFences.layerFences</span></span><br><span class="line">        |fences.layerFences.<span class="built_in">emplace</span>(hwcLayer, hwc.<span class="built_in">getLayerReleaseFence</span>(*halDisplayIdOpt, hwcLayer));</span><br><span class="line">|<span class="comment">// 释放GPU合成使用的buffer</span></span><br><span class="line">|mRenderSurface-&gt;<span class="built_in">onPresentDisplayCompleted</span>();</span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">auto</span>* layer : <span class="built_in">getOutputLayersOrderedByZ</span>())</span><br><span class="line">    |sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE;</span><br><span class="line">|<span class="comment">// 获取HWC每个layer的releaseFence</span></span><br><span class="line">|<span class="keyword">if</span> (<span class="keyword">auto</span> hwcLayer = layer-&gt;<span class="built_in">getHwcLayer</span>())</span><br><span class="line">        |<span class="keyword">if</span> (<span class="keyword">auto</span> f = frame.layerFences.<span class="built_in">find</span>(hwcLayer); f != frame.layerFences.<span class="built_in">end</span>())</span><br><span class="line">            |releaseFence = f-&gt;second;</span><br><span class="line">|<span class="comment">// 如果有客户端合成，merge GPUbuffer的fence</span></span><br><span class="line">    |<span class="keyword">if</span> (outputState.usesClientComposition)</span><br><span class="line">        |releaseFence = Fence::<span class="built_in">merge</span>(<span class="string">&quot;LayerRelease&quot;</span>, releaseFence, frame.clientTargetAcquireFence);</span><br><span class="line">|<span class="comment">//同步Fence到Layer中</span></span><br><span class="line">    |<span class="comment">// 如果是 BufferQueueLayer设置 mSlots[slot].mFence; </span></span><br><span class="line">    |<span class="comment">// 如果是 BufferStateLayer把fence关联到回调类中</span></span><br><span class="line">|layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">onLayerDisplayed</span>(ftl::<span class="built_in">yield</span>&lt;FenceResult&gt;(std::<span class="built_in">move</span>(releaseFence)).<span class="built_in">share</span>());</span><br><span class="line">|<span class="comment">// mReleasedLayers是一些即将移除的的layer，但是当前vsync还在生产帧数据的layer</span></span><br><span class="line">|<span class="comment">// 把presentFence传给这些layer使用，毕竟他们不参与合成了</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; weakLayer : mReleasedLayers)</span><br><span class="line">    |<span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> layer = weakLayer.<span class="built_in">promote</span>())</span><br><span class="line">        |layer-&gt;<span class="built_in">onLayerDisplayed</span>(ftl::<span class="built_in">yield</span>&lt;FenceResult&gt;(frame.presentFence).<span class="built_in">share</span>());</span><br><span class="line">|mReleasedLayers.<span class="built_in">clear</span>();<span class="comment">//清空 mReleasedLayers</span></span><br></pre></td></tr></table></figure><h4 id="再回到APP进程端-releaseBuffer"><a href="#再回到APP进程端-releaseBuffer" class="headerlink" title="再回到APP进程端 releaseBuffer"></a>再回到APP进程端 releaseBuffer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码|--&gt;SurfaceFlinger::<span class="built_in">postComposition</span>() </span><br><span class="line">    |<span class="comment">// 省略一大段内容</span></span><br><span class="line">    |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer: mLayersWithQueuedFrames)</span><br><span class="line">        |<span class="comment">// 更新FrameTracker、TimeStats这些</span></span><br><span class="line">        |layer-&gt;<span class="built_in">onPostComposition</span>(display, glCompositionDoneFenceTime,mPreviousPresentFences[<span class="number">0</span>].fenceTime, compositorTiming);</span><br><span class="line">|layer-&gt;<span class="built_in">releasePendingBuffer</span>(<span class="comment">/*dequeueReadyTime*/</span> now);</span><br><span class="line">|--&gt;BufferStateLayer::<span class="built_in">releasePendingBuffer</span>(<span class="type">nsecs_t</span> dequeueReadyTime)</span><br><span class="line">            |<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; handle : mDrawingState.callbackHandles)</span><br><span class="line">                |<span class="keyword">if</span> (handle-&gt;releasePreviousBuffer &amp;&amp; mDrawingState.releaseBufferEndpoint == handle-&gt;listener)</span><br><span class="line">                    |<span class="comment">// 这个 mPreviousReleaseCallbackId 在 BufferStateLayer::updateActiveBuffer() 赋值</span></span><br><span class="line">                    |<span class="comment">// mPreviousReleaseCallbackId = &#123;getCurrentBufferId(), mBufferInfo.mFrameNumber&#125;;</span></span><br><span class="line">                    |handle-&gt;previousReleaseCallbackId = mPreviousReleaseCallbackId;</span><br><span class="line">|<span class="keyword">break</span>;</span><br><span class="line">|<span class="comment">// 把 callback 加入 TransactionCallbackInvoker::mCompletedTransactions</span></span><br><span class="line">|mFlinger-&gt;<span class="built_in">getTransactionCallbackInvoker</span>().<span class="built_in">addCallbackHandles</span>(mDrawingState.callbackHandles, jankData);</span><br><span class="line">|<span class="comment">//【这里就是通过binder通信，回调到 APP 端BBQ执行 releaseBuffer 了】</span></span><br><span class="line">|mTransactionCallbackInvoker.<span class="built_in">sendCallbacks</span>(<span class="literal">false</span> <span class="comment">/* onCommitOnly */</span>);</span><br><span class="line">|--&gt;BpTransactionCompletedListener::<span class="built_in">onTransactionCompleted</span>(android::ListenerStats)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 跨进程进入到APP端</span></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/BLASTBufferQueue.cpp</span></span><br><span class="line"><span class="built_in">releaseBufferCallbackThunk</span>(wp&lt;BLASTBufferQueue&gt; context, ReleaseCallbackId&amp; id,Fence&amp; releaseFence, <span class="type">uint32_t</span> currentMaxAcquiredBufferCount)</span><br><span class="line">|sp&lt;BLASTBufferQueue&gt; blastBufferQueue = context.<span class="built_in">promote</span>();</span><br><span class="line">|blastBufferQueue-&gt;<span class="built_in">releaseBufferCallback</span>(id, releaseFence, currentMaxAcquiredBufferCount);</span><br><span class="line">|--&gt;BLASTBufferQueue::<span class="built_in">releaseBufferCallback</span>(<span class="type">const</span> ReleaseCallbackId&amp; id,Fence&amp; releaseFence,<span class="type">uint32_t</span> currentMaxAcquiredBufferCount)</span><br><span class="line">    |<span class="built_in">releaseBufferCallbackLocked</span>(id, releaseFence, currentMaxAcquiredBufferCount,<span class="literal">false</span> <span class="comment">/* fakeRelease */</span>);</span><br><span class="line">|--&gt;BLASTBufferQueue::<span class="built_in">releaseBufferCallbackLocked</span>(ReleaseCallbackId&amp; id,Fence&amp; releaseFence,<span class="type">uint32_t</span> currentMaxAcquiredBufferCount, <span class="type">bool</span> fakeRelease)</span><br><span class="line">        |<span class="comment">//ReleaseCallbackId 是个包含 bufferId 和 帧号 的Parcelable, ReleasedBuffer结构体又把 releaseFence 包含进来</span></span><br><span class="line">        |<span class="keyword">auto</span> rb = ReleasedBuffer&#123;id, releaseFence&#125;;</span><br><span class="line">|<span class="keyword">if</span> (std::<span class="built_in">find</span>(mPendingRelease.<span class="built_in">begin</span>(), mPendingRelease.<span class="built_in">end</span>(), rb) == mPendingRelease.<span class="built_in">end</span>())</span><br><span class="line">            |<span class="comment">// 队列里边没有的话，就加入队列</span></span><br><span class="line">            |mPendingRelease.<span class="built_in">emplace_back</span>(rb);<span class="comment">//  mPendingRelease 是个 std::deque</span></span><br><span class="line">|<span class="keyword">while</span> (mPendingRelease.<span class="built_in">size</span>() &gt; numPendingBuffersToHold) <span class="comment">// numPendingBuffersToHold 是需要保留的buffer数量</span></span><br><span class="line">            |<span class="type">const</span> <span class="keyword">auto</span> releasedBuffer = mPendingRelease.<span class="built_in">front</span>();</span><br><span class="line">|mPendingRelease.<span class="built_in">pop_front</span>();</span><br><span class="line">|<span class="built_in">releaseBuffer</span>(releasedBuffer.callbackId, releasedBuffer.releaseFence);</span><br><span class="line">|--&gt;BLASTBufferQueue::<span class="built_in">releaseBuffer</span>(<span class="type">const</span> ReleaseCallbackId&amp; callbackId,<span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span><br><span class="line">            |<span class="comment">// mSubmitted 是个map&lt;ReleaseCallbackId, BufferItem&gt;，从这个map中查找对应的 BufferItem</span></span><br><span class="line">            |<span class="keyword">auto</span> it = mSubmitted.<span class="built_in">find</span>(callbackId);</span><br><span class="line">|mNumAcquired--;</span><br><span class="line">|mBufferItemConsumer-&gt;<span class="built_in">releaseBuffer</span>(it-&gt;second, releaseFence);</span><br><span class="line">|--&gt;BufferItemConsumer::<span class="built_in">releaseBuffer</span>(<span class="type">const</span> BufferItem &amp;item, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span><br><span class="line">                    |<span class="comment">// mSlots[slot].mFence = fence; 赋值releaseFence，并处理 Fence 合并情况</span></span><br><span class="line">                    |<span class="built_in">addReleaseFenceLocked</span>(item.mSlot, item.mGraphicBuffer, releaseFence);</span><br><span class="line">|<span class="built_in">releaseBufferLocked</span>(item.mSlot, item.mGraphicBuffer, EGL_NO_DISPLAY, EGL_NO_SYNC_KHR);</span><br><span class="line">|--&gt;ConsumerBase::<span class="built_in">releaseBufferLocked</span>(<span class="type">int</span> slot, <span class="type">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,  EGLDisplay display, EGLSyncKHR eglFence)</span><br><span class="line">                        |<span class="comment">// 调用消费者的 releaseBuffer 方法</span></span><br><span class="line">                        |<span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">releaseBuffer</span>(slot, mSlots[slot].mFrameNumber, display, eglFence, mSlots[slot].mFence);</span><br><span class="line">|--&gt;BufferQueueConsumer::<span class="built_in">releaseBuffer</span>(<span class="type">int</span> slot, <span class="type">uint64_t</span> frameNumber, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence,...)</span><br><span class="line">                            |<span class="comment">// 忽略一些容错处理</span></span><br><span class="line">                            |sp&lt;IProducerListener&gt; listener;</span><br><span class="line">                            |mSlots[slot].mEglDisplay = eglDisplay; <span class="comment">// display = EGL_NO_DISPLAY;</span></span><br><span class="line">|mSlots[slot].mEglFence = eglFence;  <span class="comment">// EGLSyncKHR eglFence = EGL_NO_SYNC_KHR</span></span><br><span class="line">|mSlots[slot].mFence = releaseFence; <span class="comment">// SurfaceFlinger 传递过来的 releaseFence</span></span><br><span class="line">|mSlots[slot].mBufferState.<span class="built_in">release</span>(); <span class="comment">// 状态转为 released</span></span><br><span class="line">|mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(slot);<span class="comment">// 从激活状态set中删除</span></span><br><span class="line">|mCore-&gt;mFreeBuffers.<span class="built_in">push_back</span>(slot); <span class="comment">// 放回 Free list 中</span></span><br><span class="line">|<span class="keyword">if</span> (mCore-&gt;mBufferReleasedCbEnabled)</span><br><span class="line">                                |<span class="comment">// mConnectedProducerListener 是 BufferQueueProducer::connect 时传入的</span></span><br><span class="line">                                |<span class="comment">// CPU绘制传入的 StubProducerListener,没啥用</span></span><br><span class="line">                                |listener = mCore-&gt;mConnectedProducerListener;</span><br><span class="line">|<span class="comment">// 如果有阻塞在dequeuebuffer的线程，此时会被唤醒，有新的buffer可以 Dequeue 了</span></span><br><span class="line">|mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">|<span class="keyword">if</span> (listener != <span class="literal">nullptr</span>)</span><br><span class="line">                                |listener-&gt;<span class="built_in">onBufferReleased</span>();<span class="comment">// 对于CPU绘制，这个是空函数没啥</span></span><br><span class="line">|<span class="comment">// 如果返回 buffer过时了，需要清空这个slot的 GraphicBuffer</span></span><br><span class="line">|<span class="keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) </span><br><span class="line">                            |mSlots[slotIndex].mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">|mSlots[slotIndex].mFence = Fence::NO_FENCE;</span><br><span class="line">|mSlots[slotIndex].mFrameNumber = <span class="number">0</span>;</span><br><span class="line">|mPrevFinalReleaseFence = mSlots[slot].mFence;</span><br><span class="line">|<span class="comment">// 这里的mSlots是BufferItem的，和 BufferQueue 的不是一个变量</span></span><br><span class="line">|<span class="comment">// BufferItem 的Fence设置为 NO_FENCE</span></span><br><span class="line">|mSlots[slot].mFence = Fence::NO_FENCE;</span><br><span class="line">|mSubmitted.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure><p><strong>后记：</strong></p><p>对于 Android 13 的 SurfaceFlinger 而言，参考资料真的是非常有限。</p><p>从 Android P<del>Android Q小更新，Android Q</del>Android R 大的架构更新，</p><p>Android R~Android S 机制上的更新(BBQ+BufferStateLayer)，Android S ~ Android T 又是大的架构更新，</p><p>Google还不断使用最新的c++标准去重构代码，从c11又更新到c20。更新的XX都不认识了。</p><p>最后导致能参考的资料基本失效了，只能一个个变量去查，并且都没类注释，要命的工作量啊。</p><p>最后不感谢CCTV，感谢 cs.android.com 吧，多亏了这个源码网站强大的检索能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;八、绘制&quot;&gt;&lt;a href=&quot;#八、绘制&quot; class=&quot;headerlink&quot; title=&quot;八、绘制&quot;&gt;&lt;/a&gt;八、绘制&lt;/h3&gt;&lt;h4 id=&quot;ViewRootImpl-performDraw&quot;&gt;&lt;a href=&quot;#ViewRootImpl-performD</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    
  </entry>
  
  <entry>
    <title>7.点击桌面APP图标，到APP界面显示流程分析</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/7.%E7%82%B9%E5%87%BB%E6%A1%8C%E9%9D%A2APP%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%88%B0APP%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80)/</id>
    <published>2024-01-12T01:04:50.784Z</published>
    <updated>2024-01-19T02:26:57.734Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、点击桌面App图标事件分发"><a href="#一、点击桌面App图标事件分发" class="headerlink" title="一、点击桌面App图标事件分发"></a>一、点击桌面App图标事件分发</h3><ul><li>systemserver进程启动时，会启动 inputflinger 服务： native层的 InputManager</li><li>InputManager 启动时，启动 InputDispatcher 线程和 InputReader 线程</li><li>InputReader 线程循环调用 EventHub 的 getEvents 方法，linux设备节点&#x2F;dev&#x2F;input文件夹下的event读取事件</li><li>InputReader 读取到事件后，放到 InputDispatcher.mInboundQueue 队列中，并通知 InputDispatcher 线程读取数据</li><li>InputDispatcher 线程唤醒后，从 mInboundQueue 队列中取出事件，按事件类型进行分发。</li><li>对于触屏事件，会寻找屏幕触控事件的焦点窗口，找到后把事件放入 Connection.outboundQueue 队列中<ul><li>Connection是在窗口添加时在 WindowState.openInputChannel 调用过程中创建的，</li><li>一个 Connection有一个服务端的InputChannel，一个InputChannel有一个socketpair服务端socket的fd，</li><li>同时 socketpair客户端的fd会被发送到App进程，并加入epoll监听</li><li>因此Connection就代表同App端的socket连接(或者说是管道)</li></ul></li><li>最后通过 Connection 中的 socket 把事件发送到 App</li></ul><h4 id="InputDispatcher分发流程"><a href="#InputDispatcher分发流程" class="headerlink" title="InputDispatcher分发流程"></a>InputDispatcher分发流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">c复制代码InputDispatcher::start();<span class="comment">// 这个start是SystemServer进程启动过程调用的</span></span><br><span class="line"><span class="comment">//  启动线程。循环执行 dispatchOnce()</span></span><br><span class="line">|mThread = <span class="built_in">std</span>::make_unique&lt;InputThread&gt;( <span class="string">&quot;InputDispatcher&quot;</span>, [this]() &#123; dispatchOnce(); &#125;, [this]() &#123; mLooper-&gt;wake(); &#125;);</span><br><span class="line">|--&gt;InputDispatcher::dispatchOnce();</span><br><span class="line">    |dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line"><span class="comment">//取出队列第一个数据， mPendingEvent 作为成员变量，表示待处理事件，一次循环处理一个待处理事件</span></span><br><span class="line">|mPendingEvent = mInboundQueue.front();</span><br><span class="line"><span class="comment">//取出后，移除第一个数据</span></span><br><span class="line">|mInboundQueue.pop_front();</span><br><span class="line"><span class="comment">//根据事件类别，分别调用不同的事件分发函数，比如，按键事件调用 dispatchKeyLocked</span></span><br><span class="line">|<span class="keyword">switch</span> (mPendingEvent-&gt;type) </span><br><span class="line">            <span class="comment">//以屏幕触控事件为例</span></span><br><span class="line">            |<span class="keyword">case</span> EventEntry::Type::MOTION:</span><br><span class="line">|<span class="comment">// 分发屏幕触控事件 </span></span><br><span class="line">|done = dispatchMotionLocked(currentTime, motionEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line"><span class="comment">//寻找屏幕触控事件的焦点窗口，把所有接收当前输入事件的窗口的InputChannel封装到InputTarget，并添加到集合inputTargets</span></span><br><span class="line">|findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">|dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line"><span class="comment">//遍历集合 inputTargets</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="type">const</span> InputTarget&amp; inputTarget : inputTargets) </span><br><span class="line">                                <span class="comment">// 根据 token 拿到 Connection 【见：addToDisplayAsUser 章节】</span></span><br><span class="line">        <span class="comment">// 从map类型数据 mConnectionsByToken 依据key InputChannel.mToken 查找 Connection</span></span><br><span class="line">        <span class="comment">// std::unordered_map&lt;sp&lt;IBinder&gt;, sp&lt;Connection&gt;&gt; mConnectionsByToken</span></span><br><span class="line">        <span class="comment">// mConnectionsByToken 中的数据是 createInputChannel 是添加的</span></span><br><span class="line">        <span class="comment">// createInputChannel 是添加窗口时在 WindowState.openInputChannel 调用过程中调用。</span></span><br><span class="line">                                <span class="comment">// 一个 Connection有一个服务端的InputChannel，一个InputChannel有一个socketpair服务端socket的fd</span></span><br><span class="line">                                <span class="comment">// 因此Connection就代表同App端的socket连接(或者说是管道)</span></span><br><span class="line">                                |sp&lt;Connection&gt; connection = getConnectionLocked(inputTarget.inputChannel-&gt;getConnectionToken());</span><br><span class="line">|prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">| enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">  | enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, FLAG_DISPATCH_AS_IS);</span><br><span class="line"><span class="comment">//把需要分发的事件加入到对于窗口的Connection.outboundQueue队列中</span></span><br><span class="line">|connection-&gt;outboundQueue.push_back(dispatchEntry.release());</span><br><span class="line">  <span class="comment">// 开始循环分发事件</span></span><br><span class="line">  | startDispatchCycleLocked(currentTime, connection);</span><br><span class="line"><span class="comment">// outboundQueue 队列不为空就一直循环处理</span></span><br><span class="line">| <span class="keyword">while</span> (!connection-&gt;outboundQueue.empty())</span><br><span class="line">                                            | connection-&gt;inputPublisher.publishMotionEvent(...)</span><br><span class="line">                                            | mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line"><span class="comment">// 通过socket把事件发生给客户端</span></span><br><span class="line">|::send(getFd(), &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">                                            <span class="comment">// 删除outboundQueue队列中已发送的事件</span></span><br><span class="line">                                            | connection-&gt;outboundQueue.erase(<span class="built_in">std</span>::remove(connection-&gt;outboundQueue.begin(),</span><br><span class="line">                                                    connection-&gt;outboundQueue.end(),</span><br><span class="line">                                                    dispatchEntry));</span><br><span class="line"><span class="comment">// 已发送的事件加入Connection的 waitQueue</span></span><br><span class="line"><span class="comment">// App端处理完事件后，会回调回来删除waitQueue中的事件</span></span><br><span class="line"><span class="comment">// AMR 检查时，waitQueue 中的事件超时未回调，会触发ANR</span></span><br><span class="line">| connection-&gt;waitQueue.push_back(dispatchEntry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理ANR</span></span><br><span class="line">|<span class="type">const</span> <span class="type">nsecs_t</span> nextAnrCheck = processAnrsLocked();</span><br><span class="line">|mLooper-&gt;pollOnce(timeoutMillis);</span><br></pre></td></tr></table></figure><h4 id="App进程事件分发"><a href="#App进程事件分发" class="headerlink" title="App进程事件分发"></a>App进程事件分发</h4><ul><li><p>looper epoll监听 <code>SocketPair</code> 的fd 【这个fd的来源见：addToDisplayAsUser 章节】</p></li><li><p>socket来数据后，回调 NativeInputEventReceiver::handleEvent</p><ul><li><p>android::NativeInputEventReceiver.consumeEvent</p></li><li><p>native 反射调用Java层 InputEventReceiver.deliverInputEvent</p></li><li><p>WindowInputEventReceiver.onInputEvent</p></li><li><p>ViewRootImpl.enqueueInputEvent&#x2F;&#x2F;<strong>执行入队操作—PendingInputEventQueue</strong></p></li><li><p>doProcessInputEvents()</p></li><li><p>deliverInputEvent(q);&#x2F;&#x2F;<strong>这里会在systrace显示 deliverInputEvent块</strong></p><ul><li><p>经过若干步骤后</p></li><li><p>mView.dispatchPointerEvent(event);&#x2F;&#x2F;<strong>进入view的事件分发流程</strong></p><p>然后 view 再处理各自的touch事件。</p><p>比如ScrollView，在touch事件中，会调整view的坐标，然后调用 invalidate 函数，函数最终会调用 requestNextVsync 触发 vsync ，vsync 回调doframe中绘制流程中，ScrollView根据新的坐标绘制界面，然后就看到了界面滚动。</p></li></ul></li></ul></li></ul><p>事件分发到桌面图标的view后，view自身的点击事件中调用 startActivity 启动App。</p><h3 id="二、APP创建进程"><a href="#二、APP创建进程" class="headerlink" title="二、APP创建进程"></a>二、APP创建进程</h3><h4 id="App到systemserver进程"><a href="#App到systemserver进程" class="headerlink" title="App到systemserver进程"></a>App到systemserver进程</h4><p>Activity 的 startActivity 函数会调用到 ActivityTaskManagerService 的 startActivityAsUser 或者其他几个 start 方法</p><ul><li><p>ActivityTaskManagerService.startActivityAsUser</p></li><li><p>—&gt;ActivityStarter.execute</p></li><li><p>—&gt;ActivityStarter.executeRequest</p><ul><li>内部创建ActivityRecord ： ActivityRecord r &#x3D; new ActivityRecord.Builder(mService)<ul><li>ActivityRecord 继承 WindowToken</li><li>Android 12 构造函数中 appToken &#x3D;  new Token<ul><li>Token extends IApplicationToken.Stub</li></ul></li><li>token，这个东西Android 11，Android12，Android13 这里的代码都不一样。</li><li>Android 13   Token extends Binder<ul><li>ActivityRecord  没有 appToken 变量了，也是new Token，然后传递到 父类 WindowToken 中</li></ul></li><li>由于构造函数中传递的DisplayContent为null，新创建的 ActivityRecord 还不会加入 DisplayContent 的HashMap对象 mTokenMap</li></ul></li></ul></li><li><p>—&gt;ActivityStarter.startActivityUnchecked</p></li><li><p>—&gt;ActivityStarter.startActivityInner</p><ul><li><p>setNewTask</p><p>–&gt;addOrReparentStartingActivity(task, “setTaskFromReuseOrCreateNewTask”);   把 ActivityRecord 添加到任务栈</p><ul><li>给 ActivityRecord 添加 parent : parent.addChild(mStartActivity);   ActivityRecord.getTask 返回的就是这个 targetTask</li><li><strong>addOrReparentStartingActivity 最终会把 ActivityRecord 加入到 DisplayContent .mTokenMap</strong></li></ul></li><li><p>mTargetRootTask.startActivityLocked</p><ul><li>判断当前 activity 是否需要为其新建 Task，将 ActivityRecord 加入到对应的 Task 栈顶中</li><li>ActivityRecord.showStartingWindow  启动过度界面</li></ul></li><li><p>mTargetRootTask.moveToFront</p></li><li><p>RootWindowContainer.resumeFocusedTasksTopActivities&#x3D;&#x3D;&#x3D;&gt;转Task.resumeFocusedTasksTopActivities</p></li><li><p>mSupervisor.mRecentTasks.add(mStartActivity.getTask())</p></li><li><p>其他任务栈相关的处理</p></li></ul></li><li><p>—&gt; Task.resumeFocusedTasksTopActivities</p></li><li><p>—&gt; Task.resumeTopActivityUncheckedLocked</p></li><li><p>—&gt; Task.resumeTopActivityInnerLocked  &#x2F;&#x2F; 这里写是的Android12的流程，Android 13 这里不一样了</p><ul><li>ActivityRecord next &#x3D; topRunningActivity(true &#x2F;* focusableOnly *&#x2F;);</li><li>—&gt;如果有关联的进程，则直接调度生命周期：mAtmService.getLifecycleManager().scheduleTransaction(transaction);</li><li>—&gt;如果是新的activity【mTaskSupervisor.startSpecificActivity(next, true, true)】，事务添加 LaunchActivityItem Callback，用于app进程创建activity。如果没有进程还会创建进程</li></ul></li><li><p>—&gt;ActivityTaskSupervisor.startSpecificActivity</p><ul><li>—&gt; 如果已有进程调用 realStartActivityLocked</li><li>—&gt;没有进程，创建进程流程：mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? “top-activity” : “activity”);</li></ul></li><li><p>–&gt;ATMS.startProcessAsync</p><ul><li>startProcessAsync 只是把任务post给AMS，调用 AMS.startProcess</li></ul></li><li><p>–&gt;ActivityManagerInternal.startProcess</p><ul><li>ActivityManagerInternal.startProcess 是个抽象方法，实现是 ActivityManagerService.LocalService.startProcess</li></ul></li><li><p>–&gt;ActivityManagerService.LocalService.startProcessLocked</p><ul><li>创建 HostingRecord ，并作为参数传给下一步</li><li>HostingRecord .mHostingZygote 属性用于选择 zygote 类型</li><li>HostingRecord 构造函数未传入 hostingZygote 参数，使用默认的 REGULAR_ZYGOTE ，即常规孵化器</li></ul></li><li><p>ActivityManagerService.startProcessLocked  没啥内容，直接调用 ProcessList.startProcessLocked</p></li><li><p>–&gt;16参数的ProcessList.startProcessLocked</p><ul><li>处理 badProcess，连续崩溃超过2次会变成badProcess，后台禁止启动badProcess</li><li>处理隔离进程</li><li>处理不同App在同一个进程情况，App正在启动情况<ul><li>正在启动的话，直接返回</li></ul></li><li>处理App已经死亡，但是死亡通知还未到来的情况</li><li>处理系统还未启动完成情况，先把App存起来，之后处理</li></ul></li><li><p>–&gt;4参数的ProcessList.startProcessLocked  直接转发到6参数的 startProcessLocked</p></li><li><p>–&gt;6参数的ProcessList.startProcessLocked  代码很多主要是设置启动参数</p><ul><li>进程正在启动中，返回</li><li>记录启动开始的时间</li><li>清理参与的 死亡通知信息</li><li>清理mProcessesOnHold用于保存那些在系统还没有准备好就提前请求启动的ProcessRecord</li><li>更新 Profiler 信息</li><li>设置外存储挂载模式、设置App权限：gids</li><li>处理 manifest中设置了android:debuggable 信息，添加debug启动参数</li><li>设置 ABI、设置指令集、设置 selinux</li><li>设置App进程的启动入口为 “<strong>android.app.ActivityThread</strong>“</li></ul></li><li><p>–&gt;ProcessList.startProcess</p><ul><li>启动准备</li><li>设置一些正在启动的标志</li><li>异步启动和同步启动，默认使用异步启动</li></ul></li><li><p>–&gt;ProcessList.handleProcessStart  <strong>异步启动</strong></p><ul><li>如果上一个App还没有死亡通知，则延迟启动，延迟时间最长默认 10 秒</li><li>正常情况直接调用 ProcessList.startProcess</li></ul></li><li><p>–&gt;ProcessList.startProcess</p><ul><li>处理存储目录</li><li><strong>选择创建App进程的孵化器</strong>，由于HostingRecord .mHostingZygote 为 REGULAR_ZYGOTE ，因此调用 Process.start</li></ul></li><li><p>–&gt;Process.start 没啥内容，直接调用 ZygoteProcess.start</p></li><li><p>–&gt;ZygoteProcess.start</p><ul><li>处理usap，usap启用的话，预创建APP进程，最大创建10个线程</li><li>Android 13 由属性 dalvik.vm.usap_pool_enabled 决定是否启用usap，这个属性默认为false</li><li>之后调用 ZygoteProcess.startViaZygote</li></ul></li><li><p>–&gt;ZygoteProcess.startViaZygote  把参数封装成字符串</p></li><li><p>–&gt;ZygoteProcess.zygoteSendArgsAndGetResult  处理一些字符串异常，并加入数据大小</p><ul><li>调用 openZygoteSocketIfNeeded(abi) 连接  ZygoteServer ，根据ABI确定连接 zygote(zygote64) 还是 zygote_secondary(zygote32)</li></ul></li><li><p>–&gt;ZygoteProcess.attemptZygoteSendArgsAndGetResult  写完socket，接着后读socket –&gt;zygoteWriter.write(msgStr);<br> –&gt;使用socket 数据传输到 ZygoteServer</p></li></ul><h4 id="ZygoteServer进程"><a href="#ZygoteServer进程" class="headerlink" title="ZygoteServer进程"></a>ZygoteServer进程</h4><p>从Zygote启动讲起</p><p>ZygoteInit.main   &#x2F;&#x2F; Zygote 有两种启动方式，一种是启动system_server 一种启动App</p><ul><li>main函数<ul><li>1、非懒加载情况下，预加载资源：jar，图形库，drawable、字体</li><li>2、创建zygote进程的socket server服务端对象 ZygoteServer</li><li>3、调用 ZygoteServer.runSelectLoop 进入死循环，等待 AMS 创建进程的socket消息(也会处理其他消息)</li><li>4、调用 runSelectLoop 返回的 Runnable.run 方法</li></ul></li><li>ZygoteServer.runSelectLoop</li><li>ZygoteServer.acceptCommandPeer &#x2F;&#x2F; 得到一个请求连接封装对象ZygoteConnection</li><li>ZygoteConnection.processCommand  &#x2F;&#x2F;处理AMS客户端请求</li><li>Zygote.forkSimpleApps   &#x2F;&#x2F; fork创建应用子进程，<ul><li>ZygoteCommandBuffer.forkRepeatedly &#x2F;&#x2F; 进入native层后，调用 fork()</li><li>Zygote.childMain<ul><li>ZygoteInit.zygoteInit  &#x2F;&#x2F;  开启 binder 消息监听 ,设置异常处理函数</li><li>RuntimeInit.applicationInit</li><li>RuntimeInit.findStaticMain<ul><li>return new MethodAndArgsCaller(m, argv);</li></ul></li></ul></li></ul></li></ul><p>MethodAndArgsCaller 对象不再继承Exception，仅仅继承Runnable，</p><p>MethodAndArgsCaller经过层层 return 后，返回 ZygoteInit.main ，</p><p>最后调用 MethodAndArgsCaller.run 方法 <strong>通过反射创建<code>ActivityThread</code>对象并调用其“<code>main</code>”入口方法。</strong></p><h5 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ZygoteInit.main(String[] argv);</span><br><span class="line">|<span class="type">ZygoteServer</span> <span class="variable">zygoteServer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">|Runnable caller;    </span><br><span class="line"><span class="comment">// 非懒加载情况下，预加载资源</span></span><br><span class="line">|--&gt;<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span>;</span><br><span class="line">|preloadClasses(); <span class="comment">// 加载 /system/etc/preloaded-classes </span></span><br><span class="line"><span class="comment">//  加载非启动使用的类：</span></span><br><span class="line"><span class="comment">///system/framework/android.hidl.base-V1.0-java.jar </span></span><br><span class="line"><span class="comment">///system/framework/android.hidl.manager-V1.0-java.jar</span></span><br><span class="line"><span class="comment">///system/framework/android.test.base.jar</span></span><br><span class="line">    |cacheNonBootClasspathClassLoaders();</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       com.android.internal.R.array.preloaded_drawables</span></span><br><span class="line"><span class="comment">       com.android.internal.R.array.preloaded_color_state_lists</span></span><br><span class="line"><span class="comment">       com.android.internal.R.array.preloaded_freeform_multi_window_drawables</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">|preloadResources();</span><br><span class="line"><span class="comment">// 预加载图形缓存map库</span></span><br><span class="line"><span class="comment">// Gralloc4Mapper::preload();Gralloc3Mapper::preload();Gralloc2Mapper::preload();</span></span><br><span class="line">|nativePreloadAppProcessHALs();</span><br><span class="line"><span class="comment">/* GL driver 或者 Vulkan driver 预加载 */</span></span><br><span class="line">|maybePreloadGraphicsDriver();</span><br><span class="line"><span class="comment">//加载共享库：libandroid.so libcompiler_rt.so libjnigraphics.so</span></span><br><span class="line">|preloadSharedLibraries();</span><br><span class="line"><span class="comment">//TextView.preloadFontCache();  加载字体</span></span><br><span class="line">|preloadTextResources();</span><br><span class="line">|WebViewFactory.prepareWebViewInZygote();</span><br><span class="line"><span class="comment">// native层获取socket fd; 命名空间mount rootfs; selinux_android_seapp_context_init();</span></span><br><span class="line">|Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"><span class="comment">//如果是主Zygote，Zygote 64位，创建地址名为 zygote 的socket服务端，以及usap socket服务 usap_pool_primary</span></span><br><span class="line"><span class="comment">//如果是次Zygote，Zygote 32位，创建地址名为 zygote_secondary 的socket服务端，以及usap socket服务 usap_pool_secondary</span></span><br><span class="line">|zygoteServer = <span class="keyword">new</span> <span class="title class_">ZygoteServer</span>(isPrimaryZygote);</span><br><span class="line"><span class="comment">//如果argv参数中有 &quot;start-system-server&quot; 则fork SystemServer 进程</span></span><br><span class="line">|<span class="keyword">if</span> (startSystemServer)</span><br><span class="line">    |<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line">|r.run();</span><br><span class="line">|<span class="keyword">return</span>;  <span class="comment">// for SystemServer 进程 后直接返回,退出进程</span></span><br><span class="line"><span class="comment">//默认情况，运行 runSelectLoop ，开启 zygoteServer 循环，等待 AMS 创建进程的socket消息</span></span><br><span class="line">|caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">|<span class="keyword">if</span> (caller != <span class="literal">null</span>)  <span class="comment">// fork 完成的子进程，会从runSelectLoop无线循环中跳出，会进入到这里</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果是子进程的话，这里返回的是 MethodAndArgsCaller，MethodAndArgsCaller 继承Runnable</span></span><br><span class="line"><span class="comment">    这里不像以前那样抛出异常清理栈帧，就是回退到 ZygoteInit.main，通过 MethodAndArgsCaller.run调用 android.app.ActivityThread.main</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    |caller.run();</span><br></pre></td></tr></table></figure><h5 id="ZygoteServer-runSelectLoop"><a href="#ZygoteServer-runSelectLoop" class="headerlink" title="ZygoteServer.runSelectLoop"></a>ZygoteServer.runSelectLoop</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Runnable <span class="title function_">runSelectLoop</span><span class="params">(String abiList)</span>;</span><br><span class="line"><span class="comment">//socketFDs[0] 为 ZygoteServer 的fd，之后的数据为 连接客户端的 socket fd</span></span><br><span class="line">|ArrayList&lt;FileDescriptor&gt; socketFDs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">|ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">|socketFDs.add(mZygoteSocket.getFileDescriptor());<span class="comment">// ZygoteServer 的fd</span></span><br><span class="line">|peers.add(<span class="literal">null</span>);<span class="comment">// 先add了一个null，用于和 socketFDs 共用一个下标变量 pollIndex </span></span><br><span class="line">|<span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    |StructPollfd[] pollFDs;</span><br><span class="line">    <span class="comment">//循环起始先把 socketFDs 的fd加入到数组 pollFDs </span></span><br><span class="line"><span class="comment">//之后再把 usapPool 的 fd 加入到 pollFDs</span></span><br><span class="line">    <span class="comment">//usapPoolEventFDIndex 记录 usapPool 起始索引</span></span><br><span class="line">    <span class="comment">//poll监听 socketFDs 中的文件描述符</span></span><br><span class="line">    |Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">|<span class="keyword">while</span> (--pollIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        |<span class="keyword">if</span> (pollIndex == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//pollIndex == 0 表示 ZygoteServer socket 事件</span></span><br><span class="line">            |<span class="type">ZygoteConnection</span> <span class="variable">newPeer</span> <span class="operator">=</span> acceptCommandPeer(abiList); <span class="comment">// 拿到连接客户端的socket</span></span><br><span class="line">|peers.add(newPeer);</span><br><span class="line"><span class="comment">//把客户端的fd放到数组，下一次循环，一起加入到poll监听</span></span><br><span class="line">|socketFDs.add(newPeer.getFileDescriptor());</span><br><span class="line">|<span class="keyword">else</span> <span class="keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) </span><br><span class="line">            <span class="comment">//AMS 创建进程的客户端 socket 事件</span></span><br><span class="line">            |<span class="type">ZygoteConnection</span> <span class="variable">connection</span> <span class="operator">=</span> peers.get(pollIndex);</span><br><span class="line"><span class="comment">//读取socket连接的数据，并处理</span></span><br><span class="line">|<span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> connection.processCommand(<span class="built_in">this</span>, multipleForksOK);</span><br><span class="line"><span class="comment">////默认值为false，在子进程时，会调用 setForkChild 设置为 true</span></span><br><span class="line">|<span class="keyword">if</span> (mIsForkChild)</span><br><span class="line">                <span class="comment">//子进程返回的是 继承Runnable的 MethodAndArgsCaller 对象</span></span><br><span class="line">                |<span class="keyword">return</span> command; <span class="comment">// 子进程直接返回 command ，并结束 runSelectLoop 循环</span></span><br></pre></td></tr></table></figure><h5 id="ZygoteConnection-processCommand"><a href="#ZygoteConnection-processCommand" class="headerlink" title="ZygoteConnection.processCommand"></a>ZygoteConnection.processCommand</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Runnable <span class="title function_">processCommand</span><span class="params">(ZygoteServer zygoteServer, <span class="type">boolean</span> multipleOK)</span>;</span><br><span class="line"><span class="comment">// 创建 native 层对象 NativeCommandBuffer，用于读socket数据 </span></span><br><span class="line">|<span class="type">ZygoteCommandBuffer</span> <span class="variable">argBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZygoteCommandBuffer</span>(mSocket);</span><br><span class="line"><span class="comment">// 把 ZygoteCommandBuffer 传入ZygoteArguments</span></span><br><span class="line"><span class="comment">// 并调用 ZygoteArguments.parseArgs(ZygoteCommandBuffer args, int argCount)</span></span><br><span class="line"><span class="comment">// parseArgs 读取socket，并解析数据</span></span><br><span class="line">|parsedArgs = ZygoteArguments.getInstance(argBuffer);</span><br><span class="line">|<span class="keyword">if</span> (parsedArgs.mPreloadPackage != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 如果是 WebViewZygote，预加载 WebView 的库</span></span><br><span class="line">    |handlePreloadPackage(...);</span><br><span class="line">|<span class="keyword">if</span> (canPreloadApp() &amp;&amp; parsedArgs.mPreloadApp != <span class="literal">null</span>) </span><br><span class="line">    <span class="comment">// 如果是AppZygoteServer，会预加载apk</span></span><br><span class="line">    |handlePreloadApp(...);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mInvokeWith InvokeWith  DEBUG 使用， wrap.sh 脚本相关</span></span><br><span class="line"><span class="comment">mStartChildZygote 创建子zygote进程</span></span><br><span class="line"><span class="comment">multipleOK = true</span></span><br><span class="line"><span class="comment">非系统进程（systemserver、系统App），ATMS就是 SYSTEM_UID </span></span><br><span class="line"><span class="comment">符合以上条件调用 Zygote.forkAndSpecialize，这个和以前也不一样了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">|<span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="literal">null</span> || parsedArgs.mStartChildZygote || !multipleOK || peer.getUid() != Process.SYSTEM_UID)</span><br><span class="line">|pid = Zygote.forkAndSpecialize(...); <span class="comment">// 以前用这个，现在不用了</span></span><br><span class="line">    |<span class="keyword">else</span>  <span class="comment">// 通常情况是走 else 分支，调用 Zygote.forkSimpleApps</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">result</span> <span class="operator">=</span> Zygote.forkSimpleApps(...);</span><br><span class="line">|--&gt;<span class="keyword">static</span> <span class="meta">@Nullable</span> Runnable <span class="title function_">forkSimpleApps</span><span class="params">(...)</span>;</span><br><span class="line">|<span class="type">boolean</span> <span class="variable">in_child</span> <span class="operator">=</span> argBuffer.forkRepeatedly(...);</span><br><span class="line">|<span class="keyword">return</span> nativeForkRepeatedly(...);</span><br><span class="line">| com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(...);</span><br><span class="line">  | NativeCommandBuffer.readAllLines;</span><br><span class="line">  | <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> zygote::forkApp(...); <span class="comment">// fd 的处理</span></span><br><span class="line">| zygote::ForkCommon(...);</span><br><span class="line">|<span class="type">pid_t</span> <span class="variable">pid</span> <span class="operator">=</span> fork(); <span class="comment">// 真正fork进程的地方</span></span><br><span class="line"><span class="comment">//处于子进程时，pid=0，处理分配内存的设置等等</span></span><br><span class="line">|<span class="keyword">return</span> pid;</span><br><span class="line">  |<span class="comment">//如果pid为0，处于子进程，return true;</span></span><br><span class="line">|<span class="keyword">if</span> (in_child) <span class="comment">// 如果是子进程，调用 childMain</span></span><br><span class="line">                |<span class="keyword">return</span> childMain(argBuffer, <span class="comment">/*usapPoolSocket=*/</span><span class="literal">null</span>, <span class="comment">/*writePipe=*/</span><span class="literal">null</span>);</span><br><span class="line">|<span class="keyword">else</span><span class="comment">// 如果是 Zygote 进程，return null;</span></span><br><span class="line">        |<span class="comment">// 子进程返回时，result不为null，return result;    </span></span><br></pre></td></tr></table></figure><h5 id="子进程调用-Zygote-childMain"><a href="#子进程调用-Zygote-childMain" class="headerlink" title="子进程调用 Zygote.childMain"></a>子进程调用 Zygote.childMain</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// frameworks/base/core/java/com/android/internal/os/Zygote.java</span></span><br><span class="line">Zygote.forkSimpleApps(...);</span><br><span class="line">|childMain(argBuffer, <span class="comment">/*usapPoolSocket=*/</span><span class="literal">null</span>, <span class="comment">/*writePipe=*/</span><span class="literal">null</span>);</span><br><span class="line">|--&gt;<span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">childMain</span><span class="params">(ZygoteCommandBuffer argBuffer,LocalServerSocket usapPoolSocket,FileDescriptor writePipe)</span>;</span><br><span class="line">|specializeAppProcess(...);</span><br><span class="line">| nativeSpecializeAppProcess(...);</span><br><span class="line">| com_android_internal_os_Zygote_nativeSpecializeAppProcess();</span><br><span class="line"><span class="comment">//设置命名空间的存储目录挂载</span></span><br><span class="line"><span class="comment">//设置调度策略，selinux，调试模式，SetGids，内存分配模式 等等</span></span><br><span class="line">    |SpecializeCommon(...);</span><br><span class="line">| Thread.currentThread().setPriority(Thread.NORM_PRIORITY); <span class="comment">//设置进程优先级</span></span><br><span class="line">|<span class="keyword">return</span> ZygoteInit.zygoteInit(args.mTargetSdkVersion,args.mDisabledCompatChanges,args.mRemainingArgs,<span class="literal">null</span>);</span><br><span class="line">|RuntimeInit.commonInit();</span><br><span class="line"><span class="comment">//设置异常处理</span></span><br><span class="line">|RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">|Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">KillApplicationHandler</span>(loggingHandler));</span><br><span class="line">|ZygoteInit.nativeZygoteInit(); <span class="comment">//  开启 binder 消息监听</span></span><br><span class="line">|--&gt; com_android_internal_os_ZygoteInit_nativeZygoteInit</span><br><span class="line">                    |--&gt; gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">|--&gt; frameworks/base/cmds/app_process/app_main.cpp</span><br><span class="line">                        |--&gt; onZygoteInit();</span><br><span class="line">|sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">|proc-&gt;startThreadPool();</span><br><span class="line">|<span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);</span><br><span class="line">|<span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">|<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAndArgsCaller</span>(m, argv); <span class="comment">// MethodAndArgsCaller 是个 Runnable, [见：附]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 层层 return 回退到 ZygoteInit.main，通过 MethodAndArgsCaller.run 调用 android.app.ActivityThread.main </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附：MethodAndArgsCaller</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mMethod.invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; mArgs &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、android-app-ActivityThread-main"><a href="#三、android-app-ActivityThread-main" class="headerlink" title="三、android.app.ActivityThread.main"></a>三、android.app.ActivityThread.main</h3><h4 id="1、ActivityThread-main-到-AMS-流程"><a href="#1、ActivityThread-main-到-AMS-流程" class="headerlink" title="1、ActivityThread.main  到 AMS 流程"></a>1、ActivityThread.main  到 AMS 流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ActivityThread.main</span><br><span class="line">  <span class="comment">// 1.创建主线程的 Looper 对象。 main函数最后调用 Looper.loop();启动无线循环。</span></span><br><span class="line">  | Looper.prepareMainLooper();  </span><br><span class="line">  <span class="comment">// 2.创建 ActivityThread 对象</span></span><br><span class="line">  | <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();  </span><br><span class="line"><span class="comment">// 在类成员中直接创建 ApplicationThread，ApplicationThread 继承 IApplicationThread.Stub </span></span><br><span class="line"><span class="comment">// IApplicationThread 是 APP 同 AMS 交互的接口 </span></span><br><span class="line">|<span class="keyword">final</span> <span class="type">ApplicationThread</span> <span class="variable">mAppThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationThread</span>();</span><br><span class="line">  <span class="comment">// 3. 调用 ActivityThread .attach 方法</span></span><br><span class="line">  | thread.attach(<span class="literal">false</span>, startSeq);   </span><br><span class="line">    | <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line"><span class="comment">// mAppThread 是 ApplicationThread </span></span><br><span class="line"><span class="comment">// 通过binder调用AMS的attachApplication接口将 ApplicationThread 注册到AMS中</span></span><br><span class="line">    | mgr.attachApplication(mAppThread, startSeq);  </span><br><span class="line">  <span class="comment">// 进入systemserver进程 的 AMS </span></span><br><span class="line">      | AMS.attachApplicationLocked <span class="comment">//直接转到 attachApplicationLocked</span></span><br><span class="line">        |  ProcessRecord app;  </span><br><span class="line">        | 【<span class="number">1</span>】thread.bindApplication(...); <span class="comment">//binder跨进程 回调 ApplicationThread bindApplication</span></span><br><span class="line">          <span class="comment">// bindApplication流程：</span></span><br><span class="line">          <span class="comment">/*app进程 ApplicationThread .handleBindApplication</span></span><br><span class="line"><span class="comment">            Dex文件的加载和Resource资源的加载</span></span><br><span class="line"><span class="comment">            创建应用的LoadedApk对象、创建Application的Context</span></span><br><span class="line"><span class="comment">            加载应用APK的Dex文件到内存中，加载APK的Resource资源</span></span><br><span class="line"><span class="comment">            调用LoadedApk.makeApplication函数，创建应用的Application对象</span></span><br><span class="line"><span class="comment">            执行应用 Application.onCreate 生命周期函数*/</span></span><br><span class="line">        <span class="comment">// 设置 ProcessRecord.mThread = IApplicationThread(thread)</span></span><br><span class="line">        <span class="comment">// 设置 ProcessRecord.mWindowProcessController.mThread = IApplicationThread(thread)      </span></span><br><span class="line">        | app.makeActive(thread, mProcessStats);  </span><br><span class="line">        <span class="comment">//启动应用 Activity的 流程      </span></span><br><span class="line">        | 【<span class="number">2</span>】mAtmInternal.attachApplication(app.getWindowProcessController()); </span><br><span class="line">          | mRootWindowContainer.attachApplication(wpc);</span><br><span class="line">            | RootWindowContainer::startActivityForAttachedApplicationIfNeeded<span class="comment">//这里Android 13 版本有些变化</span></span><br><span class="line">              | mStackSupervisor.realStartActivityLocked(ActivityRecord r,WindowProcessController proc,<span class="type">boolean</span> andResume,...)</span><br><span class="line">                |r.startFreezingScreenLocked(proc, <span class="number">0</span>); <span class="comment">// 冻结屏幕</span></span><br><span class="line">|r.setProcess(proc);  <span class="comment">// ActivityRecord 关联 WindowProcessController</span></span><br><span class="line"><span class="comment">//创建 ClientTransaction </span></span><br><span class="line"><span class="comment">//ClientTransaction.mClient = WindowProcessController.getThread() 是 App 端的 ApplicationThread</span></span><br><span class="line"><span class="comment">//使用 ActivityRecord.token 赋值 ClientTransaction.mActivityToken</span></span><br><span class="line"><span class="comment">//ClientTransaction.mActivityToken 会传入 客户端app进程</span></span><br><span class="line"><span class="comment">// 注：Android12 用的 ActivityRecord.appToken, Android 12 ActivityRecord.appToken=ActivityRecord.token</span></span><br><span class="line">|<span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">clientTransaction</span> <span class="operator">=</span> ClientTransaction.obtain(proc.getThread(), r.token); </span><br><span class="line"><span class="comment">//  添加 LaunchActivityItem 回调，App进程会执行其execute方法，内部执行 handleLaunchActivity</span></span><br><span class="line">|clientTransaction.addCallback(LaunchActivityItem.obtain(...))</span><br><span class="line">                |lifecycleItem = ResumeActivityItem.obtain(isTransitionForward, r.shouldSendCompatFakeFocus()); </span><br><span class="line"><span class="comment">//App进程会执行 ResumeActivityItem.execute方法 ,内部调用 handleResumeActivity</span></span><br><span class="line">|clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">                <span class="comment">//传递Launch和Resume生命周期事务</span></span><br><span class="line">                | mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">  <span class="comment">// 4. 启动loop无线循环</span></span><br><span class="line">  |  Looper.loop();</span><br></pre></td></tr></table></figure><h4 id="2、scheduleTransaction-跨进程调用，把事务传递到-APP进程"><a href="#2、scheduleTransaction-跨进程调用，把事务传递到-APP进程" class="headerlink" title="2、scheduleTransaction 跨进程调用，把事务传递到 APP进程"></a>2、scheduleTransaction 跨进程调用，把事务传递到 APP进程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ClientLifecycleManager.scheduleTransaction(ClientTransaction transaction);</span><br><span class="line">|transaction.schedule();</span><br><span class="line">|--&gt;ClientTransaction.schedule();</span><br><span class="line"><span class="comment">// IApplicationThread mClient; </span></span><br><span class="line">|mClient.scheduleTransaction(<span class="built_in">this</span>) <span class="comment">//ApplicationThread 继承 IApplicationThread</span></span><br><span class="line">|--&gt;ApplicationThread.scheduleTransaction(ClientTransaction transaction);</span><br><span class="line">|ActivityThread.<span class="built_in">this</span>.scheduleTransaction(transaction);</span><br><span class="line"><span class="comment">//ActivityThread.scheduleTransaction 继承 ClientTransactionHandler.scheduleTransaction</span></span><br><span class="line">|--&gt;ClientTransactionHandler.scheduleTransaction(ClientTransaction transaction);</span><br><span class="line"><span class="comment">//调用 LaunchActivityItem.preExecute 预处理工作</span></span><br><span class="line">|transaction.preExecute(<span class="built_in">this</span>); </span><br><span class="line">|sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); <span class="comment">//post到主线程去处理</span></span><br><span class="line">|--&gt;ActivityThread.H.handleMessage(Message msg);</span><br><span class="line">|mTransactionExecutor.execute(transaction);</span><br><span class="line">|executeCallbacks(transaction);</span><br><span class="line"><span class="comment">//取出ClientTransaction.mActivityToken 作为参数传入 LaunchActivityItem.execute</span></span><br><span class="line">|<span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> transaction.getActivityToken();</span><br><span class="line"><span class="comment">//这个 token = ActivityRecord.appToken</span></span><br><span class="line">|LaunchActivityItem.execute(ClientTransactionHandler client, IBinder token,...);</span><br><span class="line"><span class="comment">//创建 ActivityClientRecord  ActivityClientRecord.token = token;</span></span><br><span class="line"><span class="comment">//Android 12 是在 preExecute 中创建，Android 13 变更到了execute 中</span></span><br><span class="line">|<span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityClientRecord</span>(token, mIntent, mIdent, mInfo,...);</span><br><span class="line"><span class="comment">// 执行 ActivityThread.handleLaunchActivity</span></span><br><span class="line">|client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">|executeLifecycleState(transaction);</span><br><span class="line">|ResumeActivityItem.execute(ClientTransactionHandler client, ActivityClientRecord r,...);</span><br><span class="line"><span class="comment">//执行 ActivityThread.handleResumeActivity</span></span><br><span class="line">                                |client.handleResumeActivity(r, <span class="literal">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,...);</span><br></pre></td></tr></table></figure><p>ActivityClientRecord.token &#x3D; ClientTransaction.mActivityToken &#x3D; ActivityRecord.token</p><p>经过一系列的 事务，生命周期管理相关的代码后 调用 handleLaunchActivity 和 handleResumeActivity</p><h4 id="3、handleLaunchActivity"><a href="#3、handleLaunchActivity" class="headerlink" title="3、handleLaunchActivity"></a>3、handleLaunchActivity</h4><ul><li>执行 Launch 生命周期</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">//frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</span></span><br><span class="line">client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line">ActivityThread.handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent);</span><br><span class="line">|performLaunchActivity(ActivityClientRecord r, Intent customIntent)</span><br><span class="line">    <span class="comment">//1.创建Activity的Context，Activity虽然也是Context，但是其真正的Context是Activity.mBase 成员    </span></span><br><span class="line">    |<span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> createBaseContextForActivity(r);</span><br><span class="line">    <span class="comment">//2.调用 mInstrumentation.newActivity,通过反射创建Activity</span></span><br><span class="line">    |java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> appContext.getClassLoader();</span><br><span class="line">|activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);</span><br><span class="line"><span class="comment">//  把 ActivityClientRecord 存入 mActivities</span></span><br><span class="line"><span class="comment">//ActivityClientRecord.activity 存储 Activity 对象</span></span><br><span class="line">|mActivities.put(r.token, r);</span><br><span class="line">    <span class="comment">//  3.调用 activity.attach 方法</span></span><br><span class="line">|activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo,...);</span><br><span class="line"><span class="comment">//把 performLaunchActivity 创建的 context 设置到 Activity.mBase</span></span><br><span class="line">|attachBaseContext(context);</span><br><span class="line"><span class="comment">//  创建 PhoneWindow 对象</span></span><br><span class="line">|mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window, activityConfigCallback);</span><br><span class="line">|mWindowAttributes = <span class="keyword">new</span> <span class="title class_">WindowManager</span>.LayoutParams();</span><br><span class="line"><span class="comment">// 这个 type 在后边 Window.adjustLayoutParamsForSubWindow 会用到</span></span><br><span class="line">|type = TYPE_APPLICATION;</span><br><span class="line"><span class="comment">//设置Activity key dispatching， panels and menus 等回调。用于拦截点击触摸事件等等</span></span><br><span class="line">|mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//至此：</span></span><br><span class="line"><span class="comment">//activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line">|mToken = token;</span><br><span class="line">|mApplication = application;</span><br><span class="line"><span class="comment">//给 PhoneWindow 对象，设置 WindowManager 对象</span></span><br><span class="line">        |mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, ...);</span><br><span class="line"><span class="comment">//SystemServiceRegistry 静态代码中创建 getSystemService 接口的 WindowManager 实例：</span></span><br><span class="line">|<span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(ctx);</span><br><span class="line"><span class="comment">// SystemServiceRegistry 创建的WindowManagerImpl的成员 mParentWindow=null; mWindowContextToken=null;</span></span><br><span class="line">|<span class="built_in">this</span>(context, <span class="literal">null</span> <span class="comment">/* parentWindow */</span>, <span class="literal">null</span> <span class="comment">/* clientToken */</span>);</span><br><span class="line">|--&gt;Window.setWindowManager(WindowManager wm, IBinder appToken, String appName,<span class="type">boolean</span> hardwareAccelerated);</span><br><span class="line"><span class="comment">//至此：</span></span><br><span class="line"><span class="comment">//PhoneWindow.mAppToken=activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line">|mAppToken = appToken;</span><br><span class="line">|mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="built_in">this</span>);<span class="comment">// 参数传入 PhoneWindow</span></span><br><span class="line">|--&gt;WindowManagerImpl <span class="title function_">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span><br><span class="line">|<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(mContext, parentWindow, mWindowContextToken);</span><br><span class="line">|mContext = context;</span><br><span class="line">|mParentWindow = parentWindow; <span class="comment">// 这个传入的是 PhoneWindow</span></span><br><span class="line">|mWindowContextToken = windowContextToken; <span class="comment">// 这个是 null</span></span><br><span class="line">            | 这个 mWindowManager 对象时<span class="keyword">new</span>的 WindowManagerImpl</span><br><span class="line">            <span class="comment">// 也就是说Activity中的 mWindowManager 对象，获取的window管理器是 WindowManagerImpl</span></span><br><span class="line">        |mWindowManager = mWindow.getWindowManager(); </span><br><span class="line">|r.activity = activity;<span class="comment">//ActivityClientRecord 关联 activity</span></span><br><span class="line"><span class="comment">//4.Instrumentation.callActivityOnCreate---&gt;Activity.onCreate</span></span><br><span class="line">    |mInstrumentation.callActivityOnCreate</span><br><span class="line">          <span class="comment">// 执行Activity的onCreate生命周期函数</span></span><br><span class="line">          <span class="comment">// 在 setContentView 调用installDecor创建 DecorView 对象</span></span><br><span class="line">          <span class="comment">// 并设置 DecorView 的window对象为 PhoneWindow </span></span><br><span class="line">|Activity.performCreate</span><br><span class="line">      |Activity.onCreate</span><br><span class="line">        |Activity.setContentView(R.layout.activity_main);</span><br><span class="line">          |getWindow().setContentView</span><br><span class="line">            |PhoneWindow.installDecor()</span><br><span class="line">                    |mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">|<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecorView</span>(context, featureId, <span class="built_in">this</span>, getAttributes());</span><br><span class="line">|--&gt;DecorView(Context context,..., PhoneWindow window,WindowManager.LayoutParams params)</span><br><span class="line">|setWindow(window);</span><br><span class="line">|mWindow = window; <span class="comment">//PhoneWindow;</span></span><br></pre></td></tr></table></figure><h4 id="4、handleResumeActivity"><a href="#4、handleResumeActivity" class="headerlink" title="4、handleResumeActivity"></a>4、handleResumeActivity</h4><ul><li>执行Resume生命周期</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">//frameworks/base/core/java/android/app/servertransaction/ResumeActivityItem.java</span></span><br><span class="line">client.handleResumeActivity(r, <span class="literal">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward, mShouldSendCompatFakeFocus, <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="comment">// 执行应用Activity的onResume生命周期函数</span></span><br><span class="line">ActivityThread.handleResumeActivity(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,<span class="type">boolean</span> isForward, ...) </span><br><span class="line">  |  performResumeActivity(r, finalStateRequest, reason);</span><br><span class="line">  | 执行应用Activity的onResume生命周期函数</span><br><span class="line">      | r.activity.performResume(r.startsNotResumed, reason); </span><br><span class="line">|mInstrumentation.callActivityOnResume(<span class="built_in">this</span>);</span><br><span class="line">  |activity.onResume();</span><br><span class="line">  <span class="comment">//  handleResumeActivity中执行完毕performResumeActivity后，继续执行以下代码：</span></span><br><span class="line">  |   <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line">  |  r.window = r.activity.getWindow(); <span class="comment">// 赋值 ActivityClientRecord.window</span></span><br><span class="line">  |  <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">  |  decor.setVisibility(View.INVISIBLE);</span><br><span class="line">  |   <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager(); <span class="comment">//activity.attach 中创建的 WindowManagerImpl 对象  </span></span><br><span class="line">  <span class="comment">//  返回的是  Window.mWindowAttributes，即 l = PhoneWindow.mWindowAttributes</span></span><br><span class="line">  |   WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">  |  wm.addView(decor, l);</span><br><span class="line">  |--&gt;WindowManagerImpl.addView(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span><br><span class="line">      |  applyTokens(params); <span class="comment">// 这里虽然看上去是设置 WindowManager.LayoutParams.token 但分析下来不是，还要在后边</span></span><br><span class="line">  |  <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">  |  <span class="keyword">if</span>(mDefaultToken != <span class="literal">null</span> )wparams.token = mDefaultToken; <span class="comment">// 不进这个流程</span></span><br><span class="line">  |   wparams.mWindowContextToken = mWindowContextToken;  <span class="comment">// 目前为止还是 null</span></span><br><span class="line">  |   mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId());</span><br><span class="line">  |--&gt;WindowManagerGlobal.addView(View view, ViewGroup.LayoutParams params, Window parentWindow, ...)</span><br><span class="line">          |   <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">  <span class="comment">//  设置 WindowManager.LayoutParams 的 token、title、packageName、flags 属性</span></span><br><span class="line">          |  parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">  |--&gt;Window.adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp)</span><br><span class="line">              <span class="comment">//  wp.type = TYPE_APPLICATION =2; 如果是startingwindow，这里 wp.type = 3 (startingwindow的flag)</span></span><br><span class="line">|wp.token = mContainer == <span class="literal">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class="line"><span class="comment">//因为 mContainer 是 null, 所以 wp.token = mAppToken </span></span><br><span class="line"><span class="comment">/*至此：</span></span><br><span class="line"><span class="comment">PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line"><span class="comment">PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken */</span></span><br><span class="line">    |  <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display); <span class="comment">//创建ViewRootImpl对象</span></span><br><span class="line">  <span class="comment">//  ViewRootImpl构造函数</span></span><br><span class="line">  |--&gt;ViewRootImpl(Context context, Display display);</span><br><span class="line">|构造函数中创建IWindowSession  对象，用于同 wms 通信</span><br><span class="line">                |<span class="built_in">this</span>(context, display, WindowManagerGlobal.getWindowSession(), <span class="literal">false</span> <span class="comment">/* useSfChoreographer */</span>); </span><br><span class="line">|<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">IWindowSession</span> <span class="variable">sWindowSession</span> <span class="operator">=</span> windowManager.openSession(...)</span><br><span class="line">                    |mWindowSession = sWindowSession</span><br><span class="line">                    <span class="comment">//  W extends IWindow.Stub ，作为参数传递给WMS，用于同 WMS 通信    </span></span><br><span class="line">                    |mWindow = <span class="keyword">new</span> <span class="title class_">W</span>(<span class="built_in">this</span>);    </span><br><span class="line">                    |创建 Choreographer 对象</span><br><span class="line">                    |mChoreographer = useSfChoreographer ? Choreographer.getSfInstance() : Choreographer.getInstance();</span><br><span class="line">|mChoreographer = Choreographer.getInstance();<span class="comment">//以上代码简写</span></span><br><span class="line">  |  </span><br><span class="line">  |  view.setLayoutParams(wparams);</span><br><span class="line">        |  mViews.add(view);</span><br><span class="line">  |  mRoots.add(root);</span><br><span class="line">    |  mParams.add(wparams);</span><br><span class="line">   <span class="comment">//  来到关键点  ViewRootImpl.setview</span></span><br><span class="line">  |  root.setView(view, wparams, panelParentView, userId);</span><br></pre></td></tr></table></figure><p>setview之后看surface创建流程</p><h3 id="四、ViewRootImpl-注册vsync回调"><a href="#四、ViewRootImpl-注册vsync回调" class="headerlink" title="四、ViewRootImpl 注册vsync回调"></a>四、ViewRootImpl 注册vsync回调</h3><h4 id="注册vsync回调流程：Choreographer"><a href="#注册vsync回调流程：Choreographer" class="headerlink" title="注册vsync回调流程：Choreographer"></a>注册vsync回调流程：Choreographer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java复制代码WindowManagerGlobal:: mGlobal.addView</span><br><span class="line">    |<span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display); <span class="comment">//创建ViewRootImpl对象</span></span><br><span class="line">|构造函数中创建 IWindowSession  对象，用于同 wms 通信</span><br><span class="line">        | <span class="built_in">this</span>(context, display, WindowManagerGlobal.getWindowSession(), <span class="literal">false</span> <span class="comment">/* useSfChoreographer */</span>);</span><br><span class="line">|<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">IWindowSession</span> <span class="variable">sWindowSession</span> <span class="operator">=</span> windowManager.openSession(...)</span><br><span class="line">            |mWindowSession = sWindowSession;</span><br><span class="line">|创建 Choreographer 对象</span><br><span class="line">            |mChoreographer = useSfChoreographer ? Choreographer.getSfInstance() : Choreographer.getInstance();</span><br><span class="line"><span class="comment">//  以上代码简写:</span></span><br><span class="line">|mChoreographer = Choreographer.getInstance(); </span><br><span class="line">|--&gt;Choreographer::Choreographer <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//  获取当前线程的 Choreographer,如果当前线程没有，就调用ThreadLocal.initialValue()创建一个新的 Choreographer</span></span><br><span class="line">|<span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">|ThreadLocal.initialValue();</span><br><span class="line">|<span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper(); </span><br><span class="line">|<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP); <span class="comment">// VSYNC_SOURCE_APP = 0;</span></span><br><span class="line"><span class="comment">//Choreographer 构造函数:</span></span><br><span class="line">|Choreographer(Looper looper, <span class="type">int</span> vsyncSource)</span><br><span class="line">                                    |mLooper = looper;</span><br><span class="line">|mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line"><span class="comment">//  创建 FrameDisplayEventReceiver,内部创建 IDisplayEventConnection，并创建vsync的通信socket</span></span><br><span class="line">|mDisplayEventReceiver = <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource);</span><br><span class="line">|mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"><span class="comment">//CALLBACK_LAST = 4</span></span><br><span class="line">|mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//创建 5 个CallbackQueue</span></span><br><span class="line">|<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++)</span><br><span class="line">                                        |mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br></pre></td></tr></table></figure><h4 id="注册vsync回调流程：EventThread"><a href="#注册vsync回调流程：EventThread" class="headerlink" title="注册vsync回调流程：EventThread"></a>注册vsync回调流程：EventThread</h4><p>Choreographer 构造函数创建 FrameDisplayEventReceiver 时，会创建同SurfaceFlinger的EventThread线程通信的 IDisplayEventConnection</p><p>IDisplayEventConnection定义了以下接口：</p><ul><li>void stealReceiveChannel(out BitTube outChannel);获取socket通信管道</li><li>void setVsyncRate(in int count); 设置vsync分发速率。0，不调用requestNextVsync不分发；1，每次vsync事件都分发；其他，每N个vsync事件分发一次<ul><li>系统默认为 0 ，不调用requestNextVsync不分发</li></ul></li><li>oneway void requestNextVsync();  请求vsync</li><li>ParcelableVsyncEventData getLatestVsyncEventData(); 获取最新的</li></ul><p>获取到 IDisplayEventConnection 后，会立刻调用 stealReceiveChannel 获取socket通信管道</p><p><strong>从 FrameDisplayEventReceiver 构造函数开始：</strong></p><h5 id="注册vsync回调流程：APP进程端"><a href="#注册vsync回调流程：APP进程端" class="headerlink" title="注册vsync回调流程：APP进程端"></a>注册vsync回调流程：APP进程端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码Choreographer choreographer = <span class="keyword">new</span> <span class="built_in">Choreographer</span>(Looper.<span class="built_in">myLooper</span>(), VSYNC_SOURCE_APP);</span><br><span class="line">|<span class="comment">//Choreographer 构造函数中 new FrameDisplayEventReceiver</span></span><br><span class="line">|mDisplayEventReceiver = <span class="keyword">new</span> <span class="built_in">FrameDisplayEventReceiver</span>(looper, vsyncSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FrameDisplayEventReceiver 构造函数：</span></span><br><span class="line"><span class="comment">//参数 looper：当前线程的looper;vsyncSource = VSYNC_SOURCE_APP =0;</span></span><br><span class="line"><span class="built_in">FrameDisplayEventReceiver</span>(Looper looper, <span class="type">int</span> vsyncSource);</span><br><span class="line">|<span class="built_in">super</span>(looper, vsyncSource, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//FrameDisplayEventReceiver 继承 DisplayEventReceiver</span></span><br><span class="line">    |<span class="built_in">DisplayEventReceiver</span>(Looper looper, <span class="type">int</span> vsyncSource, <span class="type">int</span> eventRegistration)；</span><br><span class="line">     |mMessageQueue = looper.<span class="built_in">getQueue</span>();</span><br><span class="line"><span class="comment">//创建 NativeDisplayEventReceiver，把对象地址存储到java层的 DisplayEventReceiver.mReceiverPtr 中</span></span><br><span class="line">|mReceiverPtr = <span class="built_in">nativeInit</span>(<span class="keyword">this</span>, mMessageQueue,vsyncSource, eventRegistration);</span><br><span class="line"><span class="comment">//frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</span></span><br><span class="line">|<span class="built_in">nativeInit</span>(..., jobject receiverWeak, jobject messageQueueObj,jint vsyncSource, jint eventRegistration)</span><br><span class="line">                |sp&lt;NativeDisplayEventReceiver&gt; receiver = </span><br><span class="line">                |<span class="keyword">new</span> <span class="built_in">NativeDisplayEventReceiver</span>(env, receiverWeak, messageQueue, vsyncSource, eventRegistration);</span><br><span class="line"><span class="comment">//NativeDisplayEventReceiver 构造函数继续调用父类 DisplayEventDispatcher 的构造函数</span></span><br><span class="line"><span class="comment">//DisplayEventDispatcher 构造函数中创建成员变量 DisplayEventReceiver mReceiver(vsyncSource, eventRegistration)</span></span><br><span class="line"><span class="comment">//DisplayEventReceiver 构造函数：</span></span><br><span class="line"><span class="comment">//frameworks/native/libs/gui/DisplayEventReceiver.cpp</span></span><br><span class="line">|<span class="built_in">DisplayEventReceiver</span>(ISurfaceComposer::VsyncSource vsyncSource,EventRegistrationFlags eventRegistration)</span><br><span class="line">                        <span class="comment">//获取 SurfaceFlinger 服务</span></span><br><span class="line">                        |<span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line"><span class="comment">//获取 IDisplayEventConnection 存储到成员变量 mEventConnection</span></span><br><span class="line">|mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>(vsyncSource, eventRegistration);</span><br><span class="line"><span class="comment">//进入 BpSurfaceComposer.createDisplayEventConnection 开始binder通信</span></span><br><span class="line">|--&gt;<span class="built_in">createDisplayEventConnection</span>(VsyncSource vsyncSource, EventRegistrationFlags eventRegistration)</span><br><span class="line">                            <span class="comment">//  【见 “SurfaceFlinger进程端注册vsync流程” 章节】    </span></span><br><span class="line">                            |<span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(BnSurfaceComposer::CREATE_DISPLAY_EVENT_CONNECTION,data, &amp;reply);</span><br><span class="line">|result = <span class="built_in">interface_cast</span>&lt;IDisplayEventConnection&gt;(reply.<span class="built_in">readStrongBinder</span>());</span><br><span class="line">|<span class="keyword">return</span> result;</span><br><span class="line">|mDataChannel = std::<span class="built_in">make_unique</span>&lt;gui::BitTube&gt;();</span><br><span class="line"><span class="comment">//获取进程间通讯 socket 管道，封装到 BitTube 中，存储到成员变量 mDataChannel</span></span><br><span class="line"><span class="comment">//【详情，见 “SurfaceFlinger进程端注册vsync流程” 章节】 </span></span><br><span class="line">|mEventConnection-&gt;<span class="built_in">stealReceiveChannel</span>(mDataChannel.<span class="built_in">get</span>());</span><br><span class="line">|receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">|DisplayEventDispatcher.<span class="built_in">initialize</span>()</span><br><span class="line">                    <span class="comment">//把 socket 加入    </span></span><br><span class="line">                    |mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);    </span><br><span class="line">|receiver-&gt;<span class="built_in">incStrong</span>(gDisplayEventReceiverClassInfo.clazz);</span><br><span class="line">|<span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><h5 id="注册vsync回调流程：SurfaceFlinger-进程端"><a href="#注册vsync回调流程：SurfaceFlinger-进程端" class="headerlink" title="注册vsync回调流程：SurfaceFlinger 进程端"></a>注册vsync回调流程：SurfaceFlinger 进程端</h5><p>BpSurfaceComposer.createDisplayEventConnection 跨进程进入 SurfaceFlinger 端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="comment">//参数vsyncSource = VSYNC_SOURCE_APP = 0; eventRegistration = 0</span></span><br><span class="line">SurfaceFlinger.<span class="built_in">createDisplayEventConnection</span>(ISurfaceComposer::VsyncSource vsyncSource,EventRegistrationFlags eventRegistration);</span><br><span class="line">|<span class="comment">//eVsyncSourceSurfaceFlinger = 1</span></span><br><span class="line">|   <span class="comment">//handle = mAppConnectionHandle    </span></span><br><span class="line">|<span class="type">const</span> <span class="keyword">auto</span>&amp; handle = vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line">|<span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, eventRegistration);</span><br><span class="line">|--&gt;Scheduler.<span class="built_in">createDisplayEventConnection</span>(ConnectionHandle handle, ISurfaceComposer::EventRegistrationFlags eventRegistration)</span><br><span class="line">    <span class="comment">//std::unordered_map&lt;ConnectionHandle, Connection&gt; mConnections;</span></span><br><span class="line">    <span class="comment">//mConnections 存储的 Connection 是个结构体。仅含有两个成员变量 EventThreadConnection 和 EventThread  [参见：附]</span></span><br><span class="line">    <span class="comment">//mConnections[handle].thread.get() 获取 SurfaceFlinger.mAppConnectionHandle 对应的 EventThread, App的EventThread线程</span></span><br><span class="line">|<span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle].thread.<span class="built_in">get</span>(), eventRegistration);</span><br><span class="line">|--&gt;Scheduler.<span class="built_in">createConnectionInternal</span>( EventThread* eventThread, EventRegistrationFlags eventRegistration)</span><br><span class="line">|<span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>([&amp;] &#123; <span class="built_in">resync</span>(); &#125;, eventRegistration);</span><br><span class="line">|--&gt;EventThread.<span class="built_in">createEventConnection</span>(ResyncCallback resyncCallback, EventRegistrationFlags eventRegistration)</span><br><span class="line">            <span class="comment">//EventThreadConnection 继承 IDisplayEventConnection ，返回APP的IDisplayEventConnection 就是 EventThreadConnection</span></span><br><span class="line">            |<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="keyword">this</span>,IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>(),resyncCallback，eventRegistration）</span><br><span class="line">            <span class="comment">//EventThreadConnection 构造函数：                                     </span></span><br><span class="line">            |--&gt;<span class="built_in">EventThreadConnection</span>(EventThread* eventThread, <span class="type">uid_t</span> callingUid, ResyncCallback resyncCallback,...)</span><br><span class="line">            |: <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">                |<span class="built_in">mOwnerUid</span>(callingUid),</span><br><span class="line">                |   <span class="built_in">mEventRegistration</span>(eventRegistration),                             </span><br><span class="line">                |   <span class="built_in">mEventThread</span>(eventThread),   </span><br><span class="line">                <span class="comment">//创建 BitTube，BitTube 构造函数中创建 socketpair                                 </span></span><br><span class="line">                |   <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize)&#123;&#125; </span><br><span class="line">                    <span class="comment">//BitTube 构造函数                             </span></span><br><span class="line">|BitTube::<span class="built_in">BitTube</span>(<span class="type">size_t</span> bufsize)</span><br><span class="line">                        |<span class="built_in">init</span>(bufsize, bufsize);</span><br><span class="line">                         |<span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">                            |<span class="built_in">socketpair</span>(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets);<span class="comment">// 创建 socketpair</span></span><br><span class="line">                            |mReceiveFd.<span class="built_in">reset</span>(sockets[<span class="number">0</span>]); <span class="comment">// sockets[0] 赋值给 mReceiveFd ，未来会发送到 APP 进程端  </span></span><br><span class="line">                            |mSendFd.<span class="built_in">reset</span>(sockets[<span class="number">1</span>]); </span><br><span class="line">            <span class="comment">//EventThreadConnection 创建完成后，首次 sp 指针引用时调用 onFirstRef()</span></span><br><span class="line">            |EventThreadConnection.<span class="built_in">onFirstRef</span>();</span><br><span class="line">                <span class="comment">//注册 vsync 回调                                 </span></span><br><span class="line">                |mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);                                 </span><br><span class="line">                |--&gt;EventThread::<span class="built_in">registerDisplayEventConnection</span>(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection);</span><br><span class="line">                    |<span class="comment">// 加入vector集合 mDisplayEventConnections</span></span><br><span class="line">                    | <span class="comment">// 这个集合 mDisplayEventConnection 会在 EventThread::threadMain 循环遍历                           </span></span><br><span class="line">                    |mDisplayEventConnections.<span class="built_in">push_back</span>(connection);</span><br><span class="line">                    |mCondition.<span class="built_in">notify_all</span>();  </span><br><span class="line"></span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line"><span class="comment">// App进程端获取到 IDisplayEventConnection 后，立即就调用了stealReceiveChannel 接口获取 socket fd：                                                  </span></span><br><span class="line">|--&gt;EventThreadConnection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel)</span><br><span class="line">    <span class="comment">//把构造EventThreadConnection时，创建的 socketpair的fd 写到APP进程的 BitTube 中</span></span><br><span class="line">    |outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">|outChannel-&gt;<span class="built_in">setSendFd</span>(base::<span class="built_in">unique_fd</span>(<span class="built_in">dup</span>(mChannel.<span class="built_in">getSendFd</span>())));                                                </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line"><span class="comment">// 附： Scheduler.Connection 结构体</span></span><br><span class="line">    <span class="keyword">struct</span> Connection &#123;</span><br><span class="line">        sp&lt;EventThreadConnection&gt; connection;</span><br><span class="line">        std::unique_ptr&lt;EventThread&gt; thread;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="五、ViewRootImpl-setView"><a href="#五、ViewRootImpl-setView" class="headerlink" title="五、ViewRootImpl.setView"></a>五、ViewRootImpl.setView</h3><ol><li><p>注册 vsync 回调 <strong>IDisplayEventConnection</strong></p></li><li><p>ViewRootImpl.setView 函数中调用 <strong>requestLayout 请求vsync流程</strong></p></li><li><p>ViewRootImpl.setView 函数中调用 WindowSession.</p><p>addToDisplayAsUser</p><p>​    **创建 ISurfaceComposerClient  **</p><ul><li>addToDisplayAsUser 还有个功能是 创建 InputChannel</li></ul></li></ol><p>​       传入一个null的 inputChannel 对象到 addToDisplayAsUser，这个 inputChannel ，在wms端创建，并赋值到inputChannel ，实际就是 socketpair</p><ol><li>vsync回调回来后 调用ViewRootImpl.**relayoutWindow 创建 Surface **</li></ol><h4 id="ViewRootImpl-requestLayout-请求vsync流程"><a href="#ViewRootImpl-requestLayout-请求vsync流程" class="headerlink" title="ViewRootImpl.requestLayout 请求vsync流程"></a>ViewRootImpl.requestLayout 请求vsync流程</h4><p>衔接第三章的 setView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">//frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></span><br><span class="line">root.setView(view, wparams, panelParentView, userId); <span class="comment">// 调用ViewRootImpl 的setview方法 关键方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line">ViewRootImpl.setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</span><br><span class="line"><span class="comment">//【一】、请求vsync：</span></span><br><span class="line">| requestLayout();  <span class="comment">//请求vsync ，vsync回调后，开启界面绘制流程======！！！！！！！！！！！！！**</span></span><br><span class="line">  | scheduleTraversals();</span><br><span class="line">    |mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">    |--&gt;Choreographer.postCallback(<span class="type">int</span> callbackType, Runnable action, Object token)</span><br><span class="line">      | postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">      | postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">            <span class="comment">// 这里把 mTraversalRunnable 加入到 mCallbackQueues 数组</span></span><br><span class="line">            | mCallbackQueues[callbackType].**addCallbackLocked**(dueTime, action, token);</span><br><span class="line">      | scheduleFrameLocked</span><br><span class="line">                | scheduleVsyncLocked();</span><br><span class="line">            |   mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">         |--&gt;DisplayEventReceiver.scheduleVsync();</span><br><span class="line">      | nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">        <span class="comment">// android_view_DisplayEventReceiver.cpp </span></span><br><span class="line">                            | nativeScheduleVsync()</span><br><span class="line">          <span class="comment">// DisplayEventDispatcher.cpp</span></span><br><span class="line">                                | scheduleVsync()</span><br><span class="line"><span class="comment">//IDisplayEventConnection mEventConnection=sf-&gt;createDisplayEventConnection</span></span><br><span class="line">          | mReceiver.requestNextVsync();</span><br><span class="line"><span class="comment">// 之后跨进程调用到 SurfaceFlinger 的 requestNextVsync 方法</span></span><br><span class="line">            | DisplayEventReceiver.cpp--requestNextVsync(); </span><br><span class="line">              | mEventConnection-&gt;requestNextVsync();</span><br><span class="line">              | EventThreadConnection::requestNextVsync()</span><br><span class="line">              | EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection)</span><br><span class="line">                | mCondition.notify_all();<span class="comment">//唤醒 app EventThread 线程</span></span><br><span class="line"><span class="comment">//sf 启动后 EventThread 线程会在 threadMain 循环</span></span><br><span class="line">                | EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span><br><span class="line">                  | mCondition.wait(lock);<span class="comment">// 从阻塞中唤醒</span></span><br><span class="line">                  | mVSyncSource-&gt;setVSyncEnabled(<span class="literal">true</span>);</span><br><span class="line">                    | DispSyncSource::setVSyncEnabled(bool enable)</span><br><span class="line">                    | 又经过很多代码，最终：</span><br><span class="line">                    | VSyncDispatchTimerQueue::setTimer(nsecs_t targetTime, nsecs_t <span class="comment">/*now*/</span>)</span><br><span class="line">                    | Timer::alarmAt(std::function&lt;<span class="keyword">void</span>()&gt; const&amp; cb, nsecs_t time)</span><br><span class="line">                    | 最终的最终调用“系统调用”，timerfd_settime 设置定时发送vsync</span><br><span class="line">                    | timerfd_settime(mTimerFd, TFD_TIMER_ABSTIME, &amp;new_timer, &amp;old_timer)</span><br><span class="line"></span><br><span class="line">            | 之后就是异步代码了，之后很快就启动了vsync，之后vsync事件回调app进程的doFrame方法</span><br></pre></td></tr></table></figure><h4 id="IWindowSession-addToDisplayAsUser–-gt-WMS-addWindow"><a href="#IWindowSession-addToDisplayAsUser–-gt-WMS-addWindow" class="headerlink" title="IWindowSession.addToDisplayAsUser–&gt;WMS.addWindow"></a>IWindowSession.addToDisplayAsUser–&gt;WMS.addWindow</h4><ul><li>1、创建 WindowState</li><li>2、创建 InputChannel</li><li>3、创建同 SurfaceFlinger 的连接 ISurfaceComposerClient</li><li>4、更新焦点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">java复制代码root.setView(view, wparams, panelParentView, userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line">ViewRootImpl.setView(View view, WindowManager.LayoutParams attrs, View panelParentView);</span><br><span class="line">|mView = view; <span class="comment">// 把 DecorView 存储到 mView </span></span><br><span class="line"><span class="comment">//把 WindowManagerGlobal.addView 设置过 token 的wparams数据复制到 mWindowAttributes</span></span><br><span class="line">|mWindowAttributes.copyFrom(attrs);</span><br><span class="line"><span class="comment">/*至此：</span></span><br><span class="line"><span class="comment">WindowToken.token 是 IBinder 类</span></span><br><span class="line"><span class="comment">ActivityRecord 继承 WindowToken</span></span><br><span class="line"><span class="comment">ActivityRecord 有个内部类 ActivityRecord.Token 继承 Binder</span></span><br><span class="line"><span class="comment">ActivityRecord.token 这个成员继承自 WindowToken，是内部类 ActivityRecord.Token 的实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line"><span class="comment">ViewRootImpl.mWindowAttributes.mToken = PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//加入 PRIVATE_FLAG_USE_BLAST flag，这个flag在创建  SurfaceControl 时会用到 </span></span><br><span class="line">|mWindowAttributes.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_USE_BLAST;</span><br><span class="line"><span class="comment">//【一】、请求vsync</span></span><br><span class="line">|requestLayout();</span><br><span class="line">|<span class="type">InputChannel</span> <span class="variable">inputChannel</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 一个null的inputChannel，传递到WMS端赋值</span></span><br><span class="line"><span class="comment">//【二】、创建 ISurfaceComposerClient</span></span><br><span class="line"><span class="comment">//  mWindow 参数为 [W extends IWindow.Stub]，作为参数传递给WMS，用于同 WMS 通信</span></span><br><span class="line">|mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes..., userId,..., inputChannel, mTempInsets,...)</span><br><span class="line">    <span class="comment">//参数 attrs.token = ActivityRecord.token</span></span><br><span class="line">|--&gt;WindowManagerService.mService.addWindow(<span class="built_in">this</span>, window, attrs, viewVisibility, displayId, userId, equestedVisibility, outInputChannel, outInsetsState, outActiveControls);</span><br><span class="line"><span class="comment">// 【1】、从 DisplayContent.mTokenMap 中检索token</span></span><br><span class="line"><span class="comment">//  在 setNewTask 时，以ActivityRecord.token为键，已经把ActivityRecord加入了DisplayContent.mTokenMap</span></span><br><span class="line"><span class="comment">//所以能取到 token， 这个token不为 null</span></span><br><span class="line">|   <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line"><span class="comment">//如果 token为null，这里会走创建token流程：</span></span><br><span class="line"><span class="comment">//binder 为 ViewRootImpl.mWindowAttributes.mToken = ActivityRecord.token</span></span><br><span class="line">|   <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line"><span class="comment">//WindowToken 构造函数中，传入的 DisplayContent 参数不为null时，加入 DisplayContent.mTokenMap</span></span><br><span class="line">|   token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>.Builder(<span class="built_in">this</span>, binder, type).setDisplayContent(displayContent)....build();</span><br><span class="line">|<span class="comment">// WindowToken 构造函数：</span></span><br><span class="line">    |WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type...DisplayContent dc,...)</span><br><span class="line">        |token = _token;</span><br><span class="line">|<span class="keyword">if</span> (dc != <span class="literal">null</span>) dc.addWindowToken(token, <span class="built_in">this</span>); <span class="comment">// 加入 DisplayContent.mTokenMap</span></span><br><span class="line"><span class="comment">// 【2】、创建 WindowState </span></span><br><span class="line">  |   <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow, appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow);</span><br><span class="line"><span class="comment">//  WindowState构造函数</span></span><br><span class="line">|--&gt;WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,WindowState parentWindow...)</span><br><span class="line">        |mSession = s;</span><br><span class="line">|mClient = c;</span><br><span class="line">|mToken = token;</span><br><span class="line"><span class="comment">/*至此：</span></span><br><span class="line"><span class="comment">PhoneWindow.mAppToken = activity.mToken = ActivityClientRecord.token = ClientTransaction.mActivityToken = ActivityRecord.token</span></span><br><span class="line"><span class="comment">参数attrs.token = ViewRootImpl.mWindowAttributes.mToken = PhoneWindow.mWindowAttributes.token = PhoneWindow.mAppToken </span></span><br><span class="line"><span class="comment">WindowState.mToken = ActivityRecord */</span></span><br><span class="line">|mActivityRecord = mToken.asActivityRecord(); <span class="comment">// 把token转为 ActivityRecord</span></span><br><span class="line">|<span class="type">InputApplicationHandle</span> <span class="variable">tempIAHandle</span> <span class="operator">=</span> mActivityRecord.getInputApplicationHandle(<span class="literal">false</span>);</span><br><span class="line">            |--&gt;ActivityRecord.getInputApplicationHandle(<span class="type">boolean</span> update);</span><br><span class="line">            ||mInputApplicationHandle = <span class="keyword">new</span> <span class="title class_">InputApplicationHandle</span>(token, toString(),mInputDispatchingTimeoutMillis);</span><br><span class="line">|<span class="comment">//InputApplicationHandle 构造函数：</span></span><br><span class="line">||--&gt;InputApplicationHandle(<span class="meta">@NonNull</span> IBinder token, <span class="meta">@NonNull</span> String name,<span class="type">long</span> dispatchingTimeoutMillis);</span><br><span class="line">||<span class="built_in">this</span>.token = token;</span><br><span class="line">||<span class="keyword">return</span> mInputApplicationHandle;</span><br><span class="line">|<span class="comment">//创建 InputWindowHandleWrapper，包装为InputWindowHandle，用于输入输出，焦点更新等等，是wms，SurfaceFlinger，input 传递数据的对象</span></span><br><span class="line">|mInputWindowHandle = <span class="keyword">new</span> <span class="title class_">InputWindowHandleWrapper</span>(<span class="keyword">new</span> <span class="title class_">InputWindowHandle</span>(tempIAHandle, getDisplayId()))</span><br><span class="line">            |<span class="comment">//InputWindowHandle  构造函数： </span></span><br><span class="line">            ||--&gt;InputWindowHandle(InputApplicationHandle inputApplicationHandle, <span class="type">int</span> displayId);</span><br><span class="line">            |    |<span class="built_in">this</span>.inputApplicationHandle = inputApplicationHandle;</span><br><span class="line">            |<span class="comment">//  InputWindowHandleWrapper 构造函数：  </span></span><br><span class="line">            ||--&gt;InputWindowHandleWrapper(<span class="meta">@NonNull</span> InputWindowHandle handle);</span><br><span class="line">|<span class="comment">// WindowState.mInputWindowHandle.mHandle 为InputWindowHandle对象，这个对象会传到 SurfaceFlinger</span></span><br><span class="line">|<span class="comment">// WindowState.mInputWindowHandle.mHandle.inputApplicationHandle.token = ActivityRecord.token</span></span><br><span class="line">            |    |mHandle = handle;</span><br><span class="line">|mWinAnimator = <span class="keyword">new</span> <span class="title class_">WindowStateAnimator</span>(<span class="built_in">this</span>);<span class="comment">// 创建 WindowStateAnimator</span></span><br><span class="line"><span class="comment">// 【3】、InputChannel 创建流程：</span></span><br><span class="line">|   win.openInputChannel(outInputChannel);</span><br><span class="line">|--&gt;WindowState.openInputChannel(InputChannel outInputChannel);</span><br><span class="line">|mInputChannel = mWmService.mInputManager.createInputChannel(name);</span><br><span class="line">|--&gt;InputManagerService.createInputChannel(String name);</span><br><span class="line">                    |--&gt;NativeInputManagerService.createInputChannel(String name);</span><br><span class="line">                    |--&gt;nativeCreateInputChannel(JNIEnv* env, jobject nativeImplObj, jstring nameObj);</span><br><span class="line">                    |--&gt;NativeInputManager.createInputChannel(const std::string&amp; name);</span><br><span class="line">                    |--&gt;InputDispatcher::createInputChannel(const std::string&amp; name);</span><br><span class="line">|std::unique_ptr&lt;InputChannel&gt; serverChannel;</span><br><span class="line">|std::unique_ptr&lt;InputChannel&gt; clientChannel;</span><br><span class="line"><span class="comment">//1、创建 socketpair</span></span><br><span class="line">|InputChannel::openInputChannelPair(name, serverChannel, clientChannel);</span><br><span class="line">|--&gt;InputChannel::openInputChannelPair(...InputChannel outServerChannel,outClientChannel)</span><br><span class="line">|<span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">|socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets);<span class="comment">// 创建 socketpair</span></span><br><span class="line">                                        |sp&lt;IBinder&gt; token = <span class="keyword">new</span> <span class="title class_">BBinder</span>(); <span class="comment">//  创建token</span></span><br><span class="line">|std::<span class="type">string</span> <span class="variable">serverChannelName</span> <span class="operator">=</span> name + <span class="string">&quot; (server)&quot;</span>;</span><br><span class="line">|outServerChannel = InputChannel::create(serverChannelName, sockets[<span class="number">0</span>], token);</span><br><span class="line">|std::<span class="type">string</span> <span class="variable">clientChannelName</span> <span class="operator">=</span> name + <span class="string">&quot; (client)&quot;</span>;</span><br><span class="line">|outClientChannel = InputChannel::create(clientChannelName, sockets[<span class="number">1</span>], token);</span><br><span class="line"><span class="comment">//  获取InputChannel.mToken， 这个 token = new BBinder();</span></span><br><span class="line">                                    |const sp&lt;IBinder&gt;&amp; token = serverChannel-&gt;getConnectionToken();</span><br><span class="line"><span class="comment">//2、使用 serverChannel 创建 connection</span></span><br><span class="line">|sp&lt;Connection&gt; connection = <span class="keyword">new</span> <span class="title class_">Connection</span>(std::move(serverChannel), <span class="literal">false</span> , ...);</span><br><span class="line"><span class="comment">//以token为键，把 connection 加入 mConnectionsByToken</span></span><br><span class="line"><span class="comment">//serverChannel 和 clientChannel 共用一个token，用来寻找彼此</span></span><br><span class="line"><span class="comment">//服务端加入mConnectionsByToken，一个返回到WMS，WMS再返回给App</span></span><br><span class="line">|mConnectionsByToken.emplace(token, connection);</span><br><span class="line"><span class="comment">//3、服务端的 socket fd 加入 epoll 监听</span></span><br><span class="line">|<span class="type">int</span> <span class="variable">fd</span> <span class="operator">=</span> serverChannel-&gt;getFd();</span><br><span class="line">|mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, <span class="keyword">new</span> <span class="title class_">LooperEventCallback</span>(callback), nullptr);</span><br><span class="line">|mLooper-&gt;wake();</span><br><span class="line">|<span class="keyword">return</span> clientChannel; <span class="comment">// 返回客户端的 InputChannel </span></span><br><span class="line">|mInputChannelToken = mInputChannel.getToken(); <span class="comment">// 获取 native 创建的 token</span></span><br><span class="line"><span class="comment">//mInputWindowHandle.</span></span><br><span class="line">|mInputWindowHandle.setToken(mInputChannelToken);</span><br><span class="line"><span class="comment">// WindowState.InputWindowHandleWrapper.InputWindowHandle.token = native层创建的 token</span></span><br><span class="line"><span class="comment">//InputWindowHandle.token 这个token 很重要，是 SurfaceFlinger，input 沟通用的令牌，比如焦点更新</span></span><br><span class="line"><span class="comment">//InputWindowHandle.InputApplicationHandle.token = ActivityRecord.token</span></span><br><span class="line"><span class="comment">//wms会透过 SurfaceTransition 把InputWindowHandle传递给 SurfaceFlinger 的 Layer.mDrawingState.inputInfo</span></span><br><span class="line"><span class="comment">//到这里 Inputms，wms，ams, SurfaceFlinger 就这么连接起来了。</span></span><br><span class="line">|mHandle.token = token;</span><br><span class="line"><span class="comment">//以 mInputChannelToken 为键，把 WindowState 存入WMS的 HashMap</span></span><br><span class="line">|mWmService.mInputToWindowMap.put(mInputChannelToken, <span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//把 native 层创建的客户端InputChannel返回给 APP </span></span><br><span class="line">|mInputChannel.copyTo(outInputChannel);</span><br><span class="line">|res = ADD_OKAY;</span><br><span class="line">|<span class="comment">// mUseBLAST = (settings get global  use_blast_adapter_vr == 1)</span></span><br><span class="line">        |   <span class="comment">// global settings 中没有设置这个 use_blast_adapter_vr 值的话，默认值为 true</span></span><br><span class="line">|<span class="keyword">if</span> (mUseBLAST)res |= WindowManagerGlobal.ADD_FLAG_USE_BLAST;</span><br><span class="line"><span class="comment">// 【4】、 创建 SurfaceSession---&gt; 创建SurfaceFlinger的客户端 ISurfaceComposerClient</span></span><br><span class="line">  |   win.attach();</span><br><span class="line">    |mSession.windowAddedLocked();</span><br><span class="line"><span class="comment">//WindowState.mSession.mSurfaceSession.mNativeClient.mClient保存了用于SurfaceFlinger通信的 ISurfaceComposerClient</span></span><br><span class="line">      |Session.mSurfaceSession = <span class="keyword">new</span> <span class="title class_">SurfaceSession</span>();</span><br><span class="line">        <span class="comment">//SurfaceSession  内容很少，大概60行的代码。就是个 Native 的Java包装类</span></span><br><span class="line"><span class="comment">//SurfaceSession.mNativeClient 是个 SurfaceComposerClient 类</span></span><br><span class="line"><span class="comment">//SurfaceComposerClient.mClient 成员是个 ISurfaceComposerClient， 用于SurfaceFlinger通信</span></span><br><span class="line">        |SurfaceSession.mNativeClient = nativeCreate();</span><br><span class="line">          <span class="comment">//android_view_SurfaceSession.cpp </span></span><br><span class="line">          |android_view_SurfaceSession.nativeCreate</span><br><span class="line">            |SurfaceComposerClient* client = <span class="keyword">new</span> <span class="title class_">SurfaceComposerClient</span>();</span><br><span class="line"><span class="comment">//  sp指针引用会调用 SurfaceComposerClient::onFirstRef() </span></span><br><span class="line">            |client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">              |SurfaceComposerClient::onFirstRef()</span><br><span class="line">                                    |sp&lt;ISurfaceComposer&gt; <span class="title function_">sf</span><span class="params">(ComposerService::getComposerService()</span>);</span><br><span class="line"><span class="comment">//SurfaceComposerClient.mClient 是 ISurfaceComposerClient</span></span><br><span class="line">                |mClient = sf-&gt;createConnection();</span><br><span class="line">            |<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以 IWindow 为键，把 WindowState 加入到 mWindowMap</span></span><br><span class="line">| mWindowMap.put(client.asBinder(), win);</span><br><span class="line"><span class="comment">//把 WindowState 加入到  ActivityRecord.token ，成为其子节点</span></span><br><span class="line"><span class="comment">//  ActivityRecord.mSurfaceControl  和  WindowState.mSurfaceControl 应该都会创建。</span></span><br><span class="line"><span class="comment">//  这个流程会创建 WindowState.mSurfaceControl，继承的父类 WindowToken.mSurfaceControl</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 这里的代码应该没这么简单，具体流程待研究。创建SurfaceControl，意味着创建Layer。这里应该是创建 ContainerLayer 和 EffectLayer 相关</span></span><br><span class="line">| win.mToken.addWindow(win);</span><br><span class="line">|--&gt;WindowToken.addWindow(<span class="keyword">final</span> WindowState win)</span><br><span class="line">            |<span class="keyword">if</span> (mSurfaceControl == <span class="literal">null</span>)</span><br><span class="line">                |createSurfaceControl(<span class="literal">true</span> <span class="comment">/* force */</span>);</span><br><span class="line"><span class="comment">//更新焦点</span></span><br><span class="line">| updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,<span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br></pre></td></tr></table></figure><h3 id="六、vsync-回调"><a href="#六、vsync-回调" class="headerlink" title="六、vsync 回调"></a>六、vsync 回调</h3><h4 id="1、SurfaceFlinger进程端：-vsync-事件分发"><a href="#1、SurfaceFlinger进程端：-vsync-事件分发" class="headerlink" title="1、SurfaceFlinger进程端： vsync 事件分发"></a>1、SurfaceFlinger进程端： vsync 事件分发</h4><p>这里简单写写吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码EventThread::<span class="built_in">onVSyncEvent</span>(<span class="type">nsecs_t</span> timestamp, VSyncSource::VSyncData vsyncData)</span><br><span class="line">|mPendingEvents.<span class="built_in">push_back</span>(<span class="built_in">makeVSync</span>(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count,...);</span><br><span class="line">|mCondition.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒 EventThread::threadMain 处wait代码</span></span><br><span class="line"></span><br><span class="line">EventThread::<span class="built_in">threadMain</span>(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span><br><span class="line">|std::vector&lt;sp&lt;EventThreadConnection&gt;&gt; consumers;</span><br><span class="line">|<span class="keyword">while</span> (mState != State::Quit) </span><br><span class="line">    |std::optional&lt;DisplayEventReceiver::Event&gt; event;</span><br><span class="line">|<span class="comment">//...</span></span><br><span class="line">|<span class="keyword">if</span> (mState == State::Idle) &#123;<span class="comment">//界面不动，进这里wait</span></span><br><span class="line">    |mCondition.<span class="built_in">wait</span>(lock);</span><br><span class="line">    |<span class="comment">//...    </span></span><br><span class="line">|<span class="keyword">if</span> (!mPendingEvents.<span class="built_in">empty</span>()) <span class="comment">// 被唤醒后开始处理 mPendingEvents</span></span><br><span class="line">        |event = mPendingEvents.<span class="built_in">front</span>();</span><br><span class="line">|mPendingEvents.<span class="built_in">pop_front</span>();</span><br><span class="line">|<span class="comment">//...</span></span><br><span class="line">    |<span class="keyword">auto</span> it = mDisplayEventConnections.<span class="built_in">begin</span>();</span><br><span class="line">    |<span class="comment">// mDisplayEventConnections是存储所有 EventThreadConnection 的 vector</span></span><br><span class="line">|<span class="keyword">while</span> (it != mDisplayEventConnections.<span class="built_in">end</span>())</span><br><span class="line">        |<span class="comment">//  EventThreadConnection 为虚引用，这里 promote 提升为强引用</span></span><br><span class="line">        |<span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> connection = it-&gt;<span class="built_in">promote</span>())</span><br><span class="line">            |<span class="keyword">if</span> (event &amp;&amp; <span class="built_in">shouldConsumeEvent</span>(*event, connection))</span><br><span class="line">                |<span class="comment">// 对于需要消费这个事件的EventThreadConnection存入入 vector 中</span></span><br><span class="line">            |consumers.<span class="built_in">push_back</span>(connection);</span><br><span class="line">| ++it;</span><br><span class="line">|<span class="keyword">else</span></span><br><span class="line">            |it = mDisplayEventConnections.<span class="built_in">erase</span>(it);<span class="comment">// 如果虚引用的对象销毁了，则从集合删除</span></span><br><span class="line">    |<span class="keyword">if</span> (!consumers.<span class="built_in">empty</span>()) &#123;<span class="comment">//集合不为空，开始分发事件</span></span><br><span class="line">        |<span class="built_in">dispatchEvent</span>(*event, consumers);</span><br><span class="line">        |--&gt;EventThread::<span class="built_in">dispatchEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event, <span class="type">const</span> DisplayEventConsumers&amp; consumers)</span><br><span class="line">            |<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; consumer : consumers)</span><br><span class="line">                |DisplayEventReceiver::Event copy = event;</span><br><span class="line">                |<span class="built_in">generateFrameTimeline</span>(copy.vsync.vsyncData,...);</span><br><span class="line">        |consumer-&gt;<span class="built_in">postEvent</span>(copy)</span><br><span class="line">                |--&gt;EventThreadConnection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span><br><span class="line">                    |DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">        |gui::BitTube::<span class="built_in">sendObjects</span>(dataChannel, events, count);</span><br><span class="line">        |<span class="type">ssize_t</span> size = tube-&gt;<span class="built_in">write</span>(vaddr, count * objSize);</span><br><span class="line">        |--&gt;BitTube::<span class="built_in">write</span>(<span class="type">void</span> <span class="type">const</span>* vaddr, <span class="type">size_t</span> size)</span><br><span class="line">                                |<span class="comment">// mSendFd 是 socketpair 的fd</span></span><br><span class="line">                                |len = ::<span class="built_in">send</span>(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br></pre></td></tr></table></figure><h4 id="2、APP进程端：接收vsync回调"><a href="#2、APP进程端：接收vsync回调" class="headerlink" title="2、APP进程端：接收vsync回调"></a>2、APP进程端：接收vsync回调</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java复制代码epoll回调</span><br><span class="line">| DisplayEventDispatcher::handleEvent</span><br><span class="line">  | processPendingEvents 使用 socketpair 的BitTube 在d中取出 VSync 事件</span><br><span class="line">    | DisplayEventReceiver::getEvents() </span><br><span class="line">    | BitTube::recvObjects</span><br><span class="line">    | linux 系统调用 ::recv</span><br><span class="line">  | dispatchVsync</span><br><span class="line">    <span class="comment">// env-&gt;CallVoidMethod 回到 JAVA 层的 DisplayEventReceiver.dispatchVsync() </span></span><br><span class="line">    | DisplayEventReceiver.dispatchVsync()</span><br><span class="line">      <span class="comment">// /frameworks/base/core/java/android/view/Choreographer.java</span></span><br><span class="line">      | FrameDisplayEventReceiver.onVsync</span><br><span class="line">        | <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);<span class="comment">//传入的回调是this，即FrameDisplayEventReceiver.run() ;</span></span><br><span class="line">        | mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        | 之后进入FrameDisplayEventReceiver.run()方法调用 doFrame </span><br><span class="line">          | <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame, DisplayEventReceiver.VsyncEventData vsyncEventData)</span></span><br><span class="line">            | doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos, frameIntervalNanos)</span><br><span class="line">            | doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">            | doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">            | doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">              | ViewRootImpl.mTraversalRunnable.run()</span><br><span class="line">                | doTraversal();</span><br><span class="line">                  | performTraversals();</span><br><span class="line">                    |relayoutWindow <span class="comment">//创建 Surface 流程</span></span><br><span class="line">            | doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos, frameIntervalNanos);</span><br></pre></td></tr></table></figure><h4 id="3、ViewRootImpl-relayoutWindow-创建-Surface"><a href="#3、ViewRootImpl-relayoutWindow-创建-Surface" class="headerlink" title="3、ViewRootImpl.relayoutWindow 创建 Surface"></a>3、ViewRootImpl.relayoutWindow 创建 Surface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">java复制代码ViewRootImpl.mTraversalRunnable.run()</span><br><span class="line">| doTraversal();</span><br><span class="line">  | performTraversals(); </span><br><span class="line"><span class="comment">// 如果是ViewRootImpl刚创建，还没执行过performTraversals，或者窗口需要resize，或者显示属性变化,需要执行 relayoutWindow</span></span><br><span class="line">    | relayoutWindow   <span class="comment">//创建surface流程 + sf 创建layer流程</span></span><br><span class="line"></span><br><span class="line">ViewRootImpl.relayoutWindow(WindowManager.LayoutParams params, <span class="type">int</span> viewVisibility,<span class="type">boolean</span> insetsPending);</span><br><span class="line">|mWindowSession.relayout(mWindow, params,requestedWidth, requestedHeight,...mSurfaceControl, mTempInsets, mTempControls, mRelayoutBundle);</span><br><span class="line">|<span class="comment">// 【接口层：ViewRootImpl.mSurfaceControl 构造流程】</span></span><br><span class="line">|android.view.IWindowSession.Stub.Proxy.relayout(...android.view.SurfaceControl outSurfaceControl,...)</span><br><span class="line">        |<span class="comment">// 调用 system_server 进程 Session.relayout  【转到： &quot;system_server 进程 Session.relayout&quot;】</span></span><br><span class="line">        |<span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">|<span class="comment">//若干步骤太多了不写了QTNND...</span></span><br><span class="line">|IPCThreadState::transact(...);</span><br><span class="line">|IPCThreadState::waitForResponse(...);<span class="comment">//binder通信</span></span><br><span class="line">|<span class="comment">// 从 system_server 进程返回后，从 _reply 读取返回的 SurfaceControl 到 outSurfaceControl，即 ViewRootImpl.mSurfaceControl</span></span><br><span class="line">|outSurfaceControl.readFromParcel(_reply); </span><br><span class="line"></span><br><span class="line"><span class="comment">// system_server 进程 Session.relayout</span></span><br><span class="line">|--&gt;Session.relayout(IWindow window, WindowManager.LayoutParams attrs,...SurfaceControl outSurfaceControl,...)</span><br><span class="line">    <span class="comment">//进入system_server进程的 WMS</span></span><br><span class="line">  |mService.relayoutWindow(<span class="built_in">this</span>, window, attrs,requestedWidth, requestedHeight,... outSurfaceControl,...)</span><br><span class="line">    |--&gt;WindowManagerService.relayoutWindow(Session session, IWindow client, LayoutParams attrs,...SurfaceControl outSurfaceControl,...)</span><br><span class="line">    |<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    |<span class="comment">//从 WindowManagerService.mWindowMap 获取之前addToDisplayAsUser流程存储的 WindowState</span></span><br><span class="line">    |<span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> windowForClientLocked(session, client, <span class="literal">false</span>);</span><br><span class="line">|<span class="comment">// WindowState.mWinAnimator: WindowState构造函数中创建的</span></span><br><span class="line">|<span class="type">WindowStateAnimator</span> <span class="variable">winAnimator</span> <span class="operator">=</span> win.mWinAnimator;</span><br><span class="line">|result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</span><br><span class="line">    |--&gt;WindowManagerService.createSurfaceControl(SurfaceControl outSurfaceControl, <span class="type">int</span> result,WindowState win, WindowStateAnimator winAnimator)</span><br><span class="line">            |<span class="type">WindowSurfaceController</span> <span class="variable">surfaceController</span> <span class="operator">=</span> winAnimator.createSurfaceLocked();</span><br><span class="line">|--&gt;WindowStateAnimator.createSurfaceLocked()</span><br><span class="line">                |<span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">w</span> <span class="operator">=</span> mWin; <span class="comment">// WindowState构造函数中会把WindowState自身传入WindowStateAnimator.mWin</span></span><br><span class="line">|<span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">attrs</span> <span class="operator">=</span> w.mAttrs;</span><br><span class="line">|<span class="keyword">final</span> <span class="type">int</span> <span class="variable">format</span> <span class="operator">=</span> isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;</span><br><span class="line">|<span class="comment">// 1、创建 WindowSurfaceController，赋值到 WindowStateAnimator.mSurfaceController</span></span><br><span class="line">        ||mSurfaceController = <span class="keyword">new</span> <span class="title class_">WindowSurfaceController</span>(attrs.getTitle().toString(), format, flags, <span class="built_in">this</span>, attrs.type);</span><br><span class="line"><span class="comment">//WindowSurfaceController 构造函数</span></span><br><span class="line">|--&gt;WindowSurfaceController(String name, <span class="type">int</span> format, <span class="type">int</span> flags, WindowStateAnimator animator,<span class="type">int</span> windowType)</span><br><span class="line">                    |mAnimator = animator; title = name; mService = animator.mService;</span><br><span class="line">|<span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> animator.mWin;</span><br><span class="line">|mWindowType = windowType;</span><br><span class="line">|mWindowSession = win.mSession;</span><br><span class="line">|<span class="comment">// 注意这里的 parent = WindowState.mSurfaceControl</span></span><br><span class="line">|SurfaceControl.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> win.makeSurface().setParent(win.getSurfaceControl()).setName(name).setFormat(format)</span><br><span class="line">                        .setFlags(flags).setMetadata(METADATA_WINDOW_TYPE, windowType).setMetadata(...mUid).setMetadata(...mPid)...;</span><br><span class="line">|<span class="comment">//mService.mUseBLAST = (settings get global  use_blast_adapter_vr == 1)</span></span><br><span class="line">                        <span class="comment">//global  settings 中没有设置这个 use_blast_adapter_vr 值的话，默认值为 true</span></span><br><span class="line">                        <span class="comment">//PRIVATE_FLAG_USE_BLAST 这个 flag 是在 ViewRootImpl.setview 设置的</span></span><br><span class="line">                        <span class="comment">//综上，useBLAST = true</span></span><br><span class="line">|<span class="type">boolean</span> <span class="variable">useBLAST</span> <span class="operator">=</span> mService.mUseBLAST &amp;&amp; ((win.getAttrs().privateFlags&amp; LayoutParams.PRIVATE_FLAG_USE_BLAST) != <span class="number">0</span>);</span><br><span class="line">|<span class="keyword">if</span> (useBLAST) b.setBLASTLayer();</span><br><span class="line">|<span class="comment">//FX_SURFACE_BLAST = 0x00040000; 对应于  ISurfaceComposerClient.eFXSurfaceBufferState = 0x00040000</span></span><br><span class="line">|--&gt;SurfaceControl.Builder.setFlags(FX_SURFACE_BLAST, FX_SURFACE_MASK); </span><br><span class="line">|<span class="comment">// 2、创建Java层的 SurfaceControl ，赋值到 WindowStateAnimator.mSurfaceController.mSurfaceControl</span></span><br><span class="line">        |  |mSurfaceControl = b.build();</span><br><span class="line">        |  ||<span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata,mLocalOwnerView, mCallsite);</span><br><span class="line">|--&gt;SurfaceControl(SurfaceSession session, String name, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> format, <span class="type">int</span> flags, SurfaceControl parent...)</span><br><span class="line">||mName = name;mWidth = w;mHeight = h;mLocalOwnerView = localOwnerView;</span><br><span class="line">|<span class="comment">// 3、创建native层的 SurfaceControl，赋值到 WindowStateAnimator.mSurfaceController.mSurfaceControl.mNativeObject</span></span><br><span class="line">        |    |   mNativeObject = nativeCreate(session, name, w, h, format, flags,... metaParcel);</span><br><span class="line">        |      |||   <span class="comment">// /frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line">        |                |--&gt;nativeCreate(..., jobject sessionObj,jstring nameStr, jint w, jint h, jint format, jint flags, ...)</span><br><span class="line">                ||   sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">|client = android_view_SurfaceSession_getClient(env, sessionObj);</span><br><span class="line">|sp&lt;SurfaceControl&gt; surface;<span class="comment">// surface 作为引用参数传入</span></span><br><span class="line">|client-&gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;surface,flags, parentHandle...);</span><br><span class="line">|<span class="comment">// /frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line">                |   SurfaceComposerClient.createSurfaceChecked(const String8&amp; name,...,sp&lt;SurfaceControl&gt;* outSurface,...)</span><br><span class="line">                |                   |sp&lt;IBinder&gt; handle;</span><br><span class="line">|||sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">|||<span class="type">int32_t</span> <span class="variable">id</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        |          |mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,... &amp;handle, &amp;gbp, &amp;id, &amp;transformHint);   </span><br><span class="line">                    |<span class="comment">//surfaceflinger/Client.cpp</span></span><br><span class="line">                |    ||mFlinger-&gt;createLayer</span><br><span class="line">        |           |  |<span class="comment">// 进入SurfaceFlinger进程，创建layer流程 【转“SurfaceFlinger创建layer”章节】</span></span><br><span class="line">                      |SurfaceFlinger::createLayer(name, <span class="built_in">this</span>, w, h, format,... handle, gbp, parentHandle, outLayerId,...)  </span><br><span class="line">        |       |  |*outSurface = <span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(<span class="built_in">this</span>, handle, gbp, id, w, h, format,...flags);</span><br><span class="line">|||<span class="comment">// 4、使用SurfaceFlinger创建的 handle，GraphicBufferProducer,layerId 构造native层的 SurfaceControl</span></span><br><span class="line">|||<span class="comment">// GraphicBufferProducer 图形buffer的生产者，handle用于layer销毁时SurfaceFlinger端回调，和layer检索</span></span><br><span class="line">|SurfaceControl(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">                            |                          const sp&lt;IGraphicBufferProducer&gt;&amp; gbp, int32_t layerId,</span><br><span class="line">        |       |                                      uint32_t w, uint32_t h, PixelFormat format, uint32_t transform,uint32_t flags)</span><br><span class="line">                    |       |           |: mClient(client), mHandle(handle), mGraphicBufferProducer(gbp), mTransformHint(transform) </span><br><span class="line">        |       |           |           |  mWidth(w),mHeight(h),mFormat(format),mCreateFlags(flags) &#123;&#125;</span><br><span class="line">||<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());<span class="comment">// 返回native创建的 SurfaceControl </span></span><br><span class="line">|   <span class="comment">// 如果native有 mBbqChild ，返回 mBbqChild.mHandle，否则直接返回native SurfaceControl.mHandle</span></span><br><span class="line">        |    ||||mNativeHandle = nativeGetHandle(mNativeObject);/</span><br><span class="line">|w.mInputWindowHandle.forceChange();</span><br><span class="line">|<span class="keyword">return</span> mSurfaceController;</span><br><span class="line">      ||surfaceController.getSurfaceControl(outSurfaceControl);<span class="comment">//====================!!!</span></span><br><span class="line">|--&gt;WindowSurfaceController.getSurfaceControl(SurfaceControl outSurfaceControl)</span><br><span class="line">                |<span class="comment">// 传入的是 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl</span></span><br><span class="line">                |<span class="comment">// 5、把AMS创建的 SurfaceControl 数据，复制给需要返回 App进程的对象 outSurfaceControl</span></span><br><span class="line">                |outSurfaceControl.copyFrom(mSurfaceControl, <span class="string">&quot;WindowSurfaceController.getSurfaceControl&quot;</span>);</span><br><span class="line">|--&gt;SurfaceControl.copyFrom(<span class="meta">@NonNull</span> SurfaceControl other, String callsite)</span><br><span class="line">                    |<span class="comment">// 几个重要成员复制</span></span><br><span class="line">                    |mName = other.mName; mLocalOwnerView = other.mLocalOwnerView;</span><br><span class="line">|mWidth = other.mWidth; mHeight = other.mHeight;</span><br><span class="line">|<span class="comment">// native层SurfaceControl复制， 以及 mNativeObject、mNativeHandle 复制</span></span><br><span class="line">|assignNativeObject(nativeCopyFromSurfaceControl(other.mNativeObject), callsite);</span><br><span class="line">|--&gt;nativeCopyFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) </span><br><span class="line">                            |sp&lt;SurfaceControl&gt; <span class="title function_">surface</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>);</span><br><span class="line">|<span class="comment">// native 层创建新的 SurfaceControl</span></span><br><span class="line">                                <span class="comment">// 把 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl.mNativeObject 数据复制到新的 SurfaceControl 对象</span></span><br><span class="line">|sp&lt;SurfaceControl&gt; newSurface = <span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(surface);</span><br><span class="line">|--&gt;SurfaceControl::SurfaceControl(const sp&lt;SurfaceControl&gt;&amp; other)</span><br><span class="line">                                    |mClient = other-&gt;mClient; mHandle = other-&gt;mHandle;</span><br><span class="line">|mGraphicBufferProducer = other-&gt;mGraphicBufferProducer;</span><br><span class="line">|mTransformHint = other-&gt;mTransformHint; mLayerId = other-&gt;mLayerId;</span><br><span class="line">|mWidth = other-&gt;mWidth; mHeight = other-&gt;mHeight;</span><br><span class="line">|mFormat = other-&gt;mFormat; mCreateFlags = other-&gt;mCreateFlags;</span><br><span class="line">|<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(newSurface.get()); <span class="comment">// 返回新的SurfaceControl地址到Java层的 outSurfaceControl</span></span><br><span class="line">|--&gt;SurfaceControl.assignNativeObject(<span class="type">long</span> nativeObject, String callsite)</span><br><span class="line">                            |mNativeObject = nativeObject; <span class="comment">// 把native地址赋值到 SurfaceControl.mNativeObject</span></span><br><span class="line">|<span class="comment">//这里不展开了，没有mBbqChild，还是使用 WindowState.mWinAnimator.mSurfaceController.mSurfaceControl.mNativeObject.mHandle</span></span><br><span class="line">|mNativeHandle = nativeGetHandle(nativeObject);</span><br><span class="line">|<span class="keyword">return</span> result; <span class="comment">// END  WindowManagerService.createSurfaceControl</span></span><br><span class="line">|</span><br><span class="line">|mWindowPlacerLocked.performSurfacePlacement(<span class="literal">true</span> <span class="comment">/* force */</span>); <span class="comment">// 执行 Surface 的摆放工作</span></span><br><span class="line">|<span class="comment">// 如果焦点变化了更新焦点</span></span><br><span class="line">|updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, <span class="literal">true</span> <span class="comment">/*updateInputWindows*/</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 回到 APP进程端：ViewRootImpl.relayoutWindow            </span></span><br><span class="line"><span class="comment">//(1) 非 useBLAST 的情况：(Android12以后代码不会走这里)</span></span><br><span class="line">|<span class="comment">//6、创建 Surface          </span></span><br><span class="line">|mSurface.copyFrom(mSurfaceControl); </span><br><span class="line">|--&gt;Surface.copyFrom(SurfaceControl other)</span><br><span class="line">    |<span class="type">long</span> <span class="variable">surfaceControlPtr</span> <span class="operator">=</span> other.mNativeObject;</span><br><span class="line">|<span class="comment">// 获取 native 层的 Surface 地址</span></span><br><span class="line">    |<span class="type">long</span> <span class="variable">newNativeObject</span> <span class="operator">=</span> nativeGetFromSurfaceControl(mNativeObject, surfaceControlPtr);</span><br><span class="line">|--&gt;nativeGetFromSurfaceControl(JNIEnv* env, jclass clazz,jlong nativeObject, jlong surfaceControlNativeObj)</span><br><span class="line">        |sp&lt;SurfaceControl&gt; <span class="title function_">ctrl</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>);</span><br><span class="line">|sp&lt;Surface&gt; <span class="title function_">surface</span><span class="params">(ctrl-&gt;getSurface()</span>);<span class="comment">// 创建native Surface</span></span><br><span class="line">|--&gt;SurfaceControl.getSurface()</span><br><span class="line">|<span class="keyword">return</span> generateSurfaceLocked(); </span><br><span class="line">|--&gt;SurfaceControl.generateSurfaceLocked()</span><br><span class="line">|<span class="comment">// Android 11版本以前，这个函数内部直接创建 Surface 返回：new Surface(mGraphicBufferProducer, false);</span></span><br><span class="line">                |<span class="comment">// Android 12 这里使用 BBQ ，还从这里连接 SurfaceFlinger 创建layer。ViewRootImpl不走这里，目前这里的流程不知道给谁用的</span></span><br><span class="line">|mBbqChild = mClient-&gt;createSurface(String8(<span class="string">&quot;bbq-wrapper&quot;</span>), <span class="number">0</span>, <span class="number">0</span>, mFormat,flags, mHandle, &#123;&#125;, &amp;ignore);</span><br><span class="line">                |<span class="comment">// 以下流程展开参考【创建Surface：useBLAST】章节   </span></span><br><span class="line">|mBbq = sp&lt;BLASTBufferQueue&gt;::make(<span class="string">&quot;bbq-adapter&quot;</span>, mBbqChild, mWidth, mHeight, mFormat);</span><br><span class="line">|mSurfaceData = mBbq-&gt;getSurface(<span class="literal">true</span>); <span class="comment">// 返回 new BBQSurface</span></span><br><span class="line">|<span class="keyword">return</span> mSurfaceData;</span><br><span class="line">|surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">|<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());<span class="comment">//返回 native 的 Surface 地址</span></span><br><span class="line">    |updateNativeObject(newNativeObject)</span><br><span class="line">|--&gt;updateNativeObject(<span class="type">long</span> newNativeObject)</span><br><span class="line">|setNativeObjectLocked(newNativeObject);</span><br><span class="line">|--&gt;setNativeObjectLocked(<span class="type">long</span> ptr)</span><br><span class="line">|mNativeObject = ptr;<span class="comment">// 把新的native的Surface地址存储到 Surface.mNativeObject</span></span><br><span class="line"><span class="comment">//(2)useBLAST 的情况：(Android13 代码走这里，在Android12的基础上稍微变化了一下)</span></span><br><span class="line">|updateBlastSurfaceIfNeeded(); </span><br><span class="line">|mBlastBufferQueue = <span class="keyword">new</span> <span class="title class_">BLASTBufferQueue</span>(mTag, mSurfaceControl, mSurfaceSize.x, mSurfaceSize.y, mWindowAttributes.format);</span><br><span class="line">|mBlastBufferQueue.setTransactionHangCallback(sTransactionHangCallback);</span><br><span class="line">|<span class="type">Surface</span> <span class="variable">blastSurface</span> <span class="operator">=</span> mBlastBufferQueue.createSurface();</span><br><span class="line">|mSurface.transferFrom(blastSurface);</span><br></pre></td></tr></table></figure><h5 id="创建Surface：useBLAST-BBQ"><a href="#创建Surface：useBLAST-BBQ" class="headerlink" title="创建Surface：useBLAST (BBQ)"></a>创建Surface：useBLAST (BBQ)</h5><p>接续上一章节“useBLAST 的情况”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="comment">// useBLAST 函数：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mForceDisableBLAST 使用默认值false</span></span><br><span class="line"><span class="comment">mUseBLASTAdapter：如果 WMS.addWindow 返回值带有flag WindowManagerGlobal.ADD_FLAG_USE_BLAST ，则为 true。[见：IWindowSession.addToDisplayAsUser]</span></span><br><span class="line"><span class="comment">Android 12 后有这个flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">useBLAST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mUseBLASTAdapter &amp;&amp; !mForceDisableBLAST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 useBLAST() 返回 true，则调用 updateBlastSurfaceIfNeeded(); </span></span><br><span class="line"><span class="comment">// 接续上一章节“useBLAST 的情况”</span></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line">updateBlastSurfaceIfNeeded(); </span><br><span class="line">|<span class="comment">// 【1】创建 BLASTBufferQueue</span></span><br><span class="line">|<span class="comment">// 参数：mSurfaceControl 是在 ViewRootImpl.mWindowSession.relayout 的接口层调用 mSurfaceControl.readFromParcel 填充的数据</span></span><br><span class="line">|mBlastBufferQueue = <span class="keyword">new</span> <span class="title class_">BLASTBufferQueue</span>(mTag, mSurfaceControl, mSurfaceSize.x, mSurfaceSize.y, mWindowAttributes.format);</span><br><span class="line">|<span class="comment">// Java层 BLASTBufferQueue 构造</span></span><br><span class="line">|--&gt;BLASTBufferQueue (String name, SurfaceControl sc, <span class="type">int</span> width, <span class="type">int</span> height, <span class="meta">@PixelFormat</span>.Format <span class="type">int</span> format)</span><br><span class="line">    |mNativeObject = nativeCreate(name, <span class="literal">true</span>);<span class="comment">// 创建 native 层 BLASTBufferQueue，返回的地址存储到 mNativeObject</span></span><br><span class="line">|<span class="comment">//【2】创建 native BLASTBufferQueue</span></span><br><span class="line">    |<span class="comment">//frameworks/base/core/jni/android_graphics_BLASTBufferQueue.cpp </span></span><br><span class="line">|--&gt;nativeCreate(JNIEnv* env, jclass clazz, jstring jName, jboolean updateDestinationFrame)</span><br><span class="line">        |sp&lt;BLASTBufferQueue&gt; queue = <span class="keyword">new</span> <span class="title class_">BLASTBufferQueue</span>(name.c_str(), updateDestinationFrame);</span><br><span class="line">|<span class="comment">// native 层 BLASTBufferQueue 构造，Android 13的构造函数相比 Android 12 少了一部分内容，那部分内容放到了 BLASTBufferQueue::update</span></span><br><span class="line">|--&gt;BLASTBufferQueue::BLASTBufferQueue(const std::string&amp; name, bool updateDestinationFrame)</span><br><span class="line">            |: mSurfaceControl(nullptr),mSize(<span class="number">1</span>, <span class="number">1</span>),mRequestedSize(mSize),mFormat(PIXEL_FORMAT_RGBA_8888),</span><br><span class="line">|mTransactionReadyCallback(nullptr),mSyncTransaction(nullptr),mUpdateDestinationFrame(updateDestinationFrame)&#123;</span><br><span class="line">            |<span class="comment">// 【3】创建 BufferQueueCore、BBQBufferQueueProducer、BufferQueueConsumer     </span></span><br><span class="line">            |createBufferQueue(&amp;mProducer, &amp;mConsumer); <span class="comment">//[转 BLASTBufferQueue::createBufferQueue  章节]</span></span><br><span class="line">                <span class="comment">// BufferQueueProducer.mDequeueTimeout = int64.max</span></span><br><span class="line">            |mProducer-&gt;setDequeueTimeout(std::numeric_limits&lt;int64_t&gt;::max());    </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                BufferQueueCore:</span></span><br><span class="line"><span class="comment">    std::set&lt;int&gt; mFreeSlots;    // 初始添加 2个int</span></span><br><span class="line"><span class="comment">    std::list&lt;int&gt; mUnusedSlots;  // 初始添加 64 int值</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">                setMaxDequeuedBufferCount(2)的结果：</span></span><br><span class="line"><span class="comment">                1)从 BufferQueueCore.mUnusedSlots 中取出 1 个并删除，然后插入 BufferQueueCore.mFreeSlots;</span></span><br><span class="line"><span class="comment">                   mUnusedSlots 长度变为 63，mFreeSlots长度变为 3</span></span><br><span class="line"><span class="comment">                       (mFreeSlots，是dequeuebuffer数据来源，其长度代表最大可dequeue的数量，当前为3，表示三级缓存)</span></span><br><span class="line"><span class="comment">                2)BufferQueueCore.mMaxDequeuedBufferCount = 2; BufferQueueCore.mMaxAcquiredBufferCount = 1;</span></span><br><span class="line"><span class="comment">                3)调整完毕mMaxDequeuedBufferCount后,如果 dequeueBuffer 处于等待buffer状态，会被唤醒拿取buffer</span></span><br><span class="line"><span class="comment">                函数调用完成后，如果调用 getMaxBufferCountLocked，在同步模式下：</span></span><br><span class="line"><span class="comment">                BufferQueueCore.getMaxBufferCountLocked() = mMaxDequeuedBufferCount + mMaxAcquiredBufferCount = 3 (三级缓存)</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            |mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);  </span><br><span class="line">            |<span class="comment">// 【4】创建 BLASTBufferItemConsumer 并设置生产者消费者监听   </span></span><br><span class="line">            |mBufferItemConsumer = <span class="keyword">new</span> <span class="title class_">BLASTBufferItemConsumer</span>(mConsumer,USAGE_HW_COMPOSER|USAGE_HW_TEXTURE, <span class="number">1</span>, <span class="literal">false</span>, <span class="built_in">this</span>);</span><br><span class="line">            |--&gt;BLASTBufferItemConsumer(IGBConsumer&amp; consumer,uint64_t consumerUsage,<span class="type">int</span> bufferCount, bool controlledByApp, wp&lt;BLASTBufferQueue&gt; bbq)</span><br><span class="line">                : BufferItemConsumer(consumer, consumerUsage, bufferCount, controlledByApp),<span class="comment">//构造父类BufferItemConsumer</span></span><br><span class="line">                  mBLASTBufferQueue(std::move(bbq)),<span class="comment">/* 存储 BBQ*/</span>mCurrentlyConnected(<span class="literal">false</span>),mPreviouslyConnected(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">                |--&gt;:BufferItemConsumer(sp&lt;IGraphicBufferConsumer&gt;&amp; consumer,uint64_t consumerUsage,<span class="type">int</span> bufferCount, bool controlledByApp)</span><br><span class="line">                    : ConsumerBase(consumer, controlledByApp)&#123;</span><br><span class="line">                            <span class="comment">// BufferQueueCore.mConsumerUsageBits = GraphicBuffer::USAGE_HW_COMPOSER |GraphicBuffer::USAGE_HW_TEXTURE;</span></span><br><span class="line">                            mConsumer-&gt;setConsumerUsageBits(consumerUsage);</span><br><span class="line">                            <span class="comment">// 默认 BufferQueueCore-&gt;mMaxAcquiredBufferCount = 1，bufferCount=1, 所以这里无用功</span></span><br><span class="line">                            mConsumer-&gt;setMaxAcquiredBufferCount(bufferCount);</span><br><span class="line">                        &#125;</span><br><span class="line">                |--&gt;ConsumerBase.ConsumerBase(const sp&lt;IGraphicBufferConsumer&gt;&amp; bufferQueue, bool controlledByApp)</span><br><span class="line">                        : mAbandoned(<span class="literal">false</span>),mConsumer(bufferQueue),mPrevFinalReleaseFence(Fence::NO_FENCE)&#123;</span><br><span class="line">                                <span class="comment">// 创建未命令的名字，这里的名字会被之后 BLASTBufferQueue 构造函数的代码覆盖</span></span><br><span class="line">                                mName = String8::format(<span class="string">&quot;unnamed-%d-%d&quot;</span>, getpid(), createProcessUniqueId());</span><br><span class="line">                                wp&lt;ConsumerListener&gt; listener = static_cast&lt;ConsumerListener*&gt;(<span class="built_in">this</span>);</span><br><span class="line">                                sp&lt;IConsumerListener&gt; proxy = <span class="keyword">new</span> <span class="title class_">BufferQueue</span>::ProxyConsumerListener(listener);</span><br><span class="line">                                <span class="comment">//【5】调用消费者的 connect 函数，这里的代码执行结果：</span></span><br><span class="line">                                <span class="comment">// 1、赋值 BufferQueueCore 的消费者监听: BufferQueueCore.mConsumerListener = ConsumerBase</span></span><br><span class="line">                                <span class="comment">// 2、BufferQueueCore.mConsumerControlledByApp = false</span></span><br><span class="line">                                <span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> mConsumer-&gt;consumerConnect(proxy, controlledByApp);</span><br><span class="line">                                mConsumer-&gt;setConsumerName(mName);<span class="comment">// 名字传给 BufferQueueConsumer、BufferQueueCore</span></span><br><span class="line">                            &#125;</span><br><span class="line">            <span class="comment">//consumerName = &quot;ViewRootImpl#[id](BLAST Consumer)[id]&quot;    </span></span><br><span class="line">            <span class="comment">//BufferQueueCore.mConsumerName = BufferQueueConsumer.mConsumerName = BufferItemConsumer父类ConsumerBase.mName = consumerName;    </span></span><br><span class="line">            |mBufferItemConsumer-&gt;setName(String8(consumerName.c_str()));    </span><br><span class="line">                <span class="comment">//ConsumerBase.mFrameAvailableListener =  BLASTBufferQueue</span></span><br><span class="line">            |mBufferItemConsumer-&gt;setFrameAvailableListener(<span class="built_in">this</span>); <span class="comment">// queuebuffer后，通知消费者的监听</span></span><br><span class="line">                <span class="comment">//BufferItemConsumer.mBufferFreedListener =  BLASTBufferQueue</span></span><br><span class="line">            |mBufferItemConsumer-&gt;setBufferFreedListener(<span class="built_in">this</span>);    <span class="comment">// 通知生产者的的监听</span></span><br><span class="line">            |ComposerService::getComposerService()-&gt;getMaxAcquiredBufferCount(&amp;mMaxAcquiredBuffers);<span class="comment">// 从是sf获取MaxAcquiredBufferCount</span></span><br><span class="line">                <span class="comment">// 赋值 sf 的MaxAcquiredBufferCount</span></span><br><span class="line">            |mBufferItemConsumer-&gt;setMaxAcquiredBufferCount(mMaxAcquiredBuffers);</span><br><span class="line">            |mCurrentMaxAcquiredBufferCount = mMaxAcquiredBuffers;    </span><br><span class="line">            |&#125;</span><br><span class="line">|<span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(queue.get());<span class="comment">// 返回 native BLASTBufferQueue 地址</span></span><br><span class="line">|nativeUpdate(mNativeObject, sc.mNativeObject, width, height, format);</span><br><span class="line">|--&gt;nativeUpdate(JNIEnv* env, jclass clazz, jlong ptr, jlong surfaceControl, jlong width,jlong height, jint format)</span><br><span class="line">        |sp&lt;BLASTBufferQueue&gt; queue = reinterpret_cast&lt;BLASTBufferQueue*&gt;(ptr);</span><br><span class="line">|queue-&gt;update(reinterpret_cast&lt;SurfaceControl*&gt;(surfaceControl), width, height, format);</span><br><span class="line">|--&gt;BLASTBufferQueue.update(const sp&lt;SurfaceControl&gt;&amp; surface, uint32_t width, uint32_t height,int32_t format)</span><br><span class="line">            |<span class="comment">// 这些值，在 BufferQueueProducer::connect 函数中，会再返回 Surface</span></span><br><span class="line">            |mFormat = format;BufferQueueCore-&gt;mDefaultBufferFormat = mFormat;</span><br><span class="line">|mSurfaceControl = surface;</span><br><span class="line">|mTransformHint = mSurfaceControl-&gt;getTransformHint();BufferQueueCore-&gt;mTransformHint = mTransformHint;</span><br><span class="line">|<span class="comment">// 这里的宽高，来源是 ViewRootImpl.relayout 后通过 WindowLayout::computeSurfaceSize 计算的宽高</span></span><br><span class="line">|mRequestedSize = newSize(width, height);</span><br><span class="line">|mSize = mRequestedSize;</span><br><span class="line">|BufferQueueCore-&gt;mDefaultWidth = mRequestedSize.width;BufferQueueCore-&gt;mDefaultHeight = mRequestedSize.height;</span><br><span class="line">|<span class="comment">//之后再把 宽高 通过事务传递到sf</span></span><br><span class="line">            |SurfaceComposerClient::Transaction.setApplyToken(mApplyToken).apply(<span class="literal">false</span>, <span class="literal">true</span>);    </span><br><span class="line">|mBlastBufferQueue.setTransactionHangCallback(sTransactionHangCallback);<span class="comment">// GPU hang 回调</span></span><br><span class="line">|<span class="type">Surface</span> <span class="variable">blastSurface</span> <span class="operator">=</span> mBlastBufferQueue.createSurface();</span><br><span class="line">||BlastBufferQueue.nativeGetSurface(mNativeObject, <span class="literal">false</span> <span class="comment">/* includeSurfaceControlHandle */</span>);</span><br><span class="line">|<span class="comment">//frameworks/base/core/jni/android_graphics_BLASTBufferQueue.cpp</span></span><br><span class="line">|--&gt;nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr, jboolean includeSurfaceControlHandle)</span><br><span class="line">        |sp&lt;BLASTBufferQueue&gt; queue = reinterpret_cast&lt;BLASTBufferQueue*&gt;(ptr); <span class="comment">// 地址转为 native BLASTBufferQueue 对象</span></span><br><span class="line">|<span class="keyword">return</span> android_view_Surface_createFromSurface(env,queue-&gt;getSurface(includeSurfaceControlHandle));</span><br><span class="line">|<span class="comment">//【6】创建 BBQSurface</span></span><br><span class="line">|<span class="comment">//frameworks/native/libs/gui/BLASTBufferQueue.cpp</span></span><br><span class="line">            |--&gt;BLASTBufferQueue.getSurface(bool includeSurfaceControlHandle) </span><br><span class="line">                |sp&lt;IBinder&gt; scHandle = nullptr;</span><br><span class="line">|<span class="keyword">if</span> (includeSurfaceControlHandle &amp;&amp; mSurfaceControl)<span class="comment">// includeSurfaceControlHandle = false</span></span><br><span class="line">                    |scHandle = mSurfaceControl-&gt;getHandle();</span><br><span class="line">                |<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BBQSurface</span>(mProducer, <span class="literal">true</span>, scHandle, <span class="built_in">this</span>);</span><br><span class="line">|<span class="comment">//创建 BBQSurface，比较重要的是重载了 allocateBuffers </span></span><br><span class="line">|--&gt;BBQSurface(const sp&lt;IGraphicBufferProducer&gt;&amp; igbp, bool controlledByApp,</span><br><span class="line">               const sp&lt;IBinder&gt;&amp; scHandle, const sp&lt;BLASTBufferQueue&gt;&amp; bbq)</span><br><span class="line">          : Surface(igbp, controlledByApp, scHandle), mBbq(bbq) &#123;&#125;</span><br><span class="line">|<span class="comment">//Surface 的构造函数内容太多了不写了</span></span><br><span class="line">                    |--&gt;Surface::Surface(const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp,...)</span><br><span class="line">                        : mGraphicBufferProducer(bufferProducer) <span class="comment">// 最关键的就是传入了 生产者</span></span><br><span class="line">                            |mProducerControlledByApp = controlledByApp; <span class="comment">// true</span></span><br><span class="line">|<span class="comment">// 【7】创建Java层的 Surface，并把 BBQSurface 的地址存入Surface.mNativeObject,(这一步就是创建个java的Surface，临时存储native的BBQSurface)</span></span><br><span class="line">|<span class="comment">//frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line">            |--&gt;android_view_Surface_createFromSurface(JNIEnv* env, const sp&lt;Surface&gt;&amp; surface)</span><br><span class="line">                |<span class="comment">// 在 JNI new Java 层的 Surface </span></span><br><span class="line">                |<span class="type">jobject</span> <span class="variable">surfaceObj</span> <span class="operator">=</span> env-&gt;NewObject(gSurfaceClassInfo.clazz, gSurfaceClassInfo.ctor, (jlong)surface.get());</span><br><span class="line">|<span class="comment">// 调用Java层，参数为 long 的构造函数：</span></span><br><span class="line">|--&gt;Surface(<span class="type">long</span> nativeObject)</span><br><span class="line">                    |setNativeObjectLocked(nativeObject);</span><br><span class="line">|mNativeObject = nativeObject;</span><br><span class="line">|<span class="keyword">return</span> surfaceObj;<span class="comment">// 返回java层的对象</span></span><br><span class="line">|<span class="comment">//【8】把返回的BBQSurface地址 Surface.mNativeObject 转存入 ViewRootImpl.mSurface.mNativeObject</span></span><br><span class="line">|mSurface.transferFrom(blastSurface); <span class="comment">// mSurface.mNativeObject = blastSurface.mNativeObject</span></span><br></pre></td></tr></table></figure><h4 id="4、BLASTBufferQueue-createBufferQueue-生产者-消费者-BufferQueueCore"><a href="#4、BLASTBufferQueue-createBufferQueue-生产者-消费者-BufferQueueCore" class="headerlink" title="4、BLASTBufferQueue::createBufferQueue  生产者-消费者-BufferQueueCore"></a>4、BLASTBufferQueue::createBufferQueue  生产者-消费者-BufferQueueCore</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="comment">//frameworks/native/libs/gui/BLASTBufferQueue.cpp</span></span><br><span class="line">BLASTBufferQueue::<span class="built_in">createBufferQueue</span>(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer)</span><br><span class="line">|<span class="comment">// 1、创建 BufferQueueCore</span></span><br><span class="line">|<span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore())</span></span>;</span><br><span class="line">|<span class="comment">// BufferQueueCore 构造函数：</span></span><br><span class="line">|--&gt;BufferQueueCore::<span class="built_in">BufferQueueCore</span>()</span><br><span class="line">          : <span class="built_in">mMutex</span>(), <span class="built_in">mConsumerControlledByApp</span>(<span class="literal">false</span>), </span><br><span class="line">    <span class="built_in">mSlots</span>(),    <span class="comment">// BufferSlot[64] mSlots; 创建 Slots</span></span><br><span class="line">    <span class="built_in">mQueue</span>(),    <span class="comment">// Vector&lt;BufferItem&gt;  mQueue;   queuebuffer 后存储到这个变量里</span></span><br><span class="line"><span class="comment">// FREE 状态，没有GraphicBuffer的放到mFreeSlots里</span></span><br><span class="line"><span class="built_in">mFreeSlots</span>(),   <span class="comment">// std::set&lt;int&gt; mFreeSlots;  初始化为 2个int, mUnusedSlots 每减一个，对应的 mFreeSlots 加入一个</span></span><br><span class="line"><span class="comment">// FREE 状态，但是有buffer attached</span></span><br><span class="line"><span class="built_in">mFreeBuffers</span>(), <span class="comment">// std::list&lt;int&gt; mFreeBuffers;</span></span><br><span class="line"><span class="comment">// 未被使用的 Slot ，起始长度为64，64 + 2个mFreeSlots的元素 其实代表了 Slot 的总数</span></span><br><span class="line"><span class="comment">// 依据 adjustAvailableSlotsLocked函数，可以得出 mUnusedSlots 每减一个，对应的 mFreeSlots 加入一个(加入的就是mUnusedSlots减去的那个)</span></span><br><span class="line"><span class="built_in">mUnusedSlots</span>(), <span class="comment">// std::list&lt;int&gt; mUnusedSlots;</span></span><br><span class="line"><span class="comment">// 当应用申请走一个Slot时，该Slot状态会切换到DEQUEUED状态，该Slot会被放入mActiveBuffers队列</span></span><br><span class="line"><span class="built_in">mActiveBuffers</span>(),<span class="comment">//std::set&lt;int&gt; mActiveBuffers;</span></span><br><span class="line"><span class="comment">// mutable std::condition_variable mDequeueCondition;</span></span><br><span class="line"><span class="built_in">mDequeueCondition</span>(), <span class="comment">// dequeueBuffer 没slot时，调用 mDequeueCondition.wait 等待</span></span><br><span class="line"><span class="built_in">mDequeueBufferCannotBlock</span>(<span class="literal">false</span>), <span class="comment">// bool mDequeueBufferCannotBlock = false; dequeueBuffer 时 阻塞</span></span><br><span class="line"><span class="built_in">mQueueBufferCanDrop</span>(<span class="literal">false</span>), <span class="built_in">mLegacyBufferDrop</span>(<span class="literal">true</span>), <span class="built_in">mDefaultBufferFormat</span>(PIXEL_FORMAT_RGBA_8888),<span class="comment">/*默认使用的格式*/</span></span><br><span class="line"><span class="built_in">mDefaultWidth</span>(<span class="number">1</span>), <span class="built_in">mDefaultHeight</span>(<span class="number">1</span>), <span class="built_in">mDefaultBufferDataSpace</span>(HAL_DATASPACE_UNKNOWN),</span><br><span class="line"><span class="built_in">mMaxBufferCount</span>(BufferQueueDefs::NUM_BUFFER_SLOTS), <span class="comment">// NUM_BUFFER_SLOTS = 64; 这个值64，设置这么大其实用多少</span></span><br><span class="line"><span class="built_in">mMaxAcquiredBufferCount</span>(<span class="number">1</span>),  <span class="built_in">mMaxDequeuedBufferCount</span>(<span class="number">1</span>),...</span><br><span class="line">            <span class="built_in">mTransformHint</span>(<span class="number">0</span>)<span class="comment">/*优化屏幕旋转*/</span>,<span class="built_in">mIsAllocating</span>(<span class="literal">false</span>)<span class="comment">/*是否正在分配内存*/</span>,<span class="built_in">mIsAllocatingCondition</span>(),</span><br><span class="line"><span class="built_in">mAllowAllocation</span>(<span class="literal">true</span>),  <span class="comment">/*允许分配新buffer， BufferQueueProducer::connect时，设置为true*/</span></span><br><span class="line">            <span class="built_in">mBufferAge</span>(<span class="number">0</span>),<span class="comment">/*当前的 BufferSlot 自从上次 queueBuffer 后，又queue了多少个BufferSlot*/</span></span><br><span class="line">            <span class="built_in">mAsyncMode</span>(<span class="literal">false</span>),<span class="comment">/*同步模式*/</span> <span class="built_in">mSharedBufferMode</span>(<span class="literal">false</span>),...</span><br><span class="line">            <span class="built_in">mUniqueId</span>(<span class="built_in">getUniqueId</span>()),<span class="built_in">mAutoPrerotation</span>(<span class="literal">false</span>)<span class="comment">/*自动预旋转*/</span>,<span class="built_in">mTransformHintInUse</span>(<span class="number">0</span>)<span class="comment">/*自动预旋转的方向，90度时宽高互换*/</span>&#123;</span><br><span class="line">                <span class="type">int</span> numStartingBuffers = <span class="built_in">getMaxBufferCountLocked</span>(); <span class="comment">//numStartingBuffers  = 2</span></span><br><span class="line">                <span class="comment">// 构造函数中 set&lt;int&gt; mFreeSlots 插入两个int</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">                    mFreeSlots.<span class="built_in">insert</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 构造函数中 std::list&lt;int&gt; mUnusedSlots 插入 64 个int</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; <span class="comment">// NUM_BUFFER_SLOTS = 64</span></span><br><span class="line">                    mUnusedSlots.<span class="built_in">push_front</span>(s); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">|<span class="comment">// 2、创建生产者</span></span><br><span class="line">|<span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BBQBufferQueueProducer(core, <span class="keyword">this</span>))</span></span>;</span><br><span class="line">|<span class="comment">// BBQBufferQueueProducer 没多少内容，就是重载了 connect、setMaxDequeuedBufferCount、query</span></span><br><span class="line">|--&gt;<span class="built_in">BBQBufferQueueProducer</span>(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core, wp&lt;BLASTBufferQueue&gt; bbq)</span><br><span class="line">        <span class="comment">// mConsumerIsSurfaceFlinger 入队后，GraphicBuffer 在BufferItem 中的指针是否应该被清除</span></span><br><span class="line">        : <span class="built_in">BufferQueueProducer</span>(core, <span class="literal">false</span> <span class="comment">/* consumerIsSurfaceFlinger*/</span>),<span class="built_in">mBLASTBufferQueue</span>(std::<span class="built_in">move</span>(bbq)) &#123;&#125;</span><br><span class="line">|--&gt;BufferQueueProducer::<span class="built_in">BufferQueueProducer</span>(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core, <span class="type">bool</span> consumerIsSurfaceFlinger) </span><br><span class="line">            : <span class="built_in">mCore</span>(core), <span class="built_in">mSlots</span>(core-&gt;mSlots), <span class="built_in">mConsumerName</span>(),<span class="built_in">mStickyTransform</span>(<span class="number">0</span>),</span><br><span class="line">  <span class="built_in">mConsumerIsSurfaceFlinger</span>(consumerIsSurfaceFlinger<span class="comment">/*false*/</span>),<span class="built_in">mLastQueueBufferFence</span>(Fence::NO_FENCE),<span class="built_in">mLastQueuedTransform</span>(<span class="number">0</span>),</span><br><span class="line">  <span class="built_in">mCallbackMutex</span>(),<span class="built_in">mNextCallbackTicket</span>(<span class="number">0</span>),<span class="built_in">mCurrentCallbackTicket</span>(<span class="number">0</span>),<span class="built_in">mCallbackCondition</span>(),</span><br><span class="line">  <span class="built_in">mDequeueTimeout</span>(<span class="number">-1</span>),<span class="built_in">mDequeueWaitingForAllocation</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">|<span class="comment">// 3、创建消费者</span></span><br><span class="line">|<span class="function">sp&lt;BufferQueueConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">|--&gt;BufferQueueConsumer::<span class="built_in">BufferQueueConsumer</span>(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core)</span><br><span class="line">        : <span class="built_in">mCore</span>(core), <span class="built_in">mSlots</span>(core-&gt;mSlots), <span class="built_in">mConsumerName</span>() &#123;&#125;</span><br><span class="line">|<span class="comment">// 4、生产消费者赋值到 BLASTBufferQueue成员变量 mProducer 和 mConsumer</span></span><br><span class="line">|*outProducer = producer;</span><br><span class="line">|*outConsumer = consumer;</span><br></pre></td></tr></table></figure><h3 id="七、SurfaceFlinger创建layer"><a href="#七、SurfaceFlinger创建layer" class="headerlink" title="七、SurfaceFlinger创建layer"></a>七、SurfaceFlinger创建layer</h3><h4 id="Android-11-以及以前的版本简述："><a href="#Android-11-以及以前的版本简述：" class="headerlink" title="Android 11 以及以前的版本简述："></a>Android 11 以及以前的版本简述：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码SurfaceFlinger::createLayer</span><br><span class="line"></span><br><span class="line">| SurfaceFlinger::<span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, metadata, format, handle, gbp, &amp;layer);</span><br><span class="line">  | sp&lt;BufferQueueLayer&gt; layer;</span><br><span class="line">  | layer = <span class="built_in">getFactory</span>().<span class="built_in">createBufferQueueLayer</span>(args);</span><br><span class="line">    | BufferQueueLayer 对象创建完成后，在首次sp指针引用时调用 BufferQueueLayer::<span class="built_in">onFirstRef</span>()</span><br><span class="line">      | onFirstRef函数中会创建 生产者，消费者，生产者会传入到客户端</span><br><span class="line">      | sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">      | sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">      | 设置生产者的三级缓冲</span><br><span class="line">      | mProducer-&gt;<span class="built_in">setMaxDequeuedBufferCount</span>(<span class="number">2</span>);</span><br><span class="line">  | 赋值client端的参数 </span><br><span class="line">  | sp&lt;IBinder&gt; *handle = layer-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">  | sp&lt;IGraphicBufferProducer&gt; *gbp = layer-&gt;<span class="built_in">getProducer</span>(); <span class="comment">//获取生产者</span></span><br><span class="line">  | sp&lt;Layer&gt; *outLayer = layer; <span class="comment">//这个layer保存在 SurfaceComposerClient对象中，wms并未赋值，wms对应的是SurfaceControl</span></span><br><span class="line">| addClientLayer</span><br><span class="line">  | 调用 addClientLayer，把layer按照Z轴顺序存入 layersSortedByZ</span><br></pre></td></tr></table></figure><h4 id="SurfaceFlinger-createLayer-Android-13"><a href="#SurfaceFlinger-createLayer-Android-13" class="headerlink" title="SurfaceFlinger::createLayer  Android 13"></a>SurfaceFlinger::createLayer  Android 13</h4><ul><li>Android 12 以后因为BBQ都在APP进程，所以 createLayer 大大简化了，内容不多。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码【接续“ViewRootImpl.relayoutWindow 创建 Surface” 章节中的 “SurfaceComposerClient.createSurfaceChecked”】</span><br><span class="line">SurfaceFlinger::<span class="built_in">createLayer</span>(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* outHandle,sp&lt;IBinder&gt;&amp; parentHandle, <span class="type">int32_t</span>* outLayerId, sp&lt;Layer&gt;&amp; parentLayer, <span class="type">uint32_t</span>* outTransformHint)</span><br><span class="line">|sp&lt;Layer&gt; layer;    </span><br><span class="line">|<span class="keyword">switch</span> (args.flags &amp; ISurfaceComposerClient::eFXSurfaceMask)&#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         eFXSurfaceBufferState = 0x00040000</span></span><br><span class="line"><span class="comment">         WindowManagerService.createSurfaceControl 流程中 </span></span><br><span class="line"><span class="comment">         if (useBLAST) b.setBLASTLayer(); 这个函数设置的flag FX_SURFACE_BLAST = 0x00040000;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState:</span><br><span class="line">        result = <span class="built_in">createBufferStateLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        |<span class="built_in">createBufferStateLayer</span>(LayerCreationArgs&amp; args, sp&lt;IBinder&gt;* handle, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">                |*outLayer = <span class="built_in">getFactory</span>().<span class="built_in">createBufferStateLayer</span>(args); <span class="comment">// 创建的 layer </span></span><br><span class="line">        |--&gt;BufferStateLayer::<span class="built_in">BufferStateLayer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">                        |: <span class="built_in">BufferLayer</span>(args), <span class="built_in">mHwcSlotGenerator</span>(<span class="keyword">new</span> <span class="built_in">HwcSlotGenerator</span>())</span><br><span class="line">                        |   mDrawingState.dataspace = ui::Dataspace::V0_SRGB;</span><br><span class="line">        |--&gt;BufferLayer::<span class="built_in">BufferLayer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">                                : <span class="built_in">Layer</span>(args), <span class="built_in">mTextureName</span>(args.textureName),</span><br><span class="line">        |mCompositionState&#123;mFlinger-&gt;<span class="built_in">getCompositionEngine</span>().<span class="built_in">createLayerFECompositionState</span>()&#125; </span><br><span class="line">        |--&gt;Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">                                    : <span class="built_in">sequence</span>(args.sequence.<span class="built_in">value_or</span>(sSequence++)),</span><br><span class="line">          <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">          <span class="built_in">mName</span>(base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;%s#%d&quot;</span>, args.name.<span class="built_in">c_str</span>(), sequence)),</span><br><span class="line">          <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">          <span class="built_in">mWindowType</span>(<span class="built_in">static_cast</span>&lt;WindowInfo::Type&gt;(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>))),</span><br><span class="line">          <span class="built_in">mLayerCreationFlags</span>(args.flags)</span><br><span class="line">                                         <span class="comment">// 然后是一堆 mDrawingState 成员属性的初始化     </span></span><br><span class="line">        |*handle = (*outLayer)-&gt;<span class="built_in">getHandle</span>(); <span class="comment">// 把创建的 handle 传入外部，最终会返回到APP进程端，用于创建 SurfaceControl</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceEffect: <span class="comment">// 这里是 Task、DefaultTaskDisplayArea</span></span><br><span class="line">        result = <span class="built_in">createEffectLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceContainer:<span class="comment">//这里是 ActivityRecord、WindowState 等等</span></span><br><span class="line">        result = <span class="built_in">createContainerLayer</span>(args, outHandle, &amp;layer);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        result = BAD_VALUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">|</span><br><span class="line">|result = <span class="built_in">addClientLayer</span>(args.client, *outHandle, layer, parent, addToRoot, outTransformHint);</span><br><span class="line">|--&gt;SurfaceFlinger.<span class="built_in">addClientLayer</span>(<span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> sp&lt;IBinder&gt;&amp; handle,<span class="type">const</span> sp&lt;Layer&gt;&amp; layer, <span class="type">const</span> wp&lt;Layer&gt;&amp; parent,...)</span><br><span class="line">    |<span class="comment">//std::vector&lt;LayerCreatedState&gt; mCreatedLayers  加入到数组</span></span><br><span class="line">    |mCreatedLayers.<span class="built_in">emplace_back</span>(layer, parent, addToRoot);</span><br><span class="line">|<span class="comment">//缓存到 Client.mLayers 集合中 //frameworks/native/services/surfaceflinger/Client.h</span></span><br><span class="line">|client-&gt;<span class="built_in">attachLayer</span>(handle, layer);</span><br><span class="line">    |<span class="comment">// 请求 sf-vsync,这里的代码和 SurfaceFlinger::commitCreatedLayers() 以及 mCreatedLayers 是相关联的，具体见 SurfaceFlinger 章节</span></span><br><span class="line">|<span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">|*outLayerId = layer-&gt;sequence;</span><br><span class="line">|<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、点击桌面App图标事件分发&quot;&gt;&lt;a href=&quot;#一、点击桌面App图标事件分发&quot; class=&quot;headerlink&quot; title=&quot;一、点击桌面App图标事件分发&quot;&gt;&lt;/a&gt;一、点击桌面App图标事件分发&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;systemserver</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    
  </entry>
  
  <entry>
    <title>6.PowerManagerService启动流程和核心方法</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/6.PowerManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/</id>
    <published>2023-12-29T06:46:03.018Z</published>
    <updated>2024-01-07T03:19:52.799Z</updated>
    
    <content type="html"><![CDATA[<p> PowerManagerService(简称PMS)主要是负责协调、管理设备CPU资源，并提供功能接口给应用框架层或应用层申请获取CPU资源的一个服务，例如：亮灭屏、关机、WakeLock管理、Dreamland(屏保模式)、休眠时间等行为。</p><h3 id="1-PMS的启动流程"><a href="#1-PMS的启动流程" class="headerlink" title="1. PMS的启动流程"></a>1. <a href="https://so.csdn.net/so/search?q=PMS&spm=1001.2101.3001.7020">PMS</a>的启动流程</h3><p>PMS是在SystemServer的startBootstrapServices()中通过SystemServiceManager.startService()启动，很多服务依赖PMS服务，所以它需要尽早的启动并注册到ServiceManage中，所以它在startBootstrapServices()中来启动</p><pre><code>frameworks/base/services/java/com/android/server/SystemServer.java            private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123;        t.traceBegin(&quot;StartPowerManager&quot;);        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);        t.traceEnd();    &#125;</code></pre><p>SystemServiceManager.startService()通过反射拿到PowerManagerService对象</p><pre><code>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java    public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123;        try &#123;            final String name = serviceClass.getName();            final T service;            try &#123;                //获取类构造方法，构造对应对象                Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);                service = constructor.newInstance(mContext);            &#125; catch (InstantiationException ex) &#123;                throw new RuntimeException(&quot;Failed to create service &quot; + name                        + &quot;: service could not be instantiated&quot;, ex);            &#125; catch (IllegalAccessException ex) &#123;                ...            &#125;            //调用startService启动服务            startService(service);            //返回服务对象            return service;        &#125; finally &#123;            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);        &#125;    &#125;    public void startService(@NonNull final SystemService service) &#123;        // Check if already started        String className = service.getClass().getName();        mServiceClassnames.add(className);        // Register it.        //注册服务        mServices.add(service);        // Start it.        long time = SystemClock.elapsedRealtime();        try &#123;            //调用服务的onStart()方法启动服务            service.onStart();        &#125; catch (RuntimeException ex) &#123;            throw new RuntimeException(&quot;Failed to start service &quot; + service.getClass().getName()                    + &quot;: onStart threw an exception&quot;, ex);        &#125;        warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;);    &#125;</code></pre><p>将服务加入mServices列表中，然后调用服务的onStart()方法，mServices列表是管理着所有需要接收系统启动过程中生命周期的服务</p><h4 id="1-1-PowerManagerService构造方法"><a href="#1-1-PowerManagerService构造方法" class="headerlink" title="1.1 PowerManagerService构造方法"></a>1.1 PowerManagerService构造方法</h4><pre><code>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    public PowerManagerService(Context context) &#123;        this(context, new Injector());  //内部类Injector对象，管理创建其他对象    &#125;    PowerManagerService(Context context, Injector injector) &#123;        super(context);        mContext = context;        mBinderService = new BinderService();  //用于IPC交互, BinderService 继承于 IPowerManager.Stub        mLocalService = new LocalService();  //用户跨线程交互(SystemServer进程内部)        //创建一个NativeWrapper对象，管理所有的native交互        mNativeWrapper = injector.createNativeWrapper();        //创建SystemPropertiesWrapper对象，用于获取系统属性等信息        mSystemProperties = injector.createSystemPropertiesWrapper();        mClock = injector.createClock();        //内部类Injector对象，管理创建其他对象        mInjector = injector;                //创建PMS主线程，优先级为DISPLAY级别        mHandlerThread = new ServiceThread(TAG,                Process.THREAD_PRIORITY_DISPLAY, /* allowIo= */ false);        mHandlerThread.start();  //启动主线程        //创建PMS主线程Handler        mHandler = injector.createHandler(mHandlerThread.getLooper(),                new PowerManagerHandlerCallback());        //用于管理Settings.Global下的常量        mConstants = new Constants(mHandler);        //创建AmbientDisplayConfiguration对象，管理一些显示配置，如AOD        mAmbientDisplayConfiguration = mInjector.createAmbientDisplayConfiguration(context);        //创建AmbientDisplaySuppressionController对象，用于管理AmbientDisplay显示相关，和AOD显示有关        mAmbientDisplaySuppressionController =                mInjector.createAmbientDisplaySuppressionController(context);        //创建AttentionDetector对象，用来检查用户活动是否需要再更新        mAttentionDetector = new AttentionDetector(this::onUserAttention, mLock);                mFaceDownDetector = new FaceDownDetector(this::onFlip);                mScreenUndimDetector = new ScreenUndimDetector();        //创建BatterySavingStats对象，用来记录电池耗电率        mBatterySavingStats = new BatterySavingStats(mLock);        //创建BatterySaverPolicy对象，管理一些省电策略        mBatterySaverPolicy =                mInjector.createBatterySaverPolicy(mLock, mContext, mBatterySavingStats);        //创建BatterySaverController对象，管理省电策略的切换        mBatterySaverController = mInjector.createBatterySaverController(mLock, mContext,                mBatterySaverPolicy, mBatterySavingStats);        //创建BatterySaverStateMachine对象，负责省电策略的开启/关闭        mBatterySaverStateMachine = mInjector.createBatterySaverStateMachine(mLock, mContext,                mBatterySaverController);        mLowPowerStandbyController = mInjector.createLowPowerStandbyController(mContext,                Looper.getMainLooper());                        mInattentiveSleepWarningOverlayController =                mInjector.createInattentiveSleepWarningController();        mAppOpsManager = injector.createAppOpsManager(mContext);        mPowerGroupWakefulnessChangeListener = new PowerGroupWakefulnessChangeListener();                ...//获取一些配置初始值                synchronized (mLock) &#123;            //创建SuspendBlockerImpl对象，&quot;PowerManagerService.Booting&quot;类型对象负责在开机时负责保活CPU            mBootingSuspendBlocker =                    mInjector.createSuspendBlocker(this, &quot;PowerManagerService.Booting&quot;);           //创建SuspendBlockerImpl对象，WakeLock的最终反映，&quot;PowerManagerService.WakeLocks&quot;类型对象负责保活CPU            mWakeLockSuspendBlocker =                    mInjector.createSuspendBlocker(this, &quot;PowerManagerService.WakeLocks&quot;);            //创建SuspendBlockerImpl对象，&quot;PowerManagerService.Display&quot;类型对象负责保持屏幕常亮            mDisplaySuspendBlocker =                    mInjector.createSuspendBlocker(this, &quot;PowerManagerService.Display&quot;);            //申请mBootingSuspendBlocker，保持开机启动过程CPU资源            if (mBootingSuspendBlocker != null) &#123;                mBootingSuspendBlocker.acquire();                mHoldingBootingSuspendBlocker = true;            &#125;            //申请mDisplaySuspendBlocker，保持屏幕常亮            if (mDisplaySuspendBlocker != null) &#123;                mDisplaySuspendBlocker.acquire(HOLDING_DISPLAY_SUSPEND_BLOCKER);                mHoldingDisplaySuspendBlocker = true;            &#125;            //auto-suspend 模式是否可用            mHalAutoSuspendModeEnabled = false;            //是否是可交互状态            mHalInteractiveModeEnabled = true;            //设置设备状态为唤醒状态            mWakefulnessRaw = WAKEFULNESS_AWAKE;            //静默模式，会控制背光的点亮，使用场景不多            sQuiescent = mSystemProperties.get(SYSTEM_PROPERTY_QUIESCENT, &quot;0&quot;).equals(&quot;1&quot;)                    || InitProperties.userspace_reboot_in_progress().orElse(false);                                //mNativeWrapper对象进行native层初始化工作            mNativeWrapper.nativeInit(this);            mNativeWrapper.nativeSetAutoSuspend(false);  //设置auto suspend状态            mNativeWrapper.nativeSetPowerMode(Mode.INTERACTIVE, true);  //设置interactive状态            mNativeWrapper.nativeSetPowerMode(Mode.DOUBLE_TAP_TO_WAKE, false);  //设置双击唤醒模式状态            mInjector.invalidateIsInteractiveCaches();        &#125;    &#125;</code></pre><p>构造方法主要做了几件事：</p><ol><li>创建用于IPC的BinderService对象和system_server进程内跨线程交互的LocalService对象；</li><li>创建PMS的主线程，并使用该HandlerThread的Looper实例化PowerManagerHandler，将作为PMS主线程Handler进行Message的处理</li><li>相关配置参数的读取，如系统配置各种亮度参数</li><li>获取了三个Suspend锁对象，SuspendBlocker是一种锁机制，上层申请的wakelock锁在PMS中都会反映为SuspendBlocker锁</li><li>通过mNativeWrapper对象和底层进行状态交互</li></ol><h4 id="1-2-onStart-中注册发布服务"><a href="#1-2-onStart-中注册发布服务" class="headerlink" title="1.2 onStart()中注册发布服务"></a>1.2 onStart()中注册发布服务</h4><p>执行完构造方法后接着执行了onStart()</p><pre><code>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    @Override    public void onStart() &#123;        //向ServiceManager进程注册当前服务mBinderService(BinderServic才是PMS的Binder服务端)        publishBinderService(Context.POWER_SERVICE, mBinderService, /* allowIsolated= */ false,                DUMP_FLAG_PRIORITY_DEFAULT | DUMP_FLAG_PRIORITY_CRITICAL);        //发布本地服务提供给SystemServer进程中其他组件访问        publishLocalService(PowerManagerInternal.class, mLocalService);        //添加watchdog监听        Watchdog.getInstance().addMonitor(this);        Watchdog.getInstance().addThread(mHandler);    &#125;</code></pre><p>这个方法中会进行对PMS的Binder服务和Local服务的注册，BinderService注册后，其他模块中就可以通过ServiceManager获取到对应的Binder对象，进行IPC通信；LocalService注册后，在system_server进程内就可以通过获取LocalService对象跨线程交互。<br>PMS中的BinderService，是继承自IPowerManager.Stub的一个内部类BinderService，IPowerManager.Stub继承自Binder并且实现了IPowerManager，因此，PMS和其他模块的跨进程交互，实际上就是通过PMS.BinderService实现。</p><p>Binder服务注册的过程在SystemService中的publishBinderService方法，通过ServiceManager.addService注册：</p><pre><code>frameworks/base/services/core/java/com/android/server/SystemService.java    protected final void publishBinderService(String name, IBinder service,            boolean allowIsolated, int dumpPriority) &#123;        ServiceManager.addService(name, service, allowIsolated, dumpPriority);    &#125;frameworks/base/core/java/android/os/ServiceManager.java    public static void addService(String name, IBinder service) &#123;        addService(name, service, false, IServiceManager.DUMP_FLAG_PRIORITY_DEFAULT);    &#125;</code></pre><p>当通过ServiceManager注册后，就可以根据Context.POWER_SERVICE在其他服务中获得服务代理对象，进行跨进程交互了。</p><p>LocalService则用于system_server进程内部交互，注册的对象是另一个内部类——继承自PowerManagerInternal的LocalService(带有Internal的类一般都在System进程内使用)。Local Service的注册是在LocalServices中进行，其注册方法如下：</p><pre><code>frameworks/base/services/core/java/com/android/server/SystemService.java    protected final &lt;T&gt; void publishLocalService(Class&lt;T&gt; type, T service) &#123;        LocalServices.addService(type, service);    &#125;frameworks/base/core/java/com/android/server/LocalServices.java    public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123;        synchronized (sLocalServiceObjects) &#123;            if (sLocalServiceObjects.containsKey(type)) &#123;                throw new IllegalStateException(&quot;Overriding service registration&quot;);            &#125;            sLocalServiceObjects.put(type, service); //添加到sLocalServiceObjects容器中        &#125;    &#125;</code></pre><h4 id="1-3-onBootPhase-进行各个启动阶段的处理"><a href="#1-3-onBootPhase-进行各个启动阶段的处理" class="headerlink" title="1.3 onBootPhase()进行各个启动阶段的处理"></a>1.3 onBootPhase()进行各个启动阶段的处理</h4><p>回到SytemServer中，startBootstrapServices()方法中PMS的实例化和注册流程执行完成了，接下来会开始执行SystemService的生命周期，会开始执行SystemServiceManager.onBootPhase()，这个方法为所有的已进行实例化和注册的服务(通过前面的startService启动的服务)设置启动阶段，以便在不同的启动阶段进行不同的工作，方法如下：</p><pre><code>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java    public void startBootPhase(@NonNull TimingsTraceAndSlog t, int phase) &#123;        mCurrentPhase = phase;        try &#123;            final int serviceLen = mServices.size();            for (int i = 0; i &lt; serviceLen; i++) &#123;                final SystemService service = mServices.get(i);                try &#123;                    service.onBootPhase(mCurrentPhase);                &#125; catch (Exception ex) &#123;                    ...                &#125;            &#125;        &#125; finally &#123;            t.traceEnd();        &#125;        if (phase == SystemService.PHASE_BOOT_COMPLETED) &#123;            final long totalBootTime = SystemClock.uptimeMillis() - mRuntimeStartUptime;            t.logDuration(&quot;TotalBootTime&quot;, totalBootTime);            SystemServerInitThreadPool.shutdown();        &#125;    &#125;</code></pre><p>在SystemServiceManager#startBootPhase()中，通过在SystemServiceManager中传入不同的形参，遍历SystemServiceManager#mServices列表，调用各个SystemService#onBootPhase(int)方法，根据参数在方法实现中完成不同的工作。在SystemService中定义了七个代表启动阶段的参数：</p><blockquote><p>PHASE_WAIT_FOR_DEFAULT_DISPLAY：第一个启动阶段，用于在启动PKMS之前，需要确保已经存在默认逻辑屏，只有DisplayManagerService使用该阶段；<br>PHASE_LOCK_SETTINGS_READY：第二个启动阶段，该阶段的执行，意味这Lock Pattern&#x2F;Password相关服务已经准备完毕，只有DisplayManagerService使用该阶段；<br>PHASE_SYSTEM_SERVICES_READY：第三个启动阶段，该阶段的执行，意味这其他服务可以安全地使用核心系统服务;<br>PHASE_DEVICE_SPECIFIC_SERVICES_READY：第四个启动阶段，该阶段的执行，意味这其他服务可以安全地使用设备指定的一些系统服务，这些服务在config_deviceSpecificSystemServices中进行配置;<br>PHASE_ACTIVITY_MANAGER_READY：第五个启动阶段，该阶段的执行，意味这其他AMS组件已经启动完成，可以进行广播操作;<br>PHASE_THIRD_PARTY_APPS_CAN_START：第六个启动阶段，该阶段的执行，意味这系统可以启动APP，并可以进行service的bind&#x2F;start操作了；<br>PHASE_BOOT_COMPLETED：第六个启动阶段，该阶段的执行，意味这启动完成，Home应用也已经启动完成，并且可以和设备进行交互了。</p></blockquote><p>PMS#onBootPhase()方法只对以上的3个阶段做了处理：</p><pre><code>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    @Override    public void onBootPhase(int phase) &#123;        if (phase == PHASE_SYSTEM_SERVICES_READY) &#123;            systemReady();  //如果是PHASE_SYSTEM_SERVICES_READY阶段则调用PMS的systemReady()        &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;            //统计系统启动次数，adb shell settings get global boot_count可查看            incrementBootCount();        &#125; else if (phase == PHASE_BOOT_COMPLETED) &#123;            synchronized (mLock) &#123;                final long now = mClock.uptimeMillis();                mBootCompleted = true;  //表示启动完成                mDirty |= DIRTY_BOOT_COMPLETED;  //最重要的标志位                                //执行BatterySaverStateMachine.onBootCompleted()                mBatterySaverStateMachine.onBootCompleted();                //更新用户活动时间                userActivityNoUpdateLocked(                        now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);                //更新全局状态信息                updatePowerStateLocked();                if (sQuiescent) &#123;                    sleepPowerGroupLocked(mPowerGroups.get(Display.DEFAULT_DISPLAY_GROUP),                            mClock.uptimeMillis(),                            PowerManager.GO_TO_SLEEP_REASON_QUIESCENT,                            Process.SYSTEM_UID);                &#125;                //注册DeviceStateManager服务的回调接口                mContext.getSystemService(DeviceStateManager.class).registerCallback(                        new HandlerExecutor(mHandler), new DeviceStateListener());            &#125;        &#125;    &#125;</code></pre><p>mDirty是一个二进制的标记位，用来表示电源状态哪一部分发生了改变，通过对其进行置位（|操作）、清零（～操作），得到二进制数各个位的值(0或1)，进行不同的处理，这个变量非常重要。<br>最后，调用updatePowerStateLocked()方法，这是整个PMS中最重要的方法，会在下面进行详细分析。<br>此时，启动过程中SystemService的生命周期方法全部执行完毕。</p><h4 id="1-4-sytemReady"><a href="#1-4-sytemReady" class="headerlink" title="1.4 sytemReady()"></a>1.4 sytemReady()</h4><p>当onBootPhase处于PHASE_SYSTEM_SERVICES_READY阶段时，执行sytemReady()</p><pre><code>    private void systemReady() &#123;        //方法太长了    &#125;</code></pre><p>这个方法中主要做了以下几个操作，方法太长了相关方法代码就不再粘贴:</p><p>获取各类本地服务和远程服务，如Dreamland服务(DreamMangerService)、窗口服务(PhoneWindowManager)、电池状态监听(BatteryService)等服务；<br>注册用于和其他SytemService交互的广播；<br>调用updateSettingsLocked()方法更新Settings中值的变化；<br>调用readConfigurationLocked()方法读取配置文件中的默认值；<br>注册SettingsObserver监听；</p><p>到此为止，PMS的启动过程完成。</p><h3 id="2-核心方法updatePowerStateLocked"><a href="#2-核心方法updatePowerStateLocked" class="headerlink" title="2. 核心方法updatePowerStateLocked()"></a>2. 核心方法updatePowerStateLocked()</h3><p>updatePowerStateLocked()方法是整个PMS模块的核心方法，也是整个PSM中最重要的一个方法，它用来更新整个Power状态。当Power状态发生改变时，如亮灭屏、电池状态改变、暗屏、WakeLock锁申请&#x2F;释放…都会调用该方法，并调用其他同级方法进行各个状态的更新：</p><pre><code>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    private void updatePowerStateLocked() &#123;        if (!mSystemReady || mDirty == 0 || mUpdatePowerStateInProgress) &#123;            return;        &#125;        Trace.traceBegin(Trace.TRACE_TAG_POWER, &quot;updatePowerState&quot;);        mUpdatePowerStateInProgress = true;        try &#123;            // Phase 0: Basic state updates. 基本状态的更新            updateIsPoweredLocked(mDirty);  //更新充电状态            updateStayOnLocked(mDirty);  //更新当前是否为屏幕常亮状态，由mStayOn控制            updateScreenBrightnessBoostLocked(mDirty);  //更新是否需要增强亮度变量            // Phase 1: Update wakefulness. 更新唤醒状态            // Loop because the wake lock and user activity computations are influenced            // by changes in wakefulness.            // 循环是因为唤醒锁和用户活动计算受到唤醒状态变化的影响。            final long now = mClock.uptimeMillis();            int dirtyPhase2 = 0;            for (;;) &#123; // 循环进行更新流程，直到updateWakefulnessLocked()返回false                int dirtyPhase1 = mDirty;                dirtyPhase2 |= dirtyPhase1;                mDirty = 0;  //清空标记                // 更新用于统计wakelock的标记值mWakeLockSummary属性                updateWakeLockSummaryLocked(dirtyPhase1);                // 更新用于统计用户活动状态的标记值mUserActivitySummary属性                updateUserActivitySummaryLocked(now, dirtyPhase1);                // 更新细微模式状态                updateAttentiveStateLocked(now, dirtyPhase1);                // 更新唤醒状态，如果状态改变返回true                if (!updateWakefulnessLocked(dirtyPhase1)) &#123;                    break;                &#125;            &#125;            // Phase 2: Lock profiles that became inactive/not kept awake.            updateProfilesLocked(now);            // Phase 3: Update power state of all PowerGroups. 更新PowerGroups状态            final boolean powerGroupsBecameReady = updatePowerGroupsLocked(dirtyPhase2);            // Phase 4: Update dream state (depends on power group ready signal). 更新Dreamland状态            updateDreamLocked(dirtyPhase2, powerGroupsBecameReady);            // Phase 5: Send notifications, if needed. 如果wakefulness改变，做最后的收尾工作            finishWakefulnessChangeIfNeededLocked();            // Phase 6: Update suspend blocker.            // Because we might release the last suspend blocker here, we need to make sure            // we finished everything else first! 更新SuspendBlocker锁状态            updateSuspendBlockerLocked();        &#125; finally &#123;            Trace.traceEnd(Trace.TRACE_TAG_POWER);            mUpdatePowerStateInProgress = false;        &#125;    &#125;</code></pre><p>下面对以上内容中所有方法逐个进行分析</p><h4 id="2-1-updateIsPoweredLocked-更新充电状态"><a href="#2-1-updateIsPoweredLocked-更新充电状态" class="headerlink" title="2.1 updateIsPoweredLocked()更新充电状态"></a>2.1 updateIsPoweredLocked()更新充电状态</h4><p>这个方法用于更新mIsPowered属性，它代表当前的充电状态。插拔USB点亮屏幕功能的逻辑，就是在这个方法中。该方法如下：</p><pre><code>    private void updateIsPoweredLocked(int dirty) &#123;        if ((dirty &amp; DIRTY_BATTERY_STATE) != 0) &#123;            // 记录旧值            final boolean wasPowered = mIsPowered;            final int oldPlugType = mPlugType;            // 获取新值            mIsPowered = mBatteryManagerInternal.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);            mPlugType = mBatteryManagerInternal.getPlugType();            mBatteryLevel = mBatteryManagerInternal.getBatteryLevel();            mBatteryLevelLow = mBatteryManagerInternal.getBatteryLevelLow();            // 当充电状态发生变化            if (wasPowered != mIsPowered || oldPlugType != mPlugType) &#123;                mDirty |= DIRTY_IS_POWERED; // 设置标记位DIRTY_IS_POWERED                // 更新无线充电状态                final boolean dockedOnWirelessCharger = mWirelessChargerDetector.update(                        mIsPowered, mPlugType);                final long now = mClock.uptimeMillis();                // 插拔USB是否需要亮屏                if (shouldWakeUpWhenPluggedOrUnpluggedLocked(wasPowered, oldPlugType,                        dockedOnWirelessCharger)) &#123;                    // 亮屏流程                    wakePowerGroupLocked(mPowerGroups.get(Display.DEFAULT_DISPLAY_GROUP),                            now, PowerManager.WAKE_REASON_PLUGGED_IN,                            &quot;android.server.power:PLUGGED:&quot; + mIsPowered, Process.SYSTEM_UID,                            mContext.getOpPackageName(), Process.SYSTEM_UID);                &#125;                // 更新用户活动时间                userActivityNoUpdateLocked(mPowerGroups.get(Display.DEFAULT_DISPLAY_GROUP), now,                        PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);                // 播放充电提示音和动画                if (mBootCompleted) &#123;  //只有在开机完成后才允许播放充电提示声                    if (mIsPowered &amp;&amp; !BatteryManager.isPlugWired(oldPlugType)                            &amp;&amp; BatteryManager.isPlugWired(mPlugType)) &#123;                        mNotifier.onWiredChargingStarted(mUserId);                    &#125; else if (dockedOnWirelessCharger) &#123;                        mNotifier.onWirelessChargingStarted(mBatteryLevel, mUserId);                    &#125;                &#125;            &#125;            //将充电状态更新到BatterySaverStateMachine            mBatterySaverStateMachine.setBatteryStatus(mIsPowered, mBatteryLevel, mBatteryLevelLow);        &#125;    &#125;</code></pre><p>只有对mDirty设置了DIRTY_BATTERY_STATE标记时才会进入这个方法中，那么DIRTY_BATTERY_STATE在什么时候会设置呢？一是当PMS执行systemReady()时，二是当电池信息变化后，由healthd模块上报给BatteryService，BatteryService中则会发出广播Intent.ACTION_BATTERY_CHANGED来通知其他组件，PMS中会接收这个广播并作出处理：</p><pre><code>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    final class BatteryReceiver extends BroadcastReceiver &#123;        @Override        public void onReceive(Context context, Intent intent) &#123;            synchronized (mLock) &#123;                handleBatteryStateChangedLocked();            &#125;        &#125;    &#125;    private void handleBatteryStateChangedLocked() &#123;        mDirty |= DIRTY_BATTERY_STATE;        updatePowerStateLocked();    &#125;</code></pre><p>因此，只要电池状态发生变化，就会执行这个方法。在这个方法中：</p><ol><li>首先，更新一些如mIsPowered等全局变量。</li><li>然后，通过shouldWakeUpWhenPluggedOrUnpluggedLocked()方法判断是否需要亮屏，这就是插拔USB点亮屏幕功能的逻辑。</li><li>接下来，执行userActivityNoUpdateLocked()方法更新用户活动时间，这个时间决定了何时会自动灭屏，用户每次操作手机(触摸、按键、Other)都会更新到当前时间，用户最后活动时间 + 设置自动休眠时间 &#x3D; 最终自动灭屏的时间点，这个方法会在后面部分分析。</li><li>再接下来，则调用Notifier对象播放插拔USB音效或动画，Notifier类是PMS模块中用于发送广播、异步通知其他组件的一个类。</li><li>最后，将充电状态传递给mBatterySaverStateMachine中，进行省电策略的调整。</li></ol><h4 id="2-2-updateStayOnLocked-更新屏幕常亮状态"><a href="#2-2-updateStayOnLocked-更新屏幕常亮状态" class="headerlink" title="2.2 updateStayOnLocked()更新屏幕常亮状态"></a>2.2 updateStayOnLocked()更新屏幕常亮状态</h4><p>这个方法用来更新全局变量mStayOn的值，如果把”开发者选项—不锁定屏幕”这个选项开启后，则在充电时将保持常亮不会自动休眠：</p><pre><code>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    private void updateStayOnLocked(int dirty) &#123;        if ((dirty &amp; (DIRTY_BATTERY_STATE | DIRTY_SETTINGS)) != 0) &#123;            final boolean wasStayOn = mStayOn;            if (mStayOnWhilePluggedInSetting != 0                    &amp;&amp; !isMaximumScreenOffTimeoutFromDeviceAdminEnforcedLocked()) &#123;                // 如果任意方式充电(AC/USB/wireless)，返回true                mStayOn = mBatteryManagerInternal.isPowered(mStayOnWhilePluggedInSetting);            &#125; else &#123;                mStayOn = false;            &#125;            // 状态发生变化时，向mDirty设置DIRTY_STAY_ON标记            if (mStayOn != wasStayOn) &#123;                mDirty |= DIRTY_STAY_ON;            &#125;        &#125;    &#125;</code></pre><p>只有mDirty设置了DIRTY_BATTERY_STATE或DIRTY_SETTINGS标记位后，才会执行该方法。DIRTY_BATTERY_STATE在电池状态发生变化后设置，DIRTY_SETTINGS是在Settings中的值发生变化后设置，mStayOnWhilePluggedInSetting就是从来自于Settings中”不锁定屏幕”的值，如果发生变化，且处于充电状态，则会更新mStayOn变量的值。在自动灭屏流程中，一旦mStayOn值为true，则永远不会灭屏，从而实现了“不锁定屏幕”这个功能。</p><h4 id="2-3-updateScreenBrightnessBoostLocked-更新是否增强亮度"><a href="#2-3-updateScreenBrightnessBoostLocked-更新是否增强亮度" class="headerlink" title="2.3 updateScreenBrightnessBoostLocked()更新是否增强亮度"></a>2.3 updateScreenBrightnessBoostLocked()更新是否增强亮度</h4><p>这个方法会更新表示增强亮度的全局变量mScreenBrightnessBoostInProgress，PMS.BinderService提供了boostScreenBrightness()方法，允许其他组件通过该接口将亮度调节到最大(短时间保持)，并保持5s后恢复：</p><pre><code>    private void updateScreenBrightnessBoostLocked(int dirty) &#123;        if ((dirty &amp; DIRTY_SCREEN_BRIGHTNESS_BOOST) != 0) &#123;            if (mScreenBrightnessBoostInProgress) &#123;                final long now = mClock.uptimeMillis();                mHandler.removeMessages(MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT);                if (mLastScreenBrightnessBoostTime &gt; mLastGlobalSleepTime) &#123;                    final long boostTimeout = mLastScreenBrightnessBoostTime +                            SCREEN_BRIGHTNESS_BOOST_TIMEOUT;                    // 向主线程mHandler发出一个异步消息，5s后会再次更新                    if (boostTimeout &gt; now) &#123;                        Message msg = mHandler.obtainMessage(MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT);                        msg.setAsynchronous(true);                        mHandler.sendMessageAtTime(msg, boostTimeout);                        return;                    &#125;                &#125;                // 表示增强亮度结束                mScreenBrightnessBoostInProgress = false;                // 更新用户活动时间                userActivityNoUpdateLocked(now,                        PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);            &#125;        &#125;    &#125;</code></pre><p>只有当mDirty设置了DIRTY_SCREEN_BRIGHTNESS_BOOST标记时，才会执行这个方法。这个标记位就是通过boostScreenBrightness()设置，这个功能在Google原生逻辑中有一个使用场景：</p><pre><code>// frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java//是否开启双击Power键定制行为(例如双击打开NFC,相机等)mDoublePressOnPowerBehavior = mContext.getResources().getInteger(        com.android.internal.R.integer.config_doublePressOnPowerBehavior);    // must match: config_doublePressOnPowerBehavior in config.xml    static final int MULTI_PRESS_POWER_NOTHING = 0;  //默认无    static final int MULTI_PRESS_POWER_THEATER_MODE = 1;  //剧场模式    static final int MULTI_PRESS_POWER_BRIGHTNESS_BOOST = 2;  //双击电源键会将亮度调到最大    static final int MULTI_PRESS_POWER_LAUNCH_TARGET_ACTIVITY = 3;  //双击打开特定应用</code></pre><h4 id="2-4-updateWakeLockSummaryLocked-更新WakeLock统计值"><a href="#2-4-updateWakeLockSummaryLocked-更新WakeLock统计值" class="headerlink" title="2.4 updateWakeLockSummaryLocked()更新WakeLock统计值"></a>2.4 updateWakeLockSummaryLocked()更新WakeLock统计值</h4><p>从这个方法开始到，直到updateWakefulnessLocked()结束，将会在一个for循环中执行。<br>该方法用来更新mWakeLockSummary属性，它是用来记录所有WakeLock锁状态的状态值，代表了所有的WakeLock，在请求Display状时作为判断条件确定具体的请求状态。系统规定了系统休眠状态对WakeLock锁的使用影响，如当系统休眠后，常亮锁(PowerManager.SCREEN_BRIGHT等)将会被忽略；系统唤醒后，Doze锁(PowerManager.DOZE_WAKE_LOCK等）将会被忽略：</p><pre><code>    private void updateWakeLockSummaryLocked(int dirty) &#123;        if ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_WAKEFULNESS | DIRTY_DISPLAY_GROUP_WAKEFULNESS))                != 0) &#123;            mWakeLockSummary = 0;  //初始值为0            // 将每个ProfilePowerState的mWakeLockSummary也进行重置            final int numProfiles = mProfilePowerState.size();            for (int i = 0; i &lt; numProfiles; i++) &#123;                mProfilePowerState.valueAt(i).mWakeLockSummary = 0;            &#125;            // 将每个mPowerGroups的setWakeLockSummaryLocked也进行重置            for (int idx = 0; idx &lt; mPowerGroups.size(); idx++) &#123;                mPowerGroups.valueAt(idx).setWakeLockSummaryLocked(0);            &#125;            int invalidGroupWakeLockSummary = 0;            final int numWakeLocks = mWakeLocks.size();            // 遍历mWakeLocks列表            for (int i = 0; i &lt; numWakeLocks; i++) &#123;                final WakeLock wakeLock = mWakeLocks.get(i);                final Integer groupId = wakeLock.getPowerGroupId();                // a wakelock with an invalid group ID should affect all groups                if (groupId == null || (groupId != Display.INVALID_DISPLAY_GROUP                        &amp;&amp; !mPowerGroups.contains(groupId))) &#123;                    continue;                &#125;                final PowerGroup powerGroup = mPowerGroups.get(groupId);                // 获取每个WakeLock对应的Flag标记                final int wakeLockFlags = getWakeLockSummaryFlags(wakeLock);                 // 标记在mWakeLockSummary上                mWakeLockSummary |= wakeLockFlags;                if (groupId != Display.INVALID_DISPLAY_GROUP) &#123;                    int wakeLockSummary = powerGroup.getWakeLockSummaryLocked();                    wakeLockSummary |= wakeLockFlags;                    powerGroup.setWakeLockSummaryLocked(wakeLockSummary);                &#125; else &#123;                    invalidGroupWakeLockSummary |= wakeLockFlags;                &#125;                // 对每个ProfilePowerState#mWakeLockSummary也进行标记                for (int j = 0; j &lt; numProfiles; j++) &#123;                    final ProfilePowerState profile = mProfilePowerState.valueAt(j);                    if (wakeLockAffectsUser(wakeLock, profile.mUserId)) &#123;                        profile.mWakeLockSummary |= wakeLockFlags;                    &#125;                &#125;            &#125;            for (int idx = 0; idx &lt; mPowerGroups.size(); idx++) &#123;                final PowerGroup powerGroup = mPowerGroups.valueAt(idx);                final int wakeLockSummary = adjustWakeLockSummary(powerGroup.getWakefulnessLocked(),                        invalidGroupWakeLockSummary | powerGroup.getWakeLockSummaryLocked());                powerGroup.setWakeLockSummaryLocked(wakeLockSummary);            &#125;            // 根据系统状态对mWakeLockSummary进行调整            mWakeLockSummary = adjustWakeLockSummary(getGlobalWakefulnessLocked(),                    mWakeLockSummary);            // 对每个ProfilePowerState#mWakeLockSummary也进行调整            for (int i = 0; i &lt; numProfiles; i++) &#123;                final ProfilePowerState profile = mProfilePowerState.valueAt(i);                profile.mWakeLockSummary = adjustWakeLockSummary(getGlobalWakefulnessLocked(),                        profile.mWakeLockSummary);            &#125;        &#125;    &#125;</code></pre><p>只有当mDirty设置了DIRTY_WAKE_LOCKS和DIRTY_WAKEFULNESS标记位时，才会执行该方法。DIRTY_WAKE_LOCKS在申请WakeLock锁时设置，DIRTY_WAKEFULNESS在系统唤醒状态发生变化时设置。<br>进入该方法后，首先从保存了WakeLock的List中进行遍历，并根据WakeLock类型给mWakeLockSummary设置标记，这些标记位如下:</p><pre><code>// frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    // Summarizes the state of all active wakelocks.    static final int WAKE_LOCK_CPU = 1 &lt;&lt; 0;  // 表示需要CPU保持唤醒状态    static final int WAKE_LOCK_SCREEN_BRIGHT = 1 &lt;&lt; 1;  // 表示持有FULL_WAKE_LOCK锁，需要屏幕常亮    static final int WAKE_LOCK_SCREEN_DIM = 1 &lt;&lt; 2;  // 表示持有SCREEN_DIM_WAKE_LOCK锁，需要保持dim不灭屏    static final int WAKE_LOCK_BUTTON_BRIGHT = 1 &lt;&lt; 3;  //表示持有FULL_WAKE_LOCK锁，需要按键灯常亮    static final int WAKE_LOCK_PROXIMITY_SCREEN_OFF = 1 &lt;&lt; 4;  // 表示持有Psensor WakeLock锁    static final int WAKE_LOCK_STAY_AWAKE = 1 &lt;&lt; 5; // only set if already awake  // 表示保持屏幕常亮(只能用在awake状态时)    static final int WAKE_LOCK_DOZE = 1 &lt;&lt; 6;   // 表示持有DOZE_WAKE_LOCK锁    static final int WAKE_LOCK_DRAW = 1 &lt;&lt; 7;   //表示持有DRAW_WAKE_LOCK锁</code></pre><p>然后将根据系统状态进行调整:</p><pre><code>// frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    private static int adjustWakeLockSummary(int wakefulness, int wakeLockSummary) &#123;        // Cancel wake locks that make no sense based on the current state.         // 唤醒状态不处于Doze状态时，忽略掉PowerManager.DOZE_WAKE_LOCK和PowerManager.DRAW_WAKE_LOCK两类型锁        if (wakefulness != WAKEFULNESS_DOZING) &#123;            wakeLockSummary &amp;= ~(WAKE_LOCK_DOZE | WAKE_LOCK_DRAW);        &#125;        // 唤醒状态处于Asleep状态或者Doze状态时，忽略掉屏幕常亮锁、PSensor锁        if (wakefulness == WAKEFULNESS_ASLEEP                || (wakeLockSummary &amp; WAKE_LOCK_DOZE) != 0) &#123;            wakeLockSummary &amp;= ~(WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM                    | WAKE_LOCK_BUTTON_BRIGHT);            if (wakefulness == WAKEFULNESS_ASLEEP) &#123;                wakeLockSummary &amp;= ~WAKE_LOCK_PROXIMITY_SCREEN_OFF;            &#125;        &#125;        // Infer implied wake locks where necessary based on the current state.        if ((wakeLockSummary &amp; (WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM)) != 0) &#123;            // 唤醒状态处于Awake状态，WAKE_LOCK_STAY_AWAKE只用于awake状态时            if (wakefulness == WAKEFULNESS_AWAKE) &#123;                wakeLockSummary |= WAKE_LOCK_CPU | WAKE_LOCK_STAY_AWAKE;            &#125; else if (wakefulness == WAKEFULNESS_DREAMING) &#123;  // 唤醒状态处于Awake状态，WAKE_LOCK_STAY_AWAKE只用于awake状态时                wakeLockSummary |= WAKE_LOCK_CPU;            &#125;        &#125;        // 有DRAW_WAKE_LOCK锁时，需要CPU保持唤醒        if ((wakeLockSummary &amp; WAKE_LOCK_DRAW) != 0) &#123;            wakeLockSummary |= WAKE_LOCK_CPU;        &#125;        return wakeLockSummary;    &#125;</code></pre><blockquote><p>在平时分析处理不灭屏相关Bug时，通过该值可确定当前系统持有哪些类型的锁。</p></blockquote><p>最终得到mWakeLockSummary，在自动灭屏流程中将使用起到重要作用，当自动灭屏时，如果mWakeLockSummary设置有WAKE_LOCK_STAY_AWAKE标记位，那么将不会灭屏。<br>此外，上面方法中出现了对ProfilePowerState对象的处理，它用来对不同user进行不同参数的设置，在多用户模式下，可以支持不同的状态，这部分略去。</p><h4 id="2-5-updateUserActivitySummaryLocked-更新用户活动状态"><a href="#2-5-updateUserActivitySummaryLocked-更新用户活动状态" class="headerlink" title="2.5 updateUserActivitySummaryLocked()更新用户活动状态"></a>2.5 updateUserActivitySummaryLocked()更新用户活动状态</h4><p>这个方法用来更新全局变量mUserActivitySummary，它表示用户活动状态，有三个值:</p><pre><code>    // Summarizes the user activity state.    static final int USER_ACTIVITY_SCREEN_BRIGHT = 1 &lt;&lt; 0;  // 表示亮屏状态下的交互    static final int USER_ACTIVITY_SCREEN_DIM = 1 &lt;&lt; 1;  // 表示Dim状态下的交互    static final int USER_ACTIVITY_SCREEN_DREAM = 1 &lt;&lt; 2;  // 表示Dreamland状态下的交互</code></pre><p>何时开始自动灭屏，就是这个方法中实现的。当设备和用户有交互时，都会根据当前时间和自动灭屏时间、Dim时长、当前唤醒状态计算下次休眠的时间，完成自动灭屏的操作。由亮屏进入Dim的时长、Dim到灭屏的时长、亮屏到屏保的时长，都是在这里计算的，这个方法的详细分析见后面的灭屏流程篇。</p><h4 id="2-6-updateAttentiveStateLocked-更新细微模式状态"><a href="#2-6-updateAttentiveStateLocked-更新细微模式状态" class="headerlink" title="2.6 updateAttentiveStateLocked()更新细微模式状态"></a>2.6 updateAttentiveStateLocked()更新细微模式状态</h4><p>这个方法用来更新细微模式状态，这是Android R上新添加的一个功能，其目的就是解决用户长时间没有操作但一直持有亮屏锁导致系统不灭屏这个场景的，算是一个省电优化项，看下是如何实现的：</p><pre><code>//frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    private void updateAttentiveStateLocked(long now, int dirty) &#123;        // 触发细微模式的时间阈值        long attentiveTimeout = getAttentiveTimeoutLocked();        // Attentive state only applies to the default display group.        // 自动休眠时间        long goToSleepTime = mPowerGroups.get(                Display.DEFAULT_DISPLAY_GROUP).getLastUserActivityTimeLocked() + attentiveTimeout;         // 细微模式提示Dialog弹出时间        long showWarningTime = goToSleepTime - mAttentiveWarningDurationConfig;        // 是否已经弹出提升对话框        boolean warningDismissed = maybeHideInattentiveSleepWarningLocked(now, showWarningTime);        if (attentiveTimeout &gt;= 0 &amp;&amp; (warningDismissed                || (dirty &amp; (DIRTY_ATTENTIVE | DIRTY_STAY_ON | DIRTY_SCREEN_BRIGHTNESS_BOOST                | DIRTY_PROXIMITY_POSITIVE | DIRTY_WAKEFULNESS | DIRTY_BOOT_COMPLETED                | DIRTY_SETTINGS)) != 0)) &#123;            mHandler.removeMessages(MSG_ATTENTIVE_TIMEOUT);            // 是否需要弹出警告            if (isBeingKeptFromInattentiveSleepLocked()) &#123;                return;            &#125;            long nextTimeout = -1;            if (now &lt; showWarningTime) &#123;                nextTimeout = showWarningTime;            &#125; else if (now &lt; goToSleepTime) &#123;                // 弹出警告给用户                mInattentiveSleepWarningOverlayController.show();                nextTimeout = goToSleepTime;            &#125;             // 下一次进入时将会灭屏            if (nextTimeout &gt;= 0) &#123;                scheduleAttentiveTimeout(nextTimeout);            &#125;        &#125;    &#125;</code></pre><p>这里提供了两个配置值：</p><ul><li>mAttentiveWarningDurationConfig表示触发细微模式前，弹出警告的时长，到达该时间时，会弹出对话框提示用户是否还要亮屏；</li><li>mAttentiveTimeoutConfig表示触发细微模式的时间阈值，到达该时长后，会进行自动灭屏；<br>这种情况下，即使没有达到用户设置的自动休眠时间，也会进行自动灭屏。</li></ul><h4 id="2-7-updateWakefulnessLocked-是否需要更新唤醒状态"><a href="#2-7-updateWakefulnessLocked-是否需要更新唤醒状态" class="headerlink" title="2.7 updateWakefulnessLocked()是否需要更新唤醒状态"></a>2.7 updateWakefulnessLocked()是否需要更新唤醒状态</h4><p>这个方法也和自动灭屏流程有关。如果满足自动灭屏条件，会更新系统唤醒状态。<br>这三个方法放在for(;;)循环中执行，是因为它们共同决定了设备的唤醒状态，前两个方法是汇总状态，后一个方法是根据前两个方法汇总的值而进行判断是否要改变当前的设备唤醒状态，汇总状态会受mWakefulness的影响，因此会进行循环处理。<br>同时，也仅仅会在超时灭屏进入睡眠或屏保时，for循环会执行两次，其他情况下，只会执行一次。这个方法的详细分析见PMS灭屏流程。</p><h4 id="2-8-updateProfilesLocked"><a href="#2-8-updateProfilesLocked" class="headerlink" title="2.8 updateProfilesLocked()"></a>2.8 updateProfilesLocked()</h4><p>以上几个方法针对全局状态进行更新，这个方法则根据ProfilePowerState中保存的状态，更新不同用户是否进入锁定状态，由于使用场景不是很高，这里暂且略过。</p><h4 id="2-9-updatePowerGroupsLocked"><a href="#2-9-updatePowerGroupsLocked" class="headerlink" title="2.9 updatePowerGroupsLocked"></a>2.9 updatePowerGroupsLocked</h4><p>该方法用于请求并更新Display状态，在这个方法中，会确定多个影响Display状态的属性，并将这些值封装到DisplayPowerRequest对象中，向DisplayMangerService发起请求，最终由DMS完成Display亮度、状态的更新：</p><pre><code>    private boolean updatePowerGroupsLocked(int dirty) &#123;        final boolean oldPowerGroupsReady = areAllPowerGroupsReadyLocked();        if ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS                | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_BOOT_COMPLETED                | DIRTY_SETTINGS | DIRTY_SCREEN_BRIGHTNESS_BOOST | DIRTY_VR_MODE_CHANGED |                DIRTY_QUIESCENT | DIRTY_DISPLAY_GROUP_WAKEFULNESS)) != 0) &#123;            if ((dirty &amp; DIRTY_QUIESCENT) != 0) &#123;                if (areAllPowerGroupsReadyLocked()) &#123;                    sQuiescent = false;                &#125; else &#123;                    mDirty |= DIRTY_QUIESCENT;                &#125;            &#125;            for (int idx = 0; idx &lt; mPowerGroups.size(); idx++) &#123;                final PowerGroup powerGroup = mPowerGroups.valueAt(idx);                final int groupId = powerGroup.getGroupId();                // Determine appropriate screen brightness and auto-brightness adjustments.                final boolean autoBrightness;  // 自动亮度是否开启                final float screenBrightnessOverride;  // 是否有覆盖亮度                if (!mBootCompleted) &#123;                    //启动过程中要求亮度稳定，要求默认亮度和Bootloader中设定的亮度值保持一致                    autoBrightness = false;  //不开启自动亮度                    screenBrightnessOverride = mScreenBrightnessDefault;  //使用默认值                &#125; else if (isValidBrightness(mScreenBrightnessOverrideFromWindowManager)) &#123;                    //使用WindowManager覆盖的亮度值                    autoBrightness = false;                    screenBrightnessOverride = mScreenBrightnessOverrideFromWindowManager;                &#125; else &#123;                    autoBrightness = (mScreenBrightnessModeSetting                            == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);                    screenBrightnessOverride = PowerManager.BRIGHTNESS_INVALID_FLOAT;                &#125;                //向DisplayMangerService发起请                boolean ready = powerGroup.updateLocked(screenBrightnessOverride, autoBrightness,                        shouldUseProximitySensorLocked(), shouldBoostScreenBrightness(),                        mDozeScreenStateOverrideFromDreamManager,                        mDozeScreenBrightnessOverrideFromDreamManagerFloat,                        mDrawWakeLockOverrideFromSidekick,                        mBatterySaverPolicy.getBatterySaverPolicy(ServiceType.SCREEN_BRIGHTNESS),                        sQuiescent, mDozeAfterScreenOff, mIsVrModeEnabled, mBootCompleted,                        mScreenBrightnessBoostInProgress, mRequestWaitForNegativeProximity);                int wakefulness = powerGroup.getWakefulnessLocked();                final boolean displayReadyStateChanged = powerGroup.setReadyLocked(ready);                final boolean poweringOn = powerGroup.isPoweringOnLocked();                if (ready &amp;&amp; displayReadyStateChanged &amp;&amp; poweringOn                        &amp;&amp; wakefulness == WAKEFULNESS_AWAKE) &#123;                    powerGroup.setIsPoweringOnLocked(false);                    LatencyTracker.getInstance(mContext).onActionEnd(ACTION_TURN_ON_SCREEN);                    Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, TRACE_SCREEN_ON, groupId);                    final int latencyMs = (int) (mClock.uptimeMillis()                            - powerGroup.getLastPowerOnTimeLocked());                    // 如果亮屏流程超过200ms，输出亮屏所用时间                    if (latencyMs &gt;= SCREEN_ON_LATENCY_WARNING_MS) &#123;                        Slog.w(TAG, &quot;Screen on took &quot; + latencyMs + &quot; ms&quot;);                    &#125;                &#125;            &#125;            // 释放PSensor WakeLock锁时的一个标记            mRequestWaitForNegativeProximity = false;        &#125;        return areAllPowerGroupsReadyLocked() &amp;&amp; !oldPowerGroupsReady;    &#125;    boolean updateLocked(float screenBrightnessOverride, boolean autoBrightness,            boolean useProximitySensor, boolean boostScreenBrightness, int dozeScreenState,            float dozeScreenBrightness, boolean overrideDrawWakeLock,            PowerSaveState powerSaverState, boolean quiescent, boolean dozeAfterScreenOff,            boolean vrModeEnabled, boolean bootCompleted, boolean screenBrightnessBoostInProgress,            boolean waitForNegativeProximity) &#123;        // 根据系统唤醒状态获取请求的&#39;策略&#39;： off, doze, dim or bright.        mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked(quiescent, dozeAfterScreenOff,                vrModeEnabled, bootCompleted, screenBrightnessBoostInProgress);        // WindowManager覆盖的亮度值，如播放视频时调节亮度        mDisplayPowerRequest.screenBrightnessOverride = screenBrightnessOverride;        // 是否使用自动亮度        mDisplayPowerRequest.useAutoBrightness = autoBrightness;        // 是否存在PSensor Wakelock锁        mDisplayPowerRequest.useProximitySensor = useProximitySensor;        // 是否有增强亮度        mDisplayPowerRequest.boostScreenBrightness = boostScreenBrightness;        // 唤醒状态为Doze时，确定display的状态        if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DOZE) &#123;            mDisplayPowerRequest.dozeScreenState = dozeScreenState;            if ((getWakeLockSummaryLocked() &amp; WAKE_LOCK_DRAW) != 0 &amp;&amp; !overrideDrawWakeLock) &#123;                if (mDisplayPowerRequest.dozeScreenState == Display.STATE_DOZE_SUSPEND) &#123;                    mDisplayPowerRequest.dozeScreenState = Display.STATE_DOZE;                &#125;                if (mDisplayPowerRequest.dozeScreenState == Display.STATE_ON_SUSPEND) &#123;                    mDisplayPowerRequest.dozeScreenState = Display.STATE_ON;                &#125;            &#125;            // Doze时的屏幕亮度            mDisplayPowerRequest.dozeScreenBrightness = dozeScreenBrightness;        &#125; else &#123;            mDisplayPowerRequest.dozeScreenState = Display.STATE_UNKNOWN;            mDisplayPowerRequest.dozeScreenBrightness = PowerManager.BRIGHTNESS_INVALID_FLOAT;        &#125;        mDisplayPowerRequest.lowPowerMode = powerSaverState.batterySaverEnabled;        mDisplayPowerRequest.screenLowPowerBrightnessFactor = powerSaverState.brightnessFactor;        // 发起请求，返回值表示DisplayPowerController中是否完成这次请求        boolean ready = mDisplayManagerInternal.requestPowerState(mGroupId, mDisplayPowerRequest,                waitForNegativeProximity);        mNotifier.onScreenPolicyUpdate(mGroupId, mDisplayPowerRequest.policy);        return ready;    &#125;</code></pre><p>在向DisplayManagerService发起请求时，会将所有的信息封装到DisplayPowerRequest对象中，其中，policy属性值有五类：</p><ul><li>POLICY_OFF：请求屏幕进入灭屏状态；</li><li>POLICY_DOZE：请求屏幕进入Doze状态；</li><li>POLICY_DIM：请求屏幕进入Dim状态，</li><li>POLICY_BRIGHT：请求屏幕处于正常亮屏状态；</li><li>POLICY_VR：VR模式相关；</li></ul><p>在请求前，通过getDesiredScreenPolicyLocked()方法，根据当前唤醒状态和WakeLock统计状态来决定要请求的Display状态：</p><pre><code>    int getDesiredScreenPolicyLocked(boolean quiescent, boolean dozeAfterScreenOff,            boolean vrModeEnabled, boolean bootCompleted, boolean screenBrightnessBoostInProgress) &#123;        final int wakefulness = getWakefulnessLocked();        final int wakeLockSummary = getWakeLockSummaryLocked();        // 当前唤醒状态为Asleep，则Display状态会设置为OFF        if (wakefulness == WAKEFULNESS_ASLEEP || quiescent) &#123;            return DisplayPowerRequest.POLICY_OFF;        &#125; else if (wakefulness == WAKEFULNESS_DOZING) &#123;  // 当前唤醒状态为Doze，则Display状态会设置为Doze指定的状态            if ((wakeLockSummary &amp; WAKE_LOCK_DOZE) != 0) &#123;                return DisplayPowerRequest.POLICY_DOZE;            &#125;            // 表示跳过Doze的状态，直接设置成OFF            if (dozeAfterScreenOff) &#123;                return DisplayPowerRequest.POLICY_OFF;            &#125;            // Fall through and preserve the current screen policy if not configured to            // doze after screen off.  This causes the screen off transition to be skipped.        &#125;        //如果开启了VR模式则设置为VR模式        if (vrModeEnabled) &#123;            return DisplayPowerRequest.POLICY_VR;        &#125;        // 如果存在亮屏锁、用户活动状态为亮屏、进行增强亮度，则Display状态将设置为ON        if ((wakeLockSummary &amp; WAKE_LOCK_SCREEN_BRIGHT) != 0                || !bootCompleted                || (getUserActivitySummaryLocked() &amp; USER_ACTIVITY_SCREEN_BRIGHT) != 0                || screenBrightnessBoostInProgress) &#123;            return DisplayPowerRequest.POLICY_BRIGHT;        &#125;        // 不满足以上条件，默认设置DIM        return DisplayPowerRequest.POLICY_DIM;    &#125;</code></pre><h4 id="2-10-updateDreamLocked"><a href="#2-10-updateDreamLocked" class="headerlink" title="2.10 updateDreamLocked()"></a>2.10 updateDreamLocked()</h4><p>该方法用来更新设备Dreamland状态，比如是否进入Dream、Doze或者开始休眠:</p><pre><code>// frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    private void updateDreamLocked(int dirty, boolean powerGroupBecameReady) &#123;        if ((dirty &amp; (DIRTY_WAKEFULNESS                | DIRTY_USER_ACTIVITY                | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED                | DIRTY_ATTENTIVE                | DIRTY_WAKE_LOCKS                | DIRTY_BOOT_COMPLETED                | DIRTY_SETTINGS                | DIRTY_IS_POWERED                | DIRTY_STAY_ON                | DIRTY_PROXIMITY_POSITIVE                | DIRTY_BATTERY_STATE)) != 0 || powerGroupBecameReady) &#123;            if (areAllPowerGroupsReadyLocked()) &#123; //areAllPowerGroupsReadyLocked为ture后，才会进一步执行                //通过Handler异步发送一个消息                scheduleSandmanLocked();            &#125;        &#125;    &#125;    private boolean areAllPowerGroupsReadyLocked() &#123;        final int size = mPowerGroups.size();        for (int i = 0; i &lt; size; i++) &#123;            if (!mPowerGroups.valueAt(i).isReadyLocked()) &#123;                return false;            &#125;        &#125;        return true;    &#125;</code></pre><p>可以看到，对于Dreamland相关状态的更新，依赖areAllPowerGroupsReadyLocked的返回值，它表示每一个display是否已经准备就绪，因此只有在准备就绪的情况下才会进一步调用该方法的方法体。最后会PMS主线程中，调用handleSandman()方法执行Dreamland的操作:</p><pre><code>// frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    private void handleSandman(int groupId) &#123; // runs on handler thread        // Handle preconditions.        final boolean startDreaming;        final int wakefulness;        synchronized (mLock) &#123;            mSandmanScheduled = false;            final PowerGroup powerGroup = mPowerGroups.get(groupId);            wakefulness = powerGroup.getWakefulnessLocked();            // 如果召唤了&quot;睡魔&quot;，且每个Display状态已经准备完毕            if ((wakefulness == WAKEFULNESS_DREAMING || wakefulness == WAKEFULNESS_DOZING) &amp;&amp;                    powerGroup.isSandmanSummonedLocked() &amp;&amp; powerGroup.isReadyLocked()) &#123;                // 判断是否可以进入Dreamland                startDreaming = canDreamLocked(powerGroup) || canDozeLocked(powerGroup);                powerGroup.setSandmanSummonedLocked(/* isSandmanSummoned= */ false);            &#125; else &#123;                startDreaming = false;            &#125;        &#125;        // Start dreaming if needed.        // We only control the dream on the handler thread, so we don&#39;t need to worry about        // concurrent attempts to start or stop the dream.        final boolean isDreaming;        if (mDreamManager != null) &#123;            // Restart the dream whenever the sandman is summoned.            if (startDreaming) &#123;                mDreamManager.stopDream(/* immediate= */ false);                // 开始进入Dreamland                mDreamManager.startDream(wakefulness == WAKEFULNESS_DOZING);            &#125;            isDreaming = mDreamManager.isDreaming();        &#125; else &#123;            isDreaming = false;        &#125;        // At this point, we either attempted to start the dream or no attempt will be made,        // so stop holding the display suspend blocker for Doze.        mDozeStartInProgress = false;        // Update dream state.        synchronized (mLock) &#123;            ...            // Remember the initial battery level when the dream started.            // 记录下进入Dream模式前的初始电量值            if (startDreaming &amp;&amp; isDreaming) &#123;                mBatteryLevelWhenDreamStarted = mBatteryLevel;                if (wakefulness == WAKEFULNESS_DOZING) &#123;                    Slog.i(TAG, &quot;Dozing...&quot;);                &#125; else &#123;                    Slog.i(TAG, &quot;Dreaming...&quot;);                &#125;            &#125;            // If preconditions changed, wait for the next iteration to determine            // whether the dream should continue (or be restarted).            final PowerGroup powerGroup = mPowerGroups.get(groupId);            if (powerGroup.isSandmanSummonedLocked()                    || powerGroup.getWakefulnessLocked() != wakefulness) &#123;                return; // wait for next cycle            &#125;            // Determine whether the dream should continue.            long now = mClock.uptimeMillis();            if (wakefulness == WAKEFULNESS_DREAMING) &#123;                if (isDreaming &amp;&amp; canDreamLocked(powerGroup)) &#123;                    if (mDreamsBatteryLevelDrainCutoffConfig &gt;= 0                            &amp;&amp; mBatteryLevel &lt; mBatteryLevelWhenDreamStarted                                    - mDreamsBatteryLevelDrainCutoffConfig                            &amp;&amp; !isBeingKeptAwakeLocked(powerGroup)) &#123;                            //充电速度慢于消耗速度或者用户活动timeout已过则退出Dream进入睡眠                    &#125; else &#123;                        return; // continue dreaming 继续维持Dream状态                    &#125;                &#125;                // Dream has ended or will be stopped.  Update the power state.                // 退出Dreamland,进入休眠状态                if (isItBedTimeYetLocked(powerGroup)) &#123;                    if (isAttentiveTimeoutExpired(powerGroup, now)) &#123;                        //更新睡眠状态                        sleepPowerGroupLocked(powerGroup, now,                                PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, Process.SYSTEM_UID);                    &#125; else &#123;                        //更新doze状态                        dozePowerGroupLocked(powerGroup, now,                                PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, Process.SYSTEM_UID);                    &#125;                &#125; else &#123;                    // 唤醒设备                    wakePowerGroupLocked(powerGroup, now,                            PowerManager.WAKE_REASON_DREAM_FINISHED,                            &quot;android.server.power:DREAM_FINISHED&quot;, Process.SYSTEM_UID,                            mContext.getOpPackageName(), Process.SYSTEM_UID);                &#125;            &#125; else if (wakefulness == WAKEFULNESS_DOZING) &#123;                if (isDreaming) &#123;                    return; // continue dozing 继续保持doze状态                &#125;                                // Doze has ended or will be stopped.  Update the power state.                // 更新睡眠状态                sleepPowerGroupLocked(powerGroup, now,  PowerManager.GO_TO_SLEEP_REASON_TIMEOUT,                        Process.SYSTEM_UID);            &#125;        &#125;        // Stop dream.        if (isDreaming) &#123;            mDreamManager.stopDream(/* immediate= */ false);        &#125;    &#125;</code></pre><p>在以上方法中，将会调用DreamManager处理具体的Dreamland逻辑，这部分流程的分析，在DreamManagerService模块分析时会进行详细分析。</p><h4 id="2-11-finishWakefulnessChangeIfNeededLocked"><a href="#2-11-finishWakefulnessChangeIfNeededLocked" class="headerlink" title="2.11 finishWakefulnessChangeIfNeededLocked()"></a>2.11 finishWakefulnessChangeIfNeededLocked()</h4><p>该方法主要做唤醒状态发生变化后，后半部分更新工作：</p><pre><code>//frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java    @GuardedBy(&quot;mLock&quot;)    private void finishWakefulnessChangeIfNeededLocked() &#123;        if (mWakefulnessChanging &amp;&amp; areAllPowerGroupsReadyLocked()) &#123;            if (getGlobalWakefulnessLocked() == WAKEFULNESS_DOZING                    &amp;&amp; (mWakeLockSummary &amp; WAKE_LOCK_DOZE) == 0) &#123;                return; // wait until dream has enabled dozing            &#125; else &#123;                // Doze wakelock acquired (doze started) or device is no longer dozing.                mDozeStartInProgress = false;            &#125;Android采码蜂:            if (getGlobalWakefulnessLocked() == WAKEFULNESS_DOZING                    || getGlobalWakefulnessLocked() == WAKEFULNESS_ASLEEP) &#123;                logSleepTimeoutRecapturedLocked();            &#125;            mWakefulnessChanging = false;            mNotifier.onWakefulnessChangeFinished();        &#125;    &#125;</code></pre><p>只有当屏幕状态改变后，才会执行该方法。进入该方法后，将通过Notifier#onWakefulnessChangeFinished()方法发送亮屏、灭屏广播等。</p><blockquote><p>该方法中的logScreenOn()方法将打印出整个亮屏流程的耗时，在平时处理问题时很有帮助。</p></blockquote><h4 id="2-12-updateSuspendBlockerLocked"><a href="#2-12-updateSuspendBlockerLocked" class="headerlink" title="2.12 updateSuspendBlockerLocked()"></a>2.12 updateSuspendBlockerLocked()</h4><p>这个方法用来更新SuspendBlocker锁状态。Suspend锁机制是Android框架中锁机的一种锁，它代表了框架层以上所有的WakeLock。Wakelock锁是APP或其他组建向PMS模块申请，而Suspend锁是PMS模块中对WakeLock锁的最终表现，或者说上层应用或system_server其他组件申请了wakelock锁后，在PMS中最终都会表现为Suspend锁，通过Suspend锁向Hal层写入节点，Kernal层会读取节点，从而唤醒或者休眠<a href="https://so.csdn.net/so/search?q=CPU&spm=1001.2101.3001.7020">CPU</a>。<br>该方法的详细分析在PMS WakeLock机制中进行汇总。<br>到此为止，对PMS中所有核心方法进行了简单的分析，有些方法仅仅说明了下作用，会在后面具体业务中进行详细分析。</p><p>跟着学习自： <a href="https://juejin.cn/post/6946581970960793613">Android R PowerManagerService模块(1) 启动流程和核心方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; PowerManagerService(简称PMS)主要是负责协调、管理设备CPU资源，并提供功能接口给应用框架层或应用层申请获取CPU资源的一个服务，例如：亮灭屏、关机、WakeLock管理、Dreamland(屏保模式)、休眠时间等行为。&lt;/p&gt;
&lt;h3 id=&quot;1-</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    
  </entry>
  
  <entry>
    <title>5.触摸事件在应用进程的分发和处理</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/5.%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2023-12-29T06:19:31.052Z</published>
    <updated>2024-01-07T03:05:50.878Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经梳理了<a href="https://so.csdn.net/so/search?q=input%E4%BA%8B%E4%BB%B6&spm=1001.2101.3001.7020">input事件</a>在native层的传递，这一篇我们接着探索input事件在应用中的传递与处理，我们将按键事件和触摸事件分开梳理，这一篇就只涉及触摸事件。</p><h4 id="一、事件的接收"><a href="#一、事件的接收" class="headerlink" title="一、事件的接收"></a>一、事件的接收</h4><p>从前面的篇幅我们知道，<a href="https://so.csdn.net/so/search?q=framework&spm=1001.2101.3001.7020">framework</a> native层<code>InputDispatcher</code>向应用通过socket方式发送事件,应用的<code>Looper</code> 通过epoll方式监听sockcet的fd, 当应用的socket变为可读时（例如，inputDispatcher向socket中写入数据），<code>Looper</code>将回调<code>handleEvent</code>。 此时，应用应读取已进入套接字的事件。 只要socket中有未读事件，函数 handleEvent 就会继续触发。</p><h5 id="NativeInputEventReceiver-handleEvent"><a href="#NativeInputEventReceiver-handleEvent" class="headerlink" title="NativeInputEventReceiver::handleEvent"></a>NativeInputEventReceiver::handleEvent</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NativeInputEventReceiver::handleEvent</span><span class="params">(<span class="type">int</span> receiveFd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allowed return values of this function as documented in LooperCallback::handleEvent</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> REMOVE_CALLBACK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> KEEP_CALLBACK = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//注意：下面这个event不是真正的输入事件，只是Looper的event</span></span><br><span class="line">    <span class="keyword">if</span> (events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP)) &#123;</span><br><span class="line">        <span class="comment">//当inputdispatcher异常导致socket被关闭或者目标窗口正在被移除或者传递窗口时输入法，但是输入法正在关闭时会直接抛弃这个事件</span></span><br><span class="line">        <span class="keyword">return</span> REMOVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是传入的事件，即是inputDispatcher传递过来的事件时需要处理时</span></span><br><span class="line">    <span class="comment">//回调java层的consumeEvents方法</span></span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line">        <span class="type">status_t</span> status = <span class="built_in">consumeEvents</span>(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;handleReceiveCallback&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? KEEP_CALLBACK : REMOVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是要传出的事件，即已处理的事件需要告知inputdispatcher这个事件已处理时</span></span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_OUTPUT) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> status = <span class="built_in">processOutboundEvents</span>();</span><br><span class="line">        <span class="keyword">if</span> (status == OK || status == WOULD_BLOCK) &#123;</span><br><span class="line">            <span class="keyword">return</span> KEEP_CALLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> REMOVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> KEEP_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里既会监视<code>inputDispatcher</code>发送过来的事件（准确的说应该是<code>InputPublisher</code>发过来的）也监视当前进程发送已经消费的事件发给Looper的行为，无论是接收来自<code>InputPublisher</code>的事件，还是来自当前进程的事件，都会被looper监听到并回调<code>handleEvent</code>。这里就用events中的标志位来区分（<code>ALOOPER_EVENT_INPUT</code>和<code>ALOOPER_EVENT_OUTPUT</code>）对于接收来自<code>InputPublisher</code>的事件则调<code>consumeEvents</code>方法处理.</p><h5 id="NativeInputEventReceiver-consumeEvents"><a href="#NativeInputEventReceiver-consumeEvents" class="headerlink" title="NativeInputEventReceiver::consumeEvents"></a>NativeInputEventReceiver::consumeEvents</h5><pre><code>//frameworks/base/core/jni/android_view_InputEventReceiver.cppstatus_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,        bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123;    ...    ScopedLocalRef&lt;jobject&gt; receiverObj(env, nullptr);    bool skipCallbacks = false;    for (;;) &#123;        uint32_t seq;        InputEvent* inputEvent;        //获取mInputConsumer发过来的事件，并构建成具体的某种InputEvent，例如MotionEvent        status_t status = mInputConsumer.consume(&amp;mInputEventFactory,                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);        if (status != OK &amp;&amp; status != WOULD_BLOCK) &#123;            ALOGE(&quot;channel &#39;%s&#39; ~ Failed to consume input event.  status=%s(%d)&quot;,                  getInputChannelName().c_str(), statusToString(status).c_str(), status);            return status;        &#125;        ...</code></pre><h5 id="InputConsumer-consume"><a href="#InputConsumer-consume" class="headerlink" title="InputConsumer::consume"></a>InputConsumer::consume</h5><pre><code>//frameworks/native/libs/input/InputTransport.cppstatus_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches,                                nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123;    ...    *outSeq = 0;    *outEvent = nullptr;    // Fetch the next input message.    // Loop until an event can be returned or no additional events are received.    while (!*outEvent) &#123;  //获取到一次真正的事件就退出        if (mMsgDeferred) &#123;            ...        &#125; else &#123;            // Receive a fresh message.            status_t result = mChannel-&gt;receiveMessage(&amp;mMsg);  //通过InputChannel来接收socket中真正的InputMessage(描述事件的结构体)            ...        &#125;        ...        &#125;    &#125;    return OK;&#125;</code></pre><p><code>InputConsumer::consume</code>中获取事件实际上是通过InputChannel去读取</p><h5 id="InputChannel-receiveMessage"><a href="#InputChannel-receiveMessage" class="headerlink" title="InputChannel::receiveMessage"></a>InputChannel::receiveMessage</h5><pre><code>frameworks/native/libs/input/InputTransport.cppstatus_t InputChannel::receiveMessage(InputMessage* msg) &#123;    ssize_t nRead;    do &#123;        nRead = ::recv(getFd(), msg, sizeof(InputMessage), MSG_DONTWAIT); //在这里真正的读取socket fd,并将输入事件信息装入msg（InputMessage)    &#125; while (nRead == -1 &amp;&amp; errno == EINTR);        ...        return OK;  //最后返回OK&#125;</code></pre><p>通过<code>InputChannel</code>去读取真正的事件信息，并装入InputMessage对象，最后返回OK</p><h5 id="InputChannel-receiveMessage-1"><a href="#InputChannel-receiveMessage-1" class="headerlink" title="InputChannel::receiveMessage"></a>InputChannel::receiveMessage</h5><pre><code>frameworks/native/libs/input/InputTransport.cppstatus_t InputChannel::receiveMessage(InputMessage* msg) &#123;    ssize_t nRead;    do &#123;        nRead = ::recv(getFd(), msg, sizeof(InputMessage), MSG_DONTWAIT); //在这里真正的读取socket fd,并将输入事件信息装入msg（InputMessage)    &#125; while (nRead == -1 &amp;&amp; errno == EINTR);        ...        return OK;  //最后返回OK&#125;</code></pre><p>通过<code>InputChannel</code>去读取真正的事件信息，并装入InputMessage对象，最后返回OK；</p><p>创建并使用InputMessager中的事件信息填充MotionEvent，然后继续往下执行 <code>NativeInputEventReceiver::consumeEvents</code></p><h5 id="NativeInputEventReceiver-consumeEvents-1"><a href="#NativeInputEventReceiver-consumeEvents-1" class="headerlink" title="NativeInputEventReceiver::consumeEvents"></a>NativeInputEventReceiver::consumeEvents</h5><pre><code>//frameworks/base/core/jni/android_view_InputEventReceiver.cppstatus_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,        bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123;    ...    for (;;) &#123;        uint32_t seq;        InputEvent* inputEvent;        //真正的去获取socket发过来的事件，并构建成具体的某种InputEvent，例MotionEvent        //上面的分析从这里进入的，返回到这里继续往下分析        status_t status = mInputConsumer.consume(&amp;mInputEventFactory,                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);        ...        if (!skipCallbacks) &#123;            jobject inputEventObj;            switch (inputEvent-&gt;getType()) &#123;            case AINPUT_EVENT_TYPE_MOTION: &#123;                MotionEvent* motionEvent = static_cast&lt;MotionEvent*&gt;(inputEvent);                if ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;                    *outConsumedBatch = true;                &#125;                //创建一个java层MotionEvent对象                inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent);                break;                &#125;            &#125;            ...            if (inputEventObj) &#123;                ...//jni调用InputEventReceiver.java中的InputEventReceiver，将事件传递到java的世界                //                env-&gt;CallVoidMethod(receiverObj.get(),                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);                  ...                env-&gt;DeleteLocalRef(inputEventObj);            &#125;            ...        &#125;    &#125;&#125;</code></pre><h5 id="dispatchInputEvent"><a href="#dispatchInputEvent" class="headerlink" title="dispatchInputEvent"></a>dispatchInputEvent</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/view/InputEventReceiver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> <span class="title class_">InputEventReceiver</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//  //从native执行的调用</span></span><br><span class="line">    @<span class="built_in">SuppressWarnings</span>(<span class="string">&quot;unused&quot;</span>)</span><br><span class="line">    @<span class="built_in">UnsupportedAppUsage</span>(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = <span class="number">170729553</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="type">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">        mSeqMap.<span class="built_in">put</span>(event.<span class="built_in">getSequenceNumber</span>(), seq);</span><br><span class="line">        <span class="built_in">onInputEvent</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputEventReceiver是一个抽象类，但是对应的dispatchInputEvent方法，它的子类WindowInputEventReceiver并没有实现，所以native层调用父类的InputEventReceiver的方法，这个方法中接着调用了onInputEvent接着处理。onInputEvent子类是有实现的，所以会走子类的方法。</p><h5 id="onInputEvent"><a href="#onInputEvent" class="headerlink" title="onInputEvent"></a>onInputEvent</h5><pre><code>//frameworks/base/core/java/android/view/ViewRootImpl.java    ...    final class WindowInputEventReceiver extends InputEventReceiver &#123;        public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123;            super(inputChannel, looper);        &#125;        @Override        public void onInputEvent(InputEvent event) &#123;            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;processInputEventForCompatibility&quot;);            List&lt;InputEvent&gt; processedEvents;            try &#123;                //对M版本之前的触摸事件的兼容处理                processedEvents =                    mInputCompatProcessor.processInputEventForCompatibility(event);             &#125; finally &#123;                Trace.traceEnd(Trace.TRACE_TAG_VIEW);            &#125;            if (processedEvents != null) &#123;                ...            &#125; else &#123;  //因为上面返回null 所以走到这里                //在这里将自己this传入                //processImmediately 为true意味着需要马上处理，而不是延迟处理                       enqueueInputEvent(event, this, 0, true);            &#125;        &#125;    ...</code></pre><p><code>onInputEvent</code>中会通过<code>QueuedInputEvent</code>的<code>enqueueInputEvent</code>将事件加入队列中再处理</p><h5 id="enqueueInputEvent"><a href="#enqueueInputEvent" class="headerlink" title="enqueueInputEvent"></a>enqueueInputEvent</h5><pre><code>//frameworks/base/core/java/android/view/ViewRootImpl.java            @UnsupportedAppUsage    void enqueueInputEvent(InputEvent event,            InputEventReceiver receiver, int flags, boolean processImmediately) &#123;        QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);  //将事件加入队列，确保事件的有序处理        if (event instanceof MotionEvent) &#123;            MotionEvent me = (MotionEvent) event;            if (me.getAction() == MotionEvent.ACTION_CANCEL) &#123;                //inputDispatcher中会根据实际焦点和触摸坐标的关系或者事件是有down无up情形设置ACTION_CANCEL            &#125;        &#125; else if (event instanceof KeyEvent) &#123;            ...        &#125;        // Always enqueue the input event in order, regardless of its time stamp.        // We do this because the application or the IME may inject key events        // in response to touch events and we want to ensure that the injected keys        // are processed in the order they were received and we cannot trust that        // the time stamp of injected events are monotonic.        // 无论时间戳如何，始终按顺序排列输入事件。        // 我们这样做是因为应用程序或 IME 可能会注入按键事件以响应触摸事件，        // 我们希望确保注入的按键按照接收到的顺序进行处理，不能仅仅通过时间戳的前后来确定顺序。        QueuedInputEvent last = mPendingInputEventTail;        if (last == null) &#123;            mPendingInputEventHead = q;            mPendingInputEventTail = q;        &#125; else &#123;            last.mNext = q;            mPendingInputEventTail = q;        &#125;        mPendingInputEventCount += 1;        Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,                mPendingInputEventCount);        if (processImmediately) &#123;            doProcessInputEvents();  //前面传进来的processImmediately = true所以走这里处理        &#125; else &#123;            scheduleProcessInputEvents();        &#125;    &#125;</code></pre><h5 id="doProcessInputEvents"><a href="#doProcessInputEvents" class="headerlink" title="doProcessInputEvents"></a>doProcessInputEvents</h5><pre><code>//frameworks/base/core/java/android/view/ViewRootImpl.java    void doProcessInputEvents() &#123;        // Deliver all pending input events in the queue.        while (mPendingInputEventHead != null) &#123;            QueuedInputEvent q = mPendingInputEventHead;  //从队头开始处理            mPendingInputEventHead = q.mNext;            if (mPendingInputEventHead == null) &#123;                mPendingInputEventTail = null;            &#125;            q.mNext = null;            mPendingInputEventCount -= 1;            Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,                    mPendingInputEventCount);            mViewFrameInfo.setInputEvent(mInputEventAssigner.processEvent(q.mEvent));            deliverInputEvent(q);  //开始分发事件        &#125;        // We are done processing all input events that we can process right now        // so we can clear the pending flag immediately.        //已经处理完所有待办的输入事件，是时候移除主线程mHandler中的MSG_PROCESS_INPUT_EVENTS消息了        if (mProcessInputEventsScheduled) &#123;            mProcessInputEventsScheduled = false;            mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS);        &#125;    &#125;</code></pre><h4 id="二、事件的传递"><a href="#二、事件的传递" class="headerlink" title="二、事件的传递"></a>二、事件的传递</h4><p>前面将事件入队，然后在<code>doProcessInputEvents</code>就开始从队头拿出并通过<code>deliverInputEvent</code>开始分发</p><h5 id="deliverInputEvent"><a href="#deliverInputEvent" class="headerlink" title="deliverInputEvent"></a>deliverInputEvent</h5><pre><code>//frameworks/base/core/java/android/view/ViewRootImpl.java    private void deliverInputEvent(QueuedInputEvent q) &#123;        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, &quot;deliverInputEvent&quot;,                q.mEvent.getId());        ...        try &#123;            ...            InputStage stage;            if (q.shouldSendToSynthesizer()) &#123;                stage = mSyntheticInputStage;            &#125; else &#123;                //如果忽略输入法窗口则从mFirstPostImeInputStage阶段开始分发，否则从mFirstInputStage开始                stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;            &#125;            ...            if (stage != null) &#123;                handleWindowFocusChanged();  //在分发前确认是否焦点窗口变化了，如果变化就需要更新焦点的信息                stage.deliver(q);  //调用对应的stage阶段的deliver方法分发事件            &#125; else &#123;                finishInputEvent(q);            &#125;        &#125; finally &#123;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        &#125;    &#125;</code></pre><p>把事件从拿出，下一步就是往view或者IME分发，分发的过程这里会分为多个阶段(InputStage)来顺序执行, 这些阶段在ViewRootImpl中setView时会指定</p><h5 id="setView"><a href="#setView" class="headerlink" title="setView"></a>setView</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We have one child</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == null) &#123;</span><br><span class="line">            </span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// Set up the input pipeline.</span></span><br><span class="line">                CharSequence counterSuffix = attrs.<span class="built_in">getTitle</span>();</span><br><span class="line">                <span class="comment">//这里进行的赋值；</span></span><br><span class="line">                mSyntheticInputStage = <span class="keyword">new</span> <span class="built_in">SyntheticInputStage</span>();</span><br><span class="line">                InputStage viewPostImeStage = <span class="keyword">new</span> <span class="built_in">ViewPostImeInputStage</span>(mSyntheticInputStage);</span><br><span class="line">                InputStage nativePostImeStage = <span class="keyword">new</span> <span class="built_in">NativePostImeInputStage</span>(viewPostImeStage,</span><br><span class="line">                        <span class="string">&quot;aq:native-post-ime:&quot;</span> + counterSuffix);</span><br><span class="line">                InputStage earlyPostImeStage = <span class="keyword">new</span> <span class="built_in">EarlyPostImeInputStage</span>(nativePostImeStage);</span><br><span class="line">                InputStage imeStage = <span class="keyword">new</span> <span class="built_in">ImeInputStage</span>(earlyPostImeStage,</span><br><span class="line">                        <span class="string">&quot;aq:ime:&quot;</span> + counterSuffix);</span><br><span class="line">                InputStage viewPreImeStage = <span class="keyword">new</span> <span class="built_in">ViewPreImeInputStage</span>(imeStage);</span><br><span class="line">                InputStage nativePreImeStage = <span class="keyword">new</span> <span class="built_in">NativePreImeInputStage</span>(viewPreImeStage,</span><br><span class="line">                        <span class="string">&quot;aq:native-pre-ime:&quot;</span> + counterSuffix);</span><br><span class="line"></span><br><span class="line">                mFirstInputStage = nativePreImeStage;</span><br><span class="line">                mFirstPostImeInputStage = earlyPostImeStage;</span><br><span class="line">                mPendingInputEventQueueLengthCounterName = <span class="string">&quot;aq:pending:&quot;</span> + counterSuffix;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>InputStage</code>这里采用责任链的设计模式，从抽象类<code>InputStage</code>内容可以知道，每一个子类都会将next指向下一个stage子类对象</p><h5 id="InputStage"><a href="#InputStage" class="headerlink" title="InputStage"></a>InputStage</h5><pre><code>//frameworks/base/core/java/android/view/ViewRootImpl.java    abstract class InputStage &#123;        private final InputStage mNext;        protected static final int FORWARD = 0;        protected static final int FINISH_HANDLED = 1;        protected static final int FINISH_NOT_HANDLED = 2;        private String mTracePrefix;        /**         * Creates an input stage.         * 将所有的阶段都组成一个链表，next指向下一个阶段         * @param next The next stage to which events should be forwarded.         */        public InputStage(InputStage next) &#123;            mNext = next;        &#125;        ...</code></pre><p>从<code>setView</code>方法中的内容，我们得出整个链条的结构</p><p><img src="/../../../../../images/image-20240107104408898.png" alt="image-20240107104408898"></p><p>分发阶段就会从第一个创建的stage子类开始执行到最后一个stage子类,无论要不要处理，都要从链表的头传递到尾。<br>回到<code>deliverInputEvent</code>方法中<code>stage.deliver(q)</code>正式进入stage的分发中,观察下完整的一个stage的处理流程</p><pre><code>//frameworks/base/core/java/android/view/ViewRootImpl.java        /**         * Delivers an event to be processed.         */        public final void deliver(QueuedInputEvent q) &#123;            if ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != 0) &#123;  //如果上一stage中事件被处理（FLAG_FINISHED）那么本stage就不会再处理（onProcess），直接传递到下一个stage(无论是要处理，链表都要走完)                forward(q);            &#125; else if (shouldDropInputEvent(q)) &#123;                finish(q, false);            &#125; else &#123;                traceEvent(q, Trace.TRACE_TAG_VIEW);                final int result;                try &#123;                    result = onProcess(q);  //如果前面的阶段没有被处理，本stage就需要走处理流程                &#125; finally &#123;                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);                &#125;                apply(q, result);  //判断是否需要下一个阶段走处理流程            &#125;        &#125;        /**         * Marks the input event as finished then forwards it to the next stage.         *  如果事件在当前阶段被结束，q.mFlags被标记为FLAG_FINISHED，并通过forward(q)传递给下一个阶段         */        protected void finish(QueuedInputEvent q, boolean handled) &#123;            q.mFlags |= QueuedInputEvent.FLAG_FINISHED;            if (handled) &#123;                q.mFlags |= QueuedInputEvent.FLAG_FINISHED_HANDLED;            &#125;            forward(q);        &#125;        /**         * Forwards the event to the next stage.         * 往下一个阶段分发         */        protected void forward(QueuedInputEvent q) &#123;            onDeliverToNext(q);// 继续往下一个阶段传递        &#125;        /**         * Applies a result code from &#123;@link #onProcess&#125; to the specified event.         * 判断是否需要继续接着往下一个阶段分发         */        protected void apply(QueuedInputEvent q, int result) &#123;            if (result == FORWARD) &#123;  //如果上一个阶段还没处理这个事件，则继续往下一个阶段分发处理                forward(q);            &#125; else if (result == FINISH_HANDLED) &#123;   //如果事件被处理了，就标记为FLAG_FINISHED|FLAG_FINISHED_HANDLED，然后继续传递给下一个阶段（但不走onProcess()了）                finish(q, true);            &#125; else if (result == FINISH_NOT_HANDLED) &#123;  //如果事件没有被处理则标记为FLAG_FINISHED，然后继续传递给下一个阶段（但不走onProcess()了）                finish(q, false);            &#125; else &#123;                throw new IllegalArgumentException(&quot;Invalid result: &quot; + result);            &#125;        &#125;        /**         * Called when an event is ready to be processed.         * @return A result code indicating how the event was handled.         */        protected int onProcess(QueuedInputEvent q) &#123;            return FORWARD;        &#125;        /**         * Called when an event is being delivered to the next stage.         * 继续执行下一阶段的deliver         */        protected void onDeliverToNext(QueuedInputEvent q) &#123;            if (DEBUG_INPUT_STAGES) &#123;                Log.v(mTag, &quot;Done with &quot; + getClass().getSimpleName() + &quot;. &quot; + q);            &#125;            if (mNext != null) &#123;                mNext.deliver(q);  //如果下一阶段不为空就继续执行下一阶段的deliver，继续往下一阶段传递            &#125; else &#123;                finishInputEvent(q);            &#125;        &#125;</code></pre><p>具体如流程图： </p><p><img src="/../../../../../images/image-20240107104610042.png" alt="image-20240107104610042"></p><p>从<code>NativePreImeInputStage</code>开始deliver，事件经过每一个stage, 如果该事件没有被处理（标记为）<code>FLAG_FINISHED</code>或者该事件应该被抛弃<code>（shouldDropInputEvent</code>)，那么就应该传给本阶段<code>（stage）</code>处理<code>（onProcess）</code>，按照这个逻辑一直跑完整个链表。</p><h4 id="三、View树的分发"><a href="#三、View树的分发" class="headerlink" title="三、View树的分发"></a>三、View树的分发</h4><p>在这里阶段里我们本篇比较关心往View树分发的阶段，即<code>ViewPostImeInputStage</code></p><h5 id="ViewPostImeInputStage"><a href="#ViewPostImeInputStage" class="headerlink" title="ViewPostImeInputStage"></a>ViewPostImeInputStage</h5><pre><code>    /**     * Delivers post-ime input events to the view hierarchy.     */    final class ViewPostImeInputStage extends InputStage &#123;        public ViewPostImeInputStage(InputStage next) &#123;            super(next);        &#125;        @Override        protected int onProcess(QueuedInputEvent q) &#123;            if (q.mEvent instanceof KeyEvent) &#123;                return processKeyEvent(q);  //按键事件            &#125; else &#123;                final int source = q.mEvent.getSource();                if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123;                    return processPointerEvent(q);  //pointer类型（包含触摸事件）                &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123;                    return processTrackballEvent(q);  //轨迹球                &#125; else &#123;                    return processGenericMotionEvent(q);  //其他                &#125;            &#125;        &#125;        @Override        protected void onDeliverToNext(QueuedInputEvent q) &#123;            ...            super.onDeliverToNext(q);        &#125;        private int processPointerEvent(QueuedInputEvent q) &#123;            final MotionEvent event = (MotionEvent)q.mEvent;            mHandwritingInitiator.onTouchEvent(event);            mAttachInfo.mUnbufferedDispatchRequested = false;            mAttachInfo.mHandlingPointerEvent = true;                        boolean handled = mView.dispatchPointerEvent(event);  //mView实际上是DecorView, 在addView时添加                        maybeUpdatePointerIcon(event);            maybeUpdateTooltip(event);            mAttachInfo.mHandlingPointerEvent = false;            if (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123;                mUnbufferedInputDispatch = true;                if (mConsumeBatchedInputScheduled) &#123;                    scheduleConsumeBatchedInputImmediately();                &#125;            &#125;            return handled ? FINISH_HANDLED : FORWARD;        &#125;        ... &#125;</code></pre><p>回顾下继承关系：DecorView-&gt;FrameLayout-&gt;ViewGroup-&gt;View<br><code>dispatchPointerEvent</code>方法并没有被<code>DecorView-&gt;FrameLayout-&gt;ViewGroup</code>实现，是祖父类View实现了这个方法</p><h5 id="View-dispatchPointerEvent"><a href="#View-dispatchPointerEvent" class="headerlink" title="View::dispatchPointerEvent"></a>View::dispatchPointerEvent</h5><pre><code>    public final boolean dispatchPointerEvent(MotionEvent event) &#123;        if (event.isTouchEvent()) &#123;  //根据MotionEvent事件的类型，如果是触摸事件            return dispatchTouchEvent(event);  //此时是this对象是DecorView子类对象，所以调的是它的dispatchTouchEvent        &#125; else &#123;  //其他（如鼠标）            return dispatchGenericMotionEvent(event);        &#125;    &#125;</code></pre><h5 id="DecorView-dispatchTouchEvent"><a href="#DecorView-dispatchTouchEvent" class="headerlink" title="DecorView::dispatchTouchEvent"></a>DecorView::dispatchTouchEvent</h5><pre><code>    @Override    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        final Window.Callback cb = mWindow.getCallback();        //这个cb实际上是Activity对象，(当调Activity的attach方法时， 通过mWindow.setCallback(this)传入)        //这里判断条件为真，走cb.dispatchTouchEvent(ev)，也就是Activity的方法        return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0                ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);    &#125;</code></pre><h5 id="Activity-dispatchTouchEvent"><a href="#Activity-dispatchTouchEvent" class="headerlink" title="Activity::dispatchTouchEvent"></a>Activity::dispatchTouchEvent</h5><pre><code>    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;            onUserInteraction(); //按下时通知通知栏进行相应的变化        &#125;        //getWindow获取到的是PhoneWindow对象(在Activity的attach方法中创建的)        //所以这里会传递给PhoneWindow::superDispatchTouchEvent        if (getWindow().superDispatchTouchEvent(ev)) &#123;            return true;        &#125;        //如果上面的链路都没人处理，一路都是返回的false，那么最终还是由Activity来消费        return onTouchEvent(ev);    &#125;</code></pre><h5 id="PhoneWindow-superDispatchTouchEvent"><a href="#PhoneWindow-superDispatchTouchEvent" class="headerlink" title="PhoneWindow::superDispatchTouchEvent"></a>PhoneWindow::superDispatchTouchEvent</h5><pre><code>    @Override    public boolean superDispatchTouchEvent(MotionEvent event) &#123;        // 兜兜转转又到DecorView手里，原因就是它是View树的最顶部ViewGroup呀，还是得从它开始的        return mDecor.superDispatchTouchEvent(event);    &#125;</code></pre><h5 id="DecorView-superDispatchTouchEvent"><a href="#DecorView-superDispatchTouchEvent" class="headerlink" title="DecorView::superDispatchTouchEvent"></a>DecorView::superDispatchTouchEvent</h5><pre><code>    public boolean superDispatchTouchEvent(MotionEvent event) &#123;        //调用父类ViewGroup的dispatchTouchEvent开始遍历子成员分发         //step ViewGroup.java dispatchTouchEvent();        return super.dispatchTouchEvent(event);    &#125;</code></pre><h5 id="ViewGroup-dispatchTouchEvent"><a href="#ViewGroup-dispatchTouchEvent" class="headerlink" title="ViewGroup::dispatchTouchEvent"></a>ViewGroup::dispatchTouchEvent</h5><pre><code>    @Override    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        ...        boolean handled = false;        if (onFilterTouchEventForSecurity(ev)) &#123;            final int action = ev.getAction();            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;            // Handle an initial down.            //如果这是个ACTION_DOWN事件说明是一个新触摸行为的开始，那么重置相关的状态            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;                // Throw away all previous state when starting a new touch gesture.                // The framework may have dropped the up or cancel event for the previous gesture                // due to an app switch, ANR, or some other state change.                cancelAndClearTouchTargets(ev);                resetTouchState();            &#125;            // Check for interception.            //ViewGroup是否拦截当前事件，通过onInterceptTouchEvent方法。这个方法只有ViewGroup有            final boolean intercepted;            if (actionMasked == MotionEvent.ACTION_DOWN                    || mFirstTouchTarget != null) &#123;                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;                if (!disallowIntercept) &#123;                    intercepted = onInterceptTouchEvent(ev);  //                    ev.setAction(action); // restore action in case it was changed                &#125; else &#123;                    intercepted = false;                &#125;            &#125; else &#123;                // There are no touch targets and this action is not an initial down                // so this view group continues to intercept touches.                intercepted = true;            &#125;                        ...                        if (!canceled &amp;&amp; !intercepted) &#123;                //当这时一个ACTION_DOWN事件进这里                if (actionMasked == MotionEvent.ACTION_DOWN                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;                    final int actionIndex = ev.getActionIndex(); // always 0 for down                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)                            : TouchTarget.ALL_POINTER_IDS;                    // Clean up earlier touch targets for this pointer id in case they                    // have become out of sync.                    removePointersFromTouchTargets(idBitsToAssign);                    final int childrenCount = mChildrenCount;                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;                        final float x =                                isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);                        final float y =                                isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);                                                        // Find a child that can receive the event.                        // Scan children from front to back.                        //在当前ViewGroup中找到能处理这个事件的子View或者Viewgroup                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();                        final boolean customOrder = preorderedList == null                                &amp;&amp; isChildrenDrawingOrderEnabled();                        final View[] children = mChildren;                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;                            final int childIndex = getAndVerifyPreorderedIndex(                                    childrenCount, i, customOrder);                            final View child = getAndVerifyPreorderedView(                                    preorderedList, children, childIndex);                               ....                            newTouchTarget = getTouchTarget(child);                            resetCancelNextUpFlag(child);                            //传递到child，调用dispatchTouchEvent，或者如果当前ViewGroup没有child，则调用View的dispatchTouchEvent交由当前ViewGroup处理                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;                                // Child wants to receive touch within its bounds.                                ...                                mLastTouchDownX = ev.getX();                                mLastTouchDownY = ev.getY();                                //记录下这个能消费触摸事件的View target                                newTouchTarget = addTouchTarget(child, idBitsToAssign);                                alreadyDispatchedToNewTouchTarget = true;  //这个标识通过这个Down事件找到了能处理这个触摸行为的View target                                break;                            &#125;                            // The accessibility focus didn&#39;t handle the event, so clear                            // the flag and do a normal dispatch to all children.                            ev.setTargetAccessibilityFocus(false);                        &#125;                        if (preorderedList != null) preorderedList.clear();                    &#125;                    ...                &#125;            &#125;            // Dispatch to touch targets.            if (mFirstTouchTarget == null) &#123;                // No touch targets so treat this as an ordinary view.                //如果找不到mFirstTouchTarget，则交给当前ViewGroup处理，即通过super.dispatchTouchEvent(event)                handled = dispatchTransformedTouchEvent(ev, canceled, null,                        TouchTarget.ALL_POINTER_IDS);            &#125; else &#123;                // Dispatch to touch targets, excluding the new touch target if we already                // dispatched to it.  Cancel touch targets if necessary.                TouchTarget predecessor = null;                TouchTarget target = mFirstTouchTarget;                while (target != null) &#123;                    final TouchTarget next = target.next;                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;                        //前面的dispatchTransformedTouchEvent已经处理了这个Down事件,直接标识为已消费                        handled = true;                    &#125; else &#123;                        final boolean cancelChild = resetCancelNextUpFlag(target.child)                                || intercepted;                        //如果被拦截，则给子child发ACTION_CANCEL事件                        //如果没有拦截则正常分发到子类，包括MOVE和UP事件                        if (dispatchTransformedTouchEvent(ev, cancelChild,                                target.child, target.pointerIdBits)) &#123;                            handled = true;                        &#125;                        if (cancelChild) &#123;                            if (predecessor == null) &#123;                                mFirstTouchTarget = next;                            &#125; else &#123;                                predecessor.next = next;                            &#125;                            target.recycle();                            target = next;                            continue;                        &#125;                    &#125;                    predecessor = target;                    target = next;                &#125;            &#125;        ...        return handled;    &#125;</code></pre><h5 id="ViewGroup-dispatchTransformedTouchEvent"><a href="#ViewGroup-dispatchTransformedTouchEvent" class="headerlink" title="ViewGroup::dispatchTransformedTouchEvent"></a>ViewGroup::dispatchTransformedTouchEvent</h5><pre><code>    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,            View child, int desiredPointerIdBits) &#123;        final boolean handled;        ...        final MotionEvent transformedEvent;        if (newPointerIdBits == oldPointerIdBits) &#123;            if (child == null || child.hasIdentityMatrix()) &#123;                if (child == null) &#123; //如果当前ViewGroup没有子View或者子ViewGroup，则调用View的dispatchTouchEvent，即由当前ViewGroup来处理                    handled = super.dispatchTouchEvent(event);                &#125; else &#123;                    final float offsetX = mScrollX - child.mLeft;                    final float offsetY = mScrollY - child.mTop;                    event.offsetLocation(offsetX, offsetY);                    handled = child.dispatchTouchEvent(event);  //由子View或者子ViewGroup的dispatchTouchEvent处理                    event.offsetLocation(-offsetX, -offsetY);                &#125;                return handled;            &#125;            transformedEvent = MotionEvent.obtain(event);        &#125; else &#123;            transformedEvent = event.split(newPointerIdBits);        &#125;        ...        return handled;    &#125;</code></pre><h5 id="View-dispatchTouchEvent"><a href="#View-dispatchTouchEvent" class="headerlink" title="View::dispatchTouchEvent"></a>View::dispatchTouchEvent</h5><pre><code>    public boolean dispatchTouchEvent(MotionEvent event) &#123;        ...        if (onFilterTouchEventForSecurity(event)) &#123;            ...            //noinspection SimplifiableIfStatement            ListenerInfo li = mListenerInfo;            if (li != null &amp;&amp; li.mOnTouchListener != null                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;  //如果实现了onTouch方法，则不往下执行                result = true;            &#125;            if (!result &amp;&amp; onTouchEvent(event)) &#123;  //调用当前View的onTouchEvent(这个View可能是View也可能是ViewGroup)                result = true;            &#125;        &#125;        ...        return result;    &#125;</code></pre><h5 id="View-onTouchEvent"><a href="#View-onTouchEvent" class="headerlink" title="View::onTouchEvent"></a>View::onTouchEvent</h5><pre><code>    public boolean onTouchEvent(MotionEvent event) &#123;           final float x = event.getX();        final float y = event.getY();        final int viewFlags = mViewFlags;        final int action = event.getAction();        final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;        ...        if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;  //根据action进行处理            switch (action) &#123;                case MotionEvent.ACTION_UP:                     ...                    break;                case MotionEvent.ACTION_DOWN:                    ...                    break;                case MotionEvent.ACTION_CANCEL:                    ...                    break;                case MotionEvent.ACTION_MOVE:                    ...                    break;            &#125;            return true;        &#125;        return false;    &#125;</code></pre><p>这个方法也是又臭又长，核心方法了, 还是用图来说明更直接，也结束触摸事件的分析。</p><p><img src="/../../../../../images/49401196c705443fa51bc2804b769e2b-17045930876368.jpeg" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面我们已经梳理了&lt;a href=&quot;https://so.csdn.net/so/search?q=input%E4%BA%8B%E4%BB%B6&amp;spm=1001.2101.3001.7020&quot;&gt;input事件&lt;/a&gt;在native层的传递，这一篇我们接着探索input事</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="InPutManagerService" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"/>
    
    
  </entry>
  
  <entry>
    <title>4.InputDispatcher事件分发</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/4.InputDispatcher%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</id>
    <published>2023-12-29T06:17:18.207Z</published>
    <updated>2024-01-07T01:57:31.774Z</updated>
    
    <content type="html"><![CDATA[<h4 id="InputDispatcher-dispatchOnce"><a href="#InputDispatcher-dispatchOnce" class="headerlink" title="InputDispatcher::dispatchOnce()"></a>InputDispatcher::dispatchOnce()</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;dispatcher&#x2F;InputDispatcher.cpp</p><pre><code>void InputDispatcher::dispatchOnce() &#123;    nsecs_t nextWakeupTime = LONG_LONG_MAX;    &#123; // acquire lock        std::scoped_lock _l(mLock);        mDispatcherIsAlive.notify_all();  //唤醒在这个condition上wait的所有地方                // Run a dispatch loop if there are no pending commands.        // The dispatch loop might enqueue commands to run afterwards.        // 如果当前没有待办的command需要处理（command一般是需要处理一些异常情况，比如ANR）        // 就进行事件的分发        if (!haveCommandsLocked()) &#123;            dispatchOnceInnerLocked(&amp;nextWakeupTime);  //事件分发        &#125;        // Run all pending commands if there are any.        // If any commands were run then force the next poll to wake up immediately.        // 如果mCommandQueue不为空，就执行完所有command，并将下次唤醒时间设置为最小值，强制下一次poll唤醒线程        if (runCommandsLockedInterruptable()) &#123;            nextWakeupTime = LONG_LONG_MIN;        &#125;        // If we are still waiting for ack on some events,        // we might have to wake up earlier to check if an app is anr&#39;ing.        // 如果此时正在等待分发出去的事件的ack(目标应用的响应)，我们需要早点唤醒去检查这个应用是否正在ANR        const nsecs_t nextAnrCheck = processAnrsLocked();        nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck);        // We are about to enter an infinitely long sleep, because we have no commands or        // pending or queued events        // 如果唤醒时间还是LONG_LONG_MAX没有被修改        // 说明上面没有待处理的事件也没有待处理的command，那么将进入无限期的休眠中        if (nextWakeupTime == LONG_LONG_MAX) &#123;            mDispatcherEnteredIdle.notify_all();  //唤醒等待进入idle状态的condition        &#125;    &#125; // release lock    // Wait for callback or timeout or wake.  (make sure we round up, not down)    nsecs_t currentTime = now();    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);    mLooper-&gt;pollOnce(timeoutMillis);  //进入阻塞等待唤醒或者timeout或者callback回调&#125;</code></pre><h4 id="InputDispatcher-dispatchOnceInnerLocked"><a href="#InputDispatcher-dispatchOnceInnerLocked" class="headerlink" title="InputDispatcher::dispatchOnceInnerLocked"></a>InputDispatcher::dispatchOnceInnerLocked</h4><pre><code>void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123;    nsecs_t currentTime = now();    // Reset the key repeat timer whenever normal dispatch is suspended while the    // device is in a non-interactive state.  This is to ensure that we abort a key    // repeat if the device is just coming out of sleep.    // 如果设备处于不可交互时，则不进行事件的分发    // 如果处于不可分发状态则重置按键重复计时器    if (!mDispatchEnabled) &#123;        resetKeyRepeatLocked();    &#125;    // If dispatching is frozen, do not process timeouts or try to deliver any new events.    // 如果处于frozen状态，则不处理任何有关目标进程是否有简单窗口的timeout行为，也不会进行事件的分发    if (mDispatchFrozen) &#123;        if (DEBUG_FOCUS) &#123;            ALOGD(&quot;Dispatch frozen.  Waiting some more.&quot;);        &#125;        return;    &#125;    // Optimize latency of app switches.    // Essentially we start a short timeout when an app switch key (HOME / ENDCALL) has    // been pressed.  When it expires, we preempt dispatch and drop all other pending events.    // 对APP切换时的优化措施，当按下类似HOME键时，启动一个超时机制(0.5s)，当timeout时，会立即分发事件并抛弃其他的未处理事件    bool isAppSwitchDue = mAppSwitchDueTime &lt;= currentTime;    if (mAppSwitchDueTime &lt; *nextWakeupTime) &#123;        *nextWakeupTime = mAppSwitchDueTime;    &#125;    // Ready to start a new event.    // If we don&#39;t already have a pending event, go grab one.    if (!mPendingEvent) &#123;  //正常一次分发前mPendingEvent = nullptr        if (mInboundQueue.empty()) &#123;            ...        &#125; else &#123;  //因为inputReader已经往Inbound queue中添加了事件，所以不为空            // Inbound queue has at least one entry.            mPendingEvent = mInboundQueue.front(); //拿出一个待分发的事件            mInboundQueue.pop_front(); //从mInboundQueue中移除这个事件            traceInboundQueueLengthLocked();  //systrace、perfetto中可以看到这个队列size发生变化        &#125;        // Poke user activity for this event.        // 每次分发事件时都调PMS的updatePowerStateLocked更新电源的状态        if (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;            pokeUserActivityLocked(*mPendingEvent);        &#125;    &#125;    // Now we have an event to dispatch.    // All events are eventually dequeued and processed this way, even if we intend to drop them.    ALOG_ASSERT(mPendingEvent != nullptr);    bool done = false;    DropReason dropReason = DropReason::NOT_DROPPED;    if (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;  //如果事件不是分发给用户的则抛弃drop        dropReason = DropReason::POLICY;    &#125; else if (!mDispatchEnabled) &#123;  //如果当前属于不可交互的状态则drop        dropReason = DropReason::DISABLED;    &#125;    if (mNextUnblockedEvent == mPendingEvent) &#123;        mNextUnblockedEvent = nullptr;    &#125;    switch (mPendingEvent-&gt;type) &#123;        ...        case EventEntry::Type::KEY: &#123;            ...        &#125;        case EventEntry::Type::MOTION: &#123;            std::shared_ptr&lt;MotionEntry&gt; motionEntry =                    std::static_pointer_cast&lt;MotionEntry&gt;(mPendingEvent);            if (dropReason == DropReason::NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;                dropReason = DropReason::APP_SWITCH;  //处于APP切换情形drop的事件            &#125;            if (dropReason == DropReason::NOT_DROPPED &amp;&amp; isStaleEvent(currentTime, *motionEntry)) &#123;                   //事件超过了一个事件允许分发的最大时间(10s)(事件太老)则drop这个事件                   //时间计算：currentTime - entry.eventTime                dropReason = DropReason::STALE;            &#125;            if (dropReason == DropReason::NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;                //当焦点将要移到到新的应用上，则抛弃期间的事件                dropReason = DropReason::BLOCKED;            &#125;            //事件的分发（无论这个事件要分发还是要drop都要走这里）            done = dispatchMotionLocked(currentTime, motionEntry, &amp;dropReason, nextWakeupTime);            break;        &#125;        ...    &#125;    if (done) &#123;        if (dropReason != DropReason::NOT_DROPPED) &#123;            dropInboundEventLocked(*mPendingEvent, dropReason);        &#125;        mLastDropReason = dropReason;        releasePendingEventLocked();  //将mPendingEvent设置为nullptr，重置为下一个事件分发准备        //  强制下一个poll中立即唤醒inputDispatcher线程来干活        *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately    &#125;&#125;</code></pre><h4 id="InputDispatcher-dispatchMotionLocked"><a href="#InputDispatcher-dispatchMotionLocked" class="headerlink" title="InputDispatcher::dispatchMotionLocked"></a>InputDispatcher::dispatchMotionLocked</h4><pre><code>bool InputDispatcher::dispatchMotionLocked(nsecs_t currentTime, std::shared_ptr&lt;MotionEntry&gt; entry,                                           DropReason* dropReason, nsecs_t* nextWakeupTime) &#123;    ATRACE_CALL();    // Preprocessing.    //将当前事件的dispatchInProgress设置为true表示处理中    if (!entry-&gt;dispatchInProgress) &#123;        entry-&gt;dispatchInProgress = true;        logOutboundMotionDetails(&quot;dispatchMotion - &quot;, *entry);    &#125;    // Clean up if dropping the event.    //如果事件需要抛弃    if (*dropReason != DropReason::NOT_DROPPED) &#123;        setInjectionResult(*entry,                           *dropReason == DropReason::POLICY ? InputEventInjectionResult::SUCCEEDED                                                             : InputEventInjectionResult::FAILED);        return true;    &#125;    //从entry-&gt;source判断事件的源类型    const bool isPointerEvent = isFromSource(entry-&gt;source, AINPUT_SOURCE_CLASS_POINTER);    // Identify targets.    std::vector&lt;InputTarget&gt; inputTargets;    bool conflictingPointerActions = false;    InputEventInjectionResult injectionResult;    if (isPointerEvent) &#123;  //触屏这这里        // Pointer event.  (eg. touchscreen)        //重要的方法，获取当前焦点窗口，后续单独展开分析这个，这里就展开        //获取到的焦点窗口为inputTargets        injectionResult =                findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime,                                               &amp;conflictingPointerActions);    &#125; else &#123;        ...    &#125;    ...    setInjectionResult(*entry, injectionResult);    ...    // Add monitor channels from event&#39;s or focused display.    //将全局的监视器窗口加入分发的目标窗口列表中（举个例子：开发者选项中的显示触摸轨迹图层就一个全局监视器）    //只要事件在前面没有被抛弃，那么无论后面的流程是否拦截事件，这些全局监视器都能收到事件    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));    // Dispatch the motion.    ...    dispatchEventLocked(currentTime, entry, inputTargets);  //往目标窗口分发事件    return true;  //return true就可以进行下一次从iq中读取新事件并分发&#125;</code></pre><h4 id="InputDispatcher-dispatchEventLocked"><a href="#InputDispatcher-dispatchEventLocked" class="headerlink" title="InputDispatcher::dispatchEventLocked"></a>InputDispatcher::dispatchEventLocked</h4><pre><code>void InputDispatcher::dispatchEventLocked(nsecs_t currentTime,                                          std::shared_ptr&lt;EventEntry&gt; eventEntry,                                          const std::vector&lt;InputTarget&gt;&amp; inputTargets) &#123;    ATRACE_CALL();    updateInteractionTokensLocked(*eventEntry, inputTargets);    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); // should already have been set to true    pokeUserActivityLocked(*eventEntry);  //再次更新电源状态，避免进入息屏等行为    //遍历所有找到的目标窗口inputTargets，通过他们的向他们inputChannel分发当前的事件    for (const InputTarget&amp; inputTarget : inputTargets) &#123;        sp&lt;Connection&gt; connection =                getConnectionLocked(inputTarget.inputChannel-&gt;getConnectionToken());        if (connection != nullptr) &#123;            prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget);        &#125; else &#123;            if (DEBUG_FOCUS) &#123;                ALOGD(&quot;Dropping event delivery to target with channel &#39;%s&#39; because it &quot;                      &quot;is no longer registered with the input dispatcher.&quot;,                      inputTarget.inputChannel-&gt;getName().c_str());            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="InputDispatcher-prepareDispatchCycleLocked"><a href="#InputDispatcher-prepareDispatchCycleLocked" class="headerlink" title="InputDispatcher::prepareDispatchCycleLocked"></a>InputDispatcher::prepareDispatchCycleLocked</h4><pre><code>void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,                                                 const sp&lt;Connection&gt;&amp; connection,                                                 std::shared_ptr&lt;EventEntry&gt; eventEntry,                                                 const InputTarget&amp; inputTarget) &#123;    ...    // Skip this event if the connection status is not normal.    // We don&#39;t want to enqueue additional outbound events if the connection is broken.    // 如果目标窗口的连接状态不正常，比如进程已经死了，那么就不向它分发了    if (connection-&gt;status != Connection::Status::NORMAL) &#123;        return;    &#125;    // Split a motion event if needed.    // 如果当前系统处于分屏的状态，就需要考虑分离触摸的情形，检查目标窗口是否设置分离触摸标志    if (inputTarget.flags &amp; InputTarget::FLAG_SPLIT) &#123;        const MotionEntry&amp; originalMotionEntry = static_cast&lt;const MotionEntry&amp;&gt;(*eventEntry);        if (inputTarget.pointerIds.count() != originalMotionEntry.pointerCount) &#123;            std::unique_ptr&lt;MotionEntry&gt; splitMotionEntry =                    splitMotionEvent(originalMotionEntry, inputTarget.pointerIds);            if (!splitMotionEntry) &#123;                return; // split event was dropped            &#125;            if (splitMotionEntry-&gt;action == AMOTION_EVENT_ACTION_CANCEL) &#123;                std::string reason = std::string(&quot;reason=pointer cancel on split window&quot;);                android_log_event_list(LOGTAG_INPUT_CANCEL)                        &lt;&lt; connection-&gt;getInputChannelName().c_str() &lt;&lt; reason &lt;&lt; LOG_ID_EVENTS;            &#125;            enqueueDispatchEntriesLocked(currentTime, connection, std::move(splitMotionEntry),                                         inputTarget);            return;        &#125;    &#125;    // Not splitting.  Enqueue dispatch entries for the event as is.    //一般走这里，继续事件的分发，将事件加入目标窗口的即将分发的队列中    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);&#125;</code></pre><h4 id="InputDispatcher-enqueueDispatchEntriesLocked"><a href="#InputDispatcher-enqueueDispatchEntriesLocked" class="headerlink" title="InputDispatcher::enqueueDispatchEntriesLocked"></a>InputDispatcher::enqueueDispatchEntriesLocked</h4><pre><code>void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime,                                                   const sp&lt;Connection&gt;&amp; connection,                                                   std::shared_ptr&lt;EventEntry&gt; eventEntry,                                                   const InputTarget&amp; inputTarget) &#123;    bool wasEmpty = connection-&gt;outboundQueue.empty();    // Enqueue dispatch entries for the requested modes.    // 将事件加入分发队列outboundQueue，这里有些复杂    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,                               InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);  //2048    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,                               InputTarget::FLAG_DISPATCH_AS_OUTSIDE);  //512    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,                               InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);  //1024    //FLAG_DISPATCH_AS_IS表示事件按原样分发，不改变事件的分发模式，一般都是走这里，其他的是特殊情形    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,                               InputTarget::FLAG_DISPATCH_AS_IS);  //256      enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,                               InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);  //4096    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,                               InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);  //8192    // If the outbound queue was previously empty, start the dispatch cycle going.    if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.empty()) &#123;        startDispatchCycleLocked(currentTime, connection);  //outboundQueue中已经有事件，可以分发    &#125;&#125;</code></pre><h4 id="InputDispatcher-enqueueDispatchEntryLocked"><a href="#InputDispatcher-enqueueDispatchEntryLocked" class="headerlink" title="InputDispatcher::enqueueDispatchEntryLocked"></a>InputDispatcher::enqueueDispatchEntryLocked</h4><pre><code>void InputDispatcher::enqueueDispatchEntryLocked(const sp&lt;Connection&gt;&amp; connection,                                                 std::shared_ptr&lt;EventEntry&gt; eventEntry,                                                 const InputTarget&amp; inputTarget,                                                 int32_t dispatchMode) &#123;                                                     int32_t inputTargetFlags = inputTarget.flags;    //这里很关键，enqueueDispatchEntryLocked从上面来看，貌似会调五次，但是    // 这里有限制条件，根据inputTargetFlags是否等于本次传入的dispatchMode，不同则return    // 所以是否入队还是由inputTargetFlags决定，正常事件都是inputTargetFlags = FLAG_DISPATCH_AS_IS    // 所以一般只有dispatchMode = FLAG_DISPATCH_AS_IS时才会往下执行    if (!(inputTargetFlags &amp; dispatchMode)) &#123;        return;    &#125;    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;    // This is a new event.    // Enqueue a new dispatch entry onto the outbound queue for this connection.    // 创建DispatchEntry，DispatchEntry是对EventEntry的包装，加入分发的一些跟踪状态属性值    // 关联eventEntry，inputTarget，inputTarget，    std::unique_ptr&lt;DispatchEntry&gt; dispatchEntry =            createDispatchEntry(inputTarget, eventEntry, inputTarget);    // Use the eventEntry from dispatchEntry since the entry may have changed and can now be a    // different EventEntry than what was passed in.    EventEntry&amp; newEntry = *(dispatchEntry-&gt;eventEntry);    // Apply target flags and update the connection&#39;s input state.    switch (newEntry.type) &#123;        case EventEntry::Type::KEY: &#123;            ...            break;        &#125;        case EventEntry::Type::MOTION: &#123;            const MotionEntry&amp; motionEntry = static_cast&lt;const MotionEntry&amp;&gt;(newEntry);            // Assign a default value to dispatchEntry that will never be generated by InputReader,            // and assign a InputDispatcher value if it doesn&#39;t change in the if-else chain below.            constexpr int32_t DEFAULT_RESOLVED_EVENT_ID =                    static_cast&lt;int32_t&gt;(IdGenerator::Source::OTHER);            dispatchEntry-&gt;resolvedEventId = DEFAULT_RESOLVED_EVENT_ID;                        if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_OUTSIDE) &#123;                dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;            &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) &#123;                dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;            &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) &#123;                dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;            &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) &#123;                dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_CANCEL;            &#125; else if (dispatchMode &amp; InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) &#123;                dispatchEntry-&gt;resolvedAction = AMOTION_EVENT_ACTION_DOWN;            &#125; else &#123;  //由上面可知dispatchMode = FLAG_DISPATCH_AS_IS所以走else，保留事件原本的action和id                dispatchEntry-&gt;resolvedAction = motionEntry.action;                dispatchEntry-&gt;resolvedEventId = motionEntry.id;            &#125;                        if (dispatchEntry-&gt;resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE &amp;&amp;                ...            &#125;            dispatchEntry-&gt;resolvedFlags = motionEntry.flags;            //判断当前目标窗口是否被其他可见窗口遮挡的情况并设置到dispatchEntry-&gt;resolvedFlags, 全遮挡还是部分遮挡            if (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_OBSCURED) &#123;                dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;            &#125;            if (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) &#123;                dispatchEntry-&gt;resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;            &#125;            ...            // 从上面可知，当dispatchMode = FLAG_DISPATCH_AS_IS时            // 事件的resolvedEventId仍然保留原有motionEntry.id            dispatchEntry-&gt;resolvedEventId =                    dispatchEntry-&gt;resolvedEventId == DEFAULT_RESOLVED_EVENT_ID                    ? mIdGenerator.nextId()                    : motionEntry.id;            if ((motionEntry.flags &amp; AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE) &amp;&amp;                (motionEntry.policyFlags &amp; POLICY_FLAG_TRUSTED)) &#123;                // Skip reporting pointer down outside focus to the policy.                break;            &#125;            //处理分发事件目标窗口不是当前焦点窗口的情况            dispatchPointerDownOutsideFocus(motionEntry.source, dispatchEntry-&gt;resolvedAction,                                            inputTarget.inputChannel-&gt;getConnectionToken());            break;        &#125;        ...    &#125;    // Remember that we are waiting for this dispatch to complete.    if (dispatchEntry-&gt;hasForegroundTarget()) &#123;        incrementPendingForegroundDispatches(newEntry);    &#125;    // Enqueue the dispatch entry.    // 将dispatchEntry加入当前目标窗口的outboundQueue    connection-&gt;outboundQueue.push_back(dispatchEntry.release());    traceOutboundQueueLength(*connection);  //systrace可以看到outboundQueue的size发生改变&#125;</code></pre><h4 id="InputDispatcher-startDispatchCycleLocked"><a href="#InputDispatcher-startDispatchCycleLocked" class="headerlink" title="InputDispatcher::startDispatchCycleLocked"></a>InputDispatcher::startDispatchCycleLocked</h4><pre><code>void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,                                               const sp&lt;Connection&gt;&amp; connection) &#123;    //循环从outboundQueue中取出事件通过目标窗口的inputchannel向目标窗口分发    while (connection-&gt;status == Connection::Status::NORMAL &amp;&amp; !connection-&gt;outboundQueue.empty()) &#123;        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.front();  //取出DispatchEntry        dispatchEntry-&gt;deliveryTime = currentTime;  //记录分发事件        const std::chrono::nanoseconds timeout = getDispatchingTimeoutLocked(connection);         //事件处理的超时时间点 = currentTime + 5s  超时会引发ANR        dispatchEntry-&gt;timeoutTime = currentTime + timeout.count();        // Publish the event.        status_t status;        const EventEntry&amp; eventEntry = *(dispatchEntry-&gt;eventEntry);  //获取EventEntry        switch (eventEntry.type) &#123;            case EventEntry::Type::KEY: &#123;                ...            &#125;            case EventEntry::Type::MOTION: &#123;                const MotionEntry&amp; motionEntry = static_cast&lt;const MotionEntry&amp;&gt;(eventEntry);  //转化为触摸对应MotionEntry                PointerCoords scaledCoords[MAX_POINTERS];                const PointerCoords* usingCoords = motionEntry.pointerCoords;                // Set the X and Y offset and X and Y scale depending on the input source.                //根据输入源设置 X 和 Y 偏移以及 X 和 Y 比例。                if ((motionEntry.source &amp; AINPUT_SOURCE_CLASS_POINTER) &amp;&amp;                    !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;  //模拟器走这里                    float globalScaleFactor = dispatchEntry-&gt;globalScaleFactor;                    if (globalScaleFactor != 1.0f) &#123;                        for (uint32_t i = 0; i &lt; motionEntry.pointerCount; i++) &#123;                            scaledCoords[i] = motionEntry.pointerCoords[i];                            // Don&#39;t apply window scale here since we don&#39;t want scale to affect raw                            // coordinates. The scale will be sent back to the client and applied                            // later when requesting relative coordinates.                            //如果当前窗口的全局坐标比例不是1.0f,那么这里先把每个pointer的比例设置为1.0f                            scaledCoords[i].scale(globalScaleFactor, 1 /* windowXScale */,                                                  1 /* windowYScale */);                        &#125;                        usingCoords = scaledCoords;                    &#125;                &#125; else &#123;                    ...                &#125;                std::array&lt;uint8_t, 32&gt; hmac = getSignature(motionEntry, *dispatchEntry);                // Publish the motion event.                // 向目标窗口分发触摸事件                status = connection-&gt;inputPublisher                                 .publishMotionEvent(dispatchEntry-&gt;seq,                                                     dispatchEntry-&gt;resolvedEventId,                                                     motionEntry.deviceId, motionEntry.source,                                                     motionEntry.displayId, std::move(hmac),                                                     dispatchEntry-&gt;resolvedAction,                                                     motionEntry.actionButton,                                                     dispatchEntry-&gt;resolvedFlags,                                                     motionEntry.edgeFlags, motionEntry.metaState,                                                     motionEntry.buttonState,                                                     motionEntry.classification,                                                     dispatchEntry-&gt;transform,                                                     motionEntry.xPrecision, motionEntry.yPrecision,                                                     motionEntry.xCursorPosition,                                                     motionEntry.yCursorPosition,                                                     dispatchEntry-&gt;rawTransform,                                                     motionEntry.downTime, motionEntry.eventTime,                                                     motionEntry.pointerCount,                                                     motionEntry.pointerProperties, usingCoords);                break;            &#125;            ...        &#125;        // Check the result.        // 检测分发的结果，正常时status = 0        if (status) &#123;            if (status == WOULD_BLOCK) &#123;                if (connection-&gt;waitQueue.empty()) &#123;                    // 当前waitQueue是空的，说明socket中也应该是空的，但是却是WOULD_BLOCK，说明这时一个异常的情况，中断分发                    abortBrokenDispatchCycleLocked(currentTime, connection, true /*notify*/);                &#125; else &#123;                    // Pipe is full and we are waiting for the app to finish process some events                    // before sending more events to it.                    // socket满了，等待应用进程处理掉一些事件                &#125;            &#125; else &#123;                //其他异常的情况                abortBrokenDispatchCycleLocked(currentTime, connection, true /*notify*/);            &#125;            return;        &#125;        // Re-enqueue the event on the wait queue.        // 将已经分发的事件dispatchEntry从outboundQueue中移除        connection-&gt;outboundQueue.erase(std::remove(connection-&gt;outboundQueue.begin(),                                                    connection-&gt;outboundQueue.end(),                                                    dispatchEntry));        traceOutboundQueueLength(*connection); //systrace中跟踪outboundQueue的长度                // 将已经分发的事件dispatchEntry加入目标窗口waitQueue中，记录下已经分发到目标窗口侧的事件，便于监控ANR等行为        connection-&gt;waitQueue.push_back(dispatchEntry);      //如果目标窗口进程（例如应用进程）可响应，则将这个事件超时事件点和目标窗口连接对象token加入mAnrTracker中监控      //如果不可响应，则不再向它分发更多的事件，直到它消耗了已经分发给它的事件        if (connection-&gt;responsive) &#123;            mAnrTracker.insert(dispatchEntry-&gt;timeoutTime,                               connection-&gt;inputChannel-&gt;getConnectionToken());        &#125;        traceWaitQueueLength(*connection); //systrace中跟踪waitQueue的长度    &#125;&#125;</code></pre><h4 id="InputPublisher-publishMotionEvent"><a href="#InputPublisher-publishMotionEvent" class="headerlink" title="InputPublisher::publishMotionEvent"></a>InputPublisher::publishMotionEvent</h4><p>frameworks&#x2F;native&#x2F;libs&#x2F;input&#x2F;InputTransport.cpp</p><pre><code>status_t InputPublisher::publishMotionEvent(        uint32_t seq, int32_t eventId, int32_t deviceId, int32_t source, int32_t displayId,        std::array&lt;uint8_t, 32&gt; hmac, int32_t action, int32_t actionButton, int32_t flags,        int32_t edgeFlags, int32_t metaState, int32_t buttonState,        MotionClassification classification, const ui::Transform&amp; transform, float xPrecision,        float yPrecision, float xCursorPosition, float yCursorPosition,        const ui::Transform&amp; rawTransform, nsecs_t downTime, nsecs_t eventTime,        uint32_t pointerCount, const PointerProperties* pointerProperties,        const PointerCoords* pointerCoords) &#123;    //创建InputMessage，将dispatchEntry转化为InputMessage    InputMessage msg;    msg.header.type = InputMessage::Type::MOTION;    msg.header.seq = seq;    msg.body.motion.eventId = eventId;    msg.body.motion.deviceId = deviceId;    msg.body.motion.source = source;    msg.body.motion.displayId = displayId;    msg.body.motion.hmac = std::move(hmac);    msg.body.motion.action = action;    msg.body.motion.actionButton = actionButton;    msg.body.motion.flags = flags;    msg.body.motion.edgeFlags = edgeFlags;    msg.body.motion.metaState = metaState;    msg.body.motion.buttonState = buttonState;    msg.body.motion.classification = classification;    msg.body.motion.dsdx = transform.dsdx();    msg.body.motion.dtdx = transform.dtdx();    msg.body.motion.dtdy = transform.dtdy();    msg.body.motion.dsdy = transform.dsdy();    msg.body.motion.tx = transform.tx();    msg.body.motion.ty = transform.ty();    msg.body.motion.xPrecision = xPrecision;    msg.body.motion.yPrecision = yPrecision;    msg.body.motion.xCursorPosition = xCursorPosition;    msg.body.motion.yCursorPosition = yCursorPosition;    msg.body.motion.dsdxRaw = rawTransform.dsdx();    msg.body.motion.dtdxRaw = rawTransform.dtdx();    msg.body.motion.dtdyRaw = rawTransform.dtdy();    msg.body.motion.dsdyRaw = rawTransform.dsdy();    msg.body.motion.txRaw = rawTransform.tx();    msg.body.motion.tyRaw = rawTransform.ty();    msg.body.motion.downTime = downTime;    msg.body.motion.eventTime = eventTime;    msg.body.motion.pointerCount = pointerCount;    for (uint32_t i = 0; i &lt; pointerCount; i++) &#123; //多指的情况        msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]);        msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]);    &#125;    return mChannel-&gt;sendMessage(&amp;msg);  //通过socketpair传递到目标窗口所在的进程中&#125;</code></pre><p>到这里InputDispatcher的Native层分发就分析完了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;InputDispatcher-dispatchOnce&quot;&gt;&lt;a href=&quot;#InputDispatcher-dispatchOnce&quot; class=&quot;headerlink&quot; title=&quot;InputDispatcher::dispatchOnce()&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="InPutManagerService" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"/>
    
    
  </entry>
  
  <entry>
    <title>2.EventHub获取事件</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/2.EventHub%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6/</id>
    <published>2023-12-29T06:14:59.074Z</published>
    <updated>2024-01-02T02:59:44.371Z</updated>
    
    <content type="html"><![CDATA[<p> 从前面inputflinger的启动分析中，我们知道事件来源是在<code>EventHub::getEvents</code>, 所以我们重点看下这个方法的流程来了解事件是如何从驱动上报中获取的。</p><h4 id="EventHub-getEvents"><a href="#EventHub-getEvents" class="headerlink" title="EventHub::getEvents"></a>EventHub::getEvents</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;EventHub.cpp</p><pre><code>size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123;    ALOG_ASSERT(bufferSize &gt;= 1);            std::scoped_lock _l(mLock);    //创建一个input_event数组，用于存放从epoll中读取到的input_events    struct input_event readBuffer[bufferSize];    //buffer是inputReader传入的RawEvent数组首地址，数组大小为256，将事件构造成RawEvent并装入后返回给inputReader    //用这里把数组地址赋给event指针，后续使用这个指针操作这个数组    RawEvent* event = buffer; //传入的RawEvent数组首地址    //一次处理事件的最大容量为256个    size_t capacity = bufferSize;    bool awoken = false;    for (;;) &#123;        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);  //获取当前时间戳        //处理有关设备状态变化的逻辑        // Reopen input devices if needed.        if (mNeedToReopenDevices) &#123;            mNeedToReopenDevices = false;            ALOGI(&quot;Reopening all input devices due to a configuration change.&quot;);            closeAllDevicesLocked();            mNeedToScanDevices = true;            break; // return to the caller before we actually rescan        &#125;        // Report any devices that had last been added/removed.        //当调用closeDeviceLocked时，就会把需要关闭的设备加入mClosingDevices，下一次循环到这里时就遍历这个列表处理        for (auto it = mClosingDevices.begin(); it != mClosingDevices.end();) &#123;            //移除一个设备就构建一个DEVICE_REMOVED类型的event并加入RawEvent数组中            std::unique_ptr&lt;Device&gt; device = std::move(*it);            ALOGV(&quot;Reporting device closed: id=%d, name=%s\n&quot;, device-&gt;id, device-&gt;path.c_str());            event-&gt;when = now;            event-&gt;deviceId = (device-&gt;id == mBuiltInKeyboardId)                    ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID                    : device-&gt;id;            event-&gt;type = DEVICE_REMOVED;            event += 1;            it = mClosingDevices.erase(it);  //从mClosingDevices中移除device            mNeedToSendFinishedDeviceScan = true;            if (--capacity == 0) &#123;                break;            &#125;        &#125;        //当EventHub初始化时，mNeedToScanDevices = true， 所以首次进入需要scan输入设备        if (mNeedToScanDevices) &#123;            mNeedToScanDevices = false;            scanDevicesLocked();  //扫描设备&quot;/dev/input&quot;下的设备，例如event1、event2，这个方法很复杂，            mNeedToSendFinishedDeviceScan = true;        &#125;        //上一步进行了scan device的操作，现在mOpeningDevices是记录着获取到的Device        while (!mOpeningDevices.empty()) &#123;            //遍历取出mOpeningDevices中Device，构建RawEvent-&gt;DEVICE_ADDED事件，写入event缓冲区中            std::unique_ptr&lt;Device&gt; device = std::move(*mOpeningDevices.rbegin());            mOpeningDevices.pop_back();//把这个device对象从移除mOpeningDevices中            ALOGV(&quot;Reporting device opened: id=%d, name=%s\n&quot;, device-&gt;id, device-&gt;path.c_str());            //构建一个RawEvent时间，type = DEVICE_ADDED            event-&gt;when = now;            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id;            event-&gt;type = DEVICE_ADDED;            event += 1; //RawEvent对象偏移 + 1（RawEvent数组中RawEvent数量）                    ...            //从已经处理的设备中mOpeningDevices中的device加入mDevices Map中，以device-&gt;id标记            auto [dev_it, inserted] = mDevices.insert_or_assign(device-&gt;id, std::move(device));            mNeedToSendFinishedDeviceScan = true;  //标记扫描完成，可以退出扫描状态（退出也要发退出事件）            //如果RawEvent数组装满了，就跳出循环往下执行（需要等数组中数据分发释放后进入这里再处理）            if (--capacity == 0) &#123;                  break;            &#125;        &#125;        //如果扫描结束需要发一个mNeedToSendFinishedDeviceScan事件，将这个事件构造并写入event（RawEvent）数组中        if (mNeedToSendFinishedDeviceScan) &#123;            mNeedToSendFinishedDeviceScan = false;            event-&gt;when = now;            event-&gt;type = FINISHED_DEVICE_SCAN;            event += 1;  //RawEvent对象偏移 + 1（RawEvent数组中RawEvent数量）            if (--capacity == 0) &#123;                break;            &#125;        &#125;        // Grab the next input event.        //从epoll中下一个输入事件        bool deviceChanged = false;  //这个变量标记当前设备是否有变化（拔插、配置改变等）        //mPendingEventCount指epoll中返回的事件（在epoll event数组中）的数量        //mPendingEventIndex指要处理的epoll事件在epoll返回列表中的下标        //循环处理epoll返回列表中的epoll事件        while (mPendingEventIndex &lt; mPendingEventCount) &#123;            const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++];            if (eventItem.data.fd == mINotifyFd) &#123;                if (eventItem.events &amp; EPOLLIN) &#123;                    mPendingINotify = true;                &#125; else &#123;                    ALOGW(&quot;Received unexpected epoll event 0x%08x for INotify.&quot;, eventItem.events);                &#125;                continue;            &#125;            if (eventItem.data.fd == mWakeReadPipeFd) &#123;                if (eventItem.events &amp; EPOLLIN) &#123;                    ALOGV(&quot;awoken after wake()&quot;);                    awoken = true;                    char wakeReadBuffer[16];                    ssize_t nRead;                    do &#123;                        nRead = read(mWakeReadPipeFd, wakeReadBuffer, sizeof(wakeReadBuffer));                    &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(wakeReadBuffer));                &#125; else &#123;                    ALOGW(&quot;Received unexpected epoll event 0x%08x for wake read pipe.&quot;,                          eventItem.events);                &#125;                continue;            &#125;            //如果非mINotifyFd和非mWakeReadPipeFd，则是底层输入驱动上报的输入事件，那么通过fd获取这个事件对应的Device            Device* device = getDeviceByFdLocked(eventItem.data.fd);                         ...            // This must be an input event            //如果是个epoll读事件            if (eventItem.events &amp; EPOLLIN) &#123;                //通过read方法获取读缓冲区大小和数据。写入readBuffer，读取size为256个input_event                int32_t readSize =                        read(device-&gt;fd, readBuffer, sizeof(struct input_event) * capacity);                                        if (readSize == 0 || (readSize &lt; 0 &amp;&amp; errno == ENODEV)) &#123;                    // Device was removed before INotify noticed.                    //如果读取的size &lt;= 0 且返回异常可能是设备已经被移除了，只是INotify还没通知，                    //那么就标记这个设备状态改变，并移除这个设备                    deviceChanged = true;  //标记这个设备状态改变                    closeDeviceLocked(*device);  //移除这个设备                &#125; else if (readSize &lt; 0) &#123;                    ...                &#125; else if ((readSize % sizeof(struct input_event)) != 0) &#123;                    ...                &#125; else &#123; //正常读到数据了                    //(特殊)如果读到的device是内置键盘，name就设置它的device-&gt;id = 0                    int32_t deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id;                    //计算这次读到的epoll读事件中的readBuffer中包含的input_event数量                    size_t count = size_t(readSize) / sizeof(struct input_event);                    //从readBuffer循环取出读到的的input_event对象                    //构造RawEvent对象写入RawEvent数组中，指针依次往后偏移                    for (size_t i = 0; i &lt; count; i++) &#123;                        struct input_event&amp; iev = readBuffer[i];                        event-&gt;when = processEventTimestamp(iev);                        event-&gt;readTime = systemTime(SYSTEM_TIME_MONOTONIC);                        event-&gt;deviceId = deviceId;                        event-&gt;type = iev.type;                        event-&gt;code = iev.code;                        event-&gt;value = iev.value;                        event += 1;                        capacity -= 1;                    &#125;                    //如果写满了RawEvent数组                    if (capacity == 0) &#123;                        // The result buffer is full.  Reset the pending event index                        // so we will try to read the device again on the next iteration.                        // 如果RawEvent数组写满了，就把mPendingEventIndex - 1，(因为下次循环开始会加一，提前减一这样处理的就还是当前这个epoll事件)                        // 说明我们本次epoll读事件我们没有处理完，下一个循环还要继续处理这个epoll事件                        mPendingEventIndex -= 1;                        break;                    &#125;                &#125;            &#125; else if (eventItem.events &amp; EPOLLHUP) &#123;  //如果是hang-up事件说明设备拔出，就移除这个设备，通知设备状态变化                ALOGI(&quot;Removing device %s due to epoll hang-up event.&quot;,                      device-&gt;identifier.name.c_str());                deviceChanged = true;                closeDeviceLocked(*device);            &#125; else &#123;  //收到异常的epoll事件，不处理                ALOGW(&quot;Received unexpected epoll event 0x%08x for device %s.&quot;, eventItem.events,                      device-&gt;identifier.name.c_str());            &#125;        &#125;        // readNotify() will modify the list of devices so this must be done after        // processing all other events to ensure that we read all remaining events        // before closing the devices.        //当处理完一次一次epoll_wait返回列表中所有epoll事件后，检测下是否有底层设备变化（mPendingINotify = true）        //如果有就通知设备状态改变        if (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;            mPendingINotify = false;            readNotifyLocked();  //通过read去读取INotify fd返回的事件，判断设备状态，是需要重新获取设备还是移除设备            deviceChanged = true;  //标记设备状态改变，        &#125;        // Report added or removed devices immediately.        // 如果有设备状态改变（新增或者移除）需要马上到下一个循环处理        if (deviceChanged) &#123;            continue;        &#125;        // Return now if we have collected any events or if we were explicitly awoken.        //1.如果其他地方调用了`mEventHub-&gt;wake()`则会唤醒阻塞在epoll_wait()中的inputReader线程，下一次循环时然后从这里跳出getEvents方法，往下执行loopOnce，处理输入事件        //2. 或者RawEvent数组中有数据则跳出getEvents方法，往下执行loopOnce，处理输入事件        if (event != buffer || awoken) &#123;            break;        &#125;        //如果RawEvent数组为空且没有inputReader线程没有被外部唤醒，则下面就准备开始获取下一次epoll事件(进入阻塞等待)        mPendingEventIndex = 0; //准备进入下一次事件接收前，重置mPendingEventIndex下标        mLock.unlock(); // release lock before poll        //进入epoll_wait阻塞等待驱动上报事件        int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);        //从epoll_wait中唤醒        //也许是外部调用mEventHub-&gt;wake()唤醒        //或者内核通知事件上报唤醒        //或者是超时退出休眠                mLock.lock(); // reacquire lock after poll        if (pollResult == 0) &#123;            // Timed out.            // 超时退出的情况            mPendingEventCount = 0;            break;        &#125;        if (pollResult &lt; 0) &#123;            // An error occurred.            mPendingEventCount = 0;            // Sleep after errors to avoid locking up the system.            // Hopefully the error is transient.            if (errno != EINTR) &#123;                ALOGW(&quot;poll failed (errno=%d)\n&quot;, errno);                usleep(100000);            &#125;        &#125; else &#123;            // Some events occurred.            // 获取到epoll事件，将事件数量赋给mPendingEventCount            mPendingEventCount = size_t(pollResult);        &#125;    &#125;    // All done, return the number of events we read.    // 处理结束，退出循环将事件返回到inputReader的loopOnce中处理    return event - buffer;&#125;</code></pre><h4 id="EventHub-scanDevicesLocked"><a href="#EventHub-scanDevicesLocked" class="headerlink" title="EventHub::scanDevicesLocked()"></a>EventHub::scanDevicesLocked()</h4><pre><code>void EventHub::scanDevicesLocked() &#123;    status_t result;    std::error_code errorCode;                if (std::filesystem::exists(DEVICE_INPUT_PATH, errorCode)) &#123;        result = scanDirLocked(DEVICE_INPUT_PATH);            &#125; else &#123;        ...    &#125;    ...&#125;status_t EventHub::scanDirLocked(const std::string&amp; dirname) &#123;    //遍历 /dev/input/event* 路径，打开这些设备并获取相关设备信息    for (const auto&amp; entry : std::filesystem::directory_iterator(dirname)) &#123;        openDeviceLocked(entry.path());    &#125;    return 0;&#125;</code></pre><h4 id="EventHub-openDeviceLocked"><a href="#EventHub-openDeviceLocked" class="headerlink" title="EventHub::openDeviceLocked"></a>EventHub::openDeviceLocked</h4><p>这个方法很长，主要作用就是打开<code>/dev/input/eventX</code>设备节点，用返回的fd通过<code>ioctl</code>向驱动获取输入设备<code>device</code>相关信息。</p><pre><code>void EventHub::openDeviceLocked(const std::string&amp; devicePath) &#123;    //如果目标路径是当前已存在的设备（之前扫描过的设备）的，就不再扫描这个路径了，避免出现重复设备    for (const auto&amp; [deviceId, device] : mDevices) &#123;        if (device-&gt;path == devicePath) &#123;            return; // device was already registered        &#125;    &#125;    char buffer[80];    ALOGV(&quot;Opening device: %s&quot;, devicePath.c_str());    //通过open打开设备节点，返回该设备节点的fd    int fd = open(devicePath.c_str(), O_RDWR | O_CLOEXEC | O_NONBLOCK);                InputDeviceIdentifier identifier;  //一个硬件设备的结构体在用户空间中描述, 包括name、vendor、product、descriptor等    // Get device name.    //获取设备 device name    if (ioctl(fd, EVIOCGNAME(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;        ALOGE(&quot;Could not get device name for %s: %s&quot;, devicePath.c_str(), strerror(errno));    &#125; else &#123;        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;        identifier.name = buffer;    &#125;    // Check to see if the device is on our excluded list    //通过device name检测下这个设备是不是在排除名单，如果是就忽略这个设备    for (size_t i = 0; i &lt; mExcludedDevices.size(); i++) &#123;        const std::string&amp; item = mExcludedDevices[i];        if (identifier.name == item) &#123;            ALOGI(&quot;ignoring event id %s driver %s\n&quot;, devicePath.c_str(), item.c_str());            close(fd);            return;        &#125;    &#125;    // Get device driver version.    //获取设备驱动版本    int driverVersion;    if (ioctl(fd, EVIOCGVERSION, &amp;driverVersion)) &#123;    &#125;    // Get device identifier.    //获取设备的identifier，是设备在内核空间的描述    //内核描述为input_id结构体，内容为：bustype、product、product、version    struct input_id inputId;    if (ioctl(fd, EVIOCGID, &amp;inputId)) &#123;    &#125;    identifier.bus = inputId.bustype;    identifier.product = inputId.product;    identifier.vendor = inputId.product;    identifier.version = inputId.version;    // Get device physical location.    //获取设备的物理位置（物理拓扑中的位置）    if (ioctl(fd, EVIOCGPHYS(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;        // fprintf(stderr, &quot;could not get location for %s, %s\n&quot;, devicePath, strerror(errno));    &#125; else &#123;        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;        identifier.location = buffer;    &#125;    // Get device unique id.    //获取设备的unique id（一般的设备这个字段都是没有的，为空）    if (ioctl(fd, EVIOCGUNIQ(sizeof(buffer) - 1), &amp;buffer) &lt; 1) &#123;        // fprintf(stderr, &quot;could not get idstring for %s, %s\n&quot;, devicePath, strerror(errno));    &#125; else &#123;        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;        identifier.uniqueId = buffer;    &#125;    // Fill in the descriptor.    // 获取设备的descriptor，这个字段很重要，它是用于标识这个设备的标识符，无论重启、拔插、升级都不会变    //根据unique_id、vendor_id、product_id、随机数组合后sha1转化生成，赋值给identifier.descriptor    assignDescriptorLocked(identifier);    // Allocate device.  (The device object takes ownership of the fd at this point.)    //创建Device结构体，用于描述当前从驱动获取到的这个输入设备，将前面获取的设备fd、设备节点路径devicePath、设备硬件描述identifier赋给这个Device,    //同时还有deviceId，这个id并不是驱动传上来的，而是我们每次通过ioctl获取到新设备时计数 + 1    int32_t deviceId = mNextDeviceId++;    std::unique_ptr&lt;Device&gt; device = std::make_unique&lt;Device&gt;(fd, deviceId, devicePath, identifier);    //我们可以通过这个打印或者dumpsys input获取设备的信息    ALOGV(&quot;add device %d: %s\n&quot;, deviceId, devicePath.c_str());    ALOGV(&quot;  bus:        %04x\n&quot;          &quot;  vendor      %04x\n&quot;          &quot;  product     %04x\n&quot;          &quot;  version     %04x\n&quot;,          identifier.bus, identifier.vendor, identifier.product, identifier.version);    ALOGV(&quot;  name:       \&quot;%s\&quot;\n&quot;, identifier.name.c_str());    ALOGV(&quot;  location:   \&quot;%s\&quot;\n&quot;, identifier.location.c_str());    ALOGV(&quot;  unique id:  \&quot;%s\&quot;\n&quot;, identifier.uniqueId.c_str());    ALOGV(&quot;  descriptor: \&quot;%s\&quot;\n&quot;, identifier.descriptor.c_str());    ALOGV(&quot;  driver:     v%d.%d.%d\n&quot;, driverVersion &gt;&gt; 16, (driverVersion &gt;&gt; 8) &amp; 0xff,          driverVersion &amp; 0xff);    // Load the configuration file for the device.    //为当前获取到的设备加载`.idc`配置文件，格式一般是：/vendor/usr/idc/Vendor_XXXX_Product_XXXX_Version_XXXX.idc    //通过product/vendor/version来检索主要路径下符合条件的`idc`文件    //解析该文件后保存在device对象的configuration变量中    device-&gt;loadConfigurationLocked();    // 针对带电池，有LED灯的输入设备，需要设备associatedDevice来关联它的额外能力    bool hasBattery = false;    bool hasLights = false;    // Check the sysfs root path    std::optional&lt;std::filesystem::path&gt; sysfsRootPath = getSysfsRootPath(devicePath.c_str());    if (sysfsRootPath.has_value()) &#123;        std::shared_ptr&lt;AssociatedDevice&gt; associatedDevice;        for (const auto&amp; [id, dev] : mDevices) &#123;            if (device-&gt;identifier.descriptor == dev-&gt;identifier.descriptor &amp;&amp;                !dev-&gt;associatedDevice) &#123;                associatedDevice = dev-&gt;associatedDevice;            &#125;        &#125;        if (!associatedDevice) &#123;            associatedDevice = std::make_shared&lt;AssociatedDevice&gt;(sysfsRootPath.value());        &#125;        hasBattery = associatedDevice-&gt;configureBatteryLocked();        hasLights = associatedDevice-&gt;configureLightsLocked();        device-&gt;associatedDevice = associatedDevice;    &#125;    //向ioctl驱动查询这个设备会上报那种类型的事件，每个类型都问一下支不支持，有点...    //设备会上报哪一种事件，对应的XXBitmask就会有对应的值，用于判断它是什么类型的设备    // Figure out the kinds of events the device reports.    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_KEY, 0), device-&gt;keyBitmask);    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_ABS, 0), device-&gt;absBitmask);    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_REL, 0), device-&gt;relBitmask);    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_SW, 0), device-&gt;swBitmask);    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_LED, 0), device-&gt;ledBitmask);    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_FF, 0), device-&gt;ffBitmask);    device-&gt;readDeviceBitMask(EVIOCGBIT(EV_MSC, 0), device-&gt;mscBitmask);    device-&gt;readDeviceBitMask(EVIOCGPROP(0), device-&gt;propBitmask);    // See if this is a keyboard.  Ignore everything in the button range except for    // joystick and gamepad buttons which are handled like keyboards for the most part.    // 判断是否是键盘、游戏手柄等    bool haveKeyboardKeys =            device-&gt;keyBitmask.any(0, BTN_MISC) || device-&gt;keyBitmask.any(BTN_WHEEL, KEY_MAX + 1);    bool haveGamepadButtons = device-&gt;keyBitmask.any(BTN_MISC, BTN_MOUSE) ||            device-&gt;keyBitmask.any(BTN_JOYSTICK, BTN_DIGI);    if (haveKeyboardKeys || haveGamepadButtons) &#123;        device-&gt;classes |= InputDeviceClass::KEYBOARD;    &#125;    // See if this is a cursor device such as a trackball or mouse.    //判断设备是不是鼠标或者轨迹球类型    if (device-&gt;keyBitmask.test(BTN_MOUSE) &amp;&amp; device-&gt;relBitmask.test(REL_X) &amp;&amp;        device-&gt;relBitmask.test(REL_Y)) &#123;        device-&gt;classes |= InputDeviceClass::CURSOR;    &#125;    // See if this is a rotary encoder type device.    //判断设备是不是旋转编码器类型（旋钮）    String8 deviceType = String8();    if (device-&gt;configuration &amp;&amp;        device-&gt;configuration-&gt;tryGetProperty(String8(&quot;device.type&quot;), deviceType)) &#123;        if (!deviceType.compare(String8(&quot;rotaryEncoder&quot;))) &#123;            device-&gt;classes |= InputDeviceClass::ROTARY_ENCODER;        &#125;    &#125;    // See if this is a touch pad.    // Is this a new modern multi-touch driver?    //是不是触摸板，支不支持多点触摸    if (device-&gt;absBitmask.test(ABS_MT_POSITION_X) &amp;&amp; device-&gt;absBitmask.test(ABS_MT_POSITION_Y)) &#123;        // Some joysticks such as the PS3 controller report axes that conflict        // with the ABS_MT range.  Try to confirm that the device really is        // a touch screen.        if (device-&gt;keyBitmask.test(BTN_TOUCH) || !haveGamepadButtons) &#123;            device-&gt;classes |= (InputDeviceClass::TOUCH | InputDeviceClass::TOUCH_MT);        &#125;        // Is this an old style single-touch driver?        //是不是老版的单点触摸驱动    &#125; else if (device-&gt;keyBitmask.test(BTN_TOUCH) &amp;&amp; device-&gt;absBitmask.test(ABS_X) &amp;&amp;               device-&gt;absBitmask.test(ABS_Y)) &#123;        device-&gt;classes |= InputDeviceClass::TOUCH;        // Is this a BT stylus?        //是不是蓝牙手写笔    &#125; else if ((device-&gt;absBitmask.test(ABS_PRESSURE) || device-&gt;keyBitmask.test(BTN_TOUCH)) &amp;&amp;               !device-&gt;absBitmask.test(ABS_X) &amp;&amp; !device-&gt;absBitmask.test(ABS_Y)) &#123;        device-&gt;classes |= InputDeviceClass::EXTERNAL_STYLUS;        // Keyboard will try to claim some of the buttons but we really want to reserve those so we        // can fuse it with the touch screen data, so just take them back. Note this means an        // external stylus cannot also be a keyboard device.        //外部手写笔不能同时是键盘设备        device-&gt;classes &amp;= ~InputDeviceClass::KEYBOARD;    &#125;    // See if this device is a joystick.    // Assumes that joysticks always have gamepad buttons in order to distinguish them    // from other devices such as accelerometers that also have absolute axes.    //是不是操作杆    if (haveGamepadButtons) &#123;        auto assumedClasses = device-&gt;classes | InputDeviceClass::JOYSTICK;        for (int i = 0; i &lt;= ABS_MAX; i++) &#123;            if (device-&gt;absBitmask.test(i) &amp;&amp;                (getAbsAxisUsage(i, assumedClasses).test(InputDeviceClass::JOYSTICK))) &#123;                device-&gt;classes = assumedClasses;                break;            &#125;        &#125;    &#125;    // Check whether this device is an accelerometer.    //是不是加速计    if (device-&gt;propBitmask.test(INPUT_PROP_ACCELEROMETER)) &#123;        device-&gt;classes |= InputDeviceClass::SENSOR;    &#125;    // Check whether this device has switches.    //是不是有开关    for (int i = 0; i &lt;= SW_MAX; i++) &#123;        if (device-&gt;swBitmask.test(i)) &#123;            device-&gt;classes |= InputDeviceClass::SWITCH;            break;        &#125;    &#125;    // Check whether this device supports the vibrator.    //支不支持震动    if (device-&gt;ffBitmask.test(FF_RUMBLE)) &#123;        device-&gt;classes |= InputDeviceClass::VIBRATOR;    &#125;    // Configure virtual keys.    //虚拟按键（类似于老手机上面三个虚拟按键back、home、recent）    if ((device-&gt;classes.test(InputDeviceClass::TOUCH))) &#123;        // Load the virtual keys for the touch screen, if any.        // We do this now so that we can make sure to load the keymap if necessary.        bool success = device-&gt;loadVirtualKeyMapLocked();        if (success) &#123;            device-&gt;classes |= InputDeviceClass::KEYBOARD;        &#125;    &#125;    // Load the key map.    // We need to do this for joysticks too because the key layout may specify axes, and for    // sensor as well because the key layout may specify the axes to sensor data mapping.    //如果设备是键盘等设备就加载按键映射配置文件，    //包括kl(keyLayout)文件、kcm(KeyCharacterMap)文件    status_t keyMapStatus = NAME_NOT_FOUND;    if (device-&gt;classes.any(InputDeviceClass::KEYBOARD | InputDeviceClass::JOYSTICK |                            InputDeviceClass::SENSOR)) &#123;        // Load the keymap for the device.        keyMapStatus = device-&gt;loadKeyMapLocked();  //加载过程和idc文件类似    &#125;    // Configure the keyboard, gamepad or virtual keyboard.    //配置键盘、手柄、虚拟键盘相关    if (device-&gt;classes.test(InputDeviceClass::KEYBOARD)) &#123;        // Register the keyboard as a built-in keyboard if it is eligible.        //如果符合内置键盘的条件就把这个device指定为内置键盘        if (!keyMapStatus &amp;&amp; mBuiltInKeyboardId == NO_BUILT_IN_KEYBOARD &amp;&amp;            isEligibleBuiltInKeyboard(device-&gt;identifier, device-&gt;configuration.get(),                                      &amp;device-&gt;keyMap)) &#123;            mBuiltInKeyboardId = device-&gt;id;        &#125;        // &#39;Q&#39; key support = cheap test of whether this is an alpha-capable kbd        //如果有Q键就说明是一个标准全功能键盘，设置为ALPHAKEY类型        if (device-&gt;hasKeycodeLocked(AKEYCODE_Q)) &#123;            device-&gt;classes |= InputDeviceClass::ALPHAKEY;        &#125;        // See if this device has a DPAD.        //如果有方向键        if (device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_UP) &amp;&amp;            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_DOWN) &amp;&amp;            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_LEFT) &amp;&amp;            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_RIGHT) &amp;&amp;            device-&gt;hasKeycodeLocked(AKEYCODE_DPAD_CENTER)) &#123;            device-&gt;classes |= InputDeviceClass::DPAD;        &#125;        // See if this device has a gamepad.        //如果是游戏手柄        for (size_t i = 0; i &lt; sizeof(GAMEPAD_KEYCODES) / sizeof(GAMEPAD_KEYCODES[0]); i++) &#123;            if (device-&gt;hasKeycodeLocked(GAMEPAD_KEYCODES[i])) &#123;                device-&gt;classes |= InputDeviceClass::GAMEPAD;                break;            &#125;        &#125;    &#125;    // If the device isn&#39;t recognized as something we handle, don&#39;t monitor it.    //如果这个设备上面的类型都不符合，那么这个设备就是个屑，不用往下处理了，忽略，直接返回    if (device-&gt;classes == ftl::Flags&lt;InputDeviceClass&gt;(0)) &#123;        ALOGV(&quot;Dropping device: id=%d, path=&#39;%s&#39;, name=&#39;%s&#39;&quot;, deviceId, devicePath.c_str(),              device-&gt;identifier.name.c_str());        return;    &#125;    // Classify InputDeviceClass::BATTERY.    //如果这个设备还有关联的电池    if (hasBattery) &#123;        device-&gt;classes |= InputDeviceClass::BATTERY;    &#125;    // Classify InputDeviceClass::LIGHT.    //如果这个设备还有先进的LED灯    if (hasLights) &#123;        device-&gt;classes |= InputDeviceClass::LIGHT;    &#125;    // Determine whether the device has a mic.    //如果这个设备还有麦克风    if (device-&gt;deviceHasMicLocked()) &#123;        device-&gt;classes |= InputDeviceClass::MIC;    &#125;    // Determine whether the device is external or internal.    //从设备的idc文件中获取这个设备是内部设备还是外接设备，这个会影响一些优先级等，比如多屏    if (device-&gt;isExternalDeviceLocked()) &#123;        device-&gt;classes |= InputDeviceClass::EXTERNAL;    &#125;    //游戏手柄和操作杆有时会有多个controller    if (device-&gt;classes.any(InputDeviceClass::JOYSTICK | InputDeviceClass::DPAD) &amp;&amp;        device-&gt;classes.test(InputDeviceClass::GAMEPAD)) &#123;        device-&gt;controllerNumber = getNextControllerNumberLocked(device-&gt;identifier.name);        device-&gt;setLedForControllerLocked();    &#125;    //将这个设备的fd加入epoll的监听    if (registerDeviceForEpollLocked(*device) != OK) &#123;        return;    &#125;    //使用ioctl设置fd参数，例如按键重复、挂起块和时钟类型    device-&gt;configureFd();    ALOGI(&quot;New device: id=%d, fd=%d, path=&#39;%s&#39;, name=&#39;%s&#39;, classes=%s, &quot;          &quot;configuration=&#39;%s&#39;, keyLayout=&#39;%s&#39;, keyCharacterMap=&#39;%s&#39;, builtinKeyboard=%s, &quot;,          deviceId, fd, devicePath.c_str(), device-&gt;identifier.name.c_str(),          device-&gt;classes.string().c_str(), device-&gt;configurationFile.c_str(),          device-&gt;keyMap.keyLayoutFile.c_str(), device-&gt;keyMap.keyCharacterMapFile.c_str(),          toString(mBuiltInKeyboardId == deviceId));    //到这里从驱动获取到的这个设备已经完成各种初始化和配置，是时候加到mOpeningDevices中了，继续下一个循环，最后读取所有的设备    addDeviceLocked(std::move(device));&#125;</code></pre><p>这个方法很长，总的概括来看就做了几件事情：</p><ol><li>打开设备节点，从设备驱动中获取设备的各种描述信息并构造出Device对象</li><li>根据设备的信息加载这个设备的<code>idc</code>文件</li><li>向驱动查询这个设备支持的事件类型</li><li>判断设备的类型，设置相关的属性到<code>device-&gt;classes</code>中</li><li>如果是键盘灯设备还需要加载设备对应的<code>kl</code>文件和<code>kcm</code>文件，</li><li>将这个<code>设备的fd</code>加入<code>epoll</code>的监听中</li><li>通过<code>ioctl</code>设置<code>fd参数</code>，例如<code>按键重复、挂起块和时钟类型</code></li><li>最后再把这个设备加到<code>mOpeningDevices</code>中管理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 从前面inputflinger的启动分析中，我们知道事件来源是在&lt;code&gt;EventHub::getEvents&lt;/code&gt;, 所以我们重点看下这个方法的流程来了解事件是如何从驱动上报中获取的。&lt;/p&gt;
&lt;h4 id=&quot;EventHub-getEvents&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="InPutManagerService" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"/>
    
    
  </entry>
  
  <entry>
    <title>1.InputFlinger的启动</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/1.InputFlinger%E7%9A%84%E5%90%AF%E5%8A%A8/</id>
    <published>2023-12-29T06:13:43.909Z</published>
    <updated>2024-01-08T01:45:36.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务的启动"><a href="#服务的启动" class="headerlink" title="服务的启动"></a>服务的启动</h3><p>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</p><pre><code>    private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123;        t.traceBegin(&quot;startOtherServices&quot;);        ...        WindowManagerService wm = null;        InputManagerService inputManager = null;        try &#123;            //1. 获取InputManagerService，并走初始化inputManager流程            ...            t.traceBegin(&quot;StartInputManagerService&quot;);            inputManager = new InputManagerService(context);            t.traceEnd();            ...            //2. WindowManagerService服务持有inputManager对象            t.traceBegin(&quot;StartWindowManagerService&quot;);            wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,                    new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);               ...               //3. 向ServiceManager注册java层ims服务，name = &quot;input&quot;，(native层的服务name = &quot;inputflinger&quot;)            ServiceManager.addService(Context.INPUT_SERVICE, inputManager,                    /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);            t.traceEnd();            ...            //4. 启动inputflinger，处理输入事件            t.traceBegin(&quot;StartInputManager&quot;);            inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());            inputManager.start();            t.traceEnd();            ...        &#125; catch (Throwable e) &#123;            ...        &#125;</code></pre><ol><li>获取InputManagerService，并走初始化inputManager（java层和native层）流程</li><li>WindowManagerService服务构造时传入inputManager对象，用户wms和ims交互</li><li>向ServiceManager注册java层ims服务</li><li>启动inputflinger，处理输入事件</li></ol><p>我们重点看下1和4</p><h3 id="1-初始化InputFlinger"><a href="#1-初始化InputFlinger" class="headerlink" title="1. 初始化InputFlinger"></a>1. 初始化InputFlinger</h3><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java</p><pre><code>    public InputManagerService(Context context) &#123;        this(new Injector(context, DisplayThread.get().getLooper()));    &#125;    @VisibleForTesting    InputManagerService(Injector injector) &#123;        ...        mContext = injector.getContext();        mHandler = new InputManagerHandler(injector.getLooper());  //创建一个handle（使用DisplayThread，这个线程用户       //wms，display，input三个服务使用，对延迟敏感）        mNative = injector.getNativeService(this);  //创建native input服务（NativeInputManagerService）        ...        injector.registerLocalService(new LocalService());  //将InputManagerService中的InputManagerInternal实现类加入LocalServices，供同进程其他服务调用相关功能    &#125;    @VisibleForTesting    static class Injector &#123;        private final Context mContext;        private final Looper mLooper;        Injector(Context context, Looper looper) &#123;            mContext = context;            mLooper = looper;        &#125;        Context getContext() &#123;            return mContext;        &#125;        Looper getLooper() &#123;            return mLooper;        &#125;        //创建native层对应的service        NativeInputManagerService getNativeService(InputManagerService service) &#123;            return new NativeInputManagerService.NativeImpl(service, mContext, mLooper.getQueue());        &#125;        //将InputManagerService中的InputManagerInternal实现类加入LocalServices，供同进程其他服务调用相关功能        void registerLocalService(InputManagerInternal localService) &#123;            LocalServices.addService(InputManagerInternal.class, localService);        &#125;    &#125;</code></pre><h4 id="NativeInputManagerService-NativeImpl"><a href="#NativeInputManagerService-NativeImpl" class="headerlink" title="NativeInputManagerService.NativeImpl"></a>NativeInputManagerService.NativeImpl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface NativeInputManagerService &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NativeImpl</span> implements NativeInputManagerService &#123;</span><br><span class="line">        <span class="comment">/** Pointer to native input manager service object, used by native code. */</span></span><br><span class="line">        @<span class="built_in">SuppressWarnings</span>(&#123;<span class="string">&quot;unused&quot;</span>, <span class="string">&quot;FieldCanBeLocal&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> mPtr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NativeImpl</span>(InputManagerService service, Context context, MessageQueue messageQueue) &#123;</span><br><span class="line">            mPtr = <span class="built_in">init</span>(service, context, messageQueue);  <span class="comment">//初始化native层服务并返回该服务的对象指针到java层</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> native <span class="type">long</span> <span class="title">init</span><span class="params">(InputManagerService service, Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                MessageQueue messageQueue)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nativeInit"><a href="#nativeInit" class="headerlink" title="nativeInit"></a>nativeInit</h4><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;<a href="https://so.csdn.net/so/search?q=jni&spm=1001.2101.3001.7020">jni</a>&#x2F;com_android_server_input_InputManagerService.cpp</p><pre><code>static const JNINativeMethod gInputManagerMethods[] = &#123;        &#123;&quot;init&quot;,         &quot;(Lcom/android/server/input/InputManagerService;Landroid/content/Context;Landroid/os/&quot;         &quot;MessageQueue;)J&quot;,         (void*)nativeInit&#125;,  //init(java)-&gt;nativeInit(native)        ...&#125;;    static jlong nativeInit(JNIEnv* env, jclass /* clazz */,        jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);    ...    // 创建native层NativeInputManager，保存java层的context对象、ims对象、msgqueue    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,            messageQueue-&gt;getLooper());    im-&gt;incStrong(0);  //NativeInputManager对象强引用 + 1    return reinterpret_cast&lt;jlong&gt;(im);  //将native层NativeInputManager对象地址返回给java层，这个地址可以在native层获取出同一个对象&#125;//NativeInputManager类声明，实现了三个重要接口抽象类/*class NativeInputManager : public virtual RefBase,    public virtual InputReaderPolicyInterface,    public virtual InputDispatcherPolicyInterface,    public virtual PointerControllerPolicyInterface &#123;    */    NativeInputManager::NativeInputManager(jobject contextObj,        jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) :        mLooper(looper), mInteractive(true) &#123;    JNIEnv* env = jniEnv();  //获取虚拟机环境指针            mServiceObj = env-&gt;NewGlobalRef(serviceObj);  //将java层的ims对象保存为全局引用    &#123;        AutoMutex _l(mLock);        mLocked.systemUiLightsOut = false;        mLocked.pointerSpeed = 0;        mLocked.pointerAcceleration = android::os::IInputConstants::DEFAULT_POINTER_ACCELERATION;        mLocked.pointerGesturesEnabled = true;        mLocked.showTouches = false;        mLocked.pointerDisplayId = ADISPLAY_ID_DEFAULT;    &#125;    mInteractive = true;    InputManager* im = new InputManager(this, this);  //创建native层InputManager    mInputManager = im;    defaultServiceManager()-&gt;addService(String16(&quot;inputflinger&quot;), im);  //向ServiceManager注册native层inputflinger服务&#125;</code></pre><h4 id="new-InputManager"><a href="#new-InputManager" class="headerlink" title="new InputManager"></a>new InputManager</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputManager.cpp</p><pre><code>/** * The event flow is via the &quot;InputListener&quot; interface, as follows: * InputReader -&gt; UnwantedInteractionBlocker -&gt; InputClassifier -&gt; InputDispatcher */InputManager::InputManager(        const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;    mDispatcher = createInputDispatcher(dispatcherPolicy);    mClassifier = std::make_unique&lt;InputClassifier&gt;(*mDispatcher);    mBlocker = std::make_unique&lt;UnwantedInteractionBlocker&gt;(*mClassifier);    mReader = createInputReader(readerPolicy, *mBlocker);&#125;</code></pre><p>创建并初始化四个event flow中的重要对象, 事件从前到后传递，前面的对象依次持有下一个阶段的对象引用<br><code>event flow: InputReader -&gt; UnwantedInteractionBlocker -&gt; InputClassifier -&gt; InputDispatcher</code></p><h4 id="createInputDispatcher"><a href="#createInputDispatcher" class="headerlink" title="createInputDispatcher"></a>createInputDispatcher</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;dispatcher&#x2F;InputDispatcher.cpp</p><pre><code>//InputDispatcherFactory.cppstd::unique_ptr&lt;InputDispatcherInterface&gt; createInputDispatcher(        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) &#123;    return std::make_unique&lt;android::inputdispatcher::InputDispatcher&gt;(policy);&#125;//  InputDispatcher.cppInputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy)      : InputDispatcher(policy, STALE_EVENT_TIMEOUT) &#123;&#125;InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy,                                 std::chrono::nanoseconds staleEventTimeout)      : mPolicy(policy),  //将接口实现对象传进来，用户和wms服务交互     ...//一些成员变量初始化，太多了不列出     &#123;         mLooper = new Looper(false);  //用于InputDispatcher线程    mReporter = createInputReporter();    //注册SurfaceComposer监听，当window状态改变时回调此接口onWindowInfosChanged通知inputflinger    mWindowInfoListener = new DispatcherWindowListener(*this);    SurfaceComposerClient::getDefault()-&gt;addWindowInfosListener(mWindowInfoListener);    mKeyRepeatState.lastKeyEntry = nullptr;    policy-&gt;getDispatcherConfiguration(&amp;mConfig);&#125;</code></pre><h4 id="InputClassifier"><a href="#InputClassifier" class="headerlink" title="InputClassifier"></a>InputClassifier</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputClassifier.cpp</p><pre><code>//构建InputClassifier，传入mQueuedListener = listener 这个就是mDispatcher对象，这样就可以回调mDispatcher的方法InputClassifier::InputClassifier(InputListenerInterface&amp; listener) : mQueuedListener(listener) &#123;&#125;</code></pre><h4 id="UnwantedInteractionBlocker"><a href="#UnwantedInteractionBlocker" class="headerlink" title="UnwantedInteractionBlocker"></a>UnwantedInteractionBlocker</h4><pre><code>//UnwantedInteractionBlocker是所有输入事件都会经历的一个阶段//inputReader通过它notifyXXX方法向InputDispatcher传递对应事件//其中对于触摸事件，如果支持手掌误触等功能，则会在这里有特殊处理UnwantedInteractionBlocker::UnwantedInteractionBlocker(InputListenerInterface&amp; listener)      : UnwantedInteractionBlocker(listener, isPalmRejectionEnabled())&#123;&#125;;//isPalmRejectionEnabled 检测是否开始手掌误触功能UnwantedInteractionBlocker::UnwantedInteractionBlocker(InputListenerInterface&amp; listener,                                                       bool enablePalmRejection)      : mQueuedListener(listener), mEnablePalmRejection(enablePalmRejection) &#123;&#125;</code></pre><h4 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputReader.cpp</p><pre><code>std::unique_ptr&lt;InputReaderInterface&gt; createInputReader(        const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, InputListenerInterface&amp; listener) &#123;    return std::make_unique&lt;InputReader&gt;(std::make_unique&lt;EventHub&gt;(), policy, listener);&#125;InputReader::InputReader(std::shared_ptr&lt;EventHubInterface&gt; eventHub,                         const sp&lt;InputReaderPolicyInterface&gt;&amp; policy,                         InputListenerInterface&amp; listener)      : mContext(this),        mEventHub(eventHub), //1.初始化EventHub        mPolicy(policy),        mQueuedListener(listener),  //2. 传入UnwantedInteractionBlocker对象        mGlobalMetaState(AMETA_NONE),        mLedMetaState(AMETA_NONE),        mGeneration(1),        mNextInputDeviceId(END_RESERVED_ID),        mDisableVirtualKeysTimeout(LLONG_MIN),        mNextTimeout(LLONG_MAX),        mConfigurationChangesToRefresh(0) &#123;    refreshConfigurationLocked(0);    updateGlobalMetaStateLocked();&#125;</code></pre><p><code>InputReader</code>最重要就是：</p><ol><li>创建并初始化<code>EventHub</code>, 通过它向驱动获取上报的事件</li><li>注册<code>UnwantedInteractionBlocker</code> listener, 通过它向<code>inputDispater</code>传递事件</li></ol><h4 id="EventHub"><a href="#EventHub" class="headerlink" title="EventHub"></a>EventHub</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;EventHub.cpp</p><pre><code>EventHub::EventHub(void)      : mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD),        mNextDeviceId(1),        mControllerNumbers(),        mNeedToSendFinishedDeviceScan(false),        mNeedToReopenDevices(false),        mNeedToScanDevices(true),        mPendingEventCount(0),        mPendingEventIndex(0),        mPendingINotify(false) &#123;    ensureProcessCanBlockSuspend();    //初始化epoll (用于监听文件描述符上的事件，用于监听具体/dev/input/eventX的fd的事件)    mEpollFd = epoll_create1(EPOLL_CLOEXEC);    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno));    //初始化inotify (用于监听文件和目录的变化，这里主要时用于监听/dev/input/下面的目录变化)    mINotifyFd = inotify_init1(IN_CLOEXEC);    std::error_code errorCode;    bool isDeviceInotifyAdded = false;    //检测 &quot;/dev/input&quot; 文件节点是否存在    if (std::filesystem::exists(DEVICE_INPUT_PATH, errorCode)) &#123;        //如果当前&quot;/dev/input&quot; 文件节点存在则将这个路径加入Inotify监听        addDeviceInputInotify();    &#125; else &#123;        //如果当前&quot;/dev/input&quot; 文件节点不存在，则先将这个路径&quot;/dev&quot;加入Inotify监听(监听dev所有节点)        //因为有些嵌入式设备不一定一直存在输入设备，那么仅当/dev/input出现时（插入输入设备）才添加对/dev/input内容的监听,         addDeviceInotify();        isDeviceInotifyAdded = true;    &#125;        //V4L视频设备相关    if (isV4lScanningEnabled() &amp;&amp; !isDeviceInotifyAdded) &#123;        addDeviceInotify();    &#125; else &#123;        ALOGI(&quot;Video device scanning disabled&quot;);    &#125;    struct epoll_event eventItem = &#123;&#125;;    eventItem.events = EPOLLIN | EPOLLWAKEUP; //设置监听epoll事件类型    eventItem.data.fd = mINotifyFd;//要处理的事件相关的文件描述符        //将mINotifyFd加入epoll监听的fd池子    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);    //创建一个管道    int wakeFds[2];    result = pipe2(wakeFds, O_CLOEXEC);    mWakeReadPipeFd = wakeFds[0];  //0为读端    mWakeWritePipeFd = wakeFds[1];  //1为写端    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);    eventItem.data.fd = mWakeReadPipeFd;  //将mWakeReadPipeFd设置到eventItem.data.fd，当epoll有event到来会    //将管道读端fd加入epoll监听的fd池子，当管道写端写入数据时，读端就换监听到epoll事件    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);&#125;</code></pre><p>到这里初始化InputFlinger就完成了</p><h3 id="2-启动inputflinger，处理输入事件"><a href="#2-启动inputflinger，处理输入事件" class="headerlink" title="2. 启动inputflinger，处理输入事件"></a>2. 启动inputflinger，处理输入事件</h3><p>前面<code>SystemServer</code>的1、2、3步都完成后，会往下执行</p><pre><code>    //4. 启动inputflinger，处理输入事件          t.traceBegin(&quot;StartInputManager&quot;);          //ims也注册wms的回调，用于通知wms一些事件发生          inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());          inputManager.start();  //启动ims，开始处理输入事件          t.traceEnd();</code></pre><h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java</p><pre><code>    public void start() &#123;        Slog.i(TAG, &quot;Starting input manager&quot;);        mNative.start();  //到native中的方法        // Add ourselves to the Watchdog monitors.        Watchdog.getInstance().addMonitor(this); //加入Watchdog的检测列表中        //一系列对settings中开关的状态值监听        ...    &#125;</code></pre><h4 id="nativeStart"><a href="#nativeStart" class="headerlink" title="nativeStart"></a>nativeStart</h4><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;com_android_server_input_InputManagerService.cpp</p><pre><code>static void nativeStart(JNIEnv* env, jobject nativeImplObj) &#123;    NativeInputManager* im = getNativeInputManager(env, nativeImplObj);        status_t result = im-&gt;getInputManager()-&gt;start();&#125;</code></pre><h4 id="InputManager-start"><a href="#InputManager-start" class="headerlink" title="InputManager::start()"></a>InputManager::start()</h4><pre><code>status_t InputManager::start() &#123;    status_t result = mDispatcher-&gt;start();    result = mReader-&gt;start();    return OK;&#125;</code></pre><p>分别调用<code>inputDispatcher</code>和<code>inputReader</code>的<code>start</code>方法</p><h4 id="InputDispatcher-start"><a href="#InputDispatcher-start" class="headerlink" title="InputDispatcher::start()"></a>InputDispatcher::start()</h4><pre><code>//InputManager.cppstatus_t InputDispatcher::start() &#123;    //创建线程InputDispatcher，线程体函数dispatchOnce(), 线程唤醒函数mLooper-&gt;wake()    mThread = std::make_unique&lt;InputThread&gt;(            &quot;InputDispatcher&quot;, [this]() &#123; dispatchOnce(); &#125;, [this]() &#123; mLooper-&gt;wake(); &#125;);    return OK;&#125;</code></pre><p><code>InputThread</code>继承与<a href="https://so.csdn.net/so/search?q=Thead&spm=1001.2101.3001.7020">Thead</a>类<br>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputThread.cpp</p><pre><code>InputThread::InputThread(std::string name, std::function&lt;void()&gt; loop, std::function&lt;void()&gt; wake)      : mName(name), mThreadWake(wake) &#123;    mThread = new InputThreadImpl(loop);    mThread-&gt;run(mName.c_str(), ANDROID_PRIORITY_URGENT_DISPLAY);  //启动线程，线程优先级很高&#125;        class InputThreadImpl : public Thread &#123;public:    explicit InputThreadImpl(std::function&lt;void()&gt; loop)          : Thread(/* canCallJava */ true), mThreadLoop(loop) &#123;&#125;    ~InputThreadImpl() &#123;&#125;private:    std::function&lt;void()&gt; mThreadLoop;    bool threadLoop() override &#123;        mThreadLoop();        return true;    &#125;&#125;;</code></pre><p>创建一个线程，用于分发事件，线程执行体<code>dispatchOnce()</code></p><pre><code>void InputDispatcher::dispatchOnce() &#123;    nsecs_t nextWakeupTime = LONG_LONG_MAX;    &#123; // acquire lock        std::scoped_lock _l(mLock);        mDispatcherIsAlive.notify_all();        // Run a dispatch loop if there are no pending commands.        // The dispatch loop might enqueue commands to run afterwards.        if (!haveCommandsLocked()) &#123;            dispatchOnceInnerLocked(&amp;nextWakeupTime);  //处理事件的分发        &#125;        // Run all pending commands if there are any.        // If any commands were run then force the next poll to wake up immediately.        if (runCommandsLockedInterruptable()) &#123;  //处理命令队列中的命令            nextWakeupTime = LONG_LONG_MIN;        &#125;        // If we are still waiting for ack on some events,        // we might have to wake up earlier to check if an app is anr&#39;ing.        const nsecs_t nextAnrCheck = processAnrsLocked();  //处理input ANR相关        nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck);        // We are about to enter an infinitely long sleep, because we have no commands or        // pending or queued events        if (nextWakeupTime == LONG_LONG_MAX) &#123;            mDispatcherEnteredIdle.notify_all();  //线程进入idle状态        &#125;    &#125; // release lock    // Wait for callback or timeout or wake.  (make sure we round up, not down)    nsecs_t currentTime = now();    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);    mLooper-&gt;pollOnce(timeoutMillis);  //再次进入阻塞等待中&#125;</code></pre><h4 id="InputReader-start"><a href="#InputReader-start" class="headerlink" title="InputReader::start()"></a>InputReader::start()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputReader::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程InputReader，线程体函数loopOnce(), 线程唤醒函数mEventHub-&gt;wake()（调用EventHub的wake方法来唤醒）</span></span><br><span class="line">    mThread = std::<span class="built_in">make_unique</span>&lt;InputThread&gt;(</span><br><span class="line">            <span class="string">&quot;InputReader&quot;</span>, [<span class="keyword">this</span>]() &#123; <span class="built_in">loopOnce</span>(); &#125;, [<span class="keyword">this</span>]() &#123; mEventHub-&gt;<span class="built_in">wake</span>(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="type">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="type">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    std::vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用EventHub的getEvents获取输入事件</span></span><br><span class="line">    <span class="type">size_t</span> count = mEventHub-&gt;<span class="built_in">getEvents</span>(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        mReaderIsAliveCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            <span class="built_in">processEventsLocked</span>(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;</span><br><span class="line">            <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= mNextTimeout) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_RAW_EVENTS) &#123;</span><br><span class="line">                    <span class="built_in">ALOGD</span>(<span class="string">&quot;Timeout expired, latency=%0.3fms&quot;</span>, (now - mNextTimeout) * <span class="number">0.000001f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mNextTimeout = LLONG_MAX;</span><br><span class="line">                <span class="built_in">timeoutExpiredLocked</span>(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldGeneration != mGeneration) &#123;</span><br><span class="line">            inputDevicesChanged = <span class="literal">true</span>;</span><br><span class="line">            inputDevices = <span class="built_in">getInputDevicesLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send out a message that the describes the changed input devices.</span></span><br><span class="line">    <span class="comment">//如果输入设备有变化，通知其他服务</span></span><br><span class="line">    <span class="keyword">if</span> (inputDevicesChanged) &#123;</span><br><span class="line">        mPolicy-&gt;<span class="built_in">notifyInputDevicesChanged</span>(inputDevices);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueuedListener.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在循环从<code>mEventHub-&gt;getEvents</code>获取输入事件（这个方法会引起阻塞），如果获取到事件，EventHub会唤醒此线程，返回后会刷新<code>mQueuedListener</code>的事件队列, 唤醒<code>InputDispatcher</code>线程来消费。<br>到这里inputflinger的启动就完成，开始正常等待输入事件的上报并处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;服务的启动&quot;&gt;&lt;a href=&quot;#服务的启动&quot; class=&quot;headerlink&quot; title=&quot;服务的启动&quot;&gt;&lt;/a&gt;服务的启动&lt;/h3&gt;&lt;p&gt;frameworks&amp;#x2F;base&amp;#x2F;services&amp;#x2F;java&amp;#x2F;com&amp;#x2F</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="InPutManagerService" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"/>
    
    
  </entry>
  
  <entry>
    <title>3.InputReader事件处理</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/InPutManagerService/3.InputReader%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</id>
    <published>2023-12-29T03:09:54.231Z</published>
    <updated>2024-01-02T08:58:59.359Z</updated>
    
    <content type="html"><![CDATA[<p>####回顾</p><p>从前面的InputFlinger的启动可知，InputReader线程启动后会循环执行loopOnce()方法，然后阻塞在<code>getEvents</code>等待事件的上报，这里就从loopOnce获取到事件被唤醒后来分析InputReader对事件的处理。</p><h4 id="InputReader-loopOnce"><a href="#InputReader-loopOnce" class="headerlink" title="InputReader::loopOnce()"></a>InputReader::loopOnce()</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputReader.cpp</p><pre><code>void InputReader::loopOnce() &#123;    int32_t oldGeneration;    int32_t timeoutMillis;    bool inputDevicesChanged = false;    std::vector&lt;InputDeviceInfo&gt; inputDevices;        ...    //从EventHub中读取事件    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);            &#123; // acquire lock        ...        if (count) &#123;            //处理事件            processEventsLocked(mEventBuffer, count);        &#125;        ...            &#125; // release lock    // Send out a message that the describes the changed input devices.    //如果输入设备状态改变则通过回调通知java层    if (inputDevicesChanged) &#123;        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);    &#125;    // Flush queued events out to the listener.    mQueuedListener.flush();&#125;</code></pre><h3 id="一、处理事件"><a href="#一、处理事件" class="headerlink" title="一、处理事件"></a>一、处理事件</h3><h4 id="InputReader-processEventsLocked"><a href="#InputReader-processEventsLocked" class="headerlink" title="InputReader::processEventsLocked"></a>InputReader::processEventsLocked</h4><pre><code>void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123;    for (const RawEvent* rawEvent = rawEvents; count;) &#123;        int32_t type = rawEvent-&gt;type;        size_t batchSize = 1;        //除了设备添加、移除、结束扫描事件之外的普通事件采用批处理方式方式处理        if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;            int32_t deviceId = rawEvent-&gt;deviceId;            while (batchSize &lt; count) &#123;                //如果出现不符合批处理的事件（一般上面的判断已经足够）则退出本次事件流程                if (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT ||                    rawEvent[batchSize].deviceId != deviceId) &#123;                    break;                &#125;                batchSize += 1;            &#125;            //处理普通事件（批量处理）            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);        &#125; else &#123;            switch (rawEvent-&gt;type) &#123;                //如果是设备添加事件                case EventHubInterface::DEVICE_ADDED:                    //添加设备主要就是创建设备对应的inputDevice                    //通过设备的class类型创建对应的mapper                    //将对应的mapper和EventHub、inputReader关联（InputDeviceContext）                    //然后将对应的deviceId、mapper、InputDeviceContext加入inputDevice容器中                    addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);                    break;                //如果是设备移除事件                case EventHubInterface::DEVICE_REMOVED:                    removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);                    break;                //如果是设备结束扫描事件                case EventHubInterface::FINISHED_DEVICE_SCAN:                    handleConfigurationChangedLocked(rawEvent-&gt;when);                    break;                default:                    ALOG_ASSERT(false); // can&#39;t happen                    break;            &#125;        &#125;        count -= batchSize;        rawEvent += batchSize;    &#125;&#125;</code></pre><h4 id="InputReader-processEventsForDeviceLocked"><a href="#InputReader-processEventsForDeviceLocked" class="headerlink" title="InputReader::processEventsForDeviceLocked"></a>InputReader::processEventsForDeviceLocked</h4><pre><code>void InputReader::processEventsForDeviceLocked(int32_t eventHubId, const RawEvent* rawEvents,                                               size_t count) &#123;    auto deviceIt = mDevices.find(eventHubId);  //通过device id找到事件对应的inputDevice对象    ...    device-&gt;process(rawEvents, count);  //调用事件对应的inputDevice对象process处理当前事件&#125;</code></pre><h4 id="InputDevice-process"><a href="#InputDevice-process" class="headerlink" title="InputDevice::process"></a>InputDevice::process</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;InputDevice.cpp</p><pre><code>void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123;    //按顺序分发给对应的mapper处理，要求事件按照时间顺序处理    for (const RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) &#123;        if (mDropUntilNextSync) &#123;  //抛弃下一个SYN事件前的所有事件            ...        &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;            ...        &#125; else &#123;  //正常走这里            //通过deviceId查询mDevices中对应的mapper（这个是在设备add事件时添加的）            for_each_mapper_in_subdevice(rawEvent-&gt;deviceId, [rawEvent](InputMapper&amp; mapper) &#123;                mapper.process(rawEvent);            &#125;);        &#125;        --count;    &#125;&#125;</code></pre><h4 id="for-each-mapper-in-subdevice"><a href="#for-each-mapper-in-subdevice" class="headerlink" title="for_each_mapper_in_subdevice"></a>for_each_mapper_in_subdevice</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;include&#x2F;InputDevice.h</p><pre><code>    // run a function against every mapper on a specific subdevice    inline void for_each_mapper_in_subdevice(int32_t eventHubDevice,                                             std::function&lt;void(InputMapper&amp;)&gt; f) &#123;        auto deviceIt = mDevices.find(eventHubDevice);        if (deviceIt != mDevices.end()) &#123;            auto&amp; devicePair = deviceIt-&gt;second;            auto&amp; mappers = devicePair.second;            for (auto&amp; mapperPtr : mappers) &#123;                f(*mapperPtr);            &#125;        &#125;    &#125;</code></pre><p>通过<code>rawEvent-&gt;deviceId</code>来查询这个事件对应的设备在<code>设备add事件</code>时添加的<code>mapper</code>，这个<code>mapper</code>是根据<code>device</code>的<code>class类型</code>来决定的</p><h4 id="MultiTouchInputMapper-process"><a href="#MultiTouchInputMapper-process" class="headerlink" title="MultiTouchInputMapper::process"></a>MultiTouchInputMapper::process</h4><p>在<code>InputReader::addDeviceLocked</code>中可以知道触摸现在走的是<code>MultiTouchInputMapper</code><br>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;mapper&#x2F;MultiTouchInputMapper.cpp</p><pre><code>void MultiTouchInputMapper::process(const RawEvent* rawEvent) &#123;    TouchInputMapper::process(rawEvent);    //处理常规触摸EV_ABS事件，包括多指情况（多个slot）    mMultiTouchMotionAccumulator.process(rawEvent);&#125;void TouchInputMapper::process(const RawEvent* rawEvent) &#123;    mCursorButtonAccumulator.process(rawEvent);  //如果是光标按键事件，一般不是    mCursorScrollAccumulator.process(rawEvent);  //如果是光标滚动事件，一般不是    mTouchButtonAccumulator.process(rawEvent);   //如果是触摸按键事件，（手写笔有时有）    //只有当收到一次EV_SYN事件上上报本次触摸的事件集    if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;        sync(rawEvent-&gt;when, rawEvent-&gt;readTime);    &#125;&#125;    void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) &#123;    if (rawEvent-&gt;type == EV_ABS) &#123;        bool newSlot = false;        if (mUsingSlotsProtocol) &#123;  //如果支持多指触摸协议            if (rawEvent-&gt;code == ABS_MT_SLOT) &#123;                mCurrentSlot = rawEvent-&gt;value;                newSlot = true;            &#125;        &#125; else if (mCurrentSlot &lt; 0) &#123;            mCurrentSlot = 0;        &#125;        if (mCurrentSlot &lt; 0 || size_t(mCurrentSlot) &gt;= mSlotCount) &#123;            ...        &#125; else &#123;            Slot* slot = &amp;mSlots[mCurrentSlot];            // If mUsingSlotsProtocol is true, it means the raw pointer has axis info of            // ABS_MT_TRACKING_ID and ABS_MT_SLOT, so driver should send a valid trackingId while            // updating the slot.            //如果支持多指触摸协议，那么驱动就需要上报有效的trackingId来给上层区分            if (!mUsingSlotsProtocol) &#123;                slot-&gt;mInUse = true;            &#125;            //根据事件的code来更新slot的信息            switch (rawEvent-&gt;code) &#123;                case ABS_MT_POSITION_X:                    slot-&gt;mAbsMTPositionX = rawEvent-&gt;value;                    warnIfNotInUse(*rawEvent, *slot);                    break;                case ABS_MT_POSITION_Y:                    slot-&gt;mAbsMTPositionY = rawEvent-&gt;value;                    warnIfNotInUse(*rawEvent, *slot);                    break;                case ABS_MT_TOUCH_MAJOR:                    slot-&gt;mAbsMTTouchMajor = rawEvent-&gt;value;                    break;                case ABS_MT_TOUCH_MINOR:                    slot-&gt;mAbsMTTouchMinor = rawEvent-&gt;value;                    slot-&gt;mHaveAbsMTTouchMinor = true;                    break;                case ABS_MT_WIDTH_MAJOR:                    slot-&gt;mAbsMTWidthMajor = rawEvent-&gt;value;                    break;                case ABS_MT_WIDTH_MINOR:                    slot-&gt;mAbsMTWidthMinor = rawEvent-&gt;value;                    slot-&gt;mHaveAbsMTWidthMinor = true;                    break;                case ABS_MT_ORIENTATION:                    slot-&gt;mAbsMTOrientation = rawEvent-&gt;value;                    break;                case ABS_MT_TRACKING_ID:                    if (mUsingSlotsProtocol &amp;&amp; rawEvent-&gt;value &lt; 0) &#123;                        // The slot is no longer in use but it retains its previous contents,                        // which may be reused for subsequent touches.                        slot-&gt;mInUse = false;                    &#125; else &#123;                        slot-&gt;mInUse = true;                        slot-&gt;mAbsMTTrackingId = rawEvent-&gt;value;                    &#125;                    break;                case ABS_MT_PRESSURE:                    slot-&gt;mAbsMTPressure = rawEvent-&gt;value;                    break;                case ABS_MT_DISTANCE:                    slot-&gt;mAbsMTDistance = rawEvent-&gt;value;                    break;                case ABS_MT_TOOL_TYPE:                    slot-&gt;mAbsMTToolType = rawEvent-&gt;value;                    slot-&gt;mHaveAbsMTToolType = true;                    break;            &#125;        &#125;    &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_MT_REPORT) &#123;        // MultiTouch Sync: The driver has returned all data for *one* of the pointers.        mCurrentSlot += 1;    &#125;&#125;</code></pre><h4 id="TouchInputMapper-sync"><a href="#TouchInputMapper-sync" class="headerlink" title="TouchInputMapper::sync"></a>TouchInputMapper::sync</h4><pre><code>void TouchInputMapper::sync(nsecs_t when, nsecs_t readTime) &#123;    //创建一个RawState并加入mRawStatesPending列表    // Push a new state.    mRawStatesPending.emplace_back();    //初始化上面的RawState, 将相关的各个mapper.process()中记录的事件的属性写入（sync）    RawState&amp; next = mRawStatesPending.back();    next.clear();    next.when = when;    next.readTime = readTime;    ...    // Sync touch    //同步触摸的状态，这里是调用子类MultiTouchInputMapper的实现，将子类的process中赋值的多指触摸相关属性赋值给next    syncTouch(when, &amp;next);    // The last RawState is the actually second to last, since we just added a new state    const RawState&amp; last =            mRawStatesPending.size() == 1 ? mCurrentRawState : mRawStatesPending.rbegin()[1];    ...    processRawTouches(false /*timeout*/);&#125;</code></pre><h4 id="TouchInputMapper-processRawTouches"><a href="#TouchInputMapper-processRawTouches" class="headerlink" title="TouchInputMapper::processRawTouches"></a>TouchInputMapper::processRawTouches</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;reader&#x2F;mapper&#x2F;TouchInputMapper.cpp</p><pre><code>void TouchInputMapper::processRawTouches(bool timeout) &#123;    //如果当前事件的设备被禁用，则中断这个触摸事件集的传递    if (mDeviceMode == DeviceMode::DISABLED) &#123;        // Drop all input if the device is disabled.        cancelTouch(mCurrentRawState.when, mCurrentRawState.readTime);        mCurrentCookedState.clear();        updateTouchSpots();        return;    &#125;    // Drain any pending touch states. The invariant here is that the mCurrentRawState is always    // valid and must go through the full cook and dispatch cycle. This ensures that anything    // touching the current state will only observe the events that have been dispatched to the    // rest of the pipeline.    const size_t N = mRawStatesPending.size();    size_t count;    for (count = 0; count &lt; N; count++) &#123;        const RawState&amp; next = mRawStatesPending[count];        // A failure to assign the stylus id means that we&#39;re waiting on stylus data        // and so should defer the rest of the pipeline.        //检测手写笔id是否可以获取到，如果无法获取就中断本次触摸批事件处理        if (assignExternalStylusId(next, timeout)) &#123;            break;        &#125;        // All ready to go.        clearStylusDataPendingFlags();  //移除手写笔状态相关变量        mCurrentRawState.copyFrom(next);  //将next赋给mCurrentRawState        ...        cookAndDispatch(mCurrentRawState.when, mCurrentRawState.readTime);    &#125;    if (count != 0) &#123;        //从mRawStatesPending移除本次已处理的RawState，一个RawState对应一次SYNC包含的触摸事件集        mRawStatesPending.erase(mRawStatesPending.begin(), mRawStatesPending.begin() + count);    &#125;    ...&#125;</code></pre><h4 id="TouchInputMapper-cookAndDispatch"><a href="#TouchInputMapper-cookAndDispatch" class="headerlink" title="TouchInputMapper::cookAndDispatch"></a>TouchInputMapper::cookAndDispatch</h4><pre><code>void TouchInputMapper::cookAndDispatch(nsecs_t when, nsecs_t readTime) &#123;    // Always start with a clean state.    mCurrentCookedState.clear();    // Apply stylus buttons to current raw state.    applyExternalStylusButtonState(when);  //处理手写笔按键状态    // Handle policy on initial down or hover events.    bool initialDown = mLastRawState.rawPointerData.pointerCount == 0 &amp;&amp;            mCurrentRawState.rawPointerData.pointerCount != 0;    uint32_t policyFlags = 0;    bool buttonsPressed = mCurrentRawState.buttonState &amp; ~mLastRawState.buttonState;    if (initialDown || buttonsPressed) &#123;        // If this is a touch screen, hide the pointer on an initial down.        if (mDeviceMode == DeviceMode::DIRECT) &#123;            getContext()-&gt;fadePointer();        &#125;        if (mParameters.wake) &#123;            policyFlags |= POLICY_FLAG_WAKE;        &#125;    &#125;    // Consume raw off-screen touches before cooking pointer data.    // If touches are consumed, subsequent code will not receive any pointer data.    //处理一些非屏幕区域的触摸行为，比如屏幕外的虚拟按键等，    //如果本次触摸是虚拟按键，那么本次触摸事件将会被虚拟按键逻辑消费，不在往下处理    if (consumeRawTouches(when, readTime, policyFlags)) &#123;        mCurrentRawState.rawPointerData.clear();    &#125;    // Cook pointer data.  This call populates the mCurrentCookedState.cookedPointerData structure    // with cooked pointer data that has the same ids and indices as the raw data.    // The following code can use either the raw or cooked data, as needed.    //这里就是将触摸设备(TP)的坐标范围映射到实际屏幕的坐标范围等（常识：TP的坐标不一定和屏幕的坐标对应，所以需要转化）    cookPointerData();        // Apply stylus pressure to current cooked state.    applyExternalStylusTouchState(when);  处理手写笔触摸状态    // Synthesize key down from raw buttons if needed.    // 如果上面有处理触摸按键相关的事件，在这里会进行按键事件的分发，走按键分发逻辑（notifyKey）    synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_DOWN, when, readTime, getDeviceId(),                         mSource, mViewport.displayId, policyFlags, mLastCookedState.buttonState,                         mCurrentCookedState.buttonState);    // Dispatch the touches either directly or by translation through a pointer on screen.    if (mDeviceMode == DeviceMode::POINTER) &#123;  //pointer光标        ...    &#125; else &#123;  //触摸 DeviceMode::DIRECT touchscreen        if (!mCurrentMotionAborted) &#123;            updateTouchSpots();  //更新触摸点相关            dispatchButtonRelease(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理            dispatchHoverExit(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理            dispatchTouches(when, readTime, policyFlags);  // 分发触摸事件，主要是这里            dispatchHoverEnterAndMove(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理            dispatchButtonPress(when, readTime, policyFlags);  //一般触摸不涉及，不进行任何处理        &#125;        if (mCurrentCookedState.cookedPointerData.pointerCount == 0) &#123;            mCurrentMotionAborted = false;        &#125;    &#125;    // Synthesize key up from raw buttons if needed.    synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_UP, when, readTime, getDeviceId(), mSource,                         mViewport.displayId, policyFlags, mLastCookedState.buttonState,                         mCurrentCookedState.buttonState);            // Clear some transient state.    mCurrentRawState.rawVScroll = 0;    mCurrentRawState.rawHScroll = 0;    // Copy current touch to last touch in preparation for the next cycle.    mLastRawState.copyFrom(mCurrentRawState);    mLastCookedState.copyFrom(mCurrentCookedState);&#125;</code></pre><h4 id="TouchInputMapper-cookPointerData"><a href="#TouchInputMapper-cookPointerData" class="headerlink" title="TouchInputMapper::cookPointerData"></a>TouchInputMapper::cookPointerData</h4><pre><code>void TouchInputMapper::cookPointerData() &#123;    uint32_t currentPointerCount = mCurrentRawState.rawPointerData.pointerCount;        mCurrentCookedState.cookedPointerData.clear();    mCurrentCookedState.cookedPointerData.pointerCount = currentPointerCount;    mCurrentCookedState.cookedPointerData.hoveringIdBits =            mCurrentRawState.rawPointerData.hoveringIdBits;    mCurrentCookedState.cookedPointerData.touchingIdBits =            mCurrentRawState.rawPointerData.touchingIdBits;    mCurrentCookedState.cookedPointerData.canceledIdBits =            mCurrentRawState.rawPointerData.canceledIdBits;    if (mCurrentCookedState.cookedPointerData.pointerCount == 0) &#123;        mCurrentCookedState.buttonState = 0;    &#125; else &#123;        mCurrentCookedState.buttonState = mCurrentRawState.buttonState;    &#125;    // Walk through the the active pointers and map device coordinates onto    // display coordinates and adjust for display orientation.    // 遍历活动指针并将设备坐标映射到显示坐标并调整显示方向。    // 并将相关的转化值写入mCurrentCookedState.cookedPointerData    for (uint32_t i = 0; i &lt; currentPointerCount; i++) &#123;        const RawPointerData::Pointer&amp; in = mCurrentRawState.rawPointerData.pointers[i];        // Size        // 长短轴大小校准        float touchMajor, touchMinor, toolMajor, toolMinor, size;        switch (mCalibration.sizeCalibration) &#123;            case Calibration::SizeCalibration::GEOMETRIC:  //几何类型            case Calibration::SizeCalibration::DIAMETER:  //直径类型            case Calibration::SizeCalibration::BOX:  // 方型？            case Calibration::SizeCalibration::AREA:  //面积类型？                if (mRawPointerAxes.touchMajor.valid &amp;&amp; mRawPointerAxes.toolMajor.valid) &#123;                    touchMajor = in.touchMajor;                    touchMinor = mRawPointerAxes.touchMinor.valid ? in.touchMinor : in.touchMajor;                    toolMajor = in.toolMajor;                    toolMinor = mRawPointerAxes.toolMinor.valid ? in.toolMinor : in.toolMajor;                    size = mRawPointerAxes.touchMinor.valid ? avg(in.touchMajor, in.touchMinor)                                                            : in.touchMajor;                &#125; else if (mRawPointerAxes.touchMajor.valid) &#123;                    toolMajor = touchMajor = in.touchMajor;                    toolMinor = touchMinor =                            mRawPointerAxes.touchMinor.valid ? in.touchMinor : in.touchMajor;                    size = mRawPointerAxes.touchMinor.valid ? avg(in.touchMajor, in.touchMinor)                                                            : in.touchMajor;                &#125; else if (mRawPointerAxes.toolMajor.valid) &#123;                    touchMajor = toolMajor = in.toolMajor;                    touchMinor = toolMinor =                            mRawPointerAxes.toolMinor.valid ? in.toolMinor : in.toolMajor;                    size = mRawPointerAxes.toolMinor.valid ? avg(in.toolMajor, in.toolMinor)                                                           : in.toolMajor;                &#125; else &#123;                    ...                &#125;                if (mCalibration.haveSizeIsSummed &amp;&amp; mCalibration.sizeIsSummed) &#123;                    uint32_t touchingCount = mCurrentRawState.rawPointerData.touchingIdBits.count();                    if (touchingCount &gt; 1) &#123;                        touchMajor /= touchingCount;                        touchMinor /= touchingCount;                        toolMajor /= touchingCount;                        toolMinor /= touchingCount;                        size /= touchingCount;                    &#125;                &#125;                if (mCalibration.sizeCalibration == Calibration::SizeCalibration::GEOMETRIC) &#123;                    touchMajor *= mGeometricScale;                    touchMinor *= mGeometricScale;                    toolMajor *= mGeometricScale;                    toolMinor *= mGeometricScale;                &#125; else if (mCalibration.sizeCalibration == Calibration::SizeCalibration::AREA) &#123;                    touchMajor = touchMajor &gt; 0 ? sqrtf(touchMajor) : 0;                    touchMinor = touchMajor;                    toolMajor = toolMajor &gt; 0 ? sqrtf(toolMajor) : 0;                    toolMinor = toolMajor;                &#125; else if (mCalibration.sizeCalibration == Calibration::SizeCalibration::DIAMETER) &#123;                    touchMinor = touchMajor;                    toolMinor = toolMajor;                &#125;                mCalibration.applySizeScaleAndBias(&amp;touchMajor);                mCalibration.applySizeScaleAndBias(&amp;touchMinor);                mCalibration.applySizeScaleAndBias(&amp;toolMajor);                mCalibration.applySizeScaleAndBias(&amp;toolMinor);                size *= mSizeScale;                break;            default:                touchMajor = 0;                touchMinor = 0;                toolMajor = 0;                toolMinor = 0;                size = 0;                break;        &#125;        // Pressure        //压感校准        float pressure;        switch (mCalibration.pressureCalibration) &#123;            case Calibration::PressureCalibration::PHYSICAL:            case Calibration::PressureCalibration::AMPLITUDE:                pressure = in.pressure * mPressureScale;                break;            default:                pressure = in.isHovering ? 0 : 1;                break;        &#125;        // Tilt and Orientation        //倾斜角度和方向        float tilt;        float orientation;        if (mHaveTilt) &#123;            float tiltXAngle = (in.tiltX - mTiltXCenter) * mTiltXScale;            float tiltYAngle = (in.tiltY - mTiltYCenter) * mTiltYScale;            orientation = atan2f(-sinf(tiltXAngle), sinf(tiltYAngle));            tilt = acosf(cosf(tiltXAngle) * cosf(tiltYAngle));        &#125; else &#123;            tilt = 0;            switch (mCalibration.orientationCalibration) &#123;                case Calibration::OrientationCalibration::INTERPOLATED:                    orientation = in.orientation * mOrientationScale;                    break;                case Calibration::OrientationCalibration::VECTOR: &#123;                    int32_t c1 = signExtendNybble((in.orientation &amp; 0xf0) &gt;&gt; 4);                    int32_t c2 = signExtendNybble(in.orientation &amp; 0x0f);                    if (c1 != 0 || c2 != 0) &#123;                        orientation = atan2f(c1, c2) * 0.5f;                        float confidence = hypotf(c1, c2);                        float scale = 1.0f + confidence / 16.0f;                        touchMajor *= scale;                        touchMinor /= scale;                        toolMajor *= scale;                        toolMinor /= scale;                    &#125; else &#123;                        orientation = 0;                    &#125;                    break;                &#125;                default:                    orientation = 0;            &#125;        &#125;        // Distance        //距离校准        float distance;        switch (mCalibration.distanceCalibration) &#123;            case Calibration::DistanceCalibration::SCALED:                distance = in.distance * mDistanceScale;                break;            default:                distance = 0;        &#125;        // Coverage        // 覆盖校准？        int32_t rawLeft, rawTop, rawRight, rawBottom;        switch (mCalibration.coverageCalibration) &#123;            case Calibration::CoverageCalibration::BOX:                rawLeft = (in.toolMinor &amp; 0xffff0000) &gt;&gt; 16;                rawRight = in.toolMinor &amp; 0x0000ffff;                rawBottom = in.toolMajor &amp; 0x0000ffff;                rawTop = (in.toolMajor &amp; 0xffff0000) &gt;&gt; 16;                break;            default:                rawLeft = rawTop = rawRight = rawBottom = 0;                break;        &#125;        // Adjust X,Y coords for device calibration        // TODO: Adjust coverage coords?        float xTransformed = in.x, yTransformed = in.y;        mAffineTransform.applyTo(xTransformed, yTransformed);        rotateAndScale(xTransformed, yTransformed);        // Adjust X, Y, and coverage coords for input device orientation.        float left, top, right, bottom;        // 转换触摸设备坐标到实际的屏幕方向上的坐标        switch (mInputDeviceOrientation) &#123;            case DISPLAY_ORIENTATION_90:                left = float(rawTop - mRawPointerAxes.y.minValue) * mYScale;                right = float(rawBottom - mRawPointerAxes.y.minValue) * mYScale;                bottom = float(mRawPointerAxes.x.maxValue - rawLeft) * mXScale;                top = float(mRawPointerAxes.x.maxValue - rawRight) * mXScale;                orientation -= M_PI_2;                if (mOrientedRanges.haveOrientation &amp;&amp;                    orientation &lt; mOrientedRanges.orientation.min) &#123;                    orientation +=                            (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min);                &#125;                break;            case DISPLAY_ORIENTATION_180:                left = float(mRawPointerAxes.x.maxValue - rawRight) * mXScale;                right = float(mRawPointerAxes.x.maxValue - rawLeft) * mXScale;                bottom = float(mRawPointerAxes.y.maxValue - rawTop) * mYScale;                top = float(mRawPointerAxes.y.maxValue - rawBottom) * mYScale;                orientation -= M_PI;                if (mOrientedRanges.haveOrientation &amp;&amp;                    orientation &lt; mOrientedRanges.orientation.min) &#123;                    orientation +=                            (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min);                &#125;                break;            case DISPLAY_ORIENTATION_270:                left = float(mRawPointerAxes.y.maxValue - rawBottom) * mYScale;                right = float(mRawPointerAxes.y.maxValue - rawTop) * mYScale;                bottom = float(rawRight - mRawPointerAxes.x.minValue) * mXScale;                top = float(rawLeft - mRawPointerAxes.x.minValue) * mXScale;                orientation += M_PI_2;                if (mOrientedRanges.haveOrientation &amp;&amp;                    orientation &gt; mOrientedRanges.orientation.max) &#123;                    orientation -=                            (mOrientedRanges.orientation.max - mOrientedRanges.orientation.min);                &#125;                break;            default:                left = float(rawLeft - mRawPointerAxes.x.minValue) * mXScale;                right = float(rawRight - mRawPointerAxes.x.minValue) * mXScale;                bottom = float(rawBottom - mRawPointerAxes.y.minValue) * mYScale;                top = float(rawTop - mRawPointerAxes.y.minValue) * mYScale;                break;        &#125;        // Write output coords.        PointerCoords&amp; out = mCurrentCookedState.cookedPointerData.pointerCoords[i];        out.clear();        out.setAxisValue(AMOTION_EVENT_AXIS_X, xTransformed);        out.setAxisValue(AMOTION_EVENT_AXIS_Y, yTransformed);        out.setAxisValue(AMOTION_EVENT_AXIS_PRESSURE, pressure);        out.setAxisValue(AMOTION_EVENT_AXIS_SIZE, size);        out.setAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR, touchMajor);        out.setAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR, touchMinor);        out.setAxisValue(AMOTION_EVENT_AXIS_ORIENTATION, orientation);        out.setAxisValue(AMOTION_EVENT_AXIS_TILT, tilt);        out.setAxisValue(AMOTION_EVENT_AXIS_DISTANCE, distance);        if (mCalibration.coverageCalibration == Calibration::CoverageCalibration::BOX) &#123;            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_1, left);            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_2, top);            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_3, right);            out.setAxisValue(AMOTION_EVENT_AXIS_GENERIC_4, bottom);        &#125; else &#123;            out.setAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR, toolMajor);            out.setAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR, toolMinor);        &#125;        // Write output relative fields if applicable.        uint32_t id = in.id;        if (mSource == AINPUT_SOURCE_TOUCHPAD &amp;&amp;            mLastCookedState.cookedPointerData.hasPointerCoordsForId(id)) &#123;            const PointerCoords&amp; p = mLastCookedState.cookedPointerData.pointerCoordsForId(id);            float dx = xTransformed - p.getAxisValue(AMOTION_EVENT_AXIS_X);            float dy = yTransformed - p.getAxisValue(AMOTION_EVENT_AXIS_Y);            out.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, dx);            out.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, dy);        &#125;        // Write output properties.        PointerProperties&amp; properties = mCurrentCookedState.cookedPointerData.pointerProperties[i];        properties.clear();        properties.id = id;        properties.toolType = in.toolType;        // Write id index and mark id as valid.        mCurrentCookedState.cookedPointerData.idToIndex[id] = i;        mCurrentCookedState.cookedPointerData.validIdBits.markBit(id);    &#125;&#125;</code></pre><h4 id="TouchInputMapper-dispatchTouches"><a href="#TouchInputMapper-dispatchTouches" class="headerlink" title="TouchInputMapper::dispatchTouches"></a>TouchInputMapper::dispatchTouches</h4><pre><code>void TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t readTime, uint32_t policyFlags) &#123;    BitSet32 currentIdBits = mCurrentCookedState.cookedPointerData.touchingIdBits;    BitSet32 lastIdBits = mLastCookedState.cookedPointerData.touchingIdBits;    int32_t metaState = getContext()-&gt;getGlobalMetaState();    int32_t buttonState = mCurrentCookedState.buttonState;            if (currentIdBits == lastIdBits) &#123;  //pointer id 没有改变        if (!currentIdBits.isEmpty()) &#123;            // No pointer id changes so this is a move event.            // The listener takes care of batching moves so we don&#39;t have to deal with that here.            // 如果pointer id 没有改变，说明是个move事件，这里不进行处理，直接分发到listener            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_MOVE, 0, 0,                           metaState, buttonState, AMOTION_EVENT_EDGE_FLAG_NONE,                           mCurrentCookedState.cookedPointerData.pointerProperties,                           mCurrentCookedState.cookedPointerData.pointerCoords,                           mCurrentCookedState.cookedPointerData.idToIndex, currentIdBits, -1,                           mOrientedXPrecision, mOrientedYPrecision, mDownTime);        &#125;    &#125; else &#123;        // There may be pointers going up and pointers going down and pointers moving        // all at the same time.        // 获取并更新四个方向pointers的值，判断本次是down、up、move的哪一种        BitSet32 upIdBits(lastIdBits.value &amp; ~currentIdBits.value);        BitSet32 downIdBits(currentIdBits.value &amp; ~lastIdBits.value);        BitSet32 moveIdBits(lastIdBits.value &amp; currentIdBits.value);        BitSet32 dispatchedIdBits(lastIdBits.value);  //用于记录上一次分发的事件        // Update last coordinates of pointers that have moved so that we observe the new        // pointer positions at the same time as other pointers that have just gone up.        //更新最后一个pointers的坐标        bool moveNeeded =                updateMovedPointers(mCurrentCookedState.cookedPointerData.pointerProperties,                                    mCurrentCookedState.cookedPointerData.pointerCoords,                                    mCurrentCookedState.cookedPointerData.idToIndex,                                    mLastCookedState.cookedPointerData.pointerProperties,                                    mLastCookedState.cookedPointerData.pointerCoords,                                    mLastCookedState.cookedPointerData.idToIndex, moveIdBits);        if (buttonState != mLastCookedState.buttonState) &#123;            moveNeeded = true;        &#125;        // Dispatch pointer up events.        //分发up事件        while (!upIdBits.isEmpty()) &#123;            uint32_t upId = upIdBits.clearFirstMarkedBit();  //这个id应该和downId相同（看上面的更新四个方向BitSet32可知）            bool isCanceled = mCurrentCookedState.cookedPointerData.canceledIdBits.hasBit(uplastIdBitsId);            if (isCanceled) &#123;                ALOGI(&quot;Canceling pointer %d for the palm event was detected.&quot;, upId);            &#125;            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_POINTER_UP, 0,                           isCanceled ? AMOTION_EVENT_FLAG_CANCELED : 0, metaState, buttonState, 0,                           mLastCookedState.cookedPointerData.pointerProperties,                           mLastCookedState.cookedPointerData.pointerCoords,                           mLastCookedState.cookedPointerData.idToIndex, dispatchedIdBits, upId,                           mOrientedXPrecision, mOrientedYPrecision, mDownTime);            dispatchedIdBits.clearBit(upId);  //up事件分发后，重置dispatchedIdBits            mCurrentCookedState.cookedPointerData.canceledIdBits.clearBit(upId);        &#125;        // Dispatch move events if any of the remaining pointers moved from their old locations.        // Although applications receive new locations as part of individual pointer up        // events, they do not generally handle them except when presented in a move event.        //分发move事件        if (moveNeeded &amp;&amp; !moveIdBits.isEmpty()) &#123;            ALOG_ASSERT(moveIdBits.value == dispatchedIdBits.value);            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_MOVE, 0, 0,                           metaState, buttonState, 0,                           mCurrentCookedState.cookedPointerData.pointerProperties,                           mCurrentCookedState.cookedPointerData.pointerCoords,                           mCurrentCookedState.cookedPointerData.idToIndex, dispatchedIdBits, -1,                           mOrientedXPrecision, mOrientedYPrecision, mDownTime);        &#125;        // Dispatch pointer down events using the new pointer locations.        //分发down事件        while (!downIdBits.isEmpty()) &#123;            uint32_t downId = downIdBits.clearFirstMarkedBit();            dispatchedIdBits.markBit(downId); //记录分发的down事件            if (dispatchedIdBits.count() == 1) &#123;                // First pointer is going down.  Set down time.                mDownTime = when;            &#125;            dispatchMotion(when, readTime, policyFlags, mSource, AMOTION_EVENT_ACTION_POINTER_DOWN,                           0, 0, metaState, buttonState, 0,                           mCurrentCookedState.cookedPointerData.pointerProperties,                           mCurrentCookedState.cookedPointerData.pointerCoords,                           mCurrentCookedState.cookedPointerData.idToIndex, dispatchedIdBits,                           downId, mOrientedXPrecision, mOrientedYPrecision, mDownTime);        &#125;    &#125;&#125;</code></pre><h4 id="TouchInputMapper-dispatchMotion"><a href="#TouchInputMapper-dispatchMotion" class="headerlink" title="TouchInputMapper::dispatchMotion"></a>TouchInputMapper::dispatchMotion</h4><pre><code>void TouchInputMapper::dispatchMotion(nsecs_t when, nsecs_t readTime, uint32_t policyFlags,                                      uint32_t source, int32_t action, int32_t actionButton,                                      int32_t flags, int32_t metaState, int32_t buttonState,                                      int32_t edgeFlags, const PointerProperties* properties,                                      const PointerCoords* coords, const uint32_t* idToIndex,                                      BitSet32 idBits, int32_t changedId, float xPrecision,                                      float yPrecision, nsecs_t downTime) &#123;    PointerCoords pointerCoords[MAX_POINTERS];    PointerProperties pointerProperties[MAX_POINTERS];    uint32_t pointerCount = 0;    while (!idBits.isEmpty()) &#123;        uint32_t id = idBits.clearFirstMarkedBit();        uint32_t index = idToIndex[id];        pointerProperties[pointerCount].copyFrom(properties[index]);        pointerCoords[pointerCount].copyFrom(coords[index]);        if (changedId &gt;= 0 &amp;&amp; id == uint32_t(changedId)) &#123;            action |= pointerCount &lt;&lt; AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;        &#125;        pointerCount += 1;    &#125;    ALOG_ASSERT(pointerCount != 0);    if (changedId &gt;= 0 &amp;&amp; pointerCount == 1) &#123;        // Replace initial down and final up action.        // We can compare the action without masking off the changed pointer index        // because we know the index is 0.        if (action == AMOTION_EVENT_ACTION_POINTER_DOWN) &#123;            action = AMOTION_EVENT_ACTION_DOWN;        &#125; else if (action == AMOTION_EVENT_ACTION_POINTER_UP) &#123;            if ((flags &amp; AMOTION_EVENT_FLAG_CANCELED) != 0) &#123;                action = AMOTION_EVENT_ACTION_CANCEL;            &#125; else &#123;                action = AMOTION_EVENT_ACTION_UP;            &#125;        &#125; else &#123;            // Can&#39;t happen.            ALOG_ASSERT(false);        &#125;    &#125;    float xCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION;    float yCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION;    if (mDeviceMode == DeviceMode::POINTER) &#123;  //是否是pointer模式，触摸是DIRECT模式，所以一般不设置这个        mPointerController-&gt;getPosition(&amp;xCursorPosition, &amp;yCursorPosition);    &#125;    //获取当前物理屏幕的id（有些设备有多个屏幕）    //获取displayId主要从DisplayViewport中，而DisplayViewport主要来自：    // 1. inputDevice中通过configure中指定。      // 2. WindowManagerService指定。      // 3.通过idc文件中的唯一id或显示类型获取匹配的Viewport    const int32_t displayId = getAssociatedDisplayId().value_or(ADISPLAY_ID_NONE);    const int32_t deviceId = getDeviceId();    std::vector&lt;TouchVideoFrame&gt; frames = getDeviceContext().getVideoFrames();  //有关视频触摸事件的，一般不是    std::for_each(frames.begin(), frames.end(),                  [this](TouchVideoFrame&amp; frame) &#123; frame.rotate(this-&gt;mInputDeviceOrientation); &#125;);    //创建NotifyMotionArgs对象    NotifyMotionArgs args(getContext()-&gt;getNextId(), when, readTime, deviceId, source, displayId,                          policyFlags, action, actionButton, flags, metaState, buttonState,                          MotionClassification::NONE, edgeFlags, pointerCount, pointerProperties,                          pointerCoords, xPrecision, yPrecision, xCursorPosition, yCursorPosition,                          downTime, std::move(frames));     // 调用mapper创建时关联的context持有的QueuedInputListener对象的notifyMotion     // 这里是getListener是UnwantedInteractionBlocker    getListener().notifyMotion(&amp;args);&#125;</code></pre><h4 id="QueuedInputListener-notifyMotion"><a href="#QueuedInputListener-notifyMotion" class="headerlink" title="QueuedInputListener::notifyMotion"></a>QueuedInputListener::notifyMotion</h4><pre><code>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;    ALOGD(&quot;hongxi.zhu: QueuedInputListener::notifyMotion() -&gt; mArgsQueue.emplace_back(NotifyMotionArgs)&quot;);    traceEvent(__func__, args-&gt;id);    mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args));&#125;</code></pre><p><code>QueuedInputListener::notifyMotion</code>只是将<code>NotifyMotionArgs</code>加入当前<code>listener</code>对象的<code>mArgsQueue</code>列表, 到这里我们<code>InputReader::processEventsLocked</code>方法就执行结束，回到<code>loopOnce()</code>中继续往下执行到<code>mQueuedListener.flush()</code>，开始事件的传递。</p><h3 id="二、mQueuedListener-flush-事件传递"><a href="#二、mQueuedListener-flush-事件传递" class="headerlink" title="二、mQueuedListener.flush()事件传递"></a>二、mQueuedListener.flush()事件传递</h3><p>接着上面，在<code>InputReader::loopOnce()</code>中往下执行到<code>mQueuedListener.flush()</code></p><h4 id="QueuedInputListener-flush"><a href="#QueuedInputListener-flush" class="headerlink" title="QueuedInputListener::flush()"></a>QueuedInputListener::flush()</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputListener.cpp</p><pre><code>void QueuedInputListener::flush() &#123;    for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123;        args-&gt;notify(mInnerListener);  //args这里是前面传进来的NotifyMotionArgs    &#125;    mArgsQueue.clear();&#125;</code></pre><h4 id="NotifyMotionArgs-notify"><a href="#NotifyMotionArgs-notify" class="headerlink" title="NotifyMotionArgs::notify"></a>NotifyMotionArgs::notify</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputListener.cpp</p><pre><code>void NotifyMotionArgs::notify(InputListenerInterface&amp; listener) const &#123;    listener.notifyMotion(this);&#125;</code></pre><p>这个<code>listener</code>是一个<code>InputListenerInterface</code>子类对象，到底是哪个呢？回顾下<code>InputManager</code>的构造方法，<br>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;InputManager.cpp</p><pre><code>InputManager::InputManager(        const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;    mDispatcher = createInputDispatcher(dispatcherPolicy);    mClassifier = std::make_unique&lt;InputClassifier&gt;(*mDispatcher);    mBlocker = std::make_unique&lt;UnwantedInteractionBlocker&gt;(*mClassifier);    mReader = createInputReader(readerPolicy, *mBlocker);&#125;</code></pre><p><code>mDispatcher</code>、<code>mClassifier</code>、<code>mBlocker</code>都是<code>InputListenerInterface</code>的子类，从构造方法的传参得出事件传递的过程：<br><code>InputReader-&gt;UnwantedInteractionBlocker-&gt;InputClassifier-&gt;InputDispatcher</code><br>结合类继承关系，可知上面<code>InputReader::loopOnce()</code>中的<code>mQueuedListener</code>是<code>UnwantedInteractionBlocker</code>，调用它的<code>flush</code>方法(这几个子类都没有实现<code>flush</code>方法，所以执行的是<code>QueuedInputListener</code>的<code>flush</code>方法)，<code>QueuedInputListener</code>中的<code>mInnerListener</code>是<code>UnwantedInteractionBlocker</code>，那么<code>listener.notifyMotion(this)</code>实际就是：<code>UnwantedInteractionBlocker::notifyMotion(NotifyMotionArgs)</code></p><h4 id="UnwantedInteractionBlocker-notifyMotion"><a href="#UnwantedInteractionBlocker-notifyMotion" class="headerlink" title="UnwantedInteractionBlocker::notifyMotion"></a>UnwantedInteractionBlocker::notifyMotion</h4><p>frameworks&#x2F;native&#x2F;services&#x2F;inputflinger&#x2F;UnwantedInteractionBlocker.cpp</p><pre><code>void UnwantedInteractionBlocker::notifyMotion(const NotifyMotionArgs* args) &#123;    &#123; // acquire lock        std::scoped_lock lock(mLock);        const std::vector&lt;NotifyMotionArgs&gt; processedArgs =                mPreferStylusOverTouchBlocker.processMotion(*args);        for (const NotifyMotionArgs&amp; loopArgs : processedArgs) &#123;            notifyMotionLocked(&amp;loopArgs);        &#125;    &#125; // release lock    // Call out to the next stage without holding the lock    mQueuedListener.flush();&#125;</code></pre><h4 id="UnwantedInteractionBlocker-notifyMotionLocked"><a href="#UnwantedInteractionBlocker-notifyMotionLocked" class="headerlink" title="UnwantedInteractionBlocker::notifyMotionLocked"></a>UnwantedInteractionBlocker::notifyMotionLocked</h4><pre><code>void UnwantedInteractionBlocker::notifyMotionLocked(const NotifyMotionArgs* args) &#123;    auto it = mPalmRejectors.find(args-&gt;deviceId);    const bool sendToPalmRejector = it != mPalmRejectors.end() &amp;&amp; isFromTouchscreen(args-&gt;source);    if (!sendToPalmRejector) &#123;  //如果不支持手掌误触处理，走这里，一般走这里        //调用UnwantedInteractionBlocker中持有的QueuedListener对象的notifyMotion        //mQueuedListener这里是        mQueuedListener.notifyMotion(args);  //一般走这里, 按照前面        return;    &#125;    //如果支持手掌误触    std::vector&lt;NotifyMotionArgs&gt; processedArgs = it-&gt;second.processMotion(*args);processedArgs.size());    for (const NotifyMotionArgs&amp; loopArgs : processedArgs) &#123;        mQueuedListener.notifyMotion(&amp;loopArgs);  //同理这里的mQueuedListener是InputClassifier    &#125;&#125;</code></pre><p>然后又是同样的走法<code>notifyMotion</code>-&gt;<code>flush</code>-&gt;<code>notifyMotion</code>, <code>mInnerListener</code>是<code>InputClassifier</code></p><h4 id="QueuedInputListener-notifyMotion-1"><a href="#QueuedInputListener-notifyMotion-1" class="headerlink" title="QueuedInputListener::notifyMotion"></a>QueuedInputListener::notifyMotion</h4><pre><code>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;    traceEvent(__func__, args-&gt;id);    mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args));&#125;void QueuedInputListener::flush() &#123;    for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123;           //args这里是前面传进来的NotifyMotionArgs，mInnerListener是InputClassifier        args-&gt;notify(mInnerListener);    &#125;    mArgsQueue.clear();&#125;void NotifyMotionArgs::notify(InputListenerInterface&amp; listener) const &#123;    listener.notifyMotion(this);&#125;</code></pre><h4 id="InputClassifier-notifyMotion"><a href="#InputClassifier-notifyMotion" class="headerlink" title="InputClassifier::notifyMotion"></a>InputClassifier::notifyMotion</h4><pre><code>void InputClassifier::notifyMotion(const NotifyMotionArgs* args) &#123;    &#123; // acquire lock        std::scoped_lock lock(mLock);        // MotionClassifier is only used for touch events, for now        const bool sendToMotionClassifier = mMotionClassifier &amp;&amp; isTouchEvent(*args);        if (!sendToMotionClassifier) &#123;  //目前模拟器走这里，真机不清楚            mQueuedListener.notifyMotion(args);        &#125; else &#123;            NotifyMotionArgs newArgs(*args);            newArgs.classification = mMotionClassifier-&gt;classify(newArgs);            mQueuedListener.notifyMotion(&amp;newArgs);        &#125;    &#125; // release lock    mQueuedListener.flush();&#125;</code></pre><p>然后又是同样的走法<code>notifyMotion</code>-&gt;<code>flush</code>-&gt;<code>notifyMotion</code>, <code>mInnerListener</code>是<code>InputDispatcher</code></p><h4 id="QueuedInputListener-notifyMotion-2"><a href="#QueuedInputListener-notifyMotion-2" class="headerlink" title="QueuedInputListener::notifyMotion"></a>QueuedInputListener::notifyMotion</h4><pre><code>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;    traceEvent(__func__, args-&gt;id);    mArgsQueue.emplace_back(std::make_unique&lt;NotifyMotionArgs&gt;(*args));&#125;void QueuedInputListener::flush() &#123;    for (const std::unique_ptr&lt;NotifyArgs&gt;&amp; args : mArgsQueue) &#123;           //args这里是前面传进来的NotifyMotionArgs，mInnerListener是InputClassifier        args-&gt;notify(mInnerListener);    &#125;    mArgsQueue.clear();&#125;</code></pre><h4 id="InputDispatcher-notifyMotion"><a href="#InputDispatcher-notifyMotion" class="headerlink" title="InputDispatcher::notifyMotion"></a>InputDispatcher::notifyMotion</h4><pre><code>void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) &#123;    ...    uint32_t policyFlags = args-&gt;policyFlags;    policyFlags |= POLICY_FLAG_TRUSTED;    android::base::Timer t;    //回调wms中的interceptMotionBeforeQueueingNonInteractive方法    mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;displayId, args-&gt;eventTime, /*byref*/ policyFlags);            bool needWake = false;    &#123; // acquire lock        mLock.lock();        ...        // Just enqueue a new motion event.        //创建一个MotionEntry对象，将NotifyMotionArgs转化为MotionEntry        std::unique_ptr&lt;MotionEntry&gt; newEntry =                std::make_unique&lt;MotionEntry&gt;(args-&gt;id, args-&gt;eventTime, args-&gt;deviceId,                                              args-&gt;source, args-&gt;displayId, policyFlags,                                              args-&gt;action, args-&gt;actionButton, args-&gt;flags,                                              args-&gt;metaState, args-&gt;buttonState,                                              args-&gt;classification, args-&gt;edgeFlags,                                              args-&gt;xPrecision, args-&gt;yPrecision,                                              args-&gt;xCursorPosition, args-&gt;yCursorPosition,                                              args-&gt;downTime, args-&gt;pointerCount,                                              args-&gt;pointerProperties, args-&gt;pointerCoords);        ...        //将MotionEntry加入InboundQueue        needWake = enqueueInboundEventLocked(std::move(newEntry));         mLock.unlock();    &#125; // release lock    if (needWake) &#123;        mLooper-&gt;wake();  //唤醒InputDispatcher线程，处理InboundQueue中的MotionEntry    &#125;&#125;</code></pre><h4 id="InputDispatcher-enqueueInboundEventLocked"><a href="#InputDispatcher-enqueueInboundEventLocked" class="headerlink" title="InputDispatcher::enqueueInboundEventLocked"></a>InputDispatcher::enqueueInboundEventLocked</h4><pre><code>bool InputDispatcher::enqueueInboundEventLocked(std::unique_ptr&lt;EventEntry&gt; newEntry) &#123;    bool needWake = mInboundQueue.empty();    mInboundQueue.push_back(std::move(newEntry));    EventEntry&amp; entry = *(mInboundQueue.back());    traceInboundQueueLengthLocked();    switch (entry.type) &#123;        case EventEntry::Type::KEY: &#123;              ...            break;        &#125;        case EventEntry::Type::MOTION: &#123;            LOG_ALWAYS_FATAL_IF((entry.policyFlags &amp; POLICY_FLAG_TRUSTED) == 0,                                &quot;Unexpected untrusted event.&quot;);            if (shouldPruneInboundQueueLocked(static_cast&lt;MotionEntry&amp;&gt;(entry))) &#123;                mNextUnblockedEvent = mInboundQueue.back();                needWake = true;            &#125;            break;            ...    &#125;    return needWake;&#125;</code></pre><p>   到此，InputReader线程就将事件传递到InputDispatcher线程，InputDispatcher线程被唤醒开始处理触摸事件，而InputReader线程继续循环执行loopOnce()方法，再次阻塞在getEvents方法中等待事件的上报。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;####回顾&lt;/p&gt;
&lt;p&gt;从前面的InputFlinger的启动可知，InputReader线程启动后会循环执行loopOnce()方法，然后阻塞在&lt;code&gt;getEvents&lt;/code&gt;等待事件的上报，这里就从loopOnce获取到事件被唤醒后来分析InputRea</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    <category term="InPutManagerService" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/InPutManagerService/"/>
    
    
  </entry>
  
  <entry>
    <title>ASFP (Android Studio for Platform)使用</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/ASFP%20(android%20studio%20for%20platform)%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-01T02:21:11.389Z</published>
    <updated>2023-12-01T06:45:18.634Z</updated>
    
    <content type="html"><![CDATA[<p> Android Studio for Platform 这个是最新的google开发的阅读aosp源码的工具，特别适合做原生系统开发。具体官方介绍如下地址：<br>参考链接：<a href="https://developer.android.google.cn/studio/platform">https://developer.android.google.cn/studio/platform</a></p><h3 id="1、android-studio-for-platform工具介绍"><a href="#1、android-studio-for-platform工具介绍" class="headerlink" title="1、android studio for platform工具介绍"></a>1、android studio for platform工具介绍</h3><p><img src="/../../images/6661ce941ec8464c8f324f785d8b16c3.png" alt="在这里插入图片描述"><br>可以直接点击下载（提示目前只有ubuntu可以哈，语言切换到英文，中文发现无法下载)</p><p>看看相关的官方介绍：</p><p>Android Studio for Platform (ASfP) is the version of the Android Studio IDE for Android Open Source Project (AOSP) platform developers who build with the Soong build system. ASfP includes the following features:</p><pre><code>languageMulti-language SupportEdit C++, Kotlin, and Java programming languages in the same IDE.settingsProject Setup WizardConfigure your lunch target and platform modules.</code></pre><p>官方的介绍就以上一小段文字，总结如下：<br>ASfP是专门用于开发aosp的ide工具，有着 Soong build system.，主要有以下几个特点<br>语言支持部分：<br>同时支持：C++, Kotlin, and Java 同时使用在ide中编程<br>设置部分：<br>可以配置你的编译target和具体的模块</p><h3 id="2、android-studio-for-platform痛点解决"><a href="#2、android-studio-for-platform痛点解决" class="headerlink" title="2、android studio for platform痛点解决"></a>2、android studio for platform痛点解决</h3><p>这里最吸引我们的还是他居然支持多语言，c++，java，kotlin同时都支持。<br>以前我们开发aosp时候，其实java部分使用android studio的体验还是相当好，但是android studio没办法支持c++等native代码的跳转和代码提示，所以不得不使用vscode工具，这个vscode工具相关看c++等代码也是比较方便，基本上的代码也是可以跳转的，但是毕竟有时候需要两个工具相互切快捷键等还是有一点点不方便，虽然不太影响。</p><p>所以开发aosp之前的选择就是：<br>java相关代码使用android studio<br>c++相关代码使用vscode</p><p>目前ASfP工具出现真的是我们framework开发者的一个巨大福音，解决了android studio无法跳转c++代码的这个巨大痛点。</p><h3 id="3、android-studio-for-platform使用体验"><a href="#3、android-studio-for-platform使用体验" class="headerlink" title="3、android studio for platform使用体验"></a>3、android studio for platform使用体验</h3><p>官方使用介绍：</p><p>​    </p><pre><code>Get started with ASfP    If you haven&#39;t already installed repo, follow the instructions at Installing Repo.    If you haven&#39;t already initialized and synced your Repo checkout, follow the instructions at Initializing a Repo client.    Download ASfP.    Install ASfP: sudo dpkg -i /path/to/asfp-2023.1.1.19-linux.deb.    Open ASfP from the command line: /opt/android-studio-for-platform/bin/studio.sh.    Import your project by pointing to your repo checkout directory, specifying a lunch target, and selecting which modules you want to build.    Click Finish and your project will begin syncing.    Request to join our external group for user support.</code></pre><p>​<br>​    </p><p>这里我们就直接自己转化把<br>1、下载好工具，安装好即可以（限制在ubuntu）<br><img src="/../../images/b20e0607028843e986a19dcae913e668.png" alt="在这里插入图片描述"><br><img src="/../../images/7fa95deacf934894baf36342705913fd.png" alt="在这里插入图片描述"><br>可以直接点击安装的</p><p>2、启动工具<br>在terminator下面输入如下命令：<br>&#x2F;opt&#x2F;android-studio-for-platform&#x2F;bin&#x2F;studio.sh<br>就会启动工具</p><p>3、导入需要模块<br><img src="/../../images/8539626963a04c35bea4bcb88c11561b.png" alt="导入AOSP选项"><br>这里导入了Launcher和framework<br><img src="/../../images/5cf8b014d4a04e3fa98f5a8605a97db3.png" alt="在这里插入图片描述"><br><img src="/../../images/6eae4bc3e37a4d40a56e2b68fe5d7d5b.png" alt="在这里插入图片描述"></p><p>同步完成就一切都好了即可以查看相关代码和跳转。</p><h3 id="ps使用的注意点："><a href="#ps使用的注意点：" class="headerlink" title="ps使用的注意点："></a>ps使用的注意点：</h3><p>1、跳转framework的类时候会跳到对应jar包的class文件，不是java文件，解决如下<br><img src="/../../images/cf63f456bca348f291be71bfa3c7466b.png" alt="在这里插入图片描述"></p><p>2、KeyMap如果习惯eclipse的可以切换</p><p>3、如果导入c++相关开发建议以下3个文件夹：<br>frameworks<br>system<br>packages</p><p>导入越多整体就慢</p><h3 id="总结体验："><a href="#总结体验：" class="headerlink" title="总结体验："></a>总结体验：</h3><p>整体体验和以前android studio没有大的差别<br>1、不过说实话单独java部分的代码开发的话，体验还不如以前的android studio轻量，反而依赖的东西太多，对于跳转等，查找代码还没有以前方便，针对java部分的话，这个建议可以先观望等更多版本更新稳定</p><p>2、c++部分的native代码，来说简直就利器，非常好用，跳转准确，非常值的推荐</p><p>google官方教学视频教程地址：<br><a href="https://www.bilibili.com/video/BV1UV411P7nf/?vd_source=a8c604ee3ce4999324264828f8fd99d8">https://www.bilibili.com/video/BV1UV411P7nf/?vd_source&#x3D;a8c604ee3ce4999324264828f8fd99d8</a></p><p><strong>生成桌面图标</strong></p><img src="../../images/e5702cee47164cd5818f3f5e164c5005.png" alt="生成桌面图标" style="zoom:67%;" /><p><strong>修改配置文件</strong></p><img src="../../images/8daa5801b6d8469b9281a30b655801ff.png" alt="修改配置文件后进行sync" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; Android Studio for Platform 这个是最新的google开发的阅读aosp源码的工具，特别适合做原生系统开发。具体官方介绍如下地址：&lt;br&gt;参考链接：&lt;a href=&quot;https://developer.android.google.cn/stud</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    
  </entry>
  
  <entry>
    <title>5.android13启动流程之SystemServer内部逻辑分析.md</title>
    <link href="https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/"/>
    <id>https://cq_tyl.gitee.io/wiki/Android%20FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%2013/5.Android13%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BSystemServer%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/</id>
    <published>2023-11-29T09:21:42.354Z</published>
    <updated>2024-02-29T03:57:13.032Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要分析一下SystemServer启动过后的内部逻辑，特别说明一下<a href="https://so.csdn.net/so/search?q=AMS&spm=1001.2101.3001.7020">AMS</a>,WMS都属于SystemServer进程，属于同一个进程</p></blockquote><h2 id="一-SystemServer进程启动流程"><a href="#一-SystemServer进程启动流程" class="headerlink" title="一. SystemServer进程启动流程"></a>一. SystemServer进程启动流程</h2><p><a href="https://blog.csdn.net/q1210249579/article/details/128782204">基于Android13的系统启动流程分析（五）之Zygote和SystemServer启动流程</a>这篇文章有详细讲解，这里再简单的过一下如何启动的SystemServer</p><p>在zygote进程创建过后，会调用<code>forkSystemServer()</code>来孵化出SystemServer进程，当前该进程创建成功后会反射调用到SystemServer.java的main函数，从而启动完成SystemServer</p><h2 id="二-SystemServer主函数分析"><a href="#二-SystemServer主函数分析" class="headerlink" title="二. SystemServer主函数分析"></a>二. SystemServer主函数分析</h2><p>main函数会被ZygoteInit的子方法<code>handleSystemServerProcess</code>反射调用到<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</p><pre><code>public static void main(String[] args) &#123;        new SystemServer().run();&#125;</code></pre><p>继续看看run方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">           <span class="comment">// 设置系统语言，国家，时区相关</span></span><br><span class="line">           <span class="keyword">if</span> (!SystemProperties.<span class="built_in">get</span>(<span class="string">&quot;persist.sys.language&quot;</span>).<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">               <span class="keyword">final</span> String languageTag = Locale.<span class="built_in">getDefault</span>().<span class="built_in">toLanguageTag</span>();</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.locale&quot;</span>, languageTag);</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.language&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.country&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;persist.sys.localevar&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">...</span><br><span class="line">           <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">           <span class="comment">// 设置main线程的优先级，有此可得主线程就是：SystemServer进程下的其中线程</span></span><br><span class="line">           android.os.Process.<span class="built_in">setThreadPriority</span>(</span><br><span class="line">                   android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">           android.os.Process.<span class="built_in">setCanSelfBackground</span>(<span class="literal">false</span>);</span><br><span class="line">           <span class="comment">// 开始主线程的运行，和Looper.loop配对使用</span></span><br><span class="line">           <span class="comment">// 运行在 Looper.prepareMainLooper()～Looper.loop()</span></span><br><span class="line">           <span class="comment">// 之间的就是运行在主线程中</span></span><br><span class="line">           Looper.<span class="built_in">prepareMainLooper</span>();</span><br><span class="line">           Looper.<span class="built_in">getMainLooper</span>().<span class="built_in">setSlowLogThresholdMs</span>(</span><br><span class="line">                   SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">// 初始化native services,加载android_servers库（libandroid_servers.so）</span></span><br><span class="line">           System.<span class="built_in">loadLibrary</span>(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">...</span><br><span class="line">           <span class="comment">// 通过ActivityThread来创建system上下文</span></span><br><span class="line">           <span class="built_in">createSystemContext</span>();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">           <span class="comment">// 初始化ActivityThread</span></span><br><span class="line">           <span class="comment">// 创建TelephonyServiceManager，StatsServiceManager，MediaServiceManager</span></span><br><span class="line">           ActivityThread.<span class="built_in">initializeMainlineModules</span>();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将SystemServer加入ServiceManager（binder线程池）</span></span><br><span class="line">           <span class="comment">// 每个继承自SystemServer 或属于SystemServer进程的服务都将加入到</span></span><br><span class="line">           <span class="comment">// ServiceManager中的线程池中</span></span><br><span class="line">           ServiceManager.<span class="built_in">addService</span>(<span class="string">&quot;system_server_dumper&quot;</span>, mDumper);</span><br><span class="line">           mDumper.<span class="built_in">addDumpable</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 每个server基本上对应了一个manager,对外提供的API也是只能获取到manager</span></span><br><span class="line">           <span class="comment">// 创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理，启动系统的各种服务</span></span><br><span class="line">           mSystemServiceManager = <span class="keyword">new</span> <span class="built_in">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">           mSystemServiceManager.<span class="built_in">setStartInfo</span>(mRuntimeRestart,</span><br><span class="line">                   mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">           mDumper.<span class="built_in">addDumpable</span>(mSystemServiceManager);</span><br><span class="line">           <span class="comment">// LocalServices是system_server进程中各个服务提供的本地服务</span></span><br><span class="line">           <span class="comment">// system_server进程中每个服务都可以往LocalServices放对象</span></span><br><span class="line">           <span class="comment">// 有些核心服务是继承自SystemServer,LocalServices是公开缓存池目的是：解耦</span></span><br><span class="line">           LocalServices.<span class="built_in">addService</span>(SystemServiceManager.<span class="keyword">class</span>, mSystemServiceManager);</span><br><span class="line">           ...</span><br><span class="line">       <span class="comment">// Start services.</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">           <span class="comment">// 启动系统启动所需的一系列关键服务：AMS,P(power/package)MS,SensorService,DisplayManagerService,LightService等</span></span><br><span class="line">           <span class="built_in">startBootstrapServices</span>(t);</span><br><span class="line">           <span class="comment">// 启动核心服务：BatteryService，GpuService等</span></span><br><span class="line">           <span class="built_in">startCoreServices</span>(t);</span><br><span class="line">           <span class="comment">// 启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等</span></span><br><span class="line">           <span class="built_in">startOtherServices</span>(t);</span><br><span class="line">           <span class="comment">// 以上的所有服务都由mSystemServiceManager来启动，所以都是继承自SystemServer</span></span><br><span class="line">           <span class="comment">// 分别是引导服务、核心服务和其他服务</span></span><br><span class="line">           <span class="comment">// [引导服务]</span></span><br><span class="line">           <span class="comment">// Installer 系统安装apk时的一个服务类，启动完成Installer服务之后才能启动其他的系统服务</span></span><br><span class="line">           <span class="comment">//ActivityManagerService 负责四大组件的启动、切换、调度。</span></span><br><span class="line">           <span class="comment">//PowerManagerService 计算系统中和Power相关的计算，然后决策系统应该如何反应</span></span><br><span class="line">           <span class="comment">//LightsService 管理和显示背光LED</span></span><br><span class="line">           <span class="comment">//DisplayManagerService 用来管理所有显示设备</span></span><br><span class="line">           <span class="comment">//UserManagerService 多用户模式管理</span></span><br><span class="line">           <span class="comment">//SensorService 为系统提供各种感应器服务</span></span><br><span class="line">           <span class="comment">//PackageManagerService 用来对apk进行安装、解析、删除、卸载等等操作</span></span><br><span class="line">           <span class="comment">// [核心服务]</span></span><br><span class="line">           <span class="comment">//BatteryService 管理电池相关的服务</span></span><br><span class="line">           <span class="comment">//UsageStatsService 收集用户使用每一个APP的频率、使用时常</span></span><br><span class="line">           <span class="comment">//WebViewUpdateService WebView更新服务</span></span><br><span class="line">           <span class="comment">// [其他服务]</span></span><br><span class="line">           <span class="comment">//CameraService 摄像头相关服务</span></span><br><span class="line">           <span class="comment">//AlarmManagerService 全局定时器管理服务</span></span><br><span class="line">           <span class="comment">//InputManagerService 管理输入事件</span></span><br><span class="line">           <span class="comment">//WindowManagerService 窗口管理服务</span></span><br><span class="line">           <span class="comment">//VrManagerService VR模式管理服务</span></span><br><span class="line">           <span class="comment">//BluetoothService 蓝牙管理服务</span></span><br><span class="line">           <span class="comment">//NotificationManagerService 通知管理服务</span></span><br><span class="line">           <span class="comment">//DeviceStorageMonitorService 存储相关管理服务</span></span><br><span class="line">           <span class="comment">//LocationManagerService 定位管理服务</span></span><br><span class="line">           <span class="comment">//AudioService 音频相关管理服务</span></span><br><span class="line">       &#125; <span class="built_in">catch</span> (Throwable ex) &#123;</span><br><span class="line">          ...</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">      ...</span><br><span class="line">       Looper.<span class="built_in">loop</span>();<span class="comment">// 主线程</span></span><br><span class="line">       <span class="comment">// 若执行到这里说明主线程意外退出了</span></span><br><span class="line">       <span class="comment">// 主线程：Looper.prepareMainlooper~ Looper.loop之间</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上方法可以看出来关于其他服务的启动都是运行在主线程中的Looper.prepareMainlooper~ Looper.loop之间，每个SystemServer中的服务都有一个<a href="https://so.csdn.net/so/search?q=binder&spm=1001.2101.3001.7020">binder</a>,会加入到ServiceManager的binder线程池中统一管理，这样拿到全局的ServiceManager,根据AIDL 获取到每Service了</p><ul><li>startBootstrapServices(t)<br>启动系统启动所需的一系列关键服务：<br>AMS,P(power&#x2F;package)MS,SensorService,DisplayManagerService,LightService等</li><li>startCoreServices(t)<br>启动核心服务：BatteryService，GpuService等</li><li>startOtherServices(t)<br>启动其他服务：VibratorManagerService，闹钟服务，相机服务，网络服务，输入法服务，存储服务等</li></ul><blockquote><p>在这些启动的服务里（调用了onStart启动服务），都会将服务存入ServiceManager 用来管理系统中的各种Service，用于系统C&#x2F;S架构中的Binder机制通信：Client端要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通讯通路，这样Client端就可以使用Service了</p></blockquote><p><img src="/../../../../images/image-20231129172417054.png" alt="image-20231129172417054"></p><p><img src="/../../../../images/image-20231129172431908.png" alt="image-20231129172431908"></p><h4 id="1-startBootstrapServices"><a href="#1-startBootstrapServices" class="headerlink" title="1. startBootstrapServices"></a>1. startBootstrapServices</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">startBootstrapServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 尽早启动看门狗，以便在早期启动过程中出现死锁时使系统服务器崩溃</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartWatchdog&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动看门狗，看门狗需要定时喂狗，若喂狗超时则会触发重启，以便知道进程和服务是否正常运行</span></span><br><span class="line">      <span class="keyword">final</span> Watchdog watchdog = Watchdog.<span class="built_in">getInstance</span>();</span><br><span class="line">      watchdog.<span class="built_in">start</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartInstaller&quot;</span>);</span><br><span class="line">      <span class="comment">// 通过mSystemServiceManager来启动Installer服务,管理应用的安装与卸载</span></span><br><span class="line">      Installer installer = mSystemServiceManager.<span class="built_in">startService</span>(Installer.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 通过mSystemServiceManager来启动UriGrantsManagerService，管理Uri</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;UriGrantsManagerService&quot;</span>);</span><br><span class="line">mSystemServiceManager.<span class="built_in">startService</span>(UriGrantsManagerService.Lifecycle.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过mSystemServiceManager来启动PowerStatsService，管理电源状态</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartPowerStatsService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(PowerStatsService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">...</span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">      <span class="comment">// 通过mSystemServiceManager来启动ActivityTaskManagerService，管理Activity任务栈</span></span><br><span class="line">      ActivityTaskManagerService atm = mSystemServiceManager.<span class="built_in">startService</span>(</span><br><span class="line">              ActivityTaskManagerService.Lifecycle.<span class="keyword">class</span>).<span class="built_in">getService</span>();</span><br><span class="line">      <span class="comment">// 启动ActivityManagerService,管理Activity等</span></span><br><span class="line">      mActivityManagerService = ActivityManagerService.Lifecycle.<span class="built_in">startService</span>(</span><br><span class="line">              mSystemServiceManager, atm);</span><br><span class="line">      <span class="comment">// 让ActivityManagerService拿到systemServer,例如可以通过mSystemServiceManager来判断系统是否启动完成</span></span><br><span class="line">      mActivityManagerService.<span class="built_in">setSystemServiceManager</span>(mSystemServiceManager);</span><br><span class="line">      mActivityManagerService.<span class="built_in">setInstaller</span>(installer);</span><br><span class="line">      mWindowManagerGlobalLock = atm.<span class="built_in">getGlobalLock</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// 启用PowerManagerService服务，电源管理服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartPowerManager&quot;</span>);</span><br><span class="line">      mPowerManagerService = mSystemServiceManager.<span class="built_in">startService</span>(PowerManagerService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 启动屏幕亮度服务，比如亮度调整</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartLightsService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(LightsService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动屏幕显示服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartDisplayManager&quot;</span>);</span><br><span class="line">      mDisplayManagerService = mSystemServiceManager.<span class="built_in">startService</span>(DisplayManagerService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">          <span class="comment">// 启动PMS,包管理服务</span></span><br><span class="line">          mPackageManagerService = PackageManagerService.<span class="built_in">main</span>(mSystemContext, installer,</span><br><span class="line">                  domainVerificationService, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF,</span><br><span class="line">                  mOnlyCore);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          Watchdog.<span class="built_in">getInstance</span>().<span class="built_in">resumeWatchingCurrentThread</span>(<span class="string">&quot;packagemanagermain&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">       <span class="comment">// 启动传感器服务</span></span><br><span class="line">      t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartSensorService&quot;</span>);</span><br><span class="line">      mSystemServiceManager.<span class="built_in">startService</span>(SensorService.<span class="keyword">class</span>);</span><br><span class="line">      t.<span class="built_in">traceEnd</span>();</span><br><span class="line">      t.<span class="built_in">traceEnd</span>(); <span class="comment">// startBootstrapServices</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到大多数服务都是通过<code>mSystemServiceManager.startService</code>来启动，核心服务和其他服务都是一样的，就不过多分析了<br>可以先看看startService方法内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> String name = serviceClass.<span class="built_in">getName</span>();</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">final</span> T service;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 反射拿到该java类</span></span><br><span class="line">               Constructor&lt;T&gt; constructor = serviceClass.<span class="built_in">getConstructor</span>(Context.<span class="keyword">class</span>);</span><br><span class="line">               service = constructor.<span class="built_in">newInstance</span>(mContext);</span><br><span class="line">           &#125; ...</span><br><span class="line">           <span class="comment">// 将当前服务（java类）加入SystemService服务队列中，统一管理</span></span><br><span class="line">           <span class="built_in">startService</span>(service);</span><br><span class="line">           <span class="keyword">return</span> service;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Trace.<span class="built_in">traceEnd</span>(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将当前服务加入mServices队列中</span></span><br><span class="line">       mServices.<span class="built_in">add</span>(service);</span><br><span class="line">       <span class="comment">// Start it.</span></span><br><span class="line">       <span class="type">long</span> time = SystemClock.<span class="built_in">elapsedRealtime</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 调用当前服务的onStart来启动服务</span></span><br><span class="line">           service.<span class="built_in">onStart</span>();</span><br><span class="line">       &#125; <span class="built_in">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">warnIfTooLong</span>(SystemClock.<span class="built_in">elapsedRealtime</span>() - time, service, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到startService方法就是反射拿到服务类，然后加入队列中，调用其onStart方法进行启动</p><h4 id="2-ServiceManager服务管理"><a href="#2-ServiceManager服务管理" class="headerlink" title="2. ServiceManager服务管理"></a>2. ServiceManager服务管理</h4><p>每个属于SystemServer的服务都将加入到ServiceManager的binder线程池中，以供后续直接获取和管理<br>就拿BatteryService服务来讲解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.<span class="built_in">startService</span>(BatteryService.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><p>已知startService后会调用BatteryService服务的onStart方法，继续看看onStart内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">Override</span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="type">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">       mBinderService = <span class="keyword">new</span> <span class="built_in">BinderService</span>();</span><br><span class="line">       <span class="comment">// 将BinderService服务加入ServiceManager中</span></span><br><span class="line">       <span class="built_in">publishBinderService</span>(<span class="string">&quot;battery&quot;</span>, mBinderService);</span><br><span class="line">       mBatteryPropertiesRegistrar = <span class="keyword">new</span> <span class="built_in">BatteryPropertiesRegistrar</span>();</span><br><span class="line">       <span class="comment">// 将batteryproperties服务加入ServiceManager中</span></span><br><span class="line">       <span class="built_in">publishBinderService</span>(<span class="string">&quot;batteryproperties&quot;</span>, mBatteryPropertiesRegistrar);</span><br><span class="line">       <span class="comment">// 将BinderService服务加入到LocalServices中</span></span><br><span class="line">       <span class="built_in">publishLocalService</span>(BatteryManagerInternal.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="built_in">LocalService</span>());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>继续看看<code>mBinderService</code>具体是什么，又是如何加入到ServiceManager中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BinderService</span> extends Binder &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>mBinderService</code>就是一个Binder,然后调用<code>publishBinderService</code>加入到ServiceManager中的binder线程池中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">void</span> <span class="title">publishBinderService</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ServiceManager.<span class="built_in">addService</span>(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用<code>ServiceManager.addService</code>加入到binder线程池中（ServiceManager暂不深究，只知其内部维护了binder线程池），而ServiceManager服务早就在rc文件中作为核心服务启动了，所以具体实现都是c++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">core</span> animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart apexd</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart class_restart main</span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>其实SystemServer是通过init fork出来的，父进程就是zygote,而zygote父进程就是init进程。<br>SystemServer内部逻辑主要就是创建了核心服务，引导服务，其他服务，例如<a href="https://so.csdn.net/so/search?q=WMS&spm=1001.2101.3001.7020">WMS</a>,PMS,电池服务，蓝牙服务等。这些服务都不是单独的进程，而是都属于SystemServer进程，启动这些服务过后会将这些服务加入ServiceManager的binder线程池中，因为这些服务内部都创建了Binder实例，再加入到了ServiceManager的binder线程池中，以便与随时获取服务与只通信</p><p>参考文章：<a href="http://liuwangshu.cn/framework/booting/3-syetemserver.html">Android系统启动流程（三）解析SyetemServer进程启动过程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;主要分析一下SystemServer启动过后的内部逻辑，特别说明一下&lt;a href=&quot;https://so.csdn.net/so/search?q=AMS&amp;spm=1001.2101.3001.7020&quot;&gt;AMS&lt;/a&gt;,WMS都属于System</summary>
      
    
    
    
    <category term="Android FrameWork" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/"/>
    
    <category term="Framework源码分析" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Android 13" scheme="https://cq_tyl.gitee.io/categories/Android-FrameWork/Framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android-13/"/>
    
    
  </entry>
  
</feed>
